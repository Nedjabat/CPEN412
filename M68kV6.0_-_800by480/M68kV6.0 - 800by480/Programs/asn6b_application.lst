680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 13 Apr 2023      Time: 11:24:21          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\ASN6B_APPLICATION.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0000 0C06   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0000 0AFA   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  0000      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  1CEE      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  00C0      
                     116              ;
0000041A  23FC 0000  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  6D30 0800 
00000422  00CC      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  1CEE 0800 
0000042C  00D0      
0000042E  4EB9 0000  119              jsr         _main							; now call main() from our C program (yeah!!!!)
00000432  0698      
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  0064      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  0068      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  006C      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  0070      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  0074      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  0078      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  007C      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  0080      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  0084      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  0088      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  008C      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  0090      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  0094      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  0098      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  009C      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  00A0      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  00A4      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  00A8      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  00AC      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  00B0      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  00B4      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  00B8      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  00BC      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  0008      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  000C      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  0010      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  0014      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  0018      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  001C      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  0020      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  0024      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  0028      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  002C      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   ; C:\IDE68K\UCOSII\ASN6B_APPLICATION.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     352   ; /*
                     353   ; * EXAMPLE_1.C
                     354   ; *
                     355   ; * This is a minimal program to verify multitasking.
                     356   ; *
                     357   ; */
                     358   ; #include <stdio.h>
                     359   ; #include "Bios.h"
                     360   ; #include "ucos_ii.h"
                     361   ; #include "Canbus-Controller.h"
                     362   ; #define STACKSIZE 256
                     363   ; /*
                     364   ; ** Stacks for each task are allocated here in the application in this case = 256 bytes
                     365   ; ** but you can change size if required
                     366   ; */
                     367   ; OS_STK Task1Stk[STACKSIZE];
                     368   ; OS_STK Task2Stk[STACKSIZE];
                     369   ; OS_STK Task3Stk[STACKSIZE];
                     370   ; OS_STK Task4Stk[STACKSIZE];
                     371   ; OS_STK Task5Stk[STACKSIZE];
                     372   ; OS_STK Task6Stk[STACKSIZE];
                     373   ; /* Prototypes for our tasks/threads*/
                     374   ; void Task1(void *); /* (void *) means the child task expects no data from parent*/
                     375   ; void Task2(void *);
                     376   ; void Task3(void *);
                     377   ; void Task4(void *);
                     378   ; void Task5(void *);
                     379   ; void Task6(void *);
                     380   ; /*
                     381   ; ** Our main application which has to
                     382   ; ** 1) Initialise any peripherals on the board, e.g. RS232 for hyperterminal + LCD
                     383   ; ** 2) Call OSInit() to initialise the OS
                     384   ; ** 3) Create our application task/threads
                     385   ; ** 4) Call OSStart()
                     386   ; */
                     387   ; void main(void)
                     388   ; {
                     389   _main:
00000698  2F0A       390          move.l    A2,-(A7)
0000069A  45F9 0000  391          lea       _OSTaskCreate.L,A2
0000069E  48BE      
                     392   ; // initialise board hardware by calling our routines from the BIOS.C source file
                     393   ; Init_RS232();
000006A0  4EB9 0000  394          jsr       _Init_RS232
000006A4  5E64      
                     395   ; Init_LCD();
000006A6  4EB9 0000  396          jsr       _Init_LCD
000006AA  5F1C      
                     397   ; /* display welcome message on LCD display */
                     398   ; Oline0("Altera DE1/68K");
000006AC  4879 0000  399          pea       @asn6b_~1_1.L
000006B0  6A62      
000006B2  4EB9 0000  400          jsr       _Oline0
000006B6  5F92      
000006B8  584F       401          addq.w    #4,A7
                     402   ; Oline1("Micrium uC/OS-II RTOS");
000006BA  4879 0000  403          pea       @asn6b_~1_2.L
000006BE  6A72      
000006C0  4EB9 0000  404          jsr       _Oline1
000006C4  5FC0      
000006C6  584F       405          addq.w    #4,A7
                     406   ; OSInit(); // call to initialise the OS
000006C8  4EB9 0000  407          jsr       _OSInit
000006CC  1186      
                     408   ; /*
                     409   ; ** Now create the 4 child tasks and pass them no data.
                     410   ; ** the smaller the numerical priority value, the higher the task priority
                     411   ; */
                     412   ; OSTaskCreate(Task1, OS_NULL, &Task1Stk[STACKSIZE], 12);
000006CE  4878 000C  413          pea       12
000006D2  41F9 0800  414          lea       _Task1Stk.L,A0
000006D6  00D4      
000006D8  D0FC 0200  415          add.w     #512,A0
000006DC  2F08       416          move.l    A0,-(A7)
000006DE  42A7       417          clr.l     -(A7)
000006E0  4879 0000  418          pea       _Task1.L
000006E4  078C      
000006E6  4E92       419          jsr       (A2)
000006E8  DEFC 0010  420          add.w     #16,A7
                     421   ; OSTaskCreate(Task2, OS_NULL, &Task2Stk[STACKSIZE], 11); // highest priority task
000006EC  4878 000B  422          pea       11
000006F0  41F9 0800  423          lea       _Task2Stk.L,A0
000006F4  02D4      
000006F6  D0FC 0200  424          add.w     #512,A0
000006FA  2F08       425          move.l    A0,-(A7)
000006FC  42A7       426          clr.l     -(A7)
000006FE  4879 0000  427          pea       _Task2.L
00000702  07BC      
00000704  4E92       428          jsr       (A2)
00000706  DEFC 0010  429          add.w     #16,A7
                     430   ; OSTaskCreate(Task3, OS_NULL, &Task3Stk[STACKSIZE], 13);
0000070A  4878 000D  431          pea       13
0000070E  41F9 0800  432          lea       _Task3Stk.L,A0
00000712  04D4      
00000714  D0FC 0200  433          add.w     #512,A0
00000718  2F08       434          move.l    A0,-(A7)
0000071A  42A7       435          clr.l     -(A7)
0000071C  4879 0000  436          pea       _Task3.L
00000720  07E6      
00000722  4E92       437          jsr       (A2)
00000724  DEFC 0010  438          add.w     #16,A7
                     439   ; OSTaskCreate(Task4, OS_NULL, &Task4Stk[STACKSIZE], 14); 
00000728  4878 000E  440          pea       14
0000072C  41F9 0800  441          lea       _Task4Stk.L,A0
00000730  06D4      
00000732  D0FC 0200  442          add.w     #512,A0
00000736  2F08       443          move.l    A0,-(A7)
00000738  42A7       444          clr.l     -(A7)
0000073A  4879 0000  445          pea       _Task4.L
0000073E  0816      
00000740  4E92       446          jsr       (A2)
00000742  DEFC 0010  447          add.w     #16,A7
                     448   ; OSTaskCreate(Task5, OS_NULL, &Task5Stk[STACKSIZE], 15); 
00000746  4878 000F  449          pea       15
0000074A  41F9 0800  450          lea       _Task5Stk.L,A0
0000074E  08D4      
00000750  D0FC 0200  451          add.w     #512,A0
00000754  2F08       452          move.l    A0,-(A7)
00000756  42A7       453          clr.l     -(A7)
00000758  4879 0000  454          pea       _Task5.L
0000075C  0840      
0000075E  4E92       455          jsr       (A2)
00000760  DEFC 0010  456          add.w     #16,A7
                     457   ; OSTaskCreate(Task6, OS_NULL, &Task6Stk[STACKSIZE], 16); // lowest priority task
00000764  4878 0010  458          pea       16
00000768  41F9 0800  459          lea       _Task6Stk.L,A0
0000076C  0AD4      
0000076E  D0FC 0200  460          add.w     #512,A0
00000772  2F08       461          move.l    A0,-(A7)
00000774  42A7       462          clr.l     -(A7)
00000776  4879 0000  463          pea       _Task6.L
0000077A  086A      
0000077C  4E92       464          jsr       (A2)
0000077E  DEFC 0010  465          add.w     #16,A7
                     466   ; OSStart(); // call to start the OS scheduler, (never returns from this function)
00000782  4EB9 0000  467          jsr       _OSStart
00000786  12EE      
00000788  245F       468          move.l    (A7)+,A2
0000078A  4E75       469          rts
                     470   ; }
                     471   ; /*
                     472   ; ** IMPORTANT : Timer 1 interrupts must be started by the highest priority task
                     473   ; ** that runs first which is Task2
                     474   ; */
                     475   ; void Task1(void *pdata)
                     476   ; {
                     477   _Task1:
0000078C  4E56 0000  478          link      A6,#0
00000790  2F02       479          move.l    D2,-(A7)
                     480   ; unsigned char count = 0;
00000792  4202       481          clr.b     D2
                     482   ; // must start timer ticker here
                     483   ; Timer1_Init() ; // this function is in BIOS.C and written by us to start timer
00000794  4EB9 0000  484          jsr       _Timer1_Init
00000798  6004      
                     485   ; for (;;) {
                     486   Task1_1:
                     487   ; //printf("RANDOM HEX DISPLAY\n");
                     488   ; HEX_A = ((count << 4) + (count & 0x0f));
0000079A  1002       489          move.b    D2,D0
0000079C  E908       490          lsl.b     #4,D0
0000079E  1202       491          move.b    D2,D1
000007A0  C23C 000F  492          and.b     #15,D1
000007A4  D001       493          add.b     D1,D0
000007A6  13C0 0040  494          move.b    D0,4194320
000007AA  0010      
                     495   ; count++;
000007AC  5202       496          addq.b    #1,D2
                     497   ; OSTimeDly(200);
000007AE  4878 00C8  498          pea       200
000007B2  4EB9 0000  499          jsr       _OSTimeDly
000007B6  521E      
000007B8  584F       500          addq.w    #4,A7
000007BA  60DE       501          bra       Task1_1
                     502   ; }
                     503   ; }
                     504   ; /*
                     505   ; ** Task 2 below was created with the highest priority so it must start timer1
                     506   ; ** so that it produces interrupts for the 100hz context switches
                     507   ; */
                     508   ; void Task2(void *pdata)
                     509   ; {
                     510   _Task2:
000007BC  4E56 0000  511          link      A6,#0
000007C0  2F02       512          move.l    D2,-(A7)
                     513   ; unsigned char count = 0;
000007C2  4202       514          clr.b     D2
                     515   ; for (;;) {
                     516   Task2_1:
                     517   ; //printf("RANDOM LED DISPLAY\n");
                     518   ; PortA = ((count << 4) + (count & 0x0f)); //LED0-7
000007C4  1002       519          move.b    D2,D0
000007C6  E908       520          lsl.b     #4,D0
000007C8  1202       521          move.b    D2,D1
000007CA  C23C 000F  522          and.b     #15,D1
000007CE  D001       523          add.b     D1,D0
000007D0  13C0 0040  524          move.b    D0,4194304
000007D4  0000      
                     525   ; count++;
000007D6  5202       526          addq.b    #1,D2
                     527   ; OSTimeDly(100);
000007D8  4878 0064  528          pea       100
000007DC  4EB9 0000  529          jsr       _OSTimeDly
000007E0  521E      
000007E2  584F       530          addq.w    #4,A7
000007E4  60DE       531          bra       Task2_1
                     532   ; }
                     533   ; }
                     534   ; void Task3(void *pdata)
                     535   ; {
                     536   _Task3:
000007E6  4E56 0000  537          link      A6,#0
000007EA  2F02       538          move.l    D2,-(A7)
                     539   ; unsigned char count = 0;
000007EC  4202       540          clr.b     D2
                     541   ; // must start timer ticker here
                     542   ; Timer1_Init() ; // this function is in BIOS.C and written by us to start timer
000007EE  4EB9 0000  543          jsr       _Timer1_Init
000007F2  6004      
                     544   ; for (;;) {
                     545   Task3_1:
                     546   ; //printf("RANDOM HEX DISPLAY\n");
                     547   ; HEX_B = ((count << 4) + (count & 0x0f));
000007F4  1002       548          move.b    D2,D0
000007F6  E908       549          lsl.b     #4,D0
000007F8  1202       550          move.b    D2,D1
000007FA  C23C 000F  551          and.b     #15,D1
000007FE  D001       552          add.b     D1,D0
00000800  13C0 0040  553          move.b    D0,4194322
00000804  0012      
                     554   ; count++;
00000806  5202       555          addq.b    #1,D2
                     556   ; OSTimeDly(50);
00000808  4878 0032  557          pea       50
0000080C  4EB9 0000  558          jsr       _OSTimeDly
00000810  521E      
00000812  584F       559          addq.w    #4,A7
00000814  60DE       560          bra       Task3_1
                     561   ; }
                     562   ; }
                     563   ; void Task4(void *pdata)
                     564   ; {
                     565   _Task4:
00000816  4E56 0000  566          link      A6,#0
0000081A  2F02       567          move.l    D2,-(A7)
                     568   ; unsigned char count = 0;
0000081C  4202       569          clr.b     D2
                     570   ; for (;;) {
                     571   Task4_1:
                     572   ; //printf("RANDOM LED DISPLAY\n");
                     573   ; PortB = ((count << 4) + (count & 0x0f)); //LED8-9
0000081E  1002       574          move.b    D2,D0
00000820  E908       575          lsl.b     #4,D0
00000822  1202       576          move.b    D2,D1
00000824  C23C 000F  577          and.b     #15,D1
00000828  D001       578          add.b     D1,D0
0000082A  13C0 0040  579          move.b    D0,4194306
0000082E  0002      
                     580   ; count++;
00000830  5202       581          addq.b    #1,D2
                     582   ; OSTimeDly(25);
00000832  4878 0019  583          pea       25
00000836  4EB9 0000  584          jsr       _OSTimeDly
0000083A  521E      
0000083C  584F       585          addq.w    #4,A7
0000083E  60DE       586          bra       Task4_1
                     587   ; }
                     588   ; }
                     589   ; void Task5(void *pdata)
                     590   ; {
                     591   _Task5:
00000840  4E56 0000  592          link      A6,#0
00000844  2F02       593          move.l    D2,-(A7)
                     594   ; unsigned char count = 0;
00000846  4202       595          clr.b     D2
                     596   ; for (;;) {
                     597   Task5_1:
                     598   ; //printf("RANDOM HEX DISPLAY\n");
                     599   ; HEX_C = ((count << 4) + (count & 0x0f)); //LED8-9
00000848  1002       600          move.b    D2,D0
0000084A  E908       601          lsl.b     #4,D0
0000084C  1202       602          move.b    D2,D1
0000084E  C23C 000F  603          and.b     #15,D1
00000852  D001       604          add.b     D1,D0
00000854  13C0 0040  605          move.b    D0,4194324
00000858  0014      
                     606   ; count++;
0000085A  5202       607          addq.b    #1,D2
                     608   ; OSTimeDly(10);
0000085C  4878 000A  609          pea       10
00000860  4EB9 0000  610          jsr       _OSTimeDly
00000864  521E      
00000866  584F       611          addq.w    #4,A7
00000868  60DE       612          bra       Task5_1
                     613   ; }
                     614   ; }
                     615   ; void Task6(void *pdata)
                     616   ; {
                     617   _Task6:
0000086A  4E56 FFFC  618          link      A6,#-4
                     619   ; unsigned char count = 0;
0000086E  422E FFFF  620          clr.b     -1(A6)
                     621   ; for (;;) {
                     622   Task6_1:
                     623   ; //printf("RANDOM HEX DISPLAY\n");
                     624   ; OSTimeDly(10);
00000872  4878 000A  625          pea       10
00000876  4EB9 0000  626          jsr       _OSTimeDly
0000087A  521E      
0000087C  584F       627          addq.w    #4,A7
0000087E  60F2       628          bra       Task6_1
                     629   ; }
                     630   ; }
                     631   ; C:\IDE68K\UCOSII\CANBUS-CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     632   ; #include <stdio.h>
                     633   ; #include "Canbus-Controller.h"
                     634   ; /*********************************************************************************************
                     635   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                     636   ; ** application note and adapted for the 68k assignment
                     637   ; *********************************************************************************************/
                     638   ; /*
                     639   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                     640   ; ** assume the addresses for the 2 can controllers given in the assignment
                     641   ; **
                     642   ; ** Registers are defined in terms of the following Macro for each Can controller,
                     643   ; ** where (i) represents an registers number
                     644   ; */
                     645   ; /*  bus timing values for
                     646   ; **  bit-rate : 100 kBit/s
                     647   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     648   ; **  maximum tolerated propagation delay : 4450 ns
                     649   ; **  minimum requested propagation delay : 500 ns
                     650   ; **
                     651   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     652   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     653   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     654   ; */
                     655   ; // initialisation for Can controller 0
                     656   ; void Init_CanBus_Controller0(void)
                     657   ; {
                     658   _Init_CanBus_Controller0:
                     659   ; // TODO - put your Canbus initialisation code for CanController 0 here
                     660   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     661   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                     662   ; leave loop after a time out and signal an error */
                     663   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     664   Init_CanBus_Controller0_1:
00000880  1039 0050  665          move.b    5242880,D0
00000884  0000      
00000886  C03C 0001  666          and.b     #1,D0
0000088A  6612       667          bne.s     Init_CanBus_Controller0_3
                     668   ; {
                     669   ; /* other bits than the reset mode/request bit are unchanged */
                     670   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit ;
0000088C  1039 0050  671          move.b    5242880,D0
00000890  0000      
00000892  803C 0001  672          or.b      #1,D0
00000896  13C0 0050  673          move.b    D0,5242880
0000089A  0000      
0000089C  60E2       674          bra       Init_CanBus_Controller0_1
                     675   Init_CanBus_Controller0_3:
                     676   ; }
                     677   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                     678   ; select PeliCAN mode
                     679   ; bypass CAN input comparator as external transceiver is used
                     680   ; select the clock for the controller S87C654 */
                     681   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
0000089E  13FC 00C0  682          move.b    #192,5242942
000008A2  0050 003E 
                     683   ; /* disable CAN interrupts, if required (always necessary after power-on)
                     684   ; (write to SJA1000 Interrupt Enable / Control Register) */
                     685   ; Can0_InterruptEnReg = ClrIntEnSJA;
000008A6  4239 0050  686          clr.b     5242888
000008AA  0008      
                     687   ; /* define acceptance code and mask */
                     688   ; Can0_AcceptCode0Reg = ClrByte;
000008AC  4239 0050  689          clr.b     5242912
000008B0  0020      
                     690   ; Can0_AcceptCode1Reg = ClrByte;
000008B2  4239 0050  691          clr.b     5242914
000008B6  0022      
                     692   ; Can0_AcceptCode2Reg = ClrByte;
000008B8  4239 0050  693          clr.b     5242916
000008BC  0024      
                     694   ; Can0_AcceptCode3Reg = ClrByte;
000008BE  4239 0050  695          clr.b     5242918
000008C2  0026      
                     696   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
000008C4  13FC 00FF  697          move.b    #255,5242920
000008C8  0050 0028 
                     698   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
000008CC  13FC 00FF  699          move.b    #255,5242922
000008D0  0050 002A 
                     700   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
000008D4  13FC 00FF  701          move.b    #255,5242924
000008D8  0050 002C 
                     702   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
000008DC  13FC 00FF  703          move.b    #255,5242926
000008E0  0050 002E 
                     704   ; /* configure bus timing */
                     705   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                     706   ; Can0_BusTiming0Reg = 0x04;
000008E4  13FC 0004  707          move.b    #4,5242892
000008E8  0050 000C 
                     708   ; Can0_BusTiming1Reg = 0x7F;
000008EC  13FC 007F  709          move.b    #127,5242894
000008F0  0050 000E 
                     710   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                     711   ; normal output mode */
                     712   ; Can0_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
000008F4  13FC 001A  713          move.b    #26,5242896
000008F8  0050 0010 
                     714   ; /* leave the reset mode/request i.e. switch to operating mode,
                     715   ; the interrupts of the S87C654 are enabled
                     716   ; but not the CAN interrupts of the SJA1000, which can be done separately
                     717   ; for the different tasks in a system */
                     718   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                     719   ; switch off Self Test Mode and Listen Only Mode,
                     720   ; clear Sleep Mode (wake up) */
                     721   ; /* wait until RM_RR_Bit is cleared */
                     722   ; /* break loop after a time out and signal an error */
                     723   ; do{
                     724   Init_CanBus_Controller0_4:
                     725   ; Can0_ModeControlReg = ClrByte;
000008FC  4239 0050  726          clr.b     5242880
00000900  0000      
00000902  1039 0050  727          move.b    5242880,D0
00000906  0000      
00000908  C03C 0001  728          and.b     #1,D0
0000090C  66EE       729          bne       Init_CanBus_Controller0_4
0000090E  4E75       730          rts
                     731   ; } while((Can0_ModeControlReg & RM_RR_Bit ) != ClrByte);
                     732   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                     733   ; }
                     734   ; // initialisation for Can controller 1
                     735   ; void Init_CanBus_Controller1(void)
                     736   ; {
                     737   _Init_CanBus_Controller1:
                     738   ; // TODO - put your Canbus initialisation code for CanController 1 here
                     739   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     740   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                     741   ; leave loop after a time out and signal an error */
                     742   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     743   Init_CanBus_Controller1_1:
00000910  1039 0050  744          move.b    5243392,D0
00000914  0200      
00000916  C03C 0001  745          and.b     #1,D0
0000091A  6612       746          bne.s     Init_CanBus_Controller1_3
                     747   ; {
                     748   ; /* other bits than the reset mode/request bit are unchanged */
                     749   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit ;
0000091C  1039 0050  750          move.b    5243392,D0
00000920  0200      
00000922  803C 0001  751          or.b      #1,D0
00000926  13C0 0050  752          move.b    D0,5243392
0000092A  0200      
0000092C  60E2       753          bra       Init_CanBus_Controller1_1
                     754   Init_CanBus_Controller1_3:
                     755   ; }
                     756   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                     757   ; select PeliCAN mode
                     758   ; bypass CAN input comparator as external transceiver is used
                     759   ; select the clock for the controller S87C654 */
                     760   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
0000092E  13FC 00C0  761          move.b    #192,5243454
00000932  0050 023E 
                     762   ; /* disable CAN interrupts, if required (always necessary after power-on)
                     763   ; (write to SJA1000 Interrupt Enable / Control Register) */
                     764   ; Can1_InterruptEnReg = ClrIntEnSJA;
00000936  4239 0050  765          clr.b     5243400
0000093A  0208      
                     766   ; /* define acceptance code and mask */
                     767   ; Can1_AcceptCode0Reg = ClrByte;
0000093C  4239 0050  768          clr.b     5243424
00000940  0220      
                     769   ; Can1_AcceptCode1Reg = ClrByte;
00000942  4239 0050  770          clr.b     5243426
00000946  0222      
                     771   ; Can1_AcceptCode2Reg = ClrByte;
00000948  4239 0050  772          clr.b     5243428
0000094C  0224      
                     773   ; Can1_AcceptCode3Reg = ClrByte;
0000094E  4239 0050  774          clr.b     5243430
00000952  0226      
                     775   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00000954  13FC 00FF  776          move.b    #255,5243432
00000958  0050 0228 
                     777   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
0000095C  13FC 00FF  778          move.b    #255,5243434
00000960  0050 022A 
                     779   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00000964  13FC 00FF  780          move.b    #255,5243436
00000968  0050 022C 
                     781   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
0000096C  13FC 00FF  782          move.b    #255,5243438
00000970  0050 022E 
                     783   ; /* configure bus timing */
                     784   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                     785   ; Can1_BusTiming0Reg = 0x04;
00000974  13FC 0004  786          move.b    #4,5243404
00000978  0050 020C 
                     787   ; Can1_BusTiming1Reg = 0x7F;
0000097C  13FC 007F  788          move.b    #127,5243406
00000980  0050 020E 
                     789   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                     790   ; normal output mode */
                     791   ; Can1_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00000984  13FC 001A  792          move.b    #26,5243408
00000988  0050 0210 
                     793   ; /* leave the reset mode/request i.e. switch to operating mode,
                     794   ; the interrupts of the S87C654 are enabled
                     795   ; but not the CAN interrupts of the SJA1000, which can be done separately
                     796   ; for the different tasks in a system */
                     797   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                     798   ; switch off Self Test Mode and Listen Only Mode,
                     799   ; clear Sleep Mode (wake up) */
                     800   ; /* wait until RM_RR_Bit is cleared */
                     801   ; /* break loop after a time out and signal an error */
                     802   ; do{
                     803   Init_CanBus_Controller1_4:
                     804   ; Can1_ModeControlReg = ClrByte;
0000098C  4239 0050  805          clr.b     5243392
00000990  0200      
00000992  1039 0050  806          move.b    5243392,D0
00000996  0200      
00000998  C03C 0001  807          and.b     #1,D0
0000099C  66EE       808          bne       Init_CanBus_Controller1_4
0000099E  4E75       809          rts
                     810   ; } while((Can1_ModeControlReg & RM_RR_Bit ) != ClrByte);
                     811   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                     812   ; }
                     813   ; // Transmit for sending a message via Can controller 0
                     814   ; void CanBus0_Transmit(void)
                     815   ; {
                     816   _CanBus0_Transmit:
                     817   ; // TODO - put your Canbus transmit code for CanController 0 here
                     818   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     819   ; /* wait until the Transmit Buffer is released */
                     820   ; do{
                     821   CanBus0_Transmit_1:
                     822   ; /* start a polling timer and run some tasks while waiting
                     823   ; break the loop and signal an error if time too long */
                     824   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
000009A0  1039 0050  825          move.b    5242884,D0
000009A4  0004      
000009A6  C03C 0004  826          and.b     #4,D0
000009AA  0C00 0004  827          cmp.b     #4,D0
000009AE  66F0       828          bne       CanBus0_Transmit_1
                     829   ; /* Transmit Buffer is released, a message may be written into the buffer */
                     830   ; /* in this example a Standard Frame message shall be transmitted */
                     831   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
000009B0  13FC 0008  832          move.b    #8,5242912
000009B4  0050 0020 
                     833   ; Can0_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
000009B8  13FC 00A5  834          move.b    #165,5242914
000009BC  0050 0022 
                     835   ; Can0_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
000009C0  13FC 0020  836          move.b    #32,5242916
000009C4  0050 0024 
                     837   ; Can0_TxBuffer3 = 0x51; /* data1 = 51 */
000009C8  13FC 0051  838          move.b    #81,5242918
000009CC  0050 0026 
                     839   ; /* Start the transmission */
                     840   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
000009D0  13FC 0001  841          move.b    #1,5242882
000009D4  0050 0002 
000009D8  4E75       842          rts
                     843   ; }
                     844   ; // Transmit for sending a message via Can controller 1
                     845   ; void CanBus1_Transmit(void)
                     846   ; {
                     847   _CanBus1_Transmit:
                     848   ; // TODO - put your Canbus transmit code for CanController 1 here
                     849   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     850   ; /* wait until the Transmit Buffer is released */
                     851   ; do{
                     852   CanBus1_Transmit_1:
                     853   ; /* start a polling timer and run some tasks while waiting
                     854   ; break the loop and signal an error if time too long */
                     855   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
000009DA  1039 0050  856          move.b    5243396,D0
000009DE  0204      
000009E0  C03C 0004  857          and.b     #4,D0
000009E4  0C00 0004  858          cmp.b     #4,D0
000009E8  66F0       859          bne       CanBus1_Transmit_1
                     860   ; /* Transmit Buffer is released, a message may be written into the buffer */
                     861   ; /* in this example a Standard Frame message shall be transmitted */
                     862   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
000009EA  13FC 0008  863          move.b    #8,5243424
000009EE  0050 0220 
                     864   ; Can1_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
000009F2  13FC 00A5  865          move.b    #165,5243426
000009F6  0050 0222 
                     866   ; Can1_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
000009FA  13FC 0020  867          move.b    #32,5243428
000009FE  0050 0224 
                     868   ; Can1_TxBuffer3 = 0x51; /* data1 = 51 */
00000A02  13FC 0051  869          move.b    #81,5243430
00000A06  0050 0226 
                     870   ; /* Start the transmission */
                     871   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00000A0A  13FC 0001  872          move.b    #1,5243394
00000A0E  0050 0202 
00000A12  4E75       873          rts
                     874   ; }
                     875   ; // Receive for reading a received message via Can controller 0
                     876   ; void CanBus0_Receive(void)
                     877   ; {
                     878   _CanBus0_Receive:
                     879   ; // TODO - put your Canbus receive code for CanController 0 here
                     880   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     881   ; //Bottom of page 35
                     882   ; /* enable the receive interrupt */
                     883   ; //Can0_InterruptEnReg = RIE_Bit; ////
                     884   ; /* wait until the Receiver Buffer is released */
                     885   ; do{
                     886   CanBus0_Receive_1:
                     887   ; /* start a polling timer and run some tasks while waiting
                     888   ; break the loop and signal an error if time too long */
                     889   ; } while((Can0_StatusReg & RBS_Bit) != RBS_Bit );
00000A14  1039 0050  890          move.b    5242884,D0
00000A18  0004      
00000A1A  C03C 0001  891          and.b     #1,D0
00000A1E  0C00 0001  892          cmp.b     #1,D0
00000A22  66F0       893          bne       CanBus0_Receive_1
                     894   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                     895   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                     896   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                     897   ; */
                     898   ; /* get the content of the Receive Buffer from SJA1000 and store the
                     899   ; message into internal memory of the controller,
                     900   ; it is possible at once to decode the FrameInfo and Data Length Code
                     901   ; and adapt the fetch appropriately */
                     902   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                     903   ; further messages will generate a new interrupt */
                     904   ; Can0_CommandReg = RRB_Bit; /* Release Receive Buffer */
00000A24  13FC 0004  905          move.b    #4,5242882
00000A28  0050 0002 
                     906   ; printf("CAN0 Received: %X\r\n", Can0_RxBuffer1);
00000A2C  1239 0050  907          move.b    5242914,D1
00000A30  0022      
00000A32  C2BC 0000  908          and.l     #255,D1
00000A36  00FF      
00000A38  2F01       909          move.l    D1,-(A7)
00000A3A  4879 0000  910          pea       @canbus~1_1.L
00000A3E  6A88      
00000A40  4EB9 0000  911          jsr       _printf
00000A44  6016      
00000A46  504F       912          addq.w    #8,A7
00000A48  4E75       913          rts
                     914   ; }
                     915   ; // Receive for reading a received message via Can controller 1
                     916   ; void CanBus1_Receive(void)
                     917   ; {
                     918   _CanBus1_Receive:
                     919   ; // TODO - put your Canbus receive code for CanController 1 here
                     920   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     921   ; //Bottom of page 35
                     922   ; // TODO - put your Canbus receive code for CanController 0 here
                     923   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     924   ; /* enable the receive interrupt */
                     925   ; //Can1_InterruptEnReg = RIE_Bit;
                     926   ; /* wait until the Receiver Buffer is released */
                     927   ; do{
                     928   CanBus1_Receive_1:
                     929   ; /* start a polling timer and run some tasks while waiting
                     930   ; break the loop and signal an error if time too long */
                     931   ; } while((Can1_StatusReg & RBS_Bit) != RBS_Bit );
00000A4A  1039 0050  932          move.b    5243396,D0
00000A4E  0204      
00000A50  C03C 0001  933          and.b     #1,D0
00000A54  0C00 0001  934          cmp.b     #1,D0
00000A58  66F0       935          bne       CanBus1_Receive_1
                     936   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                     937   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                     938   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                     939   ; */
                     940   ; /* get the content of the Receive Buffer from SJA1000 and store the
                     941   ; message into internal memory of the controller,
                     942   ; it is possible at once to decode the FrameInfo and Data Length Code
                     943   ; and adapt the fetch appropriately */
                     944   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                     945   ; further messages will generate a new interrupt */
                     946   ; Can1_CommandReg = RRB_Bit; /* Release Receive Buffer */
00000A5A  13FC 0004  947          move.b    #4,5243394
00000A5E  0050 0202 
                     948   ; printf("CAN1 Received: %X\r\n", Can1_RxBuffer1);
00000A62  1239 0050  949          move.b    5243426,D1
00000A66  0222      
00000A68  C2BC 0000  950          and.l     #255,D1
00000A6C  00FF      
00000A6E  2F01       951          move.l    D1,-(A7)
00000A70  4879 0000  952          pea       @canbus~1_2.L
00000A74  6A9C      
00000A76  4EB9 0000  953          jsr       _printf
00000A7A  6016      
00000A7C  504F       954          addq.w    #8,A7
00000A7E  4E75       955          rts
                     956   ; }
                     957   ; void CanBusTest(void)
                     958   ; {
                     959   _CanBusTest:
00000A80  2F0A       960          move.l    A2,-(A7)
00000A82  45F9 0000  961          lea       _printf.L,A2
00000A86  6016      
                     962   ; // initialise the two Can controllers
                     963   ; Init_CanBus_Controller0();
00000A88  4EB8 0880  964          jsr       _Init_CanBus_Controller0
                     965   ; Init_CanBus_Controller1();
00000A8C  4EB8 0910  966          jsr       _Init_CanBus_Controller1
                     967   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00000A90  4879 0000  968          pea       @canbus~1_3.L
00000A94  6AB0      
00000A96  4E92       969          jsr       (A2)
00000A98  584F       970          addq.w    #4,A7
                     971   ; // simple application to alternately transmit and receive messages from each of two nodes
                     972   ; while(1)    {
                     973   CanBusTest_1:
                     974   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00000A9A  4EB9 0000  975          jsr       _WaitHalfSecond
00000A9E  0ACC      
                     976   ; CanBus0_Transmit() ;       // transmit a message via Controller 0
00000AA0  4EB8 09A0  977          jsr       _CanBus0_Transmit
                     978   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
00000AA4  4EB8 0A4A  979          jsr       _CanBus1_Receive
                     980   ; printf("\r\n") ;
00000AA8  4879 0000  981          pea       @canbus~1_4.L
00000AAC  6ACC      
00000AAE  4E92       982          jsr       (A2)
00000AB0  584F       983          addq.w    #4,A7
                     984   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00000AB2  4EB9 0000  985          jsr       _WaitHalfSecond
00000AB6  0ACC      
                     986   ; CanBus1_Transmit() ;        // transmit a message via Controller 1
00000AB8  4EB8 09DA  987          jsr       _CanBus1_Transmit
                     988   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
00000ABC  4EB8 0A14  989          jsr       _CanBus0_Receive
                     990   ; printf("\r\n") ;
00000AC0  4879 0000  991          pea       @canbus~1_4.L
00000AC4  6ACC      
00000AC6  4E92       992          jsr       (A2)
00000AC8  584F       993          addq.w    #4,A7
00000ACA  60CE       994          bra       CanBusTest_1
                     995   ; }
                     996   ; }
                     997   ; /************************************************************************************
                     998   ; *Subroutine to give the 68000 something useless to do to waste 1 x 500 mSec = 500mSec = 0.5sec
                     999   ; ************************************************************************************/
                    1000   ; void WaitHalfSecond(void)
                    1001   ; {
                    1002   _WaitHalfSecond:
00000ACC  2F02      1003          move.l    D2,-(A7)
                    1004   ; long int  i;
                    1005   ; for (i = 0; i < 500000; i++)
00000ACE  4282      1006          clr.l     D2
                    1007   WaitHalfSecond_1:
00000AD0  0C82 0007 1008          cmp.l     #500000,D2
00000AD4  A120      
00000AD6  6C04      1009          bge.s     WaitHalfSecond_3
00000AD8  5282      1010          addq.l    #1,D2
00000ADA  60F4      1011          bra       WaitHalfSecond_1
                    1012   WaitHalfSecond_3:
00000ADC  241F      1013          move.l    (A7)+,D2
00000ADE  4E75      1014          rts
                    1015   ; ;
                    1016   ; }
                    1017   ;********************************************************************************************************
                    1018   ;                                               uC/OS-II
                    1019   ;                                         The Real-Time Kernel
                    1020   ;
                    1021   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                    1022   ;                                          All Rights Reserved
                    1023   ;
                    1024   ;
                    1025   ;                                     68000 Specific assembly code
                    1026   ;                                               IDE68K
                    1027   ;
                    1028   ; File         : OS_CPU_A.ASM
                    1029   ; By           : Jean J. Labrosse, Peter J. Fondse
                    1030   ;********************************************************************************************************
                    1031   
                    1032   
                    1033   ;********************************************************************************************************
                    1034   ;                                            REVISION HISTORY
                    1035   ;
                    1036   ; $Log$
                    1037   ;
                    1038   ;********************************************************************************************************
                    1039   
                    1040   
                    1041   ;********************************************************************************************************
                    1042   ;                                          PUBLIC DECLARATIONS
                    1043   ;********************************************************************************************************
                    1044   
                    1045   
                    1046   ;********************************************************************************************************
                    1047   ;                                         EXTERNAL DECLARATIONS
                    1048   ;********************************************************************************************************
                    1049   
                    1050   
                    1051   ;********************************************************************************************************
                    1052   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                    1053   ;
                    1054   ; Description : This function is called by OSStart() to start the highest priority task that was created
                    1055   ;               by your application before calling OSStart().
                    1056   ;
                    1057   ; Arguments   : none
                    1058   ;
                    1059   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                    1060   ;
                    1061   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                    1062   ;                                            +  2         D0    (L)
                    1063   ;                                            +  4         D1    (H)
                    1064   ;                                            +  6         D1    (L)
                    1065   ;                                            +  8         D2    (H)
                    1066   ;                                            + 10         D2    (L)
                    1067   ;                                            + 12         D3    (H)
                    1068   ;                                            + 14         D3    (L)
                    1069   ;                                            + 16         D4    (H)
                    1070   ;                                            + 18         D4    (L)
                    1071   ;                                            + 20         D5    (H)
                    1072   ;                                            + 22         D5    (L)
                    1073   ;                                            + 24         D6    (H)
                    1074   ;                                            + 26         D6    (L)
                    1075   ;                                            + 28         D7    (H)
                    1076   ;                                            + 30         D7    (L)
                    1077   ;                                            + 32         A0    (H)
                    1078   ;                                            + 34         A0    (L)
                    1079   ;                                            + 36         A1    (H)
                    1080   ;                                            + 38         A1    (L)
                    1081   ;                                            + 40         A2    (H)
                    1082   ;                                            + 42         A2    (L)
                    1083   ;                                            + 44         A3    (H)
                    1084   ;                                            + 46         A3    (L)
                    1085   ;                                            + 48         A4    (H)
                    1086   ;                                            + 50         A4    (L)
                    1087   ;                                            + 52         A5    (H)
                    1088   ;                                            + 54         A5    (L)
                    1089   ;                                            + 56         A6    (H)
                    1090   ;                                            + 58         A6    (L)
                    1091   ;                                            + 60         OS_INITIAL_SR
                    1092   ;                                            + 62         task  (H)
                    1093   ;                                            + 64         task  (L)
                    1094   ;                                            + 66         task  (H)
                    1095   ;                                            + 68         task  (L)
                    1096   ;                                            + 70         pdata (H)
                    1097   ;                                            + 72         pdata (L)        High Memory
                    1098   ;
                    1099   ;               2) OSStartHighRdy() MUST:
                    1100   ;                      a) Call OSTaskSwHook() then,
                    1101   ;                      b) Set OSRunning to TRUE,
                    1102   ;                      c) Switch to the highest priority task.
                    1103   ;********************************************************************************************************
                    1104   
                    1105   ; Pseudocode for OSStartHighRdy:
                    1106   ;          Call OSTaskSwHook();
                    1107   ;          Set OSRunning to 1;
                    1108   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                    1109   ;          POP all the processor registers from the stack;
                    1110   ;          Execute a Return from Interrupt instruction;
                    1111   
                    1112   
                    1113   _OSStartHighRdy:
00000AE0  4EB9 0000 1114           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
00000AE4  0D16      
00000AE6  5239 0800 1115           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
00000AEA  0F18      
00000AEC  2079 0800 1116           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
00000AF0  1028      
00000AF2  2E50      1117           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
00000AF4  4CDF 7FFF 1118           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
00000AF8  4E73      1119           rte                                ; Run task
                    1120   
                    1121   ;********************************************************************************************************
                    1122   ;                                       TASK LEVEL CONTEXT SWITCH
                    1123   ;
                    1124   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                    1125   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                    1126   ;
                    1127   ; Arguments   : none
                    1128   ;
                    1129   ; Note(s)     : 1) Upon entry,
                    1130   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                    1131   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                    1132   ;
                    1133   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                    1134   ;                  task to suspend need to be saved):
                    1135   ;
                    1136   ;                                         SP +  0  ---->  SR                   Low Memory
                    1137   ;                                            +  2         PC of task  (H)
                    1138   ;                                            +  4         PC of task  (L)      High Memory
                    1139   ;
                    1140   ;               3) The stack frame of the task to resume looks as follows:
                    1141   ;
                    1142   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                    1143   ;                                            +  2         D0    (L)
                    1144   ;                                            +  4         D1    (H)
                    1145   ;                                            +  6         D1    (L)
                    1146   ;                                            +  8         D2    (H)
                    1147   ;                                            + 10         D2    (L)
                    1148   ;                                            + 12         D3    (H)
                    1149   ;                                            + 14         D3    (L)
                    1150   ;                                            + 16         D4    (H)
                    1151   ;                                            + 18         D4    (L)
                    1152   ;                                            + 20         D5    (H)
                    1153   ;                                            + 22         D5    (L)
                    1154   ;                                            + 24         D6    (H)
                    1155   ;                                            + 26         D6    (L)
                    1156   ;                                            + 28         D7    (H)
                    1157   ;                                            + 30         D7    (L)
                    1158   ;                                            + 32         A0    (H)
                    1159   ;                                            + 34         A0    (L)
                    1160   ;                                            + 36         A1    (H)
                    1161   ;                                            + 38         A1    (L)
                    1162   ;                                            + 40         A2    (H)
                    1163   ;                                            + 42         A2    (L)
                    1164   ;                                            + 44         A3    (H)
                    1165   ;                                            + 46         A3    (L)
                    1166   ;                                            + 48         A4    (H)
                    1167   ;                                            + 50         A4    (L)
                    1168   ;                                            + 52         A5    (H)
                    1169   ;                                            + 54         A5    (L)
                    1170   ;                                            + 56         A6    (H)
                    1171   ;                                            + 58         A6    (L)
                    1172   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                    1173   ;                                            + 62         PC of task  (H)
                    1174   ;                                            + 64         PC of task  (L)     High Memory
                    1175   ;********************************************************************************************************
                    1176   
                    1177   ; Pseudocode for OSCtxSw:
                    1178   ; OSCtxSw:
                    1179   ; PUSH processor registers onto the current tasks stack;
                    1180   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                    1181   ; Call OSTaskSwHook(); (1)
                    1182   ; OSTCBCur = OSTCBHighRdy;
                    1183   ; OSPrioCur = OSPrioHighRdy; (2)
                    1184   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                    1185   ; POP all the processor registers from the stack;
                    1186   ; Execute a Return from Interrupt instruction;
                    1187   
                    1188   _OSCtxSw:
00000AFA  48E7 FFFE 1189           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
00000AFE  2079 0800 1190           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
00000B02  1020      
00000B04  208F      1191           move.l    A7,(A0)
00000B06  4EB9 0000 1192           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
00000B0A  0D16      
00000B0C  13F9 0800 1193           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000B10  0F0C 0800 
00000B14  0F0A      
00000B16  2079 0800 1194           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
00000B1A  1028      
00000B1C  23C8 0800 1195           move.l    A0,_OSTCBCur
00000B20  1020      
00000B22  2E50      1196           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
00000B24  4CDF 7FFF 1197           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
00000B28  4E73      1198           rte                                      ; Run task
                    1199   
                    1200   ;********************************************************************************************************
                    1201   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                    1202   ;
                    1203   ; Description : This function is called from OSIntExit() in OS_CORE.C
                    1204   ;               Provided for backward compatibility.
                    1205   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                    1206   ;********************************************************************************************************
                    1207   
                    1208   ; Pseudocode for OSIntCtxSw
                    1209   ; OSIntCtxSw
                    1210   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                    1211   ;          Call OSTaskSwHook(); (1)
                    1212   ;          OSTCBCur = OSTCBHighRdy;
                    1213   ;          OSPrioCur = OSPrioHighRdy; (2)
                    1214   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                    1215   ;          POP all the processor registers from the stack;
                    1216   ;          Execute a Return from Interrupt instruction;
                    1217   
                    1218   _OSIntCtxSw:
00000B2A  DFFC 0000 1219           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
00000B2E  000A      
00000B30  2279 0800 1220           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
00000B34  1020      
00000B36  228F      1221           move.l    A7,(A1)
                    1222   ;
00000B38  4EB9 0000 1223           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
00000B3C  0D16      
                    1224   ;
00000B3E  2279 0800 1225           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
00000B42  1028      
00000B44  23C9 0800 1226           move.l    A1,_OSTCBCur
00000B48  1020      
00000B4A  2E51      1227           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                    1228   ;
00000B4C  13F9 0800 1229           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000B50  0F0C 0800 
00000B54  0F0A      
00000B56  4CDF 7FFF 1230           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
00000B5A  4E73      1231           rte                                      ; Run task
                    1232   
                    1233   ;********************************************************************************************************
                    1234   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                    1235   ;
                    1236   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                    1237   ;
                    1238   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                    1239   ;
                    1240   ; Stack frame upon entry:
                    1241   ;
                    1242   ;                  SP +  0  ---->  D0    (H)
                    1243   ;                     +  2         D0    (L)
                    1244   ;                     +  4         D1    (H)
                    1245   ;                     +  6         D1    (L)
                    1246   ;                     +  8         D2    (H)
                    1247   ;                     + 10         D2    (L)
                    1248   ;                     + 12         D3    (H)
                    1249   ;                     + 14         D3    (L)
                    1250   ;                     + 16         D4    (H)
                    1251   ;                     + 18         D4    (L)
                    1252   ;                     + 20         D5    (H)
                    1253   ;                     + 22         D5    (L)
                    1254   ;                     + 24         D6    (H)
                    1255   ;                     + 26         D6    (L)
                    1256   ;                     + 28         D7    (H)
                    1257   ;                     + 30         D7    (L)
                    1258   ;                     + 32         A0    (H)
                    1259   ;                     + 34         A0    (L)
                    1260   ;                     + 36         A1    (H)
                    1261   ;                     + 38         A1    (L)
                    1262   ;                     + 40         A2    (H)
                    1263   ;                     + 42         A2    (L)
                    1264   ;                     + 44         A3    (H)
                    1265   ;                     + 46         A3    (L)
                    1266   ;                     + 48         A4    (H)
                    1267   ;                     + 50         A4    (L)
                    1268   ;                     + 52         A5    (H)
                    1269   ;                     + 54         A5    (L)
                    1270   ;                     + 56         A6    (H)
                    1271   ;                     + 58         A6    (L)
                    1272   ;                     + 60         Task or ISR's SR
                    1273   ;                     + 62         PC of task  (H)
                    1274   ;                     + 64         PC of task  (L)                   High Memory
                    1275   ;********************************************************************************************************
                    1276   
                    1277   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                    1278   
                    1279   ; void OSIntExit (void)
                    1280   ; {
                    1281   ;           OS_ENTER_CRITICAL();
                    1282   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                    1283   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                    1284   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                    1285   ;                       if (OSPrioHighRdy != OSPrioCur) {
                    1286   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                    1287   ;                                       OSCtxSwCtr++;
                    1288   ;                                       OSIntCtxSw();
                    1289   ;                       }
                    1290   ;           }
                    1291   ;           OS_EXIT_CRITICAL();
                    1292   ; }
                    1293   
                    1294   OSIntExit68K:
00000B5C  5339 0800 1295           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
00000B60  0F06      
00000B62  6600 009C 1296           bne       OSIntExit68K_1
00000B66  4A39 0800 1297           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
00000B6A  0F08      
00000B6C  6600 0092 1298           bne       OSIntExit68K_1
                    1299   
                    1300   ;       re-enabling interrupts
00000B70  302F 003C 1301           move.w    (60,A7),D0                    ; must be LAST nested ISR
00000B74  C07C 0700 1302           and.w     #$0700,D0                     ; do we want to change S bit in SR
                    1303   ;
00000B78  6600 0086 1304           bne       OSIntExit68K_1
00000B7C  41F9 0000 1305           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000B80  6B22      
00000B82  4280      1306           clr.l     D0
00000B84  1039 0800 1307           move.b    _OSRdyGrp,D0
00000B88  0F0E      
00000B8A  1230 0800 1308           move.b    0(A0,D0.L),D1                 ;  y in D1
                    1309   ;
00000B8E  41F9 0800 1310           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
00000B92  0F10      
00000B94  4280      1311           clr.l     D0
00000B96  1001      1312           move.b    D1,D0
00000B98  41F0 0800 1313           lea       0(A0,D0.L),A0
00000B9C  4280      1314           clr.l     D0
00000B9E  1010      1315           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000BA0  41F9 0000 1316           lea       _OSUnMapTbl,A0
00000BA4  6B22      
00000BA6  41F0 0800 1317           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
00000BAA  1001      1318           move.b    D1,D0
00000BAC  E708      1319           lsl.b     #3,D0                         ;  (y << 3) in D0
00000BAE  D010      1320           add.b     (A0),D0
00000BB0  13C0 0800 1321           move.b    D0,_OSPrioHighRdy
00000BB4  0F0C      
                    1322   ;
00000BB6  B039 0800 1323           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
00000BBA  0F0A      
00000BBC  6742      1324           beq.s     OSIntExit68K_1
                    1325   ;
00000BBE  41F9 0800 1326           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00000BC2  1030      
00000BC4  4281      1327           clr.l     D1
00000BC6  1200      1328           move.b    D0,D1
00000BC8  E589      1329           lsl.l     #2,D1
00000BCA  41F0 1800 1330           lea       0(A0,D1.L),A0
00000BCE  23D0 0800 1331           move.l    (A0),_OSTCBHighRdy
00000BD2  1028      
                    1332   ;
00000BD4  52B9 0800 1333           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
00000BD8  0CD6      
                    1334   ;
00000BDA  2079 0800 1335           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
00000BDE  1020      
00000BE0  208F      1336           move.l    A7,(A0)
00000BE2  4EB9 0000 1337           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
00000BE6  0D16      
00000BE8  2079 0800 1338           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
00000BEC  1028      
00000BEE  23C8 0800 1339           move.l    A0,_OSTCBCur
00000BF2  1020      
00000BF4  13F9 0800 1340           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
00000BF8  0F0C 0800 
00000BFC  0F0A      
00000BFE  2E50      1341           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                    1342   OSIntExit68K_1:
00000C00  4CDF 7FFF 1343           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
00000C04  4E73      1344           rte                                     ;  Return to task or nested ISR
                    1345   
                    1346   ;********************************************************************************************************
                    1347   ;                                           SYSTEM TICK ISR
                    1348   ;
                    1349   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                    1350   ;
                    1351   ; Arguments   : none
                    1352   ;
                    1353   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                    1354   ;               2) You MUST save ALL the CPU registers as shown below
                    1355   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                    1356   ;********************************************************************************************************
                    1357   
                    1358   ; C Code for OSInterrupt exit taken from text book on OS example program
                    1359   
                    1360   ; void OSTickISR(void)
                    1361   ; {
                    1362   ;          Save processor registers;
                    1363   ;          Call OSIntEnter() or increment OSIntNesting;
                    1364   ;          Call OSTimeTick();
                    1365   ;          Call OSIntExit();
                    1366   ;          Restore processor registers;
                    1367   ;          Execute a return from interrupt instruction;
                    1368   ; }
                    1369   
                    1370   
                    1371   _OSTickISR:
00000C06  007C 0700 1372           or.w      #$0700,SR                     ; Disable ALL interrupts
00000C0A  5239 0800 1373           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
00000C0E  0F06      
00000C10  48E7 FFFE 1374           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                    1375           ; call your ISR here to clear the tick interrupt
00000C14  4EB9 0000 1376           jsr       _Timer_ISR
00000C18  5FEE      
                    1377           ;
00000C1A  4EB9 0000 1378           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
00000C1E  1374      
00000C20  6000 FF3A 1379           bra       OSIntExit68K                  ; Exit ISR
                    1380   ; C:\IDE68K\UCOSII\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1381   ; /*
                    1382   ; *********************************************************************************************************
                    1383   ; *                                               uC/OS-II
                    1384   ; *                                         The Real-Time Kernel
                    1385   ; *
                    1386   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                    1387   ; *                                          All Rights Reserved
                    1388   ; *
                    1389   ; *
                    1390   ; *                                         68000 Specific C code
                    1391   ; *                                                IDE68K
                    1392   ; *
                    1393   ; * File         : OS_CPU_C.C
                    1394   ; * By           : Jean J. Labrosse
                    1395   ; *********************************************************************************************************
                    1396   ; */
                    1397   ; #ifndef  OS_MASTER_FILE
                    1398   ; #include "ucos_ii.h"
                    1399   ; #endif
                    1400   ; #include "Bios.h"
                    1401   ; /*
                    1402   ; *********************************************************************************************************
                    1403   ; *                                           REVISION HISTORY
                    1404   ; *
                    1405   ; * $Log$
                    1406   ; *
                    1407   ; *********************************************************************************************************
                    1408   ; */
                    1409   ; #if OS_TMR_EN > 0
                    1410   ; INT8U OSTmrTickCtr;
                    1411   ; #endif
                    1412   ; /*$PAGE*/
                    1413   ; /*
                    1414   ; *********************************************************************************************************
                    1415   ; *                                        INITIALIZE A TASK'S STACK
                    1416   ; *
                    1417   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                    1418   ; *              stack frame of the task being created.  This function is highly processor specific.
                    1419   ; *
                    1420   ; * Arguments  : task          is a pointer to the task code
                    1421   ; *
                    1422   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                    1423   ; *                            when the task first executes.
                    1424   ; *
                    1425   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                    1426   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                    1427   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                    1428   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                    1429   ; *                            of the stack.
                    1430   ; *
                    1431   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                    1432   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                    1433   ; *
                    1434   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                    1435   ; *              been placed on the stack in the proper order.
                    1436   ; *
                    1437   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                    1438   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                    1439   ; *                 mode.
                    1440   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                    1441   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                    1442   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                    1443   ; *                 OSTaskIdle() and OSTaskStat().
                    1444   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                    1445   ; *********************************************************************************************************
                    1446   ; */
                    1447   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                    1448   ; {
                    1449   _OSTaskStkInit:
00000C24  4E56 0000 1450          link      A6,#0
00000C28  48E7 3000 1451          movem.l   D2/D3,-(A7)
                    1452   ; INT32U  *pstk32;
                    1453   ; INT16U  *pstk16;
                    1454   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                    1455   ; /* Load stack pointer and align on 32-bit bound  */
                    1456   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
00000C2C  202E 0010 1457          move.l    16(A6),D0
00000C30  C0BC 7FFF 1458          and.l     #2147483647,D0
00000C34  FFFF      
00000C36  2400      1459          move.l    D0,D2
                    1460   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                    1461   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
00000C38  5982      1462          subq.l    #4,D2
00000C3A  2042      1463          move.l    D2,A0
00000C3C  20AE 000C 1464          move.l    12(A6),(A0)
                    1465   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000C40  5982      1466          subq.l    #4,D2
00000C42  2042      1467          move.l    D2,A0
00000C44  20AE 0008 1468          move.l    8(A6),(A0)
                    1469   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                    1470   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000C48  5982      1471          subq.l    #4,D2
00000C4A  2042      1472          move.l    D2,A0
00000C4C  20AE 0008 1473          move.l    8(A6),(A0)
                    1474   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
00000C50  2602      1475          move.l    D2,D3
                    1476   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
00000C52  5583      1477          subq.l    #2,D3
00000C54  2043      1478          move.l    D3,A0
00000C56  30BC 2000 1479          move.w    #8192,(A0)
                    1480   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
00000C5A  2403      1481          move.l    D3,D2
                    1482   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                    1483   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
00000C5C  5982      1484          subq.l    #4,D2
00000C5E  2042      1485          move.l    D2,A0
00000C60  20BC 00A6 1486          move.l    #10879142,(A0)
00000C64  00A6      
                    1487   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
00000C66  5982      1488          subq.l    #4,D2
00000C68  2042      1489          move.l    D2,A0
00000C6A  20BC 00A5 1490          move.l    #10813605,(A0)
00000C6E  00A5      
                    1491   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
00000C70  5982      1492          subq.l    #4,D2
00000C72  2042      1493          move.l    D2,A0
00000C74  20BC 00A4 1494          move.l    #10748068,(A0)
00000C78  00A4      
                    1495   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
00000C7A  5982      1496          subq.l    #4,D2
00000C7C  2042      1497          move.l    D2,A0
00000C7E  20BC 00A3 1498          move.l    #10682531,(A0)
00000C82  00A3      
                    1499   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
00000C84  5982      1500          subq.l    #4,D2
00000C86  2042      1501          move.l    D2,A0
00000C88  20BC 00A2 1502          move.l    #10616994,(A0)
00000C8C  00A2      
                    1503   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
00000C8E  5982      1504          subq.l    #4,D2
00000C90  2042      1505          move.l    D2,A0
00000C92  20BC 00A1 1506          move.l    #10551457,(A0)
00000C96  00A1      
                    1507   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
00000C98  5982      1508          subq.l    #4,D2
00000C9A  2042      1509          move.l    D2,A0
00000C9C  20BC 00A0 1510          move.l    #10485920,(A0)
00000CA0  00A0      
                    1511   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
00000CA2  5982      1512          subq.l    #4,D2
00000CA4  2042      1513          move.l    D2,A0
00000CA6  20BC 00D7 1514          move.l    #14090455,(A0)
00000CAA  00D7      
                    1515   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000CAC  5982      1516          subq.l    #4,D2
00000CAE  2042      1517          move.l    D2,A0
00000CB0  20BC 00D6 1518          move.l    #14024918,(A0)
00000CB4  00D6      
                    1519   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
00000CB6  5982      1520          subq.l    #4,D2
00000CB8  2042      1521          move.l    D2,A0
00000CBA  20BC 00D5 1522          move.l    #13959381,(A0)
00000CBE  00D5      
                    1523   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
00000CC0  5982      1524          subq.l    #4,D2
00000CC2  2042      1525          move.l    D2,A0
00000CC4  20BC 00D4 1526          move.l    #13893844,(A0)
00000CC8  00D4      
                    1527   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000CCA  5982      1528          subq.l    #4,D2
00000CCC  2042      1529          move.l    D2,A0
00000CCE  20BC 00D3 1530          move.l    #13828307,(A0)
00000CD2  00D3      
                    1531   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
00000CD4  5982      1532          subq.l    #4,D2
00000CD6  2042      1533          move.l    D2,A0
00000CD8  20BC 00D2 1534          move.l    #13762770,(A0)
00000CDC  00D2      
                    1535   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
00000CDE  5982      1536          subq.l    #4,D2
00000CE0  2042      1537          move.l    D2,A0
00000CE2  20BC 00D1 1538          move.l    #13697233,(A0)
00000CE6  00D1      
                    1539   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
00000CE8  5982      1540          subq.l    #4,D2
00000CEA  2042      1541          move.l    D2,A0
00000CEC  20BC 00D0 1542          move.l    #13631696,(A0)
00000CF0  00D0      
                    1543   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
00000CF2  2002      1544          move.l    D2,D0
00000CF4  4CDF 000C 1545          movem.l   (A7)+,D2/D3
00000CF8  4E5E      1546          unlk      A6
00000CFA  4E75      1547          rts
                    1548   ; }
                    1549   ; /*$PAGE*/
                    1550   ; /*
                    1551   ; *********************************************************************************************************
                    1552   ; *                                             GET ISR VECTOR
                    1553   ; *
                    1554   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                    1555   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                    1556   ; *
                    1557   ; * Arguments  : vect     is the vector number
                    1558   ; *
                    1559   ; * Note(s)    : 1) Interrupts are disabled during this call
                    1560   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                    1561   ; *********************************************************************************************************
                    1562   ; */
                    1563   ; /*$PAGE*/
                    1564   ; #if OS_CPU_HOOKS_EN
                    1565   ; /*
                    1566   ; *********************************************************************************************************
                    1567   ; *                                       OS INITIALIZATION HOOK
                    1568   ; *                                            (BEGINNING)
                    1569   ; *
                    1570   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                    1571   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                    1572   ; *
                    1573   ; * Arguments  : none
                    1574   ; *
                    1575   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1576   ; *********************************************************************************************************
                    1577   ; */
                    1578   ; void OSInitHookBegin(void)
                    1579   ; {
                    1580   _OSInitHookBegin:
00000CFC  4E75      1581          rts
                    1582   ; }
                    1583   ; /*
                    1584   ; *********************************************************************************************************
                    1585   ; *                                       OS INITIALIZATION HOOK
                    1586   ; *                                               (END)
                    1587   ; *
                    1588   ; * Description: This function is called by OSInit() at the end of OSInit().
                    1589   ; *
                    1590   ; * Arguments  : none
                    1591   ; *
                    1592   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1593   ; *********************************************************************************************************
                    1594   ; */
                    1595   ; void OSInitHookEnd(void)
                    1596   ; {
                    1597   _OSInitHookEnd:
                    1598   ; #if OS_TMR_EN > 0
                    1599   ; OSTmrTickCtr = 0;
00000CFE  4239 0800 1600          clr.b     _OSTmrTickCtr.L
00000D02  0CD4      
00000D04  4E75      1601          rts
                    1602   ; #endif
                    1603   ; }
                    1604   ; /*
                    1605   ; *********************************************************************************************************
                    1606   ; *                                          TASK CREATION HOOK
                    1607   ; *
                    1608   ; * Description: This function is called when a task is created.
                    1609   ; *
                    1610   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                    1611   ; *
                    1612   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1613   ; *********************************************************************************************************
                    1614   ; */
                    1615   ; void OSTaskCreateHook(OS_TCB *ptcb)
                    1616   ; {
                    1617   _OSTaskCreateHook:
00000D06  4E56 0000 1618          link      A6,#0
00000D0A  4E5E      1619          unlk      A6
00000D0C  4E75      1620          rts
                    1621   ; }
                    1622   ; /*
                    1623   ; *********************************************************************************************************
                    1624   ; *                                           TASK DELETION HOOK
                    1625   ; *
                    1626   ; * Description: This function is called when a task is deleted.
                    1627   ; *
                    1628   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                    1629   ; *
                    1630   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1631   ; *********************************************************************************************************
                    1632   ; */
                    1633   ; void OSTaskDelHook(OS_TCB *ptcb)
                    1634   ; {
                    1635   _OSTaskDelHook:
00000D0E  4E56 0000 1636          link      A6,#0
00000D12  4E5E      1637          unlk      A6
00000D14  4E75      1638          rts
                    1639   ; }
                    1640   ; /*
                    1641   ; *********************************************************************************************************
                    1642   ; *                                           TASK SWITCH HOOK
                    1643   ; *
                    1644   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                    1645   ; *              operations during a context switch.
                    1646   ; *
                    1647   ; * Arguments  : none
                    1648   ; *
                    1649   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1650   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                    1651   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                    1652   ; *                 task being switched out (i.e. the preempted task).
                    1653   ; *********************************************************************************************************
                    1654   ; */
                    1655   ; void OSTaskSwHook(void)
                    1656   ; {
                    1657   _OSTaskSwHook:
00000D16  4E75      1658          rts
                    1659   ; }
                    1660   ; /*
                    1661   ; *********************************************************************************************************
                    1662   ; *                                           TASK IDLE HOOK
                    1663   ; *
                    1664   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                    1665   ; *              operations during the idle task.
                    1666   ; *
                    1667   ; * Arguments  : none
                    1668   ; *
                    1669   ; * Note(s)    : none
                    1670   ; *********************************************************************************************************
                    1671   ; */
                    1672   ; void OSTaskIdleHook(void)
                    1673   ; {
                    1674   _OSTaskIdleHook:
00000D18  4E75      1675          rts
                    1676   ; }
                    1677   ; /*
                    1678   ; *********************************************************************************************************
                    1679   ; *                                           TASK RETURN HOOK
                    1680   ; *
                    1681   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1682   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1683   ; *
                    1684   ; * Arguments  : Pointer to currently running TCB
                    1685   ; *
                    1686   ; * Note(s)    : none
                    1687   ; *********************************************************************************************************
                    1688   ; */
                    1689   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1690   ; {
                    1691   _OSTaskReturnHook:
00000D1A  4E56 0000 1692          link      A6,#0
00000D1E  4E5E      1693          unlk      A6
00000D20  4E75      1694          rts
                    1695   ; }
                    1696   ; /*
                    1697   ; *********************************************************************************************************
                    1698   ; *                                           STATISTIC TASK HOOK
                    1699   ; *
                    1700   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1701   ; *              application to add functionality to the statistics task.
                    1702   ; *
                    1703   ; * Arguments  : none
                    1704   ; *********************************************************************************************************
                    1705   ; */
                    1706   ; void OSTaskStatHook(void)
                    1707   ; {
                    1708   _OSTaskStatHook:
00000D22  4E75      1709          rts
                    1710   ; }
                    1711   ; /*
                    1712   ; *********************************************************************************************************
                    1713   ; *                                               TICK HOOK
                    1714   ; *
                    1715   ; * Description: This function is called every tick.
                    1716   ; *
                    1717   ; * Arguments  : none
                    1718   ; *
                    1719   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1720   ; *********************************************************************************************************
                    1721   ; */
                    1722   ; void OSTimeTickHook(void)
                    1723   ; {
                    1724   _OSTimeTickHook:
                    1725   ; #if OS_TMR_EN > 0
                    1726   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
00000D24  3039 0800 1727          move.w    _OSTmrUsed.L,D0
00000D28  197C      
00000D2A  0C40 0000 1728          cmp.w     #0,D0
00000D2E  631E      1729          bls.s     OSTimeTickHook_1
00000D30  5239 0800 1730          addq.b    #1,_OSTmrTickCtr.L
00000D34  0CD4      
00000D36  1039 0800 1731          move.b    _OSTmrTickCtr.L,D0
00000D3A  0CD4      
00000D3C  0C00 000A 1732          cmp.b     #10,D0
00000D40  650C      1733          blo.s     OSTimeTickHook_1
                    1734   ; OSTmrTickCtr = 0;
00000D42  4239 0800 1735          clr.b     _OSTmrTickCtr.L
00000D46  0CD4      
                    1736   ; OSTmrSignal();
00000D48  4EB9 0000 1737          jsr       _OSTmrSignal
00000D4C  59EE      
                    1738   OSTimeTickHook_1:
00000D4E  4E75      1739          rts
                    1740   ; }
                    1741   ; #endif
                    1742   ; }
                    1743   ; /*
                    1744   ; *********************************************************************************************************
                    1745   ; *                                           OSTCBInit() HOOK
                    1746   ; *
                    1747   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1748   ; *
                    1749   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1750   ; *
                    1751   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1752   ; *********************************************************************************************************
                    1753   ; */
                    1754   ; #if OS_VERSION > 203
                    1755   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1756   ; {
                    1757   _OSTCBInitHook:
00000D50  4E56 0000 1758          link      A6,#0
00000D54  4E5E      1759          unlk      A6
00000D56  4E75      1760          rts
                    1761   ; }
                    1762   ; #endif
                    1763   ; #endif // OS_CPU_HOOKS_EN
                    1764   ; C:\IDE68K\UCOSII\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1765   ; /*
                    1766   ; *********************************************************************************************************
                    1767   ; *                                                uC/OS-II
                    1768   ; *                                          The Real-Time Kernel
                    1769   ; *                                             CORE FUNCTIONS
                    1770   ; *
                    1771   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1772   ; *                                           All Rights Reserved
                    1773   ; *
                    1774   ; * File    : OS_CORE.C
                    1775   ; * By      : Jean J. Labrosse
                    1776   ; * Version : V2.92.07
                    1777   ; *
                    1778   ; * LICENSING TERMS:
                    1779   ; * ---------------
                    1780   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1781   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1782   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1783   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1784   ; * licensing fee.
                    1785   ; *********************************************************************************************************
                    1786   ; */
                    1787   ; #define  MICRIUM_SOURCE
                    1788   ; #ifndef  OS_MASTER_FILE
                    1789   ; #define  OS_GLOBALS
                    1790   ; #include <ucos_ii.h>
                    1791   ; #endif
                    1792   ; /*
                    1793   ; *********************************************************************************************************
                    1794   ; *                                      PRIORITY RESOLUTION TABLE
                    1795   ; *
                    1796   ; * Note: Index into table is bit pattern to resolve highest priority
                    1797   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1798   ; *********************************************************************************************************
                    1799   ; */
                    1800   ; INT8U  const  OSUnMapTbl[256] = {
                    1801   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1802   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1803   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1804   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1805   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1806   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1807   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1808   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1809   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1810   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1811   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1812   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1813   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1814   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1815   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1816   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1817   ; };
                    1818   ; /*$PAGE*/
                    1819   ; /*
                    1820   ; *********************************************************************************************************
                    1821   ; *                                         FUNCTION PROTOTYPES
                    1822   ; *********************************************************************************************************
                    1823   ; */
                    1824   ; static  void  OS_InitEventList(void);
                    1825   ; static  void  OS_InitMisc(void);
                    1826   ; static  void  OS_InitRdyList(void);
                    1827   ; static  void  OS_InitTaskIdle(void);
                    1828   ; #if OS_TASK_STAT_EN > 0u
                    1829   ; static  void  OS_InitTaskStat(void);
                    1830   ; #endif
                    1831   ; static  void  OS_InitTCBList(void);
                    1832   ; static  void  OS_SchedNew(void);
                    1833   ; /*$PAGE*/
                    1834   ; /*
                    1835   ; *********************************************************************************************************
                    1836   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1837   ; *
                    1838   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1839   ; *
                    1840   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1841   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1842   ; *                        type is irrelevant.
                    1843   ; *
                    1844   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1845   ; *                        mutex, mailbox or queue.
                    1846   ; *
                    1847   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1848   ; *
                    1849   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1850   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1851   ; *                                                   control block type.
                    1852   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1853   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1854   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1855   ; *
                    1856   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1857   ; *********************************************************************************************************
                    1858   ; */
                    1859   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1860   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1861   ; INT8U     **pname,
                    1862   ; INT8U      *perr)
                    1863   ; {
                    1864   _OSEventNameGet:
00000D58  4E56 FFFC 1865          link      A6,#-4
00000D5C  2F02      1866          move.l    D2,-(A7)
00000D5E  242E 0010 1867          move.l    16(A6),D2
                    1868   ; INT8U      len;
                    1869   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1870   ; OS_CPU_SR  cpu_sr = 0u;
                    1871   ; #endif
                    1872   ; #ifdef OS_SAFETY_CRITICAL
                    1873   ; if (perr == (INT8U *)0) {
                    1874   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1875   ; return (0u);
                    1876   ; }
                    1877   ; #endif
                    1878   ; #if OS_ARG_CHK_EN > 0u
                    1879   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1880   ; *perr = OS_ERR_PEVENT_NULL;
                    1881   ; return (0u);
                    1882   ; }
                    1883   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1884   ; *perr = OS_ERR_PNAME_NULL;
                    1885   ; return (0u);
                    1886   ; }
                    1887   ; #endif
                    1888   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000D62  1039 0800 1889          move.b    _OSIntNesting.L,D0
00000D66  0F06      
00000D68  0C00 0000 1890          cmp.b     #0,D0
00000D6C  630C      1891          bls.s     OSEventNameGet_1
                    1892   ; *perr  = OS_ERR_NAME_GET_ISR;
00000D6E  2042      1893          move.l    D2,A0
00000D70  10BC 0011 1894          move.b    #17,(A0)
                    1895   ; return (0u);
00000D74  4200      1896          clr.b     D0
00000D76  6000 0066 1897          bra       OSEventNameGet_3
                    1898   OSEventNameGet_1:
                    1899   ; }
                    1900   ; switch (pevent->OSEventType) {
00000D7A  206E 0008 1901          move.l    8(A6),A0
00000D7E  1010      1902          move.b    (A0),D0
00000D80  C0BC 0000 1903          and.l     #255,D0
00000D84  00FF      
00000D86  5380      1904          subq.l    #1,D0
00000D88  651C      1905          blo.s     OSEventNameGet_4
00000D8A  0C80 0000 1906          cmp.l     #4,D0
00000D8E  0004      
00000D90  6414      1907          bhs.s     OSEventNameGet_4
00000D92  E380      1908          asl.l     #1,D0
00000D94  303B 0806 1909          move.w    OSEventNameGet_6(PC,D0.L),D0
00000D98  4EFB 0002 1910          jmp       OSEventNameGet_6(PC,D0.W)
                    1911   OSEventNameGet_6:
00000D9C  0008      1912          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000D9E  0008      1913          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000DA0  0008      1914          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000DA2  0008      1915          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1916   OSEventNameGet_7:
                    1917   ; case OS_EVENT_TYPE_SEM:
                    1918   ; case OS_EVENT_TYPE_MUTEX:
                    1919   ; case OS_EVENT_TYPE_MBOX:
                    1920   ; case OS_EVENT_TYPE_Q:
                    1921   ; break;
00000DA4  600A      1922          bra.s     OSEventNameGet_5
                    1923   OSEventNameGet_4:
                    1924   ; default:
                    1925   ; *perr = OS_ERR_EVENT_TYPE;
00000DA6  2042      1926          move.l    D2,A0
00000DA8  10BC 0001 1927          move.b    #1,(A0)
                    1928   ; return (0u);
00000DAC  4200      1929          clr.b     D0
00000DAE  602E      1930          bra.s     OSEventNameGet_3
                    1931   OSEventNameGet_5:
                    1932   ; }
                    1933   ; OS_ENTER_CRITICAL();
00000DB0  40E7      1934          dc.w      16615
00000DB2  007C      1935          dc.w      124
00000DB4  0700      1936          dc.w      1792
                    1937   ; *pname = pevent->OSEventName;
00000DB6  206E 0008 1938          move.l    8(A6),A0
00000DBA  226E 000C 1939          move.l    12(A6),A1
00000DBE  22A8 0012 1940          move.l    18(A0),(A1)
                    1941   ; len    = OS_StrLen(*pname);
00000DC2  206E 000C 1942          move.l    12(A6),A0
00000DC6  2F10      1943          move.l    (A0),-(A7)
00000DC8  4EB9 0000 1944          jsr       _OS_StrLen
00000DCC  1ACC      
00000DCE  584F      1945          addq.w    #4,A7
00000DD0  1D40 FFFF 1946          move.b    D0,-1(A6)
                    1947   ; OS_EXIT_CRITICAL();
00000DD4  46DF      1948          dc.w      18143
                    1949   ; *perr  = OS_ERR_NONE;
00000DD6  2042      1950          move.l    D2,A0
00000DD8  4210      1951          clr.b     (A0)
                    1952   ; return (len);
00000DDA  102E FFFF 1953          move.b    -1(A6),D0
                    1954   OSEventNameGet_3:
00000DDE  241F      1955          move.l    (A7)+,D2
00000DE0  4E5E      1956          unlk      A6
00000DE2  4E75      1957          rts
                    1958   ; }
                    1959   ; #endif
                    1960   ; /*$PAGE*/
                    1961   ; /*
                    1962   ; *********************************************************************************************************
                    1963   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1964   ; *
                    1965   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1966   ; *
                    1967   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1968   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1969   ; *                        matter the actual type.
                    1970   ; *
                    1971   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1972   ; *                        mutex, mailbox or queue.
                    1973   ; *
                    1974   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1975   ; *
                    1976   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1977   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1978   ; *                                                   control block type.
                    1979   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1980   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1981   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1982   ; *
                    1983   ; * Returns    : None
                    1984   ; *********************************************************************************************************
                    1985   ; */
                    1986   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1987   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1988   ; INT8U     *pname,
                    1989   ; INT8U     *perr)
                    1990   ; {
                    1991   _OSEventNameSet:
00000DE4  4E56 0000 1992          link      A6,#0
00000DE8  2F02      1993          move.l    D2,-(A7)
00000DEA  242E 0010 1994          move.l    16(A6),D2
                    1995   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1996   ; OS_CPU_SR  cpu_sr = 0u;
                    1997   ; #endif
                    1998   ; #ifdef OS_SAFETY_CRITICAL
                    1999   ; if (perr == (INT8U *)0) {
                    2000   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    2001   ; return;
                    2002   ; }
                    2003   ; #endif
                    2004   ; #if OS_ARG_CHK_EN > 0u
                    2005   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    2006   ; *perr = OS_ERR_PEVENT_NULL;
                    2007   ; return;
                    2008   ; }
                    2009   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    2010   ; *perr = OS_ERR_PNAME_NULL;
                    2011   ; return;
                    2012   ; }
                    2013   ; #endif
                    2014   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000DEE  1039 0800 2015          move.b    _OSIntNesting.L,D0
00000DF2  0F06      
00000DF4  0C00 0000 2016          cmp.b     #0,D0
00000DF8  630A      2017          bls.s     OSEventNameSet_1
                    2018   ; *perr = OS_ERR_NAME_SET_ISR;
00000DFA  2042      2019          move.l    D2,A0
00000DFC  10BC 0012 2020          move.b    #18,(A0)
                    2021   ; return;
00000E00  6000 004C 2022          bra       OSEventNameSet_3
                    2023   OSEventNameSet_1:
                    2024   ; }
                    2025   ; switch (pevent->OSEventType) {
00000E04  206E 0008 2026          move.l    8(A6),A0
00000E08  1010      2027          move.b    (A0),D0
00000E0A  C0BC 0000 2028          and.l     #255,D0
00000E0E  00FF      
00000E10  5380      2029          subq.l    #1,D0
00000E12  651C      2030          blo.s     OSEventNameSet_4
00000E14  0C80 0000 2031          cmp.l     #4,D0
00000E18  0004      
00000E1A  6414      2032          bhs.s     OSEventNameSet_4
00000E1C  E380      2033          asl.l     #1,D0
00000E1E  303B 0806 2034          move.w    OSEventNameSet_6(PC,D0.L),D0
00000E22  4EFB 0002 2035          jmp       OSEventNameSet_6(PC,D0.W)
                    2036   OSEventNameSet_6:
00000E26  0008      2037          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000E28  0008      2038          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000E2A  0008      2039          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000E2C  0008      2040          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    2041   OSEventNameSet_7:
                    2042   ; case OS_EVENT_TYPE_SEM:
                    2043   ; case OS_EVENT_TYPE_MUTEX:
                    2044   ; case OS_EVENT_TYPE_MBOX:
                    2045   ; case OS_EVENT_TYPE_Q:
                    2046   ; break;
00000E2E  6008      2047          bra.s     OSEventNameSet_5
                    2048   OSEventNameSet_4:
                    2049   ; default:
                    2050   ; *perr = OS_ERR_EVENT_TYPE;
00000E30  2042      2051          move.l    D2,A0
00000E32  10BC 0001 2052          move.b    #1,(A0)
                    2053   ; return;
00000E36  6016      2054          bra.s     OSEventNameSet_3
                    2055   OSEventNameSet_5:
                    2056   ; }
                    2057   ; OS_ENTER_CRITICAL();
00000E38  40E7      2058          dc.w      16615
00000E3A  007C      2059          dc.w      124
00000E3C  0700      2060          dc.w      1792
                    2061   ; pevent->OSEventName = pname;
00000E3E  206E 0008 2062          move.l    8(A6),A0
00000E42  216E 000C 2063          move.l    12(A6),18(A0)
00000E46  0012      
                    2064   ; OS_EXIT_CRITICAL();
00000E48  46DF      2065          dc.w      18143
                    2066   ; *perr = OS_ERR_NONE;
00000E4A  2042      2067          move.l    D2,A0
00000E4C  4210      2068          clr.b     (A0)
                    2069   OSEventNameSet_3:
00000E4E  241F      2070          move.l    (A7)+,D2
00000E50  4E5E      2071          unlk      A6
00000E52  4E75      2072          rts
                    2073   ; }
                    2074   ; #endif
                    2075   ; /*$PAGE*/
                    2076   ; /*
                    2077   ; *********************************************************************************************************
                    2078   ; *                                       PEND ON MULTIPLE EVENTS
                    2079   ; *
                    2080   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    2081   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    2082   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    2083   ; *
                    2084   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    2085   ; *
                    2086   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    2087   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    2088   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    2089   ; *
                    2090   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    2091   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    2092   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    2093   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    2094   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    2095   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    2096   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    2097   ; *
                    2098   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    2099   ; *                            wait for the resources up to the amount of time specified by this argument.
                    2100   ; *                            If you specify 0, however, your task will wait forever for the specified
                    2101   ; *                            events or, until the resources becomes available (or the events occur).
                    2102   ; *
                    2103   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    2104   ; *                            messages are:
                    2105   ; *
                    2106   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    2107   ; *                                                or, the events you are waiting for occurred; check the
                    2108   ; *                                                'pevents_rdy' array for which events are available.
                    2109   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    2110   ; *                                                'pevents_rdy' array for which events were aborted.
                    2111   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    2112   ; *                                                'timeout'.
                    2113   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    2114   ; *                                                NULL pointer.
                    2115   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    2116   ; *                                                mailboxes, and/or queues.
                    2117   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    2118   ; *                                                would lead to a suspension.
                    2119   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    2120   ; *
                    2121   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    2122   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    2123   ; *
                    2124   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    2125   ; *
                    2126   ; *                        semaphores, mailboxes, queues
                    2127   ; *
                    2128   ; *                 b. Return ALL available events and messages, if any
                    2129   ; *
                    2130   ; *                 c. Add    current task priority as pending to   each events's wait list
                    2131   ; *                      Performed in OS_EventTaskWaitMulti()
                    2132   ; *
                    2133   ; *                 d. Wait on any of multiple events
                    2134   ; *
                    2135   ; *                 e. Remove current task priority as pending from each events's wait list
                    2136   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    2137   ; *
                    2138   ; *                 f. Return any event posted or aborted, if any
                    2139   ; *                      else
                    2140   ; *                    Return timeout
                    2141   ; *
                    2142   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    2143   ; *                 case of any error(s).
                    2144   ; *********************************************************************************************************
                    2145   ; */
                    2146   ; /*$PAGE*/
                    2147   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    2148   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    2149   ; OS_EVENT  **pevents_rdy,
                    2150   ; void      **pmsgs_rdy,
                    2151   ; INT32U      timeout,
                    2152   ; INT8U      *perr)
                    2153   ; {
                    2154   _OSEventPendMulti:
00000E54  4E56 FFFC 2155          link      A6,#-4
00000E58  48E7 3F38 2156          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000E5C  45F9 0800 2157          lea       _OSTCBCur.L,A2
00000E60  1020      
00000E62  282E 0018 2158          move.l    24(A6),D4
00000E66  2A2E 000C 2159          move.l    12(A6),D5
00000E6A  266E 0010 2160          move.l    16(A6),A3
00000E6E  286E 0008 2161          move.l    8(A6),A4
                    2162   ; OS_EVENT  **pevents;
                    2163   ; OS_EVENT   *pevent;
                    2164   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    2165   ; OS_Q       *pq;
                    2166   ; #endif
                    2167   ; BOOLEAN     events_rdy;
                    2168   ; INT16U      events_rdy_nbr;
                    2169   ; INT8U       events_stat;
                    2170   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    2171   ; OS_CPU_SR   cpu_sr = 0u;
                    2172   ; #endif
                    2173   ; #ifdef OS_SAFETY_CRITICAL
                    2174   ; if (perr == (INT8U *)0) {
                    2175   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    2176   ; return (0u);
                    2177   ; }
                    2178   ; #endif
                    2179   ; #if (OS_ARG_CHK_EN > 0u)
                    2180   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    2181   ; *perr =  OS_ERR_PEVENT_NULL;
                    2182   ; return (0u);
                    2183   ; }
                    2184   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    2185   ; *perr =  OS_ERR_PEVENT_NULL;
                    2186   ; return (0u);
                    2187   ; }
                    2188   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    2189   ; *perr =  OS_ERR_PEVENT_NULL;
                    2190   ; return (0u);
                    2191   ; }
                    2192   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    2193   ; *perr =  OS_ERR_PEVENT_NULL;
                    2194   ; return (0u);
                    2195   ; }
                    2196   ; #endif
                    2197   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000E72  2045      2198          move.l    D5,A0
00000E74  4290      2199          clr.l     (A0)
                    2200   ; pevents     =  pevents_pend;
00000E76  2E0C      2201          move.l    A4,D7
                    2202   ; pevent      = *pevents;
00000E78  2047      2203          move.l    D7,A0
00000E7A  2410      2204          move.l    (A0),D2
                    2205   ; while  (pevent != (OS_EVENT *)0) {
                    2206   OSEventPendMulti_1:
00000E7C  4A82      2207          tst.l     D2
00000E7E  6700 0046 2208          beq       OSEventPendMulti_3
                    2209   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000E82  2042      2210          move.l    D2,A0
00000E84  1010      2211          move.b    (A0),D0
00000E86  C0BC 0000 2212          and.l     #255,D0
00000E8A  00FF      
00000E8C  5380      2213          subq.l    #1,D0
00000E8E  6522      2214          blo.s     OSEventPendMulti_10
00000E90  0C80 0000 2215          cmp.l     #5,D0
00000E94  0005      
00000E96  641A      2216          bhs.s     OSEventPendMulti_10
00000E98  E380      2217          asl.l     #1,D0
00000E9A  303B 0806 2218          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000E9E  4EFB 0002 2219          jmp       OSEventPendMulti_6(PC,D0.W)
                    2220   OSEventPendMulti_6:
00000EA2  000C      2221          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
00000EA4  000E      2222          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
00000EA6  000A      2223          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
00000EA8  0010      2224          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000EAA  0010      2225          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    2226   OSEventPendMulti_7:
                    2227   ; #if (OS_SEM_EN  > 0u)
                    2228   ; case OS_EVENT_TYPE_SEM:
                    2229   ; break;
00000EAC  6010      2230          bra.s     OSEventPendMulti_5
                    2231   OSEventPendMulti_8:
                    2232   ; #endif
                    2233   ; #if (OS_MBOX_EN > 0u)
                    2234   ; case OS_EVENT_TYPE_MBOX:
                    2235   ; break;
00000EAE  600E      2236          bra.s     OSEventPendMulti_5
                    2237   OSEventPendMulti_9:
                    2238   ; #endif
                    2239   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    2240   ; case OS_EVENT_TYPE_Q:
                    2241   ; break;
00000EB0  600C      2242          bra.s     OSEventPendMulti_5
                    2243   OSEventPendMulti_10:
                    2244   ; #endif
                    2245   ; case OS_EVENT_TYPE_MUTEX:
                    2246   ; case OS_EVENT_TYPE_FLAG:
                    2247   ; default:
                    2248   ; *perr = OS_ERR_EVENT_TYPE;
00000EB2  2044      2249          move.l    D4,A0
00000EB4  10BC 0001 2250          move.b    #1,(A0)
                    2251   ; return (0u);
00000EB8  4240      2252          clr.w     D0
00000EBA  6000 02C2 2253          bra       OSEventPendMulti_13
                    2254   OSEventPendMulti_5:
                    2255   ; }
                    2256   ; pevents++;
00000EBE  5887      2257          addq.l    #4,D7
                    2258   ; pevent = *pevents;
00000EC0  2047      2259          move.l    D7,A0
00000EC2  2410      2260          move.l    (A0),D2
00000EC4  60B6      2261          bra       OSEventPendMulti_1
                    2262   OSEventPendMulti_3:
                    2263   ; }
                    2264   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00000EC6  1039 0800 2265          move.b    _OSIntNesting.L,D0
00000ECA  0F06      
00000ECC  0C00 0000 2266          cmp.b     #0,D0
00000ED0  630C      2267          bls.s     OSEventPendMulti_14
                    2268   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00000ED2  2044      2269          move.l    D4,A0
00000ED4  10BC 0002 2270          move.b    #2,(A0)
                    2271   ; return (0u);
00000ED8  4240      2272          clr.w     D0
00000EDA  6000 02A2 2273          bra       OSEventPendMulti_13
                    2274   OSEventPendMulti_14:
                    2275   ; }
                    2276   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00000EDE  1039 0800 2277          move.b    _OSLockNesting.L,D0
00000EE2  0F08      
00000EE4  0C00 0000 2278          cmp.b     #0,D0
00000EE8  630C      2279          bls.s     OSEventPendMulti_16
                    2280   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
00000EEA  2044      2281          move.l    D4,A0
00000EEC  10BC 000D 2282          move.b    #13,(A0)
                    2283   ; return (0u);
00000EF0  4240      2284          clr.w     D0
00000EF2  6000 028A 2285          bra       OSEventPendMulti_13
                    2286   OSEventPendMulti_16:
                    2287   ; }
                    2288   ; /*$PAGE*/
                    2289   ; events_rdy     =  OS_FALSE;
00000EF6  422E FFFE 2290          clr.b     -2(A6)
                    2291   ; events_rdy_nbr =  0u;
00000EFA  4243      2292          clr.w     D3
                    2293   ; events_stat    =  OS_STAT_RDY;
00000EFC  422E FFFF 2294          clr.b     -1(A6)
                    2295   ; pevents        =  pevents_pend;
00000F00  2E0C      2296          move.l    A4,D7
                    2297   ; pevent         = *pevents;
00000F02  2047      2298          move.l    D7,A0
00000F04  2410      2299          move.l    (A0),D2
                    2300   ; OS_ENTER_CRITICAL();
00000F06  40E7      2301          dc.w      16615
00000F08  007C      2302          dc.w      124
00000F0A  0700      2303          dc.w      1792
                    2304   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    2305   OSEventPendMulti_18:
00000F0C  4A82      2306          tst.l     D2
00000F0E  6700 010A 2307          beq       OSEventPendMulti_20
                    2308   ; switch (pevent->OSEventType) {
00000F12  2042      2309          move.l    D2,A0
00000F14  1010      2310          move.b    (A0),D0
00000F16  C0BC 0000 2311          and.l     #255,D0
00000F1A  00FF      
00000F1C  5380      2312          subq.l    #1,D0
00000F1E  6500 00DE 2313          blo       OSEventPendMulti_27
00000F22  0C80 0000 2314          cmp.l     #5,D0
00000F26  0005      
00000F28  6400 00D4 2315          bhs       OSEventPendMulti_27
00000F2C  E380      2316          asl.l     #1,D0
00000F2E  303B 0806 2317          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000F32  4EFB 0002 2318          jmp       OSEventPendMulti_23(PC,D0.W)
                    2319   OSEventPendMulti_23:
00000F36  003A      2320          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
00000F38  0068      2321          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000F3A  000A      2322          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000F3C  00C8      2323          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000F3E  00C8      2324          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    2325   OSEventPendMulti_24:
                    2326   ; #if (OS_SEM_EN > 0u)
                    2327   ; case OS_EVENT_TYPE_SEM:
                    2328   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000F40  2042      2329          move.l    D2,A0
00000F42  3028 0006 2330          move.w    6(A0),D0
00000F46  0C40 0000 2331          cmp.w     #0,D0
00000F4A  631A      2332          bls.s     OSEventPendMulti_30
                    2333   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000F4C  2002      2334          move.l    D2,D0
00000F4E  5C80      2335          addq.l    #6,D0
00000F50  2040      2336          move.l    D0,A0
00000F52  5350      2337          subq.w    #1,(A0)
                    2338   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00000F54  2045      2339          move.l    D5,A0
00000F56  5885      2340          addq.l    #4,D5
00000F58  2082      2341          move.l    D2,(A0)
                    2342   ; events_rdy   =  OS_TRUE;
00000F5A  1D7C 0001 2343          move.b    #1,-2(A6)
00000F5E  FFFE      
                    2344   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000F60  429B      2345          clr.l     (A3)+
                    2346   ; events_rdy_nbr++;
00000F62  5243      2347          addq.w    #1,D3
00000F64  6006      2348          bra.s     OSEventPendMulti_31
                    2349   OSEventPendMulti_30:
                    2350   ; } else {
                    2351   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
00000F66  002E 0001 2352          or.b      #1,-1(A6)
00000F6A  FFFF      
                    2353   OSEventPendMulti_31:
                    2354   ; }
                    2355   ; break;
00000F6C  6000 00A2 2356          bra       OSEventPendMulti_22
                    2357   OSEventPendMulti_25:
                    2358   ; #endif
                    2359   ; #if (OS_MBOX_EN > 0u)
                    2360   ; case OS_EVENT_TYPE_MBOX:
                    2361   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000F70  2042      2362          move.l    D2,A0
00000F72  2028 0002 2363          move.l    2(A0),D0
00000F76  671C      2364          beq.s     OSEventPendMulti_32
                    2365   ; /* ... return available message,           ... */
                    2366   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
00000F78  2042      2367          move.l    D2,A0
00000F7A  26E8 0002 2368          move.l    2(A0),(A3)+
                    2369   ; pevent->OSEventPtr  = (void *)0;
00000F7E  2042      2370          move.l    D2,A0
00000F80  42A8 0002 2371          clr.l     2(A0)
                    2372   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
00000F84  2045      2373          move.l    D5,A0
00000F86  5885      2374          addq.l    #4,D5
00000F88  2082      2375          move.l    D2,(A0)
                    2376   ; events_rdy         =  OS_TRUE;
00000F8A  1D7C 0001 2377          move.b    #1,-2(A6)
00000F8E  FFFE      
                    2378   ; events_rdy_nbr++;
00000F90  5243      2379          addq.w    #1,D3
00000F92  6006      2380          bra.s     OSEventPendMulti_33
                    2381   OSEventPendMulti_32:
                    2382   ; } else {
                    2383   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
00000F94  002E 0002 2384          or.b      #2,-1(A6)
00000F98  FFFF      
                    2385   OSEventPendMulti_33:
                    2386   ; }
                    2387   ; break;
00000F9A  6000 0074 2388          bra       OSEventPendMulti_22
                    2389   OSEventPendMulti_26:
                    2390   ; #endif
                    2391   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    2392   ; case OS_EVENT_TYPE_Q:
                    2393   ; pq = (OS_Q *)pevent->OSEventPtr;
00000F9E  2042      2394          move.l    D2,A0
00000FA0  2C28 0002 2395          move.l    2(A0),D6
                    2396   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
00000FA4  2046      2397          move.l    D6,A0
00000FA6  3028 0016 2398          move.w    22(A0),D0
00000FAA  0C40 0000 2399          cmp.w     #0,D0
00000FAE  6300 0046 2400          bls       OSEventPendMulti_34
                    2401   ; /* ... return available message,           ... */
                    2402   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000FB2  2006      2403          move.l    D6,D0
00000FB4  0680 0000 2404          add.l     #16,D0
00000FB8  0010      
00000FBA  2040      2405          move.l    D0,A0
00000FBC  2250      2406          move.l    (A0),A1
00000FBE  5890      2407          addq.l    #4,(A0)
00000FC0  26D1      2408          move.l    (A1),(A3)+
                    2409   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000FC2  2046      2410          move.l    D6,A0
00000FC4  2246      2411          move.l    D6,A1
00000FC6  2028 0010 2412          move.l    16(A0),D0
00000FCA  B0A9 0008 2413          cmp.l     8(A1),D0
00000FCE  660A      2414          bne.s     OSEventPendMulti_36
                    2415   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
00000FD0  2046      2416          move.l    D6,A0
00000FD2  2246      2417          move.l    D6,A1
00000FD4  2368 0004 2418          move.l    4(A0),16(A1)
00000FD8  0010      
                    2419   OSEventPendMulti_36:
                    2420   ; }
                    2421   ; pq->OSQEntries--;                  /* Update number of queue entries              */
00000FDA  2006      2422          move.l    D6,D0
00000FDC  0680 0000 2423          add.l     #22,D0
00000FE0  0016      
00000FE2  2040      2424          move.l    D0,A0
00000FE4  5350      2425          subq.w    #1,(A0)
                    2426   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
00000FE6  2045      2427          move.l    D5,A0
00000FE8  5885      2428          addq.l    #4,D5
00000FEA  2082      2429          move.l    D2,(A0)
                    2430   ; events_rdy   = OS_TRUE;
00000FEC  1D7C 0001 2431          move.b    #1,-2(A6)
00000FF0  FFFE      
                    2432   ; events_rdy_nbr++;
00000FF2  5243      2433          addq.w    #1,D3
00000FF4  6006      2434          bra.s     OSEventPendMulti_35
                    2435   OSEventPendMulti_34:
                    2436   ; } else {
                    2437   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
00000FF6  002E 0004 2438          or.b      #4,-1(A6)
00000FFA  FFFF      
                    2439   OSEventPendMulti_35:
                    2440   ; }
                    2441   ; break;
00000FFC  6012      2442          bra.s     OSEventPendMulti_22
                    2443   OSEventPendMulti_27:
                    2444   ; #endif
                    2445   ; case OS_EVENT_TYPE_MUTEX:
                    2446   ; case OS_EVENT_TYPE_FLAG:
                    2447   ; default:
                    2448   ; OS_EXIT_CRITICAL();
00000FFE  46DF      2449          dc.w      18143
                    2450   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
00001000  2045      2451          move.l    D5,A0
00001002  4290      2452          clr.l     (A0)
                    2453   ; *perr        =  OS_ERR_EVENT_TYPE;
00001004  2044      2454          move.l    D4,A0
00001006  10BC 0001 2455          move.b    #1,(A0)
                    2456   ; return (events_rdy_nbr);
0000100A  3003      2457          move.w    D3,D0
0000100C  6000 0170 2458          bra       OSEventPendMulti_13
                    2459   OSEventPendMulti_22:
                    2460   ; }
                    2461   ; pevents++;
00001010  5887      2462          addq.l    #4,D7
                    2463   ; pevent = *pevents;
00001012  2047      2464          move.l    D7,A0
00001014  2410      2465          move.l    (A0),D2
00001016  6000 FEF4 2466          bra       OSEventPendMulti_18
                    2467   OSEventPendMulti_20:
                    2468   ; }
                    2469   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
0000101A  102E FFFE 2470          move.b    -2(A6),D0
0000101E  0C00 0001 2471          cmp.b     #1,D0
00001022  6610      2472          bne.s     OSEventPendMulti_38
                    2473   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
00001024  2045      2474          move.l    D5,A0
00001026  4290      2475          clr.l     (A0)
                    2476   ; OS_EXIT_CRITICAL();
00001028  46DF      2477          dc.w      18143
                    2478   ; *perr        =  OS_ERR_NONE;
0000102A  2044      2479          move.l    D4,A0
0000102C  4210      2480          clr.b     (A0)
                    2481   ; return (events_rdy_nbr);
0000102E  3003      2482          move.w    D3,D0
00001030  6000 014C 2483          bra       OSEventPendMulti_13
                    2484   OSEventPendMulti_38:
                    2485   ; }
                    2486   ; /*$PAGE*/
                    2487   ; /* Otherwise, must wait until any event occurs */
                    2488   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00001034  2052      2489          move.l    (A2),A0
00001036  102E FFFF 2490          move.b    -1(A6),D0
0000103A  803C 0080 2491          or.b      #128,D0
0000103E  8128 0032 2492          or.b      D0,50(A0)
                    2493   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    2494   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00001042  2052      2495          move.l    (A2),A0
00001044  4228 0033 2496          clr.b     51(A0)
                    2497   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00001048  2052      2498          move.l    (A2),A0
0000104A  216E 0014 2499          move.l    20(A6),46(A0)
0000104E  002E      
                    2500   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00001050  2F0C      2501          move.l    A4,-(A7)
00001052  4EB9 0000 2502          jsr       _OS_EventTaskWaitMulti
00001056  15AA      
00001058  584F      2503          addq.w    #4,A7
                    2504   ; OS_EXIT_CRITICAL();
0000105A  46DF      2505          dc.w      18143
                    2506   ; OS_Sched();                                         /* Find next highest priority task ready       */
0000105C  4EB9 0000 2507          jsr       _OS_Sched
00001060  1A22      
                    2508   ; OS_ENTER_CRITICAL();
00001062  40E7      2509          dc.w      16615
00001064  007C      2510          dc.w      124
00001066  0700      2511          dc.w      1792
                    2512   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00001068  2052      2513          move.l    (A2),A0
0000106A  1028 0033 2514          move.b    51(A0),D0
0000106E  C0BC 0000 2515          and.l     #255,D0
00001072  00FF      
00001074  0C80 0000 2516          cmp.l     #1,D0
00001078  0001      
0000107A  6700 0046 2517          beq       OSEventPendMulti_44
0000107E  6208      2518          bhi.s     OSEventPendMulti_46
00001080  4A80      2519          tst.l     D0
00001082  6710      2520          beq.s     OSEventPendMulti_42
00001084  6000 003C 2521          bra       OSEventPendMulti_44
                    2522   OSEventPendMulti_46:
00001088  0C80 0000 2523          cmp.l     #2,D0
0000108C  0002      
0000108E  6704      2524          beq.s     OSEventPendMulti_42
00001090  6000 0030 2525          bra       OSEventPendMulti_44
                    2526   OSEventPendMulti_42:
                    2527   ; case OS_STAT_PEND_OK:
                    2528   ; case OS_STAT_PEND_ABORT:
                    2529   ; pevent = OSTCBCur->OSTCBEventPtr;
00001094  2052      2530          move.l    (A2),A0
00001096  2428 001C 2531          move.l    28(A0),D2
                    2532   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
0000109A  4A82      2533          tst.l     D2
0000109C  670E      2534          beq.s     OSEventPendMulti_47
                    2535   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
0000109E  2045      2536          move.l    D5,A0
000010A0  5885      2537          addq.l    #4,D5
000010A2  2082      2538          move.l    D2,(A0)
                    2539   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
000010A4  2045      2540          move.l    D5,A0
000010A6  4290      2541          clr.l     (A0)
                    2542   ; events_rdy_nbr =  1;
000010A8  7601      2543          moveq     #1,D3
000010AA  6014      2544          bra.s     OSEventPendMulti_48
                    2545   OSEventPendMulti_47:
                    2546   ; } else {                                   /* Else NO event available, handle as timeout  */
                    2547   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
000010AC  2052      2548          move.l    (A2),A0
000010AE  117C 0001 2549          move.b    #1,51(A0)
000010B2  0033      
                    2550   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
000010B4  2F0C      2551          move.l    A4,-(A7)
000010B6  2F12      2552          move.l    (A2),-(A7)
000010B8  4EB9 0000 2553          jsr       _OS_EventTaskRemoveMulti
000010BC  169A      
000010BE  504F      2554          addq.w    #8,A7
                    2555   OSEventPendMulti_48:
                    2556   ; }
                    2557   ; break;
000010C0  600C      2558          bra.s     OSEventPendMulti_41
                    2559   OSEventPendMulti_44:
                    2560   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    2561   ; default:                                        /* ... remove task from events' wait lists     */
                    2562   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
000010C2  2F0C      2563          move.l    A4,-(A7)
000010C4  2F12      2564          move.l    (A2),-(A7)
000010C6  4EB9 0000 2565          jsr       _OS_EventTaskRemoveMulti
000010CA  169A      
000010CC  504F      2566          addq.w    #8,A7
                    2567   ; break;
                    2568   OSEventPendMulti_41:
                    2569   ; }
                    2570   ; switch (OSTCBCur->OSTCBStatPend) {
000010CE  2052      2571          move.l    (A2),A0
000010D0  1028 0033 2572          move.b    51(A0),D0
000010D4  C0BC 0000 2573          and.l     #255,D0
000010D8  00FF      
000010DA  0C80 0000 2574          cmp.l     #1,D0
000010DE  0001      
000010E0  6700 0072 2575          beq       OSEventPendMulti_53
000010E4  6208      2576          bhi.s     OSEventPendMulti_55
000010E6  4A80      2577          tst.l     D0
000010E8  6712      2578          beq.s     OSEventPendMulti_51
000010EA  6000 0068 2579          bra       OSEventPendMulti_53
                    2580   OSEventPendMulti_55:
000010EE  0C80 0000 2581          cmp.l     #2,D0
000010F2  0002      
000010F4  6700 0054 2582          beq       OSEventPendMulti_52
000010F8  6000 005A 2583          bra       OSEventPendMulti_53
                    2584   OSEventPendMulti_51:
                    2585   ; case OS_STAT_PEND_OK:
                    2586   ; switch (pevent->OSEventType) {             /* Return event's message                      */
000010FC  2042      2587          move.l    D2,A0
000010FE  1010      2588          move.b    (A0),D0
00001100  C0BC 0000 2589          and.l     #255,D0
00001104  00FF      
00001106  5380      2590          subq.l    #1,D0
00001108  6528      2591          blo.s     OSEventPendMulti_62
0000110A  0C80 0000 2592          cmp.l     #5,D0
0000110E  0005      
00001110  6420      2593          bhs.s     OSEventPendMulti_62
00001112  E380      2594          asl.l     #1,D0
00001114  303B 0806 2595          move.w    OSEventPendMulti_58(PC,D0.L),D0
00001118  4EFB 0002 2596          jmp       OSEventPendMulti_58(PC,D0.W)
                    2597   OSEventPendMulti_58:
0000111C  000E      2598          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
0000111E  000E      2599          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00001120  000A      2600          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
00001122  0016      2601          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00001124  0016      2602          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    2603   OSEventPendMulti_59:
                    2604   ; #if (OS_SEM_EN > 0u)
                    2605   ; case OS_EVENT_TYPE_SEM:
                    2606   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00001126  429B      2607          clr.l     (A3)+
                    2608   ; break;
00001128  601A      2609          bra.s     OSEventPendMulti_57
                    2610   OSEventPendMulti_60:
                    2611   ; #endif
                    2612   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2613   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2614   ; case OS_EVENT_TYPE_MBOX:
                    2615   ; case OS_EVENT_TYPE_Q:
                    2616   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
0000112A  2052      2617          move.l    (A2),A0
0000112C  26E8 0024 2618          move.l    36(A0),(A3)+
                    2619   ; break;
00001130  6012      2620          bra.s     OSEventPendMulti_57
                    2621   OSEventPendMulti_62:
                    2622   ; #endif
                    2623   ; case OS_EVENT_TYPE_MUTEX:
                    2624   ; case OS_EVENT_TYPE_FLAG:
                    2625   ; default:
                    2626   ; OS_EXIT_CRITICAL();
00001132  46DF      2627          dc.w      18143
                    2628   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00001134  2045      2629          move.l    D5,A0
00001136  4290      2630          clr.l     (A0)
                    2631   ; *perr        =  OS_ERR_EVENT_TYPE;
00001138  2044      2632          move.l    D4,A0
0000113A  10BC 0001 2633          move.b    #1,(A0)
                    2634   ; return (events_rdy_nbr);
0000113E  3003      2635          move.w    D3,D0
00001140  6000 003C 2636          bra       OSEventPendMulti_13
                    2637   OSEventPendMulti_57:
                    2638   ; }
                    2639   ; *perr = OS_ERR_NONE;
00001144  2044      2640          move.l    D4,A0
00001146  4210      2641          clr.b     (A0)
                    2642   ; break;
00001148  6012      2643          bra.s     OSEventPendMulti_50
                    2644   OSEventPendMulti_52:
                    2645   ; case OS_STAT_PEND_ABORT:
                    2646   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
0000114A  429B      2647          clr.l     (A3)+
                    2648   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
0000114C  2044      2649          move.l    D4,A0
0000114E  10BC 000E 2650          move.b    #14,(A0)
                    2651   ; break;
00001152  6008      2652          bra.s     OSEventPendMulti_50
                    2653   OSEventPendMulti_53:
                    2654   ; case OS_STAT_PEND_TO:
                    2655   ; default:
                    2656   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00001154  429B      2657          clr.l     (A3)+
                    2658   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00001156  2044      2659          move.l    D4,A0
00001158  10BC 000A 2660          move.b    #10,(A0)
                    2661   ; break;
                    2662   OSEventPendMulti_50:
                    2663   ; }
                    2664   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
0000115C  2052      2665          move.l    (A2),A0
0000115E  4228 0032 2666          clr.b     50(A0)
                    2667   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
00001162  2052      2668          move.l    (A2),A0
00001164  4228 0033 2669          clr.b     51(A0)
                    2670   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00001168  2052      2671          move.l    (A2),A0
0000116A  42A8 001C 2672          clr.l     28(A0)
                    2673   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000116E  2052      2674          move.l    (A2),A0
00001170  42A8 0020 2675          clr.l     32(A0)
                    2676   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2677   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2678   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00001174  2052      2679          move.l    (A2),A0
00001176  42A8 0024 2680          clr.l     36(A0)
                    2681   ; #endif
                    2682   ; OS_EXIT_CRITICAL();
0000117A  46DF      2683          dc.w      18143
                    2684   ; return (events_rdy_nbr);
0000117C  3003      2685          move.w    D3,D0
                    2686   OSEventPendMulti_13:
0000117E  4CDF 1CFC 2687          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00001182  4E5E      2688          unlk      A6
00001184  4E75      2689          rts
                    2690   ; }
                    2691   ; #endif
                    2692   ; /*$PAGE*/
                    2693   ; /*
                    2694   ; *********************************************************************************************************
                    2695   ; *                                           INITIALIZATION
                    2696   ; *
                    2697   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2698   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2699   ; *
                    2700   ; * Arguments  : none
                    2701   ; *
                    2702   ; * Returns    : none
                    2703   ; *********************************************************************************************************
                    2704   ; */
                    2705   ; void  OSInit (void)
                    2706   ; {
                    2707   _OSInit:
                    2708   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00001186  4EB8 0CFC 2709          jsr       _OSInitHookBegin
                    2710   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
0000118A  4EB9 0000 2711          jsr       @ucos_ii_OS_InitMisc
0000118E  17E2      
                    2712   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
00001190  4EB9 0000 2713          jsr       @ucos_ii_OS_InitRdyList
00001194  1826      
                    2714   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00001196  4EB9 0000 2715          jsr       @ucos_ii_OS_InitTCBList
0000119A  191E      
                    2716   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
0000119C  4EB9 0000 2717          jsr       @ucos_ii_OS_InitEventList
000011A0  173A      
                    2718   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2719   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
000011A2  4EB9 0000 2720          jsr       _OS_FlagInit
000011A6  2730      
                    2721   ; #endif
                    2722   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2723   ; OS_MemInit();                                                /* Initialize the memory manager            */
000011A8  4EB9 0000 2724          jsr       _OS_MemInit
000011AC  2FEE      
                    2725   ; #endif
                    2726   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2727   ; OS_QInit();                                                  /* Initialize the message queue structures  */
000011AE  4EB9 0000 2728          jsr       _OS_QInit
000011B2  4154      
                    2729   ; #endif
                    2730   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000011B4  4EB9 0000 2731          jsr       @ucos_ii_OS_InitTaskIdle
000011B8  1866      
                    2732   ; #if OS_TASK_STAT_EN > 0u
                    2733   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
000011BA  4EB9 0000 2734          jsr       @ucos_ii_OS_InitTaskStat
000011BE  18C2      
                    2735   ; #endif
                    2736   ; #if OS_TMR_EN > 0u
                    2737   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
000011C0  4EB9 0000 2738          jsr       _OSTmr_Init
000011C4  5AA6      
                    2739   ; #endif
                    2740   ; OSInitHookEnd();                                             /* Call port specific init. code            */
000011C6  4EB8 0CFE 2741          jsr       _OSInitHookEnd
000011CA  4E75      2742          rts
                    2743   ; #if OS_DEBUG_EN > 0u
                    2744   ; OSDebugInit();
                    2745   ; #endif
                    2746   ; }
                    2747   ; /*$PAGE*/
                    2748   ; /*
                    2749   ; *********************************************************************************************************
                    2750   ; *                                              ENTER ISR
                    2751   ; *
                    2752   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2753   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2754   ; *              only perform rescheduling at the last nested ISR.
                    2755   ; *
                    2756   ; * Arguments  : none
                    2757   ; *
                    2758   ; * Returns    : none
                    2759   ; *
                    2760   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2761   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2762   ; *                 OSIntNesting has been declared 'global'.
                    2763   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2764   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2765   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2766   ; *                 end of the ISR.
                    2767   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2768   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2769   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2770   ; *********************************************************************************************************
                    2771   ; */
                    2772   ; void  OSIntEnter (void)
                    2773   ; {
                    2774   _OSIntEnter:
                    2775   ; if (OSRunning == OS_TRUE) {
000011CC  1039 0800 2776          move.b    _OSRunning.L,D0
000011D0  0F18      
000011D2  0C00 0001 2777          cmp.b     #1,D0
000011D6  6612      2778          bne.s     OSIntEnter_3
                    2779   ; if (OSIntNesting < 255u) {
000011D8  1039 0800 2780          move.b    _OSIntNesting.L,D0
000011DC  0F06      
000011DE  0C00 00FF 2781          cmp.b     #255,D0
000011E2  6406      2782          bhs.s     OSIntEnter_3
                    2783   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
000011E4  5239 0800 2784          addq.b    #1,_OSIntNesting.L
000011E8  0F06      
                    2785   OSIntEnter_3:
000011EA  4E75      2786          rts
                    2787   ; }
                    2788   ; }
                    2789   ; }
                    2790   ; /*$PAGE*/
                    2791   ; /*
                    2792   ; *********************************************************************************************************
                    2793   ; *                                              EXIT ISR
                    2794   ; *
                    2795   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2796   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2797   ; *              a new, high-priority task, is ready to run.
                    2798   ; *
                    2799   ; * Arguments  : none
                    2800   ; *
                    2801   ; * Returns    : none
                    2802   ; *
                    2803   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2804   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2805   ; *                 end of the ISR.
                    2806   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2807   ; *********************************************************************************************************
                    2808   ; */
                    2809   ; void  OSIntExit (void)
                    2810   ; {
                    2811   _OSIntExit:
                    2812   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2813   ; OS_CPU_SR  cpu_sr = 0u;
                    2814   ; #endif
                    2815   ; if (OSRunning == OS_TRUE) {
000011EC  1039 0800 2816          move.b    _OSRunning.L,D0
000011F0  0F18      
000011F2  0C00 0001 2817          cmp.b     #1,D0
000011F6  6600 0078 2818          bne       OSIntExit_1
                    2819   ; OS_ENTER_CRITICAL();
000011FA  40E7      2820          dc.w      16615
000011FC  007C      2821          dc.w      124
000011FE  0700      2822          dc.w      1792
                    2823   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00001200  1039 0800 2824          move.b    _OSIntNesting.L,D0
00001204  0F06      
00001206  0C00 0000 2825          cmp.b     #0,D0
0000120A  6306      2826          bls.s     OSIntExit_3
                    2827   ; OSIntNesting--;
0000120C  5339 0800 2828          subq.b    #1,_OSIntNesting.L
00001210  0F06      
                    2829   OSIntExit_3:
                    2830   ; }
                    2831   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00001212  1039 0800 2832          move.b    _OSIntNesting.L,D0
00001216  0F06      
00001218  6600 0054 2833          bne       OSIntExit_9
                    2834   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
0000121C  1039 0800 2835          move.b    _OSLockNesting.L,D0
00001220  0F08      
00001222  664A      2836          bne.s     OSIntExit_9
                    2837   ; OS_SchedNew();
00001224  4EB9 0000 2838          jsr       @ucos_ii_OS_SchedNew
00001228  1A86      
                    2839   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0000122A  1039 0800 2840          move.b    _OSPrioHighRdy.L,D0
0000122E  0F0C      
00001230  C0BC 0000 2841          and.l     #255,D0
00001234  00FF      
00001236  E588      2842          lsl.l     #2,D0
00001238  41F9 0800 2843          lea       _OSTCBPrioTbl.L,A0
0000123C  1030      
0000123E  23F0 0800 2844          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001242  0800 1028 
                    2845   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00001246  1039 0800 2846          move.b    _OSPrioHighRdy.L,D0
0000124A  0F0C      
0000124C  B039 0800 2847          cmp.b     _OSPrioCur.L,D0
00001250  0F0A      
00001252  671A      2848          beq.s     OSIntExit_9
                    2849   ; #if OS_TASK_PROFILE_EN > 0u
                    2850   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00001254  2039 0800 2851          move.l    _OSTCBHighRdy.L,D0
00001258  1028      
0000125A  0680 0000 2852          add.l     #58,D0
0000125E  003A      
00001260  2040      2853          move.l    D0,A0
00001262  5290      2854          addq.l    #1,(A0)
                    2855   ; #endif
                    2856   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00001264  52B9 0800 2857          addq.l    #1,_OSCtxSwCtr.L
00001268  0CD6      
                    2858   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
0000126A  4EB8 0B2A 2859          jsr       _OSIntCtxSw
                    2860   OSIntExit_9:
                    2861   ; }
                    2862   ; }
                    2863   ; }
                    2864   ; OS_EXIT_CRITICAL();
0000126E  46DF      2865          dc.w      18143
                    2866   OSIntExit_1:
00001270  4E75      2867          rts
                    2868   ; }
                    2869   ; }
                    2870   ; /*$PAGE*/
                    2871   ; /*
                    2872   ; *********************************************************************************************************
                    2873   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2874   ; *
                    2875   ; * Description: This function is called by the application code to indicate that all initialization has
                    2876   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2877   ; *
                    2878   ; * Arguments  : none
                    2879   ; *
                    2880   ; * Returns    : none
                    2881   ; *
                    2882   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2883   ; *                 create kernel objects.
                    2884   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2885   ; *********************************************************************************************************
                    2886   ; */
                    2887   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2888   ; void  OSSafetyCriticalStart (void)
                    2889   ; {
                    2890   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2891   ; }
                    2892   ; #endif
                    2893   ; /*$PAGE*/
                    2894   ; /*
                    2895   ; *********************************************************************************************************
                    2896   ; *                                         PREVENT SCHEDULING
                    2897   ; *
                    2898   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2899   ; *              to prevent context switches until you are ready to permit context switching.
                    2900   ; *
                    2901   ; * Arguments  : none
                    2902   ; *
                    2903   ; * Returns    : none
                    2904   ; *
                    2905   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2906   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2907   ; *********************************************************************************************************
                    2908   ; */
                    2909   ; #if OS_SCHED_LOCK_EN > 0u
                    2910   ; void  OSSchedLock (void)
                    2911   ; {
                    2912   _OSSchedLock:
                    2913   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2914   ; OS_CPU_SR  cpu_sr = 0u;
                    2915   ; #endif
                    2916   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
00001272  1039 0800 2917          move.b    _OSRunning.L,D0
00001276  0F18      
00001278  0C00 0001 2918          cmp.b     #1,D0
0000127C  6622      2919          bne.s     OSSchedLock_1
                    2920   ; OS_ENTER_CRITICAL();
0000127E  40E7      2921          dc.w      16615
00001280  007C      2922          dc.w      124
00001282  0700      2923          dc.w      1792
                    2924   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00001284  1039 0800 2925          move.b    _OSIntNesting.L,D0
00001288  0F06      
0000128A  6612      2926          bne.s     OSSchedLock_5
                    2927   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
0000128C  1039 0800 2928          move.b    _OSLockNesting.L,D0
00001290  0F08      
00001292  0C00 00FF 2929          cmp.b     #255,D0
00001296  6406      2930          bhs.s     OSSchedLock_5
                    2931   ; OSLockNesting++;                 /* Increment lock nesting level                       */
00001298  5239 0800 2932          addq.b    #1,_OSLockNesting.L
0000129C  0F08      
                    2933   OSSchedLock_5:
                    2934   ; }
                    2935   ; }
                    2936   ; OS_EXIT_CRITICAL();
0000129E  46DF      2937          dc.w      18143
                    2938   OSSchedLock_1:
000012A0  4E75      2939          rts
                    2940   ; }
                    2941   ; }
                    2942   ; #endif
                    2943   ; /*$PAGE*/
                    2944   ; /*
                    2945   ; *********************************************************************************************************
                    2946   ; *                                          ENABLE SCHEDULING
                    2947   ; *
                    2948   ; * Description: This function is used to re-allow rescheduling.
                    2949   ; *
                    2950   ; * Arguments  : none
                    2951   ; *
                    2952   ; * Returns    : none
                    2953   ; *
                    2954   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2955   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2956   ; *********************************************************************************************************
                    2957   ; */
                    2958   ; #if OS_SCHED_LOCK_EN > 0u
                    2959   ; void  OSSchedUnlock (void)
                    2960   ; {
                    2961   _OSSchedUnlock:
                    2962   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2963   ; OS_CPU_SR  cpu_sr = 0u;
                    2964   ; #endif
                    2965   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000012A2  1039 0800 2966          move.b    _OSRunning.L,D0
000012A6  0F18      
000012A8  0C00 0001 2967          cmp.b     #1,D0
000012AC  6600 003E 2968          bne       OSSchedUnlock_4
                    2969   ; OS_ENTER_CRITICAL();
000012B0  40E7      2970          dc.w      16615
000012B2  007C      2971          dc.w      124
000012B4  0700      2972          dc.w      1792
                    2973   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000012B6  1039 0800 2974          move.b    _OSIntNesting.L,D0
000012BA  0F06      
000012BC  662C      2975          bne.s     OSSchedUnlock_3
                    2976   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000012BE  1039 0800 2977          move.b    _OSLockNesting.L,D0
000012C2  0F08      
000012C4  0C00 0000 2978          cmp.b     #0,D0
000012C8  631C      2979          bls.s     OSSchedUnlock_5
                    2980   ; OSLockNesting--;                           /* Decrement lock nesting level             */
000012CA  5339 0800 2981          subq.b    #1,_OSLockNesting.L
000012CE  0F08      
                    2982   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000012D0  1039 0800 2983          move.b    _OSLockNesting.L,D0
000012D4  0F08      
000012D6  660A      2984          bne.s     OSSchedUnlock_7
                    2985   ; OS_EXIT_CRITICAL();
000012D8  46DF      2986          dc.w      18143
                    2987   ; OS_Sched();                            /* See if a HPT is ready                    */
000012DA  4EB9 0000 2988          jsr       _OS_Sched
000012DE  1A22      
000012E0  6002      2989          bra.s     OSSchedUnlock_8
                    2990   OSSchedUnlock_7:
                    2991   ; } else {
                    2992   ; OS_EXIT_CRITICAL();
000012E2  46DF      2993          dc.w      18143
                    2994   OSSchedUnlock_8:
000012E4  6002      2995          bra.s     OSSchedUnlock_6
                    2996   OSSchedUnlock_5:
                    2997   ; }
                    2998   ; } else {
                    2999   ; OS_EXIT_CRITICAL();
000012E6  46DF      3000          dc.w      18143
                    3001   OSSchedUnlock_6:
000012E8  6002      3002          bra.s     OSSchedUnlock_4
                    3003   OSSchedUnlock_3:
                    3004   ; }
                    3005   ; } else {
                    3006   ; OS_EXIT_CRITICAL();
000012EA  46DF      3007          dc.w      18143
                    3008   OSSchedUnlock_4:
000012EC  4E75      3009          rts
                    3010   ; }
                    3011   ; }
                    3012   ; }
                    3013   ; #endif
                    3014   ; /*$PAGE*/
                    3015   ; /*
                    3016   ; *********************************************************************************************************
                    3017   ; *                                         START MULTITASKING
                    3018   ; *
                    3019   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    3020   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    3021   ; *              and you MUST have created at least one task.
                    3022   ; *
                    3023   ; * Arguments  : none
                    3024   ; *
                    3025   ; * Returns    : none
                    3026   ; *
                    3027   ; * Note       : OSStartHighRdy() MUST:
                    3028   ; *                 a) Call OSTaskSwHook() then,
                    3029   ; *                 b) Set OSRunning to OS_TRUE.
                    3030   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    3031   ; *                 d_ Execute the task.
                    3032   ; *********************************************************************************************************
                    3033   ; */
                    3034   ; void  OSStart (void)
                    3035   ; {
                    3036   _OSStart:
                    3037   ; if (OSRunning == OS_FALSE) {
000012EE  1039 0800 3038          move.b    _OSRunning.L,D0
000012F2  0F18      
000012F4  663A      3039          bne.s     OSStart_1
                    3040   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
000012F6  4EB9 0000 3041          jsr       @ucos_ii_OS_SchedNew
000012FA  1A86      
                    3042   ; OSPrioCur     = OSPrioHighRdy;
000012FC  13F9 0800 3043          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
00001300  0F0C 0800 
00001304  0F0A      
                    3044   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00001306  1039 0800 3045          move.b    _OSPrioHighRdy.L,D0
0000130A  0F0C      
0000130C  C0BC 0000 3046          and.l     #255,D0
00001310  00FF      
00001312  E588      3047          lsl.l     #2,D0
00001314  41F9 0800 3048          lea       _OSTCBPrioTbl.L,A0
00001318  1030      
0000131A  23F0 0800 3049          move.l    0(A0,D0.L),_OSTCBHighRdy.L
0000131E  0800 1028 
                    3050   ; OSTCBCur      = OSTCBHighRdy;
00001322  23F9 0800 3051          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
00001326  1028 0800 
0000132A  1020      
                    3052   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
0000132C  4EB8 0AE0 3053          jsr       _OSStartHighRdy
                    3054   OSStart_1:
00001330  4E75      3055          rts
                    3056   ; }
                    3057   ; }
                    3058   ; /*$PAGE*/
                    3059   ; /*
                    3060   ; *********************************************************************************************************
                    3061   ; *                                      STATISTICS INITIALIZATION
                    3062   ; *
                    3063   ; * Description: This function is called by your application to establish CPU usage by first determining
                    3064   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    3065   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    3066   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    3067   ; *              determined by:
                    3068   ; *
                    3069   ; *                                             OSIdleCtr
                    3070   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    3071   ; *                                            OSIdleCtrMax
                    3072   ; *
                    3073   ; * Arguments  : none
                    3074   ; *
                    3075   ; * Returns    : none
                    3076   ; *********************************************************************************************************
                    3077   ; */
                    3078   ; #if OS_TASK_STAT_EN > 0u
                    3079   ; void  OSStatInit (void)
                    3080   ; {
                    3081   _OSStatInit:
                    3082   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3083   ; OS_CPU_SR  cpu_sr = 0u;
                    3084   ; #endif
                    3085   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
00001332  4878 0002 3086          pea       2
00001336  4EB9 0000 3087          jsr       _OSTimeDly
0000133A  521E      
0000133C  584F      3088          addq.w    #4,A7
                    3089   ; OS_ENTER_CRITICAL();
0000133E  40E7      3090          dc.w      16615
00001340  007C      3091          dc.w      124
00001342  0700      3092          dc.w      1792
                    3093   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00001344  42B9 0800 3094          clr.l     _OSIdleCtr.L
00001348  0F1C      
                    3095   ; OS_EXIT_CRITICAL();
0000134A  46DF      3096          dc.w      18143
                    3097   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
0000134C  4878 000A 3098          pea       10
00001350  4EB9 0000 3099          jsr       _OSTimeDly
00001354  521E      
00001356  584F      3100          addq.w    #4,A7
                    3101   ; OS_ENTER_CRITICAL();
00001358  40E7      3102          dc.w      16615
0000135A  007C      3103          dc.w      124
0000135C  0700      3104          dc.w      1792
                    3105   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0000135E  23F9 0800 3106          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
00001362  0F1C 0800 
00001366  0DFC      
                    3107   ; OSStatRdy    = OS_TRUE;
00001368  13FC 0001 3108          move.b    #1,_OSStatRdy.L
0000136C  0800 0E04 
                    3109   ; OS_EXIT_CRITICAL();
00001370  46DF      3110          dc.w      18143
00001372  4E75      3111          rts
                    3112   ; }
                    3113   ; #endif
                    3114   ; /*$PAGE*/
                    3115   ; /*
                    3116   ; *********************************************************************************************************
                    3117   ; *                                         PROCESS SYSTEM TICK
                    3118   ; *
                    3119   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    3120   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    3121   ; *              called by a high priority task.
                    3122   ; *
                    3123   ; * Arguments  : none
                    3124   ; *
                    3125   ; * Returns    : none
                    3126   ; *********************************************************************************************************
                    3127   ; */
                    3128   ; void  OSTimeTick (void)
                    3129   ; {
                    3130   _OSTimeTick:
00001374  2F02      3131          move.l    D2,-(A7)
                    3132   ; OS_TCB    *ptcb;
                    3133   ; #if OS_TICK_STEP_EN > 0u
                    3134   ; BOOLEAN    step;
                    3135   ; #endif
                    3136   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    3137   ; OS_CPU_SR  cpu_sr = 0u;
                    3138   ; #endif
                    3139   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    3140   ; OSTimeTickHook();                                      /* Call user definable hook                     */
00001376  4EB8 0D24 3141          jsr       _OSTimeTickHook
                    3142   ; #endif
                    3143   ; #if OS_TIME_GET_SET_EN > 0u
                    3144   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
0000137A  40E7      3145          dc.w      16615
0000137C  007C      3146          dc.w      124
0000137E  0700      3147          dc.w      1792
                    3148   ; OSTime++;
00001380  52B9 0800 3149          addq.l    #1,_OSTime.L
00001384  1976      
                    3150   ; OS_EXIT_CRITICAL();
00001386  46DF      3151          dc.w      18143
                    3152   ; #endif
                    3153   ; if (OSRunning == OS_TRUE) {
00001388  1039 0800 3154          move.b    _OSRunning.L,D0
0000138C  0F18      
0000138E  0C00 0001 3155          cmp.b     #1,D0
00001392  6600 00A2 3156          bne       OSTimeTick_5
                    3157   ; #if OS_TICK_STEP_EN > 0u
                    3158   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    3159   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    3160   ; step = OS_TRUE;
                    3161   ; break;
                    3162   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    3163   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    3164   ; break;
                    3165   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    3166   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    3167   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    3168   ; break;
                    3169   ; default:                                       /* Invalid case, correct situation              */
                    3170   ; step            = OS_TRUE;
                    3171   ; OSTickStepState = OS_TICK_STEP_DIS;
                    3172   ; break;
                    3173   ; }
                    3174   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    3175   ; return;
                    3176   ; }
                    3177   ; #endif
                    3178   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
00001396  2439 0800 3179          move.l    _OSTCBList.L,D2
0000139A  102C      
                    3180   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    3181   OSTimeTick_3:
0000139C  2042      3182          move.l    D2,A0
0000139E  1028 0034 3183          move.b    52(A0),D0
000013A2  0C00 003F 3184          cmp.b     #63,D0
000013A6  6700 008E 3185          beq       OSTimeTick_5
                    3186   ; OS_ENTER_CRITICAL();
000013AA  40E7      3187          dc.w      16615
000013AC  007C      3188          dc.w      124
000013AE  0700      3189          dc.w      1792
                    3190   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
000013B0  2042      3191          move.l    D2,A0
000013B2  2028 002E 3192          move.l    46(A0),D0
000013B6  6700 0072 3193          beq       OSTimeTick_12
                    3194   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
000013BA  2002      3195          move.l    D2,D0
000013BC  0680 0000 3196          add.l     #46,D0
000013C0  002E      
000013C2  2040      3197          move.l    D0,A0
000013C4  5390      3198          subq.l    #1,(A0)
                    3199   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
000013C6  2042      3200          move.l    D2,A0
000013C8  2028 002E 3201          move.l    46(A0),D0
000013CC  6600 005C 3202          bne       OSTimeTick_12
                    3203   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000013D0  2042      3204          move.l    D2,A0
000013D2  1028 0032 3205          move.b    50(A0),D0
000013D6  C03C 0037 3206          and.b     #55,D0
000013DA  6714      3207          beq.s     OSTimeTick_10
                    3208   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000013DC  2042      3209          move.l    D2,A0
000013DE  7037      3210          moveq     #55,D0
000013E0  4600      3211          not.b     D0
000013E2  C128 0032 3212          and.b     D0,50(A0)
                    3213   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
000013E6  2042      3214          move.l    D2,A0
000013E8  117C 0001 3215          move.b    #1,51(A0)
000013EC  0033      
000013EE  6006      3216          bra.s     OSTimeTick_11
                    3217   OSTimeTick_10:
                    3218   ; } else {
                    3219   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000013F0  2042      3220          move.l    D2,A0
000013F2  4228 0033 3221          clr.b     51(A0)
                    3222   OSTimeTick_11:
                    3223   ; }
                    3224   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
000013F6  2042      3225          move.l    D2,A0
000013F8  1028 0032 3226          move.b    50(A0),D0
000013FC  C03C 0008 3227          and.b     #8,D0
00001400  6628      3228          bne.s     OSTimeTick_12
                    3229   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
00001402  2042      3230          move.l    D2,A0
00001404  1028 0038 3231          move.b    56(A0),D0
00001408  8139 0800 3232          or.b      D0,_OSRdyGrp.L
0000140C  0F0E      
                    3233   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000140E  2042      3234          move.l    D2,A0
00001410  1028 0036 3235          move.b    54(A0),D0
00001414  C0BC 0000 3236          and.l     #255,D0
00001418  00FF      
0000141A  41F9 0800 3237          lea       _OSRdyTbl.L,A0
0000141E  0F10      
00001420  2242      3238          move.l    D2,A1
00001422  1229 0037 3239          move.b    55(A1),D1
00001426  8330 0800 3240          or.b      D1,0(A0,D0.L)
                    3241   OSTimeTick_12:
                    3242   ; }
                    3243   ; }
                    3244   ; }
                    3245   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
0000142A  2042      3246          move.l    D2,A0
0000142C  2428 0014 3247          move.l    20(A0),D2
                    3248   ; OS_EXIT_CRITICAL();
00001430  46DF      3249          dc.w      18143
00001432  6000 FF68 3250          bra       OSTimeTick_3
                    3251   OSTimeTick_5:
00001436  241F      3252          move.l    (A7)+,D2
00001438  4E75      3253          rts
                    3254   ; }
                    3255   ; }
                    3256   ; }
                    3257   ; /*$PAGE*/
                    3258   ; /*
                    3259   ; *********************************************************************************************************
                    3260   ; *                                             GET VERSION
                    3261   ; *
                    3262   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    3263   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    3264   ; *              2.01.00 would be returned as 20100.
                    3265   ; *
                    3266   ; * Arguments  : none
                    3267   ; *
                    3268   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    3269   ; *********************************************************************************************************
                    3270   ; */
                    3271   ; INT16U  OSVersion (void)
                    3272   ; {
                    3273   _OSVersion:
                    3274   ; return (OS_VERSION);
0000143A  303C 7217 3275          move.w    #29207,D0
0000143E  4E75      3276          rts
                    3277   ; }
                    3278   ; /*$PAGE*/
                    3279   ; /*
                    3280   ; *********************************************************************************************************
                    3281   ; *                                           DUMMY FUNCTION
                    3282   ; *
                    3283   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    3284   ; *
                    3285   ; * Arguments  : none
                    3286   ; *
                    3287   ; * Returns    : none
                    3288   ; *********************************************************************************************************
                    3289   ; */
                    3290   ; #if OS_TASK_DEL_EN > 0u
                    3291   ; void  OS_Dummy (void)
                    3292   ; {
                    3293   _OS_Dummy:
00001440  4E75      3294          rts
                    3295   ; }
                    3296   ; #endif
                    3297   ; /*$PAGE*/
                    3298   ; /*
                    3299   ; *********************************************************************************************************
                    3300   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    3301   ; *
                    3302   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    3303   ; *              waiting for an event to occur.
                    3304   ; *
                    3305   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    3306   ; *
                    3307   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    3308   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    3309   ; *                          service functions.
                    3310   ; *
                    3311   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    3312   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    3313   ; *
                    3314   ; *              pend_stat   is used to indicate the readied task's pending status:
                    3315   ; *
                    3316   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    3317   ; *                                               an abort.
                    3318   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    3319   ; *
                    3320   ; * Returns    : none
                    3321   ; *
                    3322   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3323   ; *********************************************************************************************************
                    3324   ; */
                    3325   ; #if (OS_EVENT_EN)
                    3326   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    3327   ; void      *pmsg,
                    3328   ; INT8U      msk,
                    3329   ; INT8U      pend_stat)
                    3330   ; {
                    3331   _OS_EventTaskRdy:
00001442  4E56 FFFC 3332          link      A6,#-4
00001446  48E7 3C00 3333          movem.l   D2/D3/D4/D5,-(A7)
0000144A  262E 0008 3334          move.l    8(A6),D3
                    3335   ; OS_TCB   *ptcb;
                    3336   ; INT8U     y;
                    3337   ; INT8U     x;
                    3338   ; INT8U     prio;
                    3339   ; #if OS_LOWEST_PRIO > 63u
                    3340   ; OS_PRIO  *ptbl;
                    3341   ; #endif
                    3342   ; #if OS_LOWEST_PRIO <= 63u
                    3343   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
0000144E  2043      3344          move.l    D3,A0
00001450  1028 0008 3345          move.b    8(A0),D0
00001454  C0BC 0000 3346          and.l     #255,D0
00001458  00FF      
0000145A  41F9 0000 3347          lea       _OSUnMapTbl.L,A0
0000145E  6B22      
00001460  1830 0800 3348          move.b    0(A0,D0.L),D4
                    3349   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00001464  2043      3350          move.l    D3,A0
00001466  C8BC 0000 3351          and.l     #255,D4
0000146A  00FF      
0000146C  D1C4      3352          add.l     D4,A0
0000146E  1028 000A 3353          move.b    10(A0),D0
00001472  C0BC 0000 3354          and.l     #255,D0
00001476  00FF      
00001478  41F9 0000 3355          lea       _OSUnMapTbl.L,A0
0000147C  6B22      
0000147E  1D70 0800 3356          move.b    0(A0,D0.L),-1(A6)
00001482  FFFF      
                    3357   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001484  1004      3358          move.b    D4,D0
00001486  E708      3359          lsl.b     #3,D0
00001488  D02E FFFF 3360          add.b     -1(A6),D0
0000148C  1A00      3361          move.b    D0,D5
                    3362   ; #else
                    3363   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    3364   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    3365   ; } else {
                    3366   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    3367   ; }
                    3368   ; ptbl = &pevent->OSEventTbl[y];
                    3369   ; if ((*ptbl & 0xFFu) != 0u) {
                    3370   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    3371   ; } else {
                    3372   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    3373   ; }
                    3374   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    3375   ; #endif
                    3376   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0000148E  CABC 0000 3377          and.l     #255,D5
00001492  00FF      
00001494  2005      3378          move.l    D5,D0
00001496  E588      3379          lsl.l     #2,D0
00001498  41F9 0800 3380          lea       _OSTCBPrioTbl.L,A0
0000149C  1030      
0000149E  2430 0800 3381          move.l    0(A0,D0.L),D2
                    3382   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
000014A2  2042      3383          move.l    D2,A0
000014A4  42A8 002E 3384          clr.l     46(A0)
                    3385   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    3386   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000014A8  2042      3387          move.l    D2,A0
000014AA  216E 000C 3388          move.l    12(A6),36(A0)
000014AE  0024      
                    3389   ; #else
                    3390   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    3391   ; #endif
                    3392   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000014B0  2042      3393          move.l    D2,A0
000014B2  102E 0013 3394          move.b    19(A6),D0
000014B6  4600      3395          not.b     D0
000014B8  C128 0032 3396          and.b     D0,50(A0)
                    3397   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000014BC  2042      3398          move.l    D2,A0
000014BE  116E 0017 3399          move.b    23(A6),51(A0)
000014C2  0033      
                    3400   ; /* See if task is ready (could be susp'd)      */
                    3401   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000014C4  2042      3402          move.l    D2,A0
000014C6  1028 0032 3403          move.b    50(A0),D0
000014CA  C03C 0008 3404          and.b     #8,D0
000014CE  6622      3405          bne.s     OS_EventTaskRdy_1
                    3406   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000014D0  2042      3407          move.l    D2,A0
000014D2  1028 0038 3408          move.b    56(A0),D0
000014D6  8139 0800 3409          or.b      D0,_OSRdyGrp.L
000014DA  0F0E      
                    3410   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000014DC  C8BC 0000 3411          and.l     #255,D4
000014E0  00FF      
000014E2  41F9 0800 3412          lea       _OSRdyTbl.L,A0
000014E6  0F10      
000014E8  2242      3413          move.l    D2,A1
000014EA  1029 0037 3414          move.b    55(A1),D0
000014EE  8130 4800 3415          or.b      D0,0(A0,D4.L)
                    3416   OS_EventTaskRdy_1:
                    3417   ; }
                    3418   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000014F2  2F03      3419          move.l    D3,-(A7)
000014F4  2F02      3420          move.l    D2,-(A7)
000014F6  4EB9 0000 3421          jsr       _OS_EventTaskRemove
000014FA  1648      
000014FC  504F      3422          addq.w    #8,A7
                    3423   ; #if (OS_EVENT_MULTI_EN > 0u)
                    3424   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000014FE  2042      3425          move.l    D2,A0
00001500  2028 0020 3426          move.l    32(A0),D0
00001504  6716      3427          beq.s     OS_EventTaskRdy_3
                    3428   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00001506  2042      3429          move.l    D2,A0
00001508  2F28 0020 3430          move.l    32(A0),-(A7)
0000150C  2F02      3431          move.l    D2,-(A7)
0000150E  4EB9 0000 3432          jsr       _OS_EventTaskRemoveMulti
00001512  169A      
00001514  504F      3433          addq.w    #8,A7
                    3434   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
00001516  2042      3435          move.l    D2,A0
00001518  2143 001C 3436          move.l    D3,28(A0)
                    3437   OS_EventTaskRdy_3:
                    3438   ; }
                    3439   ; #endif
                    3440   ; return (prio);
0000151C  1005      3441          move.b    D5,D0
0000151E  4CDF 003C 3442          movem.l   (A7)+,D2/D3/D4/D5
00001522  4E5E      3443          unlk      A6
00001524  4E75      3444          rts
                    3445   ; }
                    3446   ; #endif
                    3447   ; /*$PAGE*/
                    3448   ; /*
                    3449   ; *********************************************************************************************************
                    3450   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    3451   ; *
                    3452   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    3453   ; *              not occurred.
                    3454   ; *
                    3455   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    3456   ; *
                    3457   ; * Returns    : none
                    3458   ; *
                    3459   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3460   ; *********************************************************************************************************
                    3461   ; */
                    3462   ; #if (OS_EVENT_EN)
                    3463   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    3464   ; {
                    3465   _OS_EventTaskWait:
00001526  4E56 0000 3466          link      A6,#0
0000152A  48E7 3020 3467          movem.l   D2/D3/A2,-(A7)
0000152E  45F9 0800 3468          lea       _OSTCBCur.L,A2
00001532  1020      
00001534  262E 0008 3469          move.l    8(A6),D3
                    3470   ; INT8U  y;
                    3471   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
00001538  2052      3472          move.l    (A2),A0
0000153A  2143 001C 3473          move.l    D3,28(A0)
                    3474   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0000153E  2043      3475          move.l    D3,A0
00001540  2252      3476          move.l    (A2),A1
00001542  1029 0036 3477          move.b    54(A1),D0
00001546  C0BC 0000 3478          and.l     #255,D0
0000154A  00FF      
0000154C  D1C0      3479          add.l     D0,A0
0000154E  2252      3480          move.l    (A2),A1
00001550  1029 0037 3481          move.b    55(A1),D0
00001554  8128 000A 3482          or.b      D0,10(A0)
                    3483   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00001558  2043      3484          move.l    D3,A0
0000155A  2252      3485          move.l    (A2),A1
0000155C  1029 0038 3486          move.b    56(A1),D0
00001560  8128 0008 3487          or.b      D0,8(A0)
                    3488   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00001564  2052      3489          move.l    (A2),A0
00001566  1428 0036 3490          move.b    54(A0),D2
                    3491   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0000156A  C4BC 0000 3492          and.l     #255,D2
0000156E  00FF      
00001570  41F9 0800 3493          lea       _OSRdyTbl.L,A0
00001574  0F10      
00001576  2252      3494          move.l    (A2),A1
00001578  1029 0037 3495          move.b    55(A1),D0
0000157C  4600      3496          not.b     D0
0000157E  C130 2800 3497          and.b     D0,0(A0,D2.L)
                    3498   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00001582  C4BC 0000 3499          and.l     #255,D2
00001586  00FF      
00001588  41F9 0800 3500          lea       _OSRdyTbl.L,A0
0000158C  0F10      
0000158E  1030 2800 3501          move.b    0(A0,D2.L),D0
00001592  660E      3502          bne.s     OS_EventTaskWait_1
                    3503   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001594  2052      3504          move.l    (A2),A0
00001596  1028 0038 3505          move.b    56(A0),D0
0000159A  4600      3506          not.b     D0
0000159C  C139 0800 3507          and.b     D0,_OSRdyGrp.L
000015A0  0F0E      
                    3508   OS_EventTaskWait_1:
000015A2  4CDF 040C 3509          movem.l   (A7)+,D2/D3/A2
000015A6  4E5E      3510          unlk      A6
000015A8  4E75      3511          rts
                    3512   ; }
                    3513   ; }
                    3514   ; #endif
                    3515   ; /*$PAGE*/
                    3516   ; /*
                    3517   ; *********************************************************************************************************
                    3518   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    3519   ; *
                    3520   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    3521   ; *              multiple events has not occurred.
                    3522   ; *
                    3523   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    3524   ; *                               which the task will be waiting for.
                    3525   ; *
                    3526   ; * Returns    : none.
                    3527   ; *
                    3528   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3529   ; *********************************************************************************************************
                    3530   ; */
                    3531   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3532   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    3533   ; {
                    3534   _OS_EventTaskWaitMulti:
000015AA  4E56 0000 3535          link      A6,#0
000015AE  48E7 3820 3536          movem.l   D2/D3/D4/A2,-(A7)
000015B2  45F9 0800 3537          lea       _OSTCBCur.L,A2
000015B6  1020      
                    3538   ; OS_EVENT **pevents;
                    3539   ; OS_EVENT  *pevent;
                    3540   ; INT8U      y;
                    3541   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000015B8  2052      3542          move.l    (A2),A0
000015BA  42A8 001C 3543          clr.l     28(A0)
                    3544   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
000015BE  2052      3545          move.l    (A2),A0
000015C0  216E 0008 3546          move.l    8(A6),32(A0)
000015C4  0020      
                    3547   ; pevents =  pevents_wait;
000015C6  262E 0008 3548          move.l    8(A6),D3
                    3549   ; pevent  = *pevents;
000015CA  2043      3550          move.l    D3,A0
000015CC  2410      3551          move.l    (A0),D2
                    3552   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    3553   OS_EventTaskWaitMulti_1:
000015CE  4A82      3554          tst.l     D2
000015D0  6700 0030 3555          beq       OS_EventTaskWaitMulti_3
                    3556   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000015D4  2042      3557          move.l    D2,A0
000015D6  2252      3558          move.l    (A2),A1
000015D8  1029 0036 3559          move.b    54(A1),D0
000015DC  C0BC 0000 3560          and.l     #255,D0
000015E0  00FF      
000015E2  D1C0      3561          add.l     D0,A0
000015E4  2252      3562          move.l    (A2),A1
000015E6  1029 0037 3563          move.b    55(A1),D0
000015EA  8128 000A 3564          or.b      D0,10(A0)
                    3565   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000015EE  2042      3566          move.l    D2,A0
000015F0  2252      3567          move.l    (A2),A1
000015F2  1029 0038 3568          move.b    56(A1),D0
000015F6  8128 0008 3569          or.b      D0,8(A0)
                    3570   ; pevents++;
000015FA  5883      3571          addq.l    #4,D3
                    3572   ; pevent = *pevents;
000015FC  2043      3573          move.l    D3,A0
000015FE  2410      3574          move.l    (A0),D2
00001600  60CC      3575          bra       OS_EventTaskWaitMulti_1
                    3576   OS_EventTaskWaitMulti_3:
                    3577   ; }
                    3578   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00001602  2052      3579          move.l    (A2),A0
00001604  1828 0036 3580          move.b    54(A0),D4
                    3581   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00001608  C8BC 0000 3582          and.l     #255,D4
0000160C  00FF      
0000160E  41F9 0800 3583          lea       _OSRdyTbl.L,A0
00001612  0F10      
00001614  2252      3584          move.l    (A2),A1
00001616  1029 0037 3585          move.b    55(A1),D0
0000161A  4600      3586          not.b     D0
0000161C  C130 4800 3587          and.b     D0,0(A0,D4.L)
                    3588   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00001620  C8BC 0000 3589          and.l     #255,D4
00001624  00FF      
00001626  41F9 0800 3590          lea       _OSRdyTbl.L,A0
0000162A  0F10      
0000162C  1030 4800 3591          move.b    0(A0,D4.L),D0
00001630  660E      3592          bne.s     OS_EventTaskWaitMulti_4
                    3593   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001632  2052      3594          move.l    (A2),A0
00001634  1028 0038 3595          move.b    56(A0),D0
00001638  4600      3596          not.b     D0
0000163A  C139 0800 3597          and.b     D0,_OSRdyGrp.L
0000163E  0F0E      
                    3598   OS_EventTaskWaitMulti_4:
00001640  4CDF 041C 3599          movem.l   (A7)+,D2/D3/D4/A2
00001644  4E5E      3600          unlk      A6
00001646  4E75      3601          rts
                    3602   ; }
                    3603   ; }
                    3604   ; #endif
                    3605   ; /*$PAGE*/
                    3606   ; /*
                    3607   ; *********************************************************************************************************
                    3608   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    3609   ; *
                    3610   ; * Description: Remove a task from an event's wait list.
                    3611   ; *
                    3612   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    3613   ; *
                    3614   ; *              pevent   is a pointer to the event control block.
                    3615   ; *
                    3616   ; * Returns    : none
                    3617   ; *
                    3618   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3619   ; *********************************************************************************************************
                    3620   ; */
                    3621   ; #if (OS_EVENT_EN)
                    3622   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    3623   ; OS_EVENT *pevent)
                    3624   ; {
                    3625   _OS_EventTaskRemove:
00001648  4E56 0000 3626          link      A6,#0
0000164C  48E7 3800 3627          movem.l   D2/D3/D4,-(A7)
00001650  242E 000C 3628          move.l    12(A6),D2
00001654  262E 0008 3629          move.l    8(A6),D3
                    3630   ; INT8U  y;
                    3631   ; y                       =  ptcb->OSTCBY;
00001658  2043      3632          move.l    D3,A0
0000165A  1828 0036 3633          move.b    54(A0),D4
                    3634   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
0000165E  2042      3635          move.l    D2,A0
00001660  C8BC 0000 3636          and.l     #255,D4
00001664  00FF      
00001666  D1C4      3637          add.l     D4,A0
00001668  2243      3638          move.l    D3,A1
0000166A  1029 0037 3639          move.b    55(A1),D0
0000166E  4600      3640          not.b     D0
00001670  C128 000A 3641          and.b     D0,10(A0)
                    3642   ; if (pevent->OSEventTbl[y] == 0u) {
00001674  2042      3643          move.l    D2,A0
00001676  C8BC 0000 3644          and.l     #255,D4
0000167A  00FF      
0000167C  D1C4      3645          add.l     D4,A0
0000167E  1028 000A 3646          move.b    10(A0),D0
00001682  660E      3647          bne.s     OS_EventTaskRemove_1
                    3648   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001684  2042      3649          move.l    D2,A0
00001686  2243      3650          move.l    D3,A1
00001688  1029 0038 3651          move.b    56(A1),D0
0000168C  4600      3652          not.b     D0
0000168E  C128 0008 3653          and.b     D0,8(A0)
                    3654   OS_EventTaskRemove_1:
00001692  4CDF 001C 3655          movem.l   (A7)+,D2/D3/D4
00001696  4E5E      3656          unlk      A6
00001698  4E75      3657          rts
                    3658   ; }
                    3659   ; }
                    3660   ; #endif
                    3661   ; /*$PAGE*/
                    3662   ; /*
                    3663   ; *********************************************************************************************************
                    3664   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    3665   ; *
                    3666   ; * Description: Remove a task from multiple events' wait lists.
                    3667   ; *
                    3668   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3669   ; *
                    3670   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3671   ; *
                    3672   ; * Returns    : none
                    3673   ; *
                    3674   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3675   ; *********************************************************************************************************
                    3676   ; */
                    3677   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3678   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3679   ; OS_EVENT **pevents_multi)
                    3680   ; {
                    3681   _OS_EventTaskRemoveMulti:
0000169A  4E56 FFFC 3682          link      A6,#-4
0000169E  48E7 3C00 3683          movem.l   D2/D3/D4/D5,-(A7)
000016A2  282E 0008 3684          move.l    8(A6),D4
                    3685   ; OS_EVENT **pevents;
                    3686   ; OS_EVENT  *pevent;
                    3687   ; INT8U      y;
                    3688   ; OS_PRIO    bity;
                    3689   ; OS_PRIO    bitx;
                    3690   ; y       =  ptcb->OSTCBY;
000016A6  2044      3691          move.l    D4,A0
000016A8  1A28 0036 3692          move.b    54(A0),D5
                    3693   ; bity    =  ptcb->OSTCBBitY;
000016AC  2044      3694          move.l    D4,A0
000016AE  1D68 0038 3695          move.b    56(A0),-2(A6)
000016B2  FFFE      
                    3696   ; bitx    =  ptcb->OSTCBBitX;
000016B4  2044      3697          move.l    D4,A0
000016B6  1D68 0037 3698          move.b    55(A0),-1(A6)
000016BA  FFFF      
                    3699   ; pevents =  pevents_multi;
000016BC  262E 000C 3700          move.l    12(A6),D3
                    3701   ; pevent  = *pevents;
000016C0  2043      3702          move.l    D3,A0
000016C2  2410      3703          move.l    (A0),D2
                    3704   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3705   OS_EventTaskRemoveMulti_1:
000016C4  4A82      3706          tst.l     D2
000016C6  6700 003A 3707          beq       OS_EventTaskRemoveMulti_3
                    3708   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
000016CA  2042      3709          move.l    D2,A0
000016CC  CABC 0000 3710          and.l     #255,D5
000016D0  00FF      
000016D2  D1C5      3711          add.l     D5,A0
000016D4  102E FFFF 3712          move.b    -1(A6),D0
000016D8  4600      3713          not.b     D0
000016DA  C128 000A 3714          and.b     D0,10(A0)
                    3715   ; if (pevent->OSEventTbl[y] == 0u) {
000016DE  2042      3716          move.l    D2,A0
000016E0  CABC 0000 3717          and.l     #255,D5
000016E4  00FF      
000016E6  D1C5      3718          add.l     D5,A0
000016E8  1028 000A 3719          move.b    10(A0),D0
000016EC  660C      3720          bne.s     OS_EventTaskRemoveMulti_4
                    3721   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
000016EE  2042      3722          move.l    D2,A0
000016F0  102E FFFE 3723          move.b    -2(A6),D0
000016F4  4600      3724          not.b     D0
000016F6  C128 0008 3725          and.b     D0,8(A0)
                    3726   OS_EventTaskRemoveMulti_4:
                    3727   ; }
                    3728   ; pevents++;
000016FA  5883      3729          addq.l    #4,D3
                    3730   ; pevent = *pevents;
000016FC  2043      3731          move.l    D3,A0
000016FE  2410      3732          move.l    (A0),D2
00001700  60C2      3733          bra       OS_EventTaskRemoveMulti_1
                    3734   OS_EventTaskRemoveMulti_3:
00001702  4CDF 003C 3735          movem.l   (A7)+,D2/D3/D4/D5
00001706  4E5E      3736          unlk      A6
00001708  4E75      3737          rts
                    3738   ; }
                    3739   ; }
                    3740   ; #endif
                    3741   ; /*$PAGE*/
                    3742   ; /*
                    3743   ; *********************************************************************************************************
                    3744   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3745   ; *
                    3746   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3747   ; *
                    3748   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3749   ; *
                    3750   ; * Returns    : none
                    3751   ; *
                    3752   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3753   ; *********************************************************************************************************
                    3754   ; */
                    3755   ; #if (OS_EVENT_EN)
                    3756   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3757   ; {
                    3758   _OS_EventWaitListInit:
0000170A  4E56 0000 3759          link      A6,#0
0000170E  2F02      3760          move.l    D2,-(A7)
                    3761   ; INT8U  i;
                    3762   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
00001710  206E 0008 3763          move.l    8(A6),A0
00001714  4228 0008 3764          clr.b     8(A0)
                    3765   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00001718  4202      3766          clr.b     D2
                    3767   OS_EventWaitListInit_1:
0000171A  0C02 0008 3768          cmp.b     #8,D2
0000171E  6414      3769          bhs.s     OS_EventWaitListInit_3
                    3770   ; pevent->OSEventTbl[i] = 0u;
00001720  206E 0008 3771          move.l    8(A6),A0
00001724  C4BC 0000 3772          and.l     #255,D2
00001728  00FF      
0000172A  D1C2      3773          add.l     D2,A0
0000172C  4228 000A 3774          clr.b     10(A0)
00001730  5202      3775          addq.b    #1,D2
00001732  60E6      3776          bra       OS_EventWaitListInit_1
                    3777   OS_EventWaitListInit_3:
00001734  241F      3778          move.l    (A7)+,D2
00001736  4E5E      3779          unlk      A6
00001738  4E75      3780          rts
                    3781   ; }
                    3782   ; }
                    3783   ; #endif
                    3784   ; /*$PAGE*/
                    3785   ; /*
                    3786   ; *********************************************************************************************************
                    3787   ; *                                             INITIALIZATION
                    3788   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3789   ; *
                    3790   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3791   ; *
                    3792   ; * Arguments  : none
                    3793   ; *
                    3794   ; * Returns    : none
                    3795   ; *********************************************************************************************************
                    3796   ; */
                    3797   ; static  void  OS_InitEventList (void)
                    3798   ; {
                    3799   @ucos_ii_OS_InitEventList:
0000173A  4E56 FFF8 3800          link      A6,#-8
0000173E  48E7 3020 3801          movem.l   D2/D3/A2,-(A7)
00001742  45F9 0800 3802          lea       _OSEventTbl.L,A2
00001746  0CDE      
                    3803   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3804   ; #if (OS_MAX_EVENTS > 1u)
                    3805   ; INT16U     ix;
                    3806   ; INT16U     ix_next;
                    3807   ; OS_EVENT  *pevent1;
                    3808   ; OS_EVENT  *pevent2;
                    3809   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00001748  4878 00DC 3810          pea       220
0000174C  2F0A      3811          move.l    A2,-(A7)
0000174E  4EB9 0000 3812          jsr       _OS_MemClr
00001752  19D6      
00001754  504F      3813          addq.w    #8,A7
                    3814   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00001756  4243      3815          clr.w     D3
                    3816   @ucos_ii_OS_InitEventList_1:
00001758  0C43 0009 3817          cmp.w     #9,D3
0000175C  6400 004E 3818          bhs       @ucos_ii_OS_InitEventList_3
                    3819   ; ix_next = ix + 1u;
00001760  3003      3820          move.w    D3,D0
00001762  5240      3821          addq.w    #1,D0
00001764  3D40 FFFA 3822          move.w    D0,-6(A6)
                    3823   ; pevent1 = &OSEventTbl[ix];
00001768  200A      3824          move.l    A2,D0
0000176A  C6BC 0000 3825          and.l     #65535,D3
0000176E  FFFF      
00001770  2203      3826          move.l    D3,D1
00001772  C3FC 0016 3827          muls      #22,D1
00001776  D081      3828          add.l     D1,D0
00001778  2400      3829          move.l    D0,D2
                    3830   ; pevent2 = &OSEventTbl[ix_next];
0000177A  200A      3831          move.l    A2,D0
0000177C  322E FFFA 3832          move.w    -6(A6),D1
00001780  C2BC 0000 3833          and.l     #65535,D1
00001784  FFFF      
00001786  C3FC 0016 3834          muls      #22,D1
0000178A  D081      3835          add.l     D1,D0
0000178C  2D40 FFFC 3836          move.l    D0,-4(A6)
                    3837   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00001790  2042      3838          move.l    D2,A0
00001792  4210      3839          clr.b     (A0)
                    3840   ; pevent1->OSEventPtr     = pevent2;
00001794  2042      3841          move.l    D2,A0
00001796  216E FFFC 3842          move.l    -4(A6),2(A0)
0000179A  0002      
                    3843   ; #if OS_EVENT_NAME_EN > 0u
                    3844   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
0000179C  41F9 0000 3845          lea       @ucos_ii_1.L,A0
000017A0  6AD0      
000017A2  2242      3846          move.l    D2,A1
000017A4  2348 0012 3847          move.l    A0,18(A1)
000017A8  5243      3848          addq.w    #1,D3
000017AA  60AC      3849          bra       @ucos_ii_OS_InitEventList_1
                    3850   @ucos_ii_OS_InitEventList_3:
                    3851   ; #endif
                    3852   ; }
                    3853   ; pevent1                         = &OSEventTbl[ix];
000017AC  200A      3854          move.l    A2,D0
000017AE  C6BC 0000 3855          and.l     #65535,D3
000017B2  FFFF      
000017B4  2203      3856          move.l    D3,D1
000017B6  C3FC 0016 3857          muls      #22,D1
000017BA  D081      3858          add.l     D1,D0
000017BC  2400      3859          move.l    D0,D2
                    3860   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000017BE  2042      3861          move.l    D2,A0
000017C0  4210      3862          clr.b     (A0)
                    3863   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
000017C2  2042      3864          move.l    D2,A0
000017C4  42A8 0002 3865          clr.l     2(A0)
                    3866   ; #if OS_EVENT_NAME_EN > 0u
                    3867   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
000017C8  41F9 0000 3868          lea       @ucos_ii_1.L,A0
000017CC  6AD0      
000017CE  2242      3869          move.l    D2,A1
000017D0  2348 0012 3870          move.l    A0,18(A1)
                    3871   ; #endif
                    3872   ; OSEventFreeList                 = &OSEventTbl[0];
000017D4  23CA 0800 3873          move.l    A2,_OSEventFreeList.L
000017D8  0CDA      
000017DA  4CDF 040C 3874          movem.l   (A7)+,D2/D3/A2
000017DE  4E5E      3875          unlk      A6
000017E0  4E75      3876          rts
                    3877   ; #else
                    3878   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3879   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3880   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3881   ; #if OS_EVENT_NAME_EN > 0u
                    3882   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3883   ; #endif
                    3884   ; #endif
                    3885   ; #endif
                    3886   ; }
                    3887   ; /*$PAGE*/
                    3888   ; /*
                    3889   ; *********************************************************************************************************
                    3890   ; *                                             INITIALIZATION
                    3891   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3892   ; *
                    3893   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3894   ; *
                    3895   ; * Arguments  : none
                    3896   ; *
                    3897   ; * Returns    : none
                    3898   ; *********************************************************************************************************
                    3899   ; */
                    3900   ; static  void  OS_InitMisc (void)
                    3901   ; {
                    3902   @ucos_ii_OS_InitMisc:
                    3903   ; #if OS_TIME_GET_SET_EN > 0u
                    3904   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000017E2  42B9 0800 3905          clr.l     _OSTime.L
000017E6  1976      
                    3906   ; #endif
                    3907   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000017E8  4239 0800 3908          clr.b     _OSIntNesting.L
000017EC  0F06      
                    3909   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
000017EE  4239 0800 3910          clr.b     _OSLockNesting.L
000017F2  0F08      
                    3911   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
000017F4  4239 0800 3912          clr.b     _OSTaskCtr.L
000017F8  0F1A      
                    3913   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000017FA  4239 0800 3914          clr.b     _OSRunning.L
000017FE  0F18      
                    3915   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
00001800  42B9 0800 3916          clr.l     _OSCtxSwCtr.L
00001804  0CD6      
                    3917   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
00001806  42B9 0800 3918          clr.l     _OSIdleCtr.L
0000180A  0F1C      
                    3919   ; #if OS_TASK_STAT_EN > 0u
                    3920   ; OSIdleCtrRun              = 0uL;
0000180C  42B9 0800 3921          clr.l     _OSIdleCtrRun.L
00001810  0E00      
                    3922   ; OSIdleCtrMax              = 0uL;
00001812  42B9 0800 3923          clr.l     _OSIdleCtrMax.L
00001816  0DFC      
                    3924   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
00001818  4239 0800 3925          clr.b     _OSStatRdy.L
0000181C  0E04      
                    3926   ; #endif
                    3927   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3928   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3929   ; #endif
                    3930   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3931   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
0000181E  4239 0800 3932          clr.b     _OSTaskRegNextAvailID.L
00001822  1974      
00001824  4E75      3933          rts
                    3934   ; #endif
                    3935   ; }
                    3936   ; /*$PAGE*/
                    3937   ; /*
                    3938   ; *********************************************************************************************************
                    3939   ; *                                             INITIALIZATION
                    3940   ; *                                       INITIALIZE THE READY LIST
                    3941   ; *
                    3942   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3943   ; *
                    3944   ; * Arguments  : none
                    3945   ; *
                    3946   ; * Returns    : none
                    3947   ; *********************************************************************************************************
                    3948   ; */
                    3949   ; static  void  OS_InitRdyList (void)
                    3950   ; {
                    3951   @ucos_ii_OS_InitRdyList:
00001826  2F02      3952          move.l    D2,-(A7)
                    3953   ; INT8U  i;
                    3954   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
00001828  4239 0800 3955          clr.b     _OSRdyGrp.L
0000182C  0F0E      
                    3956   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
0000182E  4202      3957          clr.b     D2
                    3958   @ucos_ii_OS_InitRdyList_1:
00001830  0C02 0008 3959          cmp.b     #8,D2
00001834  6414      3960          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3961   ; OSRdyTbl[i] = 0u;
00001836  C4BC 0000 3962          and.l     #255,D2
0000183A  00FF      
0000183C  41F9 0800 3963          lea       _OSRdyTbl.L,A0
00001840  0F10      
00001842  4230 2800 3964          clr.b     0(A0,D2.L)
00001846  5202      3965          addq.b    #1,D2
00001848  60E6      3966          bra       @ucos_ii_OS_InitRdyList_1
                    3967   @ucos_ii_OS_InitRdyList_3:
                    3968   ; }
                    3969   ; OSPrioCur     = 0u;
0000184A  4239 0800 3970          clr.b     _OSPrioCur.L
0000184E  0F0A      
                    3971   ; OSPrioHighRdy = 0u;
00001850  4239 0800 3972          clr.b     _OSPrioHighRdy.L
00001854  0F0C      
                    3973   ; OSTCBHighRdy  = (OS_TCB *)0;
00001856  42B9 0800 3974          clr.l     _OSTCBHighRdy.L
0000185A  1028      
                    3975   ; OSTCBCur      = (OS_TCB *)0;
0000185C  42B9 0800 3976          clr.l     _OSTCBCur.L
00001860  1020      
00001862  241F      3977          move.l    (A7)+,D2
00001864  4E75      3978          rts
                    3979   ; }
                    3980   ; /*$PAGE*/
                    3981   ; /*
                    3982   ; *********************************************************************************************************
                    3983   ; *                                             INITIALIZATION
                    3984   ; *                                         CREATING THE IDLE TASK
                    3985   ; *
                    3986   ; * Description: This function creates the Idle Task.
                    3987   ; *
                    3988   ; * Arguments  : none
                    3989   ; *
                    3990   ; * Returns    : none
                    3991   ; *********************************************************************************************************
                    3992   ; */
                    3993   ; static  void  OS_InitTaskIdle (void)
                    3994   ; {
                    3995   @ucos_ii_OS_InitTaskIdle:
00001866  4E56 FFFC 3996          link      A6,#-4
                    3997   ; #if OS_TASK_NAME_EN > 0u
                    3998   ; INT8U  err;
                    3999   ; #endif
                    4000   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4001   ; #if OS_STK_GROWTH == 1u
                    4002   ; (void)OSTaskCreateExt(OS_TaskIdle,
0000186A  4878 0003 4003          pea       3
0000186E  42A7      4004          clr.l     -(A7)
00001870  4878 0080 4005          pea       128
00001874  4879 0800 4006          pea       _OSTaskIdleStk.L
00001878  0F20      
0000187A  4878 FFFF 4007          pea       65535
0000187E  4878 003F 4008          pea       63
00001882  41F9 0800 4009          lea       _OSTaskIdleStk.L,A0
00001886  0F20      
00001888  D0FC 00FE 4010          add.w     #254,A0
0000188C  2F08      4011          move.l    A0,-(A7)
0000188E  42A7      4012          clr.l     -(A7)
00001890  4879 0000 4013          pea       _OS_TaskIdle.L
00001894  1AEC      
00001896  4EB9 0000 4014          jsr       _OSTaskCreateExt
0000189A  498C      
0000189C  DEFC 0024 4015          add.w     #36,A7
000018A0  C0BC 0000 4016          and.l     #255,D0
000018A4  00FF      
                    4017   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    4018   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    4019   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    4020   ; OS_TASK_IDLE_ID,
                    4021   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    4022   ; OS_TASK_IDLE_STK_SIZE,
                    4023   ; (void *)0,                                 /* No TCB extension                     */
                    4024   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    4025   ; #else
                    4026   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    4027   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    4028   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    4029   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    4030   ; OS_TASK_IDLE_ID,
                    4031   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    4032   ; OS_TASK_IDLE_STK_SIZE,
                    4033   ; (void *)0,                                 /* No TCB extension                     */
                    4034   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    4035   ; #endif
                    4036   ; #else
                    4037   ; #if OS_STK_GROWTH == 1u
                    4038   ; (void)OSTaskCreate(OS_TaskIdle,
                    4039   ; (void *)0,
                    4040   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    4041   ; OS_TASK_IDLE_PRIO);
                    4042   ; #else
                    4043   ; (void)OSTaskCreate(OS_TaskIdle,
                    4044   ; (void *)0,
                    4045   ; &OSTaskIdleStk[0],
                    4046   ; OS_TASK_IDLE_PRIO);
                    4047   ; #endif
                    4048   ; #endif
                    4049   ; #if OS_TASK_NAME_EN > 0u
                    4050   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
000018A6  486E FFFF 4051          pea       -1(A6)
000018AA  4879 0000 4052          pea       @ucos_ii_2.L
000018AE  6AD2      
000018B0  4878 003F 4053          pea       63
000018B4  4EB9 0000 4054          jsr       _OSTaskNameSet
000018B8  4D98      
000018BA  DEFC 000C 4055          add.w     #12,A7
000018BE  4E5E      4056          unlk      A6
000018C0  4E75      4057          rts
                    4058   ; #endif
                    4059   ; }
                    4060   ; /*$PAGE*/
                    4061   ; /*
                    4062   ; *********************************************************************************************************
                    4063   ; *                                             INITIALIZATION
                    4064   ; *                                      CREATING THE STATISTIC TASK
                    4065   ; *
                    4066   ; * Description: This function creates the Statistic Task.
                    4067   ; *
                    4068   ; * Arguments  : none
                    4069   ; *
                    4070   ; * Returns    : none
                    4071   ; *********************************************************************************************************
                    4072   ; */
                    4073   ; #if OS_TASK_STAT_EN > 0u
                    4074   ; static  void  OS_InitTaskStat (void)
                    4075   ; {
                    4076   @ucos_ii_OS_InitTaskStat:
000018C2  4E56 FFFC 4077          link      A6,#-4
                    4078   ; #if OS_TASK_NAME_EN > 0u
                    4079   ; INT8U  err;
                    4080   ; #endif
                    4081   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4082   ; #if OS_STK_GROWTH == 1u
                    4083   ; (void)OSTaskCreateExt(OS_TaskStat,
000018C6  4878 0003 4084          pea       3
000018CA  42A7      4085          clr.l     -(A7)
000018CC  4878 0080 4086          pea       128
000018D0  4879 0800 4087          pea       _OSTaskStatStk.L
000018D4  0E06      
000018D6  4878 FFFE 4088          pea       65534
000018DA  4878 003E 4089          pea       62
000018DE  41F9 0800 4090          lea       _OSTaskStatStk.L,A0
000018E2  0E06      
000018E4  D0FC 00FE 4091          add.w     #254,A0
000018E8  2F08      4092          move.l    A0,-(A7)
000018EA  42A7      4093          clr.l     -(A7)
000018EC  4879 0000 4094          pea       _OS_TaskStat.L
000018F0  1B04      
000018F2  4EB9 0000 4095          jsr       _OSTaskCreateExt
000018F6  498C      
000018F8  DEFC 0024 4096          add.w     #36,A7
000018FC  C0BC 0000 4097          and.l     #255,D0
00001900  00FF      
                    4098   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    4099   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    4100   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    4101   ; OS_TASK_STAT_ID,
                    4102   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    4103   ; OS_TASK_STAT_STK_SIZE,
                    4104   ; (void *)0,                                   /* No TCB extension               */
                    4105   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    4106   ; #else
                    4107   ; (void)OSTaskCreateExt(OS_TaskStat,
                    4108   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    4109   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    4110   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    4111   ; OS_TASK_STAT_ID,
                    4112   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    4113   ; OS_TASK_STAT_STK_SIZE,
                    4114   ; (void *)0,                                   /* No TCB extension               */
                    4115   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    4116   ; #endif
                    4117   ; #else
                    4118   ; #if OS_STK_GROWTH == 1u
                    4119   ; (void)OSTaskCreate(OS_TaskStat,
                    4120   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    4121   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    4122   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    4123   ; #else
                    4124   ; (void)OSTaskCreate(OS_TaskStat,
                    4125   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    4126   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    4127   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    4128   ; #endif
                    4129   ; #endif
                    4130   ; #if OS_TASK_NAME_EN > 0u
                    4131   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
00001902  486E FFFF 4132          pea       -1(A6)
00001906  4879 0000 4133          pea       @ucos_ii_3.L
0000190A  6AE0      
0000190C  4878 003E 4134          pea       62
00001910  4EB9 0000 4135          jsr       _OSTaskNameSet
00001914  4D98      
00001916  DEFC 000C 4136          add.w     #12,A7
0000191A  4E5E      4137          unlk      A6
0000191C  4E75      4138          rts
                    4139   ; #endif
                    4140   ; }
                    4141   ; #endif
                    4142   ; /*$PAGE*/
                    4143   ; /*
                    4144   ; *********************************************************************************************************
                    4145   ; *                                             INITIALIZATION
                    4146   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    4147   ; *
                    4148   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    4149   ; *
                    4150   ; * Arguments  : none
                    4151   ; *
                    4152   ; * Returns    : none
                    4153   ; *********************************************************************************************************
                    4154   ; */
                    4155   ; static  void  OS_InitTCBList (void)
                    4156   ; {
                    4157   @ucos_ii_OS_InitTCBList:
0000191E  4E56 FFF8 4158          link      A6,#-8
00001922  48E7 3020 4159          movem.l   D2/D3/A2,-(A7)
00001926  45F9 0800 4160          lea       _OSTCBTbl.L,A2
0000192A  1130      
                    4161   ; INT8U    ix;
                    4162   ; INT8U    ix_next;
                    4163   ; OS_TCB  *ptcb1;
                    4164   ; OS_TCB  *ptcb2;
                    4165   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
0000192C  4878 0764 4166          pea       1892
00001930  2F0A      4167          move.l    A2,-(A7)
00001932  4EB9 0000 4168          jsr       _OS_MemClr
00001936  19D6      
00001938  504F      4169          addq.w    #8,A7
                    4170   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
0000193A  4878 0100 4171          pea       256
0000193E  4879 0800 4172          pea       _OSTCBPrioTbl.L
00001942  1030      
00001944  4EB9 0000 4173          jsr       _OS_MemClr
00001948  19D6      
0000194A  504F      4174          addq.w    #8,A7
                    4175   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
0000194C  4203      4176          clr.b     D3
                    4177   @ucos_ii_OS_InitTCBList_1:
0000194E  0C03 0015 4178          cmp.b     #21,D3
00001952  6400 004A 4179          bhs       @ucos_ii_OS_InitTCBList_3
                    4180   ; ix_next =  ix + 1u;
00001956  7001      4181          moveq     #1,D0
00001958  D003      4182          add.b     D3,D0
0000195A  1D40 FFFB 4183          move.b    D0,-5(A6)
                    4184   ; ptcb1   = &OSTCBTbl[ix];
0000195E  200A      4185          move.l    A2,D0
00001960  C6BC 0000 4186          and.l     #255,D3
00001964  00FF      
00001966  2203      4187          move.l    D3,D1
00001968  C3FC 0056 4188          muls      #86,D1
0000196C  D081      4189          add.l     D1,D0
0000196E  2400      4190          move.l    D0,D2
                    4191   ; ptcb2   = &OSTCBTbl[ix_next];
00001970  200A      4192          move.l    A2,D0
00001972  122E FFFB 4193          move.b    -5(A6),D1
00001976  C2BC 0000 4194          and.l     #255,D1
0000197A  00FF      
0000197C  C3FC 0056 4195          muls      #86,D1
00001980  D081      4196          add.l     D1,D0
00001982  2D40 FFFC 4197          move.l    D0,-4(A6)
                    4198   ; ptcb1->OSTCBNext = ptcb2;
00001986  2042      4199          move.l    D2,A0
00001988  216E FFFC 4200          move.l    -4(A6),20(A0)
0000198C  0014      
                    4201   ; #if OS_TASK_NAME_EN > 0u
                    4202   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
0000198E  41F9 0000 4203          lea       @ucos_ii_1.L,A0
00001992  6AD0      
00001994  2242      4204          move.l    D2,A1
00001996  2348 004E 4205          move.l    A0,78(A1)
0000199A  5203      4206          addq.b    #1,D3
0000199C  60B0      4207          bra       @ucos_ii_OS_InitTCBList_1
                    4208   @ucos_ii_OS_InitTCBList_3:
                    4209   ; #endif
                    4210   ; }
                    4211   ; ptcb1                   = &OSTCBTbl[ix];
0000199E  200A      4212          move.l    A2,D0
000019A0  C6BC 0000 4213          and.l     #255,D3
000019A4  00FF      
000019A6  2203      4214          move.l    D3,D1
000019A8  C3FC 0056 4215          muls      #86,D1
000019AC  D081      4216          add.l     D1,D0
000019AE  2400      4217          move.l    D0,D2
                    4218   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000019B0  2042      4219          move.l    D2,A0
000019B2  42A8 0014 4220          clr.l     20(A0)
                    4221   ; #if OS_TASK_NAME_EN > 0u
                    4222   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000019B6  41F9 0000 4223          lea       @ucos_ii_1.L,A0
000019BA  6AD0      
000019BC  2242      4224          move.l    D2,A1
000019BE  2348 004E 4225          move.l    A0,78(A1)
                    4226   ; #endif
                    4227   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000019C2  42B9 0800 4228          clr.l     _OSTCBList.L
000019C6  102C      
                    4229   ; OSTCBFreeList           = &OSTCBTbl[0];
000019C8  23CA 0800 4230          move.l    A2,_OSTCBFreeList.L
000019CC  1024      
000019CE  4CDF 040C 4231          movem.l   (A7)+,D2/D3/A2
000019D2  4E5E      4232          unlk      A6
000019D4  4E75      4233          rts
                    4234   ; }
                    4235   ; /*$PAGE*/
                    4236   ; /*
                    4237   ; *********************************************************************************************************
                    4238   ; *                                      CLEAR A SECTION OF MEMORY
                    4239   ; *
                    4240   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    4241   ; *
                    4242   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    4243   ; *
                    4244   ; *              size     is the number of bytes to clear.
                    4245   ; *
                    4246   ; * Returns    : none
                    4247   ; *
                    4248   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4249   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    4250   ; *                 of the uses of this function gets close to this limit.
                    4251   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    4252   ; *                 of the alignment of the destination.
                    4253   ; *********************************************************************************************************
                    4254   ; */
                    4255   ; void  OS_MemClr (INT8U  *pdest,
                    4256   ; INT16U  size)
                    4257   ; {
                    4258   _OS_MemClr:
000019D6  4E56 0000 4259          link      A6,#0
                    4260   ; while (size > 0u) {
                    4261   OS_MemClr_1:
000019DA  302E 000E 4262          move.w    14(A6),D0
000019DE  0C40 0000 4263          cmp.w     #0,D0
000019E2  6310      4264          bls.s     OS_MemClr_3
                    4265   ; *pdest++ = (INT8U)0;
000019E4  206E 0008 4266          move.l    8(A6),A0
000019E8  52AE 0008 4267          addq.l    #1,8(A6)
000019EC  4210      4268          clr.b     (A0)
                    4269   ; size--;
000019EE  536E 000E 4270          subq.w    #1,14(A6)
000019F2  60E6      4271          bra       OS_MemClr_1
                    4272   OS_MemClr_3:
000019F4  4E5E      4273          unlk      A6
000019F6  4E75      4274          rts
                    4275   ; }
                    4276   ; }
                    4277   ; /*$PAGE*/
                    4278   ; /*
                    4279   ; *********************************************************************************************************
                    4280   ; *                                       COPY A BLOCK OF MEMORY
                    4281   ; *
                    4282   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    4283   ; *              location to another.
                    4284   ; *
                    4285   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    4286   ; *
                    4287   ; *              psrc     is a pointer to the 'source'      memory block
                    4288   ; *
                    4289   ; *              size     is the number of bytes to copy.
                    4290   ; *
                    4291   ; * Returns    : none
                    4292   ; *
                    4293   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    4294   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    4295   ; *                 is not a situation that will happen.
                    4296   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    4297   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    4298   ; *                 of the alignment of the source and destination.
                    4299   ; *********************************************************************************************************
                    4300   ; */
                    4301   ; void  OS_MemCopy (INT8U  *pdest,
                    4302   ; INT8U  *psrc,
                    4303   ; INT16U  size)
                    4304   ; {
                    4305   _OS_MemCopy:
000019F8  4E56 0000 4306          link      A6,#0
                    4307   ; while (size > 0u) {
                    4308   OS_MemCopy_1:
000019FC  302E 0012 4309          move.w    18(A6),D0
00001A00  0C40 0000 4310          cmp.w     #0,D0
00001A04  6318      4311          bls.s     OS_MemCopy_3
                    4312   ; *pdest++ = *psrc++;
00001A06  206E 000C 4313          move.l    12(A6),A0
00001A0A  52AE 000C 4314          addq.l    #1,12(A6)
00001A0E  226E 0008 4315          move.l    8(A6),A1
00001A12  52AE 0008 4316          addq.l    #1,8(A6)
00001A16  1290      4317          move.b    (A0),(A1)
                    4318   ; size--;
00001A18  536E 0012 4319          subq.w    #1,18(A6)
00001A1C  60DE      4320          bra       OS_MemCopy_1
                    4321   OS_MemCopy_3:
00001A1E  4E5E      4322          unlk      A6
00001A20  4E75      4323          rts
                    4324   ; }
                    4325   ; }
                    4326   ; /*$PAGE*/
                    4327   ; /*
                    4328   ; *********************************************************************************************************
                    4329   ; *                                              SCHEDULER
                    4330   ; *
                    4331   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    4332   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    4333   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    4334   ; *
                    4335   ; * Arguments  : none
                    4336   ; *
                    4337   ; * Returns    : none
                    4338   ; *
                    4339   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4340   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    4341   ; *********************************************************************************************************
                    4342   ; */
                    4343   ; void  OS_Sched (void)
                    4344   ; {
                    4345   _OS_Sched:
                    4346   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    4347   ; OS_CPU_SR  cpu_sr = 0u;
                    4348   ; #endif
                    4349   ; OS_ENTER_CRITICAL();
00001A22  40E7      4350          dc.w      16615
00001A24  007C      4351          dc.w      124
00001A26  0700      4352          dc.w      1792
                    4353   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00001A28  1039 0800 4354          move.b    _OSIntNesting.L,D0
00001A2C  0F06      
00001A2E  6600 0052 4355          bne       OS_Sched_5
                    4356   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
00001A32  1039 0800 4357          move.b    _OSLockNesting.L,D0
00001A36  0F08      
00001A38  6648      4358          bne.s     OS_Sched_5
                    4359   ; OS_SchedNew();
00001A3A  4EB9 0000 4360          jsr       @ucos_ii_OS_SchedNew
00001A3E  1A86      
                    4361   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001A40  1039 0800 4362          move.b    _OSPrioHighRdy.L,D0
00001A44  0F0C      
00001A46  C0BC 0000 4363          and.l     #255,D0
00001A4A  00FF      
00001A4C  E588      4364          lsl.l     #2,D0
00001A4E  41F9 0800 4365          lea       _OSTCBPrioTbl.L,A0
00001A52  1030      
00001A54  23F0 0800 4366          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001A58  0800 1028 
                    4367   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001A5C  1039 0800 4368          move.b    _OSPrioHighRdy.L,D0
00001A60  0F0C      
00001A62  B039 0800 4369          cmp.b     _OSPrioCur.L,D0
00001A66  0F0A      
00001A68  6718      4370          beq.s     OS_Sched_5
                    4371   ; #if OS_TASK_PROFILE_EN > 0u
                    4372   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00001A6A  2039 0800 4373          move.l    _OSTCBHighRdy.L,D0
00001A6E  1028      
00001A70  0680 0000 4374          add.l     #58,D0
00001A74  003A      
00001A76  2040      4375          move.l    D0,A0
00001A78  5290      4376          addq.l    #1,(A0)
                    4377   ; #endif
                    4378   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
00001A7A  52B9 0800 4379          addq.l    #1,_OSCtxSwCtr.L
00001A7E  0CD6      
                    4380   ; OS_TASK_SW();                          /* Perform a context switch                     */
00001A80  4E40      4381          trap      #0
                    4382   OS_Sched_5:
                    4383   ; }
                    4384   ; }
                    4385   ; }
                    4386   ; OS_EXIT_CRITICAL();
00001A82  46DF      4387          dc.w      18143
00001A84  4E75      4388          rts
                    4389   ; }
                    4390   ; /*
                    4391   ; *********************************************************************************************************
                    4392   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    4393   ; *
                    4394   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    4395   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    4396   ; *
                    4397   ; * Arguments  : none
                    4398   ; *
                    4399   ; * Returns    : none
                    4400   ; *
                    4401   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4402   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    4403   ; *********************************************************************************************************
                    4404   ; */
                    4405   ; static  void  OS_SchedNew (void)
                    4406   ; {
                    4407   @ucos_ii_OS_SchedNew:
00001A86  2F02      4408          move.l    D2,-(A7)
                    4409   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    4410   ; INT8U   y;
                    4411   ; y             = OSUnMapTbl[OSRdyGrp];
00001A88  1039 0800 4412          move.b    _OSRdyGrp.L,D0
00001A8C  0F0E      
00001A8E  C0BC 0000 4413          and.l     #255,D0
00001A92  00FF      
00001A94  41F9 0000 4414          lea       _OSUnMapTbl.L,A0
00001A98  6B22      
00001A9A  1430 0800 4415          move.b    0(A0,D0.L),D2
                    4416   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00001A9E  1002      4417          move.b    D2,D0
00001AA0  E708      4418          lsl.b     #3,D0
00001AA2  C4BC 0000 4419          and.l     #255,D2
00001AA6  00FF      
00001AA8  41F9 0800 4420          lea       _OSRdyTbl.L,A0
00001AAC  0F10      
00001AAE  1230 2800 4421          move.b    0(A0,D2.L),D1
00001AB2  C2BC 0000 4422          and.l     #255,D1
00001AB6  00FF      
00001AB8  41F9 0000 4423          lea       _OSUnMapTbl.L,A0
00001ABC  6B22      
00001ABE  D030 1800 4424          add.b     0(A0,D1.L),D0
00001AC2  13C0 0800 4425          move.b    D0,_OSPrioHighRdy.L
00001AC6  0F0C      
00001AC8  241F      4426          move.l    (A7)+,D2
00001ACA  4E75      4427          rts
                    4428   ; #else                                            /* We support up to 256 tasks                         */
                    4429   ; INT8U     y;
                    4430   ; OS_PRIO  *ptbl;
                    4431   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    4432   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    4433   ; } else {
                    4434   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    4435   ; }
                    4436   ; ptbl = &OSRdyTbl[y];
                    4437   ; if ((*ptbl & 0xFFu) != 0u) {
                    4438   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    4439   ; } else {
                    4440   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    4441   ; }
                    4442   ; #endif
                    4443   ; }
                    4444   ; /*$PAGE*/
                    4445   ; /*
                    4446   ; *********************************************************************************************************
                    4447   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    4448   ; *
                    4449   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    4450   ; *              (excluding the NUL character).
                    4451   ; *
                    4452   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    4453   ; *
                    4454   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    4455   ; *
                    4456   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4457   ; *              2) The string to check must be less than 255 characters long.
                    4458   ; *********************************************************************************************************
                    4459   ; */
                    4460   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    4461   ; INT8U  OS_StrLen (INT8U *psrc)
                    4462   ; {
                    4463   _OS_StrLen:
00001ACC  4E56 0000 4464          link      A6,#0
00001AD0  2F02      4465          move.l    D2,-(A7)
                    4466   ; INT8U  len;
                    4467   ; #if OS_ARG_CHK_EN > 0u
                    4468   ; if (psrc == (INT8U *)0) {
                    4469   ; return (0u);
                    4470   ; }
                    4471   ; #endif
                    4472   ; len = 0u;
00001AD2  4202      4473          clr.b     D2
                    4474   ; while (*psrc != OS_ASCII_NUL) {
                    4475   OS_StrLen_1:
00001AD4  206E 0008 4476          move.l    8(A6),A0
00001AD8  1010      4477          move.b    (A0),D0
00001ADA  6708      4478          beq.s     OS_StrLen_3
                    4479   ; psrc++;
00001ADC  52AE 0008 4480          addq.l    #1,8(A6)
                    4481   ; len++;
00001AE0  5202      4482          addq.b    #1,D2
00001AE2  60F0      4483          bra       OS_StrLen_1
                    4484   OS_StrLen_3:
                    4485   ; }
                    4486   ; return (len);
00001AE4  1002      4487          move.b    D2,D0
00001AE6  241F      4488          move.l    (A7)+,D2
00001AE8  4E5E      4489          unlk      A6
00001AEA  4E75      4490          rts
                    4491   ; }
                    4492   ; #endif
                    4493   ; /*$PAGE*/
                    4494   ; /*
                    4495   ; *********************************************************************************************************
                    4496   ; *                                              IDLE TASK
                    4497   ; *
                    4498   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    4499   ; *              executes because they are ALL waiting for event(s) to occur.
                    4500   ; *
                    4501   ; * Arguments  : none
                    4502   ; *
                    4503   ; * Returns    : none
                    4504   ; *
                    4505   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    4506   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    4507   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    4508   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    4509   ; *                 interrupts.
                    4510   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    4511   ; *                 power.
                    4512   ; *********************************************************************************************************
                    4513   ; */
                    4514   ; void  OS_TaskIdle (void *p_arg)
                    4515   ; {
                    4516   _OS_TaskIdle:
00001AEC  4E56 0000 4517          link      A6,#0
                    4518   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4519   ; OS_CPU_SR  cpu_sr = 0u;
                    4520   ; #endif
                    4521   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4522   ; for (;;) {
                    4523   OS_TaskIdle_1:
                    4524   ; OS_ENTER_CRITICAL();
00001AF0  40E7      4525          dc.w      16615
00001AF2  007C      4526          dc.w      124
00001AF4  0700      4527          dc.w      1792
                    4528   ; OSIdleCtr++;
00001AF6  52B9 0800 4529          addq.l    #1,_OSIdleCtr.L
00001AFA  0F1C      
                    4530   ; OS_EXIT_CRITICAL();
00001AFC  46DF      4531          dc.w      18143
                    4532   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001AFE  4EB8 0D18 4533          jsr       _OSTaskIdleHook
00001B02  60EC      4534          bra       OS_TaskIdle_1
                    4535   ; }
                    4536   ; }
                    4537   ; /*$PAGE*/
                    4538   ; /*
                    4539   ; *********************************************************************************************************
                    4540   ; *                                           STATISTICS TASK
                    4541   ; *
                    4542   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    4543   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    4544   ; *              CPU usage is determined by:
                    4545   ; *
                    4546   ; *                                          OSIdleCtr
                    4547   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    4548   ; *                                         OSIdleCtrMax
                    4549   ; *
                    4550   ; * Arguments  : parg     this pointer is not used at this time.
                    4551   ; *
                    4552   ; * Returns    : none
                    4553   ; *
                    4554   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    4555   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    4556   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    4557   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    4558   ; *                 maximum value for the idle counter.
                    4559   ; *********************************************************************************************************
                    4560   ; */
                    4561   ; #if OS_TASK_STAT_EN > 0u
                    4562   ; void  OS_TaskStat (void *p_arg)
                    4563   ; {
                    4564   _OS_TaskStat:
00001B04  4E56 0000 4565          link      A6,#0
00001B08  2F0A      4566          move.l    A2,-(A7)
00001B0A  45F9 0800 4567          lea       _OSIdleCtrMax.L,A2
00001B0E  0DFC      
                    4568   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4569   ; OS_CPU_SR  cpu_sr = 0u;
                    4570   ; #endif
                    4571   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4572   ; while (OSStatRdy == OS_FALSE) {
                    4573   OS_TaskStat_1:
00001B10  1039 0800 4574          move.b    _OSStatRdy.L,D0
00001B14  0E04      
00001B16  660E      4575          bne.s     OS_TaskStat_3
                    4576   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
00001B18  4878 0014 4577          pea       20
00001B1C  4EB9 0000 4578          jsr       _OSTimeDly
00001B20  521E      
00001B22  584F      4579          addq.w    #4,A7
00001B24  60EA      4580          bra       OS_TaskStat_1
                    4581   OS_TaskStat_3:
                    4582   ; }
                    4583   ; OSIdleCtrMax /= 100uL;
00001B26  2F12      4584          move.l    (A2),-(A7)
00001B28  4878 0064 4585          pea       100
00001B2C  4EB9 0000 4586          jsr       ULDIV
00001B30  60E6      
00001B32  2497      4587          move.l    (A7),(A2)
00001B34  504F      4588          addq.w    #8,A7
                    4589   ; if (OSIdleCtrMax == 0uL) {
00001B36  2012      4590          move.l    (A2),D0
00001B38  6618      4591          bne.s     OS_TaskStat_4
                    4592   ; OSCPUUsage = 0u;
00001B3A  4239 0800 4593          clr.b     _OSCPUUsage.L
00001B3E  0DFA      
                    4594   ; #if OS_TASK_SUSPEND_EN > 0u
                    4595   ; (void)OSTaskSuspend(OS_PRIO_SELF);
00001B40  4878 00FF 4596          pea       255
00001B44  4EB9 0000 4597          jsr       _OSTaskSuspend
00001B48  4F96      
00001B4A  584F      4598          addq.w    #4,A7
00001B4C  C0BC 0000 4599          and.l     #255,D0
00001B50  00FF      
                    4600   OS_TaskStat_4:
                    4601   ; #else
                    4602   ; for (;;) {
                    4603   ; OSTimeDly(OS_TICKS_PER_SEC);
                    4604   ; }
                    4605   ; #endif
                    4606   ; }
                    4607   ; OS_ENTER_CRITICAL();
00001B52  40E7      4608          dc.w      16615
00001B54  007C      4609          dc.w      124
00001B56  0700      4610          dc.w      1792
                    4611   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
00001B58  2F12      4612          move.l    (A2),-(A7)
00001B5A  4878 0064 4613          pea       100
00001B5E  4EB9 0000 4614          jsr       ULMUL
00001B62  6046      
00001B64  2017      4615          move.l    (A7),D0
00001B66  504F      4616          addq.w    #8,A7
00001B68  23C0 0800 4617          move.l    D0,_OSIdleCtr.L
00001B6C  0F1C      
                    4618   ; OS_EXIT_CRITICAL();
00001B6E  46DF      4619          dc.w      18143
                    4620   ; for (;;) {
                    4621   OS_TaskStat_6:
                    4622   ; OS_ENTER_CRITICAL();
00001B70  40E7      4623          dc.w      16615
00001B72  007C      4624          dc.w      124
00001B74  0700      4625          dc.w      1792
                    4626   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00001B76  23F9 0800 4627          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
00001B7A  0F1C 0800 
00001B7E  0E00      
                    4628   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001B80  42B9 0800 4629          clr.l     _OSIdleCtr.L
00001B84  0F1C      
                    4630   ; OS_EXIT_CRITICAL();
00001B86  46DF      4631          dc.w      18143
                    4632   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
00001B88  7064      4633          moveq     #100,D0
00001B8A  2F39 0800 4634          move.l    _OSIdleCtrRun.L,-(A7)
00001B8E  0E00      
00001B90  2F12      4635          move.l    (A2),-(A7)
00001B92  4EB9 0000 4636          jsr       ULDIV
00001B96  60E6      
00001B98  2217      4637          move.l    (A7),D1
00001B9A  504F      4638          addq.w    #8,A7
00001B9C  9081      4639          sub.l     D1,D0
00001B9E  13C0 0800 4640          move.b    D0,_OSCPUUsage.L
00001BA2  0DFA      
                    4641   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
00001BA4  4EB8 0D22 4642          jsr       _OSTaskStatHook
                    4643   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4644   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
00001BA8  4EB9 0000 4645          jsr       _OS_TaskStatStkChk
00001BAC  1BBC      
                    4646   ; #endif
                    4647   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00001BAE  4878 000A 4648          pea       10
00001BB2  4EB9 0000 4649          jsr       _OSTimeDly
00001BB6  521E      
00001BB8  584F      4650          addq.w    #4,A7
00001BBA  60B4      4651          bra       OS_TaskStat_6
                    4652   ; }
                    4653   ; }
                    4654   ; #endif
                    4655   ; /*$PAGE*/
                    4656   ; /*
                    4657   ; *********************************************************************************************************
                    4658   ; *                                        CHECK ALL TASK STACKS
                    4659   ; *
                    4660   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    4661   ; *
                    4662   ; * Arguments  : none
                    4663   ; *
                    4664   ; * Returns    : none
                    4665   ; *********************************************************************************************************
                    4666   ; */
                    4667   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4668   ; void  OS_TaskStatStkChk (void)
                    4669   ; {
                    4670   _OS_TaskStatStkChk:
00001BBC  4E56 FFF4 4671          link      A6,#-12
00001BC0  48E7 3000 4672          movem.l   D2/D3,-(A7)
                    4673   ; OS_TCB      *ptcb;
                    4674   ; OS_STK_DATA  stk_data;
                    4675   ; INT8U        err;
                    4676   ; INT8U        prio;
                    4677   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
00001BC4  4203      4678          clr.b     D3
                    4679   OS_TaskStatStkChk_1:
00001BC6  0C03 003F 4680          cmp.b     #63,D3
00001BCA  6200 0068 4681          bhi       OS_TaskStatStkChk_3
                    4682   ; err = OSTaskStkChk(prio, &stk_data);
00001BCE  486E FFF6 4683          pea       -10(A6)
00001BD2  C6BC 0000 4684          and.l     #255,D3
00001BD6  00FF      
00001BD8  2F03      4685          move.l    D3,-(A7)
00001BDA  4EB9 0000 4686          jsr       _OSTaskStkChk
00001BDE  4EDE      
00001BE0  504F      4687          addq.w    #8,A7
00001BE2  1D40 FFFF 4688          move.b    D0,-1(A6)
                    4689   ; if (err == OS_ERR_NONE) {
00001BE6  102E FFFF 4690          move.b    -1(A6),D0
00001BEA  6600 0044 4691          bne       OS_TaskStatStkChk_8
                    4692   ; ptcb = OSTCBPrioTbl[prio];
00001BEE  C6BC 0000 4693          and.l     #255,D3
00001BF2  00FF      
00001BF4  2003      4694          move.l    D3,D0
00001BF6  E588      4695          lsl.l     #2,D0
00001BF8  41F9 0800 4696          lea       _OSTCBPrioTbl.L,A0
00001BFC  1030      
00001BFE  2430 0800 4697          move.l    0(A0,D0.L),D2
                    4698   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
00001C02  4A82      4699          tst.l     D2
00001C04  672A      4700          beq.s     OS_TaskStatStkChk_8
                    4701   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001C06  0C82 0000 4702          cmp.l     #1,D2
00001C0A  0001      
00001C0C  6722      4703          beq.s     OS_TaskStatStkChk_8
                    4704   ; #if OS_TASK_PROFILE_EN > 0u
                    4705   ; #if OS_STK_GROWTH == 1u
                    4706   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001C0E  2042      4707          move.l    D2,A0
00001C10  2028 0008 4708          move.l    8(A0),D0
00001C14  2042      4709          move.l    D2,A0
00001C16  2228 000C 4710          move.l    12(A0),D1
00001C1A  E389      4711          lsl.l     #1,D1
00001C1C  D081      4712          add.l     D1,D0
00001C1E  2042      4713          move.l    D2,A0
00001C20  2140 0046 4714          move.l    D0,70(A0)
                    4715   ; #else
                    4716   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4717   ; #endif
                    4718   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
00001C24  41EE FFF6 4719          lea       -10(A6),A0
00001C28  2242      4720          move.l    D2,A1
00001C2A  2368 0004 4721          move.l    4(A0),74(A1)
00001C2E  004A      
                    4722   OS_TaskStatStkChk_8:
00001C30  5203      4723          addq.b    #1,D3
00001C32  6092      4724          bra       OS_TaskStatStkChk_1
                    4725   OS_TaskStatStkChk_3:
00001C34  4CDF 000C 4726          movem.l   (A7)+,D2/D3
00001C38  4E5E      4727          unlk      A6
00001C3A  4E75      4728          rts
                    4729   ; #endif
                    4730   ; }
                    4731   ; }
                    4732   ; }
                    4733   ; }
                    4734   ; }
                    4735   ; #endif
                    4736   ; /*$PAGE*/
                    4737   ; /*
                    4738   ; *********************************************************************************************************
                    4739   ; *                                           INITIALIZE TCB
                    4740   ; *
                    4741   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4742   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4743   ; *
                    4744   ; * Arguments  : prio          is the priority of the task being created
                    4745   ; *
                    4746   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4747   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4748   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4749   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4750   ; *                            specific.
                    4751   ; *
                    4752   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4753   ; *                            'OSTaskCreate()'.
                    4754   ; *
                    4755   ; *              id            is the task's ID (0..65535)
                    4756   ; *
                    4757   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4758   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4759   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4760   ; *                            units are established by the #define constant OS_STK which is CPU
                    4761   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4762   ; *
                    4763   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4764   ; *                            control block.  This allows you to store the contents of floating-point
                    4765   ; *                            registers, MMU registers or anything else you could find useful during a
                    4766   ; *                            context switch.  You can even assign a name to each task and store this name
                    4767   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4768   ; *
                    4769   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4770   ; *                            0 if called from 'OSTaskCreate()'.
                    4771   ; *
                    4772   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4773   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4774   ; *                                  be created.
                    4775   ; *
                    4776   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4777   ; *********************************************************************************************************
                    4778   ; */
                    4779   ; INT8U  OS_TCBInit (INT8U    prio,
                    4780   ; OS_STK  *ptos,
                    4781   ; OS_STK  *pbos,
                    4782   ; INT16U   id,
                    4783   ; INT32U   stk_size,
                    4784   ; void    *pext,
                    4785   ; INT16U   opt)
                    4786   ; {
                    4787   _OS_TCBInit:
00001C3C  4E56 0000 4788          link      A6,#0
00001C40  48E7 3820 4789          movem.l   D2/D3/D4/A2,-(A7)
00001C44  45F9 0800 4790          lea       _OSTCBList.L,A2
00001C48  102C      
00001C4A  182E 000B 4791          move.b    11(A6),D4
00001C4E  C8BC 0000 4792          and.l     #255,D4
00001C52  00FF      
                    4793   ; OS_TCB    *ptcb;
                    4794   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4795   ; OS_CPU_SR  cpu_sr = 0u;
                    4796   ; #endif
                    4797   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4798   ; INT8U      i;
                    4799   ; #endif
                    4800   ; OS_ENTER_CRITICAL();
00001C54  40E7      4801          dc.w      16615
00001C56  007C      4802          dc.w      124
00001C58  0700      4803          dc.w      1792
                    4804   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001C5A  2439 0800 4805          move.l    _OSTCBFreeList.L,D2
00001C5E  1024      
                    4806   ; if (ptcb != (OS_TCB *)0) {
00001C60  4A82      4807          tst.l     D2
00001C62  6700 017A 4808          beq       OS_TCBInit_1
                    4809   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00001C66  2042      4810          move.l    D2,A0
00001C68  23E8 0014 4811          move.l    20(A0),_OSTCBFreeList.L
00001C6C  0800 1024 
                    4812   ; OS_EXIT_CRITICAL();
00001C70  46DF      4813          dc.w      18143
                    4814   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00001C72  2042      4815          move.l    D2,A0
00001C74  20AE 000C 4816          move.l    12(A6),(A0)
                    4817   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00001C78  2042      4818          move.l    D2,A0
00001C7A  1144 0034 4819          move.b    D4,52(A0)
                    4820   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001C7E  2042      4821          move.l    D2,A0
00001C80  4228 0032 4822          clr.b     50(A0)
                    4823   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00001C84  2042      4824          move.l    D2,A0
00001C86  4228 0033 4825          clr.b     51(A0)
                    4826   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001C8A  2042      4827          move.l    D2,A0
00001C8C  42A8 002E 4828          clr.l     46(A0)
                    4829   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4830   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001C90  2042      4831          move.l    D2,A0
00001C92  216E 001C 4832          move.l    28(A6),4(A0)
00001C96  0004      
                    4833   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00001C98  2042      4834          move.l    D2,A0
00001C9A  216E 0018 4835          move.l    24(A6),12(A0)
00001C9E  000C      
                    4836   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001CA0  2042      4837          move.l    D2,A0
00001CA2  216E 0010 4838          move.l    16(A6),8(A0)
00001CA6  0008      
                    4839   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00001CA8  2042      4840          move.l    D2,A0
00001CAA  316E 0022 4841          move.w    34(A6),16(A0)
00001CAE  0010      
                    4842   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001CB0  2042      4843          move.l    D2,A0
00001CB2  316E 0016 4844          move.w    22(A6),18(A0)
00001CB6  0012      
                    4845   ; #else
                    4846   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4847   ; stk_size                 = stk_size;
                    4848   ; pbos                     = pbos;
                    4849   ; opt                      = opt;
                    4850   ; id                       = id;
                    4851   ; #endif
                    4852   ; #if OS_TASK_DEL_EN > 0u
                    4853   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
00001CB8  2042      4854          move.l    D2,A0
00001CBA  4228 0039 4855          clr.b     57(A0)
                    4856   ; #endif
                    4857   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4858   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001CBE  1004      4859          move.b    D4,D0
00001CC0  E608      4860          lsr.b     #3,D0
00001CC2  2042      4861          move.l    D2,A0
00001CC4  1140 0036 4862          move.b    D0,54(A0)
                    4863   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00001CC8  1004      4864          move.b    D4,D0
00001CCA  C03C 0007 4865          and.b     #7,D0
00001CCE  2042      4866          move.l    D2,A0
00001CD0  1140 0035 4867          move.b    D0,53(A0)
                    4868   ; #else                                                             /* Pre-compute X, Y                  */
                    4869   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4870   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4871   ; #endif
                    4872   ; /* Pre-compute BitX and BitY         */
                    4873   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
00001CD4  7001      4874          moveq     #1,D0
00001CD6  2042      4875          move.l    D2,A0
00001CD8  1228 0036 4876          move.b    54(A0),D1
00001CDC  C2BC 0000 4877          and.l     #255,D1
00001CE0  00FF      
00001CE2  E3A8      4878          lsl.l     D1,D0
00001CE4  2042      4879          move.l    D2,A0
00001CE6  1140 0038 4880          move.b    D0,56(A0)
                    4881   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00001CEA  7001      4882          moveq     #1,D0
00001CEC  2042      4883          move.l    D2,A0
00001CEE  1228 0035 4884          move.b    53(A0),D1
00001CF2  C2BC 0000 4885          and.l     #255,D1
00001CF6  00FF      
00001CF8  E3A8      4886          lsl.l     D1,D0
00001CFA  2042      4887          move.l    D2,A0
00001CFC  1140 0037 4888          move.b    D0,55(A0)
                    4889   ; #if (OS_EVENT_EN)
                    4890   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
00001D00  2042      4891          move.l    D2,A0
00001D02  42A8 001C 4892          clr.l     28(A0)
                    4893   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4894   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
00001D06  2042      4895          move.l    D2,A0
00001D08  42A8 0020 4896          clr.l     32(A0)
                    4897   ; #endif
                    4898   ; #endif
                    4899   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4900   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00001D0C  2042      4901          move.l    D2,A0
00001D0E  42A8 0028 4902          clr.l     40(A0)
                    4903   ; #endif
                    4904   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4905   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00001D12  2042      4906          move.l    D2,A0
00001D14  42A8 0024 4907          clr.l     36(A0)
                    4908   ; #endif
                    4909   ; #if OS_TASK_PROFILE_EN > 0u
                    4910   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00001D18  2042      4911          move.l    D2,A0
00001D1A  42A8 003A 4912          clr.l     58(A0)
                    4913   ; ptcb->OSTCBCyclesStart = 0uL;
00001D1E  2042      4914          move.l    D2,A0
00001D20  42A8 0042 4915          clr.l     66(A0)
                    4916   ; ptcb->OSTCBCyclesTot   = 0uL;
00001D24  2042      4917          move.l    D2,A0
00001D26  42A8 003E 4918          clr.l     62(A0)
                    4919   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
00001D2A  2042      4920          move.l    D2,A0
00001D2C  42A8 0046 4921          clr.l     70(A0)
                    4922   ; ptcb->OSTCBStkUsed     = 0uL;
00001D30  2042      4923          move.l    D2,A0
00001D32  42A8 004A 4924          clr.l     74(A0)
                    4925   ; #endif
                    4926   ; #if OS_TASK_NAME_EN > 0u
                    4927   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
00001D36  41F9 0000 4928          lea       @ucos_ii_1.L,A0
00001D3A  6AD0      
00001D3C  2242      4929          move.l    D2,A1
00001D3E  2348 004E 4930          move.l    A0,78(A1)
                    4931   ; #endif
                    4932   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4933   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00001D42  4203      4934          clr.b     D3
                    4935   OS_TCBInit_3:
00001D44  0C03 0001 4936          cmp.b     #1,D3
00001D48  6416      4937          bhs.s     OS_TCBInit_5
                    4938   ; ptcb->OSTCBRegTbl[i] = 0u;
00001D4A  2042      4939          move.l    D2,A0
00001D4C  C6BC 0000 4940          and.l     #255,D3
00001D50  00FF      
00001D52  2003      4941          move.l    D3,D0
00001D54  E588      4942          lsl.l     #2,D0
00001D56  D1C0      4943          add.l     D0,A0
00001D58  42A8 0052 4944          clr.l     82(A0)
00001D5C  5203      4945          addq.b    #1,D3
00001D5E  60E4      4946          bra       OS_TCBInit_3
                    4947   OS_TCBInit_5:
                    4948   ; }
                    4949   ; #endif
                    4950   ; OSTCBInitHook(ptcb);
00001D60  2F02      4951          move.l    D2,-(A7)
00001D62  4EB8 0D50 4952          jsr       _OSTCBInitHook
00001D66  584F      4953          addq.w    #4,A7
                    4954   ; OS_ENTER_CRITICAL();
00001D68  40E7      4955          dc.w      16615
00001D6A  007C      4956          dc.w      124
00001D6C  0700      4957          dc.w      1792
                    4958   ; OSTCBPrioTbl[prio] = ptcb;
00001D6E  C8BC 0000 4959          and.l     #255,D4
00001D72  00FF      
00001D74  2004      4960          move.l    D4,D0
00001D76  E588      4961          lsl.l     #2,D0
00001D78  41F9 0800 4962          lea       _OSTCBPrioTbl.L,A0
00001D7C  1030      
00001D7E  2182 0800 4963          move.l    D2,0(A0,D0.L)
                    4964   ; OS_EXIT_CRITICAL();
00001D82  46DF      4965          dc.w      18143
                    4966   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00001D84  2F02      4967          move.l    D2,-(A7)
00001D86  4EB8 0D06 4968          jsr       _OSTaskCreateHook
00001D8A  584F      4969          addq.w    #4,A7
                    4970   ; OS_ENTER_CRITICAL();
00001D8C  40E7      4971          dc.w      16615
00001D8E  007C      4972          dc.w      124
00001D90  0700      4973          dc.w      1792
                    4974   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00001D92  2042      4975          move.l    D2,A0
00001D94  2152 0014 4976          move.l    (A2),20(A0)
                    4977   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
00001D98  2042      4978          move.l    D2,A0
00001D9A  42A8 0018 4979          clr.l     24(A0)
                    4980   ; if (OSTCBList != (OS_TCB *)0) {
00001D9E  2012      4981          move.l    (A2),D0
00001DA0  6706      4982          beq.s     OS_TCBInit_6
                    4983   ; OSTCBList->OSTCBPrev = ptcb;
00001DA2  2052      4984          move.l    (A2),A0
00001DA4  2142 0018 4985          move.l    D2,24(A0)
                    4986   OS_TCBInit_6:
                    4987   ; }
                    4988   ; OSTCBList               = ptcb;
00001DA8  2482      4989          move.l    D2,(A2)
                    4990   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001DAA  2042      4991          move.l    D2,A0
00001DAC  1028 0038 4992          move.b    56(A0),D0
00001DB0  8139 0800 4993          or.b      D0,_OSRdyGrp.L
00001DB4  0F0E      
                    4994   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00001DB6  2042      4995          move.l    D2,A0
00001DB8  1028 0036 4996          move.b    54(A0),D0
00001DBC  C0BC 0000 4997          and.l     #255,D0
00001DC0  00FF      
00001DC2  41F9 0800 4998          lea       _OSRdyTbl.L,A0
00001DC6  0F10      
00001DC8  2242      4999          move.l    D2,A1
00001DCA  1229 0037 5000          move.b    55(A1),D1
00001DCE  8330 0800 5001          or.b      D1,0(A0,D0.L)
                    5002   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
00001DD2  5239 0800 5003          addq.b    #1,_OSTaskCtr.L
00001DD6  0F1A      
                    5004   ; OS_EXIT_CRITICAL();
00001DD8  46DF      5005          dc.w      18143
                    5006   ; return (OS_ERR_NONE);
00001DDA  4200      5007          clr.b     D0
00001DDC  6004      5008          bra.s     OS_TCBInit_8
                    5009   OS_TCBInit_1:
                    5010   ; }
                    5011   ; OS_EXIT_CRITICAL();
00001DDE  46DF      5012          dc.w      18143
                    5013   ; return (OS_ERR_TASK_NO_MORE_TCB);
00001DE0  7042      5014          moveq     #66,D0
                    5015   OS_TCBInit_8:
00001DE2  4CDF 041C 5016          movem.l   (A7)+,D2/D3/D4/A2
00001DE6  4E5E      5017          unlk      A6
00001DE8  4E75      5018          rts
                    5019   ; /*
                    5020   ; *********************************************************************************************************
                    5021   ; *                                                uC/OS-II
                    5022   ; *                                          The Real-Time Kernel
                    5023   ; *                                         EVENT FLAG  MANAGEMENT
                    5024   ; *
                    5025   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    5026   ; *                                           All Rights Reserved
                    5027   ; *
                    5028   ; * File    : OS_FLAG.C
                    5029   ; * By      : Jean J. Labrosse
                    5030   ; * Version : V2.92.07
                    5031   ; *
                    5032   ; * LICENSING TERMS:
                    5033   ; * ---------------
                    5034   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    5035   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    5036   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    5037   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    5038   ; * licensing fee.
                    5039   ; *********************************************************************************************************
                    5040   ; */
                    5041   ; #define  MICRIUM_SOURCE
                    5042   ; #ifndef  OS_MASTER_FILE
                    5043   ; #include <ucos_ii.h>
                    5044   ; #endif
                    5045   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    5046   ; /*
                    5047   ; *********************************************************************************************************
                    5048   ; *                                          LOCAL PROTOTYPES
                    5049   ; *********************************************************************************************************
                    5050   ; */
                    5051   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    5052   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    5053   ; /*$PAGE*/
                    5054   ; /*
                    5055   ; *********************************************************************************************************
                    5056   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    5057   ; *
                    5058   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    5059   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    5060   ; *              bits to be set/cleared.
                    5061   ; *
                    5062   ; *              This call does not block if the desired flags are not present.
                    5063   ; *
                    5064   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5065   ; *
                    5066   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    5067   ; *                            The bits you want are specified by setting the corresponding bits in
                    5068   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5069   ; *                            'flags' would contain 0x03.
                    5070   ; *
                    5071   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    5072   ; *                            to be set/cleared.
                    5073   ; *                            You can specify the following argument:
                    5074   ; *
                    5075   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    5076   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    5077   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    5078   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    5079   ; *
                    5080   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5081   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5082   ; *                                  the flags that are present, set 'wait_type' to:
                    5083   ; *
                    5084   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5085   ; *
                    5086   ; *              perr          is a pointer to an error code and can be:
                    5087   ; *                            OS_ERR_NONE               No error
                    5088   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5089   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5090   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    5091   ; *                                                      group handle.
                    5092   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    5093   ; *                                                      available.
                    5094   ; *
                    5095   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5096   ; *              occurred.
                    5097   ; *
                    5098   ; * Called from: Task or ISR
                    5099   ; *
                    5100   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5101   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5102   ; *                 event flags.
                    5103   ; *********************************************************************************************************
                    5104   ; */
                    5105   ; #if OS_FLAG_ACCEPT_EN > 0u
                    5106   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    5107   ; OS_FLAGS      flags,
                    5108   ; INT8U         wait_type,
                    5109   ; INT8U        *perr)
                    5110   ; {
                    5111   _OSFlagAccept:
00001DEA  4E56 FFFC 5112          link      A6,#-4
00001DEE  48E7 3F00 5113          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
00001DF2  262E 0008 5114          move.l    8(A6),D3
00001DF6  282E 0014 5115          move.l    20(A6),D4
00001DFA  3A2E 000E 5116          move.w    14(A6),D5
00001DFE  CABC 0000 5117          and.l     #65535,D5
00001E02  FFFF      
00001E04  1E2E 0013 5118          move.b    19(A6),D7
00001E08  CEBC 0000 5119          and.l     #255,D7
00001E0C  00FF      
                    5120   ; OS_FLAGS      flags_rdy;
                    5121   ; INT8U         result;
                    5122   ; BOOLEAN       consume;
                    5123   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5124   ; OS_CPU_SR     cpu_sr = 0u;
                    5125   ; #endif
                    5126   ; #ifdef OS_SAFETY_CRITICAL
                    5127   ; if (perr == (INT8U *)0) {
                    5128   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5129   ; return ((OS_FLAGS)0);
                    5130   ; }
                    5131   ; #endif
                    5132   ; #if OS_ARG_CHK_EN > 0u
                    5133   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5134   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5135   ; return ((OS_FLAGS)0);
                    5136   ; }
                    5137   ; #endif
                    5138   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001E0E  2043      5139          move.l    D3,A0
00001E10  1010      5140          move.b    (A0),D0
00001E12  0C00 0005 5141          cmp.b     #5,D0
00001E16  670C      5142          beq.s     OSFlagAccept_1
                    5143   ; *perr = OS_ERR_EVENT_TYPE;
00001E18  2044      5144          move.l    D4,A0
00001E1A  10BC 0001 5145          move.b    #1,(A0)
                    5146   ; return ((OS_FLAGS)0);
00001E1E  4240      5147          clr.w     D0
00001E20  6000 0100 5148          bra       OSFlagAccept_3
                    5149   OSFlagAccept_1:
                    5150   ; }
                    5151   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001E24  1007      5152          move.b    D7,D0
00001E26  C03C 0080 5153          and.b     #128,D0
00001E2A  1D40 FFFF 5154          move.b    D0,-1(A6)
                    5155   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001E2E  102E FFFF 5156          move.b    -1(A6),D0
00001E32  6708      5157          beq.s     OSFlagAccept_4
                    5158   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
00001E34  CE3C 007F 5159          and.b     #127,D7
                    5160   ; consume    = OS_TRUE;
00001E38  7C01      5161          moveq     #1,D6
00001E3A  6002      5162          bra.s     OSFlagAccept_5
                    5163   OSFlagAccept_4:
                    5164   ; } else {
                    5165   ; consume    = OS_FALSE;
00001E3C  4206      5166          clr.b     D6
                    5167   OSFlagAccept_5:
                    5168   ; }
                    5169   ; /*$PAGE*/
                    5170   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
00001E3E  2044      5171          move.l    D4,A0
00001E40  4210      5172          clr.b     (A0)
                    5173   ; OS_ENTER_CRITICAL();
00001E42  40E7      5174          dc.w      16615
00001E44  007C      5175          dc.w      124
00001E46  0700      5176          dc.w      1792
                    5177   ; switch (wait_type) {
00001E48  CEBC 0000 5178          and.l     #255,D7
00001E4C  00FF      
00001E4E  2007      5179          move.l    D7,D0
00001E50  0C80 0000 5180          cmp.l     #4,D0
00001E54  0004      
00001E56  6400 00BE 5181          bhs       OSFlagAccept_6
00001E5A  E380      5182          asl.l     #1,D0
00001E5C  303B 0806 5183          move.w    OSFlagAccept_8(PC,D0.L),D0
00001E60  4EFB 0002 5184          jmp       OSFlagAccept_8(PC,D0.W)
                    5185   OSFlagAccept_8:
00001E64  0060      5186          dc.w      OSFlagAccept_11-OSFlagAccept_8
00001E66  008A      5187          dc.w      OSFlagAccept_12-OSFlagAccept_8
00001E68  0008      5188          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001E6A  0034      5189          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    5190   OSFlagAccept_9:
                    5191   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5192   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001E6C  2043      5193          move.l    D3,A0
00001E6E  3028 0006 5194          move.w    6(A0),D0
00001E72  C045      5195          and.w     D5,D0
00001E74  3400      5196          move.w    D0,D2
                    5197   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001E76  B445      5198          cmp.w     D5,D2
00001E78  6612      5199          bne.s     OSFlagAccept_14
                    5200   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001E7A  0C06 0001 5201          cmp.b     #1,D6
00001E7E  660A      5202          bne.s     OSFlagAccept_16
                    5203   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001E80  2043      5204          move.l    D3,A0
00001E82  3002      5205          move.w    D2,D0
00001E84  4640      5206          not.w     D0
00001E86  C168 0006 5207          and.w     D0,6(A0)
                    5208   OSFlagAccept_16:
00001E8A  6006      5209          bra.s     OSFlagAccept_15
                    5210   OSFlagAccept_14:
                    5211   ; }
                    5212   ; } else {
                    5213   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001E8C  2044      5214          move.l    D4,A0
00001E8E  10BC 0070 5215          move.b    #112,(A0)
                    5216   OSFlagAccept_15:
                    5217   ; }
                    5218   ; OS_EXIT_CRITICAL();
00001E92  46DF      5219          dc.w      18143
                    5220   ; break;
00001E94  6000 008A 5221          bra       OSFlagAccept_7
                    5222   OSFlagAccept_10:
                    5223   ; case OS_FLAG_WAIT_SET_ANY:
                    5224   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001E98  2043      5225          move.l    D3,A0
00001E9A  3028 0006 5226          move.w    6(A0),D0
00001E9E  C045      5227          and.w     D5,D0
00001EA0  3400      5228          move.w    D0,D2
                    5229   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001EA2  4A42      5230          tst.w     D2
00001EA4  6712      5231          beq.s     OSFlagAccept_18
                    5232   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001EA6  0C06 0001 5233          cmp.b     #1,D6
00001EAA  660A      5234          bne.s     OSFlagAccept_20
                    5235   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001EAC  2043      5236          move.l    D3,A0
00001EAE  3002      5237          move.w    D2,D0
00001EB0  4640      5238          not.w     D0
00001EB2  C168 0006 5239          and.w     D0,6(A0)
                    5240   OSFlagAccept_20:
00001EB6  6006      5241          bra.s     OSFlagAccept_19
                    5242   OSFlagAccept_18:
                    5243   ; }
                    5244   ; } else {
                    5245   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001EB8  2044      5246          move.l    D4,A0
00001EBA  10BC 0070 5247          move.b    #112,(A0)
                    5248   OSFlagAccept_19:
                    5249   ; }
                    5250   ; OS_EXIT_CRITICAL();
00001EBE  46DF      5251          dc.w      18143
                    5252   ; break;
00001EC0  6000 005E 5253          bra       OSFlagAccept_7
                    5254   OSFlagAccept_11:
                    5255   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5256   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5257   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001EC4  2043      5258          move.l    D3,A0
00001EC6  3028 0006 5259          move.w    6(A0),D0
00001ECA  4640      5260          not.w     D0
00001ECC  C045      5261          and.w     D5,D0
00001ECE  3400      5262          move.w    D0,D2
                    5263   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001ED0  B445      5264          cmp.w     D5,D2
00001ED2  660E      5265          bne.s     OSFlagAccept_22
                    5266   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001ED4  0C06 0001 5267          cmp.b     #1,D6
00001ED8  6606      5268          bne.s     OSFlagAccept_24
                    5269   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001EDA  2043      5270          move.l    D3,A0
00001EDC  8568 0006 5271          or.w      D2,6(A0)
                    5272   OSFlagAccept_24:
00001EE0  6006      5273          bra.s     OSFlagAccept_23
                    5274   OSFlagAccept_22:
                    5275   ; }
                    5276   ; } else {
                    5277   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001EE2  2044      5278          move.l    D4,A0
00001EE4  10BC 0070 5279          move.b    #112,(A0)
                    5280   OSFlagAccept_23:
                    5281   ; }
                    5282   ; OS_EXIT_CRITICAL();
00001EE8  46DF      5283          dc.w      18143
                    5284   ; break;
00001EEA  6000 0034 5285          bra       OSFlagAccept_7
                    5286   OSFlagAccept_12:
                    5287   ; case OS_FLAG_WAIT_CLR_ANY:
                    5288   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001EEE  2043      5289          move.l    D3,A0
00001EF0  3028 0006 5290          move.w    6(A0),D0
00001EF4  4640      5291          not.w     D0
00001EF6  C045      5292          and.w     D5,D0
00001EF8  3400      5293          move.w    D0,D2
                    5294   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001EFA  4A42      5295          tst.w     D2
00001EFC  670E      5296          beq.s     OSFlagAccept_26
                    5297   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001EFE  0C06 0001 5298          cmp.b     #1,D6
00001F02  6606      5299          bne.s     OSFlagAccept_28
                    5300   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001F04  2043      5301          move.l    D3,A0
00001F06  8568 0006 5302          or.w      D2,6(A0)
                    5303   OSFlagAccept_28:
00001F0A  6006      5304          bra.s     OSFlagAccept_27
                    5305   OSFlagAccept_26:
                    5306   ; }
                    5307   ; } else {
                    5308   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001F0C  2044      5309          move.l    D4,A0
00001F0E  10BC 0070 5310          move.b    #112,(A0)
                    5311   OSFlagAccept_27:
                    5312   ; }
                    5313   ; OS_EXIT_CRITICAL();
00001F12  46DF      5314          dc.w      18143
                    5315   ; break;
00001F14  600A      5316          bra.s     OSFlagAccept_7
                    5317   OSFlagAccept_6:
                    5318   ; #endif
                    5319   ; default:
                    5320   ; OS_EXIT_CRITICAL();
00001F16  46DF      5321          dc.w      18143
                    5322   ; flags_rdy = (OS_FLAGS)0;
00001F18  4242      5323          clr.w     D2
                    5324   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
00001F1A  2044      5325          move.l    D4,A0
00001F1C  10BC 006F 5326          move.b    #111,(A0)
                    5327   ; break;
                    5328   OSFlagAccept_7:
                    5329   ; }
                    5330   ; return (flags_rdy);
00001F20  3002      5331          move.w    D2,D0
                    5332   OSFlagAccept_3:
00001F22  4CDF 00FC 5333          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
00001F26  4E5E      5334          unlk      A6
00001F28  4E75      5335          rts
                    5336   ; }
                    5337   ; #endif
                    5338   ; /*$PAGE*/
                    5339   ; /*
                    5340   ; *********************************************************************************************************
                    5341   ; *                                        CREATE AN EVENT FLAG
                    5342   ; *
                    5343   ; * Description: This function is called to create an event flag group.
                    5344   ; *
                    5345   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    5346   ; *
                    5347   ; *              perr          is a pointer to an error code which will be returned to your application:
                    5348   ; *                               OS_ERR_NONE               if the call was successful.
                    5349   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    5350   ; *                                                         ISR.
                    5351   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    5352   ; *
                    5353   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    5354   ; *
                    5355   ; * Called from: Task ONLY
                    5356   ; *********************************************************************************************************
                    5357   ; */
                    5358   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    5359   ; INT8U    *perr)
                    5360   ; {
                    5361   _OSFlagCreate:
00001F2A  4E56 0000 5362          link      A6,#0
00001F2E  48E7 3020 5363          movem.l   D2/D3/A2,-(A7)
00001F32  45F9 0800 5364          lea       _OSFlagFreeList.L,A2
00001F36  0DF6      
00001F38  262E 000C 5365          move.l    12(A6),D3
                    5366   ; OS_FLAG_GRP *pgrp;
                    5367   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    5368   ; OS_CPU_SR    cpu_sr = 0u;
                    5369   ; #endif
                    5370   ; #ifdef OS_SAFETY_CRITICAL
                    5371   ; if (perr == (INT8U *)0) {
                    5372   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5373   ; return ((OS_FLAG_GRP *)0);
                    5374   ; }
                    5375   ; #endif
                    5376   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    5377   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    5378   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5379   ; return ((OS_FLAG_GRP *)0);
                    5380   ; }
                    5381   ; #endif
                    5382   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001F3C  1039 0800 5383          move.b    _OSIntNesting.L,D0
00001F40  0F06      
00001F42  0C00 0000 5384          cmp.b     #0,D0
00001F46  630C      5385          bls.s     OSFlagCreate_1
                    5386   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
00001F48  2043      5387          move.l    D3,A0
00001F4A  10BC 0010 5388          move.b    #16,(A0)
                    5389   ; return ((OS_FLAG_GRP *)0);
00001F4E  4280      5390          clr.l     D0
00001F50  6000 0046 5391          bra       OSFlagCreate_3
                    5392   OSFlagCreate_1:
                    5393   ; }
                    5394   ; OS_ENTER_CRITICAL();
00001F54  40E7      5395          dc.w      16615
00001F56  007C      5396          dc.w      124
00001F58  0700      5397          dc.w      1792
                    5398   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001F5A  2412      5399          move.l    (A2),D2
                    5400   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001F5C  4A82      5401          tst.l     D2
00001F5E  672E      5402          beq.s     OSFlagCreate_4
                    5403   ; /* Adjust free list                                */
                    5404   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001F60  2052      5405          move.l    (A2),A0
00001F62  24A8 0002 5406          move.l    2(A0),(A2)
                    5407   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
00001F66  2042      5408          move.l    D2,A0
00001F68  10BC 0005 5409          move.b    #5,(A0)
                    5410   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001F6C  2042      5411          move.l    D2,A0
00001F6E  316E 000A 5412          move.w    10(A6),6(A0)
00001F72  0006      
                    5413   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
00001F74  2042      5414          move.l    D2,A0
00001F76  42A8 0002 5415          clr.l     2(A0)
                    5416   ; #if OS_FLAG_NAME_EN > 0u
                    5417   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001F7A  41F9 0000 5418          lea       @ucos_ii_1.L,A0
00001F7E  6AD0      
00001F80  2242      5419          move.l    D2,A1
00001F82  2348 0008 5420          move.l    A0,8(A1)
                    5421   ; #endif
                    5422   ; OS_EXIT_CRITICAL();
00001F86  46DF      5423          dc.w      18143
                    5424   ; *perr                = OS_ERR_NONE;
00001F88  2043      5425          move.l    D3,A0
00001F8A  4210      5426          clr.b     (A0)
00001F8C  6008      5427          bra.s     OSFlagCreate_5
                    5428   OSFlagCreate_4:
                    5429   ; } else {
                    5430   ; OS_EXIT_CRITICAL();
00001F8E  46DF      5431          dc.w      18143
                    5432   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001F90  2043      5433          move.l    D3,A0
00001F92  10BC 0072 5434          move.b    #114,(A0)
                    5435   OSFlagCreate_5:
                    5436   ; }
                    5437   ; return (pgrp);                                  /* Return pointer to event flag group              */
00001F96  2002      5438          move.l    D2,D0
                    5439   OSFlagCreate_3:
00001F98  4CDF 040C 5440          movem.l   (A7)+,D2/D3/A2
00001F9C  4E5E      5441          unlk      A6
00001F9E  4E75      5442          rts
                    5443   ; }
                    5444   ; /*$PAGE*/
                    5445   ; /*
                    5446   ; *********************************************************************************************************
                    5447   ; *                                     DELETE AN EVENT FLAG GROUP
                    5448   ; *
                    5449   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    5450   ; *              group.
                    5451   ; *
                    5452   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5453   ; *
                    5454   ; *              opt           determines delete options as follows:
                    5455   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    5456   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    5457   ; *                                                    waiting.  In this case, all the tasks pending will be
                    5458   ; *                                                    readied.
                    5459   ; *
                    5460   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    5461   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    5462   ; *                                                      deleted
                    5463   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    5464   ; *                                                      an ISR
                    5465   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5466   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    5467   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    5468   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    5469   ; *                                                      group.
                    5470   ; *
                    5471   ; * Returns    : pgrp          upon error
                    5472   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    5473   ; *
                    5474   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    5475   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    5476   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    5477   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    5478   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    5479   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    5480   ; *********************************************************************************************************
                    5481   ; */
                    5482   ; #if OS_FLAG_DEL_EN > 0u
                    5483   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    5484   ; INT8U         opt,
                    5485   ; INT8U        *perr)
                    5486   ; {
                    5487   _OSFlagDel:
00001FA0  4E56 0000 5488          link      A6,#0
00001FA4  48E7 3E20 5489          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
00001FA8  242E 0008 5490          move.l    8(A6),D2
00001FAC  262E 0010 5491          move.l    16(A6),D3
00001FB0  45F9 0800 5492          lea       _OSFlagFreeList.L,A2
00001FB4  0DF6      
                    5493   ; BOOLEAN       tasks_waiting;
                    5494   ; OS_FLAG_NODE *pnode;
                    5495   ; OS_FLAG_GRP  *pgrp_return;
                    5496   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5497   ; OS_CPU_SR     cpu_sr = 0u;
                    5498   ; #endif
                    5499   ; #ifdef OS_SAFETY_CRITICAL
                    5500   ; if (perr == (INT8U *)0) {
                    5501   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5502   ; return ((OS_FLAG_GRP *)0);
                    5503   ; }
                    5504   ; #endif
                    5505   ; #if OS_ARG_CHK_EN > 0u
                    5506   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5507   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5508   ; return (pgrp);
                    5509   ; }
                    5510   ; #endif
                    5511   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001FB6  1039 0800 5512          move.b    _OSIntNesting.L,D0
00001FBA  0F06      
00001FBC  0C00 0000 5513          cmp.b     #0,D0
00001FC0  630C      5514          bls.s     OSFlagDel_1
                    5515   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001FC2  2043      5516          move.l    D3,A0
00001FC4  10BC 000F 5517          move.b    #15,(A0)
                    5518   ; return (pgrp);
00001FC8  2002      5519          move.l    D2,D0
00001FCA  6000 00EC 5520          bra       OSFlagDel_3
                    5521   OSFlagDel_1:
                    5522   ; }
                    5523   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
00001FCE  2042      5524          move.l    D2,A0
00001FD0  1010      5525          move.b    (A0),D0
00001FD2  0C00 0005 5526          cmp.b     #5,D0
00001FD6  670C      5527          beq.s     OSFlagDel_4
                    5528   ; *perr = OS_ERR_EVENT_TYPE;
00001FD8  2043      5529          move.l    D3,A0
00001FDA  10BC 0001 5530          move.b    #1,(A0)
                    5531   ; return (pgrp);
00001FDE  2002      5532          move.l    D2,D0
00001FE0  6000 00D6 5533          bra       OSFlagDel_3
                    5534   OSFlagDel_4:
                    5535   ; }
                    5536   ; OS_ENTER_CRITICAL();
00001FE4  40E7      5537          dc.w      16615
00001FE6  007C      5538          dc.w      124
00001FE8  0700      5539          dc.w      1792
                    5540   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
00001FEA  2042      5541          move.l    D2,A0
00001FEC  2028 0002 5542          move.l    2(A0),D0
00001FF0  6704      5543          beq.s     OSFlagDel_6
                    5544   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00001FF2  7C01      5545          moveq     #1,D6
00001FF4  6002      5546          bra.s     OSFlagDel_7
                    5547   OSFlagDel_6:
                    5548   ; } else {
                    5549   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00001FF6  4206      5550          clr.b     D6
                    5551   OSFlagDel_7:
                    5552   ; }
                    5553   ; switch (opt) {
00001FF8  102E 000F 5554          move.b    15(A6),D0
00001FFC  C0BC 0000 5555          and.l     #255,D0
00002000  00FF      
00002002  0C80 0000 5556          cmp.l     #1,D0
00002006  0001      
00002008  6700 0048 5557          beq       OSFlagDel_11
0000200C  6200 009E 5558          bhi       OSFlagDel_8
00002010  4A80      5559          tst.l     D0
00002012  6704      5560          beq.s     OSFlagDel_10
00002014  6000 0096 5561          bra       OSFlagDel_8
                    5562   OSFlagDel_10:
                    5563   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    5564   ; if (tasks_waiting == OS_FALSE) {
00002018  4A06      5565          tst.b     D6
0000201A  6628      5566          bne.s     OSFlagDel_13
                    5567   ; #if OS_FLAG_NAME_EN > 0u
                    5568   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
0000201C  41F9 0000 5569          lea       @ucos_ii_1.L,A0
00002020  6AD0      
00002022  2242      5570          move.l    D2,A1
00002024  2348 0008 5571          move.l    A0,8(A1)
                    5572   ; #endif
                    5573   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002028  2042      5574          move.l    D2,A0
0000202A  4210      5575          clr.b     (A0)
                    5576   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
0000202C  2042      5577          move.l    D2,A0
0000202E  2152 0002 5578          move.l    (A2),2(A0)
                    5579   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00002032  2042      5580          move.l    D2,A0
00002034  4268 0006 5581          clr.w     6(A0)
                    5582   ; OSFlagFreeList       = pgrp;
00002038  2482      5583          move.l    D2,(A2)
                    5584   ; OS_EXIT_CRITICAL();
0000203A  46DF      5585          dc.w      18143
                    5586   ; *perr                = OS_ERR_NONE;
0000203C  2043      5587          move.l    D3,A0
0000203E  4210      5588          clr.b     (A0)
                    5589   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00002040  4285      5590          clr.l     D5
00002042  600A      5591          bra.s     OSFlagDel_14
                    5592   OSFlagDel_13:
                    5593   ; } else {
                    5594   ; OS_EXIT_CRITICAL();
00002044  46DF      5595          dc.w      18143
                    5596   ; *perr                = OS_ERR_TASK_WAITING;
00002046  2043      5597          move.l    D3,A0
00002048  10BC 0049 5598          move.b    #73,(A0)
                    5599   ; pgrp_return          = pgrp;
0000204C  2A02      5600          move.l    D2,D5
                    5601   OSFlagDel_14:
                    5602   ; }
                    5603   ; break;
0000204E  6000 0066 5604          bra       OSFlagDel_9
                    5605   OSFlagDel_11:
                    5606   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    5607   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00002052  2042      5608          move.l    D2,A0
00002054  2828 0002 5609          move.l    2(A0),D4
                    5610   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    5611   OSFlagDel_15:
00002058  4A84      5612          tst.l     D4
0000205A  671E      5613          beq.s     OSFlagDel_17
                    5614   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
0000205C  4878 0002 5615          pea       2
00002060  42A7      5616          clr.l     -(A7)
00002062  2F04      5617          move.l    D4,-(A7)
00002064  4EB9 0000 5618          jsr       @ucos_ii_OS_FlagTaskRdy
00002068  27D6      
0000206A  DEFC 000C 5619          add.w     #12,A7
0000206E  C0BC 0000 5620          and.l     #255,D0
00002072  00FF      
                    5621   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00002074  2044      5622          move.l    D4,A0
00002076  2810      5623          move.l    (A0),D4
00002078  60DE      5624          bra       OSFlagDel_15
                    5625   OSFlagDel_17:
                    5626   ; }
                    5627   ; #if OS_FLAG_NAME_EN > 0u
                    5628   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
0000207A  41F9 0000 5629          lea       @ucos_ii_1.L,A0
0000207E  6AD0      
00002080  2242      5630          move.l    D2,A1
00002082  2348 0008 5631          move.l    A0,8(A1)
                    5632   ; #endif
                    5633   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002086  2042      5634          move.l    D2,A0
00002088  4210      5635          clr.b     (A0)
                    5636   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
0000208A  2042      5637          move.l    D2,A0
0000208C  2152 0002 5638          move.l    (A2),2(A0)
                    5639   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00002090  2042      5640          move.l    D2,A0
00002092  4268 0006 5641          clr.w     6(A0)
                    5642   ; OSFlagFreeList       = pgrp;
00002096  2482      5643          move.l    D2,(A2)
                    5644   ; OS_EXIT_CRITICAL();
00002098  46DF      5645          dc.w      18143
                    5646   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000209A  0C06 0001 5647          cmp.b     #1,D6
0000209E  6604      5648          bne.s     OSFlagDel_18
                    5649   ; OS_Sched();                               /* Find highest priority task ready to run  */
000020A0  4EB8 1A22 5650          jsr       _OS_Sched
                    5651   OSFlagDel_18:
                    5652   ; }
                    5653   ; *perr = OS_ERR_NONE;
000020A4  2043      5654          move.l    D3,A0
000020A6  4210      5655          clr.b     (A0)
                    5656   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
000020A8  4285      5657          clr.l     D5
                    5658   ; break;
000020AA  600A      5659          bra.s     OSFlagDel_9
                    5660   OSFlagDel_8:
                    5661   ; default:
                    5662   ; OS_EXIT_CRITICAL();
000020AC  46DF      5663          dc.w      18143
                    5664   ; *perr                = OS_ERR_INVALID_OPT;
000020AE  2043      5665          move.l    D3,A0
000020B0  10BC 0007 5666          move.b    #7,(A0)
                    5667   ; pgrp_return          = pgrp;
000020B4  2A02      5668          move.l    D2,D5
                    5669   ; break;
                    5670   OSFlagDel_9:
                    5671   ; }
                    5672   ; return (pgrp_return);
000020B6  2005      5673          move.l    D5,D0
                    5674   OSFlagDel_3:
000020B8  4CDF 047C 5675          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
000020BC  4E5E      5676          unlk      A6
000020BE  4E75      5677          rts
                    5678   ; }
                    5679   ; #endif
                    5680   ; /*$PAGE*/
                    5681   ; /*
                    5682   ; *********************************************************************************************************
                    5683   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5684   ; *
                    5685   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5686   ; *
                    5687   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5688   ; *
                    5689   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5690   ; *                        group.
                    5691   ; *
                    5692   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5693   ; *
                    5694   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5695   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5696   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5697   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5698   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5699   ; *
                    5700   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5701   ; *********************************************************************************************************
                    5702   ; */
                    5703   ; #if OS_FLAG_NAME_EN > 0u
                    5704   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5705   ; INT8U        **pname,
                    5706   ; INT8U         *perr)
                    5707   ; {
                    5708   _OSFlagNameGet:
000020C0  4E56 FFFC 5709          link      A6,#-4
000020C4  2F02      5710          move.l    D2,-(A7)
000020C6  242E 0010 5711          move.l    16(A6),D2
                    5712   ; INT8U      len;
                    5713   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5714   ; OS_CPU_SR  cpu_sr = 0u;
                    5715   ; #endif
                    5716   ; #ifdef OS_SAFETY_CRITICAL
                    5717   ; if (perr == (INT8U *)0) {
                    5718   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5719   ; return (0u);
                    5720   ; }
                    5721   ; #endif
                    5722   ; #if OS_ARG_CHK_EN > 0u
                    5723   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5724   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5725   ; return (0u);
                    5726   ; }
                    5727   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5728   ; *perr = OS_ERR_PNAME_NULL;
                    5729   ; return (0u);
                    5730   ; }
                    5731   ; #endif
                    5732   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000020CA  1039 0800 5733          move.b    _OSIntNesting.L,D0
000020CE  0F06      
000020D0  0C00 0000 5734          cmp.b     #0,D0
000020D4  630C      5735          bls.s     OSFlagNameGet_1
                    5736   ; *perr = OS_ERR_NAME_GET_ISR;
000020D6  2042      5737          move.l    D2,A0
000020D8  10BC 0011 5738          move.b    #17,(A0)
                    5739   ; return (0u);
000020DC  4200      5740          clr.b     D0
000020DE  6000 0046 5741          bra       OSFlagNameGet_3
                    5742   OSFlagNameGet_1:
                    5743   ; }
                    5744   ; OS_ENTER_CRITICAL();
000020E2  40E7      5745          dc.w      16615
000020E4  007C      5746          dc.w      124
000020E6  0700      5747          dc.w      1792
                    5748   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
000020E8  206E 0008 5749          move.l    8(A6),A0
000020EC  1010      5750          move.b    (A0),D0
000020EE  0C00 0005 5751          cmp.b     #5,D0
000020F2  670C      5752          beq.s     OSFlagNameGet_4
                    5753   ; OS_EXIT_CRITICAL();
000020F4  46DF      5754          dc.w      18143
                    5755   ; *perr = OS_ERR_EVENT_TYPE;
000020F6  2042      5756          move.l    D2,A0
000020F8  10BC 0001 5757          move.b    #1,(A0)
                    5758   ; return (0u);
000020FC  4200      5759          clr.b     D0
000020FE  6026      5760          bra.s     OSFlagNameGet_3
                    5761   OSFlagNameGet_4:
                    5762   ; }
                    5763   ; *pname = pgrp->OSFlagName;
00002100  206E 0008 5764          move.l    8(A6),A0
00002104  226E 000C 5765          move.l    12(A6),A1
00002108  22A8 0008 5766          move.l    8(A0),(A1)
                    5767   ; len    = OS_StrLen(*pname);
0000210C  206E 000C 5768          move.l    12(A6),A0
00002110  2F10      5769          move.l    (A0),-(A7)
00002112  4EB8 1ACC 5770          jsr       _OS_StrLen
00002116  584F      5771          addq.w    #4,A7
00002118  1D40 FFFF 5772          move.b    D0,-1(A6)
                    5773   ; OS_EXIT_CRITICAL();
0000211C  46DF      5774          dc.w      18143
                    5775   ; *perr  = OS_ERR_NONE;
0000211E  2042      5776          move.l    D2,A0
00002120  4210      5777          clr.b     (A0)
                    5778   ; return (len);
00002122  102E FFFF 5779          move.b    -1(A6),D0
                    5780   OSFlagNameGet_3:
00002126  241F      5781          move.l    (A7)+,D2
00002128  4E5E      5782          unlk      A6
0000212A  4E75      5783          rts
                    5784   ; }
                    5785   ; #endif
                    5786   ; /*$PAGE*/
                    5787   ; /*
                    5788   ; *********************************************************************************************************
                    5789   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5790   ; *
                    5791   ; * Description: This function assigns a name to an event flag group.
                    5792   ; *
                    5793   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5794   ; *
                    5795   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5796   ; *                        group.
                    5797   ; *
                    5798   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5799   ; *
                    5800   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5801   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5802   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5803   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5804   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5805   ; *
                    5806   ; * Returns    : None
                    5807   ; *********************************************************************************************************
                    5808   ; */
                    5809   ; #if OS_FLAG_NAME_EN > 0u
                    5810   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5811   ; INT8U        *pname,
                    5812   ; INT8U        *perr)
                    5813   ; {
                    5814   _OSFlagNameSet:
0000212C  4E56 0000 5815          link      A6,#0
00002130  2F02      5816          move.l    D2,-(A7)
00002132  242E 0010 5817          move.l    16(A6),D2
                    5818   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5819   ; OS_CPU_SR  cpu_sr = 0u;
                    5820   ; #endif
                    5821   ; #ifdef OS_SAFETY_CRITICAL
                    5822   ; if (perr == (INT8U *)0) {
                    5823   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5824   ; return;
                    5825   ; }
                    5826   ; #endif
                    5827   ; #if OS_ARG_CHK_EN > 0u
                    5828   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5829   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5830   ; return;
                    5831   ; }
                    5832   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5833   ; *perr = OS_ERR_PNAME_NULL;
                    5834   ; return;
                    5835   ; }
                    5836   ; #endif
                    5837   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002136  1039 0800 5838          move.b    _OSIntNesting.L,D0
0000213A  0F06      
0000213C  0C00 0000 5839          cmp.b     #0,D0
00002140  630A      5840          bls.s     OSFlagNameSet_1
                    5841   ; *perr = OS_ERR_NAME_SET_ISR;
00002142  2042      5842          move.l    D2,A0
00002144  10BC 0012 5843          move.b    #18,(A0)
                    5844   ; return;
00002148  6000 002E 5845          bra       OSFlagNameSet_3
                    5846   OSFlagNameSet_1:
                    5847   ; }
                    5848   ; OS_ENTER_CRITICAL();
0000214C  40E7      5849          dc.w      16615
0000214E  007C      5850          dc.w      124
00002150  0700      5851          dc.w      1792
                    5852   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00002152  206E 0008 5853          move.l    8(A6),A0
00002156  1010      5854          move.b    (A0),D0
00002158  0C00 0005 5855          cmp.b     #5,D0
0000215C  670A      5856          beq.s     OSFlagNameSet_4
                    5857   ; OS_EXIT_CRITICAL();
0000215E  46DF      5858          dc.w      18143
                    5859   ; *perr = OS_ERR_EVENT_TYPE;
00002160  2042      5860          move.l    D2,A0
00002162  10BC 0001 5861          move.b    #1,(A0)
                    5862   ; return;
00002166  6010      5863          bra.s     OSFlagNameSet_3
                    5864   OSFlagNameSet_4:
                    5865   ; }
                    5866   ; pgrp->OSFlagName = pname;
00002168  206E 0008 5867          move.l    8(A6),A0
0000216C  216E 000C 5868          move.l    12(A6),8(A0)
00002170  0008      
                    5869   ; OS_EXIT_CRITICAL();
00002172  46DF      5870          dc.w      18143
                    5871   ; *perr            = OS_ERR_NONE;
00002174  2042      5872          move.l    D2,A0
00002176  4210      5873          clr.b     (A0)
                    5874   ; return;
                    5875   OSFlagNameSet_3:
00002178  241F      5876          move.l    (A7)+,D2
0000217A  4E5E      5877          unlk      A6
0000217C  4E75      5878          rts
                    5879   ; }
                    5880   ; #endif
                    5881   ; /*$PAGE*/
                    5882   ; /*
                    5883   ; *********************************************************************************************************
                    5884   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5885   ; *
                    5886   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5887   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5888   ; *
                    5889   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5890   ; *
                    5891   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5892   ; *                            The bits you want are specified by setting the corresponding bits in
                    5893   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5894   ; *                            'flags' would contain 0x03.
                    5895   ; *
                    5896   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5897   ; *                            You can specify the following argument:
                    5898   ; *
                    5899   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5900   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5901   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5902   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5903   ; *
                    5904   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5905   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5906   ; *                                  the flags that are present, set 'wait_type' to:
                    5907   ; *
                    5908   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5909   ; *
                    5910   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5911   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5912   ; *                            forever at the specified event flag group or, until a message arrives.
                    5913   ; *
                    5914   ; *              perr          is a pointer to an error code and can be:
                    5915   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5916   ; *                                                      'timeout'.
                    5917   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5918   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5919   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5920   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5921   ; *                                                      'timeout'.
                    5922   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5923   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5924   ; *
                    5925   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5926   ; *              occurred.
                    5927   ; *
                    5928   ; * Called from: Task ONLY
                    5929   ; *
                    5930   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5931   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5932   ; *                 event flags.
                    5933   ; *********************************************************************************************************
                    5934   ; */
                    5935   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5936   ; OS_FLAGS      flags,
                    5937   ; INT8U         wait_type,
                    5938   ; INT32U        timeout,
                    5939   ; INT8U        *perr)
                    5940   ; {
                    5941   _OSFlagPend:
0000217E  4E56 FFE8 5942          link      A6,#-24
00002182  48E7 3F3C 5943          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002186  262E 0008 5944          move.l    8(A6),D3
0000218A  282E 0018 5945          move.l    24(A6),D4
0000218E  3A2E 000E 5946          move.w    14(A6),D5
00002192  CABC 0000 5947          and.l     #65535,D5
00002196  FFFF      
00002198  45F9 0800 5948          lea       _OSTCBCur.L,A2
0000219C  1020      
0000219E  1C2E 0013 5949          move.b    19(A6),D6
000021A2  CCBC 0000 5950          and.l     #255,D6
000021A6  00FF      
000021A8  47EE FFEA 5951          lea       -22(A6),A3
000021AC  286E 0014 5952          move.l    20(A6),A4
000021B0  4BF9 0000 5953          lea       @ucos_ii_OS_FlagBlock.L,A5
000021B4  2678      
                    5954   ; OS_FLAG_NODE  node;
                    5955   ; OS_FLAGS      flags_rdy;
                    5956   ; INT8U         result;
                    5957   ; INT8U         pend_stat;
                    5958   ; BOOLEAN       consume;
                    5959   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5960   ; OS_CPU_SR     cpu_sr = 0u;
                    5961   ; #endif
                    5962   ; #ifdef OS_SAFETY_CRITICAL
                    5963   ; if (perr == (INT8U *)0) {
                    5964   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5965   ; return ((OS_FLAGS)0);
                    5966   ; }
                    5967   ; #endif
                    5968   ; #if OS_ARG_CHK_EN > 0u
                    5969   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5970   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5971   ; return ((OS_FLAGS)0);
                    5972   ; }
                    5973   ; #endif
                    5974   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000021B6  1039 0800 5975          move.b    _OSIntNesting.L,D0
000021BA  0F06      
000021BC  0C00 0000 5976          cmp.b     #0,D0
000021C0  630C      5977          bls.s     OSFlagPend_1
                    5978   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000021C2  2044      5979          move.l    D4,A0
000021C4  10BC 0002 5980          move.b    #2,(A0)
                    5981   ; return ((OS_FLAGS)0);
000021C8  4240      5982          clr.w     D0
000021CA  6000 028A 5983          bra       OSFlagPend_3
                    5984   OSFlagPend_1:
                    5985   ; }
                    5986   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
000021CE  1039 0800 5987          move.b    _OSLockNesting.L,D0
000021D2  0F08      
000021D4  0C00 0000 5988          cmp.b     #0,D0
000021D8  630C      5989          bls.s     OSFlagPend_4
                    5990   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
000021DA  2044      5991          move.l    D4,A0
000021DC  10BC 000D 5992          move.b    #13,(A0)
                    5993   ; return ((OS_FLAGS)0);
000021E0  4240      5994          clr.w     D0
000021E2  6000 0272 5995          bra       OSFlagPend_3
                    5996   OSFlagPend_4:
                    5997   ; }
                    5998   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000021E6  2043      5999          move.l    D3,A0
000021E8  1010      6000          move.b    (A0),D0
000021EA  0C00 0005 6001          cmp.b     #5,D0
000021EE  670C      6002          beq.s     OSFlagPend_6
                    6003   ; *perr = OS_ERR_EVENT_TYPE;
000021F0  2044      6004          move.l    D4,A0
000021F2  10BC 0001 6005          move.b    #1,(A0)
                    6006   ; return ((OS_FLAGS)0);
000021F6  4240      6007          clr.w     D0
000021F8  6000 025C 6008          bra       OSFlagPend_3
                    6009   OSFlagPend_6:
                    6010   ; }
                    6011   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
000021FC  1006      6012          move.b    D6,D0
000021FE  C03C 0080 6013          and.b     #128,D0
00002202  1D40 FFFE 6014          move.b    D0,-2(A6)
                    6015   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00002206  102E FFFE 6016          move.b    -2(A6),D0
0000220A  670C      6017          beq.s     OSFlagPend_8
                    6018   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
0000220C  103C 0080 6019          move.b    #128,D0
00002210  4600      6020          not.b     D0
00002212  CC00      6021          and.b     D0,D6
                    6022   ; consume    = OS_TRUE;
00002214  7E01      6023          moveq     #1,D7
00002216  6002      6024          bra.s     OSFlagPend_9
                    6025   OSFlagPend_8:
                    6026   ; } else {
                    6027   ; consume    = OS_FALSE;
00002218  7E00      6028          moveq     #0,D7
                    6029   OSFlagPend_9:
                    6030   ; }
                    6031   ; /*$PAGE*/
                    6032   ; OS_ENTER_CRITICAL();
0000221A  40E7      6033          dc.w      16615
0000221C  007C      6034          dc.w      124
0000221E  0700      6035          dc.w      1792
                    6036   ; switch (wait_type) {
00002220  CCBC 0000 6037          and.l     #255,D6
00002224  00FF      
00002226  2006      6038          move.l    D6,D0
00002228  0C80 0000 6039          cmp.l     #4,D0
0000222C  0004      
0000222E  6400 0156 6040          bhs       OSFlagPend_10
00002232  E380      6041          asl.l     #1,D0
00002234  303B 0806 6042          move.w    OSFlagPend_12(PC,D0.L),D0
00002238  4EFB 0002 6043          jmp       OSFlagPend_12(PC,D0.W)
                    6044   OSFlagPend_12:
0000223C  00AC      6045          dc.w      OSFlagPend_15-OSFlagPend_12
0000223E  00FC      6046          dc.w      OSFlagPend_16-OSFlagPend_12
00002240  0008      6047          dc.w      OSFlagPend_13-OSFlagPend_12
00002242  005A      6048          dc.w      OSFlagPend_14-OSFlagPend_12
                    6049   OSFlagPend_13:
                    6050   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    6051   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00002244  2043      6052          move.l    D3,A0
00002246  3028 0006 6053          move.w    6(A0),D0
0000224A  C045      6054          and.w     D5,D0
0000224C  3400      6055          move.w    D0,D2
                    6056   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
0000224E  B445      6057          cmp.w     D5,D2
00002250  6622      6058          bne.s     OSFlagPend_18
                    6059   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002252  0C07 0001 6060          cmp.b     #1,D7
00002256  660A      6061          bne.s     OSFlagPend_20
                    6062   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
00002258  2043      6063          move.l    D3,A0
0000225A  3002      6064          move.w    D2,D0
0000225C  4640      6065          not.w     D0
0000225E  C168 0006 6066          and.w     D0,6(A0)
                    6067   OSFlagPend_20:
                    6068   ; }
                    6069   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002262  2052      6070          move.l    (A2),A0
00002264  3142 002C 6071          move.w    D2,44(A0)
                    6072   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00002268  46DF      6073          dc.w      18143
                    6074   ; *perr                   = OS_ERR_NONE;
0000226A  2044      6075          move.l    D4,A0
0000226C  4210      6076          clr.b     (A0)
                    6077   ; return (flags_rdy);
0000226E  3002      6078          move.w    D2,D0
00002270  6000 01E4 6079          bra       OSFlagPend_3
                    6080   OSFlagPend_18:
                    6081   ; } else {                                      /* Block task until events occur or timeout */
                    6082   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002274  2F0C      6083          move.l    A4,-(A7)
00002276  CCBC 0000 6084          and.l     #255,D6
0000227A  00FF      
0000227C  2F06      6085          move.l    D6,-(A7)
0000227E  CABC 0000 6086          and.l     #65535,D5
00002282  FFFF      
00002284  2F05      6087          move.l    D5,-(A7)
00002286  2F0B      6088          move.l    A3,-(A7)
00002288  2F03      6089          move.l    D3,-(A7)
0000228A  4E95      6090          jsr       (A5)
0000228C  DEFC 0014 6091          add.w     #20,A7
                    6092   ; OS_EXIT_CRITICAL();
00002290  46DF      6093          dc.w      18143
                    6094   ; }
                    6095   ; break;
00002292  6000 0102 6096          bra       OSFlagPend_11
                    6097   OSFlagPend_14:
                    6098   ; case OS_FLAG_WAIT_SET_ANY:
                    6099   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
00002296  2043      6100          move.l    D3,A0
00002298  3028 0006 6101          move.w    6(A0),D0
0000229C  C045      6102          and.w     D5,D0
0000229E  3400      6103          move.w    D0,D2
                    6104   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
000022A0  4A42      6105          tst.w     D2
000022A2  6722      6106          beq.s     OSFlagPend_22
                    6107   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000022A4  0C07 0001 6108          cmp.b     #1,D7
000022A8  660A      6109          bne.s     OSFlagPend_24
                    6110   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
000022AA  2043      6111          move.l    D3,A0
000022AC  3002      6112          move.w    D2,D0
000022AE  4640      6113          not.w     D0
000022B0  C168 0006 6114          and.w     D0,6(A0)
                    6115   OSFlagPend_24:
                    6116   ; }
                    6117   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
000022B4  2052      6118          move.l    (A2),A0
000022B6  3142 002C 6119          move.w    D2,44(A0)
                    6120   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
000022BA  46DF      6121          dc.w      18143
                    6122   ; *perr                   = OS_ERR_NONE;
000022BC  2044      6123          move.l    D4,A0
000022BE  4210      6124          clr.b     (A0)
                    6125   ; return (flags_rdy);
000022C0  3002      6126          move.w    D2,D0
000022C2  6000 0192 6127          bra       OSFlagPend_3
                    6128   OSFlagPend_22:
                    6129   ; } else {                                      /* Block task until events occur or timeout */
                    6130   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
000022C6  2F0C      6131          move.l    A4,-(A7)
000022C8  CCBC 0000 6132          and.l     #255,D6
000022CC  00FF      
000022CE  2F06      6133          move.l    D6,-(A7)
000022D0  CABC 0000 6134          and.l     #65535,D5
000022D4  FFFF      
000022D6  2F05      6135          move.l    D5,-(A7)
000022D8  2F0B      6136          move.l    A3,-(A7)
000022DA  2F03      6137          move.l    D3,-(A7)
000022DC  4E95      6138          jsr       (A5)
000022DE  DEFC 0014 6139          add.w     #20,A7
                    6140   ; OS_EXIT_CRITICAL();
000022E2  46DF      6141          dc.w      18143
                    6142   ; }
                    6143   ; break;
000022E4  6000 00B0 6144          bra       OSFlagPend_11
                    6145   OSFlagPend_15:
                    6146   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6147   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    6148   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
000022E8  2043      6149          move.l    D3,A0
000022EA  3028 0006 6150          move.w    6(A0),D0
000022EE  4640      6151          not.w     D0
000022F0  C045      6152          and.w     D5,D0
000022F2  3400      6153          move.w    D0,D2
                    6154   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
000022F4  B445      6155          cmp.w     D5,D2
000022F6  661E      6156          bne.s     OSFlagPend_26
                    6157   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000022F8  0C07 0001 6158          cmp.b     #1,D7
000022FC  6606      6159          bne.s     OSFlagPend_28
                    6160   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
000022FE  2043      6161          move.l    D3,A0
00002300  8568 0006 6162          or.w      D2,6(A0)
                    6163   OSFlagPend_28:
                    6164   ; }
                    6165   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002304  2052      6166          move.l    (A2),A0
00002306  3142 002C 6167          move.w    D2,44(A0)
                    6168   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0000230A  46DF      6169          dc.w      18143
                    6170   ; *perr                   = OS_ERR_NONE;
0000230C  2044      6171          move.l    D4,A0
0000230E  4210      6172          clr.b     (A0)
                    6173   ; return (flags_rdy);
00002310  3002      6174          move.w    D2,D0
00002312  6000 0142 6175          bra       OSFlagPend_3
                    6176   OSFlagPend_26:
                    6177   ; } else {                                      /* Block task until events occur or timeout */
                    6178   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002316  2F0C      6179          move.l    A4,-(A7)
00002318  CCBC 0000 6180          and.l     #255,D6
0000231C  00FF      
0000231E  2F06      6181          move.l    D6,-(A7)
00002320  CABC 0000 6182          and.l     #65535,D5
00002324  FFFF      
00002326  2F05      6183          move.l    D5,-(A7)
00002328  2F0B      6184          move.l    A3,-(A7)
0000232A  2F03      6185          move.l    D3,-(A7)
0000232C  4E95      6186          jsr       (A5)
0000232E  DEFC 0014 6187          add.w     #20,A7
                    6188   ; OS_EXIT_CRITICAL();
00002332  46DF      6189          dc.w      18143
                    6190   ; }
                    6191   ; break;
00002334  6000 0060 6192          bra       OSFlagPend_11
                    6193   OSFlagPend_16:
                    6194   ; case OS_FLAG_WAIT_CLR_ANY:
                    6195   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00002338  2043      6196          move.l    D3,A0
0000233A  3028 0006 6197          move.w    6(A0),D0
0000233E  4640      6198          not.w     D0
00002340  C045      6199          and.w     D5,D0
00002342  3400      6200          move.w    D0,D2
                    6201   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00002344  4A42      6202          tst.w     D2
00002346  671E      6203          beq.s     OSFlagPend_30
                    6204   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002348  0C07 0001 6205          cmp.b     #1,D7
0000234C  6606      6206          bne.s     OSFlagPend_32
                    6207   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
0000234E  2043      6208          move.l    D3,A0
00002350  8568 0006 6209          or.w      D2,6(A0)
                    6210   OSFlagPend_32:
                    6211   ; }
                    6212   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002354  2052      6213          move.l    (A2),A0
00002356  3142 002C 6214          move.w    D2,44(A0)
                    6215   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0000235A  46DF      6216          dc.w      18143
                    6217   ; *perr                   = OS_ERR_NONE;
0000235C  2044      6218          move.l    D4,A0
0000235E  4210      6219          clr.b     (A0)
                    6220   ; return (flags_rdy);
00002360  3002      6221          move.w    D2,D0
00002362  6000 00F2 6222          bra       OSFlagPend_3
                    6223   OSFlagPend_30:
                    6224   ; } else {                                      /* Block task until events occur or timeout */
                    6225   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002366  2F0C      6226          move.l    A4,-(A7)
00002368  CCBC 0000 6227          and.l     #255,D6
0000236C  00FF      
0000236E  2F06      6228          move.l    D6,-(A7)
00002370  CABC 0000 6229          and.l     #65535,D5
00002374  FFFF      
00002376  2F05      6230          move.l    D5,-(A7)
00002378  2F0B      6231          move.l    A3,-(A7)
0000237A  2F03      6232          move.l    D3,-(A7)
0000237C  4E95      6233          jsr       (A5)
0000237E  DEFC 0014 6234          add.w     #20,A7
                    6235   ; OS_EXIT_CRITICAL();
00002382  46DF      6236          dc.w      18143
                    6237   ; }
                    6238   ; break;
00002384  6010      6239          bra.s     OSFlagPend_11
                    6240   OSFlagPend_10:
                    6241   ; #endif
                    6242   ; default:
                    6243   ; OS_EXIT_CRITICAL();
00002386  46DF      6244          dc.w      18143
                    6245   ; flags_rdy = (OS_FLAGS)0;
00002388  4242      6246          clr.w     D2
                    6247   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
0000238A  2044      6248          move.l    D4,A0
0000238C  10BC 006F 6249          move.b    #111,(A0)
                    6250   ; return (flags_rdy);
00002390  3002      6251          move.w    D2,D0
00002392  6000 00C2 6252          bra       OSFlagPend_3
                    6253   OSFlagPend_11:
                    6254   ; }
                    6255   ; /*$PAGE*/
                    6256   ; OS_Sched();                                            /* Find next HPT ready to run               */
00002396  4EB8 1A22 6257          jsr       _OS_Sched
                    6258   ; OS_ENTER_CRITICAL();
0000239A  40E7      6259          dc.w      16615
0000239C  007C      6260          dc.w      124
0000239E  0700      6261          dc.w      1792
                    6262   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
000023A0  2052      6263          move.l    (A2),A0
000023A2  1028 0033 6264          move.b    51(A0),D0
000023A6  6700 0056 6265          beq       OSFlagPend_34
                    6266   ; pend_stat                = OSTCBCur->OSTCBStatPend;
000023AA  2052      6267          move.l    (A2),A0
000023AC  1D68 0033 6268          move.b    51(A0),-1(A6)
000023B0  FFFF      
                    6269   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000023B2  2052      6270          move.l    (A2),A0
000023B4  4228 0033 6271          clr.b     51(A0)
                    6272   ; OS_FlagUnlink(&node);
000023B8  2F0B      6273          move.l    A3,-(A7)
000023BA  4EB9 0000 6274          jsr       _OS_FlagUnlink
000023BE  2852      
000023C0  584F      6275          addq.w    #4,A7
                    6276   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
000023C2  2052      6277          move.l    (A2),A0
000023C4  4228 0032 6278          clr.b     50(A0)
                    6279   ; OS_EXIT_CRITICAL();
000023C8  46DF      6280          dc.w      18143
                    6281   ; flags_rdy                = (OS_FLAGS)0;
000023CA  4242      6282          clr.w     D2
                    6283   ; switch (pend_stat) {
000023CC  102E FFFF 6284          move.b    -1(A6),D0
000023D0  C0BC 0000 6285          and.l     #255,D0
000023D4  00FF      
000023D6  0C80 0000 6286          cmp.l     #2,D0
000023DA  0002      
000023DC  670C      6287          beq.s     OSFlagPend_38
000023DE  6212      6288          bhi.s     OSFlagPend_39
000023E0  0C80 0000 6289          cmp.l     #1,D0
000023E4  0001      
000023E6  670A      6290          beq.s     OSFlagPend_39
000023E8  6008      6291          bra.s     OSFlagPend_39
                    6292   OSFlagPend_38:
                    6293   ; case OS_STAT_PEND_ABORT:
                    6294   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
000023EA  2044      6295          move.l    D4,A0
000023EC  10BC 000E 6296          move.b    #14,(A0)
                    6297   ; break;
000023F0  6006      6298          bra.s     OSFlagPend_37
                    6299   OSFlagPend_39:
                    6300   ; case OS_STAT_PEND_TO:
                    6301   ; default:
                    6302   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
000023F2  2044      6303          move.l    D4,A0
000023F4  10BC 000A 6304          move.b    #10,(A0)
                    6305   ; break;
                    6306   OSFlagPend_37:
                    6307   ; }
                    6308   ; return (flags_rdy);
000023F8  3002      6309          move.w    D2,D0
000023FA  6000 005A 6310          bra       OSFlagPend_3
                    6311   OSFlagPend_34:
                    6312   ; }
                    6313   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
000023FE  2052      6314          move.l    (A2),A0
00002400  3428 002C 6315          move.w    44(A0),D2
                    6316   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
00002404  0C07 0001 6317          cmp.b     #1,D7
00002408  6600 0044 6318          bne       OSFlagPend_44
                    6319   ; switch (wait_type) {
0000240C  CCBC 0000 6320          and.l     #255,D6
00002410  00FF      
00002412  2006      6321          move.l    D6,D0
00002414  0C80 0000 6322          cmp.l     #4,D0
00002418  0004      
0000241A  6426      6323          bhs.s     OSFlagPend_43
0000241C  E380      6324          asl.l     #1,D0
0000241E  303B 0806 6325          move.w    OSFlagPend_45(PC,D0.L),D0
00002422  4EFB 0002 6326          jmp       OSFlagPend_45(PC,D0.W)
                    6327   OSFlagPend_45:
00002426  0014      6328          dc.w      OSFlagPend_48-OSFlagPend_45
00002428  0014      6329          dc.w      OSFlagPend_48-OSFlagPend_45
0000242A  0008      6330          dc.w      OSFlagPend_46-OSFlagPend_45
0000242C  0008      6331          dc.w      OSFlagPend_46-OSFlagPend_45
                    6332   OSFlagPend_46:
                    6333   ; case OS_FLAG_WAIT_SET_ALL:
                    6334   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    6335   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
0000242E  2043      6336          move.l    D3,A0
00002430  3002      6337          move.w    D2,D0
00002432  4640      6338          not.w     D0
00002434  C168 0006 6339          and.w     D0,6(A0)
                    6340   ; break;
00002438  6014      6341          bra.s     OSFlagPend_44
                    6342   OSFlagPend_48:
                    6343   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6344   ; case OS_FLAG_WAIT_CLR_ALL:
                    6345   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    6346   ; pgrp->OSFlagFlags |=  flags_rdy;
0000243A  2043      6347          move.l    D3,A0
0000243C  8568 0006 6348          or.w      D2,6(A0)
                    6349   ; break;
00002440  600C      6350          bra.s     OSFlagPend_44
                    6351   OSFlagPend_43:
                    6352   ; #endif
                    6353   ; default:
                    6354   ; OS_EXIT_CRITICAL();
00002442  46DF      6355          dc.w      18143
                    6356   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00002444  2044      6357          move.l    D4,A0
00002446  10BC 006F 6358          move.b    #111,(A0)
                    6359   ; return ((OS_FLAGS)0);
0000244A  4240      6360          clr.w     D0
0000244C  6008      6361          bra.s     OSFlagPend_3
                    6362   OSFlagPend_44:
                    6363   ; }
                    6364   ; }
                    6365   ; OS_EXIT_CRITICAL();
0000244E  46DF      6366          dc.w      18143
                    6367   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
00002450  2044      6368          move.l    D4,A0
00002452  4210      6369          clr.b     (A0)
                    6370   ; return (flags_rdy);
00002454  3002      6371          move.w    D2,D0
                    6372   OSFlagPend_3:
00002456  4CDF 3CFC 6373          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000245A  4E5E      6374          unlk      A6
0000245C  4E75      6375          rts
                    6376   ; }
                    6377   ; /*$PAGE*/
                    6378   ; /*
                    6379   ; *********************************************************************************************************
                    6380   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    6381   ; *
                    6382   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    6383   ; *              In other words, this function allows you to tell "Who done it!".
                    6384   ; *
                    6385   ; * Arguments  : None
                    6386   ; *
                    6387   ; * Returns    : The flags that caused the task to be ready.
                    6388   ; *
                    6389   ; * Called from: Task ONLY
                    6390   ; *********************************************************************************************************
                    6391   ; */
                    6392   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    6393   ; {
                    6394   _OSFlagPendGetFlagsRdy:
0000245E  4E56 FFFC 6395          link      A6,#-4
                    6396   ; OS_FLAGS      flags;
                    6397   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6398   ; OS_CPU_SR     cpu_sr = 0u;
                    6399   ; #endif
                    6400   ; OS_ENTER_CRITICAL();
00002462  40E7      6401          dc.w      16615
00002464  007C      6402          dc.w      124
00002466  0700      6403          dc.w      1792
                    6404   ; flags = OSTCBCur->OSTCBFlagsRdy;
00002468  2079 0800 6405          move.l    _OSTCBCur.L,A0
0000246C  1020      
0000246E  3D68 002C 6406          move.w    44(A0),-2(A6)
00002472  FFFE      
                    6407   ; OS_EXIT_CRITICAL();
00002474  46DF      6408          dc.w      18143
                    6409   ; return (flags);
00002476  302E FFFE 6410          move.w    -2(A6),D0
0000247A  4E5E      6411          unlk      A6
0000247C  4E75      6412          rts
                    6413   ; }
                    6414   ; /*$PAGE*/
                    6415   ; /*
                    6416   ; *********************************************************************************************************
                    6417   ; *                                       POST EVENT FLAG BIT(S)
                    6418   ; *
                    6419   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    6420   ; *              set or clear are specified by a 'bit mask'.
                    6421   ; *
                    6422   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6423   ; *
                    6424   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    6425   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    6426   ; *                            and 5 you would set 'flags' to:
                    6427   ; *
                    6428   ; *                                0x31     (note, bit 0 is least significant bit)
                    6429   ; *
                    6430   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    6431   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    6432   ; *                            4 and 5 you would specify 'flags' as:
                    6433   ; *
                    6434   ; *                                0x31     (note, bit 0 is least significant bit)
                    6435   ; *
                    6436   ; *              opt           indicates whether the flags will be:
                    6437   ; *                                set     (OS_FLAG_SET) or
                    6438   ; *                                cleared (OS_FLAG_CLR)
                    6439   ; *
                    6440   ; *              perr          is a pointer to an error code and can be:
                    6441   ; *                            OS_ERR_NONE                The call was successfull
                    6442   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6443   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6444   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    6445   ; *
                    6446   ; * Returns    : the new value of the event flags bits that are still set.
                    6447   ; *
                    6448   ; * Called From: Task or ISR
                    6449   ; *
                    6450   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    6451   ; *                 flag group.
                    6452   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    6453   ; *                 the event flag group.
                    6454   ; *********************************************************************************************************
                    6455   ; */
                    6456   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    6457   ; OS_FLAGS      flags,
                    6458   ; INT8U         opt,
                    6459   ; INT8U        *perr)
                    6460   ; {
                    6461   _OSFlagPost:
0000247E  4E56 FFFC 6462          link      A6,#-4
00002482  48E7 3F20 6463          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002486  282E 0008 6464          move.l    8(A6),D4
0000248A  45F9 0000 6465          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
0000248E  27D6      
00002490  2E2E 0014 6466          move.l    20(A6),D7
                    6467   ; OS_FLAG_NODE *pnode;
                    6468   ; BOOLEAN       sched;
                    6469   ; OS_FLAGS      flags_cur;
                    6470   ; OS_FLAGS      flags_rdy;
                    6471   ; BOOLEAN       rdy;
                    6472   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    6473   ; OS_CPU_SR     cpu_sr = 0u;
                    6474   ; #endif
                    6475   ; #ifdef OS_SAFETY_CRITICAL
                    6476   ; if (perr == (INT8U *)0) {
                    6477   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6478   ; return ((OS_FLAGS)0);
                    6479   ; }
                    6480   ; #endif
                    6481   ; #if OS_ARG_CHK_EN > 0u
                    6482   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    6483   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6484   ; return ((OS_FLAGS)0);
                    6485   ; }
                    6486   ; #endif
                    6487   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00002494  2044      6488          move.l    D4,A0
00002496  1010      6489          move.b    (A0),D0
00002498  0C00 0005 6490          cmp.b     #5,D0
0000249C  670C      6491          beq.s     OSFlagPost_1
                    6492   ; *perr = OS_ERR_EVENT_TYPE;
0000249E  2047      6493          move.l    D7,A0
000024A0  10BC 0001 6494          move.b    #1,(A0)
                    6495   ; return ((OS_FLAGS)0);
000024A4  4240      6496          clr.w     D0
000024A6  6000 018C 6497          bra       OSFlagPost_3
                    6498   OSFlagPost_1:
                    6499   ; }
                    6500   ; /*$PAGE*/
                    6501   ; OS_ENTER_CRITICAL();
000024AA  40E7      6502          dc.w      16615
000024AC  007C      6503          dc.w      124
000024AE  0700      6504          dc.w      1792
                    6505   ; switch (opt) {
000024B0  102E 0013 6506          move.b    19(A6),D0
000024B4  C0BC 0000 6507          and.l     #255,D0
000024B8  00FF      
000024BA  0C80 0000 6508          cmp.l     #1,D0
000024BE  0001      
000024C0  6716      6509          beq.s     OSFlagPost_7
000024C2  6220      6510          bhi.s     OSFlagPost_4
000024C4  4A80      6511          tst.l     D0
000024C6  6702      6512          beq.s     OSFlagPost_6
000024C8  601A      6513          bra.s     OSFlagPost_4
                    6514   OSFlagPost_6:
                    6515   ; case OS_FLAG_CLR:
                    6516   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
000024CA  2044      6517          move.l    D4,A0
000024CC  302E 000E 6518          move.w    14(A6),D0
000024D0  4640      6519          not.w     D0
000024D2  C168 0006 6520          and.w     D0,6(A0)
                    6521   ; break;
000024D6  601A      6522          bra.s     OSFlagPost_5
                    6523   OSFlagPost_7:
                    6524   ; case OS_FLAG_SET:
                    6525   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
000024D8  2044      6526          move.l    D4,A0
000024DA  302E 000E 6527          move.w    14(A6),D0
000024DE  8168 0006 6528          or.w      D0,6(A0)
                    6529   ; break;
000024E2  600E      6530          bra.s     OSFlagPost_5
                    6531   OSFlagPost_4:
                    6532   ; default:
                    6533   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
000024E4  46DF      6534          dc.w      18143
                    6535   ; *perr = OS_ERR_FLAG_INVALID_OPT;
000024E6  2047      6536          move.l    D7,A0
000024E8  10BC 0071 6537          move.b    #113,(A0)
                    6538   ; return ((OS_FLAGS)0);
000024EC  4240      6539          clr.w     D0
000024EE  6000 0144 6540          bra       OSFlagPost_3
                    6541   OSFlagPost_5:
                    6542   ; }
                    6543   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
000024F2  4206      6544          clr.b     D6
                    6545   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000024F4  2044      6546          move.l    D4,A0
000024F6  2428 0002 6547          move.l    2(A0),D2
                    6548   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    6549   OSFlagPost_9:
000024FA  4A82      6550          tst.l     D2
000024FC  6700 0112 6551          beq       OSFlagPost_11
                    6552   ; switch (pnode->OSFlagNodeWaitType) {
00002500  2042      6553          move.l    D2,A0
00002502  1028 0012 6554          move.b    18(A0),D0
00002506  C0BC 0000 6555          and.l     #255,D0
0000250A  00FF      
0000250C  0C80 0000 6556          cmp.l     #4,D0
00002510  0004      
00002512  6400 00E6 6557          bhs       OSFlagPost_12
00002516  E380      6558          asl.l     #1,D0
00002518  303B 0806 6559          move.w    OSFlagPost_14(PC,D0.L),D0
0000251C  4EFB 0002 6560          jmp       OSFlagPost_14(PC,D0.W)
                    6561   OSFlagPost_14:
00002520  0070      6562          dc.w      OSFlagPost_17-OSFlagPost_14
00002522  00A8      6563          dc.w      OSFlagPost_18-OSFlagPost_14
00002524  0008      6564          dc.w      OSFlagPost_15-OSFlagPost_14
00002526  003E      6565          dc.w      OSFlagPost_16-OSFlagPost_14
                    6566   OSFlagPost_15:
                    6567   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    6568   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00002528  2044      6569          move.l    D4,A0
0000252A  3028 0006 6570          move.w    6(A0),D0
0000252E  2042      6571          move.l    D2,A0
00002530  C068 0010 6572          and.w     16(A0),D0
00002534  3600      6573          move.w    D0,D3
                    6574   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00002536  2042      6575          move.l    D2,A0
00002538  B668 0010 6576          cmp.w     16(A0),D3
0000253C  661C      6577          bne.s     OSFlagPost_22
                    6578   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
0000253E  42A7      6579          clr.l     -(A7)
00002540  C6BC 0000 6580          and.l     #65535,D3
00002544  FFFF      
00002546  2F03      6581          move.l    D3,-(A7)
00002548  2F02      6582          move.l    D2,-(A7)
0000254A  4E92      6583          jsr       (A2)
0000254C  DEFC 000C 6584          add.w     #12,A7
00002550  1A00      6585          move.b    D0,D5
                    6586   ; if (rdy == OS_TRUE) {
00002552  0C05 0001 6587          cmp.b     #1,D5
00002556  6602      6588          bne.s     OSFlagPost_22
                    6589   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002558  7C01      6590          moveq     #1,D6
                    6591   OSFlagPost_22:
                    6592   ; }
                    6593   ; }
                    6594   ; break;
0000255A  6000 00AC 6595          bra       OSFlagPost_13
                    6596   OSFlagPost_16:
                    6597   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    6598   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
0000255E  2044      6599          move.l    D4,A0
00002560  3028 0006 6600          move.w    6(A0),D0
00002564  2042      6601          move.l    D2,A0
00002566  C068 0010 6602          and.w     16(A0),D0
0000256A  3600      6603          move.w    D0,D3
                    6604   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
0000256C  4A43      6605          tst.w     D3
0000256E  671C      6606          beq.s     OSFlagPost_26
                    6607   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002570  42A7      6608          clr.l     -(A7)
00002572  C6BC 0000 6609          and.l     #65535,D3
00002576  FFFF      
00002578  2F03      6610          move.l    D3,-(A7)
0000257A  2F02      6611          move.l    D2,-(A7)
0000257C  4E92      6612          jsr       (A2)
0000257E  DEFC 000C 6613          add.w     #12,A7
00002582  1A00      6614          move.b    D0,D5
                    6615   ; if (rdy == OS_TRUE) {
00002584  0C05 0001 6616          cmp.b     #1,D5
00002588  6602      6617          bne.s     OSFlagPost_26
                    6618   ; sched = OS_TRUE;                     /* When done we will reschedule          */
0000258A  7C01      6619          moveq     #1,D6
                    6620   OSFlagPost_26:
                    6621   ; }
                    6622   ; }
                    6623   ; break;
0000258C  6000 007A 6624          bra       OSFlagPost_13
                    6625   OSFlagPost_17:
                    6626   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6627   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    6628   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00002590  2044      6629          move.l    D4,A0
00002592  3028 0006 6630          move.w    6(A0),D0
00002596  4640      6631          not.w     D0
00002598  2042      6632          move.l    D2,A0
0000259A  C068 0010 6633          and.w     16(A0),D0
0000259E  3600      6634          move.w    D0,D3
                    6635   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
000025A0  2042      6636          move.l    D2,A0
000025A2  B668 0010 6637          cmp.w     16(A0),D3
000025A6  661C      6638          bne.s     OSFlagPost_30
                    6639   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000025A8  42A7      6640          clr.l     -(A7)
000025AA  C6BC 0000 6641          and.l     #65535,D3
000025AE  FFFF      
000025B0  2F03      6642          move.l    D3,-(A7)
000025B2  2F02      6643          move.l    D2,-(A7)
000025B4  4E92      6644          jsr       (A2)
000025B6  DEFC 000C 6645          add.w     #12,A7
000025BA  1A00      6646          move.b    D0,D5
                    6647   ; if (rdy == OS_TRUE) {
000025BC  0C05 0001 6648          cmp.b     #1,D5
000025C0  6602      6649          bne.s     OSFlagPost_30
                    6650   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000025C2  7C01      6651          moveq     #1,D6
                    6652   OSFlagPost_30:
                    6653   ; }
                    6654   ; }
                    6655   ; break;
000025C4  6000 0042 6656          bra       OSFlagPost_13
                    6657   OSFlagPost_18:
                    6658   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    6659   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
000025C8  2044      6660          move.l    D4,A0
000025CA  3028 0006 6661          move.w    6(A0),D0
000025CE  4640      6662          not.w     D0
000025D0  2042      6663          move.l    D2,A0
000025D2  C068 0010 6664          and.w     16(A0),D0
000025D6  3600      6665          move.w    D0,D3
                    6666   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
000025D8  4A43      6667          tst.w     D3
000025DA  671C      6668          beq.s     OSFlagPost_34
                    6669   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000025DC  42A7      6670          clr.l     -(A7)
000025DE  C6BC 0000 6671          and.l     #65535,D3
000025E2  FFFF      
000025E4  2F03      6672          move.l    D3,-(A7)
000025E6  2F02      6673          move.l    D2,-(A7)
000025E8  4E92      6674          jsr       (A2)
000025EA  DEFC 000C 6675          add.w     #12,A7
000025EE  1A00      6676          move.b    D0,D5
                    6677   ; if (rdy == OS_TRUE) {
000025F0  0C05 0001 6678          cmp.b     #1,D5
000025F4  6602      6679          bne.s     OSFlagPost_34
                    6680   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000025F6  7C01      6681          moveq     #1,D6
                    6682   OSFlagPost_34:
                    6683   ; }
                    6684   ; }
                    6685   ; break;
000025F8  600E      6686          bra.s     OSFlagPost_13
                    6687   OSFlagPost_12:
                    6688   ; #endif
                    6689   ; default:
                    6690   ; OS_EXIT_CRITICAL();
000025FA  46DF      6691          dc.w      18143
                    6692   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
000025FC  2047      6693          move.l    D7,A0
000025FE  10BC 006F 6694          move.b    #111,(A0)
                    6695   ; return ((OS_FLAGS)0);
00002602  4240      6696          clr.w     D0
00002604  6000 002E 6697          bra       OSFlagPost_3
                    6698   OSFlagPost_13:
                    6699   ; }
                    6700   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
00002608  2042      6701          move.l    D2,A0
0000260A  2410      6702          move.l    (A0),D2
0000260C  6000 FEEC 6703          bra       OSFlagPost_9
                    6704   OSFlagPost_11:
                    6705   ; }
                    6706   ; OS_EXIT_CRITICAL();
00002610  46DF      6707          dc.w      18143
                    6708   ; if (sched == OS_TRUE) {
00002612  0C06 0001 6709          cmp.b     #1,D6
00002616  6604      6710          bne.s     OSFlagPost_36
                    6711   ; OS_Sched();
00002618  4EB8 1A22 6712          jsr       _OS_Sched
                    6713   OSFlagPost_36:
                    6714   ; }
                    6715   ; OS_ENTER_CRITICAL();
0000261C  40E7      6716          dc.w      16615
0000261E  007C      6717          dc.w      124
00002620  0700      6718          dc.w      1792
                    6719   ; flags_cur = pgrp->OSFlagFlags;
00002622  2044      6720          move.l    D4,A0
00002624  3D68 0006 6721          move.w    6(A0),-2(A6)
00002628  FFFE      
                    6722   ; OS_EXIT_CRITICAL();
0000262A  46DF      6723          dc.w      18143
                    6724   ; *perr     = OS_ERR_NONE;
0000262C  2047      6725          move.l    D7,A0
0000262E  4210      6726          clr.b     (A0)
                    6727   ; return (flags_cur);
00002630  302E FFFE 6728          move.w    -2(A6),D0
                    6729   OSFlagPost_3:
00002634  4CDF 04FC 6730          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002638  4E5E      6731          unlk      A6
0000263A  4E75      6732          rts
                    6733   ; }
                    6734   ; /*$PAGE*/
                    6735   ; /*
                    6736   ; *********************************************************************************************************
                    6737   ; *                                          QUERY EVENT FLAG
                    6738   ; *
                    6739   ; * Description: This function is used to check the value of the event flag group.
                    6740   ; *
                    6741   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6742   ; *
                    6743   ; *              perr          is a pointer to an error code returned to the called:
                    6744   ; *                            OS_ERR_NONE                The call was successfull
                    6745   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6746   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6747   ; *
                    6748   ; * Returns    : The current value of the event flag group.
                    6749   ; *
                    6750   ; * Called From: Task or ISR
                    6751   ; *********************************************************************************************************
                    6752   ; */
                    6753   ; #if OS_FLAG_QUERY_EN > 0u
                    6754   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6755   ; INT8U        *perr)
                    6756   ; {
                    6757   _OSFlagQuery:
0000263C  4E56 FFFC 6758          link      A6,#-4
                    6759   ; OS_FLAGS   flags;
                    6760   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6761   ; OS_CPU_SR  cpu_sr = 0u;
                    6762   ; #endif
                    6763   ; #ifdef OS_SAFETY_CRITICAL
                    6764   ; if (perr == (INT8U *)0) {
                    6765   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6766   ; return ((OS_FLAGS)0);
                    6767   ; }
                    6768   ; #endif
                    6769   ; #if OS_ARG_CHK_EN > 0u
                    6770   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6771   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6772   ; return ((OS_FLAGS)0);
                    6773   ; }
                    6774   ; #endif
                    6775   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00002640  206E 0008 6776          move.l    8(A6),A0
00002644  1010      6777          move.b    (A0),D0
00002646  0C00 0005 6778          cmp.b     #5,D0
0000264A  670C      6779          beq.s     OSFlagQuery_1
                    6780   ; *perr = OS_ERR_EVENT_TYPE;
0000264C  206E 000C 6781          move.l    12(A6),A0
00002650  10BC 0001 6782          move.b    #1,(A0)
                    6783   ; return ((OS_FLAGS)0);
00002654  4240      6784          clr.w     D0
00002656  601C      6785          bra.s     OSFlagQuery_3
                    6786   OSFlagQuery_1:
                    6787   ; }
                    6788   ; OS_ENTER_CRITICAL();
00002658  40E7      6789          dc.w      16615
0000265A  007C      6790          dc.w      124
0000265C  0700      6791          dc.w      1792
                    6792   ; flags = pgrp->OSFlagFlags;
0000265E  206E 0008 6793          move.l    8(A6),A0
00002662  3D68 0006 6794          move.w    6(A0),-2(A6)
00002666  FFFE      
                    6795   ; OS_EXIT_CRITICAL();
00002668  46DF      6796          dc.w      18143
                    6797   ; *perr = OS_ERR_NONE;
0000266A  206E 000C 6798          move.l    12(A6),A0
0000266E  4210      6799          clr.b     (A0)
                    6800   ; return (flags);                               /* Return the current value of the event flags       */
00002670  302E FFFE 6801          move.w    -2(A6),D0
                    6802   OSFlagQuery_3:
00002674  4E5E      6803          unlk      A6
00002676  4E75      6804          rts
                    6805   ; }
                    6806   ; #endif
                    6807   ; /*$PAGE*/
                    6808   ; /*
                    6809   ; *********************************************************************************************************
                    6810   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6811   ; *
                    6812   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6813   ; *              event flag bit(s) are set.
                    6814   ; *
                    6815   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6816   ; *
                    6817   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6818   ; *                            event flag bit(s) to be set.
                    6819   ; *
                    6820   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6821   ; *                            The bits you want are specified by setting the corresponding bits in
                    6822   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6823   ; *                            'flags' would contain 0x03.
                    6824   ; *
                    6825   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6826   ; *                            to be set/cleared.
                    6827   ; *                            You can specify the following argument:
                    6828   ; *
                    6829   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6830   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6831   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6832   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6833   ; *
                    6834   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6835   ; *                            bit(s) to be set.
                    6836   ; *
                    6837   ; * Returns    : none
                    6838   ; *
                    6839   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6840   ; *
                    6841   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6842   ; *********************************************************************************************************
                    6843   ; */
                    6844   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6845   ; OS_FLAG_NODE *pnode,
                    6846   ; OS_FLAGS      flags,
                    6847   ; INT8U         wait_type,
                    6848   ; INT32U        timeout)
                    6849   ; {
                    6850   @ucos_ii_OS_FlagBlock:
00002678  4E56 0000 6851          link      A6,#0
0000267C  48E7 3C20 6852          movem.l   D2/D3/D4/D5/A2,-(A7)
00002680  242E 000C 6853          move.l    12(A6),D2
00002684  45F9 0800 6854          lea       _OSTCBCur.L,A2
00002688  1020      
0000268A  262E 0008 6855          move.l    8(A6),D3
                    6856   ; OS_FLAG_NODE  *pnode_next;
                    6857   ; INT8U          y;
                    6858   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
0000268E  2052      6859          move.l    (A2),A0
00002690  0028 0020 6860          or.b      #32,50(A0)
00002694  0032      
                    6861   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00002696  2052      6862          move.l    (A2),A0
00002698  4228 0033 6863          clr.b     51(A0)
                    6864   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
0000269C  2052      6865          move.l    (A2),A0
0000269E  216E 0018 6866          move.l    24(A6),46(A0)
000026A2  002E      
                    6867   ; #if OS_TASK_DEL_EN > 0u
                    6868   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000026A4  2052      6869          move.l    (A2),A0
000026A6  2142 0028 6870          move.l    D2,40(A0)
                    6871   ; #endif
                    6872   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000026AA  2042      6873          move.l    D2,A0
000026AC  316E 0012 6874          move.w    18(A6),16(A0)
000026B0  0010      
                    6875   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
000026B2  2042      6876          move.l    D2,A0
000026B4  116E 0017 6877          move.b    23(A6),18(A0)
000026B8  0012      
                    6878   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
000026BA  2042      6879          move.l    D2,A0
000026BC  2152 0008 6880          move.l    (A2),8(A0)
                    6881   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000026C0  2043      6882          move.l    D3,A0
000026C2  2242      6883          move.l    D2,A1
000026C4  22A8 0002 6884          move.l    2(A0),(A1)
                    6885   ; pnode->OSFlagNodePrev     = (void *)0;
000026C8  2042      6886          move.l    D2,A0
000026CA  42A8 0004 6887          clr.l     4(A0)
                    6888   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000026CE  2042      6889          move.l    D2,A0
000026D0  2143 000C 6890          move.l    D3,12(A0)
                    6891   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000026D4  2043      6892          move.l    D3,A0
000026D6  2A28 0002 6893          move.l    2(A0),D5
                    6894   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000026DA  4A85      6895          tst.l     D5
000026DC  6706      6896          beq.s     @ucos_ii_OS_FlagBlock_1
                    6897   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000026DE  2045      6898          move.l    D5,A0
000026E0  2142 0004 6899          move.l    D2,4(A0)
                    6900   @ucos_ii_OS_FlagBlock_1:
                    6901   ; }
                    6902   ; pgrp->OSFlagWaitList = (void *)pnode;
000026E4  2043      6903          move.l    D3,A0
000026E6  2142 0002 6904          move.l    D2,2(A0)
                    6905   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000026EA  2052      6906          move.l    (A2),A0
000026EC  1828 0036 6907          move.b    54(A0),D4
                    6908   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000026F0  C8BC 0000 6909          and.l     #255,D4
000026F4  00FF      
000026F6  41F9 0800 6910          lea       _OSRdyTbl.L,A0
000026FA  0F10      
000026FC  2252      6911          move.l    (A2),A1
000026FE  1029 0037 6912          move.b    55(A1),D0
00002702  4600      6913          not.b     D0
00002704  C130 4800 6914          and.b     D0,0(A0,D4.L)
                    6915   ; if (OSRdyTbl[y] == 0x00u) {
00002708  C8BC 0000 6916          and.l     #255,D4
0000270C  00FF      
0000270E  41F9 0800 6917          lea       _OSRdyTbl.L,A0
00002712  0F10      
00002714  1030 4800 6918          move.b    0(A0,D4.L),D0
00002718  660E      6919          bne.s     @ucos_ii_OS_FlagBlock_3
                    6920   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000271A  2052      6921          move.l    (A2),A0
0000271C  1028 0038 6922          move.b    56(A0),D0
00002720  4600      6923          not.b     D0
00002722  C139 0800 6924          and.b     D0,_OSRdyGrp.L
00002726  0F0E      
                    6925   @ucos_ii_OS_FlagBlock_3:
00002728  4CDF 043C 6926          movem.l   (A7)+,D2/D3/D4/D5/A2
0000272C  4E5E      6927          unlk      A6
0000272E  4E75      6928          rts
                    6929   ; }
                    6930   ; }
                    6931   ; /*$PAGE*/
                    6932   ; /*
                    6933   ; *********************************************************************************************************
                    6934   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6935   ; *
                    6936   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6937   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6938   ; *
                    6939   ; * Arguments  : none
                    6940   ; *
                    6941   ; * Returns    : none
                    6942   ; *
                    6943   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6944   ; *********************************************************************************************************
                    6945   ; */
                    6946   ; void  OS_FlagInit (void)
                    6947   ; {
                    6948   _OS_FlagInit:
00002730  4E56 FFF8 6949          link      A6,#-8
00002734  48E7 3020 6950          movem.l   D2/D3/A2,-(A7)
00002738  45F9 0800 6951          lea       _OSFlagTbl.L,A2
0000273C  0DBA      
                    6952   ; #if OS_MAX_FLAGS == 1u
                    6953   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6954   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6955   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6956   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6957   ; #if OS_FLAG_NAME_EN > 0u
                    6958   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6959   ; #endif
                    6960   ; #endif
                    6961   ; #if OS_MAX_FLAGS >= 2u
                    6962   ; INT16U        ix;
                    6963   ; INT16U        ix_next;
                    6964   ; OS_FLAG_GRP  *pgrp1;
                    6965   ; OS_FLAG_GRP  *pgrp2;
                    6966   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
0000273E  4878 003C 6967          pea       60
00002742  2F0A      6968          move.l    A2,-(A7)
00002744  4EB8 19D6 6969          jsr       _OS_MemClr
00002748  504F      6970          addq.w    #8,A7
                    6971   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
0000274A  4243      6972          clr.w     D3
                    6973   OS_FlagInit_1:
0000274C  0C43 0004 6974          cmp.w     #4,D3
00002750  6400 004E 6975          bhs       OS_FlagInit_3
                    6976   ; ix_next = ix + 1u;
00002754  3003      6977          move.w    D3,D0
00002756  5240      6978          addq.w    #1,D0
00002758  3D40 FFFA 6979          move.w    D0,-6(A6)
                    6980   ; pgrp1 = &OSFlagTbl[ix];
0000275C  200A      6981          move.l    A2,D0
0000275E  C6BC 0000 6982          and.l     #65535,D3
00002762  FFFF      
00002764  2203      6983          move.l    D3,D1
00002766  C3FC 000C 6984          muls      #12,D1
0000276A  D081      6985          add.l     D1,D0
0000276C  2400      6986          move.l    D0,D2
                    6987   ; pgrp2 = &OSFlagTbl[ix_next];
0000276E  200A      6988          move.l    A2,D0
00002770  322E FFFA 6989          move.w    -6(A6),D1
00002774  C2BC 0000 6990          and.l     #65535,D1
00002778  FFFF      
0000277A  C3FC 000C 6991          muls      #12,D1
0000277E  D081      6992          add.l     D1,D0
00002780  2D40 FFFC 6993          move.l    D0,-4(A6)
                    6994   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002784  2042      6995          move.l    D2,A0
00002786  4210      6996          clr.b     (A0)
                    6997   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
00002788  2042      6998          move.l    D2,A0
0000278A  216E FFFC 6999          move.l    -4(A6),2(A0)
0000278E  0002      
                    7000   ; #if OS_FLAG_NAME_EN > 0u
                    7001   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
00002790  41F9 0000 7002          lea       @ucos_ii_1.L,A0
00002794  6AD0      
00002796  2242      7003          move.l    D2,A1
00002798  2348 0008 7004          move.l    A0,8(A1)
0000279C  5243      7005          addq.w    #1,D3
0000279E  60AC      7006          bra       OS_FlagInit_1
                    7007   OS_FlagInit_3:
                    7008   ; #endif
                    7009   ; }
                    7010   ; pgrp1                 = &OSFlagTbl[ix];
000027A0  200A      7011          move.l    A2,D0
000027A2  C6BC 0000 7012          and.l     #65535,D3
000027A6  FFFF      
000027A8  2203      7013          move.l    D3,D1
000027AA  C3FC 000C 7014          muls      #12,D1
000027AE  D081      7015          add.l     D1,D0
000027B0  2400      7016          move.l    D0,D2
                    7017   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000027B2  2042      7018          move.l    D2,A0
000027B4  4210      7019          clr.b     (A0)
                    7020   ; pgrp1->OSFlagWaitList = (void *)0;
000027B6  2042      7021          move.l    D2,A0
000027B8  42A8 0002 7022          clr.l     2(A0)
                    7023   ; #if OS_FLAG_NAME_EN > 0u
                    7024   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
000027BC  41F9 0000 7025          lea       @ucos_ii_1.L,A0
000027C0  6AD0      
000027C2  2242      7026          move.l    D2,A1
000027C4  2348 0008 7027          move.l    A0,8(A1)
                    7028   ; #endif
                    7029   ; OSFlagFreeList        = &OSFlagTbl[0];
000027C8  23CA 0800 7030          move.l    A2,_OSFlagFreeList.L
000027CC  0DF6      
000027CE  4CDF 040C 7031          movem.l   (A7)+,D2/D3/A2
000027D2  4E5E      7032          unlk      A6
000027D4  4E75      7033          rts
                    7034   ; #endif
                    7035   ; }
                    7036   ; /*$PAGE*/
                    7037   ; /*
                    7038   ; *********************************************************************************************************
                    7039   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    7040   ; *
                    7041   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    7042   ; *              desired event flag bits have been set.
                    7043   ; *
                    7044   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    7045   ; *                            event flag bit(s) to be set.
                    7046   ; *
                    7047   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    7048   ; *                            ready-to-run.
                    7049   ; *
                    7050   ; *              pend_stat   is used to indicate the readied task's pending status:
                    7051   ; *
                    7052   ; *
                    7053   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    7054   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    7055   ; *
                    7056   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    7057   ; *
                    7058   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    7059   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    7060   ; *********************************************************************************************************
                    7061   ; */
                    7062   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    7063   ; OS_FLAGS      flags_rdy,
                    7064   ; INT8U         pend_stat)
                    7065   ; {
                    7066   @ucos_ii_OS_FlagTaskRdy:
000027D6  4E56 0000 7067          link      A6,#0
000027DA  48E7 3000 7068          movem.l   D2/D3,-(A7)
                    7069   ; OS_TCB   *ptcb;
                    7070   ; BOOLEAN   sched;
                    7071   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000027DE  206E 0008 7072          move.l    8(A6),A0
000027E2  2428 0008 7073          move.l    8(A0),D2
                    7074   ; ptcb->OSTCBDly       = 0u;
000027E6  2042      7075          move.l    D2,A0
000027E8  42A8 002E 7076          clr.l     46(A0)
                    7077   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
000027EC  2042      7078          move.l    D2,A0
000027EE  316E 000E 7079          move.w    14(A6),44(A0)
000027F2  002C      
                    7080   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000027F4  2042      7081          move.l    D2,A0
000027F6  7020      7082          moveq     #32,D0
000027F8  4600      7083          not.b     D0
000027FA  C128 0032 7084          and.b     D0,50(A0)
                    7085   ; ptcb->OSTCBStatPend  = pend_stat;
000027FE  2042      7086          move.l    D2,A0
00002800  116E 0013 7087          move.b    19(A6),51(A0)
00002804  0033      
                    7088   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
00002806  2042      7089          move.l    D2,A0
00002808  1028 0032 7090          move.b    50(A0),D0
0000280C  662C      7091          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    7092   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
0000280E  2042      7093          move.l    D2,A0
00002810  1028 0038 7094          move.b    56(A0),D0
00002814  8139 0800 7095          or.b      D0,_OSRdyGrp.L
00002818  0F0E      
                    7096   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000281A  2042      7097          move.l    D2,A0
0000281C  1028 0036 7098          move.b    54(A0),D0
00002820  C0BC 0000 7099          and.l     #255,D0
00002824  00FF      
00002826  41F9 0800 7100          lea       _OSRdyTbl.L,A0
0000282A  0F10      
0000282C  2242      7101          move.l    D2,A1
0000282E  1229 0037 7102          move.b    55(A1),D1
00002832  8330 0800 7103          or.b      D1,0(A0,D0.L)
                    7104   ; sched                   = OS_TRUE;
00002836  7601      7105          moveq     #1,D3
00002838  6002      7106          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    7107   @ucos_ii_OS_FlagTaskRdy_1:
                    7108   ; } else {
                    7109   ; sched                   = OS_FALSE;
0000283A  4203      7110          clr.b     D3
                    7111   @ucos_ii_OS_FlagTaskRdy_2:
                    7112   ; }
                    7113   ; OS_FlagUnlink(pnode);
0000283C  2F2E 0008 7114          move.l    8(A6),-(A7)
00002840  4EB9 0000 7115          jsr       _OS_FlagUnlink
00002844  2852      
00002846  584F      7116          addq.w    #4,A7
                    7117   ; return (sched);
00002848  1003      7118          move.b    D3,D0
0000284A  4CDF 000C 7119          movem.l   (A7)+,D2/D3
0000284E  4E5E      7120          unlk      A6
00002850  4E75      7121          rts
                    7122   ; }
                    7123   ; /*$PAGE*/
                    7124   ; /*
                    7125   ; *********************************************************************************************************
                    7126   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    7127   ; *
                    7128   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    7129   ; *              list of tasks waiting for the event flag.
                    7130   ; *
                    7131   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    7132   ; *                            event flag bit(s) to be set.
                    7133   ; *
                    7134   ; * Returns    : none
                    7135   ; *
                    7136   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    7137   ; *              OSFlagPend()     OS_FLAG.C
                    7138   ; *              OSTaskDel()      OS_TASK.C
                    7139   ; *
                    7140   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    7141   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    7142   ; *********************************************************************************************************
                    7143   ; */
                    7144   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    7145   ; {
                    7146   _OS_FlagUnlink:
00002852  4E56 FFF8 7147          link      A6,#-8
00002856  48E7 3800 7148          movem.l   D2/D3/D4,-(A7)
0000285A  262E 0008 7149          move.l    8(A6),D3
                    7150   ; #if OS_TASK_DEL_EN > 0u
                    7151   ; OS_TCB       *ptcb;
                    7152   ; #endif
                    7153   ; OS_FLAG_GRP  *pgrp;
                    7154   ; OS_FLAG_NODE *pnode_prev;
                    7155   ; OS_FLAG_NODE *pnode_next;
                    7156   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
0000285E  2043      7157          move.l    D3,A0
00002860  2828 0004 7158          move.l    4(A0),D4
                    7159   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00002864  2043      7160          move.l    D3,A0
00002866  2410      7161          move.l    (A0),D2
                    7162   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
00002868  4A84      7163          tst.l     D4
0000286A  661C      7164          bne.s     OS_FlagUnlink_1
                    7165   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
0000286C  2043      7166          move.l    D3,A0
0000286E  2D68 000C 7167          move.l    12(A0),-4(A6)
00002872  FFFC      
                    7168   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00002874  206E FFFC 7169          move.l    -4(A6),A0
00002878  2142 0002 7170          move.l    D2,2(A0)
                    7171   ; if (pnode_next != (OS_FLAG_NODE *)0) {
0000287C  4A82      7172          tst.l     D2
0000287E  6706      7173          beq.s     OS_FlagUnlink_3
                    7174   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00002880  2042      7175          move.l    D2,A0
00002882  42A8 0004 7176          clr.l     4(A0)
                    7177   OS_FlagUnlink_3:
00002886  600E      7178          bra.s     OS_FlagUnlink_5
                    7179   OS_FlagUnlink_1:
                    7180   ; }
                    7181   ; } else {                                                    /* No,  A node somewhere in the list   */
                    7182   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
00002888  2044      7183          move.l    D4,A0
0000288A  2082      7184          move.l    D2,(A0)
                    7185   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
0000288C  4A82      7186          tst.l     D2
0000288E  6706      7187          beq.s     OS_FlagUnlink_5
                    7188   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00002890  2042      7189          move.l    D2,A0
00002892  2144 0004 7190          move.l    D4,4(A0)
                    7191   OS_FlagUnlink_5:
                    7192   ; }
                    7193   ; }
                    7194   ; #if OS_TASK_DEL_EN > 0u
                    7195   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00002896  2043      7196          move.l    D3,A0
00002898  2D68 0008 7197          move.l    8(A0),-8(A6)
0000289C  FFF8      
                    7198   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
0000289E  206E FFF8 7199          move.l    -8(A6),A0
000028A2  42A8 0028 7200          clr.l     40(A0)
000028A6  4CDF 001C 7201          movem.l   (A7)+,D2/D3/D4
000028AA  4E5E      7202          unlk      A6
000028AC  4E75      7203          rts
                    7204   ; /*
                    7205   ; *********************************************************************************************************
                    7206   ; *                                                uC/OS-II
                    7207   ; *                                          The Real-Time Kernel
                    7208   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    7209   ; *
                    7210   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7211   ; *                                           All Rights Reserved
                    7212   ; *
                    7213   ; * File    : OS_MBOX.C
                    7214   ; * By      : Jean J. Labrosse
                    7215   ; * Version : V2.92.07
                    7216   ; *
                    7217   ; * LICENSING TERMS:
                    7218   ; * ---------------
                    7219   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7220   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7221   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7222   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7223   ; * licensing fee.
                    7224   ; *********************************************************************************************************
                    7225   ; */
                    7226   ; #define  MICRIUM_SOURCE
                    7227   ; #ifndef  OS_MASTER_FILE
                    7228   ; #include <ucos_ii.h>
                    7229   ; #endif
                    7230   ; #if OS_MBOX_EN > 0u
                    7231   ; /*
                    7232   ; *********************************************************************************************************
                    7233   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    7234   ; *
                    7235   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    7236   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    7237   ; *
                    7238   ; * Arguments  : pevent        is a pointer to the event control block
                    7239   ; *
                    7240   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    7241   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    7242   ; *              == (void *)0  if the mailbox is empty or,
                    7243   ; *                            if 'pevent' is a NULL pointer or,
                    7244   ; *                            if you didn't pass the proper event pointer.
                    7245   ; *********************************************************************************************************
                    7246   ; */
                    7247   ; #if OS_MBOX_ACCEPT_EN > 0u
                    7248   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    7249   ; {
                    7250   _OSMboxAccept:
000028AE  4E56 FFFC 7251          link      A6,#-4
000028B2  2F02      7252          move.l    D2,-(A7)
000028B4  242E 0008 7253          move.l    8(A6),D2
                    7254   ; void      *pmsg;
                    7255   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    7256   ; OS_CPU_SR  cpu_sr = 0u;
                    7257   ; #endif
                    7258   ; #if OS_ARG_CHK_EN > 0u
                    7259   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    7260   ; return ((void *)0);
                    7261   ; }
                    7262   ; #endif
                    7263   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000028B8  2042      7264          move.l    D2,A0
000028BA  1010      7265          move.b    (A0),D0
000028BC  0C00 0001 7266          cmp.b     #1,D0
000028C0  6704      7267          beq.s     OSMboxAccept_1
                    7268   ; return ((void *)0);
000028C2  4280      7269          clr.l     D0
000028C4  601A      7270          bra.s     OSMboxAccept_3
                    7271   OSMboxAccept_1:
                    7272   ; }
                    7273   ; OS_ENTER_CRITICAL();
000028C6  40E7      7274          dc.w      16615
000028C8  007C      7275          dc.w      124
000028CA  0700      7276          dc.w      1792
                    7277   ; pmsg               = pevent->OSEventPtr;
000028CC  2042      7278          move.l    D2,A0
000028CE  2D68 0002 7279          move.l    2(A0),-4(A6)
000028D2  FFFC      
                    7280   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
000028D4  2042      7281          move.l    D2,A0
000028D6  42A8 0002 7282          clr.l     2(A0)
                    7283   ; OS_EXIT_CRITICAL();
000028DA  46DF      7284          dc.w      18143
                    7285   ; return (pmsg);                                        /* Return the message received (or NULL)     */
000028DC  202E FFFC 7286          move.l    -4(A6),D0
                    7287   OSMboxAccept_3:
000028E0  241F      7288          move.l    (A7)+,D2
000028E2  4E5E      7289          unlk      A6
000028E4  4E75      7290          rts
                    7291   ; }
                    7292   ; #endif
                    7293   ; /*$PAGE*/
                    7294   ; /*
                    7295   ; *********************************************************************************************************
                    7296   ; *                                          CREATE A MESSAGE MAILBOX
                    7297   ; *
                    7298   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    7299   ; *
                    7300   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    7301   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    7302   ; *                            will be considered empty.
                    7303   ; *
                    7304   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    7305   ; *                                created mailbox
                    7306   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    7307   ; *********************************************************************************************************
                    7308   ; */
                    7309   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    7310   ; {
                    7311   _OSMboxCreate:
000028E6  4E56 0000 7312          link      A6,#0
000028EA  48E7 2020 7313          movem.l   D2/A2,-(A7)
000028EE  45F9 0800 7314          lea       _OSEventFreeList.L,A2
000028F2  0CDA      
                    7315   ; OS_EVENT  *pevent;
                    7316   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    7317   ; OS_CPU_SR  cpu_sr = 0u;
                    7318   ; #endif
                    7319   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7320   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7321   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7322   ; return ((OS_EVENT *)0);
                    7323   ; }
                    7324   ; #endif
                    7325   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000028F4  1039 0800 7326          move.b    _OSIntNesting.L,D0
000028F8  0F06      
000028FA  0C00 0000 7327          cmp.b     #0,D0
000028FE  6306      7328          bls.s     OSMboxCreate_1
                    7329   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00002900  4280      7330          clr.l     D0
00002902  6000 0044 7331          bra       OSMboxCreate_3
                    7332   OSMboxCreate_1:
                    7333   ; }
                    7334   ; OS_ENTER_CRITICAL();
00002906  40E7      7335          dc.w      16615
00002908  007C      7336          dc.w      124
0000290A  0700      7337          dc.w      1792
                    7338   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
0000290C  2412      7339          move.l    (A2),D2
                    7340   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
0000290E  2012      7341          move.l    (A2),D0
00002910  6706      7342          beq.s     OSMboxCreate_4
                    7343   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00002912  2052      7344          move.l    (A2),A0
00002914  24A8 0002 7345          move.l    2(A0),(A2)
                    7346   OSMboxCreate_4:
                    7347   ; }
                    7348   ; OS_EXIT_CRITICAL();
00002918  46DF      7349          dc.w      18143
                    7350   ; if (pevent != (OS_EVENT *)0) {
0000291A  4A82      7351          tst.l     D2
0000291C  6728      7352          beq.s     OSMboxCreate_6
                    7353   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
0000291E  2042      7354          move.l    D2,A0
00002920  10BC 0001 7355          move.b    #1,(A0)
                    7356   ; pevent->OSEventCnt     = 0u;
00002924  2042      7357          move.l    D2,A0
00002926  4268 0006 7358          clr.w     6(A0)
                    7359   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
0000292A  2042      7360          move.l    D2,A0
0000292C  216E 0008 7361          move.l    8(A6),2(A0)
00002930  0002      
                    7362   ; #if OS_EVENT_NAME_EN > 0u
                    7363   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00002932  41F9 0000 7364          lea       @ucos_ii_1.L,A0
00002936  6AD0      
00002938  2242      7365          move.l    D2,A1
0000293A  2348 0012 7366          move.l    A0,18(A1)
                    7367   ; #endif
                    7368   ; OS_EventWaitListInit(pevent);
0000293E  2F02      7369          move.l    D2,-(A7)
00002940  4EB8 170A 7370          jsr       _OS_EventWaitListInit
00002944  584F      7371          addq.w    #4,A7
                    7372   OSMboxCreate_6:
                    7373   ; }
                    7374   ; return (pevent);                             /* Return pointer to event control block              */
00002946  2002      7375          move.l    D2,D0
                    7376   OSMboxCreate_3:
00002948  4CDF 0404 7377          movem.l   (A7)+,D2/A2
0000294C  4E5E      7378          unlk      A6
0000294E  4E75      7379          rts
                    7380   ; }
                    7381   ; /*$PAGE*/
                    7382   ; /*
                    7383   ; *********************************************************************************************************
                    7384   ; *                                           DELETE A MAIBOX
                    7385   ; *
                    7386   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    7387   ; *
                    7388   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    7389   ; *                            mailbox.
                    7390   ; *
                    7391   ; *              opt           determines delete options as follows:
                    7392   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    7393   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    7394   ; *                                                    In this case, all the tasks pending will be readied.
                    7395   ; *
                    7396   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    7397   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    7398   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    7399   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    7400   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    7401   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    7402   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    7403   ; *
                    7404   ; * Returns    : pevent        upon error
                    7405   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    7406   ; *
                    7407   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    7408   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    7409   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    7410   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    7411   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    7412   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    7413   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    7414   ; *                 will no longer be guarded by the mailbox.
                    7415   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    7416   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    7417   ; *********************************************************************************************************
                    7418   ; */
                    7419   ; #if OS_MBOX_DEL_EN > 0u
                    7420   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    7421   ; INT8U      opt,
                    7422   ; INT8U     *perr)
                    7423   ; {
                    7424   _OSMboxDel:
00002950  4E56 0000 7425          link      A6,#0
00002954  48E7 3C20 7426          movem.l   D2/D3/D4/D5/A2,-(A7)
00002958  242E 0008 7427          move.l    8(A6),D2
0000295C  262E 0010 7428          move.l    16(A6),D3
00002960  45F9 0800 7429          lea       _OSEventFreeList.L,A2
00002964  0CDA      
                    7430   ; BOOLEAN    tasks_waiting;
                    7431   ; OS_EVENT  *pevent_return;
                    7432   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7433   ; OS_CPU_SR  cpu_sr = 0u;
                    7434   ; #endif
                    7435   ; #ifdef OS_SAFETY_CRITICAL
                    7436   ; if (perr == (INT8U *)0) {
                    7437   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7438   ; return ((OS_EVENT *)0);
                    7439   ; }
                    7440   ; #endif
                    7441   ; #if OS_ARG_CHK_EN > 0u
                    7442   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7443   ; *perr = OS_ERR_PEVENT_NULL;
                    7444   ; return (pevent);
                    7445   ; }
                    7446   ; #endif
                    7447   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002966  2042      7448          move.l    D2,A0
00002968  1010      7449          move.b    (A0),D0
0000296A  0C00 0001 7450          cmp.b     #1,D0
0000296E  670C      7451          beq.s     OSMboxDel_1
                    7452   ; *perr = OS_ERR_EVENT_TYPE;
00002970  2043      7453          move.l    D3,A0
00002972  10BC 0001 7454          move.b    #1,(A0)
                    7455   ; return (pevent);
00002976  2002      7456          move.l    D2,D0
00002978  6000 00EA 7457          bra       OSMboxDel_3
                    7458   OSMboxDel_1:
                    7459   ; }
                    7460   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0000297C  1039 0800 7461          move.b    _OSIntNesting.L,D0
00002980  0F06      
00002982  0C00 0000 7462          cmp.b     #0,D0
00002986  630C      7463          bls.s     OSMboxDel_4
                    7464   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00002988  2043      7465          move.l    D3,A0
0000298A  10BC 000F 7466          move.b    #15,(A0)
                    7467   ; return (pevent);
0000298E  2002      7468          move.l    D2,D0
00002990  6000 00D2 7469          bra       OSMboxDel_3
                    7470   OSMboxDel_4:
                    7471   ; }
                    7472   ; OS_ENTER_CRITICAL();
00002994  40E7      7473          dc.w      16615
00002996  007C      7474          dc.w      124
00002998  0700      7475          dc.w      1792
                    7476   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
0000299A  2042      7477          move.l    D2,A0
0000299C  1028 0008 7478          move.b    8(A0),D0
000029A0  6704      7479          beq.s     OSMboxDel_6
                    7480   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000029A2  7A01      7481          moveq     #1,D5
000029A4  6002      7482          bra.s     OSMboxDel_7
                    7483   OSMboxDel_6:
                    7484   ; } else {
                    7485   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000029A6  4205      7486          clr.b     D5
                    7487   OSMboxDel_7:
                    7488   ; }
                    7489   ; switch (opt) {
000029A8  102E 000F 7490          move.b    15(A6),D0
000029AC  C0BC 0000 7491          and.l     #255,D0
000029B0  00FF      
000029B2  0C80 0000 7492          cmp.l     #1,D0
000029B6  0001      
000029B8  6700 0048 7493          beq       OSMboxDel_11
000029BC  6200 009A 7494          bhi       OSMboxDel_8
000029C0  4A80      7495          tst.l     D0
000029C2  6704      7496          beq.s     OSMboxDel_10
000029C4  6000 0092 7497          bra       OSMboxDel_8
                    7498   OSMboxDel_10:
                    7499   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    7500   ; if (tasks_waiting == OS_FALSE) {
000029C8  4A05      7501          tst.b     D5
000029CA  6628      7502          bne.s     OSMboxDel_13
                    7503   ; #if OS_EVENT_NAME_EN > 0u
                    7504   ; pevent->OSEventName = (INT8U *)(void *)"?";
000029CC  41F9 0000 7505          lea       @ucos_ii_1.L,A0
000029D0  6AD0      
000029D2  2242      7506          move.l    D2,A1
000029D4  2348 0012 7507          move.l    A0,18(A1)
                    7508   ; #endif
                    7509   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
000029D8  2042      7510          move.l    D2,A0
000029DA  4210      7511          clr.b     (A0)
                    7512   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
000029DC  2042      7513          move.l    D2,A0
000029DE  2152 0002 7514          move.l    (A2),2(A0)
                    7515   ; pevent->OSEventCnt  = 0u;
000029E2  2042      7516          move.l    D2,A0
000029E4  4268 0006 7517          clr.w     6(A0)
                    7518   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
000029E8  2482      7519          move.l    D2,(A2)
                    7520   ; OS_EXIT_CRITICAL();
000029EA  46DF      7521          dc.w      18143
                    7522   ; *perr               = OS_ERR_NONE;
000029EC  2043      7523          move.l    D3,A0
000029EE  4210      7524          clr.b     (A0)
                    7525   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
000029F0  4284      7526          clr.l     D4
000029F2  600A      7527          bra.s     OSMboxDel_14
                    7528   OSMboxDel_13:
                    7529   ; } else {
                    7530   ; OS_EXIT_CRITICAL();
000029F4  46DF      7531          dc.w      18143
                    7532   ; *perr               = OS_ERR_TASK_WAITING;
000029F6  2043      7533          move.l    D3,A0
000029F8  10BC 0049 7534          move.b    #73,(A0)
                    7535   ; pevent_return       = pevent;
000029FC  2802      7536          move.l    D2,D4
                    7537   OSMboxDel_14:
                    7538   ; }
                    7539   ; break;
000029FE  6000 0062 7540          bra       OSMboxDel_9
                    7541   OSMboxDel_11:
                    7542   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    7543   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    7544   OSMboxDel_15:
00002A02  2042      7545          move.l    D2,A0
00002A04  1028 0008 7546          move.b    8(A0),D0
00002A08  671C      7547          beq.s     OSMboxDel_17
                    7548   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002A0A  4878 0002 7549          pea       2
00002A0E  4878 0002 7550          pea       2
00002A12  42A7      7551          clr.l     -(A7)
00002A14  2F02      7552          move.l    D2,-(A7)
00002A16  4EB8 1442 7553          jsr       _OS_EventTaskRdy
00002A1A  DEFC 0010 7554          add.w     #16,A7
00002A1E  C0BC 0000 7555          and.l     #255,D0
00002A22  00FF      
00002A24  60DC      7556          bra       OSMboxDel_15
                    7557   OSMboxDel_17:
                    7558   ; }
                    7559   ; #if OS_EVENT_NAME_EN > 0u
                    7560   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00002A26  41F9 0000 7561          lea       @ucos_ii_1.L,A0
00002A2A  6AD0      
00002A2C  2242      7562          move.l    D2,A1
00002A2E  2348 0012 7563          move.l    A0,18(A1)
                    7564   ; #endif
                    7565   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00002A32  2042      7566          move.l    D2,A0
00002A34  4210      7567          clr.b     (A0)
                    7568   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00002A36  2042      7569          move.l    D2,A0
00002A38  2152 0002 7570          move.l    (A2),2(A0)
                    7571   ; pevent->OSEventCnt     = 0u;
00002A3C  2042      7572          move.l    D2,A0
00002A3E  4268 0006 7573          clr.w     6(A0)
                    7574   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00002A42  2482      7575          move.l    D2,(A2)
                    7576   ; OS_EXIT_CRITICAL();
00002A44  46DF      7577          dc.w      18143
                    7578   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00002A46  0C05 0001 7579          cmp.b     #1,D5
00002A4A  6604      7580          bne.s     OSMboxDel_18
                    7581   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002A4C  4EB8 1A22 7582          jsr       _OS_Sched
                    7583   OSMboxDel_18:
                    7584   ; }
                    7585   ; *perr         = OS_ERR_NONE;
00002A50  2043      7586          move.l    D3,A0
00002A52  4210      7587          clr.b     (A0)
                    7588   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
00002A54  4284      7589          clr.l     D4
                    7590   ; break;
00002A56  600A      7591          bra.s     OSMboxDel_9
                    7592   OSMboxDel_8:
                    7593   ; default:
                    7594   ; OS_EXIT_CRITICAL();
00002A58  46DF      7595          dc.w      18143
                    7596   ; *perr         = OS_ERR_INVALID_OPT;
00002A5A  2043      7597          move.l    D3,A0
00002A5C  10BC 0007 7598          move.b    #7,(A0)
                    7599   ; pevent_return = pevent;
00002A60  2802      7600          move.l    D2,D4
                    7601   ; break;
                    7602   OSMboxDel_9:
                    7603   ; }
                    7604   ; return (pevent_return);
00002A62  2004      7605          move.l    D4,D0
                    7606   OSMboxDel_3:
00002A64  4CDF 043C 7607          movem.l   (A7)+,D2/D3/D4/D5/A2
00002A68  4E5E      7608          unlk      A6
00002A6A  4E75      7609          rts
                    7610   ; }
                    7611   ; #endif
                    7612   ; /*$PAGE*/
                    7613   ; /*
                    7614   ; *********************************************************************************************************
                    7615   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    7616   ; *
                    7617   ; * Description: This function waits for a message to be sent to a mailbox
                    7618   ; *
                    7619   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7620   ; *
                    7621   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    7622   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    7623   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    7624   ; *                            forever at the specified mailbox or, until a message arrives.
                    7625   ; *
                    7626   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7627   ; *                            messages are:
                    7628   ; *
                    7629   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    7630   ; *                                                message.
                    7631   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    7632   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    7633   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    7634   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    7635   ; *                                                would lead to a suspension.
                    7636   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    7637   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    7638   ; *
                    7639   ; * Returns    : != (void *)0  is a pointer to the message received
                    7640   ; *              == (void *)0  if no message was received or,
                    7641   ; *                            if 'pevent' is a NULL pointer or,
                    7642   ; *                            if you didn't pass the proper pointer to the event control block.
                    7643   ; *********************************************************************************************************
                    7644   ; */
                    7645   ; /*$PAGE*/
                    7646   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    7647   ; INT32U     timeout,
                    7648   ; INT8U     *perr)
                    7649   ; {
                    7650   _OSMboxPend:
00002A6C  4E56 0000 7651          link      A6,#0
00002A70  48E7 3820 7652          movem.l   D2/D3/D4/A2,-(A7)
00002A74  45F9 0800 7653          lea       _OSTCBCur.L,A2
00002A78  1020      
00002A7A  262E 0010 7654          move.l    16(A6),D3
00002A7E  282E 0008 7655          move.l    8(A6),D4
                    7656   ; void      *pmsg;
                    7657   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7658   ; OS_CPU_SR  cpu_sr = 0u;
                    7659   ; #endif
                    7660   ; #ifdef OS_SAFETY_CRITICAL
                    7661   ; if (perr == (INT8U *)0) {
                    7662   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7663   ; return ((void *)0);
                    7664   ; }
                    7665   ; #endif
                    7666   ; #if OS_ARG_CHK_EN > 0u
                    7667   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7668   ; *perr = OS_ERR_PEVENT_NULL;
                    7669   ; return ((void *)0);
                    7670   ; }
                    7671   ; #endif
                    7672   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002A82  2044      7673          move.l    D4,A0
00002A84  1010      7674          move.b    (A0),D0
00002A86  0C00 0001 7675          cmp.b     #1,D0
00002A8A  670C      7676          beq.s     OSMboxPend_1
                    7677   ; *perr = OS_ERR_EVENT_TYPE;
00002A8C  2043      7678          move.l    D3,A0
00002A8E  10BC 0001 7679          move.b    #1,(A0)
                    7680   ; return ((void *)0);
00002A92  4280      7681          clr.l     D0
00002A94  6000 00F0 7682          bra       OSMboxPend_3
                    7683   OSMboxPend_1:
                    7684   ; }
                    7685   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00002A98  1039 0800 7686          move.b    _OSIntNesting.L,D0
00002A9C  0F06      
00002A9E  0C00 0000 7687          cmp.b     #0,D0
00002AA2  630C      7688          bls.s     OSMboxPend_4
                    7689   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00002AA4  2043      7690          move.l    D3,A0
00002AA6  10BC 0002 7691          move.b    #2,(A0)
                    7692   ; return ((void *)0);
00002AAA  4280      7693          clr.l     D0
00002AAC  6000 00D8 7694          bra       OSMboxPend_3
                    7695   OSMboxPend_4:
                    7696   ; }
                    7697   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00002AB0  1039 0800 7698          move.b    _OSLockNesting.L,D0
00002AB4  0F08      
00002AB6  0C00 0000 7699          cmp.b     #0,D0
00002ABA  630C      7700          bls.s     OSMboxPend_6
                    7701   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002ABC  2043      7702          move.l    D3,A0
00002ABE  10BC 000D 7703          move.b    #13,(A0)
                    7704   ; return ((void *)0);
00002AC2  4280      7705          clr.l     D0
00002AC4  6000 00C0 7706          bra       OSMboxPend_3
                    7707   OSMboxPend_6:
                    7708   ; }
                    7709   ; OS_ENTER_CRITICAL();
00002AC8  40E7      7710          dc.w      16615
00002ACA  007C      7711          dc.w      124
00002ACC  0700      7712          dc.w      1792
                    7713   ; pmsg = pevent->OSEventPtr;
00002ACE  2044      7714          move.l    D4,A0
00002AD0  2428 0002 7715          move.l    2(A0),D2
                    7716   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
00002AD4  4A82      7717          tst.l     D2
00002AD6  6712      7718          beq.s     OSMboxPend_8
                    7719   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
00002AD8  2044      7720          move.l    D4,A0
00002ADA  42A8 0002 7721          clr.l     2(A0)
                    7722   ; OS_EXIT_CRITICAL();
00002ADE  46DF      7723          dc.w      18143
                    7724   ; *perr = OS_ERR_NONE;
00002AE0  2043      7725          move.l    D3,A0
00002AE2  4210      7726          clr.b     (A0)
                    7727   ; return (pmsg);                                /* Return the message received (or NULL)         */
00002AE4  2002      7728          move.l    D2,D0
00002AE6  6000 009E 7729          bra       OSMboxPend_3
                    7730   OSMboxPend_8:
                    7731   ; }
                    7732   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
00002AEA  2052      7733          move.l    (A2),A0
00002AEC  0028 0002 7734          or.b      #2,50(A0)
00002AF0  0032      
                    7735   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00002AF2  2052      7736          move.l    (A2),A0
00002AF4  4228 0033 7737          clr.b     51(A0)
                    7738   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
00002AF8  2052      7739          move.l    (A2),A0
00002AFA  216E 000C 7740          move.l    12(A6),46(A0)
00002AFE  002E      
                    7741   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00002B00  2F04      7742          move.l    D4,-(A7)
00002B02  4EB8 1526 7743          jsr       _OS_EventTaskWait
00002B06  584F      7744          addq.w    #4,A7
                    7745   ; OS_EXIT_CRITICAL();
00002B08  46DF      7746          dc.w      18143
                    7747   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
00002B0A  4EB8 1A22 7748          jsr       _OS_Sched
                    7749   ; OS_ENTER_CRITICAL();
00002B0E  40E7      7750          dc.w      16615
00002B10  007C      7751          dc.w      124
00002B12  0700      7752          dc.w      1792
                    7753   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00002B14  2052      7754          move.l    (A2),A0
00002B16  1028 0033 7755          move.b    51(A0),D0
00002B1A  C0BC 0000 7756          and.l     #255,D0
00002B1E  00FF      
00002B20  0C80 0000 7757          cmp.l     #1,D0
00002B24  0001      
00002B26  6700 002A 7758          beq       OSMboxPend_14
00002B2A  6206      7759          bhi.s     OSMboxPend_16
00002B2C  4A80      7760          tst.l     D0
00002B2E  670C      7761          beq.s     OSMboxPend_12
00002B30  6020      7762          bra.s     OSMboxPend_14
                    7763   OSMboxPend_16:
00002B32  0C80 0000 7764          cmp.l     #2,D0
00002B36  0002      
00002B38  670E      7765          beq.s     OSMboxPend_13
00002B3A  6016      7766          bra.s     OSMboxPend_14
                    7767   OSMboxPend_12:
                    7768   ; case OS_STAT_PEND_OK:
                    7769   ; pmsg =  OSTCBCur->OSTCBMsg;
00002B3C  2052      7770          move.l    (A2),A0
00002B3E  2428 0024 7771          move.l    36(A0),D2
                    7772   ; *perr =  OS_ERR_NONE;
00002B42  2043      7773          move.l    D3,A0
00002B44  4210      7774          clr.b     (A0)
                    7775   ; break;
00002B46  601C      7776          bra.s     OSMboxPend_11
                    7777   OSMboxPend_13:
                    7778   ; case OS_STAT_PEND_ABORT:
                    7779   ; pmsg = (void *)0;
00002B48  4282      7780          clr.l     D2
                    7781   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00002B4A  2043      7782          move.l    D3,A0
00002B4C  10BC 000E 7783          move.b    #14,(A0)
                    7784   ; break;
00002B50  6012      7785          bra.s     OSMboxPend_11
                    7786   OSMboxPend_14:
                    7787   ; case OS_STAT_PEND_TO:
                    7788   ; default:
                    7789   ; OS_EventTaskRemove(OSTCBCur, pevent);
00002B52  2F04      7790          move.l    D4,-(A7)
00002B54  2F12      7791          move.l    (A2),-(A7)
00002B56  4EB8 1648 7792          jsr       _OS_EventTaskRemove
00002B5A  504F      7793          addq.w    #8,A7
                    7794   ; pmsg = (void *)0;
00002B5C  4282      7795          clr.l     D2
                    7796   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00002B5E  2043      7797          move.l    D3,A0
00002B60  10BC 000A 7798          move.b    #10,(A0)
                    7799   ; break;
                    7800   OSMboxPend_11:
                    7801   ; }
                    7802   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00002B64  2052      7803          move.l    (A2),A0
00002B66  4228 0032 7804          clr.b     50(A0)
                    7805   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00002B6A  2052      7806          move.l    (A2),A0
00002B6C  4228 0033 7807          clr.b     51(A0)
                    7808   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002B70  2052      7809          move.l    (A2),A0
00002B72  42A8 001C 7810          clr.l     28(A0)
                    7811   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7812   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00002B76  2052      7813          move.l    (A2),A0
00002B78  42A8 0020 7814          clr.l     32(A0)
                    7815   ; #endif
                    7816   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002B7C  2052      7817          move.l    (A2),A0
00002B7E  42A8 0024 7818          clr.l     36(A0)
                    7819   ; OS_EXIT_CRITICAL();
00002B82  46DF      7820          dc.w      18143
                    7821   ; return (pmsg);                                    /* Return received message                       */
00002B84  2002      7822          move.l    D2,D0
                    7823   OSMboxPend_3:
00002B86  4CDF 041C 7824          movem.l   (A7)+,D2/D3/D4/A2
00002B8A  4E5E      7825          unlk      A6
00002B8C  4E75      7826          rts
                    7827   ; }
                    7828   ; /*$PAGE*/
                    7829   ; /*
                    7830   ; *********************************************************************************************************
                    7831   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7832   ; *
                    7833   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7834   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7835   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7836   ; *
                    7837   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7838   ; *
                    7839   ; *              opt           determines the type of ABORT performed:
                    7840   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7841   ; *                                                     mailbox
                    7842   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7843   ; *                                                     mailbox
                    7844   ; *
                    7845   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7846   ; *                            messages are:
                    7847   ; *
                    7848   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7849   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7850   ; *                                                and informed of the aborted wait; check return value
                    7851   ; *                                                for the number of tasks whose wait on the mailbox
                    7852   ; *                                                was aborted.
                    7853   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7854   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7855   ; *
                    7856   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7857   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7858   ; *********************************************************************************************************
                    7859   ; */
                    7860   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7861   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7862   ; INT8U      opt,
                    7863   ; INT8U     *perr)
                    7864   ; {
                    7865   _OSMboxPendAbort:
00002B8E  4E56 0000 7866          link      A6,#0
00002B92  48E7 3800 7867          movem.l   D2/D3/D4,-(A7)
00002B96  242E 0008 7868          move.l    8(A6),D2
00002B9A  282E 0010 7869          move.l    16(A6),D4
                    7870   ; INT8U      nbr_tasks;
                    7871   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7872   ; OS_CPU_SR  cpu_sr = 0u;
                    7873   ; #endif
                    7874   ; #ifdef OS_SAFETY_CRITICAL
                    7875   ; if (perr == (INT8U *)0) {
                    7876   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7877   ; return (0u);
                    7878   ; }
                    7879   ; #endif
                    7880   ; #if OS_ARG_CHK_EN > 0u
                    7881   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7882   ; *perr = OS_ERR_PEVENT_NULL;
                    7883   ; return (0u);
                    7884   ; }
                    7885   ; #endif
                    7886   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002B9E  2042      7887          move.l    D2,A0
00002BA0  1010      7888          move.b    (A0),D0
00002BA2  0C00 0001 7889          cmp.b     #1,D0
00002BA6  670C      7890          beq.s     OSMboxPendAbort_1
                    7891   ; *perr = OS_ERR_EVENT_TYPE;
00002BA8  2044      7892          move.l    D4,A0
00002BAA  10BC 0001 7893          move.b    #1,(A0)
                    7894   ; return (0u);
00002BAE  4200      7895          clr.b     D0
00002BB0  6000 008C 7896          bra       OSMboxPendAbort_3
                    7897   OSMboxPendAbort_1:
                    7898   ; }
                    7899   ; OS_ENTER_CRITICAL();
00002BB4  40E7      7900          dc.w      16615
00002BB6  007C      7901          dc.w      124
00002BB8  0700      7902          dc.w      1792
                    7903   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
00002BBA  2042      7904          move.l    D2,A0
00002BBC  1028 0008 7905          move.b    8(A0),D0
00002BC0  6700 0074 7906          beq       OSMboxPendAbort_4
                    7907   ; nbr_tasks = 0u;
00002BC4  4203      7908          clr.b     D3
                    7909   ; switch (opt) {
00002BC6  102E 000F 7910          move.b    15(A6),D0
00002BCA  C0BC 0000 7911          and.l     #255,D0
00002BCE  00FF      
00002BD0  0C80 0000 7912          cmp.l     #1,D0
00002BD4  0001      
00002BD6  670A      7913          beq.s     OSMboxPendAbort_8
00002BD8  6200 0030 7914          bhi       OSMboxPendAbort_9
00002BDC  4A80      7915          tst.l     D0
00002BDE  672A      7916          beq.s     OSMboxPendAbort_9
00002BE0  6028      7917          bra.s     OSMboxPendAbort_9
                    7918   OSMboxPendAbort_8:
                    7919   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7920   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7921   OSMboxPendAbort_11:
00002BE2  2042      7922          move.l    D2,A0
00002BE4  1028 0008 7923          move.b    8(A0),D0
00002BE8  671E      7924          beq.s     OSMboxPendAbort_13
                    7925   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002BEA  4878 0002 7926          pea       2
00002BEE  4878 0002 7927          pea       2
00002BF2  42A7      7928          clr.l     -(A7)
00002BF4  2F02      7929          move.l    D2,-(A7)
00002BF6  4EB8 1442 7930          jsr       _OS_EventTaskRdy
00002BFA  DEFC 0010 7931          add.w     #16,A7
00002BFE  C0BC 0000 7932          and.l     #255,D0
00002C02  00FF      
                    7933   ; nbr_tasks++;
00002C04  5203      7934          addq.b    #1,D3
00002C06  60DA      7935          bra       OSMboxPendAbort_11
                    7936   OSMboxPendAbort_13:
                    7937   ; }
                    7938   ; break;
00002C08  601C      7939          bra.s     OSMboxPendAbort_7
                    7940   OSMboxPendAbort_9:
                    7941   ; case OS_PEND_OPT_NONE:
                    7942   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7943   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002C0A  4878 0002 7944          pea       2
00002C0E  4878 0002 7945          pea       2
00002C12  42A7      7946          clr.l     -(A7)
00002C14  2F02      7947          move.l    D2,-(A7)
00002C16  4EB8 1442 7948          jsr       _OS_EventTaskRdy
00002C1A  DEFC 0010 7949          add.w     #16,A7
00002C1E  C0BC 0000 7950          and.l     #255,D0
00002C22  00FF      
                    7951   ; nbr_tasks++;
00002C24  5203      7952          addq.b    #1,D3
                    7953   ; break;
                    7954   OSMboxPendAbort_7:
                    7955   ; }
                    7956   ; OS_EXIT_CRITICAL();
00002C26  46DF      7957          dc.w      18143
                    7958   ; OS_Sched();                                        /* Find HPT ready to run                    */
00002C28  4EB8 1A22 7959          jsr       _OS_Sched
                    7960   ; *perr = OS_ERR_PEND_ABORT;
00002C2C  2044      7961          move.l    D4,A0
00002C2E  10BC 000E 7962          move.b    #14,(A0)
                    7963   ; return (nbr_tasks);
00002C32  1003      7964          move.b    D3,D0
00002C34  6008      7965          bra.s     OSMboxPendAbort_3
                    7966   OSMboxPendAbort_4:
                    7967   ; }
                    7968   ; OS_EXIT_CRITICAL();
00002C36  46DF      7969          dc.w      18143
                    7970   ; *perr = OS_ERR_NONE;
00002C38  2044      7971          move.l    D4,A0
00002C3A  4210      7972          clr.b     (A0)
                    7973   ; return (0u);                                           /* No tasks waiting on mailbox              */
00002C3C  4200      7974          clr.b     D0
                    7975   OSMboxPendAbort_3:
00002C3E  4CDF 001C 7976          movem.l   (A7)+,D2/D3/D4
00002C42  4E5E      7977          unlk      A6
00002C44  4E75      7978          rts
                    7979   ; }
                    7980   ; #endif
                    7981   ; /*$PAGE*/
                    7982   ; /*
                    7983   ; *********************************************************************************************************
                    7984   ; *                                      POST MESSAGE TO A MAILBOX
                    7985   ; *
                    7986   ; * Description: This function sends a message to a mailbox
                    7987   ; *
                    7988   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7989   ; *
                    7990   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7991   ; *
                    7992   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7993   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7994   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7995   ; *                                   are allowed to send another one.
                    7996   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7997   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7998   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7999   ; *
                    8000   ; * Note(s)    : 1) HPT means Highest Priority Task
                    8001   ; *********************************************************************************************************
                    8002   ; */
                    8003   ; #if OS_MBOX_POST_EN > 0u
                    8004   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    8005   ; void      *pmsg)
                    8006   ; {
                    8007   _OSMboxPost:
00002C46  4E56 0000 8008          link      A6,#0
00002C4A  2F02      8009          move.l    D2,-(A7)
00002C4C  242E 0008 8010          move.l    8(A6),D2
                    8011   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8012   ; OS_CPU_SR  cpu_sr = 0u;
                    8013   ; #endif
                    8014   ; #if OS_ARG_CHK_EN > 0u
                    8015   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    8016   ; return (OS_ERR_PEVENT_NULL);
                    8017   ; }
                    8018   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    8019   ; return (OS_ERR_POST_NULL_PTR);
                    8020   ; }
                    8021   ; #endif
                    8022   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002C50  2042      8023          move.l    D2,A0
00002C52  1010      8024          move.b    (A0),D0
00002C54  0C00 0001 8025          cmp.b     #1,D0
00002C58  6706      8026          beq.s     OSMboxPost_1
                    8027   ; return (OS_ERR_EVENT_TYPE);
00002C5A  7001      8028          moveq     #1,D0
00002C5C  6000 004E 8029          bra       OSMboxPost_3
                    8030   OSMboxPost_1:
                    8031   ; }
                    8032   ; OS_ENTER_CRITICAL();
00002C60  40E7      8033          dc.w      16615
00002C62  007C      8034          dc.w      124
00002C64  0700      8035          dc.w      1792
                    8036   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002C66  2042      8037          move.l    D2,A0
00002C68  1028 0008 8038          move.b    8(A0),D0
00002C6C  6724      8039          beq.s     OSMboxPost_4
                    8040   ; /* Ready HPT waiting on event                    */
                    8041   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002C6E  42A7      8042          clr.l     -(A7)
00002C70  4878 0002 8043          pea       2
00002C74  2F2E 000C 8044          move.l    12(A6),-(A7)
00002C78  2F02      8045          move.l    D2,-(A7)
00002C7A  4EB8 1442 8046          jsr       _OS_EventTaskRdy
00002C7E  DEFC 0010 8047          add.w     #16,A7
00002C82  C0BC 0000 8048          and.l     #255,D0
00002C86  00FF      
                    8049   ; OS_EXIT_CRITICAL();
00002C88  46DF      8050          dc.w      18143
                    8051   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002C8A  4EB8 1A22 8052          jsr       _OS_Sched
                    8053   ; return (OS_ERR_NONE);
00002C8E  4200      8054          clr.b     D0
00002C90  601A      8055          bra.s     OSMboxPost_3
                    8056   OSMboxPost_4:
                    8057   ; }
                    8058   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002C92  2042      8059          move.l    D2,A0
00002C94  2028 0002 8060          move.l    2(A0),D0
00002C98  6706      8061          beq.s     OSMboxPost_6
                    8062   ; OS_EXIT_CRITICAL();
00002C9A  46DF      8063          dc.w      18143
                    8064   ; return (OS_ERR_MBOX_FULL);
00002C9C  7014      8065          moveq     #20,D0
00002C9E  600C      8066          bra.s     OSMboxPost_3
                    8067   OSMboxPost_6:
                    8068   ; }
                    8069   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002CA0  2042      8070          move.l    D2,A0
00002CA2  216E 000C 8071          move.l    12(A6),2(A0)
00002CA6  0002      
                    8072   ; OS_EXIT_CRITICAL();
00002CA8  46DF      8073          dc.w      18143
                    8074   ; return (OS_ERR_NONE);
00002CAA  4200      8075          clr.b     D0
                    8076   OSMboxPost_3:
00002CAC  241F      8077          move.l    (A7)+,D2
00002CAE  4E5E      8078          unlk      A6
00002CB0  4E75      8079          rts
                    8080   ; }
                    8081   ; #endif
                    8082   ; /*$PAGE*/
                    8083   ; /*
                    8084   ; *********************************************************************************************************
                    8085   ; *                                      POST MESSAGE TO A MAILBOX
                    8086   ; *
                    8087   ; * Description: This function sends a message to a mailbox
                    8088   ; *
                    8089   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    8090   ; *
                    8091   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    8092   ; *
                    8093   ; *              opt           determines the type of POST performed:
                    8094   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    8095   ; *                                                     (Identical to OSMboxPost())
                    8096   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    8097   ; *
                    8098   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    8099   ; *
                    8100   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    8101   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    8102   ; *                                   message at a time and thus, the message MUST be consumed before you
                    8103   ; *                                   are allowed to send another one.
                    8104   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    8105   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    8106   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    8107   ; *
                    8108   ; * Note(s)    : 1) HPT means Highest Priority Task
                    8109   ; *
                    8110   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    8111   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    8112   ; *********************************************************************************************************
                    8113   ; */
                    8114   ; #if OS_MBOX_POST_OPT_EN > 0u
                    8115   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    8116   ; void      *pmsg,
                    8117   ; INT8U      opt)
                    8118   ; {
                    8119   _OSMboxPostOpt:
00002CB2  4E56 0000 8120          link      A6,#0
00002CB6  48E7 3000 8121          movem.l   D2/D3,-(A7)
00002CBA  242E 0008 8122          move.l    8(A6),D2
00002CBE  262E 000C 8123          move.l    12(A6),D3
                    8124   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8125   ; OS_CPU_SR  cpu_sr = 0u;
                    8126   ; #endif
                    8127   ; #if OS_ARG_CHK_EN > 0u
                    8128   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    8129   ; return (OS_ERR_PEVENT_NULL);
                    8130   ; }
                    8131   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    8132   ; return (OS_ERR_POST_NULL_PTR);
                    8133   ; }
                    8134   ; #endif
                    8135   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002CC2  2042      8136          move.l    D2,A0
00002CC4  1010      8137          move.b    (A0),D0
00002CC6  0C00 0001 8138          cmp.b     #1,D0
00002CCA  6706      8139          beq.s     OSMboxPostOpt_1
                    8140   ; return (OS_ERR_EVENT_TYPE);
00002CCC  7001      8141          moveq     #1,D0
00002CCE  6000 0084 8142          bra       OSMboxPostOpt_3
                    8143   OSMboxPostOpt_1:
                    8144   ; }
                    8145   ; OS_ENTER_CRITICAL();
00002CD2  40E7      8146          dc.w      16615
00002CD4  007C      8147          dc.w      124
00002CD6  0700      8148          dc.w      1792
                    8149   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002CD8  2042      8150          move.l    D2,A0
00002CDA  1028 0008 8151          move.b    8(A0),D0
00002CDE  6700 005C 8152          beq       OSMboxPostOpt_4
                    8153   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00002CE2  102E 0013 8154          move.b    19(A6),D0
00002CE6  C03C 0001 8155          and.b     #1,D0
00002CEA  6724      8156          beq.s     OSMboxPostOpt_6
                    8157   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    8158   OSMboxPostOpt_8:
00002CEC  2042      8159          move.l    D2,A0
00002CEE  1028 0008 8160          move.b    8(A0),D0
00002CF2  671A      8161          beq.s     OSMboxPostOpt_10
                    8162   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002CF4  42A7      8163          clr.l     -(A7)
00002CF6  4878 0002 8164          pea       2
00002CFA  2F03      8165          move.l    D3,-(A7)
00002CFC  2F02      8166          move.l    D2,-(A7)
00002CFE  4EB8 1442 8167          jsr       _OS_EventTaskRdy
00002D02  DEFC 0010 8168          add.w     #16,A7
00002D06  C0BC 0000 8169          and.l     #255,D0
00002D0A  00FF      
00002D0C  60DE      8170          bra       OSMboxPostOpt_8
                    8171   OSMboxPostOpt_10:
00002D0E  6018      8172          bra.s     OSMboxPostOpt_7
                    8173   OSMboxPostOpt_6:
                    8174   ; }
                    8175   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    8176   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002D10  42A7      8177          clr.l     -(A7)
00002D12  4878 0002 8178          pea       2
00002D16  2F03      8179          move.l    D3,-(A7)
00002D18  2F02      8180          move.l    D2,-(A7)
00002D1A  4EB8 1442 8181          jsr       _OS_EventTaskRdy
00002D1E  DEFC 0010 8182          add.w     #16,A7
00002D22  C0BC 0000 8183          and.l     #255,D0
00002D26  00FF      
                    8184   OSMboxPostOpt_7:
                    8185   ; }
                    8186   ; OS_EXIT_CRITICAL();
00002D28  46DF      8187          dc.w      18143
                    8188   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00002D2A  102E 0013 8189          move.b    19(A6),D0
00002D2E  C03C 0004 8190          and.b     #4,D0
00002D32  6604      8191          bne.s     OSMboxPostOpt_11
                    8192   ; OS_Sched();                               /* Find HPT ready to run                         */
00002D34  4EB8 1A22 8193          jsr       _OS_Sched
                    8194   OSMboxPostOpt_11:
                    8195   ; }
                    8196   ; return (OS_ERR_NONE);
00002D38  4200      8197          clr.b     D0
00002D3A  6018      8198          bra.s     OSMboxPostOpt_3
                    8199   OSMboxPostOpt_4:
                    8200   ; }
                    8201   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002D3C  2042      8202          move.l    D2,A0
00002D3E  2028 0002 8203          move.l    2(A0),D0
00002D42  6706      8204          beq.s     OSMboxPostOpt_13
                    8205   ; OS_EXIT_CRITICAL();
00002D44  46DF      8206          dc.w      18143
                    8207   ; return (OS_ERR_MBOX_FULL);
00002D46  7014      8208          moveq     #20,D0
00002D48  600A      8209          bra.s     OSMboxPostOpt_3
                    8210   OSMboxPostOpt_13:
                    8211   ; }
                    8212   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002D4A  2042      8213          move.l    D2,A0
00002D4C  2143 0002 8214          move.l    D3,2(A0)
                    8215   ; OS_EXIT_CRITICAL();
00002D50  46DF      8216          dc.w      18143
                    8217   ; return (OS_ERR_NONE);
00002D52  4200      8218          clr.b     D0
                    8219   OSMboxPostOpt_3:
00002D54  4CDF 000C 8220          movem.l   (A7)+,D2/D3
00002D58  4E5E      8221          unlk      A6
00002D5A  4E75      8222          rts
                    8223   ; }
                    8224   ; #endif
                    8225   ; /*$PAGE*/
                    8226   ; /*
                    8227   ; *********************************************************************************************************
                    8228   ; *                                       QUERY A MESSAGE MAILBOX
                    8229   ; *
                    8230   ; * Description: This function obtains information about a message mailbox.
                    8231   ; *
                    8232   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    8233   ; *
                    8234   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    8235   ; *                            mailbox.
                    8236   ; *
                    8237   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    8238   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    8239   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    8240   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    8241   ; *********************************************************************************************************
                    8242   ; */
                    8243   ; #if OS_MBOX_QUERY_EN > 0u
                    8244   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    8245   ; OS_MBOX_DATA  *p_mbox_data)
                    8246   ; {
                    8247   _OSMboxQuery:
00002D5C  4E56 FFF8 8248          link      A6,#-8
00002D60  48E7 3800 8249          movem.l   D2/D3/D4,-(A7)
00002D64  242E 0008 8250          move.l    8(A6),D2
00002D68  282E 000C 8251          move.l    12(A6),D4
                    8252   ; INT8U       i;
                    8253   ; OS_PRIO    *psrc;
                    8254   ; OS_PRIO    *pdest;
                    8255   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8256   ; OS_CPU_SR   cpu_sr = 0u;
                    8257   ; #endif
                    8258   ; #if OS_ARG_CHK_EN > 0u
                    8259   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    8260   ; return (OS_ERR_PEVENT_NULL);
                    8261   ; }
                    8262   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    8263   ; return (OS_ERR_PDATA_NULL);
                    8264   ; }
                    8265   ; #endif
                    8266   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002D6C  2042      8267          move.l    D2,A0
00002D6E  1010      8268          move.b    (A0),D0
00002D70  0C00 0001 8269          cmp.b     #1,D0
00002D74  6706      8270          beq.s     OSMboxQuery_1
                    8271   ; return (OS_ERR_EVENT_TYPE);
00002D76  7001      8272          moveq     #1,D0
00002D78  6000 004C 8273          bra       OSMboxQuery_3
                    8274   OSMboxQuery_1:
                    8275   ; }
                    8276   ; OS_ENTER_CRITICAL();
00002D7C  40E7      8277          dc.w      16615
00002D7E  007C      8278          dc.w      124
00002D80  0700      8279          dc.w      1792
                    8280   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
00002D82  2042      8281          move.l    D2,A0
00002D84  2244      8282          move.l    D4,A1
00002D86  1368 0008 8283          move.b    8(A0),12(A1)
00002D8A  000C      
                    8284   ; psrc                    = &pevent->OSEventTbl[0];
00002D8C  700A      8285          moveq     #10,D0
00002D8E  D082      8286          add.l     D2,D0
00002D90  2D40 FFF8 8287          move.l    D0,-8(A6)
                    8288   ; pdest                   = &p_mbox_data->OSEventTbl[0];
00002D94  7004      8289          moveq     #4,D0
00002D96  D084      8290          add.l     D4,D0
00002D98  2D40 FFFC 8291          move.l    D0,-4(A6)
                    8292   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002D9C  4203      8293          clr.b     D3
                    8294   OSMboxQuery_4:
00002D9E  0C03 0008 8295          cmp.b     #8,D3
00002DA2  6416      8296          bhs.s     OSMboxQuery_6
                    8297   ; *pdest++ = *psrc++;
00002DA4  206E FFF8 8298          move.l    -8(A6),A0
00002DA8  52AE FFF8 8299          addq.l    #1,-8(A6)
00002DAC  226E FFFC 8300          move.l    -4(A6),A1
00002DB0  52AE FFFC 8301          addq.l    #1,-4(A6)
00002DB4  1290      8302          move.b    (A0),(A1)
00002DB6  5203      8303          addq.b    #1,D3
00002DB8  60E4      8304          bra       OSMboxQuery_4
                    8305   OSMboxQuery_6:
                    8306   ; }
                    8307   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002DBA  2042      8308          move.l    D2,A0
00002DBC  2244      8309          move.l    D4,A1
00002DBE  22A8 0002 8310          move.l    2(A0),(A1)
                    8311   ; OS_EXIT_CRITICAL();
00002DC2  46DF      8312          dc.w      18143
                    8313   ; return (OS_ERR_NONE);
00002DC4  4200      8314          clr.b     D0
                    8315   OSMboxQuery_3:
00002DC6  4CDF 001C 8316          movem.l   (A7)+,D2/D3/D4
00002DCA  4E5E      8317          unlk      A6
00002DCC  4E75      8318          rts
                    8319   ; /*
                    8320   ; *********************************************************************************************************
                    8321   ; *                                                uC/OS-II
                    8322   ; *                                          The Real-Time Kernel
                    8323   ; *                                            MEMORY MANAGEMENT
                    8324   ; *
                    8325   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8326   ; *                                           All Rights Reserved
                    8327   ; *
                    8328   ; * File    : OS_MEM.C
                    8329   ; * By      : Jean J. Labrosse
                    8330   ; * Version : V2.92.07
                    8331   ; *
                    8332   ; * LICENSING TERMS:
                    8333   ; * ---------------
                    8334   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8335   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8336   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8337   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8338   ; * licensing fee.
                    8339   ; *********************************************************************************************************
                    8340   ; */
                    8341   ; #define  MICRIUM_SOURCE
                    8342   ; #ifndef  OS_MASTER_FILE
                    8343   ; #include <ucos_ii.h>
                    8344   ; #endif
                    8345   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    8346   ; /*
                    8347   ; *********************************************************************************************************
                    8348   ; *                                      CREATE A MEMORY PARTITION
                    8349   ; *
                    8350   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    8351   ; *
                    8352   ; * Arguments   : addr     is the starting address of the memory partition
                    8353   ; *
                    8354   ; *               nblks    is the number of memory blocks to create from the partition.
                    8355   ; *
                    8356   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    8357   ; *
                    8358   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    8359   ; *                        this function to either:
                    8360   ; *
                    8361   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    8362   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    8363   ; *                                                 storage of the partition or, the block does not align
                    8364   ; *                                                 on a pointer boundary
                    8365   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    8366   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    8367   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    8368   ; *                                                   - must be greater than the size of a pointer
                    8369   ; *                                                   - must be able to hold an integral number of pointers
                    8370   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    8371   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    8372   ; *                              free partition is available.
                    8373   ; *********************************************************************************************************
                    8374   ; */
                    8375   ; OS_MEM  *OSMemCreate (void   *addr,
                    8376   ; INT32U  nblks,
                    8377   ; INT32U  blksize,
                    8378   ; INT8U  *perr)
                    8379   ; {
                    8380   _OSMemCreate:
00002DCE  4E56 FFFC 8381          link      A6,#-4
00002DD2  48E7 3F20 8382          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002DD6  282E 0008 8383          move.l    8(A6),D4
00002DDA  45F9 0800 8384          lea       _OSMemFreeList.L,A2
00002DDE  1894      
00002DE0  2E2E 000C 8385          move.l    12(A6),D7
                    8386   ; OS_MEM    *pmem;
                    8387   ; INT8U     *pblk;
                    8388   ; void     **plink;
                    8389   ; INT32U     loops;
                    8390   ; INT32U     i;
                    8391   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8392   ; OS_CPU_SR  cpu_sr = 0u;
                    8393   ; #endif
                    8394   ; #ifdef OS_SAFETY_CRITICAL
                    8395   ; if (perr == (INT8U *)0) {
                    8396   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8397   ; return ((OS_MEM *)0);
                    8398   ; }
                    8399   ; #endif
                    8400   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8401   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8402   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8403   ; return ((OS_MEM *)0);
                    8404   ; }
                    8405   ; #endif
                    8406   ; #if OS_ARG_CHK_EN > 0u
                    8407   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    8408   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8409   ; return ((OS_MEM *)0);
                    8410   ; }
                    8411   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    8412   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8413   ; return ((OS_MEM *)0);
                    8414   ; }
                    8415   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    8416   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    8417   ; return ((OS_MEM *)0);
                    8418   ; }
                    8419   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    8420   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    8421   ; return ((OS_MEM *)0);
                    8422   ; }
                    8423   ; #endif
                    8424   ; OS_ENTER_CRITICAL();
00002DE4  40E7      8425          dc.w      16615
00002DE6  007C      8426          dc.w      124
00002DE8  0700      8427          dc.w      1792
                    8428   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
00002DEA  2412      8429          move.l    (A2),D2
                    8430   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
00002DEC  2012      8431          move.l    (A2),D0
00002DEE  6706      8432          beq.s     OSMemCreate_1
                    8433   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
00002DF0  2052      8434          move.l    (A2),A0
00002DF2  24A8 0004 8435          move.l    4(A0),(A2)
                    8436   OSMemCreate_1:
                    8437   ; }
                    8438   ; OS_EXIT_CRITICAL();
00002DF6  46DF      8439          dc.w      18143
                    8440   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
00002DF8  4A82      8441          tst.l     D2
00002DFA  660E      8442          bne.s     OSMemCreate_3
                    8443   ; *perr = OS_ERR_MEM_INVALID_PART;
00002DFC  206E 0014 8444          move.l    20(A6),A0
00002E00  10BC 005A 8445          move.b    #90,(A0)
                    8446   ; return ((OS_MEM *)0);
00002E04  4280      8447          clr.l     D0
00002E06  6000 0050 8448          bra       OSMemCreate_5
                    8449   OSMemCreate_3:
                    8450   ; }
                    8451   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
00002E0A  2A04      8452          move.l    D4,D5
                    8453   ; pblk  = (INT8U *)addr;
00002E0C  2604      8454          move.l    D4,D3
                    8455   ; loops  = nblks - 1u;
00002E0E  2007      8456          move.l    D7,D0
00002E10  5380      8457          subq.l    #1,D0
00002E12  2D40 FFFC 8458          move.l    D0,-4(A6)
                    8459   ; for (i = 0u; i < loops; i++) {
00002E16  4286      8460          clr.l     D6
                    8461   OSMemCreate_6:
00002E18  BCAE FFFC 8462          cmp.l     -4(A6),D6
00002E1C  6410      8463          bhs.s     OSMemCreate_8
                    8464   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
00002E1E  202E 0010 8465          move.l    16(A6),D0
00002E22  D680      8466          add.l     D0,D3
                    8467   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
00002E24  2045      8468          move.l    D5,A0
00002E26  2083      8469          move.l    D3,(A0)
                    8470   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
00002E28  2A03      8471          move.l    D3,D5
00002E2A  5286      8472          addq.l    #1,D6
00002E2C  60EA      8473          bra       OSMemCreate_6
                    8474   OSMemCreate_8:
                    8475   ; }
                    8476   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
00002E2E  2045      8477          move.l    D5,A0
00002E30  4290      8478          clr.l     (A0)
                    8479   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
00002E32  2042      8480          move.l    D2,A0
00002E34  2084      8481          move.l    D4,(A0)
                    8482   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
00002E36  2042      8483          move.l    D2,A0
00002E38  2144 0004 8484          move.l    D4,4(A0)
                    8485   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
00002E3C  2042      8486          move.l    D2,A0
00002E3E  2147 0010 8487          move.l    D7,16(A0)
                    8488   ; pmem->OSMemNBlks    = nblks;
00002E42  2042      8489          move.l    D2,A0
00002E44  2147 000C 8490          move.l    D7,12(A0)
                    8491   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
00002E48  2042      8492          move.l    D2,A0
00002E4A  216E 0010 8493          move.l    16(A6),8(A0)
00002E4E  0008      
                    8494   ; *perr               = OS_ERR_NONE;
00002E50  206E 0014 8495          move.l    20(A6),A0
00002E54  4210      8496          clr.b     (A0)
                    8497   ; return (pmem);
00002E56  2002      8498          move.l    D2,D0
                    8499   OSMemCreate_5:
00002E58  4CDF 04FC 8500          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002E5C  4E5E      8501          unlk      A6
00002E5E  4E75      8502          rts
                    8503   ; }
                    8504   ; /*$PAGE*/
                    8505   ; /*
                    8506   ; *********************************************************************************************************
                    8507   ; *                                         GET A MEMORY BLOCK
                    8508   ; *
                    8509   ; * Description : Get a memory block from a partition
                    8510   ; *
                    8511   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8512   ; *
                    8513   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    8514   ; *                       function to either:
                    8515   ; *
                    8516   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    8517   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    8518   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    8519   ; *
                    8520   ; * Returns     : A pointer to a memory block if no error is detected
                    8521   ; *               A pointer to NULL if an error is detected
                    8522   ; *********************************************************************************************************
                    8523   ; */
                    8524   ; void  *OSMemGet (OS_MEM  *pmem,
                    8525   ; INT8U   *perr)
                    8526   ; {
                    8527   _OSMemGet:
00002E60  4E56 0000 8528          link      A6,#0
00002E64  48E7 3000 8529          movem.l   D2/D3,-(A7)
00002E68  242E 0008 8530          move.l    8(A6),D2
                    8531   ; void      *pblk;
                    8532   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8533   ; OS_CPU_SR  cpu_sr = 0u;
                    8534   ; #endif
                    8535   ; #ifdef OS_SAFETY_CRITICAL
                    8536   ; if (perr == (INT8U *)0) {
                    8537   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8538   ; return ((void *)0);
                    8539   ; }
                    8540   ; #endif
                    8541   ; #if OS_ARG_CHK_EN > 0u
                    8542   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    8543   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8544   ; return ((void *)0);
                    8545   ; }
                    8546   ; #endif
                    8547   ; OS_ENTER_CRITICAL();
00002E6C  40E7      8548          dc.w      16615
00002E6E  007C      8549          dc.w      124
00002E70  0700      8550          dc.w      1792
                    8551   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002E72  2042      8552          move.l    D2,A0
00002E74  2028 0010 8553          move.l    16(A0),D0
00002E78  0C80 0000 8554          cmp.l     #0,D0
00002E7C  0000      
00002E7E  6326      8555          bls.s     OSMemGet_1
                    8556   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002E80  2042      8557          move.l    D2,A0
00002E82  2628 0004 8558          move.l    4(A0),D3
                    8559   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
00002E86  2043      8560          move.l    D3,A0
00002E88  2242      8561          move.l    D2,A1
00002E8A  2350 0004 8562          move.l    (A0),4(A1)
                    8563   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002E8E  2002      8564          move.l    D2,D0
00002E90  0680 0000 8565          add.l     #16,D0
00002E94  0010      
00002E96  2040      8566          move.l    D0,A0
00002E98  5390      8567          subq.l    #1,(A0)
                    8568   ; OS_EXIT_CRITICAL();
00002E9A  46DF      8569          dc.w      18143
                    8570   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002E9C  206E 000C 8571          move.l    12(A6),A0
00002EA0  4210      8572          clr.b     (A0)
                    8573   ; return (pblk);                                /*      Return memory block to caller            */
00002EA2  2003      8574          move.l    D3,D0
00002EA4  600C      8575          bra.s     OSMemGet_3
                    8576   OSMemGet_1:
                    8577   ; }
                    8578   ; OS_EXIT_CRITICAL();
00002EA6  46DF      8579          dc.w      18143
                    8580   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
00002EA8  206E 000C 8581          move.l    12(A6),A0
00002EAC  10BC 005D 8582          move.b    #93,(A0)
                    8583   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002EB0  4280      8584          clr.l     D0
                    8585   OSMemGet_3:
00002EB2  4CDF 000C 8586          movem.l   (A7)+,D2/D3
00002EB6  4E5E      8587          unlk      A6
00002EB8  4E75      8588          rts
                    8589   ; }
                    8590   ; /*$PAGE*/
                    8591   ; /*
                    8592   ; *********************************************************************************************************
                    8593   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    8594   ; *
                    8595   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    8596   ; *
                    8597   ; * Arguments  : pmem      is a pointer to the memory partition
                    8598   ; *
                    8599   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    8600   ; *
                    8601   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8602   ; *
                    8603   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8604   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8605   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8606   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    8607   ; *
                    8608   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    8609   ; *********************************************************************************************************
                    8610   ; */
                    8611   ; #if OS_MEM_NAME_EN > 0u
                    8612   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    8613   ; INT8U   **pname,
                    8614   ; INT8U    *perr)
                    8615   ; {
                    8616   _OSMemNameGet:
00002EBA  4E56 FFFC 8617          link      A6,#-4
                    8618   ; INT8U      len;
                    8619   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8620   ; OS_CPU_SR  cpu_sr = 0u;
                    8621   ; #endif
                    8622   ; #ifdef OS_SAFETY_CRITICAL
                    8623   ; if (perr == (INT8U *)0) {
                    8624   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8625   ; return (0u);
                    8626   ; }
                    8627   ; #endif
                    8628   ; #if OS_ARG_CHK_EN > 0u
                    8629   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8630   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8631   ; return (0u);
                    8632   ; }
                    8633   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    8634   ; *perr = OS_ERR_PNAME_NULL;
                    8635   ; return (0u);
                    8636   ; }
                    8637   ; #endif
                    8638   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002EBE  1039 0800 8639          move.b    _OSIntNesting.L,D0
00002EC2  0F06      
00002EC4  0C00 0000 8640          cmp.b     #0,D0
00002EC8  630C      8641          bls.s     OSMemNameGet_1
                    8642   ; *perr = OS_ERR_NAME_GET_ISR;
00002ECA  206E 0010 8643          move.l    16(A6),A0
00002ECE  10BC 0011 8644          move.b    #17,(A0)
                    8645   ; return (0u);
00002ED2  4200      8646          clr.b     D0
00002ED4  602E      8647          bra.s     OSMemNameGet_3
                    8648   OSMemNameGet_1:
                    8649   ; }
                    8650   ; OS_ENTER_CRITICAL();
00002ED6  40E7      8651          dc.w      16615
00002ED8  007C      8652          dc.w      124
00002EDA  0700      8653          dc.w      1792
                    8654   ; *pname = pmem->OSMemName;
00002EDC  206E 0008 8655          move.l    8(A6),A0
00002EE0  226E 000C 8656          move.l    12(A6),A1
00002EE4  22A8 0014 8657          move.l    20(A0),(A1)
                    8658   ; len    = OS_StrLen(*pname);
00002EE8  206E 000C 8659          move.l    12(A6),A0
00002EEC  2F10      8660          move.l    (A0),-(A7)
00002EEE  4EB8 1ACC 8661          jsr       _OS_StrLen
00002EF2  584F      8662          addq.w    #4,A7
00002EF4  1D40 FFFF 8663          move.b    D0,-1(A6)
                    8664   ; OS_EXIT_CRITICAL();
00002EF8  46DF      8665          dc.w      18143
                    8666   ; *perr  = OS_ERR_NONE;
00002EFA  206E 0010 8667          move.l    16(A6),A0
00002EFE  4210      8668          clr.b     (A0)
                    8669   ; return (len);
00002F00  102E FFFF 8670          move.b    -1(A6),D0
                    8671   OSMemNameGet_3:
00002F04  4E5E      8672          unlk      A6
00002F06  4E75      8673          rts
                    8674   ; }
                    8675   ; #endif
                    8676   ; /*$PAGE*/
                    8677   ; /*
                    8678   ; *********************************************************************************************************
                    8679   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8680   ; *
                    8681   ; * Description: This function assigns a name to a memory partition.
                    8682   ; *
                    8683   ; * Arguments  : pmem      is a pointer to the memory partition
                    8684   ; *
                    8685   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8686   ; *
                    8687   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8688   ; *
                    8689   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8690   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8691   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8692   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8693   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8694   ; *
                    8695   ; * Returns    : None
                    8696   ; *********************************************************************************************************
                    8697   ; */
                    8698   ; #if OS_MEM_NAME_EN > 0u
                    8699   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8700   ; INT8U   *pname,
                    8701   ; INT8U   *perr)
                    8702   ; {
                    8703   _OSMemNameSet:
00002F08  4E56 0000 8704          link      A6,#0
                    8705   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8706   ; OS_CPU_SR  cpu_sr = 0u;
                    8707   ; #endif
                    8708   ; #ifdef OS_SAFETY_CRITICAL
                    8709   ; if (perr == (INT8U *)0) {
                    8710   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8711   ; return;
                    8712   ; }
                    8713   ; #endif
                    8714   ; #if OS_ARG_CHK_EN > 0u
                    8715   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8716   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8717   ; return;
                    8718   ; }
                    8719   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8720   ; *perr = OS_ERR_PNAME_NULL;
                    8721   ; return;
                    8722   ; }
                    8723   ; #endif
                    8724   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002F0C  1039 0800 8725          move.b    _OSIntNesting.L,D0
00002F10  0F06      
00002F12  0C00 0000 8726          cmp.b     #0,D0
00002F16  630A      8727          bls.s     OSMemNameSet_1
                    8728   ; *perr = OS_ERR_NAME_SET_ISR;
00002F18  206E 0010 8729          move.l    16(A6),A0
00002F1C  10BC 0012 8730          move.b    #18,(A0)
                    8731   ; return;
00002F20  6018      8732          bra.s     OSMemNameSet_3
                    8733   OSMemNameSet_1:
                    8734   ; }
                    8735   ; OS_ENTER_CRITICAL();
00002F22  40E7      8736          dc.w      16615
00002F24  007C      8737          dc.w      124
00002F26  0700      8738          dc.w      1792
                    8739   ; pmem->OSMemName = pname;
00002F28  206E 0008 8740          move.l    8(A6),A0
00002F2C  216E 000C 8741          move.l    12(A6),20(A0)
00002F30  0014      
                    8742   ; OS_EXIT_CRITICAL();
00002F32  46DF      8743          dc.w      18143
                    8744   ; *perr           = OS_ERR_NONE;
00002F34  206E 0010 8745          move.l    16(A6),A0
00002F38  4210      8746          clr.b     (A0)
                    8747   OSMemNameSet_3:
00002F3A  4E5E      8748          unlk      A6
00002F3C  4E75      8749          rts
                    8750   ; }
                    8751   ; #endif
                    8752   ; /*$PAGE*/
                    8753   ; /*
                    8754   ; *********************************************************************************************************
                    8755   ; *                                       RELEASE A MEMORY BLOCK
                    8756   ; *
                    8757   ; * Description : Returns a memory block to a partition
                    8758   ; *
                    8759   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8760   ; *
                    8761   ; *               pblk    is a pointer to the memory block being released.
                    8762   ; *
                    8763   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8764   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8765   ; *                                        partition (You freed more blocks than you allocated!)
                    8766   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8767   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8768   ; *********************************************************************************************************
                    8769   ; */
                    8770   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8771   ; void    *pblk)
                    8772   ; {
                    8773   _OSMemPut:
00002F3E  4E56 0000 8774          link      A6,#0
00002F42  2F02      8775          move.l    D2,-(A7)
00002F44  242E 0008 8776          move.l    8(A6),D2
                    8777   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8778   ; OS_CPU_SR  cpu_sr = 0u;
                    8779   ; #endif
                    8780   ; #if OS_ARG_CHK_EN > 0u
                    8781   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8782   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8783   ; }
                    8784   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8785   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8786   ; }
                    8787   ; #endif
                    8788   ; OS_ENTER_CRITICAL();
00002F48  40E7      8789          dc.w      16615
00002F4A  007C      8790          dc.w      124
00002F4C  0700      8791          dc.w      1792
                    8792   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002F4E  2042      8793          move.l    D2,A0
00002F50  2242      8794          move.l    D2,A1
00002F52  2028 0010 8795          move.l    16(A0),D0
00002F56  B0A9 000C 8796          cmp.l     12(A1),D0
00002F5A  6506      8797          blo.s     OSMemPut_1
                    8798   ; OS_EXIT_CRITICAL();
00002F5C  46DF      8799          dc.w      18143
                    8800   ; return (OS_ERR_MEM_FULL);
00002F5E  705E      8801          moveq     #94,D0
00002F60  6024      8802          bra.s     OSMemPut_3
                    8803   OSMemPut_1:
                    8804   ; }
                    8805   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002F62  2042      8806          move.l    D2,A0
00002F64  202E 000C 8807          move.l    12(A6),D0
00002F68  2240      8808          move.l    D0,A1
00002F6A  22A8 0004 8809          move.l    4(A0),(A1)
                    8810   ; pmem->OSMemFreeList = pblk;
00002F6E  2042      8811          move.l    D2,A0
00002F70  216E 000C 8812          move.l    12(A6),4(A0)
00002F74  0004      
                    8813   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
00002F76  2002      8814          move.l    D2,D0
00002F78  0680 0000 8815          add.l     #16,D0
00002F7C  0010      
00002F7E  2040      8816          move.l    D0,A0
00002F80  5290      8817          addq.l    #1,(A0)
                    8818   ; OS_EXIT_CRITICAL();
00002F82  46DF      8819          dc.w      18143
                    8820   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
00002F84  4200      8821          clr.b     D0
                    8822   OSMemPut_3:
00002F86  241F      8823          move.l    (A7)+,D2
00002F88  4E5E      8824          unlk      A6
00002F8A  4E75      8825          rts
                    8826   ; }
                    8827   ; /*$PAGE*/
                    8828   ; /*
                    8829   ; *********************************************************************************************************
                    8830   ; *                                       QUERY MEMORY PARTITION
                    8831   ; *
                    8832   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8833   ; *               used memory blocks from a memory partition.
                    8834   ; *
                    8835   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8836   ; *
                    8837   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8838   ; *                           partition.
                    8839   ; *
                    8840   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8841   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8842   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8843   ; *********************************************************************************************************
                    8844   ; */
                    8845   ; #if OS_MEM_QUERY_EN > 0u
                    8846   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8847   ; OS_MEM_DATA  *p_mem_data)
                    8848   ; {
                    8849   _OSMemQuery:
00002F8C  4E56 0000 8850          link      A6,#0
00002F90  48E7 3000 8851          movem.l   D2/D3,-(A7)
00002F94  242E 000C 8852          move.l    12(A6),D2
00002F98  262E 0008 8853          move.l    8(A6),D3
                    8854   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8855   ; OS_CPU_SR  cpu_sr = 0u;
                    8856   ; #endif
                    8857   ; #if OS_ARG_CHK_EN > 0u
                    8858   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8859   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8860   ; }
                    8861   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8862   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8863   ; }
                    8864   ; #endif
                    8865   ; OS_ENTER_CRITICAL();
00002F9C  40E7      8866          dc.w      16615
00002F9E  007C      8867          dc.w      124
00002FA0  0700      8868          dc.w      1792
                    8869   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002FA2  2043      8870          move.l    D3,A0
00002FA4  2242      8871          move.l    D2,A1
00002FA6  2290      8872          move.l    (A0),(A1)
                    8873   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
00002FA8  2043      8874          move.l    D3,A0
00002FAA  2242      8875          move.l    D2,A1
00002FAC  2368 0004 8876          move.l    4(A0),4(A1)
00002FB0  0004      
                    8877   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002FB2  2043      8878          move.l    D3,A0
00002FB4  2242      8879          move.l    D2,A1
00002FB6  2368 0008 8880          move.l    8(A0),8(A1)
00002FBA  0008      
                    8881   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002FBC  2043      8882          move.l    D3,A0
00002FBE  2242      8883          move.l    D2,A1
00002FC0  2368 000C 8884          move.l    12(A0),12(A1)
00002FC4  000C      
                    8885   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
00002FC6  2043      8886          move.l    D3,A0
00002FC8  2242      8887          move.l    D2,A1
00002FCA  2368 0010 8888          move.l    16(A0),16(A1)
00002FCE  0010      
                    8889   ; OS_EXIT_CRITICAL();
00002FD0  46DF      8890          dc.w      18143
                    8891   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
00002FD2  2042      8892          move.l    D2,A0
00002FD4  2028 000C 8893          move.l    12(A0),D0
00002FD8  2042      8894          move.l    D2,A0
00002FDA  90A8 0010 8895          sub.l     16(A0),D0
00002FDE  2042      8896          move.l    D2,A0
00002FE0  2140 0014 8897          move.l    D0,20(A0)
                    8898   ; return (OS_ERR_NONE);
00002FE4  4200      8899          clr.b     D0
00002FE6  4CDF 000C 8900          movem.l   (A7)+,D2/D3
00002FEA  4E5E      8901          unlk      A6
00002FEC  4E75      8902          rts
                    8903   ; }
                    8904   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8905   ; /*$PAGE*/
                    8906   ; /*
                    8907   ; *********************************************************************************************************
                    8908   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8909   ; *
                    8910   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8911   ; *               application MUST NOT call this function.
                    8912   ; *
                    8913   ; * Arguments   : none
                    8914   ; *
                    8915   ; * Returns     : none
                    8916   ; *
                    8917   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8918   ; *********************************************************************************************************
                    8919   ; */
                    8920   ; void  OS_MemInit (void)
                    8921   ; {
                    8922   _OS_MemInit:
00002FEE  48E7 3020 8923          movem.l   D2/D3/A2,-(A7)
00002FF2  45F9 0800 8924          lea       _OSMemTbl.L,A2
00002FF6  1898      
                    8925   ; #if OS_MAX_MEM_PART == 1u
                    8926   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8927   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8928   ; #if OS_MEM_NAME_EN > 0u
                    8929   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8930   ; #endif
                    8931   ; #endif
                    8932   ; #if OS_MAX_MEM_PART >= 2u
                    8933   ; OS_MEM  *pmem;
                    8934   ; INT16U   i;
                    8935   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
00002FF8  4878 0078 8936          pea       120
00002FFC  2F0A      8937          move.l    A2,-(A7)
00002FFE  4EB8 19D6 8938          jsr       _OS_MemClr
00003002  504F      8939          addq.w    #8,A7
                    8940   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00003004  4243      8941          clr.w     D3
                    8942   OS_MemInit_1:
00003006  0C43 0004 8943          cmp.w     #4,D3
0000300A  6400 003C 8944          bhs       OS_MemInit_3
                    8945   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
0000300E  200A      8946          move.l    A2,D0
00003010  C6BC 0000 8947          and.l     #65535,D3
00003014  FFFF      
00003016  2203      8948          move.l    D3,D1
00003018  C3FC 0018 8949          muls      #24,D1
0000301C  D081      8950          add.l     D1,D0
0000301E  2400      8951          move.l    D0,D2
                    8952   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
00003020  200A      8953          move.l    A2,D0
00003022  C6BC 0000 8954          and.l     #65535,D3
00003026  FFFF      
00003028  2203      8955          move.l    D3,D1
0000302A  5281      8956          addq.l    #1,D1
0000302C  C3FC 0018 8957          muls      #24,D1
00003030  D081      8958          add.l     D1,D0
00003032  2042      8959          move.l    D2,A0
00003034  2140 0004 8960          move.l    D0,4(A0)
                    8961   ; #if OS_MEM_NAME_EN > 0u
                    8962   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00003038  41F9 0000 8963          lea       @ucos_ii_1.L,A0
0000303C  6AD0      
0000303E  2242      8964          move.l    D2,A1
00003040  2348 0014 8965          move.l    A0,20(A1)
00003044  5243      8966          addq.w    #1,D3
00003046  60BE      8967          bra       OS_MemInit_1
                    8968   OS_MemInit_3:
                    8969   ; #endif
                    8970   ; }
                    8971   ; pmem                = &OSMemTbl[i];
00003048  200A      8972          move.l    A2,D0
0000304A  C6BC 0000 8973          and.l     #65535,D3
0000304E  FFFF      
00003050  2203      8974          move.l    D3,D1
00003052  C3FC 0018 8975          muls      #24,D1
00003056  D081      8976          add.l     D1,D0
00003058  2400      8977          move.l    D0,D2
                    8978   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
0000305A  2042      8979          move.l    D2,A0
0000305C  42A8 0004 8980          clr.l     4(A0)
                    8981   ; #if OS_MEM_NAME_EN > 0u
                    8982   ; pmem->OSMemName = (INT8U *)(void *)"?";
00003060  41F9 0000 8983          lea       @ucos_ii_1.L,A0
00003064  6AD0      
00003066  2242      8984          move.l    D2,A1
00003068  2348 0014 8985          move.l    A0,20(A1)
                    8986   ; #endif
                    8987   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
0000306C  23CA 0800 8988          move.l    A2,_OSMemFreeList.L
00003070  1894      
00003072  4CDF 040C 8989          movem.l   (A7)+,D2/D3/A2
00003076  4E75      8990          rts
                    8991   ; /*
                    8992   ; *********************************************************************************************************
                    8993   ; *                                                uC/OS-II
                    8994   ; *                                          The Real-Time Kernel
                    8995   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8996   ; *
                    8997   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8998   ; *                                           All Rights Reserved
                    8999   ; *
                    9000   ; * File    : OS_MUTEX.C
                    9001   ; * By      : Jean J. Labrosse
                    9002   ; * Version : V2.92.07
                    9003   ; *
                    9004   ; * LICENSING TERMS:
                    9005   ; * ---------------
                    9006   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    9007   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    9008   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    9009   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    9010   ; * licensing fee.
                    9011   ; *********************************************************************************************************
                    9012   ; */
                    9013   ; #define  MICRIUM_SOURCE
                    9014   ; #ifndef  OS_MASTER_FILE
                    9015   ; #include <ucos_ii.h>
                    9016   ; #endif
                    9017   ; #if OS_MUTEX_EN > 0u
                    9018   ; /*
                    9019   ; *********************************************************************************************************
                    9020   ; *                                           LOCAL CONSTANTS
                    9021   ; *********************************************************************************************************
                    9022   ; */
                    9023   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    9024   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    9025   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    9026   ; /*
                    9027   ; *********************************************************************************************************
                    9028   ; *                                           LOCAL CONSTANTS
                    9029   ; *********************************************************************************************************
                    9030   ; */
                    9031   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    9032   ; /*$PAGE*/
                    9033   ; /*
                    9034   ; *********************************************************************************************************
                    9035   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    9036   ; *
                    9037   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    9038   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    9039   ; *              not available or the event did not occur.
                    9040   ; *
                    9041   ; * Arguments  : pevent     is a pointer to the event control block
                    9042   ; *
                    9043   ; *              perr       is a pointer to an error code which will be returned to your application:
                    9044   ; *                            OS_ERR_NONE         if the call was successful.
                    9045   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    9046   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    9047   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    9048   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    9049   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    9050   ; *                                                indicates that you did not set the PCP higher (lower
                    9051   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    9052   ; *                                                Unfortunately, this is something that could not be
                    9053   ; *                                                detected when the Mutex is created because we don't know
                    9054   ; *                                                what tasks will be using the Mutex.
                    9055   ; *
                    9056   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    9057   ; *              == OS_FALSE   a) if the resource is not available
                    9058   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    9059   ; *                            c) you called this function from an ISR
                    9060   ; *
                    9061   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    9062   ; *              intended to be used by tasks only.
                    9063   ; *********************************************************************************************************
                    9064   ; */
                    9065   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    9066   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    9067   ; INT8U     *perr)
                    9068   ; {
                    9069   _OSMutexAccept:
00003078  4E56 0000 9070          link      A6,#0
0000307C  48E7 3820 9071          movem.l   D2/D3/D4/A2,-(A7)
00003080  242E 0008 9072          move.l    8(A6),D2
00003084  262E 000C 9073          move.l    12(A6),D3
00003088  45F9 0800 9074          lea       _OSTCBCur.L,A2
0000308C  1020      
                    9075   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    9076   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    9077   ; OS_CPU_SR  cpu_sr = 0u;
                    9078   ; #endif
                    9079   ; #ifdef OS_SAFETY_CRITICAL
                    9080   ; if (perr == (INT8U *)0) {
                    9081   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9082   ; return (OS_FALSE);
                    9083   ; }
                    9084   ; #endif
                    9085   ; #if OS_ARG_CHK_EN > 0u
                    9086   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    9087   ; *perr = OS_ERR_PEVENT_NULL;
                    9088   ; return (OS_FALSE);
                    9089   ; }
                    9090   ; #endif
                    9091   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
0000308E  2042      9092          move.l    D2,A0
00003090  1010      9093          move.b    (A0),D0
00003092  0C00 0004 9094          cmp.b     #4,D0
00003096  670C      9095          beq.s     OSMutexAccept_1
                    9096   ; *perr = OS_ERR_EVENT_TYPE;
00003098  2043      9097          move.l    D3,A0
0000309A  10BC 0001 9098          move.b    #1,(A0)
                    9099   ; return (OS_FALSE);
0000309E  4200      9100          clr.b     D0
000030A0  6000 0084 9101          bra       OSMutexAccept_3
                    9102   OSMutexAccept_1:
                    9103   ; }
                    9104   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
000030A4  1039 0800 9105          move.b    _OSIntNesting.L,D0
000030A8  0F06      
000030AA  0C00 0000 9106          cmp.b     #0,D0
000030AE  630C      9107          bls.s     OSMutexAccept_4
                    9108   ; *perr = OS_ERR_PEND_ISR;
000030B0  2043      9109          move.l    D3,A0
000030B2  10BC 0002 9110          move.b    #2,(A0)
                    9111   ; return (OS_FALSE);
000030B6  4200      9112          clr.b     D0
000030B8  6000 006C 9113          bra       OSMutexAccept_3
                    9114   OSMutexAccept_4:
                    9115   ; }
                    9116   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
000030BC  40E7      9117          dc.w      16615
000030BE  007C      9118          dc.w      124
000030C0  0700      9119          dc.w      1792
                    9120   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
000030C2  2042      9121          move.l    D2,A0
000030C4  3028 0006 9122          move.w    6(A0),D0
000030C8  E048      9123          lsr.w     #8,D0
000030CA  1800      9124          move.b    D0,D4
                    9125   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
000030CC  2042      9126          move.l    D2,A0
000030CE  3028 0006 9127          move.w    6(A0),D0
000030D2  C07C 00FF 9128          and.w     #255,D0
000030D6  0C40 00FF 9129          cmp.w     #255,D0
000030DA  6600 0042 9130          bne       OSMutexAccept_6
                    9131   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
000030DE  2042      9132          move.l    D2,A0
000030E0  0268 FF00 9133          and.w     #65280,6(A0)
000030E4  0006      
                    9134   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
000030E6  2042      9135          move.l    D2,A0
000030E8  2252      9136          move.l    (A2),A1
000030EA  1029 0034 9137          move.b    52(A1),D0
000030EE  C07C 00FF 9138          and.w     #255,D0
000030F2  8168 0006 9139          or.w      D0,6(A0)
                    9140   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
000030F6  2042      9141          move.l    D2,A0
000030F8  2152 0002 9142          move.l    (A2),2(A0)
                    9143   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
000030FC  0C04 00FF 9144          cmp.b     #255,D4
00003100  6712      9145          beq.s     OSMutexAccept_8
00003102  2052      9146          move.l    (A2),A0
00003104  B828 0034 9147          cmp.b     52(A0),D4
00003108  650A      9148          blo.s     OSMutexAccept_8
                    9149   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    9150   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
0000310A  46DF      9151          dc.w      18143
                    9152   ; *perr = OS_ERR_PCP_LOWER;
0000310C  2043      9153          move.l    D3,A0
0000310E  10BC 0078 9154          move.b    #120,(A0)
00003112  6006      9155          bra.s     OSMutexAccept_9
                    9156   OSMutexAccept_8:
                    9157   ; } else {
                    9158   ; OS_EXIT_CRITICAL();
00003114  46DF      9159          dc.w      18143
                    9160   ; *perr = OS_ERR_NONE;
00003116  2043      9161          move.l    D3,A0
00003118  4210      9162          clr.b     (A0)
                    9163   OSMutexAccept_9:
                    9164   ; }
                    9165   ; return (OS_TRUE);
0000311A  7001      9166          moveq     #1,D0
0000311C  6008      9167          bra.s     OSMutexAccept_3
                    9168   OSMutexAccept_6:
                    9169   ; }
                    9170   ; OS_EXIT_CRITICAL();
0000311E  46DF      9171          dc.w      18143
                    9172   ; *perr = OS_ERR_NONE;
00003120  2043      9173          move.l    D3,A0
00003122  4210      9174          clr.b     (A0)
                    9175   ; return (OS_FALSE);
00003124  4200      9176          clr.b     D0
                    9177   OSMutexAccept_3:
00003126  4CDF 041C 9178          movem.l   (A7)+,D2/D3/D4/A2
0000312A  4E5E      9179          unlk      A6
0000312C  4E75      9180          rts
                    9181   ; }
                    9182   ; #endif
                    9183   ; /*$PAGE*/
                    9184   ; /*
                    9185   ; *********************************************************************************************************
                    9186   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    9187   ; *
                    9188   ; * Description: This function creates a mutual exclusion semaphore.
                    9189   ; *
                    9190   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    9191   ; *                            other words, when the semaphore is acquired and a higher priority task
                    9192   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    9193   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    9194   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    9195   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    9196   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    9197   ; *                            semaphore do not have their priority promoted.
                    9198   ; *
                    9199   ; *              perr          is a pointer to an error code which will be returned to your application:
                    9200   ; *                               OS_ERR_NONE         if the call was successful.
                    9201   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    9202   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    9203   ; *                                                   already exist.
                    9204   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    9205   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    9206   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    9207   ; *
                    9208   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    9209   ; *                            created mutex.
                    9210   ; *              == (void *)0  if an error is detected.
                    9211   ; *
                    9212   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    9213   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    9214   ; *
                    9215   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    9216   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    9217   ; *                 promotion is disabled.
                    9218   ; *********************************************************************************************************
                    9219   ; */
                    9220   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    9221   ; INT8U  *perr)
                    9222   ; {
                    9223   _OSMutexCreate:
0000312E  4E56 0000 9224          link      A6,#0
00003132  48E7 3830 9225          movem.l   D2/D3/D4/A2/A3,-(A7)
00003136  162E 000B 9226          move.b    11(A6),D3
0000313A  C6BC 0000 9227          and.l     #255,D3
0000313E  00FF      
00003140  282E 000C 9228          move.l    12(A6),D4
00003144  45F9 0800 9229          lea       _OSEventFreeList.L,A2
00003148  0CDA      
0000314A  47F9 0800 9230          lea       _OSTCBPrioTbl.L,A3
0000314E  1030      
                    9231   ; OS_EVENT  *pevent;
                    9232   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9233   ; OS_CPU_SR  cpu_sr = 0u;
                    9234   ; #endif
                    9235   ; #ifdef OS_SAFETY_CRITICAL
                    9236   ; if (perr == (INT8U *)0) {
                    9237   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9238   ; return ((OS_EVENT *)0);
                    9239   ; }
                    9240   ; #endif
                    9241   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    9242   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    9243   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9244   ; return ((OS_EVENT *)0);
                    9245   ; }
                    9246   ; #endif
                    9247   ; #if OS_ARG_CHK_EN > 0u
                    9248   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    9249   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    9250   ; *perr = OS_ERR_PRIO_INVALID;
                    9251   ; return ((OS_EVENT *)0);
                    9252   ; }
                    9253   ; }
                    9254   ; #endif
                    9255   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003150  1039 0800 9256          move.b    _OSIntNesting.L,D0
00003154  0F06      
00003156  0C00 0000 9257          cmp.b     #0,D0
0000315A  630C      9258          bls.s     OSMutexCreate_1
                    9259   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
0000315C  2044      9260          move.l    D4,A0
0000315E  10BC 0010 9261          move.b    #16,(A0)
                    9262   ; return ((OS_EVENT *)0);
00003162  4280      9263          clr.l     D0
00003164  6000 00A6 9264          bra       OSMutexCreate_3
                    9265   OSMutexCreate_1:
                    9266   ; }
                    9267   ; OS_ENTER_CRITICAL();
00003168  40E7      9268          dc.w      16615
0000316A  007C      9269          dc.w      124
0000316C  0700      9270          dc.w      1792
                    9271   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
0000316E  0C03 00FF 9272          cmp.b     #255,D3
00003172  6730      9273          beq.s     OSMutexCreate_4
                    9274   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00003174  C6BC 0000 9275          and.l     #255,D3
00003178  00FF      
0000317A  2003      9276          move.l    D3,D0
0000317C  E588      9277          lsl.l     #2,D0
0000317E  2033 0800 9278          move.l    0(A3,D0.L),D0
00003182  670E      9279          beq.s     OSMutexCreate_6
                    9280   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00003184  46DF      9281          dc.w      18143
                    9282   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00003186  2044      9283          move.l    D4,A0
00003188  10BC 0028 9284          move.b    #40,(A0)
                    9285   ; return ((OS_EVENT *)0);
0000318C  4280      9286          clr.l     D0
0000318E  6000 007C 9287          bra       OSMutexCreate_3
                    9288   OSMutexCreate_6:
                    9289   ; }
                    9290   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
00003192  C6BC 0000 9291          and.l     #255,D3
00003196  00FF      
00003198  2003      9292          move.l    D3,D0
0000319A  E588      9293          lsl.l     #2,D0
0000319C  27BC 0000 9294          move.l    #1,0(A3,D0.L)
000031A0  0001 0800 
                    9295   OSMutexCreate_4:
                    9296   ; }
                    9297   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
000031A4  2412      9298          move.l    (A2),D2
                    9299   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
000031A6  4A82      9300          tst.l     D2
000031A8  6622      9301          bne.s     OSMutexCreate_8
                    9302   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
000031AA  0C03 00FF 9303          cmp.b     #255,D3
000031AE  670E      9304          beq.s     OSMutexCreate_10
                    9305   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
000031B0  C6BC 0000 9306          and.l     #255,D3
000031B4  00FF      
000031B6  2003      9307          move.l    D3,D0
000031B8  E588      9308          lsl.l     #2,D0
000031BA  42B3 0800 9309          clr.l     0(A3,D0.L)
                    9310   OSMutexCreate_10:
                    9311   ; }
                    9312   ; OS_EXIT_CRITICAL();
000031BE  46DF      9313          dc.w      18143
                    9314   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
000031C0  2044      9315          move.l    D4,A0
000031C2  10BC 0004 9316          move.b    #4,(A0)
                    9317   ; return (pevent);
000031C6  2002      9318          move.l    D2,D0
000031C8  6000 0042 9319          bra       OSMutexCreate_3
                    9320   OSMutexCreate_8:
                    9321   ; }
                    9322   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
000031CC  2052      9323          move.l    (A2),A0
000031CE  24A8 0002 9324          move.l    2(A0),(A2)
                    9325   ; OS_EXIT_CRITICAL();
000031D2  46DF      9326          dc.w      18143
                    9327   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
000031D4  2042      9328          move.l    D2,A0
000031D6  10BC 0004 9329          move.b    #4,(A0)
                    9330   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
000031DA  1003      9331          move.b    D3,D0
000031DC  C07C 00FF 9332          and.w     #255,D0
000031E0  E148      9333          lsl.w     #8,D0
000031E2  807C 00FF 9334          or.w      #255,D0
000031E6  2042      9335          move.l    D2,A0
000031E8  3140 0006 9336          move.w    D0,6(A0)
                    9337   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
000031EC  2042      9338          move.l    D2,A0
000031EE  42A8 0002 9339          clr.l     2(A0)
                    9340   ; #if OS_EVENT_NAME_EN > 0u
                    9341   ; pevent->OSEventName = (INT8U *)(void *)"?";
000031F2  41F9 0000 9342          lea       @ucos_ii_1.L,A0
000031F6  6AD0      
000031F8  2242      9343          move.l    D2,A1
000031FA  2348 0012 9344          move.l    A0,18(A1)
                    9345   ; #endif
                    9346   ; OS_EventWaitListInit(pevent);
000031FE  2F02      9347          move.l    D2,-(A7)
00003200  4EB8 170A 9348          jsr       _OS_EventWaitListInit
00003204  584F      9349          addq.w    #4,A7
                    9350   ; *perr = OS_ERR_NONE;
00003206  2044      9351          move.l    D4,A0
00003208  4210      9352          clr.b     (A0)
                    9353   ; return (pevent);
0000320A  2002      9354          move.l    D2,D0
                    9355   OSMutexCreate_3:
0000320C  4CDF 0C1C 9356          movem.l   (A7)+,D2/D3/D4/A2/A3
00003210  4E5E      9357          unlk      A6
00003212  4E75      9358          rts
                    9359   ; }
                    9360   ; /*$PAGE*/
                    9361   ; /*
                    9362   ; *********************************************************************************************************
                    9363   ; *                                           DELETE A MUTEX
                    9364   ; *
                    9365   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    9366   ; *
                    9367   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    9368   ; *
                    9369   ; *              opt           determines delete options as follows:
                    9370   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    9371   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    9372   ; *                                                    In this case, all the tasks pending will be readied.
                    9373   ; *
                    9374   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    9375   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    9376   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    9377   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    9378   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    9379   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9380   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    9381   ; *
                    9382   ; * Returns    : pevent        upon error
                    9383   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    9384   ; *
                    9385   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    9386   ; *                 the mutex MUST check the return code of OSMutexPend().
                    9387   ; *
                    9388   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    9389   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    9390   ; *
                    9391   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    9392   ; *                 resource(s) will no longer be guarded by the mutex.
                    9393   ; *
                    9394   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    9395   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    9396   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    9397   ; *                            that task will be made ready-to-run at its original priority.
                    9398   ; *********************************************************************************************************
                    9399   ; */
                    9400   ; #if OS_MUTEX_DEL_EN > 0u
                    9401   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    9402   ; INT8U      opt,
                    9403   ; INT8U     *perr)
                    9404   ; {
                    9405   _OSMutexDel:
00003214  4E56 FFFC 9406          link      A6,#-4
00003218  48E7 3F20 9407          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000321C  242E 0008 9408          move.l    8(A6),D2
00003220  282E 0010 9409          move.l    16(A6),D4
00003224  45F9 0800 9410          lea       _OSEventFreeList.L,A2
00003228  0CDA      
                    9411   ; BOOLEAN    tasks_waiting;
                    9412   ; OS_EVENT  *pevent_return;
                    9413   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    9414   ; INT8U      prio;
                    9415   ; OS_TCB    *ptcb;
                    9416   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9417   ; OS_CPU_SR  cpu_sr = 0u;
                    9418   ; #endif
                    9419   ; #ifdef OS_SAFETY_CRITICAL
                    9420   ; if (perr == (INT8U *)0) {
                    9421   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9422   ; return ((OS_EVENT *)0);
                    9423   ; }
                    9424   ; #endif
                    9425   ; #if OS_ARG_CHK_EN > 0u
                    9426   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9427   ; *perr = OS_ERR_PEVENT_NULL;
                    9428   ; return (pevent);
                    9429   ; }
                    9430   ; #endif
                    9431   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
0000322A  2042      9432          move.l    D2,A0
0000322C  1010      9433          move.b    (A0),D0
0000322E  0C00 0004 9434          cmp.b     #4,D0
00003232  670C      9435          beq.s     OSMutexDel_1
                    9436   ; *perr = OS_ERR_EVENT_TYPE;
00003234  2044      9437          move.l    D4,A0
00003236  10BC 0001 9438          move.b    #1,(A0)
                    9439   ; return (pevent);
0000323A  2002      9440          move.l    D2,D0
0000323C  6000 017C 9441          bra       OSMutexDel_3
                    9442   OSMutexDel_1:
                    9443   ; }
                    9444   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003240  1039 0800 9445          move.b    _OSIntNesting.L,D0
00003244  0F06      
00003246  0C00 0000 9446          cmp.b     #0,D0
0000324A  630C      9447          bls.s     OSMutexDel_4
                    9448   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
0000324C  2044      9449          move.l    D4,A0
0000324E  10BC 000F 9450          move.b    #15,(A0)
                    9451   ; return (pevent);
00003252  2002      9452          move.l    D2,D0
00003254  6000 0164 9453          bra       OSMutexDel_3
                    9454   OSMutexDel_4:
                    9455   ; }
                    9456   ; OS_ENTER_CRITICAL();
00003258  40E7      9457          dc.w      16615
0000325A  007C      9458          dc.w      124
0000325C  0700      9459          dc.w      1792
                    9460   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
0000325E  2042      9461          move.l    D2,A0
00003260  1028 0008 9462          move.b    8(A0),D0
00003264  6704      9463          beq.s     OSMutexDel_6
                    9464   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003266  7E01      9465          moveq     #1,D7
00003268  6002      9466          bra.s     OSMutexDel_7
                    9467   OSMutexDel_6:
                    9468   ; } else {
                    9469   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000326A  7E00      9470          moveq     #0,D7
                    9471   OSMutexDel_7:
                    9472   ; }
                    9473   ; switch (opt) {
0000326C  102E 000F 9474          move.b    15(A6),D0
00003270  C0BC 0000 9475          and.l     #255,D0
00003274  00FF      
00003276  0C80 0000 9476          cmp.l     #1,D0
0000327A  0001      
0000327C  6700 006E 9477          beq       OSMutexDel_11
00003280  6200 012C 9478          bhi       OSMutexDel_8
00003284  4A80      9479          tst.l     D0
00003286  6704      9480          beq.s     OSMutexDel_10
00003288  6000 0124 9481          bra       OSMutexDel_8
                    9482   OSMutexDel_10:
                    9483   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    9484   ; if (tasks_waiting == OS_FALSE) {
0000328C  4A07      9485          tst.b     D7
0000328E  6600 004E 9486          bne       OSMutexDel_13
                    9487   ; #if OS_EVENT_NAME_EN > 0u
                    9488   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00003292  41F9 0000 9489          lea       @ucos_ii_1.L,A0
00003296  6AD0      
00003298  2242      9490          move.l    D2,A1
0000329A  2348 0012 9491          move.l    A0,18(A1)
                    9492   ; #endif
                    9493   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
0000329E  2042      9494          move.l    D2,A0
000032A0  3028 0006 9495          move.w    6(A0),D0
000032A4  E048      9496          lsr.w     #8,D0
000032A6  1600      9497          move.b    D0,D3
                    9498   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000032A8  0C03 00FF 9499          cmp.b     #255,D3
000032AC  6714      9500          beq.s     OSMutexDel_15
                    9501   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
000032AE  C6BC 0000 9502          and.l     #255,D3
000032B2  00FF      
000032B4  2003      9503          move.l    D3,D0
000032B6  E588      9504          lsl.l     #2,D0
000032B8  41F9 0800 9505          lea       _OSTCBPrioTbl.L,A0
000032BC  1030      
000032BE  42B0 0800 9506          clr.l     0(A0,D0.L)
                    9507   OSMutexDel_15:
                    9508   ; }
                    9509   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
000032C2  2042      9510          move.l    D2,A0
000032C4  4210      9511          clr.b     (A0)
                    9512   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
000032C6  2042      9513          move.l    D2,A0
000032C8  2152 0002 9514          move.l    (A2),2(A0)
                    9515   ; pevent->OSEventCnt    = 0u;
000032CC  2042      9516          move.l    D2,A0
000032CE  4268 0006 9517          clr.w     6(A0)
                    9518   ; OSEventFreeList       = pevent;
000032D2  2482      9519          move.l    D2,(A2)
                    9520   ; OS_EXIT_CRITICAL();
000032D4  46DF      9521          dc.w      18143
                    9522   ; *perr                 = OS_ERR_NONE;
000032D6  2044      9523          move.l    D4,A0
000032D8  4210      9524          clr.b     (A0)
                    9525   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
000032DA  4285      9526          clr.l     D5
000032DC  600A      9527          bra.s     OSMutexDel_14
                    9528   OSMutexDel_13:
                    9529   ; } else {
                    9530   ; OS_EXIT_CRITICAL();
000032DE  46DF      9531          dc.w      18143
                    9532   ; *perr                 = OS_ERR_TASK_WAITING;
000032E0  2044      9533          move.l    D4,A0
000032E2  10BC 0049 9534          move.b    #73,(A0)
                    9535   ; pevent_return         = pevent;
000032E6  2A02      9536          move.l    D2,D5
                    9537   OSMutexDel_14:
                    9538   ; }
                    9539   ; break;
000032E8  6000 00CE 9540          bra       OSMutexDel_9
                    9541   OSMutexDel_11:
                    9542   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    9543   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
000032EC  2042      9544          move.l    D2,A0
000032EE  3028 0006 9545          move.w    6(A0),D0
000032F2  E048      9546          lsr.w     #8,D0
000032F4  1600      9547          move.b    D0,D3
                    9548   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000032F6  0C03 00FF 9549          cmp.b     #255,D3
000032FA  6700 0038 9550          beq       OSMutexDel_21
                    9551   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
000032FE  2042      9552          move.l    D2,A0
00003300  3028 0006 9553          move.w    6(A0),D0
00003304  C07C 00FF 9554          and.w     #255,D0
00003308  1D40 FFFF 9555          move.b    D0,-1(A6)
                    9556   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
0000330C  2042      9557          move.l    D2,A0
0000330E  2C28 0002 9558          move.l    2(A0),D6
                    9559   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
00003312  4A86      9560          tst.l     D6
00003314  671E      9561          beq.s     OSMutexDel_21
                    9562   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00003316  2046      9563          move.l    D6,A0
00003318  B628 0034 9564          cmp.b     52(A0),D3
0000331C  6616      9565          bne.s     OSMutexDel_21
                    9566   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
0000331E  122E FFFF 9567          move.b    -1(A6),D1
00003322  C2BC 0000 9568          and.l     #255,D1
00003326  00FF      
00003328  2F01      9569          move.l    D1,-(A7)
0000332A  2F06      9570          move.l    D6,-(A7)
0000332C  4EB9 0000 9571          jsr       @ucos_ii_OSMutex_RdyAtPrio
00003330  3870      
00003332  504F      9572          addq.w    #8,A7
                    9573   OSMutexDel_21:
                    9574   ; }
                    9575   ; }
                    9576   ; }
                    9577   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    9578   OSMutexDel_23:
00003334  2042      9579          move.l    D2,A0
00003336  1028 0008 9580          move.b    8(A0),D0
0000333A  671C      9581          beq.s     OSMutexDel_25
                    9582   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
0000333C  4878 0002 9583          pea       2
00003340  4878 0010 9584          pea       16
00003344  42A7      9585          clr.l     -(A7)
00003346  2F02      9586          move.l    D2,-(A7)
00003348  4EB8 1442 9587          jsr       _OS_EventTaskRdy
0000334C  DEFC 0010 9588          add.w     #16,A7
00003350  C0BC 0000 9589          and.l     #255,D0
00003354  00FF      
00003356  60DC      9590          bra       OSMutexDel_23
                    9591   OSMutexDel_25:
                    9592   ; }
                    9593   ; #if OS_EVENT_NAME_EN > 0u
                    9594   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00003358  41F9 0000 9595          lea       @ucos_ii_1.L,A0
0000335C  6AD0      
0000335E  2242      9596          move.l    D2,A1
00003360  2348 0012 9597          move.l    A0,18(A1)
                    9598   ; #endif
                    9599   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00003364  2042      9600          move.l    D2,A0
00003366  3028 0006 9601          move.w    6(A0),D0
0000336A  E048      9602          lsr.w     #8,D0
0000336C  1600      9603          move.b    D0,D3
                    9604   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000336E  0C03 00FF 9605          cmp.b     #255,D3
00003372  6714      9606          beq.s     OSMutexDel_26
                    9607   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
00003374  C6BC 0000 9608          and.l     #255,D3
00003378  00FF      
0000337A  2003      9609          move.l    D3,D0
0000337C  E588      9610          lsl.l     #2,D0
0000337E  41F9 0800 9611          lea       _OSTCBPrioTbl.L,A0
00003382  1030      
00003384  42B0 0800 9612          clr.l     0(A0,D0.L)
                    9613   OSMutexDel_26:
                    9614   ; }
                    9615   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00003388  2042      9616          move.l    D2,A0
0000338A  4210      9617          clr.b     (A0)
                    9618   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
0000338C  2042      9619          move.l    D2,A0
0000338E  2152 0002 9620          move.l    (A2),2(A0)
                    9621   ; pevent->OSEventCnt    = 0u;
00003392  2042      9622          move.l    D2,A0
00003394  4268 0006 9623          clr.w     6(A0)
                    9624   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
00003398  2482      9625          move.l    D2,(A2)
                    9626   ; OS_EXIT_CRITICAL();
0000339A  46DF      9627          dc.w      18143
                    9628   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000339C  0C07 0001 9629          cmp.b     #1,D7
000033A0  6604      9630          bne.s     OSMutexDel_28
                    9631   ; OS_Sched();                               /* Find highest priority task ready to run  */
000033A2  4EB8 1A22 9632          jsr       _OS_Sched
                    9633   OSMutexDel_28:
                    9634   ; }
                    9635   ; *perr         = OS_ERR_NONE;
000033A6  2044      9636          move.l    D4,A0
000033A8  4210      9637          clr.b     (A0)
                    9638   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
000033AA  4285      9639          clr.l     D5
                    9640   ; break;
000033AC  600A      9641          bra.s     OSMutexDel_9
                    9642   OSMutexDel_8:
                    9643   ; default:
                    9644   ; OS_EXIT_CRITICAL();
000033AE  46DF      9645          dc.w      18143
                    9646   ; *perr         = OS_ERR_INVALID_OPT;
000033B0  2044      9647          move.l    D4,A0
000033B2  10BC 0007 9648          move.b    #7,(A0)
                    9649   ; pevent_return = pevent;
000033B6  2A02      9650          move.l    D2,D5
                    9651   ; break;
                    9652   OSMutexDel_9:
                    9653   ; }
                    9654   ; return (pevent_return);
000033B8  2005      9655          move.l    D5,D0
                    9656   OSMutexDel_3:
000033BA  4CDF 04FC 9657          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000033BE  4E5E      9658          unlk      A6
000033C0  4E75      9659          rts
                    9660   ; }
                    9661   ; #endif
                    9662   ; /*$PAGE*/
                    9663   ; /*
                    9664   ; *********************************************************************************************************
                    9665   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9666   ; *
                    9667   ; * Description: This function waits for a mutual exclusion semaphore.
                    9668   ; *
                    9669   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9670   ; *                            mutex.
                    9671   ; *
                    9672   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9673   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9674   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9675   ; *                            mutex or, until the resource becomes available.
                    9676   ; *
                    9677   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9678   ; *                            messages are:
                    9679   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9680   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9681   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9682   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9683   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9684   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9685   ; *                                                  would lead to a suspension.
                    9686   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9687   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9688   ; *                                                  indicates that you did not set the PCP higher (lower
                    9689   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9690   ; *                                                  Unfortunately, this is something that could not be
                    9691   ; *                                                  detected when the Mutex is created because we don't know
                    9692   ; *                                                  what tasks will be using the Mutex.
                    9693   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9694   ; *
                    9695   ; * Returns    : none
                    9696   ; *
                    9697   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9698   ; *
                    9699   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9700   ; *********************************************************************************************************
                    9701   ; */
                    9702   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9703   ; INT32U     timeout,
                    9704   ; INT8U     *perr)
                    9705   ; {
                    9706   _OSMutexPend:
000033C2  4E56 FFFC 9707          link      A6,#-4
000033C6  48E7 3F30 9708          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
000033CA  45F9 0800 9709          lea       _OSTCBCur.L,A2
000033CE  1020      
000033D0  262E 0008 9710          move.l    8(A6),D3
000033D4  2A2E 0010 9711          move.l    16(A6),D5
000033D8  47F9 0800 9712          lea       _OSRdyTbl.L,A3
000033DC  0F10      
                    9713   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9714   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9715   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9716   ; OS_TCB    *ptcb;
                    9717   ; OS_EVENT  *pevent2;
                    9718   ; INT8U      y;
                    9719   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9720   ; OS_CPU_SR  cpu_sr = 0u;
                    9721   ; #endif
                    9722   ; #ifdef OS_SAFETY_CRITICAL
                    9723   ; if (perr == (INT8U *)0) {
                    9724   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9725   ; return;
                    9726   ; }
                    9727   ; #endif
                    9728   ; #if OS_ARG_CHK_EN > 0u
                    9729   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9730   ; *perr = OS_ERR_PEVENT_NULL;
                    9731   ; return;
                    9732   ; }
                    9733   ; #endif
                    9734   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000033DE  2043      9735          move.l    D3,A0
000033E0  1010      9736          move.b    (A0),D0
000033E2  0C00 0004 9737          cmp.b     #4,D0
000033E6  670A      9738          beq.s     OSMutexPend_1
                    9739   ; *perr = OS_ERR_EVENT_TYPE;
000033E8  2045      9740          move.l    D5,A0
000033EA  10BC 0001 9741          move.b    #1,(A0)
                    9742   ; return;
000033EE  6000 02AC 9743          bra       OSMutexPend_3
                    9744   OSMutexPend_1:
                    9745   ; }
                    9746   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000033F2  1039 0800 9747          move.b    _OSIntNesting.L,D0
000033F6  0F06      
000033F8  0C00 0000 9748          cmp.b     #0,D0
000033FC  630A      9749          bls.s     OSMutexPend_4
                    9750   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000033FE  2045      9751          move.l    D5,A0
00003400  10BC 0002 9752          move.b    #2,(A0)
                    9753   ; return;
00003404  6000 0296 9754          bra       OSMutexPend_3
                    9755   OSMutexPend_4:
                    9756   ; }
                    9757   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00003408  1039 0800 9758          move.b    _OSLockNesting.L,D0
0000340C  0F08      
0000340E  0C00 0000 9759          cmp.b     #0,D0
00003412  630A      9760          bls.s     OSMutexPend_6
                    9761   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00003414  2045      9762          move.l    D5,A0
00003416  10BC 000D 9763          move.b    #13,(A0)
                    9764   ; return;
0000341A  6000 0280 9765          bra       OSMutexPend_3
                    9766   OSMutexPend_6:
                    9767   ; }
                    9768   ; /*$PAGE*/
                    9769   ; OS_ENTER_CRITICAL();
0000341E  40E7      9770          dc.w      16615
00003420  007C      9771          dc.w      124
00003422  0700      9772          dc.w      1792
                    9773   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
00003424  2043      9774          move.l    D3,A0
00003426  3028 0006 9775          move.w    6(A0),D0
0000342A  E048      9776          lsr.w     #8,D0
0000342C  1E00      9777          move.b    D0,D7
                    9778   ; /* Is Mutex available?                      */
                    9779   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
0000342E  2043      9780          move.l    D3,A0
00003430  3028 0006 9781          move.w    6(A0),D0
00003434  C07C 00FF 9782          and.w     #255,D0
00003438  C07C 00FF 9783          and.w     #255,D0
0000343C  0C40 00FF 9784          cmp.w     #255,D0
00003440  6600 0042 9785          bne       OSMutexPend_8
                    9786   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
00003444  2043      9787          move.l    D3,A0
00003446  0268 FF00 9788          and.w     #65280,6(A0)
0000344A  0006      
                    9789   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
0000344C  2043      9790          move.l    D3,A0
0000344E  2252      9791          move.l    (A2),A1
00003450  1029 0034 9792          move.b    52(A1),D0
00003454  C07C 00FF 9793          and.w     #255,D0
00003458  8168 0006 9794          or.w      D0,6(A0)
                    9795   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
0000345C  2043      9796          move.l    D3,A0
0000345E  2152 0002 9797          move.l    (A2),2(A0)
                    9798   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00003462  0C07 00FF 9799          cmp.b     #255,D7
00003466  6712      9800          beq.s     OSMutexPend_10
00003468  2052      9801          move.l    (A2),A0
0000346A  BE28 0034 9802          cmp.b     52(A0),D7
0000346E  650A      9803          blo.s     OSMutexPend_10
                    9804   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9805   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00003470  46DF      9806          dc.w      18143
                    9807   ; *perr = OS_ERR_PCP_LOWER;
00003472  2045      9808          move.l    D5,A0
00003474  10BC 0078 9809          move.b    #120,(A0)
00003478  6006      9810          bra.s     OSMutexPend_11
                    9811   OSMutexPend_10:
                    9812   ; } else {
                    9813   ; OS_EXIT_CRITICAL();
0000347A  46DF      9814          dc.w      18143
                    9815   ; *perr = OS_ERR_NONE;
0000347C  2045      9816          move.l    D5,A0
0000347E  4210      9817          clr.b     (A0)
                    9818   OSMutexPend_11:
                    9819   ; }
                    9820   ; return;
00003480  6000 021A 9821          bra       OSMutexPend_3
                    9822   OSMutexPend_8:
                    9823   ; }
                    9824   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003484  0C07 00FF 9825          cmp.b     #255,D7
00003488  6700 018A 9826          beq       OSMutexPend_16
                    9827   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
0000348C  2043      9828          move.l    D3,A0
0000348E  3028 0006 9829          move.w    6(A0),D0
00003492  C07C 00FF 9830          and.w     #255,D0
00003496  1D40 FFFE 9831          move.b    D0,-2(A6)
                    9832   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
0000349A  2043      9833          move.l    D3,A0
0000349C  2428 0002 9834          move.l    2(A0),D2
                    9835   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
000034A0  2042      9836          move.l    D2,A0
000034A2  BE28 0034 9837          cmp.b     52(A0),D7
000034A6  6400 016C 9838          bhs       OSMutexPend_16
                    9839   ; if (mprio > OSTCBCur->OSTCBPrio) {
000034AA  2052      9840          move.l    (A2),A0
000034AC  102E FFFE 9841          move.b    -2(A6),D0
000034B0  B028 0034 9842          cmp.b     52(A0),D0
000034B4  6300 015E 9843          bls       OSMutexPend_16
                    9844   ; y = ptcb->OSTCBY;
000034B8  2042      9845          move.l    D2,A0
000034BA  1C28 0036 9846          move.b    54(A0),D6
                    9847   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
000034BE  CCBC 0000 9848          and.l     #255,D6
000034C2  00FF      
000034C4  1033 6800 9849          move.b    0(A3,D6.L),D0
000034C8  2042      9850          move.l    D2,A0
000034CA  C028 0037 9851          and.b     55(A0),D0
000034CE  6736      9852          beq.s     OSMutexPend_18
                    9853   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
000034D0  CCBC 0000 9854          and.l     #255,D6
000034D4  00FF      
000034D6  2042      9855          move.l    D2,A0
000034D8  1028 0037 9856          move.b    55(A0),D0
000034DC  4600      9857          not.b     D0
000034DE  C133 6800 9858          and.b     D0,0(A3,D6.L)
                    9859   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
000034E2  CCBC 0000 9860          and.l     #255,D6
000034E6  00FF      
000034E8  1033 6800 9861          move.b    0(A3,D6.L),D0
000034EC  660E      9862          bne.s     OSMutexPend_20
                    9863   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000034EE  2042      9864          move.l    D2,A0
000034F0  1028 0038 9865          move.b    56(A0),D0
000034F4  4600      9866          not.b     D0
000034F6  C139 0800 9867          and.b     D0,_OSRdyGrp.L
000034FA  0F0E      
                    9868   OSMutexPend_20:
                    9869   ; }
                    9870   ; rdy = OS_TRUE;
000034FC  1D7C 0001 9871          move.b    #1,-1(A6)
00003500  FFFF      
00003502  6000 004C 9872          bra       OSMutexPend_19
                    9873   OSMutexPend_18:
                    9874   ; } else {
                    9875   ; pevent2 = ptcb->OSTCBEventPtr;
00003506  2042      9876          move.l    D2,A0
00003508  2828 001C 9877          move.l    28(A0),D4
                    9878   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
0000350C  4A84      9879          tst.l     D4
0000350E  6700 003C 9880          beq       OSMutexPend_24
                    9881   ; y = ptcb->OSTCBY;
00003512  2042      9882          move.l    D2,A0
00003514  1C28 0036 9883          move.b    54(A0),D6
                    9884   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003518  2044      9885          move.l    D4,A0
0000351A  CCBC 0000 9886          and.l     #255,D6
0000351E  00FF      
00003520  D1C6      9887          add.l     D6,A0
00003522  2242      9888          move.l    D2,A1
00003524  1029 0037 9889          move.b    55(A1),D0
00003528  4600      9890          not.b     D0
0000352A  C128 000A 9891          and.b     D0,10(A0)
                    9892   ; if (pevent2->OSEventTbl[y] == 0u) {
0000352E  2044      9893          move.l    D4,A0
00003530  CCBC 0000 9894          and.l     #255,D6
00003534  00FF      
00003536  D1C6      9895          add.l     D6,A0
00003538  1028 000A 9896          move.b    10(A0),D0
0000353C  660E      9897          bne.s     OSMutexPend_24
                    9898   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000353E  2044      9899          move.l    D4,A0
00003540  2242      9900          move.l    D2,A1
00003542  1029 0038 9901          move.b    56(A1),D0
00003546  4600      9902          not.b     D0
00003548  C128 0008 9903          and.b     D0,8(A0)
                    9904   OSMutexPend_24:
                    9905   ; }
                    9906   ; }
                    9907   ; rdy = OS_FALSE;                        /* No                                       */
0000354C  422E FFFF 9908          clr.b     -1(A6)
                    9909   OSMutexPend_19:
                    9910   ; }
                    9911   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
00003550  2042      9912          move.l    D2,A0
00003552  1147 0034 9913          move.b    D7,52(A0)
                    9914   ; #if OS_LOWEST_PRIO <= 63u
                    9915   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
00003556  2042      9916          move.l    D2,A0
00003558  1028 0034 9917          move.b    52(A0),D0
0000355C  E608      9918          lsr.b     #3,D0
0000355E  2042      9919          move.l    D2,A0
00003560  1140 0036 9920          move.b    D0,54(A0)
                    9921   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
00003564  2042      9922          move.l    D2,A0
00003566  1028 0034 9923          move.b    52(A0),D0
0000356A  C03C 0007 9924          and.b     #7,D0
0000356E  2042      9925          move.l    D2,A0
00003570  1140 0035 9926          move.b    D0,53(A0)
                    9927   ; #else
                    9928   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9929   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9930   ; #endif
                    9931   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
00003574  7001      9932          moveq     #1,D0
00003576  2042      9933          move.l    D2,A0
00003578  1228 0036 9934          move.b    54(A0),D1
0000357C  C2BC 0000 9935          and.l     #255,D1
00003580  00FF      
00003582  E3A8      9936          lsl.l     D1,D0
00003584  2042      9937          move.l    D2,A0
00003586  1140 0038 9938          move.b    D0,56(A0)
                    9939   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
0000358A  7001      9940          moveq     #1,D0
0000358C  2042      9941          move.l    D2,A0
0000358E  1228 0035 9942          move.b    53(A0),D1
00003592  C2BC 0000 9943          and.l     #255,D1
00003596  00FF      
00003598  E3A8      9944          lsl.l     D1,D0
0000359A  2042      9945          move.l    D2,A0
0000359C  1140 0037 9946          move.b    D0,55(A0)
                    9947   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
000035A0  102E FFFF 9948          move.b    -1(A6),D0
000035A4  0C00 0001 9949          cmp.b     #1,D0
000035A8  6626      9950          bne.s     OSMutexPend_26
                    9951   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
000035AA  2042      9952          move.l    D2,A0
000035AC  1028 0038 9953          move.b    56(A0),D0
000035B0  8139 0800 9954          or.b      D0,_OSRdyGrp.L
000035B4  0F0E      
                    9955   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000035B6  2042      9956          move.l    D2,A0
000035B8  1028 0036 9957          move.b    54(A0),D0
000035BC  C0BC 0000 9958          and.l     #255,D0
000035C0  00FF      
000035C2  2042      9959          move.l    D2,A0
000035C4  1228 0037 9960          move.b    55(A0),D1
000035C8  8333 0800 9961          or.b      D1,0(A3,D0.L)
000035CC  6000 0032 9962          bra       OSMutexPend_28
                    9963   OSMutexPend_26:
                    9964   ; } else {
                    9965   ; pevent2 = ptcb->OSTCBEventPtr;
000035D0  2042      9966          move.l    D2,A0
000035D2  2828 001C 9967          move.l    28(A0),D4
                    9968   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
000035D6  4A84      9969          tst.l     D4
000035D8  6726      9970          beq.s     OSMutexPend_28
                    9971   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
000035DA  2044      9972          move.l    D4,A0
000035DC  2242      9973          move.l    D2,A1
000035DE  1029 0038 9974          move.b    56(A1),D0
000035E2  8128 0008 9975          or.b      D0,8(A0)
                    9976   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000035E6  2044      9977          move.l    D4,A0
000035E8  2242      9978          move.l    D2,A1
000035EA  1029 0036 9979          move.b    54(A1),D0
000035EE  C0BC 0000 9980          and.l     #255,D0
000035F2  00FF      
000035F4  D1C0      9981          add.l     D0,A0
000035F6  2242      9982          move.l    D2,A1
000035F8  1029 0037 9983          move.b    55(A1),D0
000035FC  8128 000A 9984          or.b      D0,10(A0)
                    9985   OSMutexPend_28:
                    9986   ; }
                    9987   ; }
                    9988   ; OSTCBPrioTbl[pcp] = ptcb;
00003600  CEBC 0000 9989          and.l     #255,D7
00003604  00FF      
00003606  2007      9990          move.l    D7,D0
00003608  E588      9991          lsl.l     #2,D0
0000360A  41F9 0800 9992          lea       _OSTCBPrioTbl.L,A0
0000360E  1030      
00003610  2182 0800 9993          move.l    D2,0(A0,D0.L)
                    9994   OSMutexPend_16:
                    9995   ; }
                    9996   ; }
                    9997   ; }
                    9998   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
00003614  2052      9999          move.l    (A2),A0
00003616  0028 0010 10000          or.b      #16,50(A0)
0000361A  0032      
                    10001   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0000361C  2052      10002          move.l    (A2),A0
0000361E  4228 0033 10003          clr.b     51(A0)
                    10004   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
00003622  2052      10005          move.l    (A2),A0
00003624  216E 000C 10006          move.l    12(A6),46(A0)
00003628  002E      
                    10007   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
0000362A  2F03      10008          move.l    D3,-(A7)
0000362C  4EB8 1526 10009          jsr       _OS_EventTaskWait
00003630  584F      10010          addq.w    #4,A7
                    10011   ; OS_EXIT_CRITICAL();
00003632  46DF      10012          dc.w      18143
                    10013   ; OS_Sched();                                       /* Find next highest priority task ready         */
00003634  4EB8 1A22 10014          jsr       _OS_Sched
                    10015   ; OS_ENTER_CRITICAL();
00003638  40E7      10016          dc.w      16615
0000363A  007C      10017          dc.w      124
0000363C  0700      10018          dc.w      1792
                    10019   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
0000363E  2052      10020          move.l    (A2),A0
00003640  1028 0033 10021          move.b    51(A0),D0
00003644  C0BC 0000 10022          and.l     #255,D0
00003648  00FF      
0000364A  0C80 0000 10023          cmp.l     #1,D0
0000364E  0001      
00003650  6720      10024          beq.s     OSMutexPend_34
00003652  6206      10025          bhi.s     OSMutexPend_36
00003654  4A80      10026          tst.l     D0
00003656  670C      10027          beq.s     OSMutexPend_32
00003658  6018      10028          bra.s     OSMutexPend_34
                    10029   OSMutexPend_36:
0000365A  0C80 0000 10030          cmp.l     #2,D0
0000365E  0002      
00003660  6708      10031          beq.s     OSMutexPend_33
00003662  600E      10032          bra.s     OSMutexPend_34
                    10033   OSMutexPend_32:
                    10034   ; case OS_STAT_PEND_OK:
                    10035   ; *perr = OS_ERR_NONE;
00003664  2045      10036          move.l    D5,A0
00003666  4210      10037          clr.b     (A0)
                    10038   ; break;
00003668  6018      10039          bra.s     OSMutexPend_31
                    10040   OSMutexPend_33:
                    10041   ; case OS_STAT_PEND_ABORT:
                    10042   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
0000366A  2045      10043          move.l    D5,A0
0000366C  10BC 000E 10044          move.b    #14,(A0)
                    10045   ; break;
00003670  6010      10046          bra.s     OSMutexPend_31
                    10047   OSMutexPend_34:
                    10048   ; case OS_STAT_PEND_TO:
                    10049   ; default:
                    10050   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003672  2F03      10051          move.l    D3,-(A7)
00003674  2F12      10052          move.l    (A2),-(A7)
00003676  4EB8 1648 10053          jsr       _OS_EventTaskRemove
0000367A  504F      10054          addq.w    #8,A7
                    10055   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
0000367C  2045      10056          move.l    D5,A0
0000367E  10BC 000A 10057          move.b    #10,(A0)
                    10058   ; break;
                    10059   OSMutexPend_31:
                    10060   ; }
                    10061   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003682  2052      10062          move.l    (A2),A0
00003684  4228 0032 10063          clr.b     50(A0)
                    10064   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003688  2052      10065          move.l    (A2),A0
0000368A  4228 0033 10066          clr.b     51(A0)
                    10067   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
0000368E  2052      10068          move.l    (A2),A0
00003690  42A8 001C 10069          clr.l     28(A0)
                    10070   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10071   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003694  2052      10072          move.l    (A2),A0
00003696  42A8 0020 10073          clr.l     32(A0)
                    10074   ; #endif
                    10075   ; OS_EXIT_CRITICAL();
0000369A  46DF      10076          dc.w      18143
                    10077   OSMutexPend_3:
0000369C  4CDF 0CFC 10078          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
000036A0  4E5E      10079          unlk      A6
000036A2  4E75      10080          rts
                    10081   ; }
                    10082   ; /*$PAGE*/
                    10083   ; /*
                    10084   ; *********************************************************************************************************
                    10085   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    10086   ; *
                    10087   ; * Description: This function signals a mutual exclusion semaphore
                    10088   ; *
                    10089   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    10090   ; *                                  mutex.
                    10091   ; *
                    10092   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    10093   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    10094   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    10095   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    10096   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    10097   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    10098   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    10099   ; *                                      indicates that you did not set the PCP higher (lower
                    10100   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    10101   ; *                                      Unfortunately, this is something that could not be
                    10102   ; *                                      detected when the Mutex is created because we don't know
                    10103   ; *                                      what tasks will be using the Mutex.
                    10104   ; *********************************************************************************************************
                    10105   ; */
                    10106   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    10107   ; {
                    10108   _OSMutexPost:
000036A4  4E56 0000 10109          link      A6,#0
000036A8  48E7 3820 10110          movem.l   D2/D3/D4/A2,-(A7)
000036AC  242E 0008 10111          move.l    8(A6),D2
000036B0  45F9 0800 10112          lea       _OSTCBCur.L,A2
000036B4  1020      
                    10113   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    10114   ; INT8U      prio;
                    10115   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10116   ; OS_CPU_SR  cpu_sr = 0u;
                    10117   ; #endif
                    10118   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000036B6  1039 0800 10119          move.b    _OSIntNesting.L,D0
000036BA  0F06      
000036BC  0C00 0000 10120          cmp.b     #0,D0
000036C0  6306      10121          bls.s     OSMutexPost_1
                    10122   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
000036C2  7005      10123          moveq     #5,D0
000036C4  6000 00F0 10124          bra       OSMutexPost_3
                    10125   OSMutexPost_1:
                    10126   ; }
                    10127   ; #if OS_ARG_CHK_EN > 0u
                    10128   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10129   ; return (OS_ERR_PEVENT_NULL);
                    10130   ; }
                    10131   ; #endif
                    10132   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
000036C8  2042      10133          move.l    D2,A0
000036CA  1010      10134          move.b    (A0),D0
000036CC  0C00 0004 10135          cmp.b     #4,D0
000036D0  6706      10136          beq.s     OSMutexPost_4
                    10137   ; return (OS_ERR_EVENT_TYPE);
000036D2  7001      10138          moveq     #1,D0
000036D4  6000 00E0 10139          bra       OSMutexPost_3
                    10140   OSMutexPost_4:
                    10141   ; }
                    10142   ; OS_ENTER_CRITICAL();
000036D8  40E7      10143          dc.w      16615
000036DA  007C      10144          dc.w      124
000036DC  0700      10145          dc.w      1792
                    10146   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
000036DE  2042      10147          move.l    D2,A0
000036E0  3028 0006 10148          move.w    6(A0),D0
000036E4  E048      10149          lsr.w     #8,D0
000036E6  1800      10150          move.b    D0,D4
                    10151   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
000036E8  2042      10152          move.l    D2,A0
000036EA  3028 0006 10153          move.w    6(A0),D0
000036EE  C07C 00FF 10154          and.w     #255,D0
000036F2  1600      10155          move.b    D0,D3
                    10156   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
000036F4  2042      10157          move.l    D2,A0
000036F6  2012      10158          move.l    (A2),D0
000036F8  B0A8 0002 10159          cmp.l     2(A0),D0
000036FC  6708      10160          beq.s     OSMutexPost_6
                    10161   ; OS_EXIT_CRITICAL();
000036FE  46DF      10162          dc.w      18143
                    10163   ; return (OS_ERR_NOT_MUTEX_OWNER);
00003700  7064      10164          moveq     #100,D0
00003702  6000 00B2 10165          bra       OSMutexPost_3
                    10166   OSMutexPost_6:
                    10167   ; }
                    10168   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003706  0C04 00FF 10169          cmp.b     #255,D4
0000370A  6732      10170          beq.s     OSMutexPost_8
                    10171   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
0000370C  2052      10172          move.l    (A2),A0
0000370E  B828 0034 10173          cmp.b     52(A0),D4
00003712  6612      10174          bne.s     OSMutexPost_10
                    10175   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
00003714  C6BC 0000 10176          and.l     #255,D3
00003718  00FF      
0000371A  2F03      10177          move.l    D3,-(A7)
0000371C  2F12      10178          move.l    (A2),-(A7)
0000371E  4EB9 0000 10179          jsr       @ucos_ii_OSMutex_RdyAtPrio
00003722  3870      
00003724  504F      10180          addq.w    #8,A7
                    10181   OSMutexPost_10:
                    10182   ; }
                    10183   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
00003726  C8BC 0000 10184          and.l     #255,D4
0000372A  00FF      
0000372C  2004      10185          move.l    D4,D0
0000372E  E588      10186          lsl.l     #2,D0
00003730  41F9 0800 10187          lea       _OSTCBPrioTbl.L,A0
00003734  1030      
00003736  21BC 0000 10188          move.l    #1,0(A0,D0.L)
0000373A  0001 0800 
                    10189   OSMutexPost_8:
                    10190   ; }
                    10191   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
0000373E  2042      10192          move.l    D2,A0
00003740  1028 0008 10193          move.b    8(A0),D0
00003744  6700 005E 10194          beq       OSMutexPost_12
                    10195   ; /* Yes, Make HPT waiting for mutex ready         */
                    10196   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
00003748  42A7      10197          clr.l     -(A7)
0000374A  4878 0010 10198          pea       16
0000374E  42A7      10199          clr.l     -(A7)
00003750  2F02      10200          move.l    D2,-(A7)
00003752  4EB8 1442 10201          jsr       _OS_EventTaskRdy
00003756  DEFC 0010 10202          add.w     #16,A7
0000375A  1600      10203          move.b    D0,D3
                    10204   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
0000375C  2042      10205          move.l    D2,A0
0000375E  0268 FF00 10206          and.w     #65280,6(A0)
00003762  0006      
                    10207   ; pevent->OSEventCnt |= prio;
00003764  2042      10208          move.l    D2,A0
00003766  C67C 00FF 10209          and.w     #255,D3
0000376A  8768 0006 10210          or.w      D3,6(A0)
                    10211   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
0000376E  C6BC 0000 10212          and.l     #255,D3
00003772  00FF      
00003774  2003      10213          move.l    D3,D0
00003776  E588      10214          lsl.l     #2,D0
00003778  41F9 0800 10215          lea       _OSTCBPrioTbl.L,A0
0000377C  1030      
0000377E  2242      10216          move.l    D2,A1
00003780  2370 0800 10217          move.l    0(A0,D0.L),2(A1)
00003784  0002      
                    10218   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
00003786  0C04 00FF 10219          cmp.b     #255,D4
0000378A  670E      10220          beq.s     OSMutexPost_14
0000378C  B604      10221          cmp.b     D4,D3
0000378E  620A      10222          bhi.s     OSMutexPost_14
                    10223   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    10224   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
00003790  46DF      10225          dc.w      18143
                    10226   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003792  4EB8 1A22 10227          jsr       _OS_Sched
                    10228   ; return (OS_ERR_PCP_LOWER);
00003796  7078      10229          moveq     #120,D0
00003798  601C      10230          bra.s     OSMutexPost_3
                    10231   OSMutexPost_14:
                    10232   ; } else {
                    10233   ; OS_EXIT_CRITICAL();
0000379A  46DF      10234          dc.w      18143
                    10235   ; OS_Sched();                               /*      Find highest priority task ready to run  */
0000379C  4EB8 1A22 10236          jsr       _OS_Sched
                    10237   ; return (OS_ERR_NONE);
000037A0  4200      10238          clr.b     D0
000037A2  6012      10239          bra.s     OSMutexPost_3
                    10240   OSMutexPost_12:
                    10241   ; }
                    10242   ; }
                    10243   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
000037A4  2042      10244          move.l    D2,A0
000037A6  0068 00FF 10245          or.w      #255,6(A0)
000037AA  0006      
                    10246   ; pevent->OSEventPtr  = (void *)0;
000037AC  2042      10247          move.l    D2,A0
000037AE  42A8 0002 10248          clr.l     2(A0)
                    10249   ; OS_EXIT_CRITICAL();
000037B2  46DF      10250          dc.w      18143
                    10251   ; return (OS_ERR_NONE);
000037B4  4200      10252          clr.b     D0
                    10253   OSMutexPost_3:
000037B6  4CDF 041C 10254          movem.l   (A7)+,D2/D3/D4/A2
000037BA  4E5E      10255          unlk      A6
000037BC  4E75      10256          rts
                    10257   ; }
                    10258   ; /*$PAGE*/
                    10259   ; /*
                    10260   ; *********************************************************************************************************
                    10261   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    10262   ; *
                    10263   ; * Description: This function obtains information about a mutex
                    10264   ; *
                    10265   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    10266   ; *
                    10267   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    10268   ; *
                    10269   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    10270   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    10271   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    10272   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    10273   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    10274   ; *********************************************************************************************************
                    10275   ; */
                    10276   ; #if OS_MUTEX_QUERY_EN > 0u
                    10277   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    10278   ; OS_MUTEX_DATA  *p_mutex_data)
                    10279   ; {
                    10280   _OSMutexQuery:
000037BE  4E56 FFF8 10281          link      A6,#-8
000037C2  48E7 3800 10282          movem.l   D2/D3/D4,-(A7)
000037C6  242E 000C 10283          move.l    12(A6),D2
000037CA  262E 0008 10284          move.l    8(A6),D3
                    10285   ; INT8U       i;
                    10286   ; OS_PRIO    *psrc;
                    10287   ; OS_PRIO    *pdest;
                    10288   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10289   ; OS_CPU_SR   cpu_sr = 0u;
                    10290   ; #endif
                    10291   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000037CE  1039 0800 10292          move.b    _OSIntNesting.L,D0
000037D2  0F06      
000037D4  0C00 0000 10293          cmp.b     #0,D0
000037D8  6306      10294          bls.s     OSMutexQuery_1
                    10295   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
000037DA  7006      10296          moveq     #6,D0
000037DC  6000 008A 10297          bra       OSMutexQuery_3
                    10298   OSMutexQuery_1:
                    10299   ; }
                    10300   ; #if OS_ARG_CHK_EN > 0u
                    10301   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10302   ; return (OS_ERR_PEVENT_NULL);
                    10303   ; }
                    10304   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    10305   ; return (OS_ERR_PDATA_NULL);
                    10306   ; }
                    10307   ; #endif
                    10308   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000037E0  2043      10309          move.l    D3,A0
000037E2  1010      10310          move.b    (A0),D0
000037E4  0C00 0004 10311          cmp.b     #4,D0
000037E8  6706      10312          beq.s     OSMutexQuery_4
                    10313   ; return (OS_ERR_EVENT_TYPE);
000037EA  7001      10314          moveq     #1,D0
000037EC  6000 007A 10315          bra       OSMutexQuery_3
                    10316   OSMutexQuery_4:
                    10317   ; }
                    10318   ; OS_ENTER_CRITICAL();
000037F0  40E7      10319          dc.w      16615
000037F2  007C      10320          dc.w      124
000037F4  0700      10321          dc.w      1792
                    10322   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
000037F6  2043      10323          move.l    D3,A0
000037F8  3028 0006 10324          move.w    6(A0),D0
000037FC  E048      10325          lsr.w     #8,D0
000037FE  2042      10326          move.l    D2,A0
00003800  1140 000B 10327          move.b    D0,11(A0)
                    10328   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
00003804  2043      10329          move.l    D3,A0
00003806  3028 0006 10330          move.w    6(A0),D0
0000380A  C07C 00FF 10331          and.w     #255,D0
0000380E  2042      10332          move.l    D2,A0
00003810  1140 000A 10333          move.b    D0,10(A0)
                    10334   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
00003814  2042      10335          move.l    D2,A0
00003816  1028 000A 10336          move.b    10(A0),D0
0000381A  0C00 00FF 10337          cmp.b     #255,D0
0000381E  660A      10338          bne.s     OSMutexQuery_6
                    10339   ; p_mutex_data->OSValue = OS_TRUE;
00003820  2042      10340          move.l    D2,A0
00003822  117C 0001 10341          move.b    #1,9(A0)
00003826  0009      
00003828  6006      10342          bra.s     OSMutexQuery_7
                    10343   OSMutexQuery_6:
                    10344   ; } else {
                    10345   ; p_mutex_data->OSValue = OS_FALSE;
0000382A  2042      10346          move.l    D2,A0
0000382C  4228 0009 10347          clr.b     9(A0)
                    10348   OSMutexQuery_7:
                    10349   ; }
                    10350   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
00003830  2043      10351          move.l    D3,A0
00003832  2242      10352          move.l    D2,A1
00003834  1368 0008 10353          move.b    8(A0),8(A1)
00003838  0008      
                    10354   ; psrc                      = &pevent->OSEventTbl[0];
0000383A  700A      10355          moveq     #10,D0
0000383C  D083      10356          add.l     D3,D0
0000383E  2D40 FFF8 10357          move.l    D0,-8(A6)
                    10358   ; pdest                     = &p_mutex_data->OSEventTbl[0];
00003842  2D42 FFFC 10359          move.l    D2,-4(A6)
                    10360   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003846  4204      10361          clr.b     D4
                    10362   OSMutexQuery_8:
00003848  0C04 0008 10363          cmp.b     #8,D4
0000384C  6416      10364          bhs.s     OSMutexQuery_10
                    10365   ; *pdest++ = *psrc++;
0000384E  206E FFF8 10366          move.l    -8(A6),A0
00003852  52AE FFF8 10367          addq.l    #1,-8(A6)
00003856  226E FFFC 10368          move.l    -4(A6),A1
0000385A  52AE FFFC 10369          addq.l    #1,-4(A6)
0000385E  1290      10370          move.b    (A0),(A1)
00003860  5204      10371          addq.b    #1,D4
00003862  60E4      10372          bra       OSMutexQuery_8
                    10373   OSMutexQuery_10:
                    10374   ; }
                    10375   ; OS_EXIT_CRITICAL();
00003864  46DF      10376          dc.w      18143
                    10377   ; return (OS_ERR_NONE);
00003866  4200      10378          clr.b     D0
                    10379   OSMutexQuery_3:
00003868  4CDF 001C 10380          movem.l   (A7)+,D2/D3/D4
0000386C  4E5E      10381          unlk      A6
0000386E  4E75      10382          rts
                    10383   ; }
                    10384   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    10385   ; /*$PAGE*/
                    10386   ; /*
                    10387   ; *********************************************************************************************************
                    10388   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    10389   ; *
                    10390   ; * Description: This function makes a task ready at the specified priority
                    10391   ; *
                    10392   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    10393   ; *
                    10394   ; *              prio            is the desired priority
                    10395   ; *
                    10396   ; * Returns    : none
                    10397   ; *********************************************************************************************************
                    10398   ; */
                    10399   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    10400   ; INT8U    prio)
                    10401   ; {
                    10402   @ucos_ii_OSMutex_RdyAtPrio:
00003870  4E56 0000 10403          link      A6,#0
00003874  48E7 3820 10404          movem.l   D2/D3/D4/A2,-(A7)
00003878  242E 0008 10405          move.l    8(A6),D2
0000387C  162E 000F 10406          move.b    15(A6),D3
00003880  C6BC 0000 10407          and.l     #255,D3
00003884  00FF      
00003886  45F9 0800 10408          lea       _OSRdyTbl.L,A2
0000388A  0F10      
                    10409   ; INT8U  y;
                    10410   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
0000388C  2042      10411          move.l    D2,A0
0000388E  1828 0036 10412          move.b    54(A0),D4
                    10413   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003892  C8BC 0000 10414          and.l     #255,D4
00003896  00FF      
00003898  2042      10415          move.l    D2,A0
0000389A  1028 0037 10416          move.b    55(A0),D0
0000389E  4600      10417          not.b     D0
000038A0  C132 4800 10418          and.b     D0,0(A2,D4.L)
                    10419   ; if (OSRdyTbl[y] == 0u) {
000038A4  C8BC 0000 10420          and.l     #255,D4
000038A8  00FF      
000038AA  1032 4800 10421          move.b    0(A2,D4.L),D0
000038AE  660E      10422          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    10423   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000038B0  2042      10424          move.l    D2,A0
000038B2  1028 0038 10425          move.b    56(A0),D0
000038B6  4600      10426          not.b     D0
000038B8  C139 0800 10427          and.b     D0,_OSRdyGrp.L
000038BC  0F0E      
                    10428   @ucos_ii_OSMutex_RdyAtPrio_1:
                    10429   ; }
                    10430   ; ptcb->OSTCBPrio         = prio;
000038BE  2042      10431          move.l    D2,A0
000038C0  1143 0034 10432          move.b    D3,52(A0)
                    10433   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
000038C4  13C3 0800 10434          move.b    D3,_OSPrioCur.L
000038C8  0F0A      
                    10435   ; #if OS_LOWEST_PRIO <= 63u
                    10436   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
000038CA  1003      10437          move.b    D3,D0
000038CC  E608      10438          lsr.b     #3,D0
000038CE  C03C 0007 10439          and.b     #7,D0
000038D2  2042      10440          move.l    D2,A0
000038D4  1140 0036 10441          move.b    D0,54(A0)
                    10442   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
000038D8  1003      10443          move.b    D3,D0
000038DA  C03C 0007 10444          and.b     #7,D0
000038DE  2042      10445          move.l    D2,A0
000038E0  1140 0035 10446          move.b    D0,53(A0)
                    10447   ; #else
                    10448   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    10449   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    10450   ; #endif
                    10451   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
000038E4  7001      10452          moveq     #1,D0
000038E6  2042      10453          move.l    D2,A0
000038E8  1228 0036 10454          move.b    54(A0),D1
000038EC  C2BC 0000 10455          and.l     #255,D1
000038F0  00FF      
000038F2  E3A8      10456          lsl.l     D1,D0
000038F4  2042      10457          move.l    D2,A0
000038F6  1140 0038 10458          move.b    D0,56(A0)
                    10459   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000038FA  7001      10460          moveq     #1,D0
000038FC  2042      10461          move.l    D2,A0
000038FE  1228 0035 10462          move.b    53(A0),D1
00003902  C2BC 0000 10463          and.l     #255,D1
00003906  00FF      
00003908  E3A8      10464          lsl.l     D1,D0
0000390A  2042      10465          move.l    D2,A0
0000390C  1140 0037 10466          move.b    D0,55(A0)
                    10467   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
00003910  2042      10468          move.l    D2,A0
00003912  1028 0038 10469          move.b    56(A0),D0
00003916  8139 0800 10470          or.b      D0,_OSRdyGrp.L
0000391A  0F0E      
                    10471   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000391C  2042      10472          move.l    D2,A0
0000391E  1028 0036 10473          move.b    54(A0),D0
00003922  C0BC 0000 10474          and.l     #255,D0
00003926  00FF      
00003928  2042      10475          move.l    D2,A0
0000392A  1228 0037 10476          move.b    55(A0),D1
0000392E  8332 0800 10477          or.b      D1,0(A2,D0.L)
                    10478   ; OSTCBPrioTbl[prio]      = ptcb;
00003932  C6BC 0000 10479          and.l     #255,D3
00003936  00FF      
00003938  2003      10480          move.l    D3,D0
0000393A  E588      10481          lsl.l     #2,D0
0000393C  41F9 0800 10482          lea       _OSTCBPrioTbl.L,A0
00003940  1030      
00003942  2182 0800 10483          move.l    D2,0(A0,D0.L)
00003946  4CDF 041C 10484          movem.l   (A7)+,D2/D3/D4/A2
0000394A  4E5E      10485          unlk      A6
0000394C  4E75      10486          rts
                    10487   ; /*
                    10488   ; *********************************************************************************************************
                    10489   ; *                                                uC/OS-II
                    10490   ; *                                          The Real-Time Kernel
                    10491   ; *                                        MESSAGE QUEUE MANAGEMENT
                    10492   ; *
                    10493   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    10494   ; *                                           All Rights Reserved
                    10495   ; *
                    10496   ; * File    : OS_Q.C
                    10497   ; * By      : Jean J. Labrosse
                    10498   ; * Version : V2.92.07
                    10499   ; *
                    10500   ; * LICENSING TERMS:
                    10501   ; * ---------------
                    10502   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    10503   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    10504   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    10505   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    10506   ; * licensing fee.
                    10507   ; *********************************************************************************************************
                    10508   ; */
                    10509   ; #define  MICRIUM_SOURCE
                    10510   ; #ifndef  OS_MASTER_FILE
                    10511   ; #include <ucos_ii.h>
                    10512   ; #endif
                    10513   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    10514   ; /*
                    10515   ; *********************************************************************************************************
                    10516   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    10517   ; *
                    10518   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    10519   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    10520   ; *
                    10521   ; * Arguments  : pevent        is a pointer to the event control block
                    10522   ; *
                    10523   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10524   ; *                            messages are:
                    10525   ; *
                    10526   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10527   ; *                                                message.
                    10528   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10529   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10530   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    10531   ; *
                    10532   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    10533   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    10534   ; *                            one less entry.
                    10535   ; *              == (void *)0  if you received a NULL pointer message
                    10536   ; *                            if the queue is empty or,
                    10537   ; *                            if 'pevent' is a NULL pointer or,
                    10538   ; *                            if you passed an invalid event type
                    10539   ; *
                    10540   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    10541   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    10542   ; *********************************************************************************************************
                    10543   ; */
                    10544   ; #if OS_Q_ACCEPT_EN > 0u
                    10545   ; void  *OSQAccept (OS_EVENT  *pevent,
                    10546   ; INT8U     *perr)
                    10547   ; {
                    10548   _OSQAccept:
0000394E  4E56 0000 10549          link      A6,#0
00003952  48E7 3800 10550          movem.l   D2/D3/D4,-(A7)
00003956  282E 000C 10551          move.l    12(A6),D4
                    10552   ; void      *pmsg;
                    10553   ; OS_Q      *pq;
                    10554   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10555   ; OS_CPU_SR  cpu_sr = 0u;
                    10556   ; #endif
                    10557   ; #ifdef OS_SAFETY_CRITICAL
                    10558   ; if (perr == (INT8U *)0) {
                    10559   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10560   ; return ((void *)0);
                    10561   ; }
                    10562   ; #endif
                    10563   ; #if OS_ARG_CHK_EN > 0u
                    10564   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10565   ; *perr = OS_ERR_PEVENT_NULL;
                    10566   ; return ((void *)0);
                    10567   ; }
                    10568   ; #endif
                    10569   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
0000395A  206E 0008 10570          move.l    8(A6),A0
0000395E  1010      10571          move.b    (A0),D0
00003960  0C00 0002 10572          cmp.b     #2,D0
00003964  670C      10573          beq.s     OSQAccept_1
                    10574   ; *perr = OS_ERR_EVENT_TYPE;
00003966  2044      10575          move.l    D4,A0
00003968  10BC 0001 10576          move.b    #1,(A0)
                    10577   ; return ((void *)0);
0000396C  4280      10578          clr.l     D0
0000396E  6000 0064 10579          bra       OSQAccept_3
                    10580   OSQAccept_1:
                    10581   ; }
                    10582   ; OS_ENTER_CRITICAL();
00003972  40E7      10583          dc.w      16615
00003974  007C      10584          dc.w      124
00003976  0700      10585          dc.w      1792
                    10586   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003978  206E 0008 10587          move.l    8(A6),A0
0000397C  2428 0002 10588          move.l    2(A0),D2
                    10589   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003980  2042      10590          move.l    D2,A0
00003982  3028 0016 10591          move.w    22(A0),D0
00003986  0C40 0000 10592          cmp.w     #0,D0
0000398A  6300 003C 10593          bls       OSQAccept_4
                    10594   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
0000398E  2002      10595          move.l    D2,D0
00003990  0680 0000 10596          add.l     #16,D0
00003994  0010      
00003996  2040      10597          move.l    D0,A0
00003998  2250      10598          move.l    (A0),A1
0000399A  5890      10599          addq.l    #4,(A0)
0000399C  2611      10600          move.l    (A1),D3
                    10601   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
0000399E  2002      10602          move.l    D2,D0
000039A0  0680 0000 10603          add.l     #22,D0
000039A4  0016      
000039A6  2040      10604          move.l    D0,A0
000039A8  5350      10605          subq.w    #1,(A0)
                    10606   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
000039AA  2042      10607          move.l    D2,A0
000039AC  2242      10608          move.l    D2,A1
000039AE  2028 0010 10609          move.l    16(A0),D0
000039B2  B0A9 0008 10610          cmp.l     8(A1),D0
000039B6  660A      10611          bne.s     OSQAccept_6
                    10612   ; pq->OSQOut = pq->OSQStart;
000039B8  2042      10613          move.l    D2,A0
000039BA  2242      10614          move.l    D2,A1
000039BC  2368 0004 10615          move.l    4(A0),16(A1)
000039C0  0010      
                    10616   OSQAccept_6:
                    10617   ; }
                    10618   ; *perr = OS_ERR_NONE;
000039C2  2044      10619          move.l    D4,A0
000039C4  4210      10620          clr.b     (A0)
000039C6  6008      10621          bra.s     OSQAccept_5
                    10622   OSQAccept_4:
                    10623   ; } else {
                    10624   ; *perr = OS_ERR_Q_EMPTY;
000039C8  2044      10625          move.l    D4,A0
000039CA  10BC 001F 10626          move.b    #31,(A0)
                    10627   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
000039CE  4283      10628          clr.l     D3
                    10629   OSQAccept_5:
                    10630   ; }
                    10631   ; OS_EXIT_CRITICAL();
000039D0  46DF      10632          dc.w      18143
                    10633   ; return (pmsg);                               /* Return message received (or NULL)                  */
000039D2  2003      10634          move.l    D3,D0
                    10635   OSQAccept_3:
000039D4  4CDF 001C 10636          movem.l   (A7)+,D2/D3/D4
000039D8  4E5E      10637          unlk      A6
000039DA  4E75      10638          rts
                    10639   ; }
                    10640   ; #endif
                    10641   ; /*$PAGE*/
                    10642   ; /*
                    10643   ; *********************************************************************************************************
                    10644   ; *                                       CREATE A MESSAGE QUEUE
                    10645   ; *
                    10646   ; * Description: This function creates a message queue if free event control blocks are available.
                    10647   ; *
                    10648   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    10649   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    10650   ; *
                    10651   ; *                            void *MessageStorage[size]
                    10652   ; *
                    10653   ; *              size          is the number of elements in the storage area
                    10654   ; *
                    10655   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    10656   ; *                                created queue
                    10657   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    10658   ; *********************************************************************************************************
                    10659   ; */
                    10660   ; OS_EVENT  *OSQCreate (void    **start,
                    10661   ; INT16U    size)
                    10662   ; {
                    10663   _OSQCreate:
000039DC  4E56 0000 10664          link      A6,#0
000039E0  48E7 3830 10665          movem.l   D2/D3/D4/A2/A3,-(A7)
000039E4  45F9 0800 10666          lea       _OSEventFreeList.L,A2
000039E8  0CDA      
000039EA  282E 0008 10667          move.l    8(A6),D4
000039EE  47F9 0800 10668          lea       _OSQFreeList.L,A3
000039F2  1910      
                    10669   ; OS_EVENT  *pevent;
                    10670   ; OS_Q      *pq;
                    10671   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10672   ; OS_CPU_SR  cpu_sr = 0u;
                    10673   ; #endif
                    10674   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10675   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10676   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10677   ; return ((OS_EVENT *)0);
                    10678   ; }
                    10679   ; #endif
                    10680   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000039F4  1039 0800 10681          move.b    _OSIntNesting.L,D0
000039F8  0F06      
000039FA  0C00 0000 10682          cmp.b     #0,D0
000039FE  6306      10683          bls.s     OSQCreate_1
                    10684   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00003A00  4280      10685          clr.l     D0
00003A02  6000 009C 10686          bra       OSQCreate_3
                    10687   OSQCreate_1:
                    10688   ; }
                    10689   ; OS_ENTER_CRITICAL();
00003A06  40E7      10690          dc.w      16615
00003A08  007C      10691          dc.w      124
00003A0A  0700      10692          dc.w      1792
                    10693   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
00003A0C  2412      10694          move.l    (A2),D2
                    10695   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
00003A0E  2012      10696          move.l    (A2),D0
00003A10  6706      10697          beq.s     OSQCreate_4
                    10698   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00003A12  2052      10699          move.l    (A2),A0
00003A14  24A8 0002 10700          move.l    2(A0),(A2)
                    10701   OSQCreate_4:
                    10702   ; }
                    10703   ; OS_EXIT_CRITICAL();
00003A18  46DF      10704          dc.w      18143
                    10705   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
00003A1A  4A82      10706          tst.l     D2
00003A1C  6700 0080 10707          beq       OSQCreate_9
                    10708   ; OS_ENTER_CRITICAL();
00003A20  40E7      10709          dc.w      16615
00003A22  007C      10710          dc.w      124
00003A24  0700      10711          dc.w      1792
                    10712   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
00003A26  2613      10713          move.l    (A3),D3
                    10714   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
00003A28  4A83      10715          tst.l     D3
00003A2A  6700 0066 10716          beq       OSQCreate_8
                    10717   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
00003A2E  2053      10718          move.l    (A3),A0
00003A30  2690      10719          move.l    (A0),(A3)
                    10720   ; OS_EXIT_CRITICAL();
00003A32  46DF      10721          dc.w      18143
                    10722   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
00003A34  2043      10723          move.l    D3,A0
00003A36  2144 0004 10724          move.l    D4,4(A0)
                    10725   ; pq->OSQEnd             = &start[size];
00003A3A  2004      10726          move.l    D4,D0
00003A3C  322E 000E 10727          move.w    14(A6),D1
00003A40  C2BC 0000 10728          and.l     #65535,D1
00003A44  FFFF      
00003A46  E589      10729          lsl.l     #2,D1
00003A48  D081      10730          add.l     D1,D0
00003A4A  2043      10731          move.l    D3,A0
00003A4C  2140 0008 10732          move.l    D0,8(A0)
                    10733   ; pq->OSQIn              = start;
00003A50  2043      10734          move.l    D3,A0
00003A52  2144 000C 10735          move.l    D4,12(A0)
                    10736   ; pq->OSQOut             = start;
00003A56  2043      10737          move.l    D3,A0
00003A58  2144 0010 10738          move.l    D4,16(A0)
                    10739   ; pq->OSQSize            = size;
00003A5C  2043      10740          move.l    D3,A0
00003A5E  316E 000E 10741          move.w    14(A6),20(A0)
00003A62  0014      
                    10742   ; pq->OSQEntries         = 0u;
00003A64  2043      10743          move.l    D3,A0
00003A66  4268 0016 10744          clr.w     22(A0)
                    10745   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
00003A6A  2042      10746          move.l    D2,A0
00003A6C  10BC 0002 10747          move.b    #2,(A0)
                    10748   ; pevent->OSEventCnt     = 0u;
00003A70  2042      10749          move.l    D2,A0
00003A72  4268 0006 10750          clr.w     6(A0)
                    10751   ; pevent->OSEventPtr     = pq;
00003A76  2042      10752          move.l    D2,A0
00003A78  2143 0002 10753          move.l    D3,2(A0)
                    10754   ; #if OS_EVENT_NAME_EN > 0u
                    10755   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003A7C  41F9 0000 10756          lea       @ucos_ii_1.L,A0
00003A80  6AD0      
00003A82  2242      10757          move.l    D2,A1
00003A84  2348 0012 10758          move.l    A0,18(A1)
                    10759   ; #endif
                    10760   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
00003A88  2F02      10761          move.l    D2,-(A7)
00003A8A  4EB8 170A 10762          jsr       _OS_EventWaitListInit
00003A8E  584F      10763          addq.w    #4,A7
00003A90  600C      10764          bra.s     OSQCreate_9
                    10765   OSQCreate_8:
                    10766   ; } else {
                    10767   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
00003A92  2042      10768          move.l    D2,A0
00003A94  2152 0002 10769          move.l    (A2),2(A0)
                    10770   ; OSEventFreeList    = pevent;
00003A98  2482      10771          move.l    D2,(A2)
                    10772   ; OS_EXIT_CRITICAL();
00003A9A  46DF      10773          dc.w      18143
                    10774   ; pevent = (OS_EVENT *)0;
00003A9C  4282      10775          clr.l     D2
                    10776   OSQCreate_9:
                    10777   ; }
                    10778   ; }
                    10779   ; return (pevent);
00003A9E  2002      10780          move.l    D2,D0
                    10781   OSQCreate_3:
00003AA0  4CDF 0C1C 10782          movem.l   (A7)+,D2/D3/D4/A2/A3
00003AA4  4E5E      10783          unlk      A6
00003AA6  4E75      10784          rts
                    10785   ; }
                    10786   ; /*$PAGE*/
                    10787   ; /*
                    10788   ; *********************************************************************************************************
                    10789   ; *                                       DELETE A MESSAGE QUEUE
                    10790   ; *
                    10791   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10792   ; *
                    10793   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10794   ; *                            queue.
                    10795   ; *
                    10796   ; *              opt           determines delete options as follows:
                    10797   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10798   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10799   ; *                                                    In this case, all the tasks pending will be readied.
                    10800   ; *
                    10801   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10802   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10803   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10804   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10805   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10806   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10807   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10808   ; *
                    10809   ; * Returns    : pevent        upon error
                    10810   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10811   ; *
                    10812   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10813   ; *                 the queue MUST check the return code of OSQPend().
                    10814   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10815   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10816   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10817   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10818   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10819   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10820   ; *                 will no longer be guarded by the queue.
                    10821   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10822   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10823   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10824   ; *                 then, the storage can be reused.
                    10825   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10826   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10827   ; *********************************************************************************************************
                    10828   ; */
                    10829   ; #if OS_Q_DEL_EN > 0u
                    10830   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10831   ; INT8U      opt,
                    10832   ; INT8U     *perr)
                    10833   ; {
                    10834   _OSQDel:
00003AA8  4E56 0000 10835          link      A6,#0
00003AAC  48E7 3E30 10836          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
00003AB0  242E 0008 10837          move.l    8(A6),D2
00003AB4  282E 0010 10838          move.l    16(A6),D4
00003AB8  45F9 0800 10839          lea       _OSEventFreeList.L,A2
00003ABC  0CDA      
00003ABE  47F9 0800 10840          lea       _OSQFreeList.L,A3
00003AC2  1910      
                    10841   ; BOOLEAN    tasks_waiting;
                    10842   ; OS_EVENT  *pevent_return;
                    10843   ; OS_Q      *pq;
                    10844   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10845   ; OS_CPU_SR  cpu_sr = 0u;
                    10846   ; #endif
                    10847   ; #ifdef OS_SAFETY_CRITICAL
                    10848   ; if (perr == (INT8U *)0) {
                    10849   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10850   ; return ((OS_EVENT *)0);
                    10851   ; }
                    10852   ; #endif
                    10853   ; #if OS_ARG_CHK_EN > 0u
                    10854   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10855   ; *perr = OS_ERR_PEVENT_NULL;
                    10856   ; return (pevent);
                    10857   ; }
                    10858   ; #endif
                    10859   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00003AC4  2042      10860          move.l    D2,A0
00003AC6  1010      10861          move.b    (A0),D0
00003AC8  0C00 0002 10862          cmp.b     #2,D0
00003ACC  670C      10863          beq.s     OSQDel_1
                    10864   ; *perr = OS_ERR_EVENT_TYPE;
00003ACE  2044      10865          move.l    D4,A0
00003AD0  10BC 0001 10866          move.b    #1,(A0)
                    10867   ; return (pevent);
00003AD4  2002      10868          move.l    D2,D0
00003AD6  6000 0104 10869          bra       OSQDel_3
                    10870   OSQDel_1:
                    10871   ; }
                    10872   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003ADA  1039 0800 10873          move.b    _OSIntNesting.L,D0
00003ADE  0F06      
00003AE0  0C00 0000 10874          cmp.b     #0,D0
00003AE4  630C      10875          bls.s     OSQDel_4
                    10876   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00003AE6  2044      10877          move.l    D4,A0
00003AE8  10BC 000F 10878          move.b    #15,(A0)
                    10879   ; return (pevent);
00003AEC  2002      10880          move.l    D2,D0
00003AEE  6000 00EC 10881          bra       OSQDel_3
                    10882   OSQDel_4:
                    10883   ; }
                    10884   ; OS_ENTER_CRITICAL();
00003AF2  40E7      10885          dc.w      16615
00003AF4  007C      10886          dc.w      124
00003AF6  0700      10887          dc.w      1792
                    10888   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
00003AF8  2042      10889          move.l    D2,A0
00003AFA  1028 0008 10890          move.b    8(A0),D0
00003AFE  6704      10891          beq.s     OSQDel_6
                    10892   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003B00  7C01      10893          moveq     #1,D6
00003B02  6002      10894          bra.s     OSQDel_7
                    10895   OSQDel_6:
                    10896   ; } else {
                    10897   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00003B04  4206      10898          clr.b     D6
                    10899   OSQDel_7:
                    10900   ; }
                    10901   ; switch (opt) {
00003B06  102E 000F 10902          move.b    15(A6),D0
00003B0A  C0BC 0000 10903          and.l     #255,D0
00003B0E  00FF      
00003B10  0C80 0000 10904          cmp.l     #1,D0
00003B14  0001      
00003B16  6700 0056 10905          beq       OSQDel_11
00003B1A  6200 00B4 10906          bhi       OSQDel_8
00003B1E  4A80      10907          tst.l     D0
00003B20  6704      10908          beq.s     OSQDel_10
00003B22  6000 00AC 10909          bra       OSQDel_8
                    10910   OSQDel_10:
                    10911   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10912   ; if (tasks_waiting == OS_FALSE) {
00003B26  4A06      10913          tst.b     D6
00003B28  6600 0036 10914          bne       OSQDel_13
                    10915   ; #if OS_EVENT_NAME_EN > 0u
                    10916   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003B2C  41F9 0000 10917          lea       @ucos_ii_1.L,A0
00003B30  6AD0      
00003B32  2242      10918          move.l    D2,A1
00003B34  2348 0012 10919          move.l    A0,18(A1)
                    10920   ; #endif
                    10921   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
00003B38  2042      10922          move.l    D2,A0
00003B3A  2628 0002 10923          move.l    2(A0),D3
                    10924   ; pq->OSQPtr             = OSQFreeList;
00003B3E  2043      10925          move.l    D3,A0
00003B40  2093      10926          move.l    (A3),(A0)
                    10927   ; OSQFreeList            = pq;
00003B42  2683      10928          move.l    D3,(A3)
                    10929   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003B44  2042      10930          move.l    D2,A0
00003B46  4210      10931          clr.b     (A0)
                    10932   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003B48  2042      10933          move.l    D2,A0
00003B4A  2152 0002 10934          move.l    (A2),2(A0)
                    10935   ; pevent->OSEventCnt     = 0u;
00003B4E  2042      10936          move.l    D2,A0
00003B50  4268 0006 10937          clr.w     6(A0)
                    10938   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003B54  2482      10939          move.l    D2,(A2)
                    10940   ; OS_EXIT_CRITICAL();
00003B56  46DF      10941          dc.w      18143
                    10942   ; *perr                  = OS_ERR_NONE;
00003B58  2044      10943          move.l    D4,A0
00003B5A  4210      10944          clr.b     (A0)
                    10945   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
00003B5C  4285      10946          clr.l     D5
00003B5E  600A      10947          bra.s     OSQDel_14
                    10948   OSQDel_13:
                    10949   ; } else {
                    10950   ; OS_EXIT_CRITICAL();
00003B60  46DF      10951          dc.w      18143
                    10952   ; *perr                  = OS_ERR_TASK_WAITING;
00003B62  2044      10953          move.l    D4,A0
00003B64  10BC 0049 10954          move.b    #73,(A0)
                    10955   ; pevent_return          = pevent;
00003B68  2A02      10956          move.l    D2,D5
                    10957   OSQDel_14:
                    10958   ; }
                    10959   ; break;
00003B6A  6000 006E 10960          bra       OSQDel_9
                    10961   OSQDel_11:
                    10962   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10963   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10964   OSQDel_15:
00003B6E  2042      10965          move.l    D2,A0
00003B70  1028 0008 10966          move.b    8(A0),D0
00003B74  671C      10967          beq.s     OSQDel_17
                    10968   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003B76  4878 0002 10969          pea       2
00003B7A  4878 0004 10970          pea       4
00003B7E  42A7      10971          clr.l     -(A7)
00003B80  2F02      10972          move.l    D2,-(A7)
00003B82  4EB8 1442 10973          jsr       _OS_EventTaskRdy
00003B86  DEFC 0010 10974          add.w     #16,A7
00003B8A  C0BC 0000 10975          and.l     #255,D0
00003B8E  00FF      
00003B90  60DC      10976          bra       OSQDel_15
                    10977   OSQDel_17:
                    10978   ; }
                    10979   ; #if OS_EVENT_NAME_EN > 0u
                    10980   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003B92  41F9 0000 10981          lea       @ucos_ii_1.L,A0
00003B96  6AD0      
00003B98  2242      10982          move.l    D2,A1
00003B9A  2348 0012 10983          move.l    A0,18(A1)
                    10984   ; #endif
                    10985   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003B9E  2042      10986          move.l    D2,A0
00003BA0  2628 0002 10987          move.l    2(A0),D3
                    10988   ; pq->OSQPtr             = OSQFreeList;
00003BA4  2043      10989          move.l    D3,A0
00003BA6  2093      10990          move.l    (A3),(A0)
                    10991   ; OSQFreeList            = pq;
00003BA8  2683      10992          move.l    D3,(A3)
                    10993   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003BAA  2042      10994          move.l    D2,A0
00003BAC  4210      10995          clr.b     (A0)
                    10996   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003BAE  2042      10997          move.l    D2,A0
00003BB0  2152 0002 10998          move.l    (A2),2(A0)
                    10999   ; pevent->OSEventCnt     = 0u;
00003BB4  2042      11000          move.l    D2,A0
00003BB6  4268 0006 11001          clr.w     6(A0)
                    11002   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003BBA  2482      11003          move.l    D2,(A2)
                    11004   ; OS_EXIT_CRITICAL();
00003BBC  46DF      11005          dc.w      18143
                    11006   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003BBE  0C06 0001 11007          cmp.b     #1,D6
00003BC2  6604      11008          bne.s     OSQDel_18
                    11009   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003BC4  4EB8 1A22 11010          jsr       _OS_Sched
                    11011   OSQDel_18:
                    11012   ; }
                    11013   ; *perr                  = OS_ERR_NONE;
00003BC8  2044      11014          move.l    D4,A0
00003BCA  4210      11015          clr.b     (A0)
                    11016   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
00003BCC  4285      11017          clr.l     D5
                    11018   ; break;
00003BCE  600A      11019          bra.s     OSQDel_9
                    11020   OSQDel_8:
                    11021   ; default:
                    11022   ; OS_EXIT_CRITICAL();
00003BD0  46DF      11023          dc.w      18143
                    11024   ; *perr                  = OS_ERR_INVALID_OPT;
00003BD2  2044      11025          move.l    D4,A0
00003BD4  10BC 0007 11026          move.b    #7,(A0)
                    11027   ; pevent_return          = pevent;
00003BD8  2A02      11028          move.l    D2,D5
                    11029   ; break;
                    11030   OSQDel_9:
                    11031   ; }
                    11032   ; return (pevent_return);
00003BDA  2005      11033          move.l    D5,D0
                    11034   OSQDel_3:
00003BDC  4CDF 0C7C 11035          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
00003BE0  4E5E      11036          unlk      A6
00003BE2  4E75      11037          rts
                    11038   ; }
                    11039   ; #endif
                    11040   ; /*$PAGE*/
                    11041   ; /*
                    11042   ; *********************************************************************************************************
                    11043   ; *                                             FLUSH QUEUE
                    11044   ; *
                    11045   ; * Description : This function is used to flush the contents of the message queue.
                    11046   ; *
                    11047   ; * Arguments   : none
                    11048   ; *
                    11049   ; * Returns     : OS_ERR_NONE         upon success
                    11050   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    11051   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    11052   ; *
                    11053   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    11054   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    11055   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    11056   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    11057   ; *********************************************************************************************************
                    11058   ; */
                    11059   ; #if OS_Q_FLUSH_EN > 0u
                    11060   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    11061   ; {
                    11062   _OSQFlush:
00003BE4  4E56 0000 11063          link      A6,#0
00003BE8  2F02      11064          move.l    D2,-(A7)
                    11065   ; OS_Q      *pq;
                    11066   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11067   ; OS_CPU_SR  cpu_sr = 0u;
                    11068   ; #endif
                    11069   ; #if OS_ARG_CHK_EN > 0u
                    11070   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11071   ; return (OS_ERR_PEVENT_NULL);
                    11072   ; }
                    11073   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    11074   ; return (OS_ERR_EVENT_TYPE);
                    11075   ; }
                    11076   ; #endif
                    11077   ; OS_ENTER_CRITICAL();
00003BEA  40E7      11078          dc.w      16615
00003BEC  007C      11079          dc.w      124
00003BEE  0700      11080          dc.w      1792
                    11081   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
00003BF0  206E 0008 11082          move.l    8(A6),A0
00003BF4  2428 0002 11083          move.l    2(A0),D2
                    11084   ; pq->OSQIn      = pq->OSQStart;
00003BF8  2042      11085          move.l    D2,A0
00003BFA  2242      11086          move.l    D2,A1
00003BFC  2368 0004 11087          move.l    4(A0),12(A1)
00003C00  000C      
                    11088   ; pq->OSQOut     = pq->OSQStart;
00003C02  2042      11089          move.l    D2,A0
00003C04  2242      11090          move.l    D2,A1
00003C06  2368 0004 11091          move.l    4(A0),16(A1)
00003C0A  0010      
                    11092   ; pq->OSQEntries = 0u;
00003C0C  2042      11093          move.l    D2,A0
00003C0E  4268 0016 11094          clr.w     22(A0)
                    11095   ; OS_EXIT_CRITICAL();
00003C12  46DF      11096          dc.w      18143
                    11097   ; return (OS_ERR_NONE);
00003C14  4200      11098          clr.b     D0
00003C16  241F      11099          move.l    (A7)+,D2
00003C18  4E5E      11100          unlk      A6
00003C1A  4E75      11101          rts
                    11102   ; }
                    11103   ; #endif
                    11104   ; /*$PAGE*/
                    11105   ; /*
                    11106   ; *********************************************************************************************************
                    11107   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    11108   ; *
                    11109   ; * Description: This function waits for a message to be sent to a queue
                    11110   ; *
                    11111   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11112   ; *
                    11113   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    11114   ; *                            wait for a message to arrive at the queue up to the amount of time
                    11115   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    11116   ; *                            forever at the specified queue or, until a message arrives.
                    11117   ; *
                    11118   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11119   ; *                            messages are:
                    11120   ; *
                    11121   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    11122   ; *                                                message.
                    11123   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    11124   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    11125   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    11126   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    11127   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    11128   ; *                                                would lead to a suspension.
                    11129   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    11130   ; *
                    11131   ; * Returns    : != (void *)0  is a pointer to the message received
                    11132   ; *              == (void *)0  if you received a NULL pointer message or,
                    11133   ; *                            if no message was received or,
                    11134   ; *                            if 'pevent' is a NULL pointer or,
                    11135   ; *                            if you didn't pass a pointer to a queue.
                    11136   ; *
                    11137   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    11138   ; *********************************************************************************************************
                    11139   ; */
                    11140   ; void  *OSQPend (OS_EVENT  *pevent,
                    11141   ; INT32U     timeout,
                    11142   ; INT8U     *perr)
                    11143   ; {
                    11144   _OSQPend:
00003C1C  4E56 0000 11145          link      A6,#0
00003C20  48E7 3C20 11146          movem.l   D2/D3/D4/D5/A2,-(A7)
00003C24  45F9 0800 11147          lea       _OSTCBCur.L,A2
00003C28  1020      
00003C2A  262E 0010 11148          move.l    16(A6),D3
00003C2E  2A2E 0008 11149          move.l    8(A6),D5
                    11150   ; void      *pmsg;
                    11151   ; OS_Q      *pq;
                    11152   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    11153   ; OS_CPU_SR  cpu_sr = 0u;
                    11154   ; #endif
                    11155   ; #ifdef OS_SAFETY_CRITICAL
                    11156   ; if (perr == (INT8U *)0) {
                    11157   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11158   ; return ((void *)0);
                    11159   ; }
                    11160   ; #endif
                    11161   ; #if OS_ARG_CHK_EN > 0u
                    11162   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    11163   ; *perr = OS_ERR_PEVENT_NULL;
                    11164   ; return ((void *)0);
                    11165   ; }
                    11166   ; #endif
                    11167   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003C32  2045      11168          move.l    D5,A0
00003C34  1010      11169          move.b    (A0),D0
00003C36  0C00 0002 11170          cmp.b     #2,D0
00003C3A  670C      11171          beq.s     OSQPend_1
                    11172   ; *perr = OS_ERR_EVENT_TYPE;
00003C3C  2043      11173          move.l    D3,A0
00003C3E  10BC 0001 11174          move.b    #1,(A0)
                    11175   ; return ((void *)0);
00003C42  4280      11176          clr.l     D0
00003C44  6000 0128 11177          bra       OSQPend_3
                    11178   OSQPend_1:
                    11179   ; }
                    11180   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00003C48  1039 0800 11181          move.b    _OSIntNesting.L,D0
00003C4C  0F06      
00003C4E  0C00 0000 11182          cmp.b     #0,D0
00003C52  630C      11183          bls.s     OSQPend_4
                    11184   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
00003C54  2043      11185          move.l    D3,A0
00003C56  10BC 0002 11186          move.b    #2,(A0)
                    11187   ; return ((void *)0);
00003C5A  4280      11188          clr.l     D0
00003C5C  6000 0110 11189          bra       OSQPend_3
                    11190   OSQPend_4:
                    11191   ; }
                    11192   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00003C60  1039 0800 11193          move.b    _OSLockNesting.L,D0
00003C64  0F08      
00003C66  0C00 0000 11194          cmp.b     #0,D0
00003C6A  630C      11195          bls.s     OSQPend_6
                    11196   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003C6C  2043      11197          move.l    D3,A0
00003C6E  10BC 000D 11198          move.b    #13,(A0)
                    11199   ; return ((void *)0);
00003C72  4280      11200          clr.l     D0
00003C74  6000 00F8 11201          bra       OSQPend_3
                    11202   OSQPend_6:
                    11203   ; }
                    11204   ; OS_ENTER_CRITICAL();
00003C78  40E7      11205          dc.w      16615
00003C7A  007C      11206          dc.w      124
00003C7C  0700      11207          dc.w      1792
                    11208   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003C7E  2045      11209          move.l    D5,A0
00003C80  2428 0002 11210          move.l    2(A0),D2
                    11211   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003C84  2042      11212          move.l    D2,A0
00003C86  3028 0016 11213          move.w    22(A0),D0
00003C8A  0C40 0000 11214          cmp.w     #0,D0
00003C8E  6300 0042 11215          bls       OSQPend_8
                    11216   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003C92  2002      11217          move.l    D2,D0
00003C94  0680 0000 11218          add.l     #16,D0
00003C98  0010      
00003C9A  2040      11219          move.l    D0,A0
00003C9C  2250      11220          move.l    (A0),A1
00003C9E  5890      11221          addq.l    #4,(A0)
00003CA0  2811      11222          move.l    (A1),D4
                    11223   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003CA2  2002      11224          move.l    D2,D0
00003CA4  0680 0000 11225          add.l     #22,D0
00003CA8  0016      
00003CAA  2040      11226          move.l    D0,A0
00003CAC  5350      11227          subq.w    #1,(A0)
                    11228   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003CAE  2042      11229          move.l    D2,A0
00003CB0  2242      11230          move.l    D2,A1
00003CB2  2028 0010 11231          move.l    16(A0),D0
00003CB6  B0A9 0008 11232          cmp.l     8(A1),D0
00003CBA  660A      11233          bne.s     OSQPend_10
                    11234   ; pq->OSQOut = pq->OSQStart;
00003CBC  2042      11235          move.l    D2,A0
00003CBE  2242      11236          move.l    D2,A1
00003CC0  2368 0004 11237          move.l    4(A0),16(A1)
00003CC4  0010      
                    11238   OSQPend_10:
                    11239   ; }
                    11240   ; OS_EXIT_CRITICAL();
00003CC6  46DF      11241          dc.w      18143
                    11242   ; *perr = OS_ERR_NONE;
00003CC8  2043      11243          move.l    D3,A0
00003CCA  4210      11244          clr.b     (A0)
                    11245   ; return (pmsg);                           /* Return message received                            */
00003CCC  2004      11246          move.l    D4,D0
00003CCE  6000 009E 11247          bra       OSQPend_3
                    11248   OSQPend_8:
                    11249   ; }
                    11250   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
00003CD2  2052      11251          move.l    (A2),A0
00003CD4  0028 0004 11252          or.b      #4,50(A0)
00003CD8  0032      
                    11253   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003CDA  2052      11254          move.l    (A2),A0
00003CDC  4228 0033 11255          clr.b     51(A0)
                    11256   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00003CE0  2052      11257          move.l    (A2),A0
00003CE2  216E 000C 11258          move.l    12(A6),46(A0)
00003CE6  002E      
                    11259   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
00003CE8  2F05      11260          move.l    D5,-(A7)
00003CEA  4EB8 1526 11261          jsr       _OS_EventTaskWait
00003CEE  584F      11262          addq.w    #4,A7
                    11263   ; OS_EXIT_CRITICAL();
00003CF0  46DF      11264          dc.w      18143
                    11265   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
00003CF2  4EB8 1A22 11266          jsr       _OS_Sched
                    11267   ; OS_ENTER_CRITICAL();
00003CF6  40E7      11268          dc.w      16615
00003CF8  007C      11269          dc.w      124
00003CFA  0700      11270          dc.w      1792
                    11271   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003CFC  2052      11272          move.l    (A2),A0
00003CFE  1028 0033 11273          move.b    51(A0),D0
00003D02  C0BC 0000 11274          and.l     #255,D0
00003D06  00FF      
00003D08  0C80 0000 11275          cmp.l     #1,D0
00003D0C  0001      
00003D0E  6700 002A 11276          beq       OSQPend_16
00003D12  6206      11277          bhi.s     OSQPend_18
00003D14  4A80      11278          tst.l     D0
00003D16  670C      11279          beq.s     OSQPend_14
00003D18  6020      11280          bra.s     OSQPend_16
                    11281   OSQPend_18:
00003D1A  0C80 0000 11282          cmp.l     #2,D0
00003D1E  0002      
00003D20  670E      11283          beq.s     OSQPend_15
00003D22  6016      11284          bra.s     OSQPend_16
                    11285   OSQPend_14:
                    11286   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    11287   ; pmsg =  OSTCBCur->OSTCBMsg;
00003D24  2052      11288          move.l    (A2),A0
00003D26  2828 0024 11289          move.l    36(A0),D4
                    11290   ; *perr =  OS_ERR_NONE;
00003D2A  2043      11291          move.l    D3,A0
00003D2C  4210      11292          clr.b     (A0)
                    11293   ; break;
00003D2E  601C      11294          bra.s     OSQPend_13
                    11295   OSQPend_15:
                    11296   ; case OS_STAT_PEND_ABORT:
                    11297   ; pmsg = (void *)0;
00003D30  4284      11298          clr.l     D4
                    11299   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00003D32  2043      11300          move.l    D3,A0
00003D34  10BC 000E 11301          move.b    #14,(A0)
                    11302   ; break;
00003D38  6012      11303          bra.s     OSQPend_13
                    11304   OSQPend_16:
                    11305   ; case OS_STAT_PEND_TO:
                    11306   ; default:
                    11307   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003D3A  2F05      11308          move.l    D5,-(A7)
00003D3C  2F12      11309          move.l    (A2),-(A7)
00003D3E  4EB8 1648 11310          jsr       _OS_EventTaskRemove
00003D42  504F      11311          addq.w    #8,A7
                    11312   ; pmsg = (void *)0;
00003D44  4284      11313          clr.l     D4
                    11314   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00003D46  2043      11315          move.l    D3,A0
00003D48  10BC 000A 11316          move.b    #10,(A0)
                    11317   ; break;
                    11318   OSQPend_13:
                    11319   ; }
                    11320   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003D4C  2052      11321          move.l    (A2),A0
00003D4E  4228 0032 11322          clr.b     50(A0)
                    11323   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003D52  2052      11324          move.l    (A2),A0
00003D54  4228 0033 11325          clr.b     51(A0)
                    11326   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003D58  2052      11327          move.l    (A2),A0
00003D5A  42A8 001C 11328          clr.l     28(A0)
                    11329   ; #if (OS_EVENT_MULTI_EN > 0u)
                    11330   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003D5E  2052      11331          move.l    (A2),A0
00003D60  42A8 0020 11332          clr.l     32(A0)
                    11333   ; #endif
                    11334   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00003D64  2052      11335          move.l    (A2),A0
00003D66  42A8 0024 11336          clr.l     36(A0)
                    11337   ; OS_EXIT_CRITICAL();
00003D6A  46DF      11338          dc.w      18143
                    11339   ; return (pmsg);                                    /* Return received message                       */
00003D6C  2004      11340          move.l    D4,D0
                    11341   OSQPend_3:
00003D6E  4CDF 043C 11342          movem.l   (A7)+,D2/D3/D4/D5/A2
00003D72  4E5E      11343          unlk      A6
00003D74  4E75      11344          rts
                    11345   ; }
                    11346   ; /*$PAGE*/
                    11347   ; /*
                    11348   ; *********************************************************************************************************
                    11349   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    11350   ; *
                    11351   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    11352   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    11353   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    11354   ; *
                    11355   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    11356   ; *
                    11357   ; *              opt           determines the type of ABORT performed:
                    11358   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    11359   ; *                                                     queue
                    11360   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    11361   ; *                                                     queue
                    11362   ; *
                    11363   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11364   ; *                            messages are:
                    11365   ; *
                    11366   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    11367   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    11368   ; *                                                and informed of the aborted wait; check return value
                    11369   ; *                                                for the number of tasks whose wait on the queue
                    11370   ; *                                                was aborted.
                    11371   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    11372   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11373   ; *
                    11374   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    11375   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    11376   ; *********************************************************************************************************
                    11377   ; */
                    11378   ; #if OS_Q_PEND_ABORT_EN > 0u
                    11379   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    11380   ; INT8U      opt,
                    11381   ; INT8U     *perr)
                    11382   ; {
                    11383   _OSQPendAbort:
00003D76  4E56 0000 11384          link      A6,#0
00003D7A  48E7 3800 11385          movem.l   D2/D3/D4,-(A7)
00003D7E  242E 0008 11386          move.l    8(A6),D2
00003D82  282E 0010 11387          move.l    16(A6),D4
                    11388   ; INT8U      nbr_tasks;
                    11389   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11390   ; OS_CPU_SR  cpu_sr = 0u;
                    11391   ; #endif
                    11392   ; #ifdef OS_SAFETY_CRITICAL
                    11393   ; if (perr == (INT8U *)0) {
                    11394   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11395   ; return (0u);
                    11396   ; }
                    11397   ; #endif
                    11398   ; #if OS_ARG_CHK_EN > 0u
                    11399   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11400   ; *perr = OS_ERR_PEVENT_NULL;
                    11401   ; return (0u);
                    11402   ; }
                    11403   ; #endif
                    11404   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00003D86  2042      11405          move.l    D2,A0
00003D88  1010      11406          move.b    (A0),D0
00003D8A  0C00 0002 11407          cmp.b     #2,D0
00003D8E  670C      11408          beq.s     OSQPendAbort_1
                    11409   ; *perr = OS_ERR_EVENT_TYPE;
00003D90  2044      11410          move.l    D4,A0
00003D92  10BC 0001 11411          move.b    #1,(A0)
                    11412   ; return (0u);
00003D96  4200      11413          clr.b     D0
00003D98  6000 008C 11414          bra       OSQPendAbort_3
                    11415   OSQPendAbort_1:
                    11416   ; }
                    11417   ; OS_ENTER_CRITICAL();
00003D9C  40E7      11418          dc.w      16615
00003D9E  007C      11419          dc.w      124
00003DA0  0700      11420          dc.w      1792
                    11421   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00003DA2  2042      11422          move.l    D2,A0
00003DA4  1028 0008 11423          move.b    8(A0),D0
00003DA8  6700 0074 11424          beq       OSQPendAbort_4
                    11425   ; nbr_tasks = 0u;
00003DAC  4203      11426          clr.b     D3
                    11427   ; switch (opt) {
00003DAE  102E 000F 11428          move.b    15(A6),D0
00003DB2  C0BC 0000 11429          and.l     #255,D0
00003DB6  00FF      
00003DB8  0C80 0000 11430          cmp.l     #1,D0
00003DBC  0001      
00003DBE  670A      11431          beq.s     OSQPendAbort_8
00003DC0  6200 0030 11432          bhi       OSQPendAbort_9
00003DC4  4A80      11433          tst.l     D0
00003DC6  672A      11434          beq.s     OSQPendAbort_9
00003DC8  6028      11435          bra.s     OSQPendAbort_9
                    11436   OSQPendAbort_8:
                    11437   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    11438   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    11439   OSQPendAbort_11:
00003DCA  2042      11440          move.l    D2,A0
00003DCC  1028 0008 11441          move.b    8(A0),D0
00003DD0  671E      11442          beq.s     OSQPendAbort_13
                    11443   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003DD2  4878 0002 11444          pea       2
00003DD6  4878 0004 11445          pea       4
00003DDA  42A7      11446          clr.l     -(A7)
00003DDC  2F02      11447          move.l    D2,-(A7)
00003DDE  4EB8 1442 11448          jsr       _OS_EventTaskRdy
00003DE2  DEFC 0010 11449          add.w     #16,A7
00003DE6  C0BC 0000 11450          and.l     #255,D0
00003DEA  00FF      
                    11451   ; nbr_tasks++;
00003DEC  5203      11452          addq.b    #1,D3
00003DEE  60DA      11453          bra       OSQPendAbort_11
                    11454   OSQPendAbort_13:
                    11455   ; }
                    11456   ; break;
00003DF0  601C      11457          bra.s     OSQPendAbort_7
                    11458   OSQPendAbort_9:
                    11459   ; case OS_PEND_OPT_NONE:
                    11460   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    11461   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003DF2  4878 0002 11462          pea       2
00003DF6  4878 0004 11463          pea       4
00003DFA  42A7      11464          clr.l     -(A7)
00003DFC  2F02      11465          move.l    D2,-(A7)
00003DFE  4EB8 1442 11466          jsr       _OS_EventTaskRdy
00003E02  DEFC 0010 11467          add.w     #16,A7
00003E06  C0BC 0000 11468          and.l     #255,D0
00003E0A  00FF      
                    11469   ; nbr_tasks++;
00003E0C  5203      11470          addq.b    #1,D3
                    11471   ; break;
                    11472   OSQPendAbort_7:
                    11473   ; }
                    11474   ; OS_EXIT_CRITICAL();
00003E0E  46DF      11475          dc.w      18143
                    11476   ; OS_Sched();                                        /* Find HPT ready to run                    */
00003E10  4EB8 1A22 11477          jsr       _OS_Sched
                    11478   ; *perr = OS_ERR_PEND_ABORT;
00003E14  2044      11479          move.l    D4,A0
00003E16  10BC 000E 11480          move.b    #14,(A0)
                    11481   ; return (nbr_tasks);
00003E1A  1003      11482          move.b    D3,D0
00003E1C  6008      11483          bra.s     OSQPendAbort_3
                    11484   OSQPendAbort_4:
                    11485   ; }
                    11486   ; OS_EXIT_CRITICAL();
00003E1E  46DF      11487          dc.w      18143
                    11488   ; *perr = OS_ERR_NONE;
00003E20  2044      11489          move.l    D4,A0
00003E22  4210      11490          clr.b     (A0)
                    11491   ; return (0u);                                           /* No tasks waiting on queue                */
00003E24  4200      11492          clr.b     D0
                    11493   OSQPendAbort_3:
00003E26  4CDF 001C 11494          movem.l   (A7)+,D2/D3/D4
00003E2A  4E5E      11495          unlk      A6
00003E2C  4E75      11496          rts
                    11497   ; }
                    11498   ; #endif
                    11499   ; /*$PAGE*/
                    11500   ; /*
                    11501   ; *********************************************************************************************************
                    11502   ; *                                       POST MESSAGE TO A QUEUE
                    11503   ; *
                    11504   ; * Description: This function sends a message to a queue
                    11505   ; *
                    11506   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11507   ; *
                    11508   ; *              pmsg          is a pointer to the message to send.
                    11509   ; *
                    11510   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11511   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11512   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11513   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11514   ; *
                    11515   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11516   ; *********************************************************************************************************
                    11517   ; */
                    11518   ; #if OS_Q_POST_EN > 0u
                    11519   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    11520   ; void      *pmsg)
                    11521   ; {
                    11522   _OSQPost:
00003E2E  4E56 0000 11523          link      A6,#0
00003E32  48E7 3000 11524          movem.l   D2/D3,-(A7)
00003E36  262E 0008 11525          move.l    8(A6),D3
                    11526   ; OS_Q      *pq;
                    11527   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11528   ; OS_CPU_SR  cpu_sr = 0u;
                    11529   ; #endif
                    11530   ; #if OS_ARG_CHK_EN > 0u
                    11531   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11532   ; return (OS_ERR_PEVENT_NULL);
                    11533   ; }
                    11534   ; #endif
                    11535   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003E3A  2043      11536          move.l    D3,A0
00003E3C  1010      11537          move.b    (A0),D0
00003E3E  0C00 0002 11538          cmp.b     #2,D0
00003E42  6706      11539          beq.s     OSQPost_1
                    11540   ; return (OS_ERR_EVENT_TYPE);
00003E44  7001      11541          moveq     #1,D0
00003E46  6000 008C 11542          bra       OSQPost_3
                    11543   OSQPost_1:
                    11544   ; }
                    11545   ; OS_ENTER_CRITICAL();
00003E4A  40E7      11546          dc.w      16615
00003E4C  007C      11547          dc.w      124
00003E4E  0700      11548          dc.w      1792
                    11549   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003E50  2043      11550          move.l    D3,A0
00003E52  1028 0008 11551          move.b    8(A0),D0
00003E56  6726      11552          beq.s     OSQPost_4
                    11553   ; /* Ready highest priority task waiting on event */
                    11554   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003E58  42A7      11555          clr.l     -(A7)
00003E5A  4878 0004 11556          pea       4
00003E5E  2F2E 000C 11557          move.l    12(A6),-(A7)
00003E62  2F03      11558          move.l    D3,-(A7)
00003E64  4EB8 1442 11559          jsr       _OS_EventTaskRdy
00003E68  DEFC 0010 11560          add.w     #16,A7
00003E6C  C0BC 0000 11561          and.l     #255,D0
00003E70  00FF      
                    11562   ; OS_EXIT_CRITICAL();
00003E72  46DF      11563          dc.w      18143
                    11564   ; OS_Sched();                                    /* Find highest priority task ready to run      */
00003E74  4EB8 1A22 11565          jsr       _OS_Sched
                    11566   ; return (OS_ERR_NONE);
00003E78  4200      11567          clr.b     D0
00003E7A  6000 0058 11568          bra       OSQPost_3
                    11569   OSQPost_4:
                    11570   ; }
                    11571   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003E7E  2043      11572          move.l    D3,A0
00003E80  2428 0002 11573          move.l    2(A0),D2
                    11574   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
00003E84  2042      11575          move.l    D2,A0
00003E86  2242      11576          move.l    D2,A1
00003E88  3028 0016 11577          move.w    22(A0),D0
00003E8C  B069 0014 11578          cmp.w     20(A1),D0
00003E90  6508      11579          blo.s     OSQPost_6
                    11580   ; OS_EXIT_CRITICAL();
00003E92  46DF      11581          dc.w      18143
                    11582   ; return (OS_ERR_Q_FULL);
00003E94  701E      11583          moveq     #30,D0
00003E96  6000 003C 11584          bra       OSQPost_3
                    11585   OSQPost_6:
                    11586   ; }
                    11587   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003E9A  2002      11588          move.l    D2,D0
00003E9C  0680 0000 11589          add.l     #12,D0
00003EA0  000C      
00003EA2  2040      11590          move.l    D0,A0
00003EA4  2250      11591          move.l    (A0),A1
00003EA6  5890      11592          addq.l    #4,(A0)
00003EA8  22AE 000C 11593          move.l    12(A6),(A1)
                    11594   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003EAC  2002      11595          move.l    D2,D0
00003EAE  0680 0000 11596          add.l     #22,D0
00003EB2  0016      
00003EB4  2040      11597          move.l    D0,A0
00003EB6  5250      11598          addq.w    #1,(A0)
                    11599   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
00003EB8  2042      11600          move.l    D2,A0
00003EBA  2242      11601          move.l    D2,A1
00003EBC  2028 000C 11602          move.l    12(A0),D0
00003EC0  B0A9 0008 11603          cmp.l     8(A1),D0
00003EC4  660A      11604          bne.s     OSQPost_8
                    11605   ; pq->OSQIn = pq->OSQStart;
00003EC6  2042      11606          move.l    D2,A0
00003EC8  2242      11607          move.l    D2,A1
00003ECA  2368 0004 11608          move.l    4(A0),12(A1)
00003ECE  000C      
                    11609   OSQPost_8:
                    11610   ; }
                    11611   ; OS_EXIT_CRITICAL();
00003ED0  46DF      11612          dc.w      18143
                    11613   ; return (OS_ERR_NONE);
00003ED2  4200      11614          clr.b     D0
                    11615   OSQPost_3:
00003ED4  4CDF 000C 11616          movem.l   (A7)+,D2/D3
00003ED8  4E5E      11617          unlk      A6
00003EDA  4E75      11618          rts
                    11619   ; }
                    11620   ; #endif
                    11621   ; /*$PAGE*/
                    11622   ; /*
                    11623   ; *********************************************************************************************************
                    11624   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    11625   ; *
                    11626   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    11627   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    11628   ; *              'priority' messages.
                    11629   ; *
                    11630   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11631   ; *
                    11632   ; *              pmsg          is a pointer to the message to send.
                    11633   ; *
                    11634   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11635   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11636   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11637   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11638   ; *
                    11639   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11640   ; *********************************************************************************************************
                    11641   ; */
                    11642   ; #if OS_Q_POST_FRONT_EN > 0u
                    11643   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    11644   ; void      *pmsg)
                    11645   ; {
                    11646   _OSQPostFront:
00003EDC  4E56 0000 11647          link      A6,#0
00003EE0  48E7 3000 11648          movem.l   D2/D3,-(A7)
00003EE4  262E 0008 11649          move.l    8(A6),D3
                    11650   ; OS_Q      *pq;
                    11651   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11652   ; OS_CPU_SR  cpu_sr = 0u;
                    11653   ; #endif
                    11654   ; #if OS_ARG_CHK_EN > 0u
                    11655   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11656   ; return (OS_ERR_PEVENT_NULL);
                    11657   ; }
                    11658   ; #endif
                    11659   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003EE8  2043      11660          move.l    D3,A0
00003EEA  1010      11661          move.b    (A0),D0
00003EEC  0C00 0002 11662          cmp.b     #2,D0
00003EF0  6706      11663          beq.s     OSQPostFront_1
                    11664   ; return (OS_ERR_EVENT_TYPE);
00003EF2  7001      11665          moveq     #1,D0
00003EF4  6000 0090 11666          bra       OSQPostFront_3
                    11667   OSQPostFront_1:
                    11668   ; }
                    11669   ; OS_ENTER_CRITICAL();
00003EF8  40E7      11670          dc.w      16615
00003EFA  007C      11671          dc.w      124
00003EFC  0700      11672          dc.w      1792
                    11673   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00003EFE  2043      11674          move.l    D3,A0
00003F00  1028 0008 11675          move.b    8(A0),D0
00003F04  6726      11676          beq.s     OSQPostFront_4
                    11677   ; /* Ready highest priority task waiting on event  */
                    11678   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003F06  42A7      11679          clr.l     -(A7)
00003F08  4878 0004 11680          pea       4
00003F0C  2F2E 000C 11681          move.l    12(A6),-(A7)
00003F10  2F03      11682          move.l    D3,-(A7)
00003F12  4EB8 1442 11683          jsr       _OS_EventTaskRdy
00003F16  DEFC 0010 11684          add.w     #16,A7
00003F1A  C0BC 0000 11685          and.l     #255,D0
00003F1E  00FF      
                    11686   ; OS_EXIT_CRITICAL();
00003F20  46DF      11687          dc.w      18143
                    11688   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00003F22  4EB8 1A22 11689          jsr       _OS_Sched
                    11690   ; return (OS_ERR_NONE);
00003F26  4200      11691          clr.b     D0
00003F28  6000 005C 11692          bra       OSQPostFront_3
                    11693   OSQPostFront_4:
                    11694   ; }
                    11695   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003F2C  2043      11696          move.l    D3,A0
00003F2E  2428 0002 11697          move.l    2(A0),D2
                    11698   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003F32  2042      11699          move.l    D2,A0
00003F34  2242      11700          move.l    D2,A1
00003F36  3028 0016 11701          move.w    22(A0),D0
00003F3A  B069 0014 11702          cmp.w     20(A1),D0
00003F3E  6508      11703          blo.s     OSQPostFront_6
                    11704   ; OS_EXIT_CRITICAL();
00003F40  46DF      11705          dc.w      18143
                    11706   ; return (OS_ERR_Q_FULL);
00003F42  701E      11707          moveq     #30,D0
00003F44  6000 0040 11708          bra       OSQPostFront_3
                    11709   OSQPostFront_6:
                    11710   ; }
                    11711   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
00003F48  2042      11712          move.l    D2,A0
00003F4A  2242      11713          move.l    D2,A1
00003F4C  2028 0010 11714          move.l    16(A0),D0
00003F50  B0A9 0004 11715          cmp.l     4(A1),D0
00003F54  660A      11716          bne.s     OSQPostFront_8
                    11717   ; pq->OSQOut = pq->OSQEnd;
00003F56  2042      11718          move.l    D2,A0
00003F58  2242      11719          move.l    D2,A1
00003F5A  2368 0008 11720          move.l    8(A0),16(A1)
00003F5E  0010      
                    11721   OSQPostFront_8:
                    11722   ; }
                    11723   ; pq->OSQOut--;
00003F60  2002      11724          move.l    D2,D0
00003F62  0680 0000 11725          add.l     #16,D0
00003F66  0010      
00003F68  2040      11726          move.l    D0,A0
00003F6A  5990      11727          subq.l    #4,(A0)
                    11728   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003F6C  2042      11729          move.l    D2,A0
00003F6E  2068 0010 11730          move.l    16(A0),A0
00003F72  20AE 000C 11731          move.l    12(A6),(A0)
                    11732   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003F76  2002      11733          move.l    D2,D0
00003F78  0680 0000 11734          add.l     #22,D0
00003F7C  0016      
00003F7E  2040      11735          move.l    D0,A0
00003F80  5250      11736          addq.w    #1,(A0)
                    11737   ; OS_EXIT_CRITICAL();
00003F82  46DF      11738          dc.w      18143
                    11739   ; return (OS_ERR_NONE);
00003F84  4200      11740          clr.b     D0
                    11741   OSQPostFront_3:
00003F86  4CDF 000C 11742          movem.l   (A7)+,D2/D3
00003F8A  4E5E      11743          unlk      A6
00003F8C  4E75      11744          rts
                    11745   ; }
                    11746   ; #endif
                    11747   ; /*$PAGE*/
                    11748   ; /*
                    11749   ; *********************************************************************************************************
                    11750   ; *                                       POST MESSAGE TO A QUEUE
                    11751   ; *
                    11752   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11753   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11754   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11755   ; *
                    11756   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11757   ; *
                    11758   ; *              pmsg          is a pointer to the message to send.
                    11759   ; *
                    11760   ; *              opt           determines the type of POST performed:
                    11761   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11762   ; *                                                     (Identical to OSQPost())
                    11763   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11764   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11765   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11766   ; *
                    11767   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11768   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11769   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11770   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11771   ; *
                    11772   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11773   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11774   ; *********************************************************************************************************
                    11775   ; */
                    11776   ; #if OS_Q_POST_OPT_EN > 0u
                    11777   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11778   ; void      *pmsg,
                    11779   ; INT8U      opt)
                    11780   ; {
                    11781   _OSQPostOpt:
00003F8E  4E56 0000 11782          link      A6,#0
00003F92  48E7 3C00 11783          movem.l   D2/D3/D4/D5,-(A7)
00003F96  262E 0008 11784          move.l    8(A6),D3
00003F9A  282E 000C 11785          move.l    12(A6),D4
00003F9E  1A2E 0013 11786          move.b    19(A6),D5
00003FA2  CABC 0000 11787          and.l     #255,D5
00003FA6  00FF      
                    11788   ; OS_Q      *pq;
                    11789   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11790   ; OS_CPU_SR  cpu_sr = 0u;
                    11791   ; #endif
                    11792   ; #if OS_ARG_CHK_EN > 0u
                    11793   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11794   ; return (OS_ERR_PEVENT_NULL);
                    11795   ; }
                    11796   ; #endif
                    11797   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003FA8  2043      11798          move.l    D3,A0
00003FAA  1010      11799          move.b    (A0),D0
00003FAC  0C00 0002 11800          cmp.b     #2,D0
00003FB0  6706      11801          beq.s     OSQPostOpt_1
                    11802   ; return (OS_ERR_EVENT_TYPE);
00003FB2  7001      11803          moveq     #1,D0
00003FB4  6000 00F6 11804          bra       OSQPostOpt_3
                    11805   OSQPostOpt_1:
                    11806   ; }
                    11807   ; OS_ENTER_CRITICAL();
00003FB8  40E7      11808          dc.w      16615
00003FBA  007C      11809          dc.w      124
00003FBC  0700      11810          dc.w      1792
                    11811   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003FBE  2043      11812          move.l    D3,A0
00003FC0  1028 0008 11813          move.b    8(A0),D0
00003FC4  6700 005A 11814          beq       OSQPostOpt_4
                    11815   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00003FC8  1005      11816          move.b    D5,D0
00003FCA  C03C 0001 11817          and.b     #1,D0
00003FCE  6724      11818          beq.s     OSQPostOpt_6
                    11819   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11820   OSQPostOpt_8:
00003FD0  2043      11821          move.l    D3,A0
00003FD2  1028 0008 11822          move.b    8(A0),D0
00003FD6  671A      11823          beq.s     OSQPostOpt_10
                    11824   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003FD8  42A7      11825          clr.l     -(A7)
00003FDA  4878 0004 11826          pea       4
00003FDE  2F04      11827          move.l    D4,-(A7)
00003FE0  2F03      11828          move.l    D3,-(A7)
00003FE2  4EB8 1442 11829          jsr       _OS_EventTaskRdy
00003FE6  DEFC 0010 11830          add.w     #16,A7
00003FEA  C0BC 0000 11831          and.l     #255,D0
00003FEE  00FF      
00003FF0  60DE      11832          bra       OSQPostOpt_8
                    11833   OSQPostOpt_10:
00003FF2  6018      11834          bra.s     OSQPostOpt_7
                    11835   OSQPostOpt_6:
                    11836   ; }
                    11837   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11838   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003FF4  42A7      11839          clr.l     -(A7)
00003FF6  4878 0004 11840          pea       4
00003FFA  2F04      11841          move.l    D4,-(A7)
00003FFC  2F03      11842          move.l    D3,-(A7)
00003FFE  4EB8 1442 11843          jsr       _OS_EventTaskRdy
00004002  DEFC 0010 11844          add.w     #16,A7
00004006  C0BC 0000 11845          and.l     #255,D0
0000400A  00FF      
                    11846   OSQPostOpt_7:
                    11847   ; }
                    11848   ; OS_EXIT_CRITICAL();
0000400C  46DF      11849          dc.w      18143
                    11850   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
0000400E  1005      11851          move.b    D5,D0
00004010  C03C 0004 11852          and.b     #4,D0
00004014  6604      11853          bne.s     OSQPostOpt_11
                    11854   ; OS_Sched();                               /* Find highest priority task ready to run       */
00004016  4EB8 1A22 11855          jsr       _OS_Sched
                    11856   OSQPostOpt_11:
                    11857   ; }
                    11858   ; return (OS_ERR_NONE);
0000401A  4200      11859          clr.b     D0
0000401C  6000 008E 11860          bra       OSQPostOpt_3
                    11861   OSQPostOpt_4:
                    11862   ; }
                    11863   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00004020  2043      11864          move.l    D3,A0
00004022  2428 0002 11865          move.l    2(A0),D2
                    11866   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00004026  2042      11867          move.l    D2,A0
00004028  2242      11868          move.l    D2,A1
0000402A  3028 0016 11869          move.w    22(A0),D0
0000402E  B069 0014 11870          cmp.w     20(A1),D0
00004032  6508      11871          blo.s     OSQPostOpt_13
                    11872   ; OS_EXIT_CRITICAL();
00004034  46DF      11873          dc.w      18143
                    11874   ; return (OS_ERR_Q_FULL);
00004036  701E      11875          moveq     #30,D0
00004038  6000 0072 11876          bra       OSQPostOpt_3
                    11877   OSQPostOpt_13:
                    11878   ; }
                    11879   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
0000403C  1005      11880          move.b    D5,D0
0000403E  C03C 0002 11881          and.b     #2,D0
00004042  6700 0030 11882          beq       OSQPostOpt_15
                    11883   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00004046  2042      11884          move.l    D2,A0
00004048  2242      11885          move.l    D2,A1
0000404A  2028 0010 11886          move.l    16(A0),D0
0000404E  B0A9 0004 11887          cmp.l     4(A1),D0
00004052  660A      11888          bne.s     OSQPostOpt_17
                    11889   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00004054  2042      11890          move.l    D2,A0
00004056  2242      11891          move.l    D2,A1
00004058  2368 0008 11892          move.l    8(A0),16(A1)
0000405C  0010      
                    11893   OSQPostOpt_17:
                    11894   ; }
                    11895   ; pq->OSQOut--;
0000405E  2002      11896          move.l    D2,D0
00004060  0680 0000 11897          add.l     #16,D0
00004064  0010      
00004066  2040      11898          move.l    D0,A0
00004068  5990      11899          subq.l    #4,(A0)
                    11900   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
0000406A  2042      11901          move.l    D2,A0
0000406C  2068 0010 11902          move.l    16(A0),A0
00004070  2084      11903          move.l    D4,(A0)
00004072  6028      11904          bra.s     OSQPostOpt_19
                    11905   OSQPostOpt_15:
                    11906   ; } else {                                          /* No,  Post as FIFO                             */
                    11907   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00004074  2002      11908          move.l    D2,D0
00004076  0680 0000 11909          add.l     #12,D0
0000407A  000C      
0000407C  2040      11910          move.l    D0,A0
0000407E  2250      11911          move.l    (A0),A1
00004080  5890      11912          addq.l    #4,(A0)
00004082  2284      11913          move.l    D4,(A1)
                    11914   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00004084  2042      11915          move.l    D2,A0
00004086  2242      11916          move.l    D2,A1
00004088  2028 000C 11917          move.l    12(A0),D0
0000408C  B0A9 0008 11918          cmp.l     8(A1),D0
00004090  660A      11919          bne.s     OSQPostOpt_19
                    11920   ; pq->OSQIn = pq->OSQStart;
00004092  2042      11921          move.l    D2,A0
00004094  2242      11922          move.l    D2,A1
00004096  2368 0004 11923          move.l    4(A0),12(A1)
0000409A  000C      
                    11924   OSQPostOpt_19:
                    11925   ; }
                    11926   ; }
                    11927   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
0000409C  2002      11928          move.l    D2,D0
0000409E  0680 0000 11929          add.l     #22,D0
000040A2  0016      
000040A4  2040      11930          move.l    D0,A0
000040A6  5250      11931          addq.w    #1,(A0)
                    11932   ; OS_EXIT_CRITICAL();
000040A8  46DF      11933          dc.w      18143
                    11934   ; return (OS_ERR_NONE);
000040AA  4200      11935          clr.b     D0
                    11936   OSQPostOpt_3:
000040AC  4CDF 003C 11937          movem.l   (A7)+,D2/D3/D4/D5
000040B0  4E5E      11938          unlk      A6
000040B2  4E75      11939          rts
                    11940   ; }
                    11941   ; #endif
                    11942   ; /*$PAGE*/
                    11943   ; /*
                    11944   ; *********************************************************************************************************
                    11945   ; *                                        QUERY A MESSAGE QUEUE
                    11946   ; *
                    11947   ; * Description: This function obtains information about a message queue.
                    11948   ; *
                    11949   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11950   ; *
                    11951   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11952   ; *                            queue.
                    11953   ; *
                    11954   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11955   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11956   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11957   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11958   ; *********************************************************************************************************
                    11959   ; */
                    11960   ; #if OS_Q_QUERY_EN > 0u
                    11961   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11962   ; OS_Q_DATA *p_q_data)
                    11963   ; {
                    11964   _OSQQuery:
000040B4  4E56 FFF8 11965          link      A6,#-8
000040B8  48E7 3C00 11966          movem.l   D2/D3/D4/D5,-(A7)
000040BC  242E 000C 11967          move.l    12(A6),D2
000040C0  282E 0008 11968          move.l    8(A6),D4
                    11969   ; OS_Q       *pq;
                    11970   ; INT8U       i;
                    11971   ; OS_PRIO    *psrc;
                    11972   ; OS_PRIO    *pdest;
                    11973   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11974   ; OS_CPU_SR   cpu_sr = 0u;
                    11975   ; #endif
                    11976   ; #if OS_ARG_CHK_EN > 0u
                    11977   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11978   ; return (OS_ERR_PEVENT_NULL);
                    11979   ; }
                    11980   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11981   ; return (OS_ERR_PDATA_NULL);
                    11982   ; }
                    11983   ; #endif
                    11984   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
000040C4  2044      11985          move.l    D4,A0
000040C6  1010      11986          move.b    (A0),D0
000040C8  0C00 0002 11987          cmp.b     #2,D0
000040CC  6706      11988          beq.s     OSQQuery_1
                    11989   ; return (OS_ERR_EVENT_TYPE);
000040CE  7001      11990          moveq     #1,D0
000040D0  6000 007A 11991          bra       OSQQuery_3
                    11992   OSQQuery_1:
                    11993   ; }
                    11994   ; OS_ENTER_CRITICAL();
000040D4  40E7      11995          dc.w      16615
000040D6  007C      11996          dc.w      124
000040D8  0700      11997          dc.w      1792
                    11998   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
000040DA  2044      11999          move.l    D4,A0
000040DC  2242      12000          move.l    D2,A1
000040DE  1368 0008 12001          move.b    8(A0),16(A1)
000040E2  0010      
                    12002   ; psrc                 = &pevent->OSEventTbl[0];
000040E4  700A      12003          moveq     #10,D0
000040E6  D084      12004          add.l     D4,D0
000040E8  2D40 FFF8 12005          move.l    D0,-8(A6)
                    12006   ; pdest                = &p_q_data->OSEventTbl[0];
000040EC  7008      12007          moveq     #8,D0
000040EE  D082      12008          add.l     D2,D0
000040F0  2D40 FFFC 12009          move.l    D0,-4(A6)
                    12010   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000040F4  4205      12011          clr.b     D5
                    12012   OSQQuery_4:
000040F6  0C05 0008 12013          cmp.b     #8,D5
000040FA  6416      12014          bhs.s     OSQQuery_6
                    12015   ; *pdest++ = *psrc++;
000040FC  206E FFF8 12016          move.l    -8(A6),A0
00004100  52AE FFF8 12017          addq.l    #1,-8(A6)
00004104  226E FFFC 12018          move.l    -4(A6),A1
00004108  52AE FFFC 12019          addq.l    #1,-4(A6)
0000410C  1290      12020          move.b    (A0),(A1)
0000410E  5205      12021          addq.b    #1,D5
00004110  60E4      12022          bra       OSQQuery_4
                    12023   OSQQuery_6:
                    12024   ; }
                    12025   ; pq = (OS_Q *)pevent->OSEventPtr;
00004112  2044      12026          move.l    D4,A0
00004114  2628 0002 12027          move.l    2(A0),D3
                    12028   ; if (pq->OSQEntries > 0u) {
00004118  2043      12029          move.l    D3,A0
0000411A  3028 0016 12030          move.w    22(A0),D0
0000411E  0C40 0000 12031          cmp.w     #0,D0
00004122  630C      12032          bls.s     OSQQuery_7
                    12033   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00004124  2043      12034          move.l    D3,A0
00004126  2068 0010 12035          move.l    16(A0),A0
0000412A  2242      12036          move.l    D2,A1
0000412C  2290      12037          move.l    (A0),(A1)
0000412E  6004      12038          bra.s     OSQQuery_8
                    12039   OSQQuery_7:
                    12040   ; } else {
                    12041   ; p_q_data->OSMsg = (void *)0;
00004130  2042      12042          move.l    D2,A0
00004132  4290      12043          clr.l     (A0)
                    12044   OSQQuery_8:
                    12045   ; }
                    12046   ; p_q_data->OSNMsgs = pq->OSQEntries;
00004134  2043      12047          move.l    D3,A0
00004136  2242      12048          move.l    D2,A1
00004138  3368 0016 12049          move.w    22(A0),4(A1)
0000413C  0004      
                    12050   ; p_q_data->OSQSize = pq->OSQSize;
0000413E  2043      12051          move.l    D3,A0
00004140  2242      12052          move.l    D2,A1
00004142  3368 0014 12053          move.w    20(A0),6(A1)
00004146  0006      
                    12054   ; OS_EXIT_CRITICAL();
00004148  46DF      12055          dc.w      18143
                    12056   ; return (OS_ERR_NONE);
0000414A  4200      12057          clr.b     D0
                    12058   OSQQuery_3:
0000414C  4CDF 003C 12059          movem.l   (A7)+,D2/D3/D4/D5
00004150  4E5E      12060          unlk      A6
00004152  4E75      12061          rts
                    12062   ; }
                    12063   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    12064   ; /*$PAGE*/
                    12065   ; /*
                    12066   ; *********************************************************************************************************
                    12067   ; *                                     QUEUE MODULE INITIALIZATION
                    12068   ; *
                    12069   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    12070   ; *               application MUST NOT call this function.
                    12071   ; *
                    12072   ; * Arguments   :  none
                    12073   ; *
                    12074   ; * Returns     : none
                    12075   ; *
                    12076   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    12077   ; *********************************************************************************************************
                    12078   ; */
                    12079   ; void  OS_QInit (void)
                    12080   ; {
                    12081   _OS_QInit:
00004154  4E56 FFF8 12082          link      A6,#-8
00004158  48E7 3020 12083          movem.l   D2/D3/A2,-(A7)
0000415C  45F9 0800 12084          lea       _OSQTbl.L,A2
00004160  1914      
                    12085   ; #if OS_MAX_QS == 1u
                    12086   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    12087   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    12088   ; #endif
                    12089   ; #if OS_MAX_QS >= 2u
                    12090   ; INT16U   ix;
                    12091   ; INT16U   ix_next;
                    12092   ; OS_Q    *pq1;
                    12093   ; OS_Q    *pq2;
                    12094   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00004162  4878 0060 12095          pea       96
00004166  2F0A      12096          move.l    A2,-(A7)
00004168  4EB8 19D6 12097          jsr       _OS_MemClr
0000416C  504F      12098          addq.w    #8,A7
                    12099   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
0000416E  4242      12100          clr.w     D2
                    12101   OS_QInit_1:
00004170  0C42 0003 12102          cmp.w     #3,D2
00004174  6400 003C 12103          bhs       OS_QInit_3
                    12104   ; ix_next = ix + 1u;
00004178  3002      12105          move.w    D2,D0
0000417A  5240      12106          addq.w    #1,D0
0000417C  3D40 FFFA 12107          move.w    D0,-6(A6)
                    12108   ; pq1 = &OSQTbl[ix];
00004180  200A      12109          move.l    A2,D0
00004182  C4BC 0000 12110          and.l     #65535,D2
00004186  FFFF      
00004188  2202      12111          move.l    D2,D1
0000418A  C3FC 0018 12112          muls      #24,D1
0000418E  D081      12113          add.l     D1,D0
00004190  2600      12114          move.l    D0,D3
                    12115   ; pq2 = &OSQTbl[ix_next];
00004192  200A      12116          move.l    A2,D0
00004194  322E FFFA 12117          move.w    -6(A6),D1
00004198  C2BC 0000 12118          and.l     #65535,D1
0000419C  FFFF      
0000419E  C3FC 0018 12119          muls      #24,D1
000041A2  D081      12120          add.l     D1,D0
000041A4  2D40 FFFC 12121          move.l    D0,-4(A6)
                    12122   ; pq1->OSQPtr = pq2;
000041A8  2043      12123          move.l    D3,A0
000041AA  20AE FFFC 12124          move.l    -4(A6),(A0)
000041AE  5242      12125          addq.w    #1,D2
000041B0  60BE      12126          bra       OS_QInit_1
                    12127   OS_QInit_3:
                    12128   ; }
                    12129   ; pq1         = &OSQTbl[ix];
000041B2  200A      12130          move.l    A2,D0
000041B4  C4BC 0000 12131          and.l     #65535,D2
000041B8  FFFF      
000041BA  2202      12132          move.l    D2,D1
000041BC  C3FC 0018 12133          muls      #24,D1
000041C0  D081      12134          add.l     D1,D0
000041C2  2600      12135          move.l    D0,D3
                    12136   ; pq1->OSQPtr = (OS_Q *)0;
000041C4  2043      12137          move.l    D3,A0
000041C6  4290      12138          clr.l     (A0)
                    12139   ; OSQFreeList = &OSQTbl[0];
000041C8  23CA 0800 12140          move.l    A2,_OSQFreeList.L
000041CC  1910      
000041CE  4CDF 040C 12141          movem.l   (A7)+,D2/D3/A2
000041D2  4E5E      12142          unlk      A6
000041D4  4E75      12143          rts
                    12144   ; /*
                    12145   ; *********************************************************************************************************
                    12146   ; *                                                uC/OS-II
                    12147   ; *                                          The Real-Time Kernel
                    12148   ; *                                          SEMAPHORE MANAGEMENT
                    12149   ; *
                    12150   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12151   ; *                                           All Rights Reserved
                    12152   ; *
                    12153   ; * File    : OS_SEM.C
                    12154   ; * By      : Jean J. Labrosse
                    12155   ; * Version : V2.92.07
                    12156   ; *
                    12157   ; * LICENSING TERMS:
                    12158   ; * ---------------
                    12159   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12160   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12161   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12162   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12163   ; * licensing fee.
                    12164   ; *********************************************************************************************************
                    12165   ; */
                    12166   ; #define  MICRIUM_SOURCE
                    12167   ; #ifndef  OS_MASTER_FILE
                    12168   ; #include <ucos_ii.h>
                    12169   ; #endif
                    12170   ; #if OS_SEM_EN > 0u
                    12171   ; /*$PAGE*/
                    12172   ; /*
                    12173   ; *********************************************************************************************************
                    12174   ; *                                          ACCEPT SEMAPHORE
                    12175   ; *
                    12176   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    12177   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    12178   ; *              resource is not available or the event did not occur.
                    12179   ; *
                    12180   ; * Arguments  : pevent     is a pointer to the event control block
                    12181   ; *
                    12182   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    12183   ; *                         decremented to obtain the resource.
                    12184   ; *              == 0       if the resource is not available or the event did not occur or,
                    12185   ; *                         if 'pevent' is a NULL pointer or,
                    12186   ; *                         if you didn't pass a pointer to a semaphore
                    12187   ; *********************************************************************************************************
                    12188   ; */
                    12189   ; #if OS_SEM_ACCEPT_EN > 0u
                    12190   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    12191   ; {
                    12192   _OSSemAccept:
000041D6  4E56 0000 12193          link      A6,#0
000041DA  48E7 3000 12194          movem.l   D2/D3,-(A7)
000041DE  262E 0008 12195          move.l    8(A6),D3
                    12196   ; INT16U     cnt;
                    12197   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12198   ; OS_CPU_SR  cpu_sr = 0u;
                    12199   ; #endif
                    12200   ; #if OS_ARG_CHK_EN > 0u
                    12201   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12202   ; return (0u);
                    12203   ; }
                    12204   ; #endif
                    12205   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000041E2  2043      12206          move.l    D3,A0
000041E4  1010      12207          move.b    (A0),D0
000041E6  0C00 0003 12208          cmp.b     #3,D0
000041EA  6704      12209          beq.s     OSSemAccept_1
                    12210   ; return (0u);
000041EC  4240      12211          clr.w     D0
000041EE  601E      12212          bra.s     OSSemAccept_3
                    12213   OSSemAccept_1:
                    12214   ; }
                    12215   ; OS_ENTER_CRITICAL();
000041F0  40E7      12216          dc.w      16615
000041F2  007C      12217          dc.w      124
000041F4  0700      12218          dc.w      1792
                    12219   ; cnt = pevent->OSEventCnt;
000041F6  2043      12220          move.l    D3,A0
000041F8  3428 0006 12221          move.w    6(A0),D2
                    12222   ; if (cnt > 0u) {                                   /* See if resource is available                  */
000041FC  0C42 0000 12223          cmp.w     #0,D2
00004200  6308      12224          bls.s     OSSemAccept_4
                    12225   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
00004202  2003      12226          move.l    D3,D0
00004204  5C80      12227          addq.l    #6,D0
00004206  2040      12228          move.l    D0,A0
00004208  5350      12229          subq.w    #1,(A0)
                    12230   OSSemAccept_4:
                    12231   ; }
                    12232   ; OS_EXIT_CRITICAL();
0000420A  46DF      12233          dc.w      18143
                    12234   ; return (cnt);                                     /* Return semaphore count                        */
0000420C  3002      12235          move.w    D2,D0
                    12236   OSSemAccept_3:
0000420E  4CDF 000C 12237          movem.l   (A7)+,D2/D3
00004212  4E5E      12238          unlk      A6
00004214  4E75      12239          rts
                    12240   ; }
                    12241   ; #endif
                    12242   ; /*$PAGE*/
                    12243   ; /*
                    12244   ; *********************************************************************************************************
                    12245   ; *                                         CREATE A SEMAPHORE
                    12246   ; *
                    12247   ; * Description: This function creates a semaphore.
                    12248   ; *
                    12249   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    12250   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    12251   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    12252   ; *                            10 resources, you would initialize the semaphore to 10).
                    12253   ; *
                    12254   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    12255   ; *                            created semaphore
                    12256   ; *              == (void *)0  if no event control blocks were available
                    12257   ; *********************************************************************************************************
                    12258   ; */
                    12259   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    12260   ; {
                    12261   _OSSemCreate:
00004216  4E56 0000 12262          link      A6,#0
0000421A  48E7 2020 12263          movem.l   D2/A2,-(A7)
0000421E  45F9 0800 12264          lea       _OSEventFreeList.L,A2
00004222  0CDA      
                    12265   ; OS_EVENT  *pevent;
                    12266   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12267   ; OS_CPU_SR  cpu_sr = 0u;
                    12268   ; #endif
                    12269   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    12270   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    12271   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12272   ; return ((OS_EVENT *)0);
                    12273   ; }
                    12274   ; #endif
                    12275   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00004224  1039 0800 12276          move.b    _OSIntNesting.L,D0
00004228  0F06      
0000422A  0C00 0000 12277          cmp.b     #0,D0
0000422E  6306      12278          bls.s     OSSemCreate_1
                    12279   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00004230  4280      12280          clr.l     D0
00004232  6000 0044 12281          bra       OSSemCreate_3
                    12282   OSSemCreate_1:
                    12283   ; }
                    12284   ; OS_ENTER_CRITICAL();
00004236  40E7      12285          dc.w      16615
00004238  007C      12286          dc.w      124
0000423A  0700      12287          dc.w      1792
                    12288   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
0000423C  2412      12289          move.l    (A2),D2
                    12290   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
0000423E  2012      12291          move.l    (A2),D0
00004240  6706      12292          beq.s     OSSemCreate_4
                    12293   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00004242  2052      12294          move.l    (A2),A0
00004244  24A8 0002 12295          move.l    2(A0),(A2)
                    12296   OSSemCreate_4:
                    12297   ; }
                    12298   ; OS_EXIT_CRITICAL();
00004248  46DF      12299          dc.w      18143
                    12300   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
0000424A  4A82      12301          tst.l     D2
0000424C  6728      12302          beq.s     OSSemCreate_6
                    12303   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
0000424E  2042      12304          move.l    D2,A0
00004250  10BC 0003 12305          move.b    #3,(A0)
                    12306   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00004254  2042      12307          move.l    D2,A0
00004256  316E 000A 12308          move.w    10(A6),6(A0)
0000425A  0006      
                    12309   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
0000425C  2042      12310          move.l    D2,A0
0000425E  42A8 0002 12311          clr.l     2(A0)
                    12312   ; #if OS_EVENT_NAME_EN > 0u
                    12313   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00004262  41F9 0000 12314          lea       @ucos_ii_1.L,A0
00004266  6AD0      
00004268  2242      12315          move.l    D2,A1
0000426A  2348 0012 12316          move.l    A0,18(A1)
                    12317   ; #endif
                    12318   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
0000426E  2F02      12319          move.l    D2,-(A7)
00004270  4EB8 170A 12320          jsr       _OS_EventWaitListInit
00004274  584F      12321          addq.w    #4,A7
                    12322   OSSemCreate_6:
                    12323   ; }
                    12324   ; return (pevent);
00004276  2002      12325          move.l    D2,D0
                    12326   OSSemCreate_3:
00004278  4CDF 0404 12327          movem.l   (A7)+,D2/A2
0000427C  4E5E      12328          unlk      A6
0000427E  4E75      12329          rts
                    12330   ; }
                    12331   ; /*$PAGE*/
                    12332   ; /*
                    12333   ; *********************************************************************************************************
                    12334   ; *                                         DELETE A SEMAPHORE
                    12335   ; *
                    12336   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    12337   ; *
                    12338   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12339   ; *                            semaphore.
                    12340   ; *
                    12341   ; *              opt           determines delete options as follows:
                    12342   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    12343   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    12344   ; *                                                    In this case, all the tasks pending will be readied.
                    12345   ; *
                    12346   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    12347   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    12348   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    12349   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    12350   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    12351   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    12352   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    12353   ; *
                    12354   ; * Returns    : pevent        upon error
                    12355   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    12356   ; *
                    12357   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    12358   ; *                 the semaphore MUST check the return code of OSSemPend().
                    12359   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    12360   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    12361   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    12362   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    12363   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    12364   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    12365   ; *                 will no longer be guarded by the semaphore.
                    12366   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    12367   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    12368   ; *********************************************************************************************************
                    12369   ; */
                    12370   ; #if OS_SEM_DEL_EN > 0u
                    12371   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    12372   ; INT8U      opt,
                    12373   ; INT8U     *perr)
                    12374   ; {
                    12375   _OSSemDel:
00004280  4E56 0000 12376          link      A6,#0
00004284  48E7 3C20 12377          movem.l   D2/D3/D4/D5/A2,-(A7)
00004288  242E 0008 12378          move.l    8(A6),D2
0000428C  262E 0010 12379          move.l    16(A6),D3
00004290  45F9 0800 12380          lea       _OSEventFreeList.L,A2
00004294  0CDA      
                    12381   ; BOOLEAN    tasks_waiting;
                    12382   ; OS_EVENT  *pevent_return;
                    12383   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12384   ; OS_CPU_SR  cpu_sr = 0u;
                    12385   ; #endif
                    12386   ; #ifdef OS_SAFETY_CRITICAL
                    12387   ; if (perr == (INT8U *)0) {
                    12388   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12389   ; return ((OS_EVENT *)0);
                    12390   ; }
                    12391   ; #endif
                    12392   ; #if OS_ARG_CHK_EN > 0u
                    12393   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12394   ; *perr = OS_ERR_PEVENT_NULL;
                    12395   ; return (pevent);
                    12396   ; }
                    12397   ; #endif
                    12398   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00004296  2042      12399          move.l    D2,A0
00004298  1010      12400          move.b    (A0),D0
0000429A  0C00 0003 12401          cmp.b     #3,D0
0000429E  670C      12402          beq.s     OSSemDel_1
                    12403   ; *perr = OS_ERR_EVENT_TYPE;
000042A0  2043      12404          move.l    D3,A0
000042A2  10BC 0001 12405          move.b    #1,(A0)
                    12406   ; return (pevent);
000042A6  2002      12407          move.l    D2,D0
000042A8  6000 00EA 12408          bra       OSSemDel_3
                    12409   OSSemDel_1:
                    12410   ; }
                    12411   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000042AC  1039 0800 12412          move.b    _OSIntNesting.L,D0
000042B0  0F06      
000042B2  0C00 0000 12413          cmp.b     #0,D0
000042B6  630C      12414          bls.s     OSSemDel_4
                    12415   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000042B8  2043      12416          move.l    D3,A0
000042BA  10BC 000F 12417          move.b    #15,(A0)
                    12418   ; return (pevent);
000042BE  2002      12419          move.l    D2,D0
000042C0  6000 00D2 12420          bra       OSSemDel_3
                    12421   OSSemDel_4:
                    12422   ; }
                    12423   ; OS_ENTER_CRITICAL();
000042C4  40E7      12424          dc.w      16615
000042C6  007C      12425          dc.w      124
000042C8  0700      12426          dc.w      1792
                    12427   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
000042CA  2042      12428          move.l    D2,A0
000042CC  1028 0008 12429          move.b    8(A0),D0
000042D0  6704      12430          beq.s     OSSemDel_6
                    12431   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000042D2  7A01      12432          moveq     #1,D5
000042D4  6002      12433          bra.s     OSSemDel_7
                    12434   OSSemDel_6:
                    12435   ; } else {
                    12436   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000042D6  4205      12437          clr.b     D5
                    12438   OSSemDel_7:
                    12439   ; }
                    12440   ; switch (opt) {
000042D8  102E 000F 12441          move.b    15(A6),D0
000042DC  C0BC 0000 12442          and.l     #255,D0
000042E0  00FF      
000042E2  0C80 0000 12443          cmp.l     #1,D0
000042E6  0001      
000042E8  6700 0048 12444          beq       OSSemDel_11
000042EC  6200 009A 12445          bhi       OSSemDel_8
000042F0  4A80      12446          tst.l     D0
000042F2  6704      12447          beq.s     OSSemDel_10
000042F4  6000 0092 12448          bra       OSSemDel_8
                    12449   OSSemDel_10:
                    12450   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    12451   ; if (tasks_waiting == OS_FALSE) {
000042F8  4A05      12452          tst.b     D5
000042FA  6628      12453          bne.s     OSSemDel_13
                    12454   ; #if OS_EVENT_NAME_EN > 0u
                    12455   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000042FC  41F9 0000 12456          lea       @ucos_ii_1.L,A0
00004300  6AD0      
00004302  2242      12457          move.l    D2,A1
00004304  2348 0012 12458          move.l    A0,18(A1)
                    12459   ; #endif
                    12460   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00004308  2042      12461          move.l    D2,A0
0000430A  4210      12462          clr.b     (A0)
                    12463   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
0000430C  2042      12464          move.l    D2,A0
0000430E  2152 0002 12465          move.l    (A2),2(A0)
                    12466   ; pevent->OSEventCnt     = 0u;
00004312  2042      12467          move.l    D2,A0
00004314  4268 0006 12468          clr.w     6(A0)
                    12469   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00004318  2482      12470          move.l    D2,(A2)
                    12471   ; OS_EXIT_CRITICAL();
0000431A  46DF      12472          dc.w      18143
                    12473   ; *perr                  = OS_ERR_NONE;
0000431C  2043      12474          move.l    D3,A0
0000431E  4210      12475          clr.b     (A0)
                    12476   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
00004320  4284      12477          clr.l     D4
00004322  600A      12478          bra.s     OSSemDel_14
                    12479   OSSemDel_13:
                    12480   ; } else {
                    12481   ; OS_EXIT_CRITICAL();
00004324  46DF      12482          dc.w      18143
                    12483   ; *perr                  = OS_ERR_TASK_WAITING;
00004326  2043      12484          move.l    D3,A0
00004328  10BC 0049 12485          move.b    #73,(A0)
                    12486   ; pevent_return          = pevent;
0000432C  2802      12487          move.l    D2,D4
                    12488   OSSemDel_14:
                    12489   ; }
                    12490   ; break;
0000432E  6000 0062 12491          bra       OSSemDel_9
                    12492   OSSemDel_11:
                    12493   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    12494   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    12495   OSSemDel_15:
00004332  2042      12496          move.l    D2,A0
00004334  1028 0008 12497          move.b    8(A0),D0
00004338  671C      12498          beq.s     OSSemDel_17
                    12499   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0000433A  4878 0002 12500          pea       2
0000433E  4878 0001 12501          pea       1
00004342  42A7      12502          clr.l     -(A7)
00004344  2F02      12503          move.l    D2,-(A7)
00004346  4EB8 1442 12504          jsr       _OS_EventTaskRdy
0000434A  DEFC 0010 12505          add.w     #16,A7
0000434E  C0BC 0000 12506          and.l     #255,D0
00004352  00FF      
00004354  60DC      12507          bra       OSSemDel_15
                    12508   OSSemDel_17:
                    12509   ; }
                    12510   ; #if OS_EVENT_NAME_EN > 0u
                    12511   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00004356  41F9 0000 12512          lea       @ucos_ii_1.L,A0
0000435A  6AD0      
0000435C  2242      12513          move.l    D2,A1
0000435E  2348 0012 12514          move.l    A0,18(A1)
                    12515   ; #endif
                    12516   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00004362  2042      12517          move.l    D2,A0
00004364  4210      12518          clr.b     (A0)
                    12519   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00004366  2042      12520          move.l    D2,A0
00004368  2152 0002 12521          move.l    (A2),2(A0)
                    12522   ; pevent->OSEventCnt     = 0u;
0000436C  2042      12523          move.l    D2,A0
0000436E  4268 0006 12524          clr.w     6(A0)
                    12525   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00004372  2482      12526          move.l    D2,(A2)
                    12527   ; OS_EXIT_CRITICAL();
00004374  46DF      12528          dc.w      18143
                    12529   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00004376  0C05 0001 12530          cmp.b     #1,D5
0000437A  6604      12531          bne.s     OSSemDel_18
                    12532   ; OS_Sched();                               /* Find highest priority task ready to run  */
0000437C  4EB8 1A22 12533          jsr       _OS_Sched
                    12534   OSSemDel_18:
                    12535   ; }
                    12536   ; *perr                  = OS_ERR_NONE;
00004380  2043      12537          move.l    D3,A0
00004382  4210      12538          clr.b     (A0)
                    12539   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00004384  4284      12540          clr.l     D4
                    12541   ; break;
00004386  600A      12542          bra.s     OSSemDel_9
                    12543   OSSemDel_8:
                    12544   ; default:
                    12545   ; OS_EXIT_CRITICAL();
00004388  46DF      12546          dc.w      18143
                    12547   ; *perr                  = OS_ERR_INVALID_OPT;
0000438A  2043      12548          move.l    D3,A0
0000438C  10BC 0007 12549          move.b    #7,(A0)
                    12550   ; pevent_return          = pevent;
00004390  2802      12551          move.l    D2,D4
                    12552   ; break;
                    12553   OSSemDel_9:
                    12554   ; }
                    12555   ; return (pevent_return);
00004392  2004      12556          move.l    D4,D0
                    12557   OSSemDel_3:
00004394  4CDF 043C 12558          movem.l   (A7)+,D2/D3/D4/D5/A2
00004398  4E5E      12559          unlk      A6
0000439A  4E75      12560          rts
                    12561   ; }
                    12562   ; #endif
                    12563   ; /*$PAGE*/
                    12564   ; /*
                    12565   ; *********************************************************************************************************
                    12566   ; *                                          PEND ON SEMAPHORE
                    12567   ; *
                    12568   ; * Description: This function waits for a semaphore.
                    12569   ; *
                    12570   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12571   ; *                            semaphore.
                    12572   ; *
                    12573   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    12574   ; *                            wait for the resource up to the amount of time specified by this argument.
                    12575   ; *                            If you specify 0, however, your task will wait forever at the specified
                    12576   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    12577   ; *
                    12578   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12579   ; *                            messages are:
                    12580   ; *
                    12581   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    12582   ; *                                                or, the event you are waiting for occurred.
                    12583   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    12584   ; *                                                'timeout'.
                    12585   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    12586   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12587   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    12588   ; *                                                would lead to a suspension.
                    12589   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12590   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    12591   ; *
                    12592   ; * Returns    : none
                    12593   ; *********************************************************************************************************
                    12594   ; */
                    12595   ; /*$PAGE*/
                    12596   ; void  OSSemPend (OS_EVENT  *pevent,
                    12597   ; INT32U     timeout,
                    12598   ; INT8U     *perr)
                    12599   ; {
                    12600   _OSSemPend:
0000439C  4E56 0000 12601          link      A6,#0
000043A0  48E7 3020 12602          movem.l   D2/D3/A2,-(A7)
000043A4  45F9 0800 12603          lea       _OSTCBCur.L,A2
000043A8  1020      
000043AA  242E 0010 12604          move.l    16(A6),D2
000043AE  262E 0008 12605          move.l    8(A6),D3
                    12606   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12607   ; OS_CPU_SR  cpu_sr = 0u;
                    12608   ; #endif
                    12609   ; #ifdef OS_SAFETY_CRITICAL
                    12610   ; if (perr == (INT8U *)0) {
                    12611   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12612   ; return;
                    12613   ; }
                    12614   ; #endif
                    12615   ; #if OS_ARG_CHK_EN > 0u
                    12616   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12617   ; *perr = OS_ERR_PEVENT_NULL;
                    12618   ; return;
                    12619   ; }
                    12620   ; #endif
                    12621   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000043B2  2043      12622          move.l    D3,A0
000043B4  1010      12623          move.b    (A0),D0
000043B6  0C00 0003 12624          cmp.b     #3,D0
000043BA  670A      12625          beq.s     OSSemPend_1
                    12626   ; *perr = OS_ERR_EVENT_TYPE;
000043BC  2042      12627          move.l    D2,A0
000043BE  10BC 0001 12628          move.b    #1,(A0)
                    12629   ; return;
000043C2  6000 00DA 12630          bra       OSSemPend_3
                    12631   OSSemPend_1:
                    12632   ; }
                    12633   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000043C6  1039 0800 12634          move.b    _OSIntNesting.L,D0
000043CA  0F06      
000043CC  0C00 0000 12635          cmp.b     #0,D0
000043D0  630A      12636          bls.s     OSSemPend_4
                    12637   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
000043D2  2042      12638          move.l    D2,A0
000043D4  10BC 0002 12639          move.b    #2,(A0)
                    12640   ; return;
000043D8  6000 00C4 12641          bra       OSSemPend_3
                    12642   OSSemPend_4:
                    12643   ; }
                    12644   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000043DC  1039 0800 12645          move.b    _OSLockNesting.L,D0
000043E0  0F08      
000043E2  0C00 0000 12646          cmp.b     #0,D0
000043E6  630A      12647          bls.s     OSSemPend_6
                    12648   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
000043E8  2042      12649          move.l    D2,A0
000043EA  10BC 000D 12650          move.b    #13,(A0)
                    12651   ; return;
000043EE  6000 00AE 12652          bra       OSSemPend_3
                    12653   OSSemPend_6:
                    12654   ; }
                    12655   ; OS_ENTER_CRITICAL();
000043F2  40E7      12656          dc.w      16615
000043F4  007C      12657          dc.w      124
000043F6  0700      12658          dc.w      1792
                    12659   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
000043F8  2043      12660          move.l    D3,A0
000043FA  3028 0006 12661          move.w    6(A0),D0
000043FE  0C40 0000 12662          cmp.w     #0,D0
00004402  6312      12663          bls.s     OSSemPend_8
                    12664   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
00004404  2003      12665          move.l    D3,D0
00004406  5C80      12666          addq.l    #6,D0
00004408  2040      12667          move.l    D0,A0
0000440A  5350      12668          subq.w    #1,(A0)
                    12669   ; OS_EXIT_CRITICAL();
0000440C  46DF      12670          dc.w      18143
                    12671   ; *perr = OS_ERR_NONE;
0000440E  2042      12672          move.l    D2,A0
00004410  4210      12673          clr.b     (A0)
                    12674   ; return;
00004412  6000 008A 12675          bra       OSSemPend_3
                    12676   OSSemPend_8:
                    12677   ; }
                    12678   ; /* Otherwise, must wait until event occurs       */
                    12679   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
00004416  2052      12680          move.l    (A2),A0
00004418  0028 0001 12681          or.b      #1,50(A0)
0000441C  0032      
                    12682   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0000441E  2052      12683          move.l    (A2),A0
00004420  4228 0033 12684          clr.b     51(A0)
                    12685   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00004424  2052      12686          move.l    (A2),A0
00004426  216E 000C 12687          move.l    12(A6),46(A0)
0000442A  002E      
                    12688   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
0000442C  2F03      12689          move.l    D3,-(A7)
0000442E  4EB8 1526 12690          jsr       _OS_EventTaskWait
00004432  584F      12691          addq.w    #4,A7
                    12692   ; OS_EXIT_CRITICAL();
00004434  46DF      12693          dc.w      18143
                    12694   ; OS_Sched();                                       /* Find next highest priority task ready         */
00004436  4EB8 1A22 12695          jsr       _OS_Sched
                    12696   ; OS_ENTER_CRITICAL();
0000443A  40E7      12697          dc.w      16615
0000443C  007C      12698          dc.w      124
0000443E  0700      12699          dc.w      1792
                    12700   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00004440  2052      12701          move.l    (A2),A0
00004442  1028 0033 12702          move.b    51(A0),D0
00004446  C0BC 0000 12703          and.l     #255,D0
0000444A  00FF      
0000444C  0C80 0000 12704          cmp.l     #1,D0
00004450  0001      
00004452  6720      12705          beq.s     OSSemPend_14
00004454  6206      12706          bhi.s     OSSemPend_16
00004456  4A80      12707          tst.l     D0
00004458  670C      12708          beq.s     OSSemPend_12
0000445A  6018      12709          bra.s     OSSemPend_14
                    12710   OSSemPend_16:
0000445C  0C80 0000 12711          cmp.l     #2,D0
00004460  0002      
00004462  6708      12712          beq.s     OSSemPend_13
00004464  600E      12713          bra.s     OSSemPend_14
                    12714   OSSemPend_12:
                    12715   ; case OS_STAT_PEND_OK:
                    12716   ; *perr = OS_ERR_NONE;
00004466  2042      12717          move.l    D2,A0
00004468  4210      12718          clr.b     (A0)
                    12719   ; break;
0000446A  6018      12720          bra.s     OSSemPend_11
                    12721   OSSemPend_13:
                    12722   ; case OS_STAT_PEND_ABORT:
                    12723   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
0000446C  2042      12724          move.l    D2,A0
0000446E  10BC 000E 12725          move.b    #14,(A0)
                    12726   ; break;
00004472  6010      12727          bra.s     OSSemPend_11
                    12728   OSSemPend_14:
                    12729   ; case OS_STAT_PEND_TO:
                    12730   ; default:
                    12731   ; OS_EventTaskRemove(OSTCBCur, pevent);
00004474  2F03      12732          move.l    D3,-(A7)
00004476  2F12      12733          move.l    (A2),-(A7)
00004478  4EB8 1648 12734          jsr       _OS_EventTaskRemove
0000447C  504F      12735          addq.w    #8,A7
                    12736   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
0000447E  2042      12737          move.l    D2,A0
00004480  10BC 000A 12738          move.b    #10,(A0)
                    12739   ; break;
                    12740   OSSemPend_11:
                    12741   ; }
                    12742   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00004484  2052      12743          move.l    (A2),A0
00004486  4228 0032 12744          clr.b     50(A0)
                    12745   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000448A  2052      12746          move.l    (A2),A0
0000448C  4228 0033 12747          clr.b     51(A0)
                    12748   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00004490  2052      12749          move.l    (A2),A0
00004492  42A8 001C 12750          clr.l     28(A0)
                    12751   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12752   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00004496  2052      12753          move.l    (A2),A0
00004498  42A8 0020 12754          clr.l     32(A0)
                    12755   ; #endif
                    12756   ; OS_EXIT_CRITICAL();
0000449C  46DF      12757          dc.w      18143
                    12758   OSSemPend_3:
0000449E  4CDF 040C 12759          movem.l   (A7)+,D2/D3/A2
000044A2  4E5E      12760          unlk      A6
000044A4  4E75      12761          rts
                    12762   ; }
                    12763   ; /*$PAGE*/
                    12764   ; /*
                    12765   ; *********************************************************************************************************
                    12766   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12767   ; *
                    12768   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12769   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12770   ; *              the semaphore via OSSemPost().
                    12771   ; *
                    12772   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12773   ; *                            semaphore.
                    12774   ; *
                    12775   ; *              opt           determines the type of ABORT performed:
                    12776   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12777   ; *                                                     semaphore
                    12778   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12779   ; *                                                     semaphore
                    12780   ; *
                    12781   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12782   ; *                            messages are:
                    12783   ; *
                    12784   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12785   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12786   ; *                                                and informed of the aborted wait; check return value
                    12787   ; *                                                for the number of tasks whose wait on the semaphore
                    12788   ; *                                                was aborted.
                    12789   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12790   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12791   ; *
                    12792   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12793   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12794   ; *********************************************************************************************************
                    12795   ; */
                    12796   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12797   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12798   ; INT8U      opt,
                    12799   ; INT8U     *perr)
                    12800   ; {
                    12801   _OSSemPendAbort:
000044A6  4E56 0000 12802          link      A6,#0
000044AA  48E7 3800 12803          movem.l   D2/D3/D4,-(A7)
000044AE  242E 0008 12804          move.l    8(A6),D2
000044B2  282E 0010 12805          move.l    16(A6),D4
                    12806   ; INT8U      nbr_tasks;
                    12807   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12808   ; OS_CPU_SR  cpu_sr = 0u;
                    12809   ; #endif
                    12810   ; #ifdef OS_SAFETY_CRITICAL
                    12811   ; if (perr == (INT8U *)0) {
                    12812   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12813   ; return (0u);
                    12814   ; }
                    12815   ; #endif
                    12816   ; #if OS_ARG_CHK_EN > 0u
                    12817   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12818   ; *perr = OS_ERR_PEVENT_NULL;
                    12819   ; return (0u);
                    12820   ; }
                    12821   ; #endif
                    12822   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000044B6  2042      12823          move.l    D2,A0
000044B8  1010      12824          move.b    (A0),D0
000044BA  0C00 0003 12825          cmp.b     #3,D0
000044BE  670C      12826          beq.s     OSSemPendAbort_1
                    12827   ; *perr = OS_ERR_EVENT_TYPE;
000044C0  2044      12828          move.l    D4,A0
000044C2  10BC 0001 12829          move.b    #1,(A0)
                    12830   ; return (0u);
000044C6  4200      12831          clr.b     D0
000044C8  6000 008C 12832          bra       OSSemPendAbort_3
                    12833   OSSemPendAbort_1:
                    12834   ; }
                    12835   ; OS_ENTER_CRITICAL();
000044CC  40E7      12836          dc.w      16615
000044CE  007C      12837          dc.w      124
000044D0  0700      12838          dc.w      1792
                    12839   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
000044D2  2042      12840          move.l    D2,A0
000044D4  1028 0008 12841          move.b    8(A0),D0
000044D8  6700 0074 12842          beq       OSSemPendAbort_4
                    12843   ; nbr_tasks = 0u;
000044DC  4203      12844          clr.b     D3
                    12845   ; switch (opt) {
000044DE  102E 000F 12846          move.b    15(A6),D0
000044E2  C0BC 0000 12847          and.l     #255,D0
000044E6  00FF      
000044E8  0C80 0000 12848          cmp.l     #1,D0
000044EC  0001      
000044EE  670A      12849          beq.s     OSSemPendAbort_8
000044F0  6200 0030 12850          bhi       OSSemPendAbort_9
000044F4  4A80      12851          tst.l     D0
000044F6  672A      12852          beq.s     OSSemPendAbort_9
000044F8  6028      12853          bra.s     OSSemPendAbort_9
                    12854   OSSemPendAbort_8:
                    12855   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12856   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12857   OSSemPendAbort_11:
000044FA  2042      12858          move.l    D2,A0
000044FC  1028 0008 12859          move.b    8(A0),D0
00004500  671E      12860          beq.s     OSSemPendAbort_13
                    12861   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00004502  4878 0002 12862          pea       2
00004506  4878 0001 12863          pea       1
0000450A  42A7      12864          clr.l     -(A7)
0000450C  2F02      12865          move.l    D2,-(A7)
0000450E  4EB8 1442 12866          jsr       _OS_EventTaskRdy
00004512  DEFC 0010 12867          add.w     #16,A7
00004516  C0BC 0000 12868          and.l     #255,D0
0000451A  00FF      
                    12869   ; nbr_tasks++;
0000451C  5203      12870          addq.b    #1,D3
0000451E  60DA      12871          bra       OSSemPendAbort_11
                    12872   OSSemPendAbort_13:
                    12873   ; }
                    12874   ; break;
00004520  601C      12875          bra.s     OSSemPendAbort_7
                    12876   OSSemPendAbort_9:
                    12877   ; case OS_PEND_OPT_NONE:
                    12878   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12879   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00004522  4878 0002 12880          pea       2
00004526  4878 0001 12881          pea       1
0000452A  42A7      12882          clr.l     -(A7)
0000452C  2F02      12883          move.l    D2,-(A7)
0000452E  4EB8 1442 12884          jsr       _OS_EventTaskRdy
00004532  DEFC 0010 12885          add.w     #16,A7
00004536  C0BC 0000 12886          and.l     #255,D0
0000453A  00FF      
                    12887   ; nbr_tasks++;
0000453C  5203      12888          addq.b    #1,D3
                    12889   ; break;
                    12890   OSSemPendAbort_7:
                    12891   ; }
                    12892   ; OS_EXIT_CRITICAL();
0000453E  46DF      12893          dc.w      18143
                    12894   ; OS_Sched();                                   /* Find HPT ready to run                         */
00004540  4EB8 1A22 12895          jsr       _OS_Sched
                    12896   ; *perr = OS_ERR_PEND_ABORT;
00004544  2044      12897          move.l    D4,A0
00004546  10BC 000E 12898          move.b    #14,(A0)
                    12899   ; return (nbr_tasks);
0000454A  1003      12900          move.b    D3,D0
0000454C  6008      12901          bra.s     OSSemPendAbort_3
                    12902   OSSemPendAbort_4:
                    12903   ; }
                    12904   ; OS_EXIT_CRITICAL();
0000454E  46DF      12905          dc.w      18143
                    12906   ; *perr = OS_ERR_NONE;
00004550  2044      12907          move.l    D4,A0
00004552  4210      12908          clr.b     (A0)
                    12909   ; return (0u);                                      /* No tasks waiting on semaphore                 */
00004554  4200      12910          clr.b     D0
                    12911   OSSemPendAbort_3:
00004556  4CDF 001C 12912          movem.l   (A7)+,D2/D3/D4
0000455A  4E5E      12913          unlk      A6
0000455C  4E75      12914          rts
                    12915   ; }
                    12916   ; #endif
                    12917   ; /*$PAGE*/
                    12918   ; /*
                    12919   ; *********************************************************************************************************
                    12920   ; *                                         POST TO A SEMAPHORE
                    12921   ; *
                    12922   ; * Description: This function signals a semaphore
                    12923   ; *
                    12924   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12925   ; *                            semaphore.
                    12926   ; *
                    12927   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12928   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12929   ; *                                  signaled the semaphore more often than you waited on it with either
                    12930   ; *                                  OSSemAccept() or OSSemPend().
                    12931   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12932   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12933   ; *********************************************************************************************************
                    12934   ; */
                    12935   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12936   ; {
                    12937   _OSSemPost:
0000455E  4E56 0000 12938          link      A6,#0
00004562  2F02      12939          move.l    D2,-(A7)
00004564  242E 0008 12940          move.l    8(A6),D2
                    12941   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12942   ; OS_CPU_SR  cpu_sr = 0u;
                    12943   ; #endif
                    12944   ; #if OS_ARG_CHK_EN > 0u
                    12945   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12946   ; return (OS_ERR_PEVENT_NULL);
                    12947   ; }
                    12948   ; #endif
                    12949   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004568  2042      12950          move.l    D2,A0
0000456A  1010      12951          move.b    (A0),D0
0000456C  0C00 0003 12952          cmp.b     #3,D0
00004570  6706      12953          beq.s     OSSemPost_1
                    12954   ; return (OS_ERR_EVENT_TYPE);
00004572  7001      12955          moveq     #1,D0
00004574  6000 0050 12956          bra       OSSemPost_3
                    12957   OSSemPost_1:
                    12958   ; }
                    12959   ; OS_ENTER_CRITICAL();
00004578  40E7      12960          dc.w      16615
0000457A  007C      12961          dc.w      124
0000457C  0700      12962          dc.w      1792
                    12963   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
0000457E  2042      12964          move.l    D2,A0
00004580  1028 0008 12965          move.b    8(A0),D0
00004584  6722      12966          beq.s     OSSemPost_4
                    12967   ; /* Ready HPT waiting on event                    */
                    12968   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
00004586  42A7      12969          clr.l     -(A7)
00004588  4878 0001 12970          pea       1
0000458C  42A7      12971          clr.l     -(A7)
0000458E  2F02      12972          move.l    D2,-(A7)
00004590  4EB8 1442 12973          jsr       _OS_EventTaskRdy
00004594  DEFC 0010 12974          add.w     #16,A7
00004598  C0BC 0000 12975          and.l     #255,D0
0000459C  00FF      
                    12976   ; OS_EXIT_CRITICAL();
0000459E  46DF      12977          dc.w      18143
                    12978   ; OS_Sched();                                   /* Find HPT ready to run                         */
000045A0  4EB8 1A22 12979          jsr       _OS_Sched
                    12980   ; return (OS_ERR_NONE);
000045A4  4200      12981          clr.b     D0
000045A6  601E      12982          bra.s     OSSemPost_3
                    12983   OSSemPost_4:
                    12984   ; }
                    12985   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
000045A8  2042      12986          move.l    D2,A0
000045AA  3028 0006 12987          move.w    6(A0),D0
000045AE  0C40 FFFF 12988          cmp.w     #65535,D0
000045B2  640E      12989          bhs.s     OSSemPost_6
                    12990   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
000045B4  2002      12991          move.l    D2,D0
000045B6  5C80      12992          addq.l    #6,D0
000045B8  2040      12993          move.l    D0,A0
000045BA  5250      12994          addq.w    #1,(A0)
                    12995   ; OS_EXIT_CRITICAL();
000045BC  46DF      12996          dc.w      18143
                    12997   ; return (OS_ERR_NONE);
000045BE  4200      12998          clr.b     D0
000045C0  6004      12999          bra.s     OSSemPost_3
                    13000   OSSemPost_6:
                    13001   ; }
                    13002   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
000045C2  46DF      13003          dc.w      18143
                    13004   ; return (OS_ERR_SEM_OVF);
000045C4  7033      13005          moveq     #51,D0
                    13006   OSSemPost_3:
000045C6  241F      13007          move.l    (A7)+,D2
000045C8  4E5E      13008          unlk      A6
000045CA  4E75      13009          rts
                    13010   ; }
                    13011   ; /*$PAGE*/
                    13012   ; /*
                    13013   ; *********************************************************************************************************
                    13014   ; *                                          QUERY A SEMAPHORE
                    13015   ; *
                    13016   ; * Description: This function obtains information about a semaphore
                    13017   ; *
                    13018   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    13019   ; *                            semaphore
                    13020   ; *
                    13021   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    13022   ; *                            semaphore.
                    13023   ; *
                    13024   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    13025   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    13026   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    13027   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    13028   ; *********************************************************************************************************
                    13029   ; */
                    13030   ; #if OS_SEM_QUERY_EN > 0u
                    13031   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    13032   ; OS_SEM_DATA  *p_sem_data)
                    13033   ; {
                    13034   _OSSemQuery:
000045CC  4E56 FFF8 13035          link      A6,#-8
000045D0  48E7 3800 13036          movem.l   D2/D3/D4,-(A7)
000045D4  242E 0008 13037          move.l    8(A6),D2
000045D8  282E 000C 13038          move.l    12(A6),D4
                    13039   ; INT8U       i;
                    13040   ; OS_PRIO    *psrc;
                    13041   ; OS_PRIO    *pdest;
                    13042   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    13043   ; OS_CPU_SR   cpu_sr = 0u;
                    13044   ; #endif
                    13045   ; #if OS_ARG_CHK_EN > 0u
                    13046   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    13047   ; return (OS_ERR_PEVENT_NULL);
                    13048   ; }
                    13049   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    13050   ; return (OS_ERR_PDATA_NULL);
                    13051   ; }
                    13052   ; #endif
                    13053   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
000045DC  2042      13054          move.l    D2,A0
000045DE  1010      13055          move.b    (A0),D0
000045E0  0C00 0003 13056          cmp.b     #3,D0
000045E4  6706      13057          beq.s     OSSemQuery_1
                    13058   ; return (OS_ERR_EVENT_TYPE);
000045E6  7001      13059          moveq     #1,D0
000045E8  6000 004C 13060          bra       OSSemQuery_3
                    13061   OSSemQuery_1:
                    13062   ; }
                    13063   ; OS_ENTER_CRITICAL();
000045EC  40E7      13064          dc.w      16615
000045EE  007C      13065          dc.w      124
000045F0  0700      13066          dc.w      1792
                    13067   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
000045F2  2042      13068          move.l    D2,A0
000045F4  2244      13069          move.l    D4,A1
000045F6  1368 0008 13070          move.b    8(A0),10(A1)
000045FA  000A      
                    13071   ; psrc                   = &pevent->OSEventTbl[0];
000045FC  700A      13072          moveq     #10,D0
000045FE  D082      13073          add.l     D2,D0
00004600  2D40 FFF8 13074          move.l    D0,-8(A6)
                    13075   ; pdest                  = &p_sem_data->OSEventTbl[0];
00004604  7002      13076          moveq     #2,D0
00004606  D084      13077          add.l     D4,D0
00004608  2D40 FFFC 13078          move.l    D0,-4(A6)
                    13079   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0000460C  4203      13080          clr.b     D3
                    13081   OSSemQuery_4:
0000460E  0C03 0008 13082          cmp.b     #8,D3
00004612  6416      13083          bhs.s     OSSemQuery_6
                    13084   ; *pdest++ = *psrc++;
00004614  206E FFF8 13085          move.l    -8(A6),A0
00004618  52AE FFF8 13086          addq.l    #1,-8(A6)
0000461C  226E FFFC 13087          move.l    -4(A6),A1
00004620  52AE FFFC 13088          addq.l    #1,-4(A6)
00004624  1290      13089          move.b    (A0),(A1)
00004626  5203      13090          addq.b    #1,D3
00004628  60E4      13091          bra       OSSemQuery_4
                    13092   OSSemQuery_6:
                    13093   ; }
                    13094   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
0000462A  2042      13095          move.l    D2,A0
0000462C  2244      13096          move.l    D4,A1
0000462E  32A8 0006 13097          move.w    6(A0),(A1)
                    13098   ; OS_EXIT_CRITICAL();
00004632  46DF      13099          dc.w      18143
                    13100   ; return (OS_ERR_NONE);
00004634  4200      13101          clr.b     D0
                    13102   OSSemQuery_3:
00004636  4CDF 001C 13103          movem.l   (A7)+,D2/D3/D4
0000463A  4E5E      13104          unlk      A6
0000463C  4E75      13105          rts
                    13106   ; }
                    13107   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    13108   ; /*$PAGE*/
                    13109   ; /*
                    13110   ; *********************************************************************************************************
                    13111   ; *                                            SET SEMAPHORE
                    13112   ; *
                    13113   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    13114   ; *              this value would be 0.
                    13115   ; *
                    13116   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    13117   ; *              and, you want to reset the count value.
                    13118   ; *
                    13119   ; * Arguments  : pevent     is a pointer to the event control block
                    13120   ; *
                    13121   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    13122   ; *                         semaphore count.
                    13123   ; *
                    13124   ; *              perr       is a pointer to an error code returned by the function as follows:
                    13125   ; *
                    13126   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    13127   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    13128   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    13129   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    13130   ; *********************************************************************************************************
                    13131   ; */
                    13132   ; #if OS_SEM_SET_EN > 0u
                    13133   ; void  OSSemSet (OS_EVENT  *pevent,
                    13134   ; INT16U     cnt,
                    13135   ; INT8U     *perr)
                    13136   ; {
                    13137   _OSSemSet:
0000463E  4E56 0000 13138          link      A6,#0
00004642  48E7 3000 13139          movem.l   D2/D3,-(A7)
00004646  242E 0008 13140          move.l    8(A6),D2
0000464A  262E 0010 13141          move.l    16(A6),D3
                    13142   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    13143   ; OS_CPU_SR  cpu_sr = 0u;
                    13144   ; #endif
                    13145   ; #ifdef OS_SAFETY_CRITICAL
                    13146   ; if (perr == (INT8U *)0) {
                    13147   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13148   ; return;
                    13149   ; }
                    13150   ; #endif
                    13151   ; #if OS_ARG_CHK_EN > 0u
                    13152   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    13153   ; *perr = OS_ERR_PEVENT_NULL;
                    13154   ; return;
                    13155   ; }
                    13156   ; #endif
                    13157   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000464E  2042      13158          move.l    D2,A0
00004650  1010      13159          move.b    (A0),D0
00004652  0C00 0003 13160          cmp.b     #3,D0
00004656  670A      13161          beq.s     OSSemSet_1
                    13162   ; *perr = OS_ERR_EVENT_TYPE;
00004658  2043      13163          move.l    D3,A0
0000465A  10BC 0001 13164          move.b    #1,(A0)
                    13165   ; return;
0000465E  6000 003C 13166          bra       OSSemSet_3
                    13167   OSSemSet_1:
                    13168   ; }
                    13169   ; OS_ENTER_CRITICAL();
00004662  40E7      13170          dc.w      16615
00004664  007C      13171          dc.w      124
00004666  0700      13172          dc.w      1792
                    13173   ; *perr = OS_ERR_NONE;
00004668  2043      13174          move.l    D3,A0
0000466A  4210      13175          clr.b     (A0)
                    13176   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
0000466C  2042      13177          move.l    D2,A0
0000466E  3028 0006 13178          move.w    6(A0),D0
00004672  0C40 0000 13179          cmp.w     #0,D0
00004676  630A      13180          bls.s     OSSemSet_4
                    13181   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
00004678  2042      13182          move.l    D2,A0
0000467A  316E 000E 13183          move.w    14(A6),6(A0)
0000467E  0006      
00004680  6018      13184          bra.s     OSSemSet_7
                    13185   OSSemSet_4:
                    13186   ; } else {                                          /* No                                            */
                    13187   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
00004682  2042      13188          move.l    D2,A0
00004684  1028 0008 13189          move.b    8(A0),D0
00004688  660A      13190          bne.s     OSSemSet_6
                    13191   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
0000468A  2042      13192          move.l    D2,A0
0000468C  316E 000E 13193          move.w    14(A6),6(A0)
00004690  0006      
00004692  6006      13194          bra.s     OSSemSet_7
                    13195   OSSemSet_6:
                    13196   ; } else {
                    13197   ; *perr              = OS_ERR_TASK_WAITING;
00004694  2043      13198          move.l    D3,A0
00004696  10BC 0049 13199          move.b    #73,(A0)
                    13200   OSSemSet_7:
                    13201   ; }
                    13202   ; }
                    13203   ; OS_EXIT_CRITICAL();
0000469A  46DF      13204          dc.w      18143
                    13205   OSSemSet_3:
0000469C  4CDF 000C 13206          movem.l   (A7)+,D2/D3
000046A0  4E5E      13207          unlk      A6
000046A2  4E75      13208          rts
                    13209   ; /*
                    13210   ; *********************************************************************************************************
                    13211   ; *                                                uC/OS-II
                    13212   ; *                                          The Real-Time Kernel
                    13213   ; *                                            TASK MANAGEMENT
                    13214   ; *
                    13215   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    13216   ; *                                           All Rights Reserved
                    13217   ; *
                    13218   ; * File    : OS_TASK.C
                    13219   ; * By      : Jean J. Labrosse
                    13220   ; * Version : V2.92.07
                    13221   ; *
                    13222   ; * LICENSING TERMS:
                    13223   ; * ---------------
                    13224   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    13225   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    13226   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    13227   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    13228   ; * licensing fee.
                    13229   ; *********************************************************************************************************
                    13230   ; */
                    13231   ; #define  MICRIUM_SOURCE
                    13232   ; #ifndef  OS_MASTER_FILE
                    13233   ; #include <ucos_ii.h>
                    13234   ; #endif
                    13235   ; /*$PAGE*/
                    13236   ; /*
                    13237   ; *********************************************************************************************************
                    13238   ; *                                      CHANGE PRIORITY OF A TASK
                    13239   ; *
                    13240   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    13241   ; *              priority MUST be available.
                    13242   ; *
                    13243   ; * Arguments  : oldp     is the old priority
                    13244   ; *
                    13245   ; *              newp     is the new priority
                    13246   ; *
                    13247   ; * Returns    : OS_ERR_NONE            is the call was successful
                    13248   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13249   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    13250   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    13251   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    13252   ; *                                     not exist.
                    13253   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    13254   ; *********************************************************************************************************
                    13255   ; */
                    13256   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    13257   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    13258   ; INT8U  newprio)
                    13259   ; {
                    13260   _OSTaskChangePrio:
000046A4  4E56 FFFC 13261          link      A6,#-4
000046A8  48E7 3F38 13262          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
000046AC  47F9 0800 13263          lea       _OSRdyTbl.L,A3
000046B0  0F10      
000046B2  49F9 0800 13264          lea       _OSTCBPrioTbl.L,A4
000046B6  1030      
                    13265   ; #if (OS_EVENT_EN)
                    13266   ; OS_EVENT  *pevent;
                    13267   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13268   ; OS_EVENT **pevents;
                    13269   ; #endif
                    13270   ; #endif
                    13271   ; OS_TCB    *ptcb;
                    13272   ; INT8U      y_new;
                    13273   ; INT8U      x_new;
                    13274   ; INT8U      y_old;
                    13275   ; OS_PRIO    bity_new;
                    13276   ; OS_PRIO    bitx_new;
                    13277   ; OS_PRIO    bity_old;
                    13278   ; OS_PRIO    bitx_old;
                    13279   ; #if OS_CRITICAL_METHOD == 3u
                    13280   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    13281   ; #endif
                    13282   ; /*$PAGE*/
                    13283   ; #if OS_ARG_CHK_EN > 0u
                    13284   ; if (oldprio >= OS_LOWEST_PRIO) {
                    13285   ; if (oldprio != OS_PRIO_SELF) {
                    13286   ; return (OS_ERR_PRIO_INVALID);
                    13287   ; }
                    13288   ; }
                    13289   ; if (newprio >= OS_LOWEST_PRIO) {
                    13290   ; return (OS_ERR_PRIO_INVALID);
                    13291   ; }
                    13292   ; #endif
                    13293   ; OS_ENTER_CRITICAL();
000046B8  40E7      13294          dc.w      16615
000046BA  007C      13295          dc.w      124
000046BC  0700      13296          dc.w      1792
                    13297   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
000046BE  102E 000F 13298          move.b    15(A6),D0
000046C2  C0BC 0000 13299          and.l     #255,D0
000046C6  00FF      
000046C8  E588      13300          lsl.l     #2,D0
000046CA  2034 0800 13301          move.l    0(A4,D0.L),D0
000046CE  6708      13302          beq.s     OSTaskChangePrio_1
                    13303   ; OS_EXIT_CRITICAL();
000046D0  46DF      13304          dc.w      18143
                    13305   ; return (OS_ERR_PRIO_EXIST);
000046D2  7028      13306          moveq     #40,D0
000046D4  6000 01E0 13307          bra       OSTaskChangePrio_3
                    13308   OSTaskChangePrio_1:
                    13309   ; }
                    13310   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
000046D8  102E 000B 13311          move.b    11(A6),D0
000046DC  0C00 00FF 13312          cmp.b     #255,D0
000046E0  660C      13313          bne.s     OSTaskChangePrio_4
                    13314   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
000046E2  2079 0800 13315          move.l    _OSTCBCur.L,A0
000046E6  1020      
000046E8  1D68 0034 13316          move.b    52(A0),11(A6)
000046EC  000B      
                    13317   OSTaskChangePrio_4:
                    13318   ; }
                    13319   ; ptcb = OSTCBPrioTbl[oldprio];
000046EE  102E 000B 13320          move.b    11(A6),D0
000046F2  C0BC 0000 13321          and.l     #255,D0
000046F6  00FF      
000046F8  E588      13322          lsl.l     #2,D0
000046FA  2634 0800 13323          move.l    0(A4,D0.L),D3
                    13324   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
000046FE  4A83      13325          tst.l     D3
00004700  6608      13326          bne.s     OSTaskChangePrio_6
                    13327   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
00004702  46DF      13328          dc.w      18143
                    13329   ; return (OS_ERR_PRIO);
00004704  7029      13330          moveq     #41,D0
00004706  6000 01AE 13331          bra       OSTaskChangePrio_3
                    13332   OSTaskChangePrio_6:
                    13333   ; }
                    13334   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
0000470A  0C83 0000 13335          cmp.l     #1,D3
0000470E  0001      
00004710  6608      13336          bne.s     OSTaskChangePrio_8
                    13337   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
00004712  46DF      13338          dc.w      18143
                    13339   ; return (OS_ERR_TASK_NOT_EXIST);
00004714  7043      13340          moveq     #67,D0
00004716  6000 019E 13341          bra       OSTaskChangePrio_3
                    13342   OSTaskChangePrio_8:
                    13343   ; }
                    13344   ; #if OS_LOWEST_PRIO <= 63u
                    13345   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
0000471A  102E 000F 13346          move.b    15(A6),D0
0000471E  E608      13347          lsr.b     #3,D0
00004720  1A00      13348          move.b    D0,D5
                    13349   ; x_new                 = (INT8U)(newprio & 0x07u);
00004722  102E 000F 13350          move.b    15(A6),D0
00004726  C03C 0007 13351          and.b     #7,D0
0000472A  1D40 FFFD 13352          move.b    D0,-3(A6)
                    13353   ; #else
                    13354   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    13355   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    13356   ; #endif
                    13357   ; bity_new              = (OS_PRIO)(1uL << y_new);
0000472E  7001      13358          moveq     #1,D0
00004730  CABC 0000 13359          and.l     #255,D5
00004734  00FF      
00004736  EBA8      13360          lsl.l     D5,D0
00004738  1D40 FFFE 13361          move.b    D0,-2(A6)
                    13362   ; bitx_new              = (OS_PRIO)(1uL << x_new);
0000473C  7001      13363          moveq     #1,D0
0000473E  122E FFFD 13364          move.b    -3(A6),D1
00004742  C2BC 0000 13365          and.l     #255,D1
00004746  00FF      
00004748  E3A8      13366          lsl.l     D1,D0
0000474A  1E00      13367          move.b    D0,D7
                    13368   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
0000474C  102E 000B 13369          move.b    11(A6),D0
00004750  C0BC 0000 13370          and.l     #255,D0
00004754  00FF      
00004756  E588      13371          lsl.l     #2,D0
00004758  42B4 0800 13372          clr.l     0(A4,D0.L)
                    13373   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
0000475C  102E 000F 13374          move.b    15(A6),D0
00004760  C0BC 0000 13375          and.l     #255,D0
00004764  00FF      
00004766  E588      13376          lsl.l     #2,D0
00004768  2983 0800 13377          move.l    D3,0(A4,D0.L)
                    13378   ; y_old                 =  ptcb->OSTCBY;
0000476C  2043      13379          move.l    D3,A0
0000476E  1828 0036 13380          move.b    54(A0),D4
                    13381   ; bity_old              =  ptcb->OSTCBBitY;
00004772  2043      13382          move.l    D3,A0
00004774  1D68 0038 13383          move.b    56(A0),-1(A6)
00004778  FFFF      
                    13384   ; bitx_old              =  ptcb->OSTCBBitX;
0000477A  2043      13385          move.l    D3,A0
0000477C  1C28 0037 13386          move.b    55(A0),D6
                    13387   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00004780  C8BC 0000 13388          and.l     #255,D4
00004784  00FF      
00004786  1033 4800 13389          move.b    0(A3,D4.L),D0
0000478A  C006      13390          and.b     D6,D0
0000478C  673A      13391          beq.s     OSTaskChangePrio_10
                    13392   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
0000478E  C8BC 0000 13393          and.l     #255,D4
00004792  00FF      
00004794  1006      13394          move.b    D6,D0
00004796  4600      13395          not.b     D0
00004798  C133 4800 13396          and.b     D0,0(A3,D4.L)
                    13397   ; if (OSRdyTbl[y_old] == 0u) {
0000479C  C8BC 0000 13398          and.l     #255,D4
000047A0  00FF      
000047A2  1033 4800 13399          move.b    0(A3,D4.L),D0
000047A6  660C      13400          bne.s     OSTaskChangePrio_12
                    13401   ; OSRdyGrp &= (OS_PRIO)~bity_old;
000047A8  102E FFFF 13402          move.b    -1(A6),D0
000047AC  4600      13403          not.b     D0
000047AE  C139 0800 13404          and.b     D0,_OSRdyGrp.L
000047B2  0F0E      
                    13405   OSTaskChangePrio_12:
                    13406   ; }
                    13407   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
000047B4  102E FFFE 13408          move.b    -2(A6),D0
000047B8  8139 0800 13409          or.b      D0,_OSRdyGrp.L
000047BC  0F0E      
                    13410   ; OSRdyTbl[y_new] |= bitx_new;
000047BE  CABC 0000 13411          and.l     #255,D5
000047C2  00FF      
000047C4  8F33 5800 13412          or.b      D7,0(A3,D5.L)
                    13413   OSTaskChangePrio_10:
                    13414   ; }
                    13415   ; #if (OS_EVENT_EN)
                    13416   ; pevent = ptcb->OSTCBEventPtr;
000047C8  2043      13417          move.l    D3,A0
000047CA  2428 001C 13418          move.l    28(A0),D2
                    13419   ; if (pevent != (OS_EVENT *)0) {
000047CE  4A82      13420          tst.l     D2
000047D0  6700 0048 13421          beq       OSTaskChangePrio_14
                    13422   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
000047D4  2042      13423          move.l    D2,A0
000047D6  C8BC 0000 13424          and.l     #255,D4
000047DA  00FF      
000047DC  D1C4      13425          add.l     D4,A0
000047DE  1006      13426          move.b    D6,D0
000047E0  4600      13427          not.b     D0
000047E2  C128 000A 13428          and.b     D0,10(A0)
                    13429   ; if (pevent->OSEventTbl[y_old] == 0u) {
000047E6  2042      13430          move.l    D2,A0
000047E8  C8BC 0000 13431          and.l     #255,D4
000047EC  00FF      
000047EE  D1C4      13432          add.l     D4,A0
000047F0  1028 000A 13433          move.b    10(A0),D0
000047F4  660C      13434          bne.s     OSTaskChangePrio_16
                    13435   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000047F6  2042      13436          move.l    D2,A0
000047F8  102E FFFF 13437          move.b    -1(A6),D0
000047FC  4600      13438          not.b     D0
000047FE  C128 0008 13439          and.b     D0,8(A0)
                    13440   OSTaskChangePrio_16:
                    13441   ; }
                    13442   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
00004802  2042      13443          move.l    D2,A0
00004804  102E FFFE 13444          move.b    -2(A6),D0
00004808  8128 0008 13445          or.b      D0,8(A0)
                    13446   ; pevent->OSEventTbl[y_new] |= bitx_new;
0000480C  2042      13447          move.l    D2,A0
0000480E  CABC 0000 13448          and.l     #255,D5
00004812  00FF      
00004814  D1C5      13449          add.l     D5,A0
00004816  8F28 000A 13450          or.b      D7,10(A0)
                    13451   OSTaskChangePrio_14:
                    13452   ; }
                    13453   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13454   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
0000481A  2043      13455          move.l    D3,A0
0000481C  2028 0020 13456          move.l    32(A0),D0
00004820  6700 005C 13457          beq       OSTaskChangePrio_22
                    13458   ; pevents =  ptcb->OSTCBEventMultiPtr;
00004824  2043      13459          move.l    D3,A0
00004826  2468 0020 13460          move.l    32(A0),A2
                    13461   ; pevent  = *pevents;
0000482A  2412      13462          move.l    (A2),D2
                    13463   ; while (pevent != (OS_EVENT *)0) {
                    13464   OSTaskChangePrio_20:
0000482C  4A82      13465          tst.l     D2
0000482E  6700 004E 13466          beq       OSTaskChangePrio_22
                    13467   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
00004832  2042      13468          move.l    D2,A0
00004834  C8BC 0000 13469          and.l     #255,D4
00004838  00FF      
0000483A  D1C4      13470          add.l     D4,A0
0000483C  1006      13471          move.b    D6,D0
0000483E  4600      13472          not.b     D0
00004840  C128 000A 13473          and.b     D0,10(A0)
                    13474   ; if (pevent->OSEventTbl[y_old] == 0u) {
00004844  2042      13475          move.l    D2,A0
00004846  C8BC 0000 13476          and.l     #255,D4
0000484A  00FF      
0000484C  D1C4      13477          add.l     D4,A0
0000484E  1028 000A 13478          move.b    10(A0),D0
00004852  660C      13479          bne.s     OSTaskChangePrio_23
                    13480   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
00004854  2042      13481          move.l    D2,A0
00004856  102E FFFF 13482          move.b    -1(A6),D0
0000485A  4600      13483          not.b     D0
0000485C  C128 0008 13484          and.b     D0,8(A0)
                    13485   OSTaskChangePrio_23:
                    13486   ; }
                    13487   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
00004860  2042      13488          move.l    D2,A0
00004862  102E FFFE 13489          move.b    -2(A6),D0
00004866  8128 0008 13490          or.b      D0,8(A0)
                    13491   ; pevent->OSEventTbl[y_new] |= bitx_new;
0000486A  2042      13492          move.l    D2,A0
0000486C  CABC 0000 13493          and.l     #255,D5
00004870  00FF      
00004872  D1C5      13494          add.l     D5,A0
00004874  8F28 000A 13495          or.b      D7,10(A0)
                    13496   ; pevents++;
00004878  584A      13497          addq.w    #4,A2
                    13498   ; pevent                     = *pevents;
0000487A  2412      13499          move.l    (A2),D2
0000487C  60AE      13500          bra       OSTaskChangePrio_20
                    13501   OSTaskChangePrio_22:
                    13502   ; }
                    13503   ; }
                    13504   ; #endif
                    13505   ; #endif
                    13506   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
0000487E  2043      13507          move.l    D3,A0
00004880  116E 000F 13508          move.b    15(A6),52(A0)
00004884  0034      
                    13509   ; ptcb->OSTCBY    = y_new;
00004886  2043      13510          move.l    D3,A0
00004888  1145 0036 13511          move.b    D5,54(A0)
                    13512   ; ptcb->OSTCBX    = x_new;
0000488C  2043      13513          move.l    D3,A0
0000488E  116E FFFD 13514          move.b    -3(A6),53(A0)
00004892  0035      
                    13515   ; ptcb->OSTCBBitY = bity_new;
00004894  2043      13516          move.l    D3,A0
00004896  116E FFFE 13517          move.b    -2(A6),56(A0)
0000489A  0038      
                    13518   ; ptcb->OSTCBBitX = bitx_new;
0000489C  2043      13519          move.l    D3,A0
0000489E  1147 0037 13520          move.b    D7,55(A0)
                    13521   ; OS_EXIT_CRITICAL();
000048A2  46DF      13522          dc.w      18143
                    13523   ; if (OSRunning == OS_TRUE) {
000048A4  1039 0800 13524          move.b    _OSRunning.L,D0
000048A8  0F18      
000048AA  0C00 0001 13525          cmp.b     #1,D0
000048AE  6604      13526          bne.s     OSTaskChangePrio_25
                    13527   ; OS_Sched();                                         /* Find new highest priority task          */
000048B0  4EB8 1A22 13528          jsr       _OS_Sched
                    13529   OSTaskChangePrio_25:
                    13530   ; }
                    13531   ; return (OS_ERR_NONE);
000048B4  4200      13532          clr.b     D0
                    13533   OSTaskChangePrio_3:
000048B6  4CDF 1CFC 13534          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
000048BA  4E5E      13535          unlk      A6
000048BC  4E75      13536          rts
                    13537   ; }
                    13538   ; #endif
                    13539   ; /*$PAGE*/
                    13540   ; /*
                    13541   ; *********************************************************************************************************
                    13542   ; *                                            CREATE A TASK
                    13543   ; *
                    13544   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13545   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13546   ; *              created by an ISR.
                    13547   ; *
                    13548   ; * Arguments  : task     is a pointer to the task's code
                    13549   ; *
                    13550   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    13551   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    13552   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    13553   ; *
                    13554   ; *                           void Task (void *p_arg)
                    13555   ; *                           {
                    13556   ; *                               for (;;) {
                    13557   ; *                                   Task code;
                    13558   ; *                               }
                    13559   ; *                           }
                    13560   ; *
                    13561   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    13562   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13563   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    13564   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    13565   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    13566   ; *                       memory locations.
                    13567   ; *
                    13568   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    13569   ; *                       lower the number, the higher the priority.
                    13570   ; *
                    13571   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13572   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13573   ; *                                               (each task MUST have a unique priority).
                    13574   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13575   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    13576   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13577   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13578   ; *                                               operation started.
                    13579   ; *********************************************************************************************************
                    13580   ; */
                    13581   ; #if OS_TASK_CREATE_EN > 0u
                    13582   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    13583   ; void    *p_arg,
                    13584   ; OS_STK  *ptos,
                    13585   ; INT8U    prio)
                    13586   ; {
                    13587   _OSTaskCreate:
000048BE  4E56 FFFC 13588          link      A6,#-4
000048C2  48E7 3020 13589          movem.l   D2/D3/A2,-(A7)
000048C6  142E 0017 13590          move.b    23(A6),D2
000048CA  C4BC 0000 13591          and.l     #255,D2
000048CE  00FF      
000048D0  45F9 0800 13592          lea       _OSTCBPrioTbl.L,A2
000048D4  1030      
                    13593   ; OS_STK     *psp;
                    13594   ; INT8U       err;
                    13595   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13596   ; OS_CPU_SR   cpu_sr = 0u;
                    13597   ; #endif
                    13598   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13599   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13600   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13601   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13602   ; }
                    13603   ; #endif
                    13604   ; #if OS_ARG_CHK_EN > 0u
                    13605   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13606   ; return (OS_ERR_PRIO_INVALID);
                    13607   ; }
                    13608   ; #endif
                    13609   ; OS_ENTER_CRITICAL();
000048D6  40E7      13610          dc.w      16615
000048D8  007C      13611          dc.w      124
000048DA  0700      13612          dc.w      1792
                    13613   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000048DC  1039 0800 13614          move.b    _OSIntNesting.L,D0
000048E0  0F06      
000048E2  0C00 0000 13615          cmp.b     #0,D0
000048E6  6308      13616          bls.s     OSTaskCreate_1
                    13617   ; OS_EXIT_CRITICAL();
000048E8  46DF      13618          dc.w      18143
                    13619   ; return (OS_ERR_TASK_CREATE_ISR);
000048EA  703C      13620          moveq     #60,D0
000048EC  6000 0096 13621          bra       OSTaskCreate_3
                    13622   OSTaskCreate_1:
                    13623   ; }
                    13624   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000048F0  C4BC 0000 13625          and.l     #255,D2
000048F4  00FF      
000048F6  2002      13626          move.l    D2,D0
000048F8  E588      13627          lsl.l     #2,D0
000048FA  2032 0800 13628          move.l    0(A2,D0.L),D0
000048FE  6600 0080 13629          bne       OSTaskCreate_4
                    13630   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00004902  C4BC 0000 13631          and.l     #255,D2
00004906  00FF      
00004908  2002      13632          move.l    D2,D0
0000490A  E588      13633          lsl.l     #2,D0
0000490C  25BC 0000 13634          move.l    #1,0(A2,D0.L)
00004910  0001 0800 
                    13635   ; /* ... the same thing until task is created.              */
                    13636   ; OS_EXIT_CRITICAL();
00004914  46DF      13637          dc.w      18143
                    13638   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
00004916  42A7      13639          clr.l     -(A7)
00004918  2F2E 0010 13640          move.l    16(A6),-(A7)
0000491C  2F2E 000C 13641          move.l    12(A6),-(A7)
00004920  2F2E 0008 13642          move.l    8(A6),-(A7)
00004924  4EB8 0C24 13643          jsr       _OSTaskStkInit
00004928  DEFC 0010 13644          add.w     #16,A7
0000492C  2D40 FFFC 13645          move.l    D0,-4(A6)
                    13646   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00004930  42A7      13647          clr.l     -(A7)
00004932  42A7      13648          clr.l     -(A7)
00004934  42A7      13649          clr.l     -(A7)
00004936  42A7      13650          clr.l     -(A7)
00004938  42A7      13651          clr.l     -(A7)
0000493A  2F2E FFFC 13652          move.l    -4(A6),-(A7)
0000493E  C4BC 0000 13653          and.l     #255,D2
00004942  00FF      
00004944  2F02      13654          move.l    D2,-(A7)
00004946  4EB8 1C3C 13655          jsr       _OS_TCBInit
0000494A  DEFC 001C 13656          add.w     #28,A7
0000494E  1600      13657          move.b    D0,D3
                    13658   ; if (err == OS_ERR_NONE) {
00004950  4A03      13659          tst.b     D3
00004952  6612      13660          bne.s     OSTaskCreate_6
                    13661   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
00004954  1039 0800 13662          move.b    _OSRunning.L,D0
00004958  0F18      
0000495A  0C00 0001 13663          cmp.b     #1,D0
0000495E  6604      13664          bne.s     OSTaskCreate_8
                    13665   ; OS_Sched();
00004960  4EB8 1A22 13666          jsr       _OS_Sched
                    13667   OSTaskCreate_8:
00004964  6016      13668          bra.s     OSTaskCreate_7
                    13669   OSTaskCreate_6:
                    13670   ; }
                    13671   ; } else {
                    13672   ; OS_ENTER_CRITICAL();
00004966  40E7      13673          dc.w      16615
00004968  007C      13674          dc.w      124
0000496A  0700      13675          dc.w      1792
                    13676   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
0000496C  C4BC 0000 13677          and.l     #255,D2
00004970  00FF      
00004972  2002      13678          move.l    D2,D0
00004974  E588      13679          lsl.l     #2,D0
00004976  42B2 0800 13680          clr.l     0(A2,D0.L)
                    13681   ; OS_EXIT_CRITICAL();
0000497A  46DF      13682          dc.w      18143
                    13683   OSTaskCreate_7:
                    13684   ; }
                    13685   ; return (err);
0000497C  1003      13686          move.b    D3,D0
0000497E  6004      13687          bra.s     OSTaskCreate_3
                    13688   OSTaskCreate_4:
                    13689   ; }
                    13690   ; OS_EXIT_CRITICAL();
00004980  46DF      13691          dc.w      18143
                    13692   ; return (OS_ERR_PRIO_EXIST);
00004982  7028      13693          moveq     #40,D0
                    13694   OSTaskCreate_3:
00004984  4CDF 040C 13695          movem.l   (A7)+,D2/D3/A2
00004988  4E5E      13696          unlk      A6
0000498A  4E75      13697          rts
                    13698   ; }
                    13699   ; #endif
                    13700   ; /*$PAGE*/
                    13701   ; /*
                    13702   ; *********************************************************************************************************
                    13703   ; *                                  CREATE A TASK (Extended Version)
                    13704   ; *
                    13705   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13706   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13707   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13708   ; *              additional information about a task to be specified.
                    13709   ; *
                    13710   ; * Arguments  : task      is a pointer to the task's code
                    13711   ; *
                    13712   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13713   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13714   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13715   ; *
                    13716   ; *                            void Task (void *p_arg)
                    13717   ; *                            {
                    13718   ; *                                for (;;) {
                    13719   ; *                                    Task code;
                    13720   ; *                                }
                    13721   ; *                            }
                    13722   ; *
                    13723   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13724   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13725   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13726   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13727   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13728   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13729   ; *
                    13730   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13731   ; *                        lower the number, the higher the priority.
                    13732   ; *
                    13733   ; *              id        is the task's ID (0..65535)
                    13734   ; *
                    13735   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13736   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13737   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13738   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13739   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13740   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13741   ; *
                    13742   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13743   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13744   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13745   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13746   ; *                        available on the stack.
                    13747   ; *
                    13748   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13749   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13750   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13751   ; *                        the task has been switched-in, etc.
                    13752   ; *
                    13753   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13754   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13755   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13756   ; *
                    13757   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13758   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13759   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13760   ; *                                                 during a context switch.
                    13761   ; *
                    13762   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13763   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13764   ; *                                               (each task MUST have a unique priority).
                    13765   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13766   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13767   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13768   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13769   ; *                                               operation started.
                    13770   ; *********************************************************************************************************
                    13771   ; */
                    13772   ; /*$PAGE*/
                    13773   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13774   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13775   ; void    *p_arg,
                    13776   ; OS_STK  *ptos,
                    13777   ; INT8U    prio,
                    13778   ; INT16U   id,
                    13779   ; OS_STK  *pbos,
                    13780   ; INT32U   stk_size,
                    13781   ; void    *pext,
                    13782   ; INT16U   opt)
                    13783   ; {
                    13784   _OSTaskCreateExt:
0000498C  4E56 FFFC 13785          link      A6,#-4
00004990  48E7 3820 13786          movem.l   D2/D3/D4/A2,-(A7)
00004994  142E 0017 13787          move.b    23(A6),D2
00004998  C4BC 0000 13788          and.l     #255,D2
0000499C  00FF      
0000499E  382E 002A 13789          move.w    42(A6),D4
000049A2  C8BC 0000 13790          and.l     #65535,D4
000049A6  FFFF      
000049A8  45F9 0800 13791          lea       _OSTCBPrioTbl.L,A2
000049AC  1030      
                    13792   ; OS_STK     *psp;
                    13793   ; INT8U       err;
                    13794   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13795   ; OS_CPU_SR   cpu_sr = 0u;
                    13796   ; #endif
                    13797   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13798   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13799   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13800   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13801   ; }
                    13802   ; #endif
                    13803   ; #if OS_ARG_CHK_EN > 0u
                    13804   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13805   ; return (OS_ERR_PRIO_INVALID);
                    13806   ; }
                    13807   ; #endif
                    13808   ; OS_ENTER_CRITICAL();
000049AE  40E7      13809          dc.w      16615
000049B0  007C      13810          dc.w      124
000049B2  0700      13811          dc.w      1792
                    13812   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000049B4  1039 0800 13813          move.b    _OSIntNesting.L,D0
000049B8  0F06      
000049BA  0C00 0000 13814          cmp.b     #0,D0
000049BE  6308      13815          bls.s     OSTaskCreateExt_1
                    13816   ; OS_EXIT_CRITICAL();
000049C0  46DF      13817          dc.w      18143
                    13818   ; return (OS_ERR_TASK_CREATE_ISR);
000049C2  703C      13819          moveq     #60,D0
000049C4  6000 00CC 13820          bra       OSTaskCreateExt_3
                    13821   OSTaskCreateExt_1:
                    13822   ; }
                    13823   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000049C8  C4BC 0000 13824          and.l     #255,D2
000049CC  00FF      
000049CE  2002      13825          move.l    D2,D0
000049D0  E588      13826          lsl.l     #2,D0
000049D2  2032 0800 13827          move.l    0(A2,D0.L),D0
000049D6  6600 00B6 13828          bne       OSTaskCreateExt_4
                    13829   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000049DA  C4BC 0000 13830          and.l     #255,D2
000049DE  00FF      
000049E0  2002      13831          move.l    D2,D0
000049E2  E588      13832          lsl.l     #2,D0
000049E4  25BC 0000 13833          move.l    #1,0(A2,D0.L)
000049E8  0001 0800 
                    13834   ; /* ... the same thing until task is created.              */
                    13835   ; OS_EXIT_CRITICAL();
000049EC  46DF      13836          dc.w      18143
                    13837   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13838   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
000049EE  C8BC 0000 13839          and.l     #65535,D4
000049F2  FFFF      
000049F4  2F04      13840          move.l    D4,-(A7)
000049F6  2F2E 0020 13841          move.l    32(A6),-(A7)
000049FA  2F2E 001C 13842          move.l    28(A6),-(A7)
000049FE  4EB9 0000 13843          jsr       _OS_TaskStkClr
00004A02  51E6      
00004A04  DEFC 000C 13844          add.w     #12,A7
                    13845   ; #endif
                    13846   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
00004A08  C8BC 0000 13847          and.l     #65535,D4
00004A0C  FFFF      
00004A0E  2F04      13848          move.l    D4,-(A7)
00004A10  2F2E 0010 13849          move.l    16(A6),-(A7)
00004A14  2F2E 000C 13850          move.l    12(A6),-(A7)
00004A18  2F2E 0008 13851          move.l    8(A6),-(A7)
00004A1C  4EB8 0C24 13852          jsr       _OSTaskStkInit
00004A20  DEFC 0010 13853          add.w     #16,A7
00004A24  2D40 FFFC 13854          move.l    D0,-4(A6)
                    13855   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
00004A28  C8BC 0000 13856          and.l     #65535,D4
00004A2C  FFFF      
00004A2E  2F04      13857          move.l    D4,-(A7)
00004A30  2F2E 0024 13858          move.l    36(A6),-(A7)
00004A34  2F2E 0020 13859          move.l    32(A6),-(A7)
00004A38  322E 001A 13860          move.w    26(A6),D1
00004A3C  C2BC 0000 13861          and.l     #65535,D1
00004A40  FFFF      
00004A42  2F01      13862          move.l    D1,-(A7)
00004A44  2F2E 001C 13863          move.l    28(A6),-(A7)
00004A48  2F2E FFFC 13864          move.l    -4(A6),-(A7)
00004A4C  C4BC 0000 13865          and.l     #255,D2
00004A50  00FF      
00004A52  2F02      13866          move.l    D2,-(A7)
00004A54  4EB8 1C3C 13867          jsr       _OS_TCBInit
00004A58  DEFC 001C 13868          add.w     #28,A7
00004A5C  1600      13869          move.b    D0,D3
                    13870   ; if (err == OS_ERR_NONE) {
00004A5E  4A03      13871          tst.b     D3
00004A60  6612      13872          bne.s     OSTaskCreateExt_6
                    13873   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
00004A62  1039 0800 13874          move.b    _OSRunning.L,D0
00004A66  0F18      
00004A68  0C00 0001 13875          cmp.b     #1,D0
00004A6C  6604      13876          bne.s     OSTaskCreateExt_8
                    13877   ; OS_Sched();
00004A6E  4EB8 1A22 13878          jsr       _OS_Sched
                    13879   OSTaskCreateExt_8:
00004A72  6016      13880          bra.s     OSTaskCreateExt_7
                    13881   OSTaskCreateExt_6:
                    13882   ; }
                    13883   ; } else {
                    13884   ; OS_ENTER_CRITICAL();
00004A74  40E7      13885          dc.w      16615
00004A76  007C      13886          dc.w      124
00004A78  0700      13887          dc.w      1792
                    13888   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
00004A7A  C4BC 0000 13889          and.l     #255,D2
00004A7E  00FF      
00004A80  2002      13890          move.l    D2,D0
00004A82  E588      13891          lsl.l     #2,D0
00004A84  42B2 0800 13892          clr.l     0(A2,D0.L)
                    13893   ; OS_EXIT_CRITICAL();
00004A88  46DF      13894          dc.w      18143
                    13895   OSTaskCreateExt_7:
                    13896   ; }
                    13897   ; return (err);
00004A8A  1003      13898          move.b    D3,D0
00004A8C  6004      13899          bra.s     OSTaskCreateExt_3
                    13900   OSTaskCreateExt_4:
                    13901   ; }
                    13902   ; OS_EXIT_CRITICAL();
00004A8E  46DF      13903          dc.w      18143
                    13904   ; return (OS_ERR_PRIO_EXIST);
00004A90  7028      13905          moveq     #40,D0
                    13906   OSTaskCreateExt_3:
00004A92  4CDF 041C 13907          movem.l   (A7)+,D2/D3/D4/A2
00004A96  4E5E      13908          unlk      A6
00004A98  4E75      13909          rts
                    13910   ; }
                    13911   ; #endif
                    13912   ; /*$PAGE*/
                    13913   ; /*
                    13914   ; *********************************************************************************************************
                    13915   ; *                                            DELETE A TASK
                    13916   ; *
                    13917   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13918   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13919   ; *              re-activated by creating the deleted task again.
                    13920   ; *
                    13921   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13922   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13923   ; *                      OS_PRIO_SELF.
                    13924   ; *
                    13925   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13926   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13927   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13928   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13929   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13930   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13931   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13932   ; *
                    13933   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13934   ; *                    a) by making it not ready
                    13935   ; *                    b) by removing it from any wait lists
                    13936   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13937   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13938   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13939   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13940   ; *              3) An ISR cannot delete a task.
                    13941   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13942   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13943   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13944   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13945   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13946   ; *********************************************************************************************************
                    13947   ; */
                    13948   ; #if OS_TASK_DEL_EN > 0u
                    13949   ; INT8U  OSTaskDel (INT8U prio)
                    13950   ; {
                    13951   _OSTaskDel:
00004A9A  4E56 0000 13952          link      A6,#0
00004A9E  48E7 3800 13953          movem.l   D2/D3/D4,-(A7)
00004AA2  162E 000B 13954          move.b    11(A6),D3
00004AA6  C6BC 0000 13955          and.l     #255,D3
00004AAA  00FF      
                    13956   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13957   ; OS_FLAG_NODE *pnode;
                    13958   ; #endif
                    13959   ; OS_TCB       *ptcb;
                    13960   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13961   ; OS_CPU_SR     cpu_sr = 0u;
                    13962   ; #endif
                    13963   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
00004AAC  1039 0800 13964          move.b    _OSIntNesting.L,D0
00004AB0  0F06      
00004AB2  0C00 0000 13965          cmp.b     #0,D0
00004AB6  6306      13966          bls.s     OSTaskDel_1
                    13967   ; return (OS_ERR_TASK_DEL_ISR);
00004AB8  7040      13968          moveq     #64,D0
00004ABA  6000 01A4 13969          bra       OSTaskDel_3
                    13970   OSTaskDel_1:
                    13971   ; }
                    13972   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00004ABE  0C03 003F 13973          cmp.b     #63,D3
00004AC2  6606      13974          bne.s     OSTaskDel_4
                    13975   ; return (OS_ERR_TASK_DEL_IDLE);
00004AC4  703E      13976          moveq     #62,D0
00004AC6  6000 0198 13977          bra       OSTaskDel_3
                    13978   OSTaskDel_4:
                    13979   ; }
                    13980   ; #if OS_ARG_CHK_EN > 0u
                    13981   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13982   ; if (prio != OS_PRIO_SELF) {
                    13983   ; return (OS_ERR_PRIO_INVALID);
                    13984   ; }
                    13985   ; }
                    13986   ; #endif
                    13987   ; /*$PAGE*/
                    13988   ; OS_ENTER_CRITICAL();
00004ACA  40E7      13989          dc.w      16615
00004ACC  007C      13990          dc.w      124
00004ACE  0700      13991          dc.w      1792
                    13992   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
00004AD0  0C03 00FF 13993          cmp.b     #255,D3
00004AD4  660A      13994          bne.s     OSTaskDel_6
                    13995   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
00004AD6  2079 0800 13996          move.l    _OSTCBCur.L,A0
00004ADA  1020      
00004ADC  1628 0034 13997          move.b    52(A0),D3
                    13998   OSTaskDel_6:
                    13999   ; }
                    14000   ; ptcb = OSTCBPrioTbl[prio];
00004AE0  C6BC 0000 14001          and.l     #255,D3
00004AE4  00FF      
00004AE6  2003      14002          move.l    D3,D0
00004AE8  E588      14003          lsl.l     #2,D0
00004AEA  41F9 0800 14004          lea       _OSTCBPrioTbl.L,A0
00004AEE  1030      
00004AF0  2430 0800 14005          move.l    0(A0,D0.L),D2
                    14006   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
00004AF4  4A82      14007          tst.l     D2
00004AF6  6608      14008          bne.s     OSTaskDel_8
                    14009   ; OS_EXIT_CRITICAL();
00004AF8  46DF      14010          dc.w      18143
                    14011   ; return (OS_ERR_TASK_NOT_EXIST);
00004AFA  7043      14012          moveq     #67,D0
00004AFC  6000 0162 14013          bra       OSTaskDel_3
                    14014   OSTaskDel_8:
                    14015   ; }
                    14016   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
00004B00  0C82 0000 14017          cmp.l     #1,D2
00004B04  0001      
00004B06  6608      14018          bne.s     OSTaskDel_10
                    14019   ; OS_EXIT_CRITICAL();
00004B08  46DF      14020          dc.w      18143
                    14021   ; return (OS_ERR_TASK_DEL);
00004B0A  703D      14022          moveq     #61,D0
00004B0C  6000 0152 14023          bra       OSTaskDel_3
                    14024   OSTaskDel_10:
                    14025   ; }
                    14026   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
00004B10  2042      14027          move.l    D2,A0
00004B12  1028 0036 14028          move.b    54(A0),D0
00004B16  C0BC 0000 14029          and.l     #255,D0
00004B1A  00FF      
00004B1C  41F9 0800 14030          lea       _OSRdyTbl.L,A0
00004B20  0F10      
00004B22  2242      14031          move.l    D2,A1
00004B24  1229 0037 14032          move.b    55(A1),D1
00004B28  4601      14033          not.b     D1
00004B2A  C330 0800 14034          and.b     D1,0(A0,D0.L)
                    14035   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
00004B2E  2042      14036          move.l    D2,A0
00004B30  1028 0036 14037          move.b    54(A0),D0
00004B34  C0BC 0000 14038          and.l     #255,D0
00004B38  00FF      
00004B3A  41F9 0800 14039          lea       _OSRdyTbl.L,A0
00004B3E  0F10      
00004B40  1030 0800 14040          move.b    0(A0,D0.L),D0
00004B44  660E      14041          bne.s     OSTaskDel_12
                    14042   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
00004B46  2042      14043          move.l    D2,A0
00004B48  1028 0038 14044          move.b    56(A0),D0
00004B4C  4600      14045          not.b     D0
00004B4E  C139 0800 14046          and.b     D0,_OSRdyGrp.L
00004B52  0F0E      
                    14047   OSTaskDel_12:
                    14048   ; }
                    14049   ; #if (OS_EVENT_EN)
                    14050   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
00004B54  2042      14051          move.l    D2,A0
00004B56  2028 001C 14052          move.l    28(A0),D0
00004B5A  670E      14053          beq.s     OSTaskDel_14
                    14054   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
00004B5C  2042      14055          move.l    D2,A0
00004B5E  2F28 001C 14056          move.l    28(A0),-(A7)
00004B62  2F02      14057          move.l    D2,-(A7)
00004B64  4EB8 1648 14058          jsr       _OS_EventTaskRemove
00004B68  504F      14059          addq.w    #8,A7
                    14060   OSTaskDel_14:
                    14061   ; }
                    14062   ; #if (OS_EVENT_MULTI_EN > 0u)
                    14063   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
00004B6A  2042      14064          move.l    D2,A0
00004B6C  2028 0020 14065          move.l    32(A0),D0
00004B70  670E      14066          beq.s     OSTaskDel_16
                    14067   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00004B72  2042      14068          move.l    D2,A0
00004B74  2F28 0020 14069          move.l    32(A0),-(A7)
00004B78  2F02      14070          move.l    D2,-(A7)
00004B7A  4EB8 169A 14071          jsr       _OS_EventTaskRemoveMulti
00004B7E  504F      14072          addq.w    #8,A7
                    14073   OSTaskDel_16:
                    14074   ; }
                    14075   ; #endif
                    14076   ; #endif
                    14077   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    14078   ; pnode = ptcb->OSTCBFlagNode;
00004B80  2042      14079          move.l    D2,A0
00004B82  2828 0028 14080          move.l    40(A0),D4
                    14081   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
00004B86  4A84      14082          tst.l     D4
00004B88  6708      14083          beq.s     OSTaskDel_18
                    14084   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00004B8A  2F04      14085          move.l    D4,-(A7)
00004B8C  4EB8 2852 14086          jsr       _OS_FlagUnlink
00004B90  584F      14087          addq.w    #4,A7
                    14088   OSTaskDel_18:
                    14089   ; }
                    14090   ; #endif
                    14091   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
00004B92  2042      14092          move.l    D2,A0
00004B94  42A8 002E 14093          clr.l     46(A0)
                    14094   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
00004B98  2042      14095          move.l    D2,A0
00004B9A  4228 0032 14096          clr.b     50(A0)
                    14097   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004B9E  2042      14098          move.l    D2,A0
00004BA0  4228 0033 14099          clr.b     51(A0)
                    14100   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
00004BA4  1039 0800 14101          move.b    _OSLockNesting.L,D0
00004BA8  0F08      
00004BAA  0C00 00FF 14102          cmp.b     #255,D0
00004BAE  6406      14103          bhs.s     OSTaskDel_20
                    14104   ; OSLockNesting++;
00004BB0  5239 0800 14105          addq.b    #1,_OSLockNesting.L
00004BB4  0F08      
                    14106   OSTaskDel_20:
                    14107   ; }
                    14108   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
00004BB6  46DF      14109          dc.w      18143
                    14110   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
00004BB8  4EB8 1440 14111          jsr       _OS_Dummy
                    14112   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00004BBC  40E7      14113          dc.w      16615
00004BBE  007C      14114          dc.w      124
00004BC0  0700      14115          dc.w      1792
                    14116   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
00004BC2  1039 0800 14117          move.b    _OSLockNesting.L,D0
00004BC6  0F08      
00004BC8  0C00 0000 14118          cmp.b     #0,D0
00004BCC  6306      14119          bls.s     OSTaskDel_22
                    14120   ; OSLockNesting--;
00004BCE  5339 0800 14121          subq.b    #1,_OSLockNesting.L
00004BD2  0F08      
                    14122   OSTaskDel_22:
                    14123   ; }
                    14124   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
00004BD4  2F02      14125          move.l    D2,-(A7)
00004BD6  4EB8 0D0E 14126          jsr       _OSTaskDelHook
00004BDA  584F      14127          addq.w    #4,A7
                    14128   ; OSTaskCtr--;                                        /* One less task being managed                 */
00004BDC  5339 0800 14129          subq.b    #1,_OSTaskCtr.L
00004BE0  0F1A      
                    14130   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
00004BE2  C6BC 0000 14131          and.l     #255,D3
00004BE6  00FF      
00004BE8  2003      14132          move.l    D3,D0
00004BEA  E588      14133          lsl.l     #2,D0
00004BEC  41F9 0800 14134          lea       _OSTCBPrioTbl.L,A0
00004BF0  1030      
00004BF2  42B0 0800 14135          clr.l     0(A0,D0.L)
                    14136   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
00004BF6  2042      14137          move.l    D2,A0
00004BF8  2028 0018 14138          move.l    24(A0),D0
00004BFC  6616      14139          bne.s     OSTaskDel_24
                    14140   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
00004BFE  2042      14141          move.l    D2,A0
00004C00  2068 0014 14142          move.l    20(A0),A0
00004C04  42A8 0018 14143          clr.l     24(A0)
                    14144   ; OSTCBList                  = ptcb->OSTCBNext;
00004C08  2042      14145          move.l    D2,A0
00004C0A  23E8 0014 14146          move.l    20(A0),_OSTCBList.L
00004C0E  0800 102C 
00004C12  601C      14147          bra.s     OSTaskDel_25
                    14148   OSTaskDel_24:
                    14149   ; } else {
                    14150   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
00004C14  2042      14151          move.l    D2,A0
00004C16  2242      14152          move.l    D2,A1
00004C18  2269 0018 14153          move.l    24(A1),A1
00004C1C  2368 0014 14154          move.l    20(A0),20(A1)
00004C20  0014      
                    14155   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
00004C22  2042      14156          move.l    D2,A0
00004C24  2242      14157          move.l    D2,A1
00004C26  2269 0014 14158          move.l    20(A1),A1
00004C2A  2368 0018 14159          move.l    24(A0),24(A1)
00004C2E  0018      
                    14160   OSTaskDel_25:
                    14161   ; }
                    14162   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
00004C30  2042      14163          move.l    D2,A0
00004C32  2179 0800 14164          move.l    _OSTCBFreeList.L,20(A0)
00004C36  1024 0014 
                    14165   ; OSTCBFreeList       = ptcb;
00004C3A  23C2 0800 14166          move.l    D2,_OSTCBFreeList.L
00004C3E  1024      
                    14167   ; #if OS_TASK_NAME_EN > 0u
                    14168   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
00004C40  41F9 0000 14169          lea       @ucos_ii_1.L,A0
00004C44  6AD0      
00004C46  2242      14170          move.l    D2,A1
00004C48  2348 004E 14171          move.l    A0,78(A1)
                    14172   ; #endif
                    14173   ; OS_EXIT_CRITICAL();
00004C4C  46DF      14174          dc.w      18143
                    14175   ; if (OSRunning == OS_TRUE) {
00004C4E  1039 0800 14176          move.b    _OSRunning.L,D0
00004C52  0F18      
00004C54  0C00 0001 14177          cmp.b     #1,D0
00004C58  6604      14178          bne.s     OSTaskDel_26
                    14179   ; OS_Sched();                                     /* Find new highest priority task              */
00004C5A  4EB8 1A22 14180          jsr       _OS_Sched
                    14181   OSTaskDel_26:
                    14182   ; }
                    14183   ; return (OS_ERR_NONE);
00004C5E  4200      14184          clr.b     D0
                    14185   OSTaskDel_3:
00004C60  4CDF 001C 14186          movem.l   (A7)+,D2/D3/D4
00004C64  4E5E      14187          unlk      A6
00004C66  4E75      14188          rts
                    14189   ; }
                    14190   ; #endif
                    14191   ; /*$PAGE*/
                    14192   ; /*
                    14193   ; *********************************************************************************************************
                    14194   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    14195   ; *
                    14196   ; * Description: This function is used to:
                    14197   ; *                   a) notify a task to delete itself.
                    14198   ; *                   b) to see if a task requested that the current task delete itself.
                    14199   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    14200   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    14201   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    14202   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    14203   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    14204   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    14205   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    14206   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    14207   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    14208   ; *              this:
                    14209   ; *
                    14210   ; *                   void Task(void *p_arg)
                    14211   ; *                   {
                    14212   ; *                       .
                    14213   ; *                       .
                    14214   ; *                       while (1) {
                    14215   ; *                           OSTimeDly(1);
                    14216   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    14217   ; *                               Release any owned resources;
                    14218   ; *                               De-allocate any dynamic memory;
                    14219   ; *                               OSTaskDel(OS_PRIO_SELF);
                    14220   ; *                           }
                    14221   ; *                       }
                    14222   ; *                   }
                    14223   ; *
                    14224   ; * Arguments  : prio    is the priority of the task to request the delete from
                    14225   ; *
                    14226   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    14227   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    14228   ; *                                     the request has been executed.
                    14229   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    14230   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    14231   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14232   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14233   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    14234   ; *                                     deleted.
                    14235   ; *********************************************************************************************************
                    14236   ; */
                    14237   ; /*$PAGE*/
                    14238   ; #if OS_TASK_DEL_EN > 0u
                    14239   ; INT8U  OSTaskDelReq (INT8U prio)
                    14240   ; {
                    14241   _OSTaskDelReq:
00004C68  4E56 FFFC 14242          link      A6,#-4
00004C6C  48E7 3000 14243          movem.l   D2/D3,-(A7)
00004C70  162E 000B 14244          move.b    11(A6),D3
00004C74  C6BC 0000 14245          and.l     #255,D3
00004C78  00FF      
                    14246   ; INT8U      stat;
                    14247   ; OS_TCB    *ptcb;
                    14248   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14249   ; OS_CPU_SR  cpu_sr = 0u;
                    14250   ; #endif
                    14251   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004C7A  0C03 003F 14252          cmp.b     #63,D3
00004C7E  6606      14253          bne.s     OSTaskDelReq_1
                    14254   ; return (OS_ERR_TASK_DEL_IDLE);
00004C80  703E      14255          moveq     #62,D0
00004C82  6000 0062 14256          bra       OSTaskDelReq_3
                    14257   OSTaskDelReq_1:
                    14258   ; }
                    14259   ; #if OS_ARG_CHK_EN > 0u
                    14260   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14261   ; if (prio != OS_PRIO_SELF) {
                    14262   ; return (OS_ERR_PRIO_INVALID);
                    14263   ; }
                    14264   ; }
                    14265   ; #endif
                    14266   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
00004C86  0C03 00FF 14267          cmp.b     #255,D3
00004C8A  661C      14268          bne.s     OSTaskDelReq_4
                    14269   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004C8C  40E7      14270          dc.w      16615
00004C8E  007C      14271          dc.w      124
00004C90  0700      14272          dc.w      1792
                    14273   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
00004C92  2079 0800 14274          move.l    _OSTCBCur.L,A0
00004C96  1020      
00004C98  1D68 0039 14275          move.b    57(A0),-1(A6)
00004C9C  FFFF      
                    14276   ; OS_EXIT_CRITICAL();
00004C9E  46DF      14277          dc.w      18143
                    14278   ; return (stat);
00004CA0  102E FFFF 14279          move.b    -1(A6),D0
00004CA4  6000 0040 14280          bra       OSTaskDelReq_3
                    14281   OSTaskDelReq_4:
                    14282   ; }
                    14283   ; OS_ENTER_CRITICAL();
00004CA8  40E7      14284          dc.w      16615
00004CAA  007C      14285          dc.w      124
00004CAC  0700      14286          dc.w      1792
                    14287   ; ptcb = OSTCBPrioTbl[prio];
00004CAE  C6BC 0000 14288          and.l     #255,D3
00004CB2  00FF      
00004CB4  2003      14289          move.l    D3,D0
00004CB6  E588      14290          lsl.l     #2,D0
00004CB8  41F9 0800 14291          lea       _OSTCBPrioTbl.L,A0
00004CBC  1030      
00004CBE  2430 0800 14292          move.l    0(A0,D0.L),D2
                    14293   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00004CC2  4A82      14294          tst.l     D2
00004CC4  6606      14295          bne.s     OSTaskDelReq_6
                    14296   ; OS_EXIT_CRITICAL();
00004CC6  46DF      14297          dc.w      18143
                    14298   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
00004CC8  7043      14299          moveq     #67,D0
00004CCA  601A      14300          bra.s     OSTaskDelReq_3
                    14301   OSTaskDelReq_6:
                    14302   ; }
                    14303   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00004CCC  0C82 0000 14304          cmp.l     #1,D2
00004CD0  0001      
00004CD2  6606      14305          bne.s     OSTaskDelReq_8
                    14306   ; OS_EXIT_CRITICAL();
00004CD4  46DF      14307          dc.w      18143
                    14308   ; return (OS_ERR_TASK_DEL);
00004CD6  703D      14309          moveq     #61,D0
00004CD8  600C      14310          bra.s     OSTaskDelReq_3
                    14311   OSTaskDelReq_8:
                    14312   ; }
                    14313   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00004CDA  2042      14314          move.l    D2,A0
00004CDC  117C 003F 14315          move.b    #63,57(A0)
00004CE0  0039      
                    14316   ; OS_EXIT_CRITICAL();
00004CE2  46DF      14317          dc.w      18143
                    14318   ; return (OS_ERR_NONE);
00004CE4  4200      14319          clr.b     D0
                    14320   OSTaskDelReq_3:
00004CE6  4CDF 000C 14321          movem.l   (A7)+,D2/D3
00004CEA  4E5E      14322          unlk      A6
00004CEC  4E75      14323          rts
                    14324   ; }
                    14325   ; #endif
                    14326   ; /*$PAGE*/
                    14327   ; /*
                    14328   ; *********************************************************************************************************
                    14329   ; *                                       GET THE NAME OF A TASK
                    14330   ; *
                    14331   ; * Description: This function is called to obtain the name of a task.
                    14332   ; *
                    14333   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    14334   ; *
                    14335   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    14336   ; *
                    14337   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    14338   ; *
                    14339   ; *                        OS_ERR_NONE                if the requested task is resumed
                    14340   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    14341   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    14342   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    14343   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    14344   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    14345   ; *
                    14346   ; *
                    14347   ; * Returns    : The length of the string or 0 if the task does not exist.
                    14348   ; *********************************************************************************************************
                    14349   ; */
                    14350   ; #if OS_TASK_NAME_EN > 0u
                    14351   ; INT8U  OSTaskNameGet (INT8U    prio,
                    14352   ; INT8U  **pname,
                    14353   ; INT8U   *perr)
                    14354   ; {
                    14355   _OSTaskNameGet:
00004CEE  4E56 FFFC 14356          link      A6,#-4
00004CF2  48E7 3800 14357          movem.l   D2/D3/D4,-(A7)
00004CF6  262E 0010 14358          move.l    16(A6),D3
00004CFA  182E 000B 14359          move.b    11(A6),D4
00004CFE  C8BC 0000 14360          and.l     #255,D4
00004D02  00FF      
                    14361   ; OS_TCB    *ptcb;
                    14362   ; INT8U      len;
                    14363   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    14364   ; OS_CPU_SR  cpu_sr = 0u;
                    14365   ; #endif
                    14366   ; #ifdef OS_SAFETY_CRITICAL
                    14367   ; if (perr == (INT8U *)0) {
                    14368   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14369   ; return (0u);
                    14370   ; }
                    14371   ; #endif
                    14372   ; #if OS_ARG_CHK_EN > 0u
                    14373   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    14374   ; if (prio != OS_PRIO_SELF) {
                    14375   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    14376   ; return (0u);
                    14377   ; }
                    14378   ; }
                    14379   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    14380   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    14381   ; return (0u);
                    14382   ; }
                    14383   ; #endif
                    14384   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00004D04  1039 0800 14385          move.b    _OSIntNesting.L,D0
00004D08  0F06      
00004D0A  0C00 0000 14386          cmp.b     #0,D0
00004D0E  630C      14387          bls.s     OSTaskNameGet_1
                    14388   ; *perr = OS_ERR_NAME_GET_ISR;
00004D10  2043      14389          move.l    D3,A0
00004D12  10BC 0011 14390          move.b    #17,(A0)
                    14391   ; return (0u);
00004D16  4200      14392          clr.b     D0
00004D18  6000 0076 14393          bra       OSTaskNameGet_3
                    14394   OSTaskNameGet_1:
                    14395   ; }
                    14396   ; OS_ENTER_CRITICAL();
00004D1C  40E7      14397          dc.w      16615
00004D1E  007C      14398          dc.w      124
00004D20  0700      14399          dc.w      1792
                    14400   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
00004D22  0C04 00FF 14401          cmp.b     #255,D4
00004D26  660A      14402          bne.s     OSTaskNameGet_4
                    14403   ; prio = OSTCBCur->OSTCBPrio;
00004D28  2079 0800 14404          move.l    _OSTCBCur.L,A0
00004D2C  1020      
00004D2E  1828 0034 14405          move.b    52(A0),D4
                    14406   OSTaskNameGet_4:
                    14407   ; }
                    14408   ; ptcb = OSTCBPrioTbl[prio];
00004D32  C8BC 0000 14409          and.l     #255,D4
00004D36  00FF      
00004D38  2004      14410          move.l    D4,D0
00004D3A  E588      14411          lsl.l     #2,D0
00004D3C  41F9 0800 14412          lea       _OSTCBPrioTbl.L,A0
00004D40  1030      
00004D42  2430 0800 14413          move.l    0(A0,D0.L),D2
                    14414   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
00004D46  4A82      14415          tst.l     D2
00004D48  660E      14416          bne.s     OSTaskNameGet_6
                    14417   ; OS_EXIT_CRITICAL();                              /* No                                         */
00004D4A  46DF      14418          dc.w      18143
                    14419   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004D4C  2043      14420          move.l    D3,A0
00004D4E  10BC 0043 14421          move.b    #67,(A0)
                    14422   ; return (0u);
00004D52  4200      14423          clr.b     D0
00004D54  6000 003A 14424          bra       OSTaskNameGet_3
                    14425   OSTaskNameGet_6:
                    14426   ; }
                    14427   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
00004D58  0C82 0000 14428          cmp.l     #1,D2
00004D5C  0001      
00004D5E  660C      14429          bne.s     OSTaskNameGet_8
                    14430   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
00004D60  46DF      14431          dc.w      18143
                    14432   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004D62  2043      14433          move.l    D3,A0
00004D64  10BC 0043 14434          move.b    #67,(A0)
                    14435   ; return (0u);
00004D68  4200      14436          clr.b     D0
00004D6A  6024      14437          bra.s     OSTaskNameGet_3
                    14438   OSTaskNameGet_8:
                    14439   ; }
                    14440   ; *pname = ptcb->OSTCBTaskName;
00004D6C  2042      14441          move.l    D2,A0
00004D6E  226E 000C 14442          move.l    12(A6),A1
00004D72  22A8 004E 14443          move.l    78(A0),(A1)
                    14444   ; len    = OS_StrLen(*pname);
00004D76  206E 000C 14445          move.l    12(A6),A0
00004D7A  2F10      14446          move.l    (A0),-(A7)
00004D7C  4EB8 1ACC 14447          jsr       _OS_StrLen
00004D80  584F      14448          addq.w    #4,A7
00004D82  1D40 FFFF 14449          move.b    D0,-1(A6)
                    14450   ; OS_EXIT_CRITICAL();
00004D86  46DF      14451          dc.w      18143
                    14452   ; *perr  = OS_ERR_NONE;
00004D88  2043      14453          move.l    D3,A0
00004D8A  4210      14454          clr.b     (A0)
                    14455   ; return (len);
00004D8C  102E FFFF 14456          move.b    -1(A6),D0
                    14457   OSTaskNameGet_3:
00004D90  4CDF 001C 14458          movem.l   (A7)+,D2/D3/D4
00004D94  4E5E      14459          unlk      A6
00004D96  4E75      14460          rts
                    14461   ; }
                    14462   ; #endif
                    14463   ; /*$PAGE*/
                    14464   ; /*
                    14465   ; *********************************************************************************************************
                    14466   ; *                                       ASSIGN A NAME TO A TASK
                    14467   ; *
                    14468   ; * Description: This function is used to set the name of a task.
                    14469   ; *
                    14470   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    14471   ; *
                    14472   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    14473   ; *
                    14474   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    14475   ; *
                    14476   ; *                        OS_ERR_NONE                if the requested task is resumed
                    14477   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    14478   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    14479   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    14480   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    14481   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    14482   ; *
                    14483   ; * Returns    : None
                    14484   ; *********************************************************************************************************
                    14485   ; */
                    14486   ; #if OS_TASK_NAME_EN > 0u
                    14487   ; void  OSTaskNameSet (INT8U   prio,
                    14488   ; INT8U  *pname,
                    14489   ; INT8U  *perr)
                    14490   ; {
                    14491   _OSTaskNameSet:
00004D98  4E56 0000 14492          link      A6,#0
00004D9C  48E7 3800 14493          movem.l   D2/D3/D4,-(A7)
00004DA0  262E 0010 14494          move.l    16(A6),D3
00004DA4  182E 000B 14495          move.b    11(A6),D4
00004DA8  C8BC 0000 14496          and.l     #255,D4
00004DAC  00FF      
                    14497   ; OS_TCB    *ptcb;
                    14498   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    14499   ; OS_CPU_SR  cpu_sr = 0u;
                    14500   ; #endif
                    14501   ; #ifdef OS_SAFETY_CRITICAL
                    14502   ; if (perr == (INT8U *)0) {
                    14503   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14504   ; return;
                    14505   ; }
                    14506   ; #endif
                    14507   ; #if OS_ARG_CHK_EN > 0u
                    14508   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    14509   ; if (prio != OS_PRIO_SELF) {
                    14510   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    14511   ; return;
                    14512   ; }
                    14513   ; }
                    14514   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    14515   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    14516   ; return;
                    14517   ; }
                    14518   ; #endif
                    14519   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004DAE  1039 0800 14520          move.b    _OSIntNesting.L,D0
00004DB2  0F06      
00004DB4  0C00 0000 14521          cmp.b     #0,D0
00004DB8  630A      14522          bls.s     OSTaskNameSet_1
                    14523   ; *perr = OS_ERR_NAME_SET_ISR;
00004DBA  2043      14524          move.l    D3,A0
00004DBC  10BC 0012 14525          move.b    #18,(A0)
                    14526   ; return;
00004DC0  6000 005A 14527          bra       OSTaskNameSet_3
                    14528   OSTaskNameSet_1:
                    14529   ; }
                    14530   ; OS_ENTER_CRITICAL();
00004DC4  40E7      14531          dc.w      16615
00004DC6  007C      14532          dc.w      124
00004DC8  0700      14533          dc.w      1792
                    14534   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
00004DCA  0C04 00FF 14535          cmp.b     #255,D4
00004DCE  660A      14536          bne.s     OSTaskNameSet_4
                    14537   ; prio = OSTCBCur->OSTCBPrio;
00004DD0  2079 0800 14538          move.l    _OSTCBCur.L,A0
00004DD4  1020      
00004DD6  1828 0034 14539          move.b    52(A0),D4
                    14540   OSTaskNameSet_4:
                    14541   ; }
                    14542   ; ptcb = OSTCBPrioTbl[prio];
00004DDA  C8BC 0000 14543          and.l     #255,D4
00004DDE  00FF      
00004DE0  2004      14544          move.l    D4,D0
00004DE2  E588      14545          lsl.l     #2,D0
00004DE4  41F9 0800 14546          lea       _OSTCBPrioTbl.L,A0
00004DE8  1030      
00004DEA  2430 0800 14547          move.l    0(A0,D0.L),D2
                    14548   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
00004DEE  4A82      14549          tst.l     D2
00004DF0  660A      14550          bne.s     OSTaskNameSet_6
                    14551   ; OS_EXIT_CRITICAL();                          /* No                                             */
00004DF2  46DF      14552          dc.w      18143
                    14553   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004DF4  2043      14554          move.l    D3,A0
00004DF6  10BC 0043 14555          move.b    #67,(A0)
                    14556   ; return;
00004DFA  6020      14557          bra.s     OSTaskNameSet_3
                    14558   OSTaskNameSet_6:
                    14559   ; }
                    14560   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
00004DFC  0C82 0000 14561          cmp.l     #1,D2
00004E00  0001      
00004E02  660A      14562          bne.s     OSTaskNameSet_8
                    14563   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
00004E04  46DF      14564          dc.w      18143
                    14565   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004E06  2043      14566          move.l    D3,A0
00004E08  10BC 0043 14567          move.b    #67,(A0)
                    14568   ; return;
00004E0C  600E      14569          bra.s     OSTaskNameSet_3
                    14570   OSTaskNameSet_8:
                    14571   ; }
                    14572   ; ptcb->OSTCBTaskName = pname;
00004E0E  2042      14573          move.l    D2,A0
00004E10  216E 000C 14574          move.l    12(A6),78(A0)
00004E14  004E      
                    14575   ; OS_EXIT_CRITICAL();
00004E16  46DF      14576          dc.w      18143
                    14577   ; *perr               = OS_ERR_NONE;
00004E18  2043      14578          move.l    D3,A0
00004E1A  4210      14579          clr.b     (A0)
                    14580   OSTaskNameSet_3:
00004E1C  4CDF 001C 14581          movem.l   (A7)+,D2/D3/D4
00004E20  4E5E      14582          unlk      A6
00004E22  4E75      14583          rts
                    14584   ; }
                    14585   ; #endif
                    14586   ; /*$PAGE*/
                    14587   ; /*
                    14588   ; *********************************************************************************************************
                    14589   ; *                                       RESUME A SUSPENDED TASK
                    14590   ; *
                    14591   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    14592   ; *              will remove an explicit task suspension.
                    14593   ; *
                    14594   ; * Arguments  : prio     is the priority of the task to resume.
                    14595   ; *
                    14596   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    14597   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    14598   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    14599   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    14600   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    14601   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    14602   ; *********************************************************************************************************
                    14603   ; */
                    14604   ; #if OS_TASK_SUSPEND_EN > 0u
                    14605   ; INT8U  OSTaskResume (INT8U prio)
                    14606   ; {
                    14607   _OSTaskResume:
00004E24  4E56 0000 14608          link      A6,#0
00004E28  2F02      14609          move.l    D2,-(A7)
                    14610   ; OS_TCB    *ptcb;
                    14611   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    14612   ; OS_CPU_SR  cpu_sr = 0u;
                    14613   ; #endif
                    14614   ; #if OS_ARG_CHK_EN > 0u
                    14615   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    14616   ; return (OS_ERR_PRIO_INVALID);
                    14617   ; }
                    14618   ; #endif
                    14619   ; OS_ENTER_CRITICAL();
00004E2A  40E7      14620          dc.w      16615
00004E2C  007C      14621          dc.w      124
00004E2E  0700      14622          dc.w      1792
                    14623   ; ptcb = OSTCBPrioTbl[prio];
00004E30  102E 000B 14624          move.b    11(A6),D0
00004E34  C0BC 0000 14625          and.l     #255,D0
00004E38  00FF      
00004E3A  E588      14626          lsl.l     #2,D0
00004E3C  41F9 0800 14627          lea       _OSTCBPrioTbl.L,A0
00004E40  1030      
00004E42  2430 0800 14628          move.l    0(A0,D0.L),D2
                    14629   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
00004E46  4A82      14630          tst.l     D2
00004E48  6608      14631          bne.s     OSTaskResume_1
                    14632   ; OS_EXIT_CRITICAL();
00004E4A  46DF      14633          dc.w      18143
                    14634   ; return (OS_ERR_TASK_RESUME_PRIO);
00004E4C  7046      14635          moveq     #70,D0
00004E4E  6000 0088 14636          bra       OSTaskResume_3
                    14637   OSTaskResume_1:
                    14638   ; }
                    14639   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004E52  0C82 0000 14640          cmp.l     #1,D2
00004E56  0001      
00004E58  6608      14641          bne.s     OSTaskResume_4
                    14642   ; OS_EXIT_CRITICAL();
00004E5A  46DF      14643          dc.w      18143
                    14644   ; return (OS_ERR_TASK_NOT_EXIST);
00004E5C  7043      14645          moveq     #67,D0
00004E5E  6000 0078 14646          bra       OSTaskResume_3
                    14647   OSTaskResume_4:
                    14648   ; }
                    14649   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004E62  2042      14650          move.l    D2,A0
00004E64  1028 0032 14651          move.b    50(A0),D0
00004E68  C03C 0008 14652          and.b     #8,D0
00004E6C  6700 0066 14653          beq       OSTaskResume_6
                    14654   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004E70  2042      14655          move.l    D2,A0
00004E72  7008      14656          moveq     #8,D0
00004E74  4600      14657          not.b     D0
00004E76  C128 0032 14658          and.b     D0,50(A0)
                    14659   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004E7A  2042      14660          move.l    D2,A0
00004E7C  1028 0032 14661          move.b    50(A0),D0
00004E80  6600 004C 14662          bne       OSTaskResume_8
                    14663   ; if (ptcb->OSTCBDly == 0u) {
00004E84  2042      14664          move.l    D2,A0
00004E86  2028 002E 14665          move.l    46(A0),D0
00004E8A  6600 003E 14666          bne       OSTaskResume_10
                    14667   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004E8E  2042      14668          move.l    D2,A0
00004E90  1028 0038 14669          move.b    56(A0),D0
00004E94  8139 0800 14670          or.b      D0,_OSRdyGrp.L
00004E98  0F0E      
                    14671   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004E9A  2042      14672          move.l    D2,A0
00004E9C  1028 0036 14673          move.b    54(A0),D0
00004EA0  C0BC 0000 14674          and.l     #255,D0
00004EA4  00FF      
00004EA6  41F9 0800 14675          lea       _OSRdyTbl.L,A0
00004EAA  0F10      
00004EAC  2242      14676          move.l    D2,A1
00004EAE  1229 0037 14677          move.b    55(A1),D1
00004EB2  8330 0800 14678          or.b      D1,0(A0,D0.L)
                    14679   ; OS_EXIT_CRITICAL();
00004EB6  46DF      14680          dc.w      18143
                    14681   ; if (OSRunning == OS_TRUE) {
00004EB8  1039 0800 14682          move.b    _OSRunning.L,D0
00004EBC  0F18      
00004EBE  0C00 0001 14683          cmp.b     #1,D0
00004EC2  6604      14684          bne.s     OSTaskResume_12
                    14685   ; OS_Sched();                               /* Find new highest priority task        */
00004EC4  4EB8 1A22 14686          jsr       _OS_Sched
                    14687   OSTaskResume_12:
00004EC8  6002      14688          bra.s     OSTaskResume_11
                    14689   OSTaskResume_10:
                    14690   ; }
                    14691   ; } else {
                    14692   ; OS_EXIT_CRITICAL();
00004ECA  46DF      14693          dc.w      18143
                    14694   OSTaskResume_11:
00004ECC  6002      14695          bra.s     OSTaskResume_9
                    14696   OSTaskResume_8:
                    14697   ; }
                    14698   ; } else {                                              /* Must be pending on event              */
                    14699   ; OS_EXIT_CRITICAL();
00004ECE  46DF      14700          dc.w      18143
                    14701   OSTaskResume_9:
                    14702   ; }
                    14703   ; return (OS_ERR_NONE);
00004ED0  4200      14704          clr.b     D0
00004ED2  6004      14705          bra.s     OSTaskResume_3
                    14706   OSTaskResume_6:
                    14707   ; }
                    14708   ; OS_EXIT_CRITICAL();
00004ED4  46DF      14709          dc.w      18143
                    14710   ; return (OS_ERR_TASK_NOT_SUSPENDED);
00004ED6  7044      14711          moveq     #68,D0
                    14712   OSTaskResume_3:
00004ED8  241F      14713          move.l    (A7)+,D2
00004EDA  4E5E      14714          unlk      A6
00004EDC  4E75      14715          rts
                    14716   ; }
                    14717   ; #endif
                    14718   ; /*$PAGE*/
                    14719   ; /*
                    14720   ; *********************************************************************************************************
                    14721   ; *                                           STACK CHECKING
                    14722   ; *
                    14723   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14724   ; *              stack.
                    14725   ; *
                    14726   ; * Arguments  : prio          is the task priority
                    14727   ; *
                    14728   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14729   ; *
                    14730   ; * Returns    : OS_ERR_NONE            upon success
                    14731   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14732   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14733   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14734   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14735   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14736   ; *********************************************************************************************************
                    14737   ; */
                    14738   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14739   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14740   ; OS_STK_DATA  *p_stk_data)
                    14741   ; {
                    14742   _OSTaskStkChk:
00004EDE  4E56 FFF8 14743          link      A6,#-8
00004EE2  48E7 3C00 14744          movem.l   D2/D3/D4/D5,-(A7)
00004EE6  282E 000C 14745          move.l    12(A6),D4
00004EEA  1A2E 000B 14746          move.b    11(A6),D5
00004EEE  CABC 0000 14747          and.l     #255,D5
00004EF2  00FF      
                    14748   ; OS_TCB    *ptcb;
                    14749   ; OS_STK    *pchk;
                    14750   ; INT32U     nfree;
                    14751   ; INT32U     size;
                    14752   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14753   ; OS_CPU_SR  cpu_sr = 0u;
                    14754   ; #endif
                    14755   ; #if OS_ARG_CHK_EN > 0u
                    14756   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14757   ; if (prio != OS_PRIO_SELF) {
                    14758   ; return (OS_ERR_PRIO_INVALID);
                    14759   ; }
                    14760   ; }
                    14761   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14762   ; return (OS_ERR_PDATA_NULL);
                    14763   ; }
                    14764   ; #endif
                    14765   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00004EF4  2044      14766          move.l    D4,A0
00004EF6  4290      14767          clr.l     (A0)
                    14768   ; p_stk_data->OSUsed = 0u;
00004EF8  2044      14769          move.l    D4,A0
00004EFA  42A8 0004 14770          clr.l     4(A0)
                    14771   ; OS_ENTER_CRITICAL();
00004EFE  40E7      14772          dc.w      16615
00004F00  007C      14773          dc.w      124
00004F02  0700      14774          dc.w      1792
                    14775   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
00004F04  0C05 00FF 14776          cmp.b     #255,D5
00004F08  660A      14777          bne.s     OSTaskStkChk_1
                    14778   ; prio = OSTCBCur->OSTCBPrio;
00004F0A  2079 0800 14779          move.l    _OSTCBCur.L,A0
00004F0E  1020      
00004F10  1A28 0034 14780          move.b    52(A0),D5
                    14781   OSTaskStkChk_1:
                    14782   ; }
                    14783   ; ptcb = OSTCBPrioTbl[prio];
00004F14  CABC 0000 14784          and.l     #255,D5
00004F18  00FF      
00004F1A  2005      14785          move.l    D5,D0
00004F1C  E588      14786          lsl.l     #2,D0
00004F1E  41F9 0800 14787          lea       _OSTCBPrioTbl.L,A0
00004F22  1030      
00004F24  2430 0800 14788          move.l    0(A0,D0.L),D2
                    14789   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00004F28  4A82      14790          tst.l     D2
00004F2A  6608      14791          bne.s     OSTaskStkChk_3
                    14792   ; OS_EXIT_CRITICAL();
00004F2C  46DF      14793          dc.w      18143
                    14794   ; return (OS_ERR_TASK_NOT_EXIST);
00004F2E  7043      14795          moveq     #67,D0
00004F30  6000 005C 14796          bra       OSTaskStkChk_5
                    14797   OSTaskStkChk_3:
                    14798   ; }
                    14799   ; if (ptcb == OS_TCB_RESERVED) {
00004F34  0C82 0000 14800          cmp.l     #1,D2
00004F38  0001      
00004F3A  6608      14801          bne.s     OSTaskStkChk_6
                    14802   ; OS_EXIT_CRITICAL();
00004F3C  46DF      14803          dc.w      18143
                    14804   ; return (OS_ERR_TASK_NOT_EXIST);
00004F3E  7043      14805          moveq     #67,D0
00004F40  6000 004C 14806          bra       OSTaskStkChk_5
                    14807   OSTaskStkChk_6:
                    14808   ; }
                    14809   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
00004F44  2042      14810          move.l    D2,A0
00004F46  3028 0010 14811          move.w    16(A0),D0
00004F4A  C07C 0001 14812          and.w     #1,D0
00004F4E  6608      14813          bne.s     OSTaskStkChk_8
                    14814   ; OS_EXIT_CRITICAL();
00004F50  46DF      14815          dc.w      18143
                    14816   ; return (OS_ERR_TASK_OPT);
00004F52  7045      14817          moveq     #69,D0
00004F54  6000 0038 14818          bra       OSTaskStkChk_5
                    14819   OSTaskStkChk_8:
                    14820   ; }
                    14821   ; nfree = 0u;
00004F58  4283      14822          clr.l     D3
                    14823   ; size  = ptcb->OSTCBStkSize;
00004F5A  2042      14824          move.l    D2,A0
00004F5C  2D68 000C 14825          move.l    12(A0),-4(A6)
00004F60  FFFC      
                    14826   ; pchk  = ptcb->OSTCBStkBottom;
00004F62  2042      14827          move.l    D2,A0
00004F64  2D68 0008 14828          move.l    8(A0),-8(A6)
00004F68  FFF8      
                    14829   ; OS_EXIT_CRITICAL();
00004F6A  46DF      14830          dc.w      18143
                    14831   ; #if OS_STK_GROWTH == 1u
                    14832   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14833   OSTaskStkChk_10:
00004F6C  206E FFF8 14834          move.l    -8(A6),A0
00004F70  54AE FFF8 14835          addq.l    #2,-8(A6)
00004F74  3010      14836          move.w    (A0),D0
00004F76  6604      14837          bne.s     OSTaskStkChk_12
                    14838   ; nfree++;
00004F78  5283      14839          addq.l    #1,D3
00004F7A  60F0      14840          bra       OSTaskStkChk_10
                    14841   OSTaskStkChk_12:
                    14842   ; }
                    14843   ; #else
                    14844   ; while (*pchk-- == (OS_STK)0) {
                    14845   ; nfree++;
                    14846   ; }
                    14847   ; #endif
                    14848   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004F7C  2044      14849          move.l    D4,A0
00004F7E  2083      14850          move.l    D3,(A0)
                    14851   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004F80  202E FFFC 14852          move.l    -4(A6),D0
00004F84  9083      14853          sub.l     D3,D0
00004F86  2044      14854          move.l    D4,A0
00004F88  2140 0004 14855          move.l    D0,4(A0)
                    14856   ; return (OS_ERR_NONE);
00004F8C  4200      14857          clr.b     D0
                    14858   OSTaskStkChk_5:
00004F8E  4CDF 003C 14859          movem.l   (A7)+,D2/D3/D4/D5
00004F92  4E5E      14860          unlk      A6
00004F94  4E75      14861          rts
                    14862   ; }
                    14863   ; #endif
                    14864   ; /*$PAGE*/
                    14865   ; /*
                    14866   ; *********************************************************************************************************
                    14867   ; *                                           SUSPEND A TASK
                    14868   ; *
                    14869   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14870   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14871   ; *
                    14872   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14873   ; *                       calling task will suspend itself and rescheduling will occur.
                    14874   ; *
                    14875   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14876   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14877   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14878   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14879   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14880   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14881   ; *
                    14882   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14883   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14884   ; *              running when the event arrives.
                    14885   ; *********************************************************************************************************
                    14886   ; */
                    14887   ; #if OS_TASK_SUSPEND_EN > 0u
                    14888   ; INT8U  OSTaskSuspend (INT8U prio)
                    14889   ; {
                    14890   _OSTaskSuspend:
00004F96  4E56 0000 14891          link      A6,#0
00004F9A  48E7 3C00 14892          movem.l   D2/D3/D4/D5,-(A7)
00004F9E  182E 000B 14893          move.b    11(A6),D4
00004FA2  C8BC 0000 14894          and.l     #255,D4
00004FA6  00FF      
                    14895   ; BOOLEAN    self;
                    14896   ; OS_TCB    *ptcb;
                    14897   ; INT8U      y;
                    14898   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14899   ; OS_CPU_SR  cpu_sr = 0u;
                    14900   ; #endif
                    14901   ; #if OS_ARG_CHK_EN > 0u
                    14902   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14903   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14904   ; }
                    14905   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14906   ; if (prio != OS_PRIO_SELF) {
                    14907   ; return (OS_ERR_PRIO_INVALID);
                    14908   ; }
                    14909   ; }
                    14910   ; #endif
                    14911   ; OS_ENTER_CRITICAL();
00004FA8  40E7      14912          dc.w      16615
00004FAA  007C      14913          dc.w      124
00004FAC  0700      14914          dc.w      1792
                    14915   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004FAE  0C04 00FF 14916          cmp.b     #255,D4
00004FB2  660E      14917          bne.s     OSTaskSuspend_1
                    14918   ; prio = OSTCBCur->OSTCBPrio;
00004FB4  2079 0800 14919          move.l    _OSTCBCur.L,A0
00004FB8  1020      
00004FBA  1828 0034 14920          move.b    52(A0),D4
                    14921   ; self = OS_TRUE;
00004FBE  7601      14922          moveq     #1,D3
00004FC0  6012      14923          bra.s     OSTaskSuspend_4
                    14924   OSTaskSuspend_1:
                    14925   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004FC2  2079 0800 14926          move.l    _OSTCBCur.L,A0
00004FC6  1020      
00004FC8  B828 0034 14927          cmp.b     52(A0),D4
00004FCC  6604      14928          bne.s     OSTaskSuspend_3
                    14929   ; self = OS_TRUE;
00004FCE  7601      14930          moveq     #1,D3
00004FD0  6002      14931          bra.s     OSTaskSuspend_4
                    14932   OSTaskSuspend_3:
                    14933   ; } else {
                    14934   ; self = OS_FALSE;                                        /* No suspending another task          */
00004FD2  4203      14935          clr.b     D3
                    14936   OSTaskSuspend_4:
                    14937   ; }
                    14938   ; ptcb = OSTCBPrioTbl[prio];
00004FD4  C8BC 0000 14939          and.l     #255,D4
00004FD8  00FF      
00004FDA  2004      14940          move.l    D4,D0
00004FDC  E588      14941          lsl.l     #2,D0
00004FDE  41F9 0800 14942          lea       _OSTCBPrioTbl.L,A0
00004FE2  1030      
00004FE4  2430 0800 14943          move.l    0(A0,D0.L),D2
                    14944   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00004FE8  4A82      14945          tst.l     D2
00004FEA  6608      14946          bne.s     OSTaskSuspend_5
                    14947   ; OS_EXIT_CRITICAL();
00004FEC  46DF      14948          dc.w      18143
                    14949   ; return (OS_ERR_TASK_SUSPEND_PRIO);
00004FEE  7048      14950          moveq     #72,D0
00004FF0  6000 0066 14951          bra       OSTaskSuspend_7
                    14952   OSTaskSuspend_5:
                    14953   ; }
                    14954   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
00004FF4  0C82 0000 14955          cmp.l     #1,D2
00004FF8  0001      
00004FFA  6608      14956          bne.s     OSTaskSuspend_8
                    14957   ; OS_EXIT_CRITICAL();
00004FFC  46DF      14958          dc.w      18143
                    14959   ; return (OS_ERR_TASK_NOT_EXIST);
00004FFE  7043      14960          moveq     #67,D0
00005000  6000 0056 14961          bra       OSTaskSuspend_7
                    14962   OSTaskSuspend_8:
                    14963   ; }
                    14964   ; y            = ptcb->OSTCBY;
00005004  2042      14965          move.l    D2,A0
00005006  1A28 0036 14966          move.b    54(A0),D5
                    14967   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
0000500A  CABC 0000 14968          and.l     #255,D5
0000500E  00FF      
00005010  41F9 0800 14969          lea       _OSRdyTbl.L,A0
00005014  0F10      
00005016  2242      14970          move.l    D2,A1
00005018  1029 0037 14971          move.b    55(A1),D0
0000501C  4600      14972          not.b     D0
0000501E  C130 5800 14973          and.b     D0,0(A0,D5.L)
                    14974   ; if (OSRdyTbl[y] == 0u) {
00005022  CABC 0000 14975          and.l     #255,D5
00005026  00FF      
00005028  41F9 0800 14976          lea       _OSRdyTbl.L,A0
0000502C  0F10      
0000502E  1030 5800 14977          move.b    0(A0,D5.L),D0
00005032  660E      14978          bne.s     OSTaskSuspend_10
                    14979   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00005034  2042      14980          move.l    D2,A0
00005036  1028 0038 14981          move.b    56(A0),D0
0000503A  4600      14982          not.b     D0
0000503C  C139 0800 14983          and.b     D0,_OSRdyGrp.L
00005040  0F0E      
                    14984   OSTaskSuspend_10:
                    14985   ; }
                    14986   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00005042  2042      14987          move.l    D2,A0
00005044  0028 0008 14988          or.b      #8,50(A0)
00005048  0032      
                    14989   ; OS_EXIT_CRITICAL();
0000504A  46DF      14990          dc.w      18143
                    14991   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
0000504C  0C03 0001 14992          cmp.b     #1,D3
00005050  6604      14993          bne.s     OSTaskSuspend_12
                    14994   ; OS_Sched();                                             /* Find new highest priority task      */
00005052  4EB8 1A22 14995          jsr       _OS_Sched
                    14996   OSTaskSuspend_12:
                    14997   ; }
                    14998   ; return (OS_ERR_NONE);
00005056  4200      14999          clr.b     D0
                    15000   OSTaskSuspend_7:
00005058  4CDF 003C 15001          movem.l   (A7)+,D2/D3/D4/D5
0000505C  4E5E      15002          unlk      A6
0000505E  4E75      15003          rts
                    15004   ; }
                    15005   ; #endif
                    15006   ; /*$PAGE*/
                    15007   ; /*
                    15008   ; *********************************************************************************************************
                    15009   ; *                                            QUERY A TASK
                    15010   ; *
                    15011   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    15012   ; *
                    15013   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    15014   ; *
                    15015   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    15016   ; *
                    15017   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    15018   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    15019   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    15020   ; *              OS_ERR_PRIO            if the desired task has not been created
                    15021   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    15022   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    15023   ; *********************************************************************************************************
                    15024   ; */
                    15025   ; #if OS_TASK_QUERY_EN > 0u
                    15026   ; INT8U  OSTaskQuery (INT8U    prio,
                    15027   ; OS_TCB  *p_task_data)
                    15028   ; {
                    15029   _OSTaskQuery:
00005060  4E56 0000 15030          link      A6,#0
00005064  48E7 3000 15031          movem.l   D2/D3,-(A7)
00005068  162E 000B 15032          move.b    11(A6),D3
0000506C  C6BC 0000 15033          and.l     #255,D3
00005070  00FF      
                    15034   ; OS_TCB    *ptcb;
                    15035   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15036   ; OS_CPU_SR  cpu_sr = 0u;
                    15037   ; #endif
                    15038   ; #if OS_ARG_CHK_EN > 0u
                    15039   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    15040   ; if (prio != OS_PRIO_SELF) {
                    15041   ; return (OS_ERR_PRIO_INVALID);
                    15042   ; }
                    15043   ; }
                    15044   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    15045   ; return (OS_ERR_PDATA_NULL);
                    15046   ; }
                    15047   ; #endif
                    15048   ; OS_ENTER_CRITICAL();
00005072  40E7      15049          dc.w      16615
00005074  007C      15050          dc.w      124
00005076  0700      15051          dc.w      1792
                    15052   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00005078  0C03 00FF 15053          cmp.b     #255,D3
0000507C  660A      15054          bne.s     OSTaskQuery_1
                    15055   ; prio = OSTCBCur->OSTCBPrio;
0000507E  2079 0800 15056          move.l    _OSTCBCur.L,A0
00005082  1020      
00005084  1628 0034 15057          move.b    52(A0),D3
                    15058   OSTaskQuery_1:
                    15059   ; }
                    15060   ; ptcb = OSTCBPrioTbl[prio];
00005088  C6BC 0000 15061          and.l     #255,D3
0000508C  00FF      
0000508E  2003      15062          move.l    D3,D0
00005090  E588      15063          lsl.l     #2,D0
00005092  41F9 0800 15064          lea       _OSTCBPrioTbl.L,A0
00005096  1030      
00005098  2430 0800 15065          move.l    0(A0,D0.L),D2
                    15066   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
0000509C  4A82      15067          tst.l     D2
0000509E  6606      15068          bne.s     OSTaskQuery_3
                    15069   ; OS_EXIT_CRITICAL();
000050A0  46DF      15070          dc.w      18143
                    15071   ; return (OS_ERR_PRIO);
000050A2  7029      15072          moveq     #41,D0
000050A4  6024      15073          bra.s     OSTaskQuery_5
                    15074   OSTaskQuery_3:
                    15075   ; }
                    15076   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
000050A6  0C82 0000 15077          cmp.l     #1,D2
000050AA  0001      
000050AC  6606      15078          bne.s     OSTaskQuery_6
                    15079   ; OS_EXIT_CRITICAL();
000050AE  46DF      15080          dc.w      18143
                    15081   ; return (OS_ERR_TASK_NOT_EXIST);
000050B0  7043      15082          moveq     #67,D0
000050B2  6016      15083          bra.s     OSTaskQuery_5
                    15084   OSTaskQuery_6:
                    15085   ; }
                    15086   ; /* Copy TCB into user storage area                    */
                    15087   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
000050B4  4878 0056 15088          pea       86
000050B8  2F02      15089          move.l    D2,-(A7)
000050BA  2F2E 000C 15090          move.l    12(A6),-(A7)
000050BE  4EB8 19F8 15091          jsr       _OS_MemCopy
000050C2  DEFC 000C 15092          add.w     #12,A7
                    15093   ; OS_EXIT_CRITICAL();
000050C6  46DF      15094          dc.w      18143
                    15095   ; return (OS_ERR_NONE);
000050C8  4200      15096          clr.b     D0
                    15097   OSTaskQuery_5:
000050CA  4CDF 000C 15098          movem.l   (A7)+,D2/D3
000050CE  4E5E      15099          unlk      A6
000050D0  4E75      15100          rts
                    15101   ; }
                    15102   ; #endif
                    15103   ; /*$PAGE*/
                    15104   ; /*
                    15105   ; *********************************************************************************************************
                    15106   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    15107   ; *
                    15108   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    15109   ; *              are application specific and can be used to store task specific values such as 'error
                    15110   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    15111   ; *
                    15112   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    15113   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    15114   ; *
                    15115   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    15116   ; *                        than OS_TASK_REG_TBL_SIZE
                    15117   ; *
                    15118   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    15119   ; *
                    15120   ; *                        OS_ERR_NONE            if the call was successful
                    15121   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    15122   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    15123   ; *
                    15124   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    15125   ; *
                    15126   ; * Note(s)    : The maximum number of task variables is 254
                    15127   ; *********************************************************************************************************
                    15128   ; */
                    15129   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    15130   ; INT32U  OSTaskRegGet (INT8U   prio,
                    15131   ; INT8U   id,
                    15132   ; INT8U  *perr)
                    15133   ; {
                    15134   _OSTaskRegGet:
000050D2  4E56 FFFC 15135          link      A6,#-4
000050D6  2F02      15136          move.l    D2,-(A7)
                    15137   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15138   ; OS_CPU_SR  cpu_sr = 0u;
                    15139   ; #endif
                    15140   ; INT32U     value;
                    15141   ; OS_TCB    *ptcb;
                    15142   ; #ifdef OS_SAFETY_CRITICAL
                    15143   ; if (perr == (INT8U *)0) {
                    15144   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15145   ; return (0u);
                    15146   ; }
                    15147   ; #endif
                    15148   ; #if OS_ARG_CHK_EN > 0u
                    15149   ; if (prio >= OS_LOWEST_PRIO) {
                    15150   ; if (prio != OS_PRIO_SELF) {
                    15151   ; *perr = OS_ERR_PRIO_INVALID;
                    15152   ; return (0u);
                    15153   ; }
                    15154   ; }
                    15155   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    15156   ; *perr = OS_ERR_ID_INVALID;
                    15157   ; return (0u);
                    15158   ; }
                    15159   ; #endif
                    15160   ; OS_ENTER_CRITICAL();
000050D8  40E7      15161          dc.w      16615
000050DA  007C      15162          dc.w      124
000050DC  0700      15163          dc.w      1792
                    15164   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
000050DE  102E 000B 15165          move.b    11(A6),D0
000050E2  0C00 00FF 15166          cmp.b     #255,D0
000050E6  6608      15167          bne.s     OSTaskRegGet_1
                    15168   ; ptcb = OSTCBCur;
000050E8  2439 0800 15169          move.l    _OSTCBCur.L,D2
000050EC  1020      
000050EE  6016      15170          bra.s     OSTaskRegGet_2
                    15171   OSTaskRegGet_1:
                    15172   ; } else {
                    15173   ; ptcb = OSTCBPrioTbl[prio];
000050F0  102E 000B 15174          move.b    11(A6),D0
000050F4  C0BC 0000 15175          and.l     #255,D0
000050F8  00FF      
000050FA  E588      15176          lsl.l     #2,D0
000050FC  41F9 0800 15177          lea       _OSTCBPrioTbl.L,A0
00005100  1030      
00005102  2430 0800 15178          move.l    0(A0,D0.L),D2
                    15179   OSTaskRegGet_2:
                    15180   ; }
                    15181   ; value = ptcb->OSTCBRegTbl[id];
00005106  2042      15182          move.l    D2,A0
00005108  102E 000F 15183          move.b    15(A6),D0
0000510C  C0BC 0000 15184          and.l     #255,D0
00005110  00FF      
00005112  E588      15185          lsl.l     #2,D0
00005114  D1C0      15186          add.l     D0,A0
00005116  2D68 0052 15187          move.l    82(A0),-4(A6)
0000511A  FFFC      
                    15188   ; OS_EXIT_CRITICAL();
0000511C  46DF      15189          dc.w      18143
                    15190   ; *perr = OS_ERR_NONE;
0000511E  206E 0010 15191          move.l    16(A6),A0
00005122  4210      15192          clr.b     (A0)
                    15193   ; return (value);
00005124  202E FFFC 15194          move.l    -4(A6),D0
00005128  241F      15195          move.l    (A7)+,D2
0000512A  4E5E      15196          unlk      A6
0000512C  4E75      15197          rts
                    15198   ; }
                    15199   ; #endif
                    15200   ; /*$PAGE*/
                    15201   ; /*
                    15202   ; ************************************************************************************************************************
                    15203   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    15204   ; *
                    15205   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    15206   ; *              allocated dynamically instead of statically.
                    15207   ; *
                    15208   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    15209   ; *
                    15210   ; *                            OS_ERR_NONE               if the call was successful
                    15211   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    15212   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    15213   ; *
                    15214   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    15215   ; ************************************************************************************************************************
                    15216   ; */
                    15217   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    15218   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    15219   ; {
                    15220   _OSTaskRegGetID:
0000512E  4E56 FFFC 15221          link      A6,#-4
                    15222   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    15223   ; OS_CPU_SR  cpu_sr = 0u;
                    15224   ; #endif
                    15225   ; INT8U      id;
                    15226   ; #ifdef OS_SAFETY_CRITICAL
                    15227   ; if (perr == (INT8U *)0) {
                    15228   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15229   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    15230   ; }
                    15231   ; #endif
                    15232   ; OS_ENTER_CRITICAL();
00005132  40E7      15233          dc.w      16615
00005134  007C      15234          dc.w      124
00005136  0700      15235          dc.w      1792
                    15236   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00005138  1039 0800 15237          move.b    _OSTaskRegNextAvailID.L,D0
0000513C  1974      
0000513E  0C00 0001 15238          cmp.b     #1,D0
00005142  650E      15239          blo.s     OSTaskRegGetID_1
                    15240   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00005144  206E 0008 15241          move.l    8(A6),A0
00005148  10BC 0096 15242          move.b    #150,(A0)
                    15243   ; OS_EXIT_CRITICAL();
0000514C  46DF      15244          dc.w      18143
                    15245   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
0000514E  7001      15246          moveq     #1,D0
00005150  601A      15247          bra.s     OSTaskRegGetID_3
                    15248   OSTaskRegGetID_1:
                    15249   ; }
                    15250   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
00005152  1D79 0800 15251          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00005156  1974 FFFF 
                    15252   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
0000515A  5239 0800 15253          addq.b    #1,_OSTaskRegNextAvailID.L
0000515E  1974      
                    15254   ; OS_EXIT_CRITICAL();
00005160  46DF      15255          dc.w      18143
                    15256   ; *perr = OS_ERR_NONE;
00005162  206E 0008 15257          move.l    8(A6),A0
00005166  4210      15258          clr.b     (A0)
                    15259   ; return (id);
00005168  102E FFFF 15260          move.b    -1(A6),D0
                    15261   OSTaskRegGetID_3:
0000516C  4E5E      15262          unlk      A6
0000516E  4E75      15263          rts
                    15264   ; }
                    15265   ; #endif
                    15266   ; /*$PAGE*/
                    15267   ; /*
                    15268   ; *********************************************************************************************************
                    15269   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    15270   ; *
                    15271   ; * Description: This function is called to change the current value of a task register.  Task registers
                    15272   ; *              are application specific and can be used to store task specific values such as 'error
                    15273   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    15274   ; *
                    15275   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    15276   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    15277   ; *
                    15278   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    15279   ; *                        than OS_TASK_REG_TBL_SIZE
                    15280   ; *
                    15281   ; *              value     is the desired value for the task register.
                    15282   ; *
                    15283   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    15284   ; *
                    15285   ; *                        OS_ERR_NONE            if the call was successful
                    15286   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    15287   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    15288   ; *
                    15289   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    15290   ; *
                    15291   ; * Note(s)    : The maximum number of task variables is 254
                    15292   ; *********************************************************************************************************
                    15293   ; */
                    15294   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    15295   ; void  OSTaskRegSet (INT8U    prio,
                    15296   ; INT8U    id,
                    15297   ; INT32U   value,
                    15298   ; INT8U   *perr)
                    15299   ; {
                    15300   _OSTaskRegSet:
00005170  4E56 0000 15301          link      A6,#0
00005174  2F02      15302          move.l    D2,-(A7)
                    15303   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15304   ; OS_CPU_SR  cpu_sr = 0u;
                    15305   ; #endif
                    15306   ; OS_TCB    *ptcb;
                    15307   ; #ifdef OS_SAFETY_CRITICAL
                    15308   ; if (perr == (INT8U *)0) {
                    15309   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15310   ; return;
                    15311   ; }
                    15312   ; #endif
                    15313   ; #if OS_ARG_CHK_EN > 0u
                    15314   ; if (prio >= OS_LOWEST_PRIO) {
                    15315   ; if (prio != OS_PRIO_SELF) {
                    15316   ; *perr = OS_ERR_PRIO_INVALID;
                    15317   ; return;
                    15318   ; }
                    15319   ; }
                    15320   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    15321   ; *perr = OS_ERR_ID_INVALID;
                    15322   ; return;
                    15323   ; }
                    15324   ; #endif
                    15325   ; OS_ENTER_CRITICAL();
00005176  40E7      15326          dc.w      16615
00005178  007C      15327          dc.w      124
0000517A  0700      15328          dc.w      1792
                    15329   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
0000517C  102E 000B 15330          move.b    11(A6),D0
00005180  0C00 00FF 15331          cmp.b     #255,D0
00005184  6608      15332          bne.s     OSTaskRegSet_1
                    15333   ; ptcb = OSTCBCur;
00005186  2439 0800 15334          move.l    _OSTCBCur.L,D2
0000518A  1020      
0000518C  6016      15335          bra.s     OSTaskRegSet_2
                    15336   OSTaskRegSet_1:
                    15337   ; } else {
                    15338   ; ptcb = OSTCBPrioTbl[prio];
0000518E  102E 000B 15339          move.b    11(A6),D0
00005192  C0BC 0000 15340          and.l     #255,D0
00005196  00FF      
00005198  E588      15341          lsl.l     #2,D0
0000519A  41F9 0800 15342          lea       _OSTCBPrioTbl.L,A0
0000519E  1030      
000051A0  2430 0800 15343          move.l    0(A0,D0.L),D2
                    15344   OSTaskRegSet_2:
                    15345   ; }
                    15346   ; ptcb->OSTCBRegTbl[id] = value;
000051A4  2042      15347          move.l    D2,A0
000051A6  102E 000F 15348          move.b    15(A6),D0
000051AA  C0BC 0000 15349          and.l     #255,D0
000051AE  00FF      
000051B0  E588      15350          lsl.l     #2,D0
000051B2  D1C0      15351          add.l     D0,A0
000051B4  216E 0010 15352          move.l    16(A6),82(A0)
000051B8  0052      
                    15353   ; OS_EXIT_CRITICAL();
000051BA  46DF      15354          dc.w      18143
                    15355   ; *perr                 = OS_ERR_NONE;
000051BC  206E 0014 15356          move.l    20(A6),A0
000051C0  4210      15357          clr.b     (A0)
000051C2  241F      15358          move.l    (A7)+,D2
000051C4  4E5E      15359          unlk      A6
000051C6  4E75      15360          rts
                    15361   ; }
                    15362   ; #endif
                    15363   ; /*$PAGE*/
                    15364   ; /*
                    15365   ; *********************************************************************************************************
                    15366   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    15367   ; *
                    15368   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    15369   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    15370   ; *
                    15371   ; * Arguments  : none
                    15372   ; *
                    15373   ; * Returns    : none
                    15374   ; *
                    15375   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    15376   ; *********************************************************************************************************
                    15377   ; */
                    15378   ; void  OS_TaskReturn (void)
                    15379   ; {
                    15380   _OS_TaskReturn:
                    15381   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
000051C8  2F39 0800 15382          move.l    _OSTCBCur.L,-(A7)
000051CC  1020      
000051CE  4EB8 0D1A 15383          jsr       _OSTaskReturnHook
000051D2  584F      15384          addq.w    #4,A7
                    15385   ; #if OS_TASK_DEL_EN > 0u
                    15386   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
000051D4  4878 00FF 15387          pea       255
000051D8  4EB8 4A9A 15388          jsr       _OSTaskDel
000051DC  584F      15389          addq.w    #4,A7
000051DE  C0BC 0000 15390          and.l     #255,D0
000051E2  00FF      
000051E4  4E75      15391          rts
                    15392   ; #else
                    15393   ; for (;;) {
                    15394   ; OSTimeDly(OS_TICKS_PER_SEC);
                    15395   ; }
                    15396   ; #endif
                    15397   ; }
                    15398   ; /*$PAGE*/
                    15399   ; /*
                    15400   ; *********************************************************************************************************
                    15401   ; *                                          CLEAR TASK STACK
                    15402   ; *
                    15403   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    15404   ; *
                    15405   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    15406   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    15407   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    15408   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    15409   ; *                       highest memory location of the stack and the stack will grow with increasing
                    15410   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    15411   ; *
                    15412   ; *              size     is the number of 'stack elements' to clear.
                    15413   ; *
                    15414   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    15415   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    15416   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    15417   ; *
                    15418   ; * Returns    : none
                    15419   ; *********************************************************************************************************
                    15420   ; */
                    15421   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    15422   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    15423   ; INT32U   size,
                    15424   ; INT16U   opt)
                    15425   ; {
                    15426   _OS_TaskStkClr:
000051E6  4E56 0000 15427          link      A6,#0
                    15428   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
000051EA  302E 0012 15429          move.w    18(A6),D0
000051EE  C07C 0001 15430          and.w     #1,D0
000051F2  6726      15431          beq.s     OS_TaskStkClr_7
                    15432   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
000051F4  302E 0012 15433          move.w    18(A6),D0
000051F8  C07C 0002 15434          and.w     #2,D0
000051FC  671C      15435          beq.s     OS_TaskStkClr_7
                    15436   ; #if OS_STK_GROWTH == 1u
                    15437   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    15438   OS_TaskStkClr_5:
000051FE  202E 000C 15439          move.l    12(A6),D0
00005202  0C80 0000 15440          cmp.l     #0,D0
00005206  0000      
00005208  6310      15441          bls.s     OS_TaskStkClr_7
                    15442   ; size--;
0000520A  53AE 000C 15443          subq.l    #1,12(A6)
                    15444   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
0000520E  206E 0008 15445          move.l    8(A6),A0
00005212  54AE 0008 15446          addq.l    #2,8(A6)
00005216  4250      15447          clr.w     (A0)
00005218  60E4      15448          bra       OS_TaskStkClr_5
                    15449   OS_TaskStkClr_7:
0000521A  4E5E      15450          unlk      A6
0000521C  4E75      15451          rts
                    15452   ; /*
                    15453   ; *********************************************************************************************************
                    15454   ; *                                                uC/OS-II
                    15455   ; *                                          The Real-Time Kernel
                    15456   ; *                                             TIME MANAGEMENT
                    15457   ; *
                    15458   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15459   ; *                                           All Rights Reserved
                    15460   ; *
                    15461   ; * File    : OS_TIME.C
                    15462   ; * By      : Jean J. Labrosse
                    15463   ; * Version : V2.92.07
                    15464   ; *
                    15465   ; * LICENSING TERMS:
                    15466   ; * ---------------
                    15467   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15468   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15469   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15470   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15471   ; * licensing fee.
                    15472   ; *********************************************************************************************************
                    15473   ; */
                    15474   ; #define  MICRIUM_SOURCE
                    15475   ; #ifndef  OS_MASTER_FILE
                    15476   ; #include <ucos_ii.h>
                    15477   ; #endif
                    15478   ; /*
                    15479   ; *********************************************************************************************************
                    15480   ; *                                        DELAY TASK 'n' TICKS
                    15481   ; *
                    15482   ; * Description: This function is called to delay execution of the currently running task until the
                    15483   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    15484   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    15485   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    15486   ; *
                    15487   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    15488   ; *                        Note that by specifying 0, the task will not be delayed.
                    15489   ; *
                    15490   ; * Returns    : none
                    15491   ; *********************************************************************************************************
                    15492   ; */
                    15493   ; void  OSTimeDly (INT32U ticks)
                    15494   ; {
                    15495   _OSTimeDly:
0000521E  4E56 0000 15496          link      A6,#0
00005222  48E7 2020 15497          movem.l   D2/A2,-(A7)
00005226  45F9 0800 15498          lea       _OSTCBCur.L,A2
0000522A  1020      
                    15499   ; INT8U      y;
                    15500   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15501   ; OS_CPU_SR  cpu_sr = 0u;
                    15502   ; #endif
                    15503   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0000522C  1039 0800 15504          move.b    _OSIntNesting.L,D0
00005230  0F06      
00005232  0C00 0000 15505          cmp.b     #0,D0
00005236  6304      15506          bls.s     OSTimeDly_1
                    15507   ; return;
00005238  6000 0072 15508          bra       OSTimeDly_6
                    15509   OSTimeDly_1:
                    15510   ; }
                    15511   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
0000523C  1039 0800 15512          move.b    _OSLockNesting.L,D0
00005240  0F08      
00005242  0C00 0000 15513          cmp.b     #0,D0
00005246  6304      15514          bls.s     OSTimeDly_4
                    15515   ; return;
00005248  6000 0062 15516          bra       OSTimeDly_6
                    15517   OSTimeDly_4:
                    15518   ; }
                    15519   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
0000524C  202E 0008 15520          move.l    8(A6),D0
00005250  0C80 0000 15521          cmp.l     #0,D0
00005254  0000      
00005256  6300 0054 15522          bls       OSTimeDly_6
                    15523   ; OS_ENTER_CRITICAL();
0000525A  40E7      15524          dc.w      16615
0000525C  007C      15525          dc.w      124
0000525E  0700      15526          dc.w      1792
                    15527   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
00005260  2052      15528          move.l    (A2),A0
00005262  1428 0036 15529          move.b    54(A0),D2
                    15530   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005266  C4BC 0000 15531          and.l     #255,D2
0000526A  00FF      
0000526C  41F9 0800 15532          lea       _OSRdyTbl.L,A0
00005270  0F10      
00005272  2252      15533          move.l    (A2),A1
00005274  1029 0037 15534          move.b    55(A1),D0
00005278  4600      15535          not.b     D0
0000527A  C130 2800 15536          and.b     D0,0(A0,D2.L)
                    15537   ; if (OSRdyTbl[y] == 0u) {
0000527E  C4BC 0000 15538          and.l     #255,D2
00005282  00FF      
00005284  41F9 0800 15539          lea       _OSRdyTbl.L,A0
00005288  0F10      
0000528A  1030 2800 15540          move.b    0(A0,D2.L),D0
0000528E  660E      15541          bne.s     OSTimeDly_8
                    15542   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005290  2052      15543          move.l    (A2),A0
00005292  1028 0038 15544          move.b    56(A0),D0
00005296  4600      15545          not.b     D0
00005298  C139 0800 15546          and.b     D0,_OSRdyGrp.L
0000529C  0F0E      
                    15547   OSTimeDly_8:
                    15548   ; }
                    15549   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
0000529E  2052      15550          move.l    (A2),A0
000052A0  216E 0008 15551          move.l    8(A6),46(A0)
000052A4  002E      
                    15552   ; OS_EXIT_CRITICAL();
000052A6  46DF      15553          dc.w      18143
                    15554   ; OS_Sched();                              /* Find next task to run!                             */
000052A8  4EB8 1A22 15555          jsr       _OS_Sched
                    15556   OSTimeDly_6:
000052AC  4CDF 0404 15557          movem.l   (A7)+,D2/A2
000052B0  4E5E      15558          unlk      A6
000052B2  4E75      15559          rts
                    15560   ; }
                    15561   ; }
                    15562   ; /*$PAGE*/
                    15563   ; /*
                    15564   ; *********************************************************************************************************
                    15565   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    15566   ; *
                    15567   ; * Description: This function is called to delay execution of the currently running task until some time
                    15568   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    15569   ; *              MILLISECONDS instead of ticks.
                    15570   ; *
                    15571   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    15572   ; *              minutes   specifies the number of minutes (max. 59)
                    15573   ; *              seconds   specifies the number of seconds (max. 59)
                    15574   ; *              ms        specifies the number of milliseconds (max. 999)
                    15575   ; *
                    15576   ; * Returns    : OS_ERR_NONE
                    15577   ; *              OS_ERR_TIME_INVALID_MINUTES
                    15578   ; *              OS_ERR_TIME_INVALID_SECONDS
                    15579   ; *              OS_ERR_TIME_INVALID_MS
                    15580   ; *              OS_ERR_TIME_ZERO_DLY
                    15581   ; *              OS_ERR_TIME_DLY_ISR
                    15582   ; *
                    15583   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    15584   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    15585   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    15586   ; *********************************************************************************************************
                    15587   ; */
                    15588   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    15589   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    15590   ; INT8U   minutes,
                    15591   ; INT8U   seconds,
                    15592   ; INT16U  ms)
                    15593   ; {
                    15594   _OSTimeDlyHMSM:
000052B4  4E56 FFFC 15595          link      A6,#-4
                    15596   ; INT32U ticks;
                    15597   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000052B8  1039 0800 15598          move.b    _OSIntNesting.L,D0
000052BC  0F06      
000052BE  0C00 0000 15599          cmp.b     #0,D0
000052C2  6306      15600          bls.s     OSTimeDlyHMSM_1
                    15601   ; return (OS_ERR_TIME_DLY_ISR);
000052C4  7055      15602          moveq     #85,D0
000052C6  6000 00A4 15603          bra       OSTimeDlyHMSM_3
                    15604   OSTimeDlyHMSM_1:
                    15605   ; }
                    15606   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
000052CA  1039 0800 15607          move.b    _OSLockNesting.L,D0
000052CE  0F08      
000052D0  0C00 0000 15608          cmp.b     #0,D0
000052D4  6306      15609          bls.s     OSTimeDlyHMSM_4
                    15610   ; return (OS_ERR_SCHED_LOCKED);
000052D6  7032      15611          moveq     #50,D0
000052D8  6000 0092 15612          bra       OSTimeDlyHMSM_3
                    15613   OSTimeDlyHMSM_4:
                    15614   ; }
                    15615   ; #if OS_ARG_CHK_EN > 0u
                    15616   ; if (hours == 0u) {
                    15617   ; if (minutes == 0u) {
                    15618   ; if (seconds == 0u) {
                    15619   ; if (ms == 0u) {
                    15620   ; return (OS_ERR_TIME_ZERO_DLY);
                    15621   ; }
                    15622   ; }
                    15623   ; }
                    15624   ; }
                    15625   ; if (minutes > 59u) {
                    15626   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    15627   ; }
                    15628   ; if (seconds > 59u) {
                    15629   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    15630   ; }
                    15631   ; if (ms > 999u) {
                    15632   ; return (OS_ERR_TIME_INVALID_MS);
                    15633   ; }
                    15634   ; #endif
                    15635   ; /* Compute the total number of clock ticks required.. */
                    15636   ; /* .. (rounded to the nearest tick)                   */
                    15637   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
000052DC  102E 000B 15638          move.b    11(A6),D0
000052E0  C0BC 0000 15639          and.l     #255,D0
000052E4  00FF      
000052E6  2F00      15640          move.l    D0,-(A7)
000052E8  4878 0E10 15641          pea       3600
000052EC  4EB9 0000 15642          jsr       ULMUL
000052F0  6046      
000052F2  2017      15643          move.l    (A7),D0
000052F4  504F      15644          addq.w    #8,A7
000052F6  122E 000F 15645          move.b    15(A6),D1
000052FA  C2BC 0000 15646          and.l     #255,D1
000052FE  00FF      
00005300  2F01      15647          move.l    D1,-(A7)
00005302  4878 003C 15648          pea       60
00005306  4EB9 0000 15649          jsr       ULMUL
0000530A  6046      
0000530C  2217      15650          move.l    (A7),D1
0000530E  504F      15651          addq.w    #8,A7
00005310  D081      15652          add.l     D1,D0
00005312  122E 0013 15653          move.b    19(A6),D1
00005316  C2BC 0000 15654          and.l     #255,D1
0000531A  00FF      
0000531C  D081      15655          add.l     D1,D0
0000531E  2F00      15656          move.l    D0,-(A7)
00005320  4878 0064 15657          pea       100
00005324  4EB9 0000 15658          jsr       ULMUL
00005328  6046      
0000532A  2017      15659          move.l    (A7),D0
0000532C  504F      15660          addq.w    #8,A7
0000532E  322E 0016 15661          move.w    22(A6),D1
00005332  C2BC 0000 15662          and.l     #65535,D1
00005336  FFFF      
00005338  5A81      15663          addq.l    #5,D1
0000533A  2F01      15664          move.l    D1,-(A7)
0000533C  4878 0064 15665          pea       100
00005340  4EB9 0000 15666          jsr       ULMUL
00005344  6046      
00005346  2217      15667          move.l    (A7),D1
00005348  504F      15668          addq.w    #8,A7
0000534A  2F01      15669          move.l    D1,-(A7)
0000534C  4878 03E8 15670          pea       1000
00005350  4EB9 0000 15671          jsr       ULDIV
00005354  60E6      
00005356  2217      15672          move.l    (A7),D1
00005358  504F      15673          addq.w    #8,A7
0000535A  D081      15674          add.l     D1,D0
0000535C  2D40 FFFC 15675          move.l    D0,-4(A6)
                    15676   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15677   ; OSTimeDly(ticks);
00005360  2F2E FFFC 15678          move.l    -4(A6),-(A7)
00005364  4EB8 521E 15679          jsr       _OSTimeDly
00005368  584F      15680          addq.w    #4,A7
                    15681   ; return (OS_ERR_NONE);
0000536A  4200      15682          clr.b     D0
                    15683   OSTimeDlyHMSM_3:
0000536C  4E5E      15684          unlk      A6
0000536E  4E75      15685          rts
                    15686   ; }
                    15687   ; #endif
                    15688   ; /*$PAGE*/
                    15689   ; /*
                    15690   ; *********************************************************************************************************
                    15691   ; *                                        RESUME A DELAYED TASK
                    15692   ; *
                    15693   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15694   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15695   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15696   ; *              like a timeout occurred.
                    15697   ; *
                    15698   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15699   ; *
                    15700   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15701   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15702   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15703   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15704   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15705   ; *********************************************************************************************************
                    15706   ; */
                    15707   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15708   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15709   ; {
                    15710   _OSTimeDlyResume:
00005370  4E56 0000 15711          link      A6,#0
00005374  2F02      15712          move.l    D2,-(A7)
                    15713   ; OS_TCB    *ptcb;
                    15714   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15715   ; OS_CPU_SR  cpu_sr = 0u;
                    15716   ; #endif
                    15717   ; if (prio >= OS_LOWEST_PRIO) {
00005376  102E 000B 15718          move.b    11(A6),D0
0000537A  0C00 003F 15719          cmp.b     #63,D0
0000537E  6506      15720          blo.s     OSTimeDlyResume_1
                    15721   ; return (OS_ERR_PRIO_INVALID);
00005380  702A      15722          moveq     #42,D0
00005382  6000 00B4 15723          bra       OSTimeDlyResume_3
                    15724   OSTimeDlyResume_1:
                    15725   ; }
                    15726   ; OS_ENTER_CRITICAL();
00005386  40E7      15727          dc.w      16615
00005388  007C      15728          dc.w      124
0000538A  0700      15729          dc.w      1792
                    15730   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
0000538C  102E 000B 15731          move.b    11(A6),D0
00005390  C0BC 0000 15732          and.l     #255,D0
00005394  00FF      
00005396  E588      15733          lsl.l     #2,D0
00005398  41F9 0800 15734          lea       _OSTCBPrioTbl.L,A0
0000539C  1030      
0000539E  2430 0800 15735          move.l    0(A0,D0.L),D2
                    15736   ; if (ptcb == (OS_TCB *)0) {
000053A2  4A82      15737          tst.l     D2
000053A4  6608      15738          bne.s     OSTimeDlyResume_4
                    15739   ; OS_EXIT_CRITICAL();
000053A6  46DF      15740          dc.w      18143
                    15741   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
000053A8  7043      15742          moveq     #67,D0
000053AA  6000 008C 15743          bra       OSTimeDlyResume_3
                    15744   OSTimeDlyResume_4:
                    15745   ; }
                    15746   ; if (ptcb == OS_TCB_RESERVED) {
000053AE  0C82 0000 15747          cmp.l     #1,D2
000053B2  0001      
000053B4  6608      15748          bne.s     OSTimeDlyResume_6
                    15749   ; OS_EXIT_CRITICAL();
000053B6  46DF      15750          dc.w      18143
                    15751   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
000053B8  7043      15752          moveq     #67,D0
000053BA  6000 007C 15753          bra       OSTimeDlyResume_3
                    15754   OSTimeDlyResume_6:
                    15755   ; }
                    15756   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
000053BE  2042      15757          move.l    D2,A0
000053C0  2028 002E 15758          move.l    46(A0),D0
000053C4  6608      15759          bne.s     OSTimeDlyResume_8
                    15760   ; OS_EXIT_CRITICAL();
000053C6  46DF      15761          dc.w      18143
                    15762   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
000053C8  7050      15763          moveq     #80,D0
000053CA  6000 006C 15764          bra       OSTimeDlyResume_3
                    15765   OSTimeDlyResume_8:
                    15766   ; }
                    15767   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
000053CE  2042      15768          move.l    D2,A0
000053D0  42A8 002E 15769          clr.l     46(A0)
                    15770   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000053D4  2042      15771          move.l    D2,A0
000053D6  1028 0032 15772          move.b    50(A0),D0
000053DA  C03C 0037 15773          and.b     #55,D0
000053DE  6712      15774          beq.s     OSTimeDlyResume_10
                    15775   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
000053E0  2042      15776          move.l    D2,A0
000053E2  0228 00C8 15777          and.b     #-56,50(A0)
000053E6  0032      
                    15778   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
000053E8  2042      15779          move.l    D2,A0
000053EA  117C 0001 15780          move.b    #1,51(A0)
000053EE  0033      
000053F0  6006      15781          bra.s     OSTimeDlyResume_11
                    15782   OSTimeDlyResume_10:
                    15783   ; } else {
                    15784   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
000053F2  2042      15785          move.l    D2,A0
000053F4  4228 0033 15786          clr.b     51(A0)
                    15787   OSTimeDlyResume_11:
                    15788   ; }
                    15789   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
000053F8  2042      15790          move.l    D2,A0
000053FA  1028 0032 15791          move.b    50(A0),D0
000053FE  C03C 0008 15792          and.b     #8,D0
00005402  6630      15793          bne.s     OSTimeDlyResume_12
                    15794   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
00005404  2042      15795          move.l    D2,A0
00005406  1028 0038 15796          move.b    56(A0),D0
0000540A  8139 0800 15797          or.b      D0,_OSRdyGrp.L
0000540E  0F0E      
                    15798   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00005410  2042      15799          move.l    D2,A0
00005412  1028 0036 15800          move.b    54(A0),D0
00005416  C0BC 0000 15801          and.l     #255,D0
0000541A  00FF      
0000541C  41F9 0800 15802          lea       _OSRdyTbl.L,A0
00005420  0F10      
00005422  2242      15803          move.l    D2,A1
00005424  1229 0037 15804          move.b    55(A1),D1
00005428  8330 0800 15805          or.b      D1,0(A0,D0.L)
                    15806   ; OS_EXIT_CRITICAL();
0000542C  46DF      15807          dc.w      18143
                    15808   ; OS_Sched();                                            /* See if this is new highest priority  */
0000542E  4EB8 1A22 15809          jsr       _OS_Sched
00005432  6002      15810          bra.s     OSTimeDlyResume_13
                    15811   OSTimeDlyResume_12:
                    15812   ; } else {
                    15813   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
00005434  46DF      15814          dc.w      18143
                    15815   OSTimeDlyResume_13:
                    15816   ; }
                    15817   ; return (OS_ERR_NONE);
00005436  4200      15818          clr.b     D0
                    15819   OSTimeDlyResume_3:
00005438  241F      15820          move.l    (A7)+,D2
0000543A  4E5E      15821          unlk      A6
0000543C  4E75      15822          rts
                    15823   ; }
                    15824   ; #endif
                    15825   ; /*$PAGE*/
                    15826   ; /*
                    15827   ; *********************************************************************************************************
                    15828   ; *                                       GET CURRENT SYSTEM TIME
                    15829   ; *
                    15830   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15831   ; *              counter which keeps track of the number of clock ticks.
                    15832   ; *
                    15833   ; * Arguments  : none
                    15834   ; *
                    15835   ; * Returns    : The current value of OSTime
                    15836   ; *********************************************************************************************************
                    15837   ; */
                    15838   ; #if OS_TIME_GET_SET_EN > 0u
                    15839   ; INT32U  OSTimeGet (void)
                    15840   ; {
                    15841   _OSTimeGet:
0000543E  4E56 FFFC 15842          link      A6,#-4
                    15843   ; INT32U     ticks;
                    15844   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15845   ; OS_CPU_SR  cpu_sr = 0u;
                    15846   ; #endif
                    15847   ; OS_ENTER_CRITICAL();
00005442  40E7      15848          dc.w      16615
00005444  007C      15849          dc.w      124
00005446  0700      15850          dc.w      1792
                    15851   ; ticks = OSTime;
00005448  2D79 0800 15852          move.l    _OSTime.L,-4(A6)
0000544C  1976 FFFC 
                    15853   ; OS_EXIT_CRITICAL();
00005450  46DF      15854          dc.w      18143
                    15855   ; return (ticks);
00005452  202E FFFC 15856          move.l    -4(A6),D0
00005456  4E5E      15857          unlk      A6
00005458  4E75      15858          rts
                    15859   ; }
                    15860   ; #endif
                    15861   ; /*
                    15862   ; *********************************************************************************************************
                    15863   ; *                                          SET SYSTEM CLOCK
                    15864   ; *
                    15865   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15866   ; *
                    15867   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15868   ; *
                    15869   ; * Returns    : none
                    15870   ; *********************************************************************************************************
                    15871   ; */
                    15872   ; #if OS_TIME_GET_SET_EN > 0u
                    15873   ; void  OSTimeSet (INT32U ticks)
                    15874   ; {
                    15875   _OSTimeSet:
0000545A  4E56 0000 15876          link      A6,#0
                    15877   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15878   ; OS_CPU_SR  cpu_sr = 0u;
                    15879   ; #endif
                    15880   ; OS_ENTER_CRITICAL();
0000545E  40E7      15881          dc.w      16615
00005460  007C      15882          dc.w      124
00005462  0700      15883          dc.w      1792
                    15884   ; OSTime = ticks;
00005464  23EE 0008 15885          move.l    8(A6),_OSTime.L
00005468  0800 1976 
                    15886   ; OS_EXIT_CRITICAL();
0000546C  46DF      15887          dc.w      18143
0000546E  4E5E      15888          unlk      A6
00005470  4E75      15889          rts
                    15890   ; /*
                    15891   ; *********************************************************************************************************
                    15892   ; *                                                uC/OS-II
                    15893   ; *                                          The Real-Time Kernel
                    15894   ; *                                            TIMER MANAGEMENT
                    15895   ; *
                    15896   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15897   ; *                                           All Rights Reserved
                    15898   ; *
                    15899   ; *
                    15900   ; * File    : OS_TMR.C
                    15901   ; * By      : Jean J. Labrosse
                    15902   ; * Version : V2.92.07
                    15903   ; *
                    15904   ; * LICENSING TERMS:
                    15905   ; * ---------------
                    15906   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15907   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15908   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15909   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15910   ; * licensing fee.
                    15911   ; *********************************************************************************************************
                    15912   ; */
                    15913   ; #define  MICRIUM_SOURCE
                    15914   ; #ifndef  OS_MASTER_FILE
                    15915   ; #include <ucos_ii.h>
                    15916   ; #endif
                    15917   ; /*
                    15918   ; *********************************************************************************************************
                    15919   ; *                                                        NOTES
                    15920   ; *
                    15921   ; * 1) Your application MUST define the following #define constants:
                    15922   ; *
                    15923   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15924   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15925   ; *
                    15926   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15927   ; *********************************************************************************************************
                    15928   ; */
                    15929   ; /*
                    15930   ; *********************************************************************************************************
                    15931   ; *                                              CONSTANTS
                    15932   ; *********************************************************************************************************
                    15933   ; */
                    15934   ; #define  OS_TMR_LINK_DLY       0u
                    15935   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15936   ; /*
                    15937   ; *********************************************************************************************************
                    15938   ; *                                          LOCAL PROTOTYPES
                    15939   ; *********************************************************************************************************
                    15940   ; */
                    15941   ; #if OS_TMR_EN > 0u
                    15942   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15943   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15944   ; static  void     OSTmr_InitTask      (void);
                    15945   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15946   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15947   ; static  void     OSTmr_Task          (void   *p_arg);
                    15948   ; #endif
                    15949   ; /*$PAGE*/
                    15950   ; /*
                    15951   ; *********************************************************************************************************
                    15952   ; *                                           CREATE A TIMER
                    15953   ; *
                    15954   ; * Description: This function is called by your application code to create a timer.
                    15955   ; *
                    15956   ; * Arguments  : dly           Initial delay.
                    15957   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15958   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15959   ; *                               wait for before the timer starts entering periodic mode.
                    15960   ; *
                    15961   ; *              period        The 'period' being repeated for the timer.
                    15962   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15963   ; *                               expires, it will automatically restart with the same period.
                    15964   ; *
                    15965   ; *              opt           Specifies either:
                    15966   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15967   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15968   ; *
                    15969   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15970   ; *                               The callback function must be declared as follows:
                    15971   ; *
                    15972   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15973   ; *
                    15974   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15975   ; *
                    15976   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15977   ; *                               useful for debugging.
                    15978   ; *
                    15979   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15980   ; *                               OS_ERR_NONE
                    15981   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15982   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15983   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15984   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15985   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15986   ; *
                    15987   ; * Returns    : A pointer to an OS_TMR data structure.
                    15988   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15989   ; *********************************************************************************************************
                    15990   ; */
                    15991   ; #if OS_TMR_EN > 0u
                    15992   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15993   ; INT32U           period,
                    15994   ; INT8U            opt,
                    15995   ; OS_TMR_CALLBACK  callback,
                    15996   ; void            *callback_arg,
                    15997   ; INT8U           *pname,
                    15998   ; INT8U           *perr)
                    15999   ; {
                    16000   _OSTmrCreate:
00005472  4E56 0000 16001          link      A6,#0
00005476  48E7 3000 16002          movem.l   D2/D3,-(A7)
0000547A  262E 0020 16003          move.l    32(A6),D3
                    16004   ; OS_TMR   *ptmr;
                    16005   ; #ifdef OS_SAFETY_CRITICAL
                    16006   ; if (perr == (INT8U *)0) {
                    16007   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16008   ; return ((OS_TMR *)0);
                    16009   ; }
                    16010   ; #endif
                    16011   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    16012   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    16013   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16014   ; return ((OS_TMR *)0);
                    16015   ; }
                    16016   ; #endif
                    16017   ; #if OS_ARG_CHK_EN > 0u
                    16018   ; switch (opt) {                                          /* Validate arguments                                     */
                    16019   ; case OS_TMR_OPT_PERIODIC:
                    16020   ; if (period == 0u) {
                    16021   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    16022   ; return ((OS_TMR *)0);
                    16023   ; }
                    16024   ; break;
                    16025   ; case OS_TMR_OPT_ONE_SHOT:
                    16026   ; if (dly == 0u) {
                    16027   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    16028   ; return ((OS_TMR *)0);
                    16029   ; }
                    16030   ; break;
                    16031   ; default:
                    16032   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    16033   ; return ((OS_TMR *)0);
                    16034   ; }
                    16035   ; #endif
                    16036   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
0000547E  1039 0800 16037          move.b    _OSIntNesting.L,D0
00005482  0F06      
00005484  0C00 0000 16038          cmp.b     #0,D0
00005488  630C      16039          bls.s     OSTmrCreate_1
                    16040   ; *perr  = OS_ERR_TMR_ISR;
0000548A  2043      16041          move.l    D3,A0
0000548C  10BC 008B 16042          move.b    #139,(A0)
                    16043   ; return ((OS_TMR *)0);
00005490  4280      16044          clr.l     D0
00005492  6000 0078 16045          bra       OSTmrCreate_3
                    16046   OSTmrCreate_1:
                    16047   ; }
                    16048   ; OSSchedLock();
00005496  4EB8 1272 16049          jsr       _OSSchedLock
                    16050   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
0000549A  4EB9 0000 16051          jsr       @ucos_ii_OSTmr_Alloc
0000549E  5A0A      
000054A0  2400      16052          move.l    D0,D2
                    16053   ; if (ptmr == (OS_TMR *)0) {
000054A2  4A82      16054          tst.l     D2
000054A4  6610      16055          bne.s     OSTmrCreate_4
                    16056   ; OSSchedUnlock();
000054A6  4EB8 12A2 16057          jsr       _OSSchedUnlock
                    16058   ; *perr = OS_ERR_TMR_NON_AVAIL;
000054AA  2043      16059          move.l    D3,A0
000054AC  10BC 0086 16060          move.b    #134,(A0)
                    16061   ; return ((OS_TMR *)0);
000054B0  4280      16062          clr.l     D0
000054B2  6000 0058 16063          bra       OSTmrCreate_3
                    16064   OSTmrCreate_4:
                    16065   ; }
                    16066   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
000054B6  2042      16067          move.l    D2,A0
000054B8  117C 0001 16068          move.b    #1,35(A0)
000054BC  0023      
                    16069   ; ptmr->OSTmrDly         = dly;
000054BE  2042      16070          move.l    D2,A0
000054C0  216E 0008 16071          move.l    8(A6),22(A0)
000054C4  0016      
                    16072   ; ptmr->OSTmrPeriod      = period;
000054C6  2042      16073          move.l    D2,A0
000054C8  216E 000C 16074          move.l    12(A6),26(A0)
000054CC  001A      
                    16075   ; ptmr->OSTmrOpt         = opt;
000054CE  2042      16076          move.l    D2,A0
000054D0  116E 0013 16077          move.b    19(A6),34(A0)
000054D4  0022      
                    16078   ; ptmr->OSTmrCallback    = callback;
000054D6  2042      16079          move.l    D2,A0
000054D8  216E 0014 16080          move.l    20(A6),2(A0)
000054DC  0002      
                    16081   ; ptmr->OSTmrCallbackArg = callback_arg;
000054DE  2042      16082          move.l    D2,A0
000054E0  216E 0018 16083          move.l    24(A6),6(A0)
000054E4  0006      
                    16084   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16085   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
000054E6  202E 001C 16086          move.l    28(A6),D0
000054EA  660E      16087          bne.s     OSTmrCreate_6
                    16088   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
000054EC  41F9 0000 16089          lea       @ucos_ii_1.L,A0
000054F0  6AD0      
000054F2  2242      16090          move.l    D2,A1
000054F4  2348 001E 16091          move.l    A0,30(A1)
000054F8  6008      16092          bra.s     OSTmrCreate_7
                    16093   OSTmrCreate_6:
                    16094   ; } else {
                    16095   ; ptmr->OSTmrName    = pname;
000054FA  2042      16096          move.l    D2,A0
000054FC  216E 001C 16097          move.l    28(A6),30(A0)
00005500  001E      
                    16098   OSTmrCreate_7:
                    16099   ; }
                    16100   ; #endif
                    16101   ; OSSchedUnlock();
00005502  4EB8 12A2 16102          jsr       _OSSchedUnlock
                    16103   ; *perr = OS_ERR_NONE;
00005506  2043      16104          move.l    D3,A0
00005508  4210      16105          clr.b     (A0)
                    16106   ; return (ptmr);
0000550A  2002      16107          move.l    D2,D0
                    16108   OSTmrCreate_3:
0000550C  4CDF 000C 16109          movem.l   (A7)+,D2/D3
00005510  4E5E      16110          unlk      A6
00005512  4E75      16111          rts
                    16112   ; }
                    16113   ; #endif
                    16114   ; /*$PAGE*/
                    16115   ; /*
                    16116   ; *********************************************************************************************************
                    16117   ; *                                           DELETE A TIMER
                    16118   ; *
                    16119   ; * Description: This function is called by your application code to delete a timer.
                    16120   ; *
                    16121   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    16122   ; *
                    16123   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16124   ; *                               OS_ERR_NONE
                    16125   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    16126   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16127   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    16128   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    16129   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    16130   ; *
                    16131   ; * Returns    : OS_TRUE       If the call was successful
                    16132   ; *              OS_FALSE      If not
                    16133   ; *********************************************************************************************************
                    16134   ; */
                    16135   ; #if OS_TMR_EN > 0u
                    16136   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    16137   ; INT8U   *perr)
                    16138   ; {
                    16139   _OSTmrDel:
00005514  4E56 0000 16140          link      A6,#0
00005518  48E7 3020 16141          movem.l   D2/D3/A2,-(A7)
0000551C  242E 000C 16142          move.l    12(A6),D2
00005520  262E 0008 16143          move.l    8(A6),D3
00005524  45F8 12A2 16144          lea       _OSSchedUnlock.L,A2
                    16145   ; #ifdef OS_SAFETY_CRITICAL
                    16146   ; if (perr == (INT8U *)0) {
                    16147   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16148   ; return (OS_FALSE);
                    16149   ; }
                    16150   ; #endif
                    16151   ; #if OS_ARG_CHK_EN > 0u
                    16152   ; if (ptmr == (OS_TMR *)0) {
                    16153   ; *perr = OS_ERR_TMR_INVALID;
                    16154   ; return (OS_FALSE);
                    16155   ; }
                    16156   ; #endif
                    16157   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00005528  2043      16158          move.l    D3,A0
0000552A  1010      16159          move.b    (A0),D0
0000552C  0C00 0064 16160          cmp.b     #100,D0
00005530  670C      16161          beq.s     OSTmrDel_1
                    16162   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005532  2042      16163          move.l    D2,A0
00005534  10BC 0089 16164          move.b    #137,(A0)
                    16165   ; return (OS_FALSE);
00005538  4200      16166          clr.b     D0
0000553A  6000 0090 16167          bra       OSTmrDel_3
                    16168   OSTmrDel_1:
                    16169   ; }
                    16170   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
0000553E  1039 0800 16171          move.b    _OSIntNesting.L,D0
00005542  0F06      
00005544  0C00 0000 16172          cmp.b     #0,D0
00005548  630C      16173          bls.s     OSTmrDel_4
                    16174   ; *perr  = OS_ERR_TMR_ISR;
0000554A  2042      16175          move.l    D2,A0
0000554C  10BC 008B 16176          move.b    #139,(A0)
                    16177   ; return (OS_FALSE);
00005550  4200      16178          clr.b     D0
00005552  6000 0078 16179          bra       OSTmrDel_3
                    16180   OSTmrDel_4:
                    16181   ; }
                    16182   ; OSSchedLock();
00005556  4EB8 1272 16183          jsr       _OSSchedLock
                    16184   ; switch (ptmr->OSTmrState) {
0000555A  2043      16185          move.l    D3,A0
0000555C  1028 0023 16186          move.b    35(A0),D0
00005560  C0BC 0000 16187          and.l     #255,D0
00005564  00FF      
00005566  0C80 0000 16188          cmp.l     #4,D0
0000556A  0004      
0000556C  6400 0054 16189          bhs       OSTmrDel_6
00005570  E380      16190          asl.l     #1,D0
00005572  303B 0806 16191          move.w    OSTmrDel_8(PC,D0.L),D0
00005576  4EFB 0002 16192          jmp       OSTmrDel_8(PC,D0.W)
                    16193   OSTmrDel_8:
0000557A  003C      16194          dc.w      OSTmrDel_12-OSTmrDel_8
0000557C  0028      16195          dc.w      OSTmrDel_10-OSTmrDel_8
0000557E  0028      16196          dc.w      OSTmrDel_10-OSTmrDel_8
00005580  0008      16197          dc.w      OSTmrDel_9-OSTmrDel_8
                    16198   OSTmrDel_9:
                    16199   ; case OS_TMR_STATE_RUNNING:
                    16200   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
00005582  2F03      16201          move.l    D3,-(A7)
00005584  4EB9 0000 16202          jsr       @ucos_ii_OSTmr_Unlink
00005588  5D00      
0000558A  584F      16203          addq.w    #4,A7
                    16204   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
0000558C  2F03      16205          move.l    D3,-(A7)
0000558E  4EB9 0000 16206          jsr       @ucos_ii_OSTmr_Free
00005592  5A44      
00005594  584F      16207          addq.w    #4,A7
                    16208   ; OSSchedUnlock();
00005596  4E92      16209          jsr       (A2)
                    16210   ; *perr = OS_ERR_NONE;
00005598  2042      16211          move.l    D2,A0
0000559A  4210      16212          clr.b     (A0)
                    16213   ; return (OS_TRUE);
0000559C  7001      16214          moveq     #1,D0
0000559E  6000 002C 16215          bra       OSTmrDel_3
                    16216   OSTmrDel_10:
                    16217   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    16218   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    16219   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
000055A2  2F03      16220          move.l    D3,-(A7)
000055A4  4EB9 0000 16221          jsr       @ucos_ii_OSTmr_Free
000055A8  5A44      
000055AA  584F      16222          addq.w    #4,A7
                    16223   ; OSSchedUnlock();
000055AC  4E92      16224          jsr       (A2)
                    16225   ; *perr = OS_ERR_NONE;
000055AE  2042      16226          move.l    D2,A0
000055B0  4210      16227          clr.b     (A0)
                    16228   ; return (OS_TRUE);
000055B2  7001      16229          moveq     #1,D0
000055B4  6016      16230          bra.s     OSTmrDel_3
                    16231   OSTmrDel_12:
                    16232   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    16233   ; OSSchedUnlock();
000055B6  4E92      16234          jsr       (A2)
                    16235   ; *perr = OS_ERR_TMR_INACTIVE;
000055B8  2042      16236          move.l    D2,A0
000055BA  10BC 0087 16237          move.b    #135,(A0)
                    16238   ; return (OS_FALSE);
000055BE  4200      16239          clr.b     D0
000055C0  600A      16240          bra.s     OSTmrDel_3
                    16241   OSTmrDel_6:
                    16242   ; default:
                    16243   ; OSSchedUnlock();
000055C2  4E92      16244          jsr       (A2)
                    16245   ; *perr = OS_ERR_TMR_INVALID_STATE;
000055C4  2042      16246          move.l    D2,A0
000055C6  10BC 008D 16247          move.b    #141,(A0)
                    16248   ; return (OS_FALSE);
000055CA  4200      16249          clr.b     D0
                    16250   OSTmrDel_3:
000055CC  4CDF 040C 16251          movem.l   (A7)+,D2/D3/A2
000055D0  4E5E      16252          unlk      A6
000055D2  4E75      16253          rts
                    16254   ; }
                    16255   ; }
                    16256   ; #endif
                    16257   ; /*$PAGE*/
                    16258   ; /*
                    16259   ; *********************************************************************************************************
                    16260   ; *                                       GET THE NAME OF A TIMER
                    16261   ; *
                    16262   ; * Description: This function is called to obtain the name of a timer.
                    16263   ; *
                    16264   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    16265   ; *
                    16266   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    16267   ; *
                    16268   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16269   ; *                               OS_ERR_NONE               The call was successful
                    16270   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    16271   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    16272   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16273   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    16274   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    16275   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    16276   ; *
                    16277   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    16278   ; *********************************************************************************************************
                    16279   ; */
                    16280   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    16281   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    16282   ; INT8U   **pdest,
                    16283   ; INT8U    *perr)
                    16284   ; {
                    16285   _OSTmrNameGet:
000055D4  4E56 FFFC 16286          link      A6,#-4
000055D8  48E7 3020 16287          movem.l   D2/D3/A2,-(A7)
000055DC  242E 0010 16288          move.l    16(A6),D2
000055E0  45F8 12A2 16289          lea       _OSSchedUnlock.L,A2
000055E4  262E 0008 16290          move.l    8(A6),D3
                    16291   ; INT8U  len;
                    16292   ; #ifdef OS_SAFETY_CRITICAL
                    16293   ; if (perr == (INT8U *)0) {
                    16294   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16295   ; return (0u);
                    16296   ; }
                    16297   ; #endif
                    16298   ; #if OS_ARG_CHK_EN > 0u
                    16299   ; if (pdest == (INT8U **)0) {
                    16300   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    16301   ; return (0u);
                    16302   ; }
                    16303   ; if (ptmr == (OS_TMR *)0) {
                    16304   ; *perr = OS_ERR_TMR_INVALID;
                    16305   ; return (0u);
                    16306   ; }
                    16307   ; #endif
                    16308   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000055E8  2043      16309          move.l    D3,A0
000055EA  1010      16310          move.b    (A0),D0
000055EC  0C00 0064 16311          cmp.b     #100,D0
000055F0  670C      16312          beq.s     OSTmrNameGet_1
                    16313   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000055F2  2042      16314          move.l    D2,A0
000055F4  10BC 0089 16315          move.b    #137,(A0)
                    16316   ; return (0u);
000055F8  4200      16317          clr.b     D0
000055FA  6000 0082 16318          bra       OSTmrNameGet_3
                    16319   OSTmrNameGet_1:
                    16320   ; }
                    16321   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000055FE  1039 0800 16322          move.b    _OSIntNesting.L,D0
00005602  0F06      
00005604  0C00 0000 16323          cmp.b     #0,D0
00005608  630C      16324          bls.s     OSTmrNameGet_4
                    16325   ; *perr = OS_ERR_NAME_GET_ISR;
0000560A  2042      16326          move.l    D2,A0
0000560C  10BC 0011 16327          move.b    #17,(A0)
                    16328   ; return (0u);
00005610  4200      16329          clr.b     D0
00005612  6000 006A 16330          bra       OSTmrNameGet_3
                    16331   OSTmrNameGet_4:
                    16332   ; }
                    16333   ; OSSchedLock();
00005616  4EB8 1272 16334          jsr       _OSSchedLock
                    16335   ; switch (ptmr->OSTmrState) {
0000561A  2043      16336          move.l    D3,A0
0000561C  1028 0023 16337          move.b    35(A0),D0
00005620  C0BC 0000 16338          and.l     #255,D0
00005624  00FF      
00005626  0C80 0000 16339          cmp.l     #4,D0
0000562A  0004      
0000562C  6400 0046 16340          bhs       OSTmrNameGet_6
00005630  E380      16341          asl.l     #1,D0
00005632  303B 0806 16342          move.w    OSTmrNameGet_8(PC,D0.L),D0
00005636  4EFB 0002 16343          jmp       OSTmrNameGet_8(PC,D0.W)
                    16344   OSTmrNameGet_8:
0000563A  002E      16345          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
0000563C  0008      16346          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
0000563E  0008      16347          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
00005640  0008      16348          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    16349   OSTmrNameGet_9:
                    16350   ; case OS_TMR_STATE_RUNNING:
                    16351   ; case OS_TMR_STATE_STOPPED:
                    16352   ; case OS_TMR_STATE_COMPLETED:
                    16353   ; *pdest = ptmr->OSTmrName;
00005642  2043      16354          move.l    D3,A0
00005644  226E 000C 16355          move.l    12(A6),A1
00005648  22A8 001E 16356          move.l    30(A0),(A1)
                    16357   ; len    = OS_StrLen(*pdest);
0000564C  206E 000C 16358          move.l    12(A6),A0
00005650  2F10      16359          move.l    (A0),-(A7)
00005652  4EB8 1ACC 16360          jsr       _OS_StrLen
00005656  584F      16361          addq.w    #4,A7
00005658  1D40 FFFF 16362          move.b    D0,-1(A6)
                    16363   ; OSSchedUnlock();
0000565C  4E92      16364          jsr       (A2)
                    16365   ; *perr = OS_ERR_NONE;
0000565E  2042      16366          move.l    D2,A0
00005660  4210      16367          clr.b     (A0)
                    16368   ; return (len);
00005662  102E FFFF 16369          move.b    -1(A6),D0
00005666  6016      16370          bra.s     OSTmrNameGet_3
                    16371   OSTmrNameGet_12:
                    16372   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    16373   ; OSSchedUnlock();
00005668  4E92      16374          jsr       (A2)
                    16375   ; *perr = OS_ERR_TMR_INACTIVE;
0000566A  2042      16376          move.l    D2,A0
0000566C  10BC 0087 16377          move.b    #135,(A0)
                    16378   ; return (0u);
00005670  4200      16379          clr.b     D0
00005672  600A      16380          bra.s     OSTmrNameGet_3
                    16381   OSTmrNameGet_6:
                    16382   ; default:
                    16383   ; OSSchedUnlock();
00005674  4E92      16384          jsr       (A2)
                    16385   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005676  2042      16386          move.l    D2,A0
00005678  10BC 008D 16387          move.b    #141,(A0)
                    16388   ; return (0u);
0000567C  4200      16389          clr.b     D0
                    16390   OSTmrNameGet_3:
0000567E  4CDF 040C 16391          movem.l   (A7)+,D2/D3/A2
00005682  4E5E      16392          unlk      A6
00005684  4E75      16393          rts
                    16394   ; }
                    16395   ; }
                    16396   ; #endif
                    16397   ; /*$PAGE*/
                    16398   ; /*
                    16399   ; *********************************************************************************************************
                    16400   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    16401   ; *
                    16402   ; * Description: This function is called to get the number of ticks before a timer times out.
                    16403   ; *
                    16404   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    16405   ; *
                    16406   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16407   ; *                               OS_ERR_NONE
                    16408   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16409   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16410   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16411   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16412   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    16413   ; *
                    16414   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    16415   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    16416   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    16417   ; *********************************************************************************************************
                    16418   ; */
                    16419   ; #if OS_TMR_EN > 0u
                    16420   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    16421   ; INT8U   *perr)
                    16422   ; {
                    16423   _OSTmrRemainGet:
00005686  4E56 0000 16424          link      A6,#0
0000568A  48E7 3820 16425          movem.l   D2/D3/D4/A2,-(A7)
0000568E  242E 000C 16426          move.l    12(A6),D2
00005692  262E 0008 16427          move.l    8(A6),D3
00005696  45F8 12A2 16428          lea       _OSSchedUnlock.L,A2
                    16429   ; INT32U  remain;
                    16430   ; #ifdef OS_SAFETY_CRITICAL
                    16431   ; if (perr == (INT8U *)0) {
                    16432   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16433   ; return (0u);
                    16434   ; }
                    16435   ; #endif
                    16436   ; #if OS_ARG_CHK_EN > 0u
                    16437   ; if (ptmr == (OS_TMR *)0) {
                    16438   ; *perr = OS_ERR_TMR_INVALID;
                    16439   ; return (0u);
                    16440   ; }
                    16441   ; #endif
                    16442   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
0000569A  2043      16443          move.l    D3,A0
0000569C  1010      16444          move.b    (A0),D0
0000569E  0C00 0064 16445          cmp.b     #100,D0
000056A2  670C      16446          beq.s     OSTmrRemainGet_1
                    16447   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000056A4  2042      16448          move.l    D2,A0
000056A6  10BC 0089 16449          move.b    #137,(A0)
                    16450   ; return (0u);
000056AA  4280      16451          clr.l     D0
000056AC  6000 00CE 16452          bra       OSTmrRemainGet_3
                    16453   OSTmrRemainGet_1:
                    16454   ; }
                    16455   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000056B0  1039 0800 16456          move.b    _OSIntNesting.L,D0
000056B4  0F06      
000056B6  0C00 0000 16457          cmp.b     #0,D0
000056BA  630C      16458          bls.s     OSTmrRemainGet_4
                    16459   ; *perr = OS_ERR_TMR_ISR;
000056BC  2042      16460          move.l    D2,A0
000056BE  10BC 008B 16461          move.b    #139,(A0)
                    16462   ; return (0u);
000056C2  4280      16463          clr.l     D0
000056C4  6000 00B6 16464          bra       OSTmrRemainGet_3
                    16465   OSTmrRemainGet_4:
                    16466   ; }
                    16467   ; OSSchedLock();
000056C8  4EB8 1272 16468          jsr       _OSSchedLock
                    16469   ; switch (ptmr->OSTmrState) {
000056CC  2043      16470          move.l    D3,A0
000056CE  1028 0023 16471          move.b    35(A0),D0
000056D2  C0BC 0000 16472          and.l     #255,D0
000056D6  00FF      
000056D8  0C80 0000 16473          cmp.l     #4,D0
000056DC  0004      
000056DE  6400 0092 16474          bhs       OSTmrRemainGet_6
000056E2  E380      16475          asl.l     #1,D0
000056E4  303B 0806 16476          move.w    OSTmrRemainGet_8(PC,D0.L),D0
000056E8  4EFB 0002 16477          jmp       OSTmrRemainGet_8(PC,D0.W)
                    16478   OSTmrRemainGet_8:
000056EC  007A      16479          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
000056EE  0022      16480          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
000056F0  0070      16481          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
000056F2  0008      16482          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    16483   OSTmrRemainGet_9:
                    16484   ; case OS_TMR_STATE_RUNNING:
                    16485   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
000056F4  2043      16486          move.l    D3,A0
000056F6  2028 0012 16487          move.l    18(A0),D0
000056FA  90B9 0800 16488          sub.l     _OSTmrTime.L,D0
000056FE  197E      
00005700  2800      16489          move.l    D0,D4
                    16490   ; OSSchedUnlock();
00005702  4E92      16491          jsr       (A2)
                    16492   ; *perr  = OS_ERR_NONE;
00005704  2042      16493          move.l    D2,A0
00005706  4210      16494          clr.b     (A0)
                    16495   ; return (remain);
00005708  2004      16496          move.l    D4,D0
0000570A  6000 0070 16497          bra       OSTmrRemainGet_3
                    16498   OSTmrRemainGet_10:
                    16499   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    16500   ; switch (ptmr->OSTmrOpt) {
0000570E  2043      16501          move.l    D3,A0
00005710  1028 0022 16502          move.b    34(A0),D0
00005714  C0BC 0000 16503          and.l     #255,D0
00005718  00FF      
0000571A  0C80 0000 16504          cmp.l     #2,D0
0000571E  0002      
00005720  670C      16505          beq.s     OSTmrRemainGet_16
00005722  6228      16506          bhi.s     OSTmrRemainGet_17
00005724  0C80 0000 16507          cmp.l     #1,D0
00005728  0001      
0000572A  6720      16508          beq.s     OSTmrRemainGet_17
0000572C  601E      16509          bra.s     OSTmrRemainGet_17
                    16510   OSTmrRemainGet_16:
                    16511   ; case OS_TMR_OPT_PERIODIC:
                    16512   ; if (ptmr->OSTmrDly == 0u) {
0000572E  2043      16513          move.l    D3,A0
00005730  2028 0016 16514          move.l    22(A0),D0
00005734  6608      16515          bne.s     OSTmrRemainGet_19
                    16516   ; remain = ptmr->OSTmrPeriod;
00005736  2043      16517          move.l    D3,A0
00005738  2828 001A 16518          move.l    26(A0),D4
0000573C  6006      16519          bra.s     OSTmrRemainGet_20
                    16520   OSTmrRemainGet_19:
                    16521   ; } else {
                    16522   ; remain = ptmr->OSTmrDly;
0000573E  2043      16523          move.l    D3,A0
00005740  2828 0016 16524          move.l    22(A0),D4
                    16525   OSTmrRemainGet_20:
                    16526   ; }
                    16527   ; OSSchedUnlock();
00005744  4E92      16528          jsr       (A2)
                    16529   ; *perr  = OS_ERR_NONE;
00005746  2042      16530          move.l    D2,A0
00005748  4210      16531          clr.b     (A0)
                    16532   ; break;
0000574A  600C      16533          bra.s     OSTmrRemainGet_15
                    16534   OSTmrRemainGet_17:
                    16535   ; case OS_TMR_OPT_ONE_SHOT:
                    16536   ; default:
                    16537   ; remain = ptmr->OSTmrDly;
0000574C  2043      16538          move.l    D3,A0
0000574E  2828 0016 16539          move.l    22(A0),D4
                    16540   ; OSSchedUnlock();
00005752  4E92      16541          jsr       (A2)
                    16542   ; *perr  = OS_ERR_NONE;
00005754  2042      16543          move.l    D2,A0
00005756  4210      16544          clr.b     (A0)
                    16545   ; break;
                    16546   OSTmrRemainGet_15:
                    16547   ; }
                    16548   ; return (remain);
00005758  2004      16549          move.l    D4,D0
0000575A  6020      16550          bra.s     OSTmrRemainGet_3
                    16551   OSTmrRemainGet_11:
                    16552   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    16553   ; OSSchedUnlock();
0000575C  4E92      16554          jsr       (A2)
                    16555   ; *perr = OS_ERR_NONE;
0000575E  2042      16556          move.l    D2,A0
00005760  4210      16557          clr.b     (A0)
                    16558   ; return (0u);
00005762  4280      16559          clr.l     D0
00005764  6016      16560          bra.s     OSTmrRemainGet_3
                    16561   OSTmrRemainGet_12:
                    16562   ; case OS_TMR_STATE_UNUSED:
                    16563   ; OSSchedUnlock();
00005766  4E92      16564          jsr       (A2)
                    16565   ; *perr = OS_ERR_TMR_INACTIVE;
00005768  2042      16566          move.l    D2,A0
0000576A  10BC 0087 16567          move.b    #135,(A0)
                    16568   ; return (0u);
0000576E  4280      16569          clr.l     D0
00005770  600A      16570          bra.s     OSTmrRemainGet_3
                    16571   OSTmrRemainGet_6:
                    16572   ; default:
                    16573   ; OSSchedUnlock();
00005772  4E92      16574          jsr       (A2)
                    16575   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005774  2042      16576          move.l    D2,A0
00005776  10BC 008D 16577          move.b    #141,(A0)
                    16578   ; return (0u);
0000577A  4280      16579          clr.l     D0
                    16580   OSTmrRemainGet_3:
0000577C  4CDF 041C 16581          movem.l   (A7)+,D2/D3/D4/A2
00005780  4E5E      16582          unlk      A6
00005782  4E75      16583          rts
                    16584   ; }
                    16585   ; }
                    16586   ; #endif
                    16587   ; /*$PAGE*/
                    16588   ; /*
                    16589   ; *********************************************************************************************************
                    16590   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    16591   ; *
                    16592   ; * Description: This function is called to determine what state the timer is in:
                    16593   ; *
                    16594   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    16595   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    16596   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    16597   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    16598   ; *
                    16599   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    16600   ; *
                    16601   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16602   ; *                               OS_ERR_NONE
                    16603   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16604   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16605   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16606   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16607   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    16608   ; *
                    16609   ; * Returns    : The current state of the timer (see description).
                    16610   ; *********************************************************************************************************
                    16611   ; */
                    16612   ; #if OS_TMR_EN > 0u
                    16613   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    16614   ; INT8U   *perr)
                    16615   ; {
                    16616   _OSTmrStateGet:
00005784  4E56 0000 16617          link      A6,#0
00005788  48E7 3000 16618          movem.l   D2/D3,-(A7)
0000578C  242E 000C 16619          move.l    12(A6),D2
                    16620   ; INT8U  state;
                    16621   ; #ifdef OS_SAFETY_CRITICAL
                    16622   ; if (perr == (INT8U *)0) {
                    16623   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16624   ; return (0u);
                    16625   ; }
                    16626   ; #endif
                    16627   ; #if OS_ARG_CHK_EN > 0u
                    16628   ; if (ptmr == (OS_TMR *)0) {
                    16629   ; *perr = OS_ERR_TMR_INVALID;
                    16630   ; return (0u);
                    16631   ; }
                    16632   ; #endif
                    16633   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005790  206E 0008 16634          move.l    8(A6),A0
00005794  1010      16635          move.b    (A0),D0
00005796  0C00 0064 16636          cmp.b     #100,D0
0000579A  670C      16637          beq.s     OSTmrStateGet_1
                    16638   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000579C  2042      16639          move.l    D2,A0
0000579E  10BC 0089 16640          move.b    #137,(A0)
                    16641   ; return (0u);
000057A2  4200      16642          clr.b     D0
000057A4  6000 005A 16643          bra       OSTmrStateGet_3
                    16644   OSTmrStateGet_1:
                    16645   ; }
                    16646   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000057A8  1039 0800 16647          move.b    _OSIntNesting.L,D0
000057AC  0F06      
000057AE  0C00 0000 16648          cmp.b     #0,D0
000057B2  630C      16649          bls.s     OSTmrStateGet_4
                    16650   ; *perr = OS_ERR_TMR_ISR;
000057B4  2042      16651          move.l    D2,A0
000057B6  10BC 008B 16652          move.b    #139,(A0)
                    16653   ; return (0u);
000057BA  4200      16654          clr.b     D0
000057BC  6000 0042 16655          bra       OSTmrStateGet_3
                    16656   OSTmrStateGet_4:
                    16657   ; }
                    16658   ; OSSchedLock();
000057C0  4EB8 1272 16659          jsr       _OSSchedLock
                    16660   ; state = ptmr->OSTmrState;
000057C4  206E 0008 16661          move.l    8(A6),A0
000057C8  1628 0023 16662          move.b    35(A0),D3
                    16663   ; switch (state) {
000057CC  C6BC 0000 16664          and.l     #255,D3
000057D0  00FF      
000057D2  2003      16665          move.l    D3,D0
000057D4  0C80 0000 16666          cmp.l     #4,D0
000057D8  0004      
000057DA  6418      16667          bhs.s     OSTmrStateGet_6
000057DC  E380      16668          asl.l     #1,D0
000057DE  303B 0806 16669          move.w    OSTmrStateGet_8(PC,D0.L),D0
000057E2  4EFB 0002 16670          jmp       OSTmrStateGet_8(PC,D0.W)
                    16671   OSTmrStateGet_8:
000057E6  0008      16672          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000057E8  0008      16673          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000057EA  0008      16674          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000057EC  0008      16675          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16676   OSTmrStateGet_9:
                    16677   ; case OS_TMR_STATE_UNUSED:
                    16678   ; case OS_TMR_STATE_STOPPED:
                    16679   ; case OS_TMR_STATE_COMPLETED:
                    16680   ; case OS_TMR_STATE_RUNNING:
                    16681   ; *perr = OS_ERR_NONE;
000057EE  2042      16682          move.l    D2,A0
000057F0  4210      16683          clr.b     (A0)
                    16684   ; break;
000057F2  6006      16685          bra.s     OSTmrStateGet_7
                    16686   OSTmrStateGet_6:
                    16687   ; default:
                    16688   ; *perr = OS_ERR_TMR_INVALID_STATE;
000057F4  2042      16689          move.l    D2,A0
000057F6  10BC 008D 16690          move.b    #141,(A0)
                    16691   ; break;
                    16692   OSTmrStateGet_7:
                    16693   ; }
                    16694   ; OSSchedUnlock();
000057FA  4EB8 12A2 16695          jsr       _OSSchedUnlock
                    16696   ; return (state);
000057FE  1003      16697          move.b    D3,D0
                    16698   OSTmrStateGet_3:
00005800  4CDF 000C 16699          movem.l   (A7)+,D2/D3
00005804  4E5E      16700          unlk      A6
00005806  4E75      16701          rts
                    16702   ; }
                    16703   ; #endif
                    16704   ; /*$PAGE*/
                    16705   ; /*
                    16706   ; *********************************************************************************************************
                    16707   ; *                                            START A TIMER
                    16708   ; *
                    16709   ; * Description: This function is called by your application code to start a timer.
                    16710   ; *
                    16711   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16712   ; *
                    16713   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16714   ; *                               OS_ERR_NONE
                    16715   ; *                               OS_ERR_TMR_INVALID
                    16716   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16717   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16718   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16719   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16720   ; *
                    16721   ; * Returns    : OS_TRUE    if the timer was started
                    16722   ; *              OS_FALSE   if an error was detected
                    16723   ; *********************************************************************************************************
                    16724   ; */
                    16725   ; #if OS_TMR_EN > 0u
                    16726   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16727   ; INT8U    *perr)
                    16728   ; {
                    16729   _OSTmrStart:
00005808  4E56 0000 16730          link      A6,#0
0000580C  48E7 3020 16731          movem.l   D2/D3/A2,-(A7)
00005810  242E 000C 16732          move.l    12(A6),D2
00005814  262E 0008 16733          move.l    8(A6),D3
00005818  45F8 12A2 16734          lea       _OSSchedUnlock.L,A2
                    16735   ; #ifdef OS_SAFETY_CRITICAL
                    16736   ; if (perr == (INT8U *)0) {
                    16737   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16738   ; return (OS_FALSE);
                    16739   ; }
                    16740   ; #endif
                    16741   ; #if OS_ARG_CHK_EN > 0u
                    16742   ; if (ptmr == (OS_TMR *)0) {
                    16743   ; *perr = OS_ERR_TMR_INVALID;
                    16744   ; return (OS_FALSE);
                    16745   ; }
                    16746   ; #endif
                    16747   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
0000581C  2043      16748          move.l    D3,A0
0000581E  1010      16749          move.b    (A0),D0
00005820  0C00 0064 16750          cmp.b     #100,D0
00005824  670C      16751          beq.s     OSTmrStart_1
                    16752   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005826  2042      16753          move.l    D2,A0
00005828  10BC 0089 16754          move.b    #137,(A0)
                    16755   ; return (OS_FALSE);
0000582C  4200      16756          clr.b     D0
0000582E  6000 0094 16757          bra       OSTmrStart_3
                    16758   OSTmrStart_1:
                    16759   ; }
                    16760   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005832  1039 0800 16761          move.b    _OSIntNesting.L,D0
00005836  0F06      
00005838  0C00 0000 16762          cmp.b     #0,D0
0000583C  630C      16763          bls.s     OSTmrStart_4
                    16764   ; *perr  = OS_ERR_TMR_ISR;
0000583E  2042      16765          move.l    D2,A0
00005840  10BC 008B 16766          move.b    #139,(A0)
                    16767   ; return (OS_FALSE);
00005844  4200      16768          clr.b     D0
00005846  6000 007C 16769          bra       OSTmrStart_3
                    16770   OSTmrStart_4:
                    16771   ; }
                    16772   ; OSSchedLock();
0000584A  4EB8 1272 16773          jsr       _OSSchedLock
                    16774   ; switch (ptmr->OSTmrState) {
0000584E  2043      16775          move.l    D3,A0
00005850  1028 0023 16776          move.b    35(A0),D0
00005854  C0BC 0000 16777          and.l     #255,D0
00005858  00FF      
0000585A  0C80 0000 16778          cmp.l     #4,D0
0000585E  0004      
00005860  6400 0058 16779          bhs       OSTmrStart_6
00005864  E380      16780          asl.l     #1,D0
00005866  303B 0806 16781          move.w    OSTmrStart_8(PC,D0.L),D0
0000586A  4EFB 0002 16782          jmp       OSTmrStart_8(PC,D0.W)
                    16783   OSTmrStart_8:
0000586E  0040      16784          dc.w      OSTmrStart_12-OSTmrStart_8
00005870  002A      16785          dc.w      OSTmrStart_10-OSTmrStart_8
00005872  002A      16786          dc.w      OSTmrStart_10-OSTmrStart_8
00005874  0008      16787          dc.w      OSTmrStart_9-OSTmrStart_8
                    16788   OSTmrStart_9:
                    16789   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16790   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
00005876  2F03      16791          move.l    D3,-(A7)
00005878  4EB9 0000 16792          jsr       @ucos_ii_OSTmr_Unlink
0000587C  5D00      
0000587E  584F      16793          addq.w    #4,A7
                    16794   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005880  42A7      16795          clr.l     -(A7)
00005882  2F03      16796          move.l    D3,-(A7)
00005884  4EB9 0000 16797          jsr       @ucos_ii_OSTmr_Link
00005888  5C2C      
0000588A  504F      16798          addq.w    #8,A7
                    16799   ; OSSchedUnlock();
0000588C  4E92      16800          jsr       (A2)
                    16801   ; *perr = OS_ERR_NONE;
0000588E  2042      16802          move.l    D2,A0
00005890  4210      16803          clr.b     (A0)
                    16804   ; return (OS_TRUE);
00005892  7001      16805          moveq     #1,D0
00005894  6000 002E 16806          bra       OSTmrStart_3
                    16807   OSTmrStart_10:
                    16808   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16809   ; case OS_TMR_STATE_COMPLETED:
                    16810   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005898  42A7      16811          clr.l     -(A7)
0000589A  2F03      16812          move.l    D3,-(A7)
0000589C  4EB9 0000 16813          jsr       @ucos_ii_OSTmr_Link
000058A0  5C2C      
000058A2  504F      16814          addq.w    #8,A7
                    16815   ; OSSchedUnlock();
000058A4  4E92      16816          jsr       (A2)
                    16817   ; *perr = OS_ERR_NONE;
000058A6  2042      16818          move.l    D2,A0
000058A8  4210      16819          clr.b     (A0)
                    16820   ; return (OS_TRUE);
000058AA  7001      16821          moveq     #1,D0
000058AC  6016      16822          bra.s     OSTmrStart_3
                    16823   OSTmrStart_12:
                    16824   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16825   ; OSSchedUnlock();
000058AE  4E92      16826          jsr       (A2)
                    16827   ; *perr = OS_ERR_TMR_INACTIVE;
000058B0  2042      16828          move.l    D2,A0
000058B2  10BC 0087 16829          move.b    #135,(A0)
                    16830   ; return (OS_FALSE);
000058B6  4200      16831          clr.b     D0
000058B8  600A      16832          bra.s     OSTmrStart_3
                    16833   OSTmrStart_6:
                    16834   ; default:
                    16835   ; OSSchedUnlock();
000058BA  4E92      16836          jsr       (A2)
                    16837   ; *perr = OS_ERR_TMR_INVALID_STATE;
000058BC  2042      16838          move.l    D2,A0
000058BE  10BC 008D 16839          move.b    #141,(A0)
                    16840   ; return (OS_FALSE);
000058C2  4200      16841          clr.b     D0
                    16842   OSTmrStart_3:
000058C4  4CDF 040C 16843          movem.l   (A7)+,D2/D3/A2
000058C8  4E5E      16844          unlk      A6
000058CA  4E75      16845          rts
                    16846   ; }
                    16847   ; }
                    16848   ; #endif
                    16849   ; /*$PAGE*/
                    16850   ; /*
                    16851   ; *********************************************************************************************************
                    16852   ; *                                            STOP A TIMER
                    16853   ; *
                    16854   ; * Description: This function is called by your application code to stop a timer.
                    16855   ; *
                    16856   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16857   ; *
                    16858   ; *              opt           Allows you to specify an option to this functions which can be:
                    16859   ; *
                    16860   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16861   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16862   ; *                                                        callback argument specified when the timer 
                    16863   ; *                                                        was created.
                    16864   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16865   ; *                                                        callback argument specified in THIS function call.
                    16866   ; *
                    16867   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16868   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16869   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16870   ; *
                    16871   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16872   ; *                               OS_ERR_NONE
                    16873   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16874   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16875   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16876   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16877   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16878   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16879   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16880   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16881   ; *
                    16882   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16883   ; *              OS_FALSE      If not
                    16884   ; *********************************************************************************************************
                    16885   ; */
                    16886   ; #if OS_TMR_EN > 0u
                    16887   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16888   ; INT8U    opt,
                    16889   ; void    *callback_arg,
                    16890   ; INT8U   *perr)
                    16891   ; {
                    16892   _OSTmrStop:
000058CC  4E56 0000 16893          link      A6,#0
000058D0  48E7 3820 16894          movem.l   D2/D3/D4/A2,-(A7)
000058D4  242E 0014 16895          move.l    20(A6),D2
000058D8  262E 0008 16896          move.l    8(A6),D3
000058DC  45F8 12A2 16897          lea       _OSSchedUnlock.L,A2
                    16898   ; OS_TMR_CALLBACK  pfnct;
                    16899   ; #ifdef OS_SAFETY_CRITICAL
                    16900   ; if (perr == (INT8U *)0) {
                    16901   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16902   ; return (OS_FALSE);
                    16903   ; }
                    16904   ; #endif
                    16905   ; #if OS_ARG_CHK_EN > 0u
                    16906   ; if (ptmr == (OS_TMR *)0) {
                    16907   ; *perr = OS_ERR_TMR_INVALID;
                    16908   ; return (OS_FALSE);
                    16909   ; }
                    16910   ; #endif
                    16911   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
000058E0  2043      16912          move.l    D3,A0
000058E2  1010      16913          move.b    (A0),D0
000058E4  0C00 0064 16914          cmp.b     #100,D0
000058E8  670C      16915          beq.s     OSTmrStop_1
                    16916   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000058EA  2042      16917          move.l    D2,A0
000058EC  10BC 0089 16918          move.b    #137,(A0)
                    16919   ; return (OS_FALSE);
000058F0  4200      16920          clr.b     D0
000058F2  6000 00F2 16921          bra       OSTmrStop_3
                    16922   OSTmrStop_1:
                    16923   ; }
                    16924   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
000058F6  1039 0800 16925          move.b    _OSIntNesting.L,D0
000058FA  0F06      
000058FC  0C00 0000 16926          cmp.b     #0,D0
00005900  630C      16927          bls.s     OSTmrStop_4
                    16928   ; *perr  = OS_ERR_TMR_ISR;
00005902  2042      16929          move.l    D2,A0
00005904  10BC 008B 16930          move.b    #139,(A0)
                    16931   ; return (OS_FALSE);
00005908  4200      16932          clr.b     D0
0000590A  6000 00DA 16933          bra       OSTmrStop_3
                    16934   OSTmrStop_4:
                    16935   ; }
                    16936   ; OSSchedLock();
0000590E  4EB8 1272 16937          jsr       _OSSchedLock
                    16938   ; switch (ptmr->OSTmrState) {
00005912  2043      16939          move.l    D3,A0
00005914  1028 0023 16940          move.b    35(A0),D0
00005918  C0BC 0000 16941          and.l     #255,D0
0000591C  00FF      
0000591E  0C80 0000 16942          cmp.l     #4,D0
00005922  0004      
00005924  6400 00B6 16943          bhs       OSTmrStop_6
00005928  E380      16944          asl.l     #1,D0
0000592A  303B 0806 16945          move.w    OSTmrStop_8(PC,D0.L),D0
0000592E  4EFB 0002 16946          jmp       OSTmrStop_8(PC,D0.W)
                    16947   OSTmrStop_8:
00005932  009E      16948          dc.w      OSTmrStop_12-OSTmrStop_8
00005934  0092      16949          dc.w      OSTmrStop_10-OSTmrStop_8
00005936  0092      16950          dc.w      OSTmrStop_10-OSTmrStop_8
00005938  0008      16951          dc.w      OSTmrStop_9-OSTmrStop_8
                    16952   OSTmrStop_9:
                    16953   ; case OS_TMR_STATE_RUNNING:
                    16954   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
0000593A  2F03      16955          move.l    D3,-(A7)
0000593C  4EB9 0000 16956          jsr       @ucos_ii_OSTmr_Unlink
00005940  5D00      
00005942  584F      16957          addq.w    #4,A7
                    16958   ; *perr = OS_ERR_NONE;
00005944  2042      16959          move.l    D2,A0
00005946  4210      16960          clr.b     (A0)
                    16961   ; switch (opt) {
00005948  102E 000F 16962          move.b    15(A6),D0
0000594C  C0BC 0000 16963          and.l     #255,D0
00005950  00FF      
00005952  0C80 0000 16964          cmp.l     #3,D0
00005956  0003      
00005958  6718      16965          beq.s     OSTmrStop_16
0000595A  620A      16966          bhi.s     OSTmrStop_20
0000595C  4A80      16967          tst.l     D0
0000595E  6700 0056 16968          beq       OSTmrStop_18
00005962  6000 0054 16969          bra       OSTmrStop_14
                    16970   OSTmrStop_20:
00005966  0C80 0000 16971          cmp.l     #4,D0
0000596A  0004      
0000596C  6728      16972          beq.s     OSTmrStop_17
0000596E  6000 0048 16973          bra       OSTmrStop_14
                    16974   OSTmrStop_16:
                    16975   ; case OS_TMR_OPT_CALLBACK:
                    16976   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005972  2043      16977          move.l    D3,A0
00005974  2828 0002 16978          move.l    2(A0),D4
                    16979   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005978  4A84      16980          tst.l     D4
0000597A  6710      16981          beq.s     OSTmrStop_21
                    16982   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
0000597C  2043      16983          move.l    D3,A0
0000597E  2F28 0006 16984          move.l    6(A0),-(A7)
00005982  2F03      16985          move.l    D3,-(A7)
00005984  2044      16986          move.l    D4,A0
00005986  4E90      16987          jsr       (A0)
00005988  504F      16988          addq.w    #8,A7
0000598A  6006      16989          bra.s     OSTmrStop_22
                    16990   OSTmrStop_21:
                    16991   ; } else {
                    16992   ; *perr = OS_ERR_TMR_NO_CALLBACK;
0000598C  2042      16993          move.l    D2,A0
0000598E  10BC 008F 16994          move.b    #143,(A0)
                    16995   OSTmrStop_22:
                    16996   ; }
                    16997   ; break;
00005992  6000 002A 16998          bra       OSTmrStop_15
                    16999   OSTmrStop_17:
                    17000   ; case OS_TMR_OPT_CALLBACK_ARG:
                    17001   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005996  2043      17002          move.l    D3,A0
00005998  2828 0002 17003          move.l    2(A0),D4
                    17004   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0000599C  4A84      17005          tst.l     D4
0000599E  670E      17006          beq.s     OSTmrStop_23
                    17007   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
000059A0  2F2E 0010 17008          move.l    16(A6),-(A7)
000059A4  2F03      17009          move.l    D3,-(A7)
000059A6  2044      17010          move.l    D4,A0
000059A8  4E90      17011          jsr       (A0)
000059AA  504F      17012          addq.w    #8,A7
000059AC  6006      17013          bra.s     OSTmrStop_24
                    17014   OSTmrStop_23:
                    17015   ; } else {
                    17016   ; *perr = OS_ERR_TMR_NO_CALLBACK;
000059AE  2042      17017          move.l    D2,A0
000059B0  10BC 008F 17018          move.b    #143,(A0)
                    17019   OSTmrStop_24:
                    17020   ; }
                    17021   ; break;
000059B4  6008      17022          bra.s     OSTmrStop_15
                    17023   OSTmrStop_18:
                    17024   ; case OS_TMR_OPT_NONE:
                    17025   ; break;
000059B6  6006      17026          bra.s     OSTmrStop_15
                    17027   OSTmrStop_14:
                    17028   ; default:
                    17029   ; *perr = OS_ERR_TMR_INVALID_OPT;
000059B8  2042      17030          move.l    D2,A0
000059BA  10BC 0084 17031          move.b    #132,(A0)
                    17032   ; break;
                    17033   OSTmrStop_15:
                    17034   ; }
                    17035   ; OSSchedUnlock();
000059BE  4E92      17036          jsr       (A2)
                    17037   ; return (OS_TRUE);
000059C0  7001      17038          moveq     #1,D0
000059C2  6022      17039          bra.s     OSTmrStop_3
                    17040   OSTmrStop_10:
                    17041   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    17042   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    17043   ; OSSchedUnlock();
000059C4  4E92      17044          jsr       (A2)
                    17045   ; *perr = OS_ERR_TMR_STOPPED;
000059C6  2042      17046          move.l    D2,A0
000059C8  10BC 008E 17047          move.b    #142,(A0)
                    17048   ; return (OS_TRUE);
000059CC  7001      17049          moveq     #1,D0
000059CE  6016      17050          bra.s     OSTmrStop_3
                    17051   OSTmrStop_12:
                    17052   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    17053   ; OSSchedUnlock();
000059D0  4E92      17054          jsr       (A2)
                    17055   ; *perr = OS_ERR_TMR_INACTIVE;
000059D2  2042      17056          move.l    D2,A0
000059D4  10BC 0087 17057          move.b    #135,(A0)
                    17058   ; return (OS_FALSE);
000059D8  4200      17059          clr.b     D0
000059DA  600A      17060          bra.s     OSTmrStop_3
                    17061   OSTmrStop_6:
                    17062   ; default:
                    17063   ; OSSchedUnlock();
000059DC  4E92      17064          jsr       (A2)
                    17065   ; *perr = OS_ERR_TMR_INVALID_STATE;
000059DE  2042      17066          move.l    D2,A0
000059E0  10BC 008D 17067          move.b    #141,(A0)
                    17068   ; return (OS_FALSE);
000059E4  4200      17069          clr.b     D0
                    17070   OSTmrStop_3:
000059E6  4CDF 041C 17071          movem.l   (A7)+,D2/D3/D4/A2
000059EA  4E5E      17072          unlk      A6
000059EC  4E75      17073          rts
                    17074   ; }
                    17075   ; }
                    17076   ; #endif
                    17077   ; /*$PAGE*/
                    17078   ; /*
                    17079   ; *********************************************************************************************************
                    17080   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    17081   ; *
                    17082   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    17083   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    17084   ; *
                    17085   ; * Arguments  : none
                    17086   ; *
                    17087   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    17088   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    17089   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    17090   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    17091   ; *                                  signaling is created by uC/OS-II.
                    17092   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    17093   ; *                                  used for signaling is created by uC/OS-II.
                    17094   ; *********************************************************************************************************
                    17095   ; */
                    17096   ; #if OS_TMR_EN > 0u
                    17097   ; INT8U  OSTmrSignal (void)
                    17098   ; {
                    17099   _OSTmrSignal:
000059EE  4E56 FFFC 17100          link      A6,#-4
                    17101   ; INT8U  err;
                    17102   ; err = OSSemPost(OSTmrSemSignal);
000059F2  2F39 0800 17103          move.l    _OSTmrSemSignal.L,-(A7)
000059F6  1986      
000059F8  4EB8 455E 17104          jsr       _OSSemPost
000059FC  584F      17105          addq.w    #4,A7
000059FE  1D40 FFFF 17106          move.b    D0,-1(A6)
                    17107   ; return (err);
00005A02  102E FFFF 17108          move.b    -1(A6),D0
00005A06  4E5E      17109          unlk      A6
00005A08  4E75      17110          rts
                    17111   ; }
                    17112   ; #endif
                    17113   ; /*$PAGE*/
                    17114   ; /*
                    17115   ; *********************************************************************************************************
                    17116   ; *                                      ALLOCATE AND FREE A TIMER
                    17117   ; *
                    17118   ; * Description: This function is called to allocate a timer.
                    17119   ; *
                    17120   ; * Arguments  : none
                    17121   ; *
                    17122   ; * Returns    : a pointer to a timer if one is available
                    17123   ; *********************************************************************************************************
                    17124   ; */
                    17125   ; #if OS_TMR_EN > 0u
                    17126   ; static  OS_TMR  *OSTmr_Alloc (void)
                    17127   ; {
                    17128   @ucos_ii_OSTmr_Alloc:
00005A0A  48E7 2020 17129          movem.l   D2/A2,-(A7)
00005A0E  45F9 0800 17130          lea       _OSTmrFreeList.L,A2
00005A12  1BCA      
                    17131   ; OS_TMR *ptmr;
                    17132   ; if (OSTmrFreeList == (OS_TMR *)0) {
00005A14  2012      17133          move.l    (A2),D0
00005A16  6604      17134          bne.s     @ucos_ii_OSTmr_Alloc_1
                    17135   ; return ((OS_TMR *)0);
00005A18  4280      17136          clr.l     D0
00005A1A  6022      17137          bra.s     @ucos_ii_OSTmr_Alloc_3
                    17138   @ucos_ii_OSTmr_Alloc_1:
                    17139   ; }
                    17140   ; ptmr            = (OS_TMR *)OSTmrFreeList;
00005A1C  2412      17141          move.l    (A2),D2
                    17142   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
00005A1E  2042      17143          move.l    D2,A0
00005A20  24A8 000A 17144          move.l    10(A0),(A2)
                    17145   ; ptmr->OSTmrNext = (OS_TCB *)0;
00005A24  2042      17146          move.l    D2,A0
00005A26  42A8 000A 17147          clr.l     10(A0)
                    17148   ; ptmr->OSTmrPrev = (OS_TCB *)0;
00005A2A  2042      17149          move.l    D2,A0
00005A2C  42A8 000E 17150          clr.l     14(A0)
                    17151   ; OSTmrUsed++;
00005A30  5279 0800 17152          addq.w    #1,_OSTmrUsed.L
00005A34  197C      
                    17153   ; OSTmrFree--;
00005A36  5379 0800 17154          subq.w    #1,_OSTmrFree.L
00005A3A  197A      
                    17155   ; return (ptmr);
00005A3C  2002      17156          move.l    D2,D0
                    17157   @ucos_ii_OSTmr_Alloc_3:
00005A3E  4CDF 0404 17158          movem.l   (A7)+,D2/A2
00005A42  4E75      17159          rts
                    17160   ; }
                    17161   ; #endif
                    17162   ; /*
                    17163   ; *********************************************************************************************************
                    17164   ; *                                   RETURN A TIMER TO THE FREE LIST
                    17165   ; *
                    17166   ; * Description: This function is called to return a timer object to the free list of timers.
                    17167   ; *
                    17168   ; * Arguments  : ptmr     is a pointer to the timer to free
                    17169   ; *
                    17170   ; * Returns    : none
                    17171   ; *********************************************************************************************************
                    17172   ; */
                    17173   ; #if OS_TMR_EN > 0u
                    17174   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    17175   ; {
                    17176   @ucos_ii_OSTmr_Free:
00005A44  4E56 0000 17177          link      A6,#0
00005A48  2F02      17178          move.l    D2,-(A7)
00005A4A  242E 0008 17179          move.l    8(A6),D2
                    17180   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
00005A4E  2042      17181          move.l    D2,A0
00005A50  4228 0023 17182          clr.b     35(A0)
                    17183   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
00005A54  2042      17184          move.l    D2,A0
00005A56  4228 0022 17185          clr.b     34(A0)
                    17186   ; ptmr->OSTmrPeriod      = 0u;
00005A5A  2042      17187          move.l    D2,A0
00005A5C  42A8 001A 17188          clr.l     26(A0)
                    17189   ; ptmr->OSTmrMatch       = 0u;
00005A60  2042      17190          move.l    D2,A0
00005A62  42A8 0012 17191          clr.l     18(A0)
                    17192   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
00005A66  2042      17193          move.l    D2,A0
00005A68  42A8 0002 17194          clr.l     2(A0)
                    17195   ; ptmr->OSTmrCallbackArg = (void *)0;
00005A6C  2042      17196          move.l    D2,A0
00005A6E  42A8 0006 17197          clr.l     6(A0)
                    17198   ; #if OS_TMR_CFG_NAME_EN > 0u
                    17199   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
00005A72  41F9 0000 17200          lea       @ucos_ii_1.L,A0
00005A76  6AD0      
00005A78  2242      17201          move.l    D2,A1
00005A7A  2348 001E 17202          move.l    A0,30(A1)
                    17203   ; #endif
                    17204   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00005A7E  2042      17205          move.l    D2,A0
00005A80  42A8 000E 17206          clr.l     14(A0)
                    17207   ; ptmr->OSTmrNext        = OSTmrFreeList;
00005A84  2042      17208          move.l    D2,A0
00005A86  2179 0800 17209          move.l    _OSTmrFreeList.L,10(A0)
00005A8A  1BCA 000A 
                    17210   ; OSTmrFreeList          = ptmr;
00005A8E  23C2 0800 17211          move.l    D2,_OSTmrFreeList.L
00005A92  1BCA      
                    17212   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
00005A94  5379 0800 17213          subq.w    #1,_OSTmrUsed.L
00005A98  197C      
                    17214   ; OSTmrFree++;
00005A9A  5279 0800 17215          addq.w    #1,_OSTmrFree.L
00005A9E  197A      
00005AA0  241F      17216          move.l    (A7)+,D2
00005AA2  4E5E      17217          unlk      A6
00005AA4  4E75      17218          rts
                    17219   ; }
                    17220   ; #endif
                    17221   ; /*$PAGE*/
                    17222   ; /*
                    17223   ; *********************************************************************************************************
                    17224   ; *                                                    INITIALIZATION
                    17225   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    17226   ; *
                    17227   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    17228   ; *
                    17229   ; * Arguments  : none
                    17230   ; *
                    17231   ; * Returns    : none
                    17232   ; *********************************************************************************************************
                    17233   ; */
                    17234   ; #if OS_TMR_EN > 0u
                    17235   ; void  OSTmr_Init (void)
                    17236   ; {
                    17237   _OSTmr_Init:
00005AA6  4E56 FFF8 17238          link      A6,#-8
00005AAA  48E7 3020 17239          movem.l   D2/D3/A2,-(A7)
00005AAE  45F9 0800 17240          lea       _OSTmrTbl.L,A2
00005AB2  198A      
                    17241   ; #if OS_EVENT_NAME_EN > 0u
                    17242   ; INT8U    err;
                    17243   ; #endif
                    17244   ; INT16U   ix;
                    17245   ; INT16U   ix_next;
                    17246   ; OS_TMR  *ptmr1;
                    17247   ; OS_TMR  *ptmr2;
                    17248   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
00005AB4  4878 0240 17249          pea       576
00005AB8  2F0A      17250          move.l    A2,-(A7)
00005ABA  4EB8 19D6 17251          jsr       _OS_MemClr
00005ABE  504F      17252          addq.w    #8,A7
                    17253   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00005AC0  4878 0020 17254          pea       32
00005AC4  4879 0800 17255          pea       _OSTmrWheelTbl.L
00005AC8  1CCE      
00005ACA  4EB8 19D6 17256          jsr       _OS_MemClr
00005ACE  504F      17257          addq.w    #8,A7
                    17258   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
00005AD0  4243      17259          clr.w     D3
                    17260   OSTmr_Init_1:
00005AD2  0C43 000F 17261          cmp.w     #15,D3
00005AD6  6400 0056 17262          bhs       OSTmr_Init_3
                    17263   ; ix_next = ix + 1u;
00005ADA  3003      17264          move.w    D3,D0
00005ADC  5240      17265          addq.w    #1,D0
00005ADE  3D40 FFFA 17266          move.w    D0,-6(A6)
                    17267   ; ptmr1 = &OSTmrTbl[ix];
00005AE2  200A      17268          move.l    A2,D0
00005AE4  C6BC 0000 17269          and.l     #65535,D3
00005AE8  FFFF      
00005AEA  2203      17270          move.l    D3,D1
00005AEC  C3FC 0024 17271          muls      #36,D1
00005AF0  D081      17272          add.l     D1,D0
00005AF2  2400      17273          move.l    D0,D2
                    17274   ; ptmr2 = &OSTmrTbl[ix_next];
00005AF4  200A      17275          move.l    A2,D0
00005AF6  322E FFFA 17276          move.w    -6(A6),D1
00005AFA  C2BC 0000 17277          and.l     #65535,D1
00005AFE  FFFF      
00005B00  C3FC 0024 17278          muls      #36,D1
00005B04  D081      17279          add.l     D1,D0
00005B06  2D40 FFFC 17280          move.l    D0,-4(A6)
                    17281   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
00005B0A  2042      17282          move.l    D2,A0
00005B0C  10BC 0064 17283          move.b    #100,(A0)
                    17284   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
00005B10  2042      17285          move.l    D2,A0
00005B12  4228 0023 17286          clr.b     35(A0)
                    17287   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
00005B16  2042      17288          move.l    D2,A0
00005B18  216E FFFC 17289          move.l    -4(A6),10(A0)
00005B1C  000A      
                    17290   ; #if OS_TMR_CFG_NAME_EN > 0u
                    17291   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005B1E  41F9 0000 17292          lea       @ucos_ii_1.L,A0
00005B22  6AD0      
00005B24  2242      17293          move.l    D2,A1
00005B26  2348 001E 17294          move.l    A0,30(A1)
00005B2A  5243      17295          addq.w    #1,D3
00005B2C  60A4      17296          bra       OSTmr_Init_1
                    17297   OSTmr_Init_3:
                    17298   ; #endif
                    17299   ; }
                    17300   ; ptmr1               = &OSTmrTbl[ix];
00005B2E  200A      17301          move.l    A2,D0
00005B30  C6BC 0000 17302          and.l     #65535,D3
00005B34  FFFF      
00005B36  2203      17303          move.l    D3,D1
00005B38  C3FC 0024 17304          muls      #36,D1
00005B3C  D081      17305          add.l     D1,D0
00005B3E  2400      17306          move.l    D0,D2
                    17307   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
00005B40  2042      17308          move.l    D2,A0
00005B42  10BC 0064 17309          move.b    #100,(A0)
                    17310   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
00005B46  2042      17311          move.l    D2,A0
00005B48  4228 0023 17312          clr.b     35(A0)
                    17313   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005B4C  2042      17314          move.l    D2,A0
00005B4E  42A8 000A 17315          clr.l     10(A0)
                    17316   ; #if OS_TMR_CFG_NAME_EN > 0u
                    17317   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005B52  41F9 0000 17318          lea       @ucos_ii_1.L,A0
00005B56  6AD0      
00005B58  2242      17319          move.l    D2,A1
00005B5A  2348 001E 17320          move.l    A0,30(A1)
                    17321   ; #endif
                    17322   ; OSTmrTime           = 0u;
00005B5E  42B9 0800 17323          clr.l     _OSTmrTime.L
00005B62  197E      
                    17324   ; OSTmrUsed           = 0u;
00005B64  4279 0800 17325          clr.w     _OSTmrUsed.L
00005B68  197C      
                    17326   ; OSTmrFree           = OS_TMR_CFG_MAX;
00005B6A  33FC 0010 17327          move.w    #16,_OSTmrFree.L
00005B6E  0800 197A 
                    17328   ; OSTmrFreeList       = &OSTmrTbl[0];
00005B72  23CA 0800 17329          move.l    A2,_OSTmrFreeList.L
00005B76  1BCA      
                    17330   ; OSTmrSem            = OSSemCreate(1u);
00005B78  4878 0001 17331          pea       1
00005B7C  4EB8 4216 17332          jsr       _OSSemCreate
00005B80  584F      17333          addq.w    #4,A7
00005B82  23C0 0800 17334          move.l    D0,_OSTmrSem.L
00005B86  1982      
                    17335   ; OSTmrSemSignal      = OSSemCreate(0u);
00005B88  42A7      17336          clr.l     -(A7)
00005B8A  4EB8 4216 17337          jsr       _OSSemCreate
00005B8E  584F      17338          addq.w    #4,A7
00005B90  23C0 0800 17339          move.l    D0,_OSTmrSemSignal.L
00005B94  1986      
                    17340   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    17341   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
00005B96  486E FFF9 17342          pea       -7(A6)
00005B9A  4879 0000 17343          pea       @ucos_ii_4.L
00005B9E  6AEE      
00005BA0  2F39 0800 17344          move.l    _OSTmrSem.L,-(A7)
00005BA4  1982      
00005BA6  4EB8 0DE4 17345          jsr       _OSEventNameSet
00005BAA  DEFC 000C 17346          add.w     #12,A7
                    17347   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
00005BAE  486E FFF9 17348          pea       -7(A6)
00005BB2  4879 0000 17349          pea       @ucos_ii_5.L
00005BB6  6B00      
00005BB8  2F39 0800 17350          move.l    _OSTmrSemSignal.L,-(A7)
00005BBC  1986      
00005BBE  4EB8 0DE4 17351          jsr       _OSEventNameSet
00005BC2  DEFC 000C 17352          add.w     #12,A7
                    17353   ; #endif
                    17354   ; OSTmr_InitTask();
00005BC6  4EB9 0000 17355          jsr       @ucos_ii_OSTmr_InitTask
00005BCA  5BD4      
00005BCC  4CDF 040C 17356          movem.l   (A7)+,D2/D3/A2
00005BD0  4E5E      17357          unlk      A6
00005BD2  4E75      17358          rts
                    17359   ; }
                    17360   ; #endif
                    17361   ; /*$PAGE*/
                    17362   ; /*
                    17363   ; *********************************************************************************************************
                    17364   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    17365   ; *
                    17366   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    17367   ; *                               * Arguments  : none
                    17368   ; *
                    17369   ; * Returns    : none
                    17370   ; *********************************************************************************************************
                    17371   ; */
                    17372   ; #if OS_TMR_EN > 0u
                    17373   ; static  void  OSTmr_InitTask (void)
                    17374   ; {
                    17375   @ucos_ii_OSTmr_InitTask:
00005BD4  4E56 FFFC 17376          link      A6,#-4
                    17377   ; #if OS_TASK_NAME_EN > 0u
                    17378   ; INT8U  err;
                    17379   ; #endif
                    17380   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    17381   ; #if OS_STK_GROWTH == 1u
                    17382   ; (void)OSTaskCreateExt(OSTmr_Task,
00005BD8  4878 0003 17383          pea       3
00005BDC  42A7      17384          clr.l     -(A7)
00005BDE  4878 0080 17385          pea       128
00005BE2  4879 0800 17386          pea       _OSTmrTaskStk.L
00005BE6  1BCE      
00005BE8  4878 FFFD 17387          pea       65533
00005BEC  4878 0005 17388          pea       5
00005BF0  41F9 0800 17389          lea       _OSTmrTaskStk.L,A0
00005BF4  1BCE      
00005BF6  D0FC 00FE 17390          add.w     #254,A0
00005BFA  2F08      17391          move.l    A0,-(A7)
00005BFC  42A7      17392          clr.l     -(A7)
00005BFE  4879 0000 17393          pea       @ucos_ii_OSTmr_Task.L
00005C02  5D9E      
00005C04  4EB8 498C 17394          jsr       _OSTaskCreateExt
00005C08  DEFC 0024 17395          add.w     #36,A7
00005C0C  C0BC 0000 17396          and.l     #255,D0
00005C10  00FF      
                    17397   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17398   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    17399   ; OS_TASK_TMR_PRIO,
                    17400   ; OS_TASK_TMR_ID,
                    17401   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    17402   ; OS_TASK_TMR_STK_SIZE,
                    17403   ; (void *)0,                                       /* No TCB extension                        */
                    17404   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17405   ; #else
                    17406   ; (void)OSTaskCreateExt(OSTmr_Task,
                    17407   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17408   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    17409   ; OS_TASK_TMR_PRIO,
                    17410   ; OS_TASK_TMR_ID,
                    17411   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    17412   ; OS_TASK_TMR_STK_SIZE,
                    17413   ; (void *)0,                                       /* No TCB extension                        */
                    17414   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17415   ; #endif
                    17416   ; #else
                    17417   ; #if OS_STK_GROWTH == 1u
                    17418   ; (void)OSTaskCreate(OSTmr_Task,
                    17419   ; (void *)0,
                    17420   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    17421   ; OS_TASK_TMR_PRIO);
                    17422   ; #else
                    17423   ; (void)OSTaskCreate(OSTmr_Task,
                    17424   ; (void *)0,
                    17425   ; &OSTmrTaskStk[0],
                    17426   ; OS_TASK_TMR_PRIO);
                    17427   ; #endif
                    17428   ; #endif
                    17429   ; #if OS_TASK_NAME_EN > 0u
                    17430   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
00005C12  486E FFFF 17431          pea       -1(A6)
00005C16  4879 0000 17432          pea       @ucos_ii_6.L
00005C1A  6B14      
00005C1C  4878 0005 17433          pea       5
00005C20  4EB8 4D98 17434          jsr       _OSTaskNameSet
00005C24  DEFC 000C 17435          add.w     #12,A7
00005C28  4E5E      17436          unlk      A6
00005C2A  4E75      17437          rts
                    17438   ; #endif
                    17439   ; }
                    17440   ; #endif
                    17441   ; /*$PAGE*/
                    17442   ; /*
                    17443   ; *********************************************************************************************************
                    17444   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    17445   ; *
                    17446   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    17447   ; *              inserted at the beginning of the list.
                    17448   ; *
                    17449   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    17450   ; *
                    17451   ; *              type          Is either:
                    17452   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    17453   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    17454   ; *
                    17455   ; * Returns    : none
                    17456   ; *********************************************************************************************************
                    17457   ; */
                    17458   ; #if OS_TMR_EN > 0u
                    17459   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    17460   ; INT8U    type)
                    17461   ; {
                    17462   @ucos_ii_OSTmr_Link:
00005C2C  4E56 FFFC 17463          link      A6,#-4
00005C30  48E7 3820 17464          movem.l   D2/D3/D4/A2,-(A7)
00005C34  242E 0008 17465          move.l    8(A6),D2
00005C38  45F9 0800 17466          lea       _OSTmrTime.L,A2
00005C3C  197E      
                    17467   ; OS_TMR       *ptmr1;
                    17468   ; OS_TMR_WHEEL *pspoke;
                    17469   ; INT16U        spoke;
                    17470   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
00005C3E  2042      17471          move.l    D2,A0
00005C40  117C 0003 17472          move.b    #3,35(A0)
00005C44  0023      
                    17473   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00005C46  102E 000F 17474          move.b    15(A6),D0
00005C4A  0C00 0001 17475          cmp.b     #1,D0
00005C4E  6610      17476          bne.s     @ucos_ii_OSTmr_Link_1
                    17477   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005C50  2042      17478          move.l    D2,A0
00005C52  2028 001A 17479          move.l    26(A0),D0
00005C56  D092      17480          add.l     (A2),D0
00005C58  2042      17481          move.l    D2,A0
00005C5A  2140 0012 17482          move.l    D0,18(A0)
00005C5E  6026      17483          bra.s     @ucos_ii_OSTmr_Link_4
                    17484   @ucos_ii_OSTmr_Link_1:
                    17485   ; } else {
                    17486   ; if (ptmr->OSTmrDly == 0u) {
00005C60  2042      17487          move.l    D2,A0
00005C62  2028 0016 17488          move.l    22(A0),D0
00005C66  6610      17489          bne.s     @ucos_ii_OSTmr_Link_3
                    17490   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005C68  2042      17491          move.l    D2,A0
00005C6A  2028 001A 17492          move.l    26(A0),D0
00005C6E  D092      17493          add.l     (A2),D0
00005C70  2042      17494          move.l    D2,A0
00005C72  2140 0012 17495          move.l    D0,18(A0)
00005C76  600E      17496          bra.s     @ucos_ii_OSTmr_Link_4
                    17497   @ucos_ii_OSTmr_Link_3:
                    17498   ; } else {
                    17499   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00005C78  2042      17500          move.l    D2,A0
00005C7A  2028 0016 17501          move.l    22(A0),D0
00005C7E  D092      17502          add.l     (A2),D0
00005C80  2042      17503          move.l    D2,A0
00005C82  2140 0012 17504          move.l    D0,18(A0)
                    17505   @ucos_ii_OSTmr_Link_4:
                    17506   ; }
                    17507   ; }
                    17508   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005C86  2002      17509          move.l    D2,D0
00005C88  0680 0000 17510          add.l     #18,D0
00005C8C  0012      
00005C8E  2040      17511          move.l    D0,A0
00005C90  2F10      17512          move.l    (A0),-(A7)
00005C92  4878 0008 17513          pea       8
00005C96  4EB9 0000 17514          jsr       ULDIV
00005C9A  60E6      
00005C9C  202F 0004 17515          move.l    4(A7),D0
00005CA0  504F      17516          addq.w    #8,A7
00005CA2  3D40 FFFE 17517          move.w    D0,-2(A6)
                    17518   ; pspoke = &OSTmrWheelTbl[spoke];
00005CA6  41F9 0800 17519          lea       _OSTmrWheelTbl.L,A0
00005CAA  1CCE      
00005CAC  302E FFFE 17520          move.w    -2(A6),D0
00005CB0  C0BC 0000 17521          and.l     #65535,D0
00005CB4  FFFF      
00005CB6  E588      17522          lsl.l     #2,D0
00005CB8  D1C0      17523          add.l     D0,A0
00005CBA  2608      17524          move.l    A0,D3
                    17525   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005CBC  2043      17526          move.l    D3,A0
00005CBE  2010      17527          move.l    (A0),D0
00005CC0  6614      17528          bne.s     @ucos_ii_OSTmr_Link_5
                    17529   ; pspoke->OSTmrFirst   = ptmr;
00005CC2  2043      17530          move.l    D3,A0
00005CC4  2082      17531          move.l    D2,(A0)
                    17532   ; ptmr->OSTmrNext      = (OS_TMR *)0;
00005CC6  2042      17533          move.l    D2,A0
00005CC8  42A8 000A 17534          clr.l     10(A0)
                    17535   ; pspoke->OSTmrEntries = 1u;
00005CCC  2043      17536          move.l    D3,A0
00005CCE  317C 0001 17537          move.w    #1,4(A0)
00005CD2  0004      
00005CD4  601C      17538          bra.s     @ucos_ii_OSTmr_Link_6
                    17539   @ucos_ii_OSTmr_Link_5:
                    17540   ; } else {
                    17541   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
00005CD6  2043      17542          move.l    D3,A0
00005CD8  2810      17543          move.l    (A0),D4
                    17544   ; pspoke->OSTmrFirst   = ptmr;
00005CDA  2043      17545          move.l    D3,A0
00005CDC  2082      17546          move.l    D2,(A0)
                    17547   ; ptmr->OSTmrNext      = (void *)ptmr1;
00005CDE  2042      17548          move.l    D2,A0
00005CE0  2144 000A 17549          move.l    D4,10(A0)
                    17550   ; ptmr1->OSTmrPrev     = (void *)ptmr;
00005CE4  2044      17551          move.l    D4,A0
00005CE6  2142 000E 17552          move.l    D2,14(A0)
                    17553   ; pspoke->OSTmrEntries++;
00005CEA  2003      17554          move.l    D3,D0
00005CEC  5880      17555          addq.l    #4,D0
00005CEE  2040      17556          move.l    D0,A0
00005CF0  5250      17557          addq.w    #1,(A0)
                    17558   @ucos_ii_OSTmr_Link_6:
                    17559   ; }
                    17560   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005CF2  2042      17561          move.l    D2,A0
00005CF4  42A8 000E 17562          clr.l     14(A0)
00005CF8  4CDF 041C 17563          movem.l   (A7)+,D2/D3/D4/A2
00005CFC  4E5E      17564          unlk      A6
00005CFE  4E75      17565          rts
                    17566   ; }
                    17567   ; #endif
                    17568   ; /*$PAGE*/
                    17569   ; /*
                    17570   ; *********************************************************************************************************
                    17571   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    17572   ; *
                    17573   ; * Description: This function is called to remove the timer from the timer wheel.
                    17574   ; *
                    17575   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    17576   ; *
                    17577   ; * Returns    : none
                    17578   ; *********************************************************************************************************
                    17579   ; */
                    17580   ; #if OS_TMR_EN > 0u
                    17581   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    17582   ; {
                    17583   @ucos_ii_OSTmr_Unlink:
00005D00  4E56 FFFC 17584          link      A6,#-4
00005D04  48E7 3C00 17585          movem.l   D2/D3/D4/D5,-(A7)
00005D08  242E 0008 17586          move.l    8(A6),D2
                    17587   ; OS_TMR        *ptmr1;
                    17588   ; OS_TMR        *ptmr2;
                    17589   ; OS_TMR_WHEEL  *pspoke;
                    17590   ; INT16U         spoke;
                    17591   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005D0C  2002      17592          move.l    D2,D0
00005D0E  0680 0000 17593          add.l     #18,D0
00005D12  0012      
00005D14  2040      17594          move.l    D0,A0
00005D16  2F10      17595          move.l    (A0),-(A7)
00005D18  4878 0008 17596          pea       8
00005D1C  4EB9 0000 17597          jsr       ULDIV
00005D20  60E6      
00005D22  202F 0004 17598          move.l    4(A7),D0
00005D26  504F      17599          addq.w    #8,A7
00005D28  3D40 FFFE 17600          move.w    D0,-2(A6)
                    17601   ; pspoke = &OSTmrWheelTbl[spoke];
00005D2C  41F9 0800 17602          lea       _OSTmrWheelTbl.L,A0
00005D30  1CCE      
00005D32  302E FFFE 17603          move.w    -2(A6),D0
00005D36  C0BC 0000 17604          and.l     #65535,D0
00005D3A  FFFF      
00005D3C  E588      17605          lsl.l     #2,D0
00005D3E  D1C0      17606          add.l     D0,A0
00005D40  2A08      17607          move.l    A0,D5
                    17608   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00005D42  2045      17609          move.l    D5,A0
00005D44  B490      17610          cmp.l     (A0),D2
00005D46  6616      17611          bne.s     @ucos_ii_OSTmr_Unlink_1
                    17612   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
00005D48  2042      17613          move.l    D2,A0
00005D4A  2628 000A 17614          move.l    10(A0),D3
                    17615   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
00005D4E  2045      17616          move.l    D5,A0
00005D50  2083      17617          move.l    D3,(A0)
                    17618   ; if (ptmr1 != (OS_TMR *)0) {
00005D52  4A83      17619          tst.l     D3
00005D54  6706      17620          beq.s     @ucos_ii_OSTmr_Unlink_3
                    17621   ; ptmr1->OSTmrPrev = (void *)0;
00005D56  2043      17622          move.l    D3,A0
00005D58  42A8 000E 17623          clr.l     14(A0)
                    17624   @ucos_ii_OSTmr_Unlink_3:
00005D5C  601C      17625          bra.s     @ucos_ii_OSTmr_Unlink_5
                    17626   @ucos_ii_OSTmr_Unlink_1:
                    17627   ; }
                    17628   ; } else {
                    17629   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00005D5E  2042      17630          move.l    D2,A0
00005D60  2628 000E 17631          move.l    14(A0),D3
                    17632   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
00005D64  2042      17633          move.l    D2,A0
00005D66  2828 000A 17634          move.l    10(A0),D4
                    17635   ; ptmr1->OSTmrNext = ptmr2;
00005D6A  2043      17636          move.l    D3,A0
00005D6C  2144 000A 17637          move.l    D4,10(A0)
                    17638   ; if (ptmr2 != (OS_TMR *)0) {
00005D70  4A84      17639          tst.l     D4
00005D72  6706      17640          beq.s     @ucos_ii_OSTmr_Unlink_5
                    17641   ; ptmr2->OSTmrPrev = (void *)ptmr1;
00005D74  2044      17642          move.l    D4,A0
00005D76  2143 000E 17643          move.l    D3,14(A0)
                    17644   @ucos_ii_OSTmr_Unlink_5:
                    17645   ; }
                    17646   ; }
                    17647   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005D7A  2042      17648          move.l    D2,A0
00005D7C  117C 0001 17649          move.b    #1,35(A0)
00005D80  0023      
                    17650   ; ptmr->OSTmrNext  = (void *)0;
00005D82  2042      17651          move.l    D2,A0
00005D84  42A8 000A 17652          clr.l     10(A0)
                    17653   ; ptmr->OSTmrPrev  = (void *)0;
00005D88  2042      17654          move.l    D2,A0
00005D8A  42A8 000E 17655          clr.l     14(A0)
                    17656   ; pspoke->OSTmrEntries--;
00005D8E  2005      17657          move.l    D5,D0
00005D90  5880      17658          addq.l    #4,D0
00005D92  2040      17659          move.l    D0,A0
00005D94  5350      17660          subq.w    #1,(A0)
00005D96  4CDF 003C 17661          movem.l   (A7)+,D2/D3/D4/D5
00005D9A  4E5E      17662          unlk      A6
00005D9C  4E75      17663          rts
                    17664   ; }
                    17665   ; #endif
                    17666   ; /*$PAGE*/
                    17667   ; /*
                    17668   ; *********************************************************************************************************
                    17669   ; *                                        TIMER MANAGEMENT TASK
                    17670   ; *
                    17671   ; * Description: This task is created by OSTmrInit().
                    17672   ; *
                    17673   ; * Arguments  : none
                    17674   ; *
                    17675   ; * Returns    : none
                    17676   ; *********************************************************************************************************
                    17677   ; */
                    17678   ; #if OS_TMR_EN > 0u
                    17679   ; static  void  OSTmr_Task (void *p_arg)
                    17680   ; {
                    17681   @ucos_ii_OSTmr_Task:
00005D9E  4E56 FFF4 17682          link      A6,#-12
00005DA2  48E7 3020 17683          movem.l   D2/D3/A2,-(A7)
00005DA6  45F9 0800 17684          lea       _OSTmrTime.L,A2
00005DAA  197E      
                    17685   ; INT8U            err;
                    17686   ; OS_TMR          *ptmr;
                    17687   ; OS_TMR          *ptmr_next;
                    17688   ; OS_TMR_CALLBACK  pfnct;
                    17689   ; OS_TMR_WHEEL    *pspoke;
                    17690   ; INT16U           spoke;
                    17691   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17692   ; for (;;) {
                    17693   @ucos_ii_OSTmr_Task_1:
                    17694   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005DAC  486E FFF5 17695          pea       -11(A6)
00005DB0  42A7      17696          clr.l     -(A7)
00005DB2  2F39 0800 17697          move.l    _OSTmrSemSignal.L,-(A7)
00005DB6  1986      
00005DB8  4EB8 439C 17698          jsr       _OSSemPend
00005DBC  DEFC 000C 17699          add.w     #12,A7
                    17700   ; OSSchedLock();
00005DC0  4EB8 1272 17701          jsr       _OSSchedLock
                    17702   ; OSTmrTime++;                                             /* Increment the current time                        */
00005DC4  5292      17703          addq.l    #1,(A2)
                    17704   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
00005DC6  2F12      17705          move.l    (A2),-(A7)
00005DC8  4878 0008 17706          pea       8
00005DCC  4EB9 0000 17707          jsr       ULDIV
00005DD0  60E6      
00005DD2  202F 0004 17708          move.l    4(A7),D0
00005DD6  504F      17709          addq.w    #8,A7
00005DD8  3D40 FFFE 17710          move.w    D0,-2(A6)
                    17711   ; pspoke = &OSTmrWheelTbl[spoke];
00005DDC  41F9 0800 17712          lea       _OSTmrWheelTbl.L,A0
00005DE0  1CCE      
00005DE2  302E FFFE 17713          move.w    -2(A6),D0
00005DE6  C0BC 0000 17714          and.l     #65535,D0
00005DEA  FFFF      
00005DEC  E588      17715          lsl.l     #2,D0
00005DEE  D1C0      17716          add.l     D0,A0
00005DF0  2D48 FFFA 17717          move.l    A0,-6(A6)
                    17718   ; ptmr   = pspoke->OSTmrFirst;
00005DF4  206E FFFA 17719          move.l    -6(A6),A0
00005DF8  2410      17720          move.l    (A0),D2
                    17721   ; while (ptmr != (OS_TMR *)0) {
                    17722   @ucos_ii_OSTmr_Task_4:
00005DFA  4A82      17723          tst.l     D2
00005DFC  6700 005E 17724          beq       @ucos_ii_OSTmr_Task_6
                    17725   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
00005E00  2042      17726          move.l    D2,A0
00005E02  2D68 000A 17727          move.l    10(A0),-10(A6)
00005E06  FFF6      
                    17728   ; /* ... timer could get unlinked from the wheel.      */
                    17729   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
00005E08  2042      17730          move.l    D2,A0
00005E0A  2012      17731          move.l    (A2),D0
00005E0C  B0A8 0012 17732          cmp.l     18(A0),D0
00005E10  6600 0044 17733          bne       @ucos_ii_OSTmr_Task_11
                    17734   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
00005E14  2F02      17735          move.l    D2,-(A7)
00005E16  4EB8 5D00 17736          jsr       @ucos_ii_OSTmr_Unlink
00005E1A  584F      17737          addq.w    #4,A7
                    17738   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
00005E1C  2042      17739          move.l    D2,A0
00005E1E  1028 0022 17740          move.b    34(A0),D0
00005E22  0C00 0002 17741          cmp.b     #2,D0
00005E26  660E      17742          bne.s     @ucos_ii_OSTmr_Task_9
                    17743   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
00005E28  4878 0001 17744          pea       1
00005E2C  2F02      17745          move.l    D2,-(A7)
00005E2E  4EB8 5C2C 17746          jsr       @ucos_ii_OSTmr_Link
00005E32  504F      17747          addq.w    #8,A7
00005E34  6008      17748          bra.s     @ucos_ii_OSTmr_Task_10
                    17749   @ucos_ii_OSTmr_Task_9:
                    17750   ; } else {
                    17751   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00005E36  2042      17752          move.l    D2,A0
00005E38  117C 0002 17753          move.b    #2,35(A0)
00005E3C  0023      
                    17754   @ucos_ii_OSTmr_Task_10:
                    17755   ; }
                    17756   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005E3E  2042      17757          move.l    D2,A0
00005E40  2628 0002 17758          move.l    2(A0),D3
                    17759   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005E44  4A83      17760          tst.l     D3
00005E46  670E      17761          beq.s     @ucos_ii_OSTmr_Task_11
                    17762   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
00005E48  2042      17763          move.l    D2,A0
00005E4A  2F28 0006 17764          move.l    6(A0),-(A7)
00005E4E  2F02      17765          move.l    D2,-(A7)
00005E50  2043      17766          move.l    D3,A0
00005E52  4E90      17767          jsr       (A0)
00005E54  504F      17768          addq.w    #8,A7
                    17769   @ucos_ii_OSTmr_Task_11:
                    17770   ; }
                    17771   ; }
                    17772   ; ptmr = ptmr_next;
00005E56  242E FFF6 17773          move.l    -10(A6),D2
00005E5A  609E      17774          bra       @ucos_ii_OSTmr_Task_4
                    17775   @ucos_ii_OSTmr_Task_6:
                    17776   ; }
                    17777   ; OSSchedUnlock();
00005E5C  4EB8 12A2 17778          jsr       _OSSchedUnlock
00005E60  6000 FF4A 17779          bra       @ucos_ii_OSTmr_Task_1
                    17780   ; /*
                    17781   ; *********************************************************************************************************
                    17782   ; *                                                uC/OS-II
                    17783   ; *                                          The Real-Time Kernel
                    17784   ; *
                    17785   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17786   ; *                                           All Rights Reserved
                    17787   ; *
                    17788   ; * File    : uCOS_II.C
                    17789   ; * By      : Jean J. Labrosse
                    17790   ; * Version : V2.91
                    17791   ; *
                    17792   ; * LICENSING TERMS:
                    17793   ; * ---------------
                    17794   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17795   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license 
                    17796   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17797   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17798   ; * licensing fee.
                    17799   ; *********************************************************************************************************
                    17800   ; */
                    17801   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17802   ; #include "ucos_ii.h"
                    17803   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17804   ; #include "os_core.c"
                    17805   ; #include "os_flag.c"
                    17806   ; #include "os_mbox.c"
                    17807   ; #include "os_mem.c"
                    17808   ; #include "os_mutex.c"
                    17809   ; #include "os_q.c"
                    17810   ; #include "os_sem.c"
                    17811   ; #include "os_task.c"
                    17812   ; #include "os_time.c"
                    17813   ; #include "os_tmr.c"
                    17814   ; C:\IDE68K\UCOSII\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17815   ; #include "Bios.h"
                    17816   ; /*
                    17817   ; **  These basic IO routines are designed to handle input and output of characters
                    17818   ; **  via the serial port to the console of hyperternal
                    17819   ; **
                    17820   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17821   ; */
                    17822   ; // things that need to be done at initialisation/boot include
                    17823   ; // 1) initialise serial port and LCD display
                    17824   ; // 2) initialise the LCD display
                    17825   ; // 3) install the trap handler for a context switch (trap0)
                    17826   ; // 4) install the TickISR for level 3 IRQ
                    17827   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17828   ; /*********************************************************************************************
                    17829   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17830   ; *********************************************************************************************/
                    17831   ; void Init_RS232(void)
                    17832   ; {
                    17833   _Init_RS232:
                    17834   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00005E64  13FC 0015 17835          move.b    #21,4194368
00005E68  0040 0040 
                    17836   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00005E6C  13FC 0001 17837          move.b    #1,4194372
00005E70  0040 0044 
00005E74  4E75      17838          rts
                    17839   ; }
                    17840   ; int kbhit(void)
                    17841   ; {
                    17842   _kbhit:
                    17843   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
00005E76  1039 0040 17844          move.b    4194368,D0
00005E7A  0040      
00005E7C  C03C 0002 17845          and.b     #2,D0
00005E80  0C00 0002 17846          cmp.b     #2,D0
00005E84  6604      17847          bne.s     kbhit_1
                    17848   ; return 1 ;
00005E86  7001      17849          moveq     #1,D0
00005E88  6002      17850          bra.s     kbhit_3
                    17851   kbhit_1:
                    17852   ; else
                    17853   ; return 0 ;
00005E8A  4280      17854          clr.l     D0
                    17855   kbhit_3:
00005E8C  4E75      17856          rts
                    17857   ; }
                    17858   ; /*********************************************************************************************************
                    17859   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17860   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17861   ; **  to allow the board to communicate with HyperTerminal Program
                    17862   ; **
                    17863   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17864   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17865   ; **  call _putch() also
                    17866   ; *********************************************************************************************************/
                    17867   ; int _putch( int c)
                    17868   ; {
                    17869   __putch:
00005E8E  4E56 0000 17870          link      A6,#0
                    17871   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17872   _putch_1:
00005E92  1039 0040 17873          move.b    4194368,D0
00005E96  0040      
00005E98  C03C 0002 17874          and.b     #2,D0
00005E9C  0C00 0002 17875          cmp.b     #2,D0
00005EA0  6702      17876          beq.s     _putch_3
00005EA2  60EE      17877          bra       _putch_1
                    17878   _putch_3:
                    17879   ; ;
                    17880   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00005EA4  202E 0008 17881          move.l    8(A6),D0
00005EA8  C03C 007F 17882          and.b     #127,D0
00005EAC  13C0 0040 17883          move.b    D0,4194370
00005EB0  0042      
                    17884   ; return c ;                                              // putchar() expects the character to be returned
00005EB2  202E 0008 17885          move.l    8(A6),D0
00005EB6  4E5E      17886          unlk      A6
00005EB8  4E75      17887          rts
                    17888   ; }
                    17889   ; /*********************************************************************************************************
                    17890   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17891   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17892   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17893   ; **
                    17894   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17895   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17896   ; **  call _getch() also
                    17897   ; *********************************************************************************************************/
                    17898   ; int _getch( void )
                    17899   ; {
                    17900   __getch:
00005EBA  2F02      17901          move.l    D2,-(A7)
                    17902   ; int c ;
                    17903   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17904   _getch_1:
00005EBC  1039 0040 17905          move.b    4194368,D0
00005EC0  0040      
00005EC2  C03C 0001 17906          and.b     #1,D0
00005EC6  0C00 0001 17907          cmp.b     #1,D0
00005ECA  6702      17908          beq.s     _getch_3
00005ECC  60EE      17909          bra       _getch_1
                    17910   _getch_3:
                    17911   ; ;
                    17912   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00005ECE  1039 0040 17913          move.b    4194370,D0
00005ED2  0042      
00005ED4  C0BC 0000 17914          and.l     #255,D0
00005ED8  00FF      
00005EDA  C0BC 0000 17915          and.l     #127,D0
00005EDE  007F      
00005EE0  2400      17916          move.l    D0,D2
                    17917   ; _putch(c);
00005EE2  2F02      17918          move.l    D2,-(A7)
00005EE4  4EB8 5E8E 17919          jsr       __putch
00005EE8  584F      17920          addq.w    #4,A7
                    17921   ; return c ;
00005EEA  2002      17922          move.l    D2,D0
00005EEC  241F      17923          move.l    (A7)+,D2
00005EEE  4E75      17924          rts
                    17925   ; }
                    17926   ; /************************************************************************************
                    17927   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17928   ; ************************************************************************************/
                    17929   ; void Wait1ms(void)
                    17930   ; {
                    17931   _Wait1ms:
00005EF0  2F02      17932          move.l    D2,-(A7)
                    17933   ; long int  i ;
                    17934   ; for(i = 0; i < 1000; i ++)
00005EF2  4282      17935          clr.l     D2
                    17936   Wait1ms_1:
00005EF4  0C82 0000 17937          cmp.l     #1000,D2
00005EF8  03E8      
00005EFA  6C04      17938          bge.s     Wait1ms_3
00005EFC  5282      17939          addq.l    #1,D2
00005EFE  60F4      17940          bra       Wait1ms_1
                    17941   Wait1ms_3:
00005F00  241F      17942          move.l    (A7)+,D2
00005F02  4E75      17943          rts
                    17944   ; ;
                    17945   ; }
                    17946   ; /************************************************************************************
                    17947   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17948   ; **************************************************************************************/
                    17949   ; void Wait3ms(void)
                    17950   ; {
                    17951   _Wait3ms:
00005F04  2F02      17952          move.l    D2,-(A7)
                    17953   ; int i ;
                    17954   ; for(i = 0; i < 3; i++)
00005F06  4282      17955          clr.l     D2
                    17956   Wait3ms_1:
00005F08  0C82 0000 17957          cmp.l     #3,D2
00005F0C  0003      
00005F0E  6C08      17958          bge.s     Wait3ms_3
                    17959   ; Wait1ms() ;
00005F10  4EB8 5EF0 17960          jsr       _Wait1ms
00005F14  5282      17961          addq.l    #1,D2
00005F16  60F0      17962          bra       Wait3ms_1
                    17963   Wait3ms_3:
00005F18  241F      17964          move.l    (A7)+,D2
00005F1A  4E75      17965          rts
                    17966   ; }
                    17967   ; /*********************************************************************************************
                    17968   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17969   ; *********************************************************************************************/
                    17970   ; void Init_LCD(void)
                    17971   ; {
                    17972   _Init_LCD:
                    17973   ; LCDcommand = (char)(0x0c) ;
00005F1C  13FC 000C 17974          move.b    #12,4194336
00005F20  0040 0020 
                    17975   ; Wait3ms() ;
00005F24  4EB8 5F04 17976          jsr       _Wait3ms
                    17977   ; LCDcommand = (char)(0x38) ;
00005F28  13FC 0038 17978          move.b    #56,4194336
00005F2C  0040 0020 
                    17979   ; Wait3ms() ;
00005F30  4EB8 5F04 17980          jsr       _Wait3ms
00005F34  4E75      17981          rts
                    17982   ; }
                    17983   ; /******************************************************************************
                    17984   ; *subroutine to output a single character held in d1 to the LCD display
                    17985   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17986   ; *current cursor position
                    17987   ; *******************************************************************************/
                    17988   ; void Outchar(int c)
                    17989   ; {
                    17990   _Outchar:
00005F36  4E56 0000 17991          link      A6,#0
                    17992   ; LCDdata = (char)(c);
00005F3A  202E 0008 17993          move.l    8(A6),D0
00005F3E  13C0 0040 17994          move.b    D0,4194338
00005F42  0022      
                    17995   ; Wait1ms() ;
00005F44  4EB8 5EF0 17996          jsr       _Wait1ms
00005F48  4E5E      17997          unlk      A6
00005F4A  4E75      17998          rts
                    17999   ; }
                    18000   ; /**********************************************************************************
                    18001   ; *subroutine to output a message at the current cursor position of the LCD display
                    18002   ; ************************************************************************************/
                    18003   ; void OutMess(char *theMessage)
                    18004   ; {
                    18005   _OutMess:
00005F4C  4E56 FFFC 18006          link      A6,#-4
                    18007   ; char c ;
                    18008   ; while((c = *theMessage++) != (char)(0))
                    18009   OutMess_1:
00005F50  206E 0008 18010          move.l    8(A6),A0
00005F54  52AE 0008 18011          addq.l    #1,8(A6)
00005F58  1D50 FFFF 18012          move.b    (A0),-1(A6)
00005F5C  1010      18013          move.b    (A0),D0
00005F5E  6712      18014          beq.s     OutMess_3
                    18015   ; Outchar(c) ;
00005F60  122E FFFF 18016          move.b    -1(A6),D1
00005F64  4881      18017          ext.w     D1
00005F66  48C1      18018          ext.l     D1
00005F68  2F01      18019          move.l    D1,-(A7)
00005F6A  4EB8 5F36 18020          jsr       _Outchar
00005F6E  584F      18021          addq.w    #4,A7
00005F70  60DE      18022          bra       OutMess_1
                    18023   OutMess_3:
00005F72  4E5E      18024          unlk      A6
00005F74  4E75      18025          rts
                    18026   ; }
                    18027   ; /******************************************************************************
                    18028   ; *subroutine to clear the line by issuing 24 space characters
                    18029   ; *******************************************************************************/
                    18030   ; void Clearln(void)
                    18031   ; {
                    18032   _Clearln:
00005F76  2F02      18033          move.l    D2,-(A7)
                    18034   ; unsigned char i ;
                    18035   ; for(i = 0; i < 24; i ++)
00005F78  4202      18036          clr.b     D2
                    18037   Clearln_1:
00005F7A  0C02 0018 18038          cmp.b     #24,D2
00005F7E  640E      18039          bhs.s     Clearln_3
                    18040   ; Outchar(' ') ;  /* write a space char to the LCD display */
00005F80  4878 0020 18041          pea       32
00005F84  4EB8 5F36 18042          jsr       _Outchar
00005F88  584F      18043          addq.w    #4,A7
00005F8A  5202      18044          addq.b    #1,D2
00005F8C  60EC      18045          bra       Clearln_1
                    18046   Clearln_3:
00005F8E  241F      18047          move.l    (A7)+,D2
00005F90  4E75      18048          rts
                    18049   ; }
                    18050   ; /******************************************************************************
                    18051   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    18052   ; *******************************************************************************/
                    18053   ; void Oline0(char *theMessage)
                    18054   ; {
                    18055   _Oline0:
00005F92  4E56 0000 18056          link      A6,#0
                    18057   ; LCDcommand = (char)(0x80) ;
00005F96  13FC 0080 18058          move.b    #128,4194336
00005F9A  0040 0020 
                    18059   ; Wait3ms();
00005F9E  4EB8 5F04 18060          jsr       _Wait3ms
                    18061   ; Clearln() ;
00005FA2  4EB8 5F76 18062          jsr       _Clearln
                    18063   ; LCDcommand = (char)(0x80) ;
00005FA6  13FC 0080 18064          move.b    #128,4194336
00005FAA  0040 0020 
                    18065   ; Wait3ms() ;
00005FAE  4EB8 5F04 18066          jsr       _Wait3ms
                    18067   ; OutMess(theMessage) ;
00005FB2  2F2E 0008 18068          move.l    8(A6),-(A7)
00005FB6  4EB8 5F4C 18069          jsr       _OutMess
00005FBA  584F      18070          addq.w    #4,A7
00005FBC  4E5E      18071          unlk      A6
00005FBE  4E75      18072          rts
                    18073   ; }
                    18074   ; /******************************************************************************
                    18075   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    18076   ; *******************************************************************************/
                    18077   ; void Oline1(char *theMessage)
                    18078   ; {
                    18079   _Oline1:
00005FC0  4E56 0000 18080          link      A6,#0
                    18081   ; LCDcommand = (char)(0xC0) ;
00005FC4  13FC 00C0 18082          move.b    #192,4194336
00005FC8  0040 0020 
                    18083   ; Wait3ms();
00005FCC  4EB8 5F04 18084          jsr       _Wait3ms
                    18085   ; Clearln() ;
00005FD0  4EB8 5F76 18086          jsr       _Clearln
                    18087   ; LCDcommand = (char)(0xC0) ;
00005FD4  13FC 00C0 18088          move.b    #192,4194336
00005FD8  0040 0020 
                    18089   ; Wait3ms() ;
00005FDC  4EB8 5F04 18090          jsr       _Wait3ms
                    18091   ; OutMess(theMessage) ;
00005FE0  2F2E 0008 18092          move.l    8(A6),-(A7)
00005FE4  4EB8 5F4C 18093          jsr       _OutMess
00005FE8  584F      18094          addq.w    #4,A7
00005FEA  4E5E      18095          unlk      A6
00005FEC  4E75      18096          rts
                    18097   ; }
                    18098   ; /*********************************************************************************
                    18099   ; ** Timer ISR
                    18100   ; **********************************************************************************/
                    18101   ; void Timer_ISR(void)
                    18102   ; {
                    18103   _Timer_ISR:
                    18104   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
00005FEE  1039 0040 18105          move.b    4194354,D0
00005FF2  0032      
00005FF4  0C00 0001 18106          cmp.b     #1,D0
00005FF8  6608      18107          bne.s     Timer_ISR_1
                    18108   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
00005FFA  13FC 0003 18109          move.b    #3,4194354
00005FFE  0040 0032 
                    18110   Timer_ISR_1:
00006002  4E75      18111          rts
                    18112   ; }
                    18113   ; }
                    18114   ; /**********************************************************************************
                    18115   ; ** Timer Initialisation Routine
                    18116   ; **********************************************************************************/
                    18117   ; void Timer1_Init(void)
                    18118   ; {
                    18119   _Timer1_Init:
                    18120   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
00006004  13FC 0003 18121          move.b    #3,4194352
00006008  0040 0030 
                    18122   ; /*
                    18123   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    18124   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    18125   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    18126   ; **
                    18127   ; **
                    18128   ; ** Now write binary 00000011 to timer control register:
                    18129   ; **	Bit0 = 1 (enable interrupt from that timer)
                    18130   ; **	Bit 1 = 1 enable counting
                    18131   ; */
                    18132   ; Timer1Control = 3;
0000600C  13FC 0003 18133          move.b    #3,4194354
00006010  0040 0032 
00006014  4E75      18134          rts
                    18135   ; }
                    18136   ; /*********************************************************************************************************************************
                    18137   ; **  IMPORTANT FUNCTION
                    18138   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    18139   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    18140   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    18141   ; **  Calling this function allows you to deal with Interrupts for example
                    18142   ; **
                    18143   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    18144   ; **
                    18145   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    18146   ; **
                    18147   ; **	see main below for other examples
                    18148   ; ***********************************************************************************************************************************/
                    18149   ; /*
                    18150   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    18151   ; {
                    18152   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    18153   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    18154   ; }
                    18155   ; */
                    18156   _printf:
00006016  4E56 FFFC 18157          link      A6,#-4
0000601A  2F02      18158          move.l    D2,-(A7)
0000601C  41EE 0008 18159          lea       8(A6),A0
00006020  5848      18160          addq.w    #4,A0
00006022  2408      18161          move.l    A0,D2
00006024  2F02      18162          move.l    D2,-(A7)
00006026  2F2E 0008 18163          move.l    8(A6),-(A7)
0000602A  42A7      18164          clr.l     -(A7)
0000602C  4EB9 0000 18165          jsr       _doprint
00006030  626A      
00006032  DEFC 000C 18166          add.w     #12,A7
00006036  2D40 FFFC 18167          move.l    D0,-4(A6)
0000603A  4282      18168          clr.l     D2
0000603C  202E FFFC 18169          move.l    -4(A6),D0
00006040  241F      18170          move.l    (A7)+,D2
00006042  4E5E      18171          unlk      A6
00006044  4E75      18172          rts
                    18173   ULMUL:
00006046  4E56 0000 18174          link    A6,#0
0000604A  48E7 C000 18175          movem.l D0/D1,-(A7)
0000604E  222E 0008 18176          move.l  8(A6),D1
00006052  202E 000C 18177          move.l  12(A6),D0
00006056  602C      18178          bra.s   lmul_3
                    18179   LMUL:
00006058  4E56 0000 18180          link    A6,#0
0000605C  48E7 C000 18181          movem.l D0/D1,-(A7)
00006060  222E 0008 18182          move.l  8(A6),D1
00006064  202E 000C 18183          move.l  12(A6),D0
00006068  4A80      18184          tst.l   D0
0000606A  6A0A      18185          bpl.s   lmul_1
0000606C  4480      18186          neg.l   D0
0000606E  4A81      18187          tst.l   D1
00006070  6A0A      18188          bpl.s   lmul_2
00006072  4481      18189          neg.l   D1
00006074  600E      18190          bra.s   lmul_3
                    18191   lmul_1:
00006076  4A81      18192          tst.l   D1
00006078  6A0A      18193          bpl.s   lmul_3
0000607A  4481      18194          neg.l   D1
                    18195   lmul_2:
0000607C  6114      18196          bsr.s   domul
0000607E  4481      18197          neg.l   D1
00006080  4080      18198          negx.l  D0
00006082  6002      18199          bra.s   lmul_4
                    18200   lmul_3:
00006084  610C      18201          bsr.s   domul
                    18202   lmul_4:
00006086  2D41 0008 18203          move.l  D1,8(A6)
0000608A  4CDF 0003 18204          movem.l (A7)+,D0/D1
0000608E  4E5E      18205          unlk    A6
00006090  4E75      18206          rts
                    18207   domul:
00006092  0C81 0000 18208          cmpi.l  #$FFFF,D1
00006096  FFFF      
00006098  620C      18209          bhi.s   domul_1
0000609A  0C80 0000 18210          cmpi.l  #$FFFF,D0
0000609E  FFFF      
000060A0  620E      18211          bhi.s   domul_2
000060A2  C2C0      18212          mulu    D0,D1
000060A4  4E75      18213          rts
                    18214   domul_1:
000060A6  0C80 0000 18215          cmpi.l  #$FFFF,D0
000060AA  FFFF      
000060AC  6218      18216          bhi.s   domul_4
000060AE  6002      18217          bra.s   domul_3
                    18218   domul_2
000060B0  C141      18219          exg     D0,D1
                    18220   domul_3:
000060B2  2F02      18221          move.l  D2,-(A7)
000060B4  2401      18222          move.l  D1,D2
000060B6  4842      18223          swap    D2
000060B8  C2C0      18224          mulu    D0,D1
000060BA  C4C0      18225          mulu    D0,D2
000060BC  4842      18226          swap    D2
000060BE  4242      18227          clr.w   D2
000060C0  D282      18228          add.l   D2,D1
000060C2  241F      18229          move.l  (A7)+,D2
000060C4  4E75      18230          rts
                    18231   domul_4:
000060C6  48E7 3000 18232          movem.l D2/D3,-(A7)
000060CA  2401      18233          move.l  D1,D2
000060CC  2601      18234          move.l  D1,D3
000060CE  C2C0      18235          mulu    D0,D1
000060D0  4842      18236          swap    D2
000060D2  C4C0      18237          mulu    D0,D2
000060D4  4840      18238          swap    D0
000060D6  C6C0      18239          mulu    D0,D3
000060D8  D483      18240          add.l   D3,D2
000060DA  4842      18241          swap    D2
000060DC  4242      18242          clr.w   D2
000060DE  D282      18243          add.l   D2,D1
000060E0  4CDF 000C 18244          movem.l (A7)+,D2/D3
000060E4  4E75      18245          rts
                    18246   ULDIV:
000060E6  4E56 0000 18247          link    A6,#0
000060EA  48E7 C000 18248          movem.l D0/D1,-(A7)
000060EE  222E 0008 18249          move.l  8(A6),D1
000060F2  202E 000C 18250          move.l  12(A6),D0
000060F6  6036      18251          bra.s   ldiv_3
                    18252   LDIV:
000060F8  4E56 0000 18253          link    A6,#0
000060FC  48E7 C000 18254          movem.l D0/D1,-(A7)
00006100  222E 0008 18255          move.l  8(A6),D1
00006104  202E 000C 18256          move.l  12(A6),D0
00006108  4A80      18257          tst.l   D0
0000610A  6A0E      18258          bpl.s   ldiv_1
0000610C  4480      18259          neg.l   D0
0000610E  4A81      18260          tst.l   D1
00006110  6A14      18261          bpl.s   ldiv_2
00006112  4481      18262          neg.l   D1
00006114  612A      18263          bsr.s   dodiv
00006116  4481      18264          neg.l   D1
00006118  6016      18265          bra.s   ldiv_4
                    18266   ldiv_1:
0000611A  4A81      18267          tst.l   D1
0000611C  6A10      18268          bpl.s   ldiv_3
0000611E  4481      18269          neg.l   D1
00006120  611E      18270          bsr.s   dodiv
00006122  4480      18271          neg.l   D0
00006124  600A      18272          bra.s   ldiv_4
                    18273   ldiv_2:
00006126  6118      18274          bsr.s   dodiv
00006128  4480      18275          neg.l   D0
0000612A  4481      18276          neg.l   D1
0000612C  6002      18277          bra.s   ldiv_4
                    18278   ldiv_3:
0000612E  6110      18279          bsr.s   dodiv
                    18280   ldiv_4:
00006130  2D40 0008 18281          move.l  D0,8(A6)
00006134  2D41 000C 18282          move.l  D1,12(A6)
00006138  4CDF 0003 18283          movem.l (A7)+,D0/D1
0000613C  4E5E      18284          unlk    A6
0000613E  4E75      18285          rts
                    18286   dodiv:
00006140  0C81 0000 18287          cmpi.l  #$FFFF,D1
00006144  FFFF      
00006146  6236      18288          bhi.s   dodiv_2
00006148  0C80 0000 18289          cmpi.l  #$FFFF,D0
0000614C  FFFF      
0000614E  6210      18290          bhi.s   dodiv_1
00006150  80C1      18291          divu    D1,D0
00006152  2200      18292          move.l  D0,D1
00006154  4241      18293          clr.w   D1
00006156  4841      18294          swap    D1
00006158  0280 0000 18295          andi.l  #$FFFF,D0
0000615C  FFFF      
0000615E  4E75      18296          rts
                    18297   dodiv_1:
00006160  48A7 A000 18298          movem.w D0/D2,-(A7)
00006164  4240      18299          clr.w   D0
00006166  4840      18300          swap    D0
00006168  80C1      18301          divu    D1,D0
0000616A  3400      18302          move.w  D0,D2
0000616C  301F      18303          move.w  (A7)+,D0
0000616E  80C1      18304          divu    D1,D0
00006170  4840      18305          swap    D0
00006172  4281      18306          clr.l   D1
00006174  3200      18307          move.w  D0,D1
00006176  3002      18308          move.w  D2,D0
00006178  4840      18309          swap    D0
0000617A  341F      18310          move.w  (A7)+,D2
0000617C  4E75      18311          rts
                    18312   dodiv_2:
0000617E  48E7 3800 18313          movem.l D2/D3/D4,-(A7)
00006182  2401      18314          move.l  D1,D2
00006184  4242      18315          clr.w   D2
00006186  4842      18316          swap    D2
00006188  5282      18317          addq.l  #1,D2
0000618A  2600      18318          move.l  D0,D3
0000618C  2801      18319          move.l  D1,D4
0000618E  2202      18320          move.l  D2,D1
00006190  61CE      18321          bsr.s   dodiv_1
00006192  2204      18322          move.l  D4,D1
00006194  82C2      18323          divu    D2,D1
00006196  80C1      18324          divu    D1,D0
00006198  0280 0000 18325          andi.l  #$FFFF,D0
0000619C  FFFF      
                    18326   dodiv_3:
0000619E  2204      18327          move.l  D4,D1
000061A0  2404      18328          move.l  D4,D2
000061A2  4842      18329          swap    D2
000061A4  C2C0      18330          mulu    D0,D1
000061A6  C4C0      18331          mulu    D0,D2
000061A8  4842      18332          swap    D2
000061AA  D282      18333          add.l   D2,D1
000061AC  9283      18334          sub.l   D3,D1
000061AE  620A      18335          bhi.s   dodiv_4
000061B0  4481      18336          neg.l   D1
000061B2  B881      18337          cmp.l   D1,D4
000061B4  6208      18338          bhi.s   dodiv_5
000061B6  5280      18339          addq.l  #1,D0
000061B8  60E4      18340          bra.s   dodiv_3
                    18341   dodiv_4:
000061BA  5380      18342          subq.l  #1,D0
000061BC  60E0      18343          bra.s   dodiv_3
                    18344   dodiv_5:
000061BE  4CDF 001C 18345          movem.l (A7)+,D2/D3/D4
000061C2  4E75      18346          rts
                    18347   @doprint_copy:
000061C4  4E56 0000 18348          link      A6,#0
000061C8  206E 0008 18349          move.l    8(A6),A0
000061CC  4A90      18350          tst.l     (A0)
000061CE  6710      18351          beq.s     @doprint_copy_1
000061D0  202E 000C 18352          move.l    12(A6),D0
000061D4  206E 0008 18353          move.l    8(A6),A0
000061D8  2250      18354          move.l    (A0),A1
000061DA  5290      18355          addq.l    #1,(A0)
000061DC  1280      18356          move.b    D0,(A1)
000061DE  600C      18357          bra.s     @doprint_copy_2
                    18358   @doprint_copy_1:
000061E0  2F2E 000C 18359          move.l    12(A6),-(A7)
000061E4  4EB9 0000 18360          jsr       _putch
000061E8  6A0A      
000061EA  584F      18361          addq.w    #4,A7
                    18362   @doprint_copy_2:
000061EC  4E5E      18363          unlk      A6
000061EE  4E75      18364          rts
                    18365   @doprint_getval:
000061F0  4E56 0000 18366          link      A6,#0
000061F4  48E7 3000 18367          movem.l   D2/D3,-(A7)
000061F8  262E 0008 18368          move.l    8(A6),D3
000061FC  4282      18369          clr.l     D2
000061FE  2043      18370          move.l    D3,A0
00006200  2050      18371          move.l    (A0),A0
00006202  1010      18372          move.b    (A0),D0
00006204  0C00 002A 18373          cmp.b     #42,D0
00006208  6612      18374          bne.s     @doprint_getval_1
0000620A  206E 000C 18375          move.l    12(A6),A0
0000620E  2250      18376          move.l    (A0),A1
00006210  5890      18377          addq.l    #4,(A0)
00006212  2411      18378          move.l    (A1),D2
00006214  2043      18379          move.l    D3,A0
00006216  5290      18380          addq.l    #1,(A0)
00006218  6000 0046 18381          bra       @doprint_getval_5
                    18382   @doprint_getval_1:
0000621C  7001      18383          moveq     #1,D0
0000621E  2043      18384          move.l    D3,A0
00006220  2050      18385          move.l    (A0),A0
00006222  1210      18386          move.b    (A0),D1
00006224  4881      18387          ext.w     D1
00006226  48C1      18388          ext.l     D1
00006228  D081      18389          add.l     D1,D0
0000622A  41F9 0000 18390          lea       __ctype.L,A0
0000622E  6C2E      
00006230  1030 0800 18391          move.b    0(A0,D0.L),D0
00006234  C03C 0004 18392          and.b     #4,D0
00006238  6726      18393          beq.s     @doprint_getval_5
0000623A  2F02      18394          move.l    D2,-(A7)
0000623C  4878 000A 18395          pea       10
00006240  4EB8 6058 18396          jsr       LMUL
00006244  2017      18397          move.l    (A7),D0
00006246  504F      18398          addq.w    #8,A7
00006248  2043      18399          move.l    D3,A0
0000624A  2250      18400          move.l    (A0),A1
0000624C  5290      18401          addq.l    #1,(A0)
0000624E  1211      18402          move.b    (A1),D1
00006250  4881      18403          ext.w     D1
00006252  48C1      18404          ext.l     D1
00006254  D081      18405          add.l     D1,D0
00006256  0480 0000 18406          sub.l     #48,D0
0000625A  0030      
0000625C  2400      18407          move.l    D0,D2
0000625E  60BC      18408          bra       @doprint_getval_1
                    18409   @doprint_getval_5:
00006260  2002      18410          move.l    D2,D0
00006262  4CDF 000C 18411          movem.l   (A7)+,D2/D3
00006266  4E5E      18412          unlk      A6
00006268  4E75      18413          rts
                    18414   _doprint:
0000626A  4E56 FFCC 18415          link      A6,#-52
0000626E  48E7 3F3C 18416          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00006272  45EE 0008 18417          lea       8(A6),A2
00006276  47F8 61C4 18418          lea       @doprint_copy.L,A3
0000627A  49F9 0000 18419          lea       _ultoa.L,A4
0000627E  6996      
00006280  4286      18420          clr.l     D6
                    18421   doprint_1:
00006282  206E 000C 18422          move.l    12(A6),A0
00006286  4A10      18423          tst.b     (A0)
00006288  6700 05EC 18424          beq       doprint_3
0000628C  206E 000C 18425          move.l    12(A6),A0
00006290  1010      18426          move.b    (A0),D0
00006292  0C00 0025 18427          cmp.b     #37,D0
00006296  671C      18428          beq.s     doprint_4
00006298  206E 000C 18429          move.l    12(A6),A0
0000629C  52AE 000C 18430          addq.l    #1,12(A6)
000062A0  1210      18431          move.b    (A0),D1
000062A2  4881      18432          ext.w     D1
000062A4  48C1      18433          ext.l     D1
000062A6  2F01      18434          move.l    D1,-(A7)
000062A8  2F0A      18435          move.l    A2,-(A7)
000062AA  4E93      18436          jsr       (A3)
000062AC  504F      18437          addq.w    #8,A7
000062AE  5286      18438          addq.l    #1,D6
000062B0  6000 05C0 18439          bra       doprint_2
                    18440   doprint_4:
000062B4  52AE 000C 18441          addq.l    #1,12(A6)
000062B8  422E FFD3 18442          clr.b     -45(A6)
000062BC  422E FFD2 18443          clr.b     -46(A6)
000062C0  422E FFD0 18444          clr.b     -48(A6)
000062C4  422E FFCF 18445          clr.b     -49(A6)
000062C8  422E FFCE 18446          clr.b     -50(A6)
000062CC  422E FFCD 18447          clr.b     -51(A6)
000062D0  42AE FFFC 18448          clr.l     -4(A6)
000062D4  7AFF      18449          moveq     #-1,D5
000062D6  41EE FFDC 18450          lea       -36(A6),A0
000062DA  2608      18451          move.l    A0,D3
000062DC  2408      18452          move.l    A0,D2
                    18453   doprint_6:
000062DE  206E 000C 18454          move.l    12(A6),A0
000062E2  1010      18455          move.b    (A0),D0
000062E4  4880      18456          ext.w     D0
000062E6  48C0      18457          ext.l     D0
000062E8  0C80 0000 18458          cmp.l     #43,D0
000062EC  002B      
000062EE  6730      18459          beq.s     doprint_12
000062F0  6E18      18460          bgt.s     doprint_15
000062F2  0C80 0000 18461          cmp.l     #35,D0
000062F6  0023      
000062F8  6700 003E 18462          beq       doprint_14
000062FC  6E00 0046 18463          bgt       doprint_9
00006300  0C80 0000 18464          cmp.l     #32,D0
00006304  0020      
00006306  6724      18465          beq.s     doprint_13
00006308  603A      18466          bra.s     doprint_9
                    18467   doprint_15:
0000630A  0C80 0000 18468          cmp.l     #45,D0
0000630E  002D      
00006310  6702      18469          beq.s     doprint_11
00006312  6030      18470          bra.s     doprint_9
                    18471   doprint_11:
00006314  1D7C 0001 18472          move.b    #1,-51(A6)
00006318  FFCD      
0000631A  52AE 000C 18473          addq.l    #1,12(A6)
0000631E  6026      18474          bra.s     doprint_7
                    18475   doprint_12:
00006320  1D7C 0001 18476          move.b    #1,-50(A6)
00006324  FFCE      
00006326  52AE 000C 18477          addq.l    #1,12(A6)
0000632A  601A      18478          bra.s     doprint_7
                    18479   doprint_13:
0000632C  1D7C 0001 18480          move.b    #1,-49(A6)
00006330  FFCF      
00006332  52AE 000C 18481          addq.l    #1,12(A6)
00006336  600E      18482          bra.s     doprint_7
                    18483   doprint_14:
00006338  1D7C 0001 18484          move.b    #1,-48(A6)
0000633C  FFD0      
0000633E  52AE 000C 18485          addq.l    #1,12(A6)
00006342  6002      18486          bra.s     doprint_7
                    18487   doprint_9:
00006344  6002      18488          bra.s     doprint_8
                    18489   doprint_7:
00006346  6096      18490          bra       doprint_6
                    18491   doprint_8:
00006348  206E 000C 18492          move.l    12(A6),A0
0000634C  1010      18493          move.b    (A0),D0
0000634E  0C00 0030 18494          cmp.b     #48,D0
00006352  660A      18495          bne.s     doprint_16
00006354  52AE 000C 18496          addq.l    #1,12(A6)
00006358  1D7C 0001 18497          move.b    #1,-46(A6)
0000635C  FFD2      
                    18498   doprint_16:
0000635E  486E 0010 18499          pea       16(A6)
00006362  486E 000C 18500          pea       12(A6)
00006366  4EB8 61F0 18501          jsr       @doprint_getval
0000636A  504F      18502          addq.w    #8,A7
0000636C  2A40      18503          move.l    D0,A5
0000636E  206E 000C 18504          move.l    12(A6),A0
00006372  1010      18505          move.b    (A0),D0
00006374  0C00 002E 18506          cmp.b     #46,D0
00006378  6614      18507          bne.s     doprint_18
0000637A  52AE 000C 18508          addq.l    #1,12(A6)
0000637E  486E 0010 18509          pea       16(A6)
00006382  486E 000C 18510          pea       12(A6)
00006386  4EB8 61F0 18511          jsr       @doprint_getval
0000638A  504F      18512          addq.w    #8,A7
0000638C  2A00      18513          move.l    D0,D5
                    18514   doprint_18:
0000638E  206E 000C 18515          move.l    12(A6),A0
00006392  1010      18516          move.b    (A0),D0
00006394  0C00 006C 18517          cmp.b     #108,D0
00006398  660A      18518          bne.s     doprint_20
0000639A  52AE 000C 18519          addq.l    #1,12(A6)
0000639E  1D7C 0001 18520          move.b    #1,-45(A6)
000063A2  FFD3      
                    18521   doprint_20:
000063A4  206E 000C 18522          move.l    12(A6),A0
000063A8  1010      18523          move.b    (A0),D0
000063AA  4880      18524          ext.w     D0
000063AC  48C0      18525          ext.l     D0
000063AE  0C80 0000 18526          cmp.l     #111,D0
000063B2  006F      
000063B4  6700 00D8 18527          beq       doprint_27
000063B8  6E34      18528          bgt.s     doprint_33
000063BA  0C80 0000 18529          cmp.l     #100,D0
000063BE  0064      
000063C0  6700 0054 18530          beq       doprint_24
000063C4  6E1C      18531          bgt.s     doprint_34
000063C6  0C80 0000 18532          cmp.l     #99,D0
000063CA  0063      
000063CC  6700 0130 18533          beq       doprint_30
000063D0  6E00 0174 18534          bgt       doprint_22
000063D4  0C80 0000 18535          cmp.l     #88,D0
000063D8  0058      
000063DA  6700 00EA 18536          beq       doprint_28
000063DE  6000 0166 18537          bra       doprint_22
                    18538   doprint_34:
000063E2  0C80 0000 18539          cmp.l     #105,D0
000063E6  0069      
000063E8  672C      18540          beq.s     doprint_24
000063EA  6000 015A 18541          bra       doprint_22
                    18542   doprint_33:
000063EE  0C80 0000 18543          cmp.l     #117,D0
000063F2  0075      
000063F4  6700 0060 18544          beq       doprint_26
000063F8  6E0E      18545          bgt.s     doprint_35
000063FA  0C80 0000 18546          cmp.l     #115,D0
000063FE  0073      
00006400  6700 0124 18547          beq       doprint_31
00006404  6000 0140 18548          bra       doprint_22
                    18549   doprint_35:
00006408  0C80 0000 18550          cmp.l     #120,D0
0000640C  0078      
0000640E  6700 00B6 18551          beq       doprint_28
00006412  6000 0132 18552          bra       doprint_22
                    18553   doprint_24:
00006416  4A2E FFD3 18554          tst.b     -45(A6)
0000641A  671C      18555          beq.s     doprint_36
0000641C  4878 000A 18556          pea       10
00006420  2F03      18557          move.l    D3,-(A7)
00006422  206E 0010 18558          move.l    16(A6),A0
00006426  58AE 0010 18559          addq.l    #4,16(A6)
0000642A  2F10      18560          move.l    (A0),-(A7)
0000642C  4EB9 0000 18561          jsr       _ltoa
00006430  6910      
00006432  DEFC 000C 18562          add.w     #12,A7
00006436  601A      18563          bra.s     doprint_37
                    18564   doprint_36:
00006438  4878 000A 18565          pea       10
0000643C  2F03      18566          move.l    D3,-(A7)
0000643E  206E 0010 18567          move.l    16(A6),A0
00006442  58AE 0010 18568          addq.l    #4,16(A6)
00006446  2F10      18569          move.l    (A0),-(A7)
00006448  4EB9 0000 18570          jsr       _ltoa
0000644C  6910      
0000644E  DEFC 000C 18571          add.w     #12,A7
                    18572   doprint_37:
00006452  6000 0100 18573          bra       doprint_23
                    18574   doprint_26:
00006456  4A2E FFD3 18575          tst.b     -45(A6)
0000645A  6718      18576          beq.s     doprint_38
0000645C  4878 000A 18577          pea       10
00006460  2F03      18578          move.l    D3,-(A7)
00006462  206E 0010 18579          move.l    16(A6),A0
00006466  58AE 0010 18580          addq.l    #4,16(A6)
0000646A  2F10      18581          move.l    (A0),-(A7)
0000646C  4E94      18582          jsr       (A4)
0000646E  DEFC 000C 18583          add.w     #12,A7
00006472  6016      18584          bra.s     doprint_39
                    18585   doprint_38:
00006474  4878 000A 18586          pea       10
00006478  2F03      18587          move.l    D3,-(A7)
0000647A  206E 0010 18588          move.l    16(A6),A0
0000647E  58AE 0010 18589          addq.l    #4,16(A6)
00006482  2F10      18590          move.l    (A0),-(A7)
00006484  4E94      18591          jsr       (A4)
00006486  DEFC 000C 18592          add.w     #12,A7
                    18593   doprint_39:
0000648A  6000 00C8 18594          bra       doprint_23
                    18595   doprint_27:
0000648E  4A2E FFD3 18596          tst.b     -45(A6)
00006492  6718      18597          beq.s     doprint_40
00006494  4878 0008 18598          pea       8
00006498  2F03      18599          move.l    D3,-(A7)
0000649A  206E 0010 18600          move.l    16(A6),A0
0000649E  58AE 0010 18601          addq.l    #4,16(A6)
000064A2  2F10      18602          move.l    (A0),-(A7)
000064A4  4E94      18603          jsr       (A4)
000064A6  DEFC 000C 18604          add.w     #12,A7
000064AA  6016      18605          bra.s     doprint_41
                    18606   doprint_40:
000064AC  4878 0008 18607          pea       8
000064B0  2F03      18608          move.l    D3,-(A7)
000064B2  206E 0010 18609          move.l    16(A6),A0
000064B6  58AE 0010 18610          addq.l    #4,16(A6)
000064BA  2F10      18611          move.l    (A0),-(A7)
000064BC  4E94      18612          jsr       (A4)
000064BE  DEFC 000C 18613          add.w     #12,A7
                    18614   doprint_41:
000064C2  6000 0090 18615          bra       doprint_23
                    18616   doprint_28:
000064C6  4A2E FFD3 18617          tst.b     -45(A6)
000064CA  6718      18618          beq.s     doprint_42
000064CC  4878 0010 18619          pea       16
000064D0  2F03      18620          move.l    D3,-(A7)
000064D2  206E 0010 18621          move.l    16(A6),A0
000064D6  58AE 0010 18622          addq.l    #4,16(A6)
000064DA  2F10      18623          move.l    (A0),-(A7)
000064DC  4E94      18624          jsr       (A4)
000064DE  DEFC 000C 18625          add.w     #12,A7
000064E2  6016      18626          bra.s     doprint_43
                    18627   doprint_42:
000064E4  4878 0010 18628          pea       16
000064E8  2F03      18629          move.l    D3,-(A7)
000064EA  206E 0010 18630          move.l    16(A6),A0
000064EE  58AE 0010 18631          addq.l    #4,16(A6)
000064F2  2F10      18632          move.l    (A0),-(A7)
000064F4  4E94      18633          jsr       (A4)
000064F6  DEFC 000C 18634          add.w     #12,A7
                    18635   doprint_43:
000064FA  6000 0058 18636          bra       doprint_23
                    18637   doprint_30:
000064FE  206E 0010 18638          move.l    16(A6),A0
00006502  58AE 0010 18639          addq.l    #4,16(A6)
00006506  2010      18640          move.l    (A0),D0
00006508  2042      18641          move.l    D2,A0
0000650A  5282      18642          addq.l    #1,D2
0000650C  1080      18643          move.b    D0,(A0)
0000650E  2042      18644          move.l    D2,A0
00006510  4210      18645          clr.b     (A0)
00006512  200D      18646          move.l    A5,D0
00006514  6704      18647          beq.s     doprint_44
00006516  200D      18648          move.l    A5,D0
00006518  6006      18649          bra.s     doprint_45
                    18650   doprint_44:
0000651A  7001      18651          moveq     #1,D0
0000651C  4880      18652          ext.w     D0
0000651E  48C0      18653          ext.l     D0
                    18654   doprint_45:
00006520  2A00      18655          move.l    D0,D5
00006522  6000 0030 18656          bra       doprint_23
                    18657   doprint_31:
00006526  206E 0010 18658          move.l    16(A6),A0
0000652A  58AE 0010 18659          addq.l    #4,16(A6)
0000652E  2610      18660          move.l    (A0),D3
00006530  0C85 FFFF 18661          cmp.l     #-1,D5
00006534  FFFF      
00006536  660C      18662          bne.s     doprint_46
00006538  2F03      18663          move.l    D3,-(A7)
0000653A  4EB9 0000 18664          jsr       _strlen
0000653E  69F8      
00006540  584F      18665          addq.w    #4,A7
00006542  2A00      18666          move.l    D0,D5
                    18667   doprint_46:
00006544  600E      18668          bra.s     doprint_23
                    18669   doprint_22:
00006546  206E 000C 18670          move.l    12(A6),A0
0000654A  2242      18671          move.l    D2,A1
0000654C  5282      18672          addq.l    #1,D2
0000654E  1290      18673          move.b    (A0),(A1)
00006550  2042      18674          move.l    D2,A0
00006552  4210      18675          clr.b     (A0)
                    18676   doprint_23:
00006554  2F03      18677          move.l    D3,-(A7)
00006556  4EB9 0000 18678          jsr       _strlen
0000655A  69F8      
0000655C  584F      18679          addq.w    #4,A7
0000655E  1800      18680          move.b    D0,D4
00006560  206E 000C 18681          move.l    12(A6),A0
00006564  1010      18682          move.b    (A0),D0
00006566  0C00 0073 18683          cmp.b     #115,D0
0000656A  661C      18684          bne.s     doprint_48
0000656C  0C85 0000 18685          cmp.l     #0,D5
00006570  0000      
00006572  6D14      18686          blt.s     doprint_48
00006574  4884      18687          ext.w     D4
00006576  48C4      18688          ext.l     D4
00006578  B885      18689          cmp.l     D5,D4
0000657A  6F04      18690          ble.s     doprint_50
0000657C  2005      18691          move.l    D5,D0
0000657E  6006      18692          bra.s     doprint_51
                    18693   doprint_50:
00006580  1004      18694          move.b    D4,D0
00006582  4880      18695          ext.w     D0
00006584  48C0      18696          ext.l     D0
                    18697   doprint_51:
00006586  1800      18698          move.b    D0,D4
                    18699   doprint_48:
00006588  206E 000C 18700          move.l    12(A6),A0
0000658C  1010      18701          move.b    (A0),D0
0000658E  0C00 0058 18702          cmp.b     #88,D0
00006592  6600 0028 18703          bne       doprint_56
00006596  41EE FFDC 18704          lea       -36(A6),A0
0000659A  2408      18705          move.l    A0,D2
                    18706   doprint_54:
0000659C  2042      18707          move.l    D2,A0
0000659E  4A10      18708          tst.b     (A0)
000065A0  671A      18709          beq.s     doprint_56
000065A2  2042      18710          move.l    D2,A0
000065A4  1210      18711          move.b    (A0),D1
000065A6  4881      18712          ext.w     D1
000065A8  48C1      18713          ext.l     D1
000065AA  2F01      18714          move.l    D1,-(A7)
000065AC  4EB9 0000 18715          jsr       _toupper
000065B0  6A36      
000065B2  584F      18716          addq.w    #4,A7
000065B4  2042      18717          move.l    D2,A0
000065B6  1080      18718          move.b    D0,(A0)
000065B8  5282      18719          addq.l    #1,D2
000065BA  60E0      18720          bra       doprint_54
                    18721   doprint_56:
000065BC  7E00      18722          moveq     #0,D7
000065BE  41EE FFD4 18723          lea       -44(A6),A0
000065C2  2408      18724          move.l    A0,D2
000065C4  206E 000C 18725          move.l    12(A6),A0
000065C8  1010      18726          move.b    (A0),D0
000065CA  0C00 0064 18727          cmp.b     #100,D0
000065CE  670E      18728          beq.s     doprint_59
000065D0  206E 000C 18729          move.l    12(A6),A0
000065D4  1010      18730          move.b    (A0),D0
000065D6  0C00 0069 18731          cmp.b     #105,D0
000065DA  6600 0068 18732          bne       doprint_65
                    18733   doprint_59:
000065DE  102E FFCE 18734          move.b    -50(A6),D0
000065E2  4880      18735          ext.w     D0
000065E4  48C0      18736          ext.l     D0
000065E6  4A80      18737          tst.l     D0
000065E8  660C      18738          bne.s     doprint_62
000065EA  2043      18739          move.l    D3,A0
000065EC  1010      18740          move.b    (A0),D0
000065EE  0C00 002D 18741          cmp.b     #45,D0
000065F2  6600 0028 18742          bne       doprint_60
                    18743   doprint_62:
000065F6  2043      18744          move.l    D3,A0
000065F8  1010      18745          move.b    (A0),D0
000065FA  0C00 002D 18746          cmp.b     #45,D0
000065FE  660E      18747          bne.s     doprint_63
00006600  2043      18748          move.l    D3,A0
00006602  5283      18749          addq.l    #1,D3
00006604  2242      18750          move.l    D2,A1
00006606  5282      18751          addq.l    #1,D2
00006608  1290      18752          move.b    (A0),(A1)
0000660A  5304      18753          subq.b    #1,D4
0000660C  6008      18754          bra.s     doprint_64
                    18755   doprint_63:
0000660E  2042      18756          move.l    D2,A0
00006610  5282      18757          addq.l    #1,D2
00006612  10BC 002B 18758          move.b    #43,(A0)
                    18759   doprint_64:
00006616  5287      18760          addq.l    #1,D7
00006618  6000 002A 18761          bra       doprint_65
                    18762   doprint_60:
0000661C  4A2E FFCF 18763          tst.b     -49(A6)
00006620  6722      18764          beq.s     doprint_65
00006622  2043      18765          move.l    D3,A0
00006624  1010      18766          move.b    (A0),D0
00006626  0C00 002D 18767          cmp.b     #45,D0
0000662A  660E      18768          bne.s     doprint_67
0000662C  2043      18769          move.l    D3,A0
0000662E  5283      18770          addq.l    #1,D3
00006630  2242      18771          move.l    D2,A1
00006632  5282      18772          addq.l    #1,D2
00006634  1290      18773          move.b    (A0),(A1)
00006636  5304      18774          subq.b    #1,D4
00006638  6008      18775          bra.s     doprint_68
                    18776   doprint_67:
0000663A  2042      18777          move.l    D2,A0
0000663C  5282      18778          addq.l    #1,D2
0000663E  10BC 0020 18779          move.b    #32,(A0)
                    18780   doprint_68:
00006642  5287      18781          addq.l    #1,D7
                    18782   doprint_65:
00006644  4A2E FFD0 18783          tst.b     -48(A6)
00006648  6700 005A 18784          beq       doprint_77
0000664C  206E 000C 18785          move.l    12(A6),A0
00006650  1010      18786          move.b    (A0),D0
00006652  4880      18787          ext.w     D0
00006654  48C0      18788          ext.l     D0
00006656  0C80 0000 18789          cmp.l     #111,D0
0000665A  006F      
0000665C  671A      18790          beq.s     doprint_73
0000665E  6E0C      18791          bgt.s     doprint_76
00006660  0C80 0000 18792          cmp.l     #88,D0
00006664  0058      
00006666  6710      18793          beq.s     doprint_73
00006668  6000 003A 18794          bra       doprint_77
                    18795   doprint_76:
0000666C  0C80 0000 18796          cmp.l     #120,D0
00006670  0078      
00006672  6704      18797          beq.s     doprint_73
00006674  6000 002E 18798          bra       doprint_77
                    18799   doprint_73:
00006678  2042      18800          move.l    D2,A0
0000667A  5282      18801          addq.l    #1,D2
0000667C  10BC 0030 18802          move.b    #48,(A0)
00006680  5287      18803          addq.l    #1,D7
00006682  206E 000C 18804          move.l    12(A6),A0
00006686  1010      18805          move.b    (A0),D0
00006688  0C00 0078 18806          cmp.b     #120,D0
0000668C  670C      18807          beq.s     doprint_79
0000668E  206E 000C 18808          move.l    12(A6),A0
00006692  1010      18809          move.b    (A0),D0
00006694  0C00 0058 18810          cmp.b     #88,D0
00006698  660A      18811          bne.s     doprint_77
                    18812   doprint_79:
0000669A  2042      18813          move.l    D2,A0
0000669C  5282      18814          addq.l    #1,D2
0000669E  10BC 0078 18815          move.b    #120,(A0)
000066A2  5287      18816          addq.l    #1,D7
                    18817   doprint_77:
000066A4  2042      18818          move.l    D2,A0
000066A6  4210      18819          clr.b     (A0)
000066A8  206E 000C 18820          move.l    12(A6),A0
000066AC  1010      18821          move.b    (A0),D0
000066AE  4880      18822          ext.w     D0
000066B0  48C0      18823          ext.l     D0
000066B2  0C80 0000 18824          cmp.l     #105,D0
000066B6  0069      
000066B8  6700 0076 18825          beq       doprint_82
000066BC  6E42      18826          bgt.s     doprint_93
000066BE  0C80 0000 18827          cmp.l     #99,D0
000066C2  0063      
000066C4  6700 0084 18828          beq       doprint_96
000066C8  6E1C      18829          bgt.s     doprint_94
000066CA  0C80 0000 18830          cmp.l     #88,D0
000066CE  0058      
000066D0  6700 005E 18831          beq       doprint_82
000066D4  6E00 0184 18832          bgt       doprint_80
000066D8  0C80 0000 18833          cmp.l     #69,D0
000066DC  0045      
000066DE  6700 0050 18834          beq       doprint_82
000066E2  6000 0176 18835          bra       doprint_80
                    18836   doprint_94:
000066E6  0C80 0000 18837          cmp.l     #101,D0
000066EA  0065      
000066EC  6700 0042 18838          beq       doprint_82
000066F0  6E00 0168 18839          bgt       doprint_80
000066F4  0C80 0000 18840          cmp.l     #100,D0
000066F8  0064      
000066FA  6734      18841          beq.s     doprint_82
000066FC  6000 015C 18842          bra       doprint_80
                    18843   doprint_93:
00006700  0C80 0000 18844          cmp.l     #117,D0
00006704  0075      
00006706  6728      18845          beq.s     doprint_82
00006708  6E1A      18846          bgt.s     doprint_95
0000670A  0C80 0000 18847          cmp.l     #115,D0
0000670E  0073      
00006710  6700 0038 18848          beq       doprint_96
00006714  6E00 0144 18849          bgt       doprint_80
00006718  0C80 0000 18850          cmp.l     #111,D0
0000671C  006F      
0000671E  6710      18851          beq.s     doprint_82
00006720  6000 0138 18852          bra       doprint_80
                    18853   doprint_95:
00006724  0C80 0000 18854          cmp.l     #120,D0
00006728  0078      
0000672A  6704      18855          beq.s     doprint_82
0000672C  6000 012C 18856          bra       doprint_80
                    18857   doprint_82:
00006730  4A2E FFD2 18858          tst.b     -46(A6)
00006734  6714      18859          beq.s     doprint_96
00006736  4A2E FFCD 18860          tst.b     -51(A6)
0000673A  660E      18861          bne.s     doprint_96
0000673C  200D      18862          move.l    A5,D0
0000673E  9087      18863          sub.l     D7,D0
00006740  4884      18864          ext.w     D4
00006742  48C4      18865          ext.l     D4
00006744  9084      18866          sub.l     D4,D0
00006746  2D40 FFFC 18867          move.l    D0,-4(A6)
                    18868   doprint_96:
0000674A  202E FFFC 18869          move.l    -4(A6),D0
0000674E  0C80 0000 18870          cmp.l     #0,D0
00006752  0000      
00006754  6C04      18871          bge.s     doprint_98
00006756  42AE FFFC 18872          clr.l     -4(A6)
                    18873   doprint_98:
0000675A  4A2E FFCD 18874          tst.b     -51(A6)
0000675E  6600 0030 18875          bne       doprint_104
00006762  1004      18876          move.b    D4,D0
00006764  4880      18877          ext.w     D0
00006766  48C0      18878          ext.l     D0
00006768  D0AE FFFC 18879          add.l     -4(A6),D0
0000676C  D087      18880          add.l     D7,D0
0000676E  1D40 FFD1 18881          move.b    D0,-47(A6)
                    18882   doprint_102:
00006772  102E FFD1 18883          move.b    -47(A6),D0
00006776  4880      18884          ext.w     D0
00006778  48C0      18885          ext.l     D0
0000677A  220D      18886          move.l    A5,D1
0000677C  534D      18887          subq.w    #1,A5
0000677E  B081      18888          cmp.l     D1,D0
00006780  6C0E      18889          bge.s     doprint_104
00006782  4878 0020 18890          pea       32
00006786  2F0A      18891          move.l    A2,-(A7)
00006788  4E93      18892          jsr       (A3)
0000678A  504F      18893          addq.w    #8,A7
0000678C  5286      18894          addq.l    #1,D6
0000678E  60E2      18895          bra       doprint_102
                    18896   doprint_104:
00006790  41EE FFD4 18897          lea       -44(A6),A0
00006794  2408      18898          move.l    A0,D2
                    18899   doprint_105:
00006796  2042      18900          move.l    D2,A0
00006798  4A10      18901          tst.b     (A0)
0000679A  6716      18902          beq.s     doprint_107
0000679C  2042      18903          move.l    D2,A0
0000679E  5282      18904          addq.l    #1,D2
000067A0  1210      18905          move.b    (A0),D1
000067A2  4881      18906          ext.w     D1
000067A4  48C1      18907          ext.l     D1
000067A6  2F01      18908          move.l    D1,-(A7)
000067A8  2F0A      18909          move.l    A2,-(A7)
000067AA  4E93      18910          jsr       (A3)
000067AC  504F      18911          addq.w    #8,A7
000067AE  5286      18912          addq.l    #1,D6
000067B0  60E4      18913          bra       doprint_105
                    18914   doprint_107:
000067B2  202E FFFC 18915          move.l    -4(A6),D0
000067B6  1D40 FFD1 18916          move.b    D0,-47(A6)
                    18917   doprint_108:
000067BA  102E FFD1 18918          move.b    -47(A6),D0
000067BE  532E FFD1 18919          subq.b    #1,-47(A6)
000067C2  4A00      18920          tst.b     D0
000067C4  670E      18921          beq.s     doprint_110
000067C6  4878 0030 18922          pea       48
000067CA  2F0A      18923          move.l    A2,-(A7)
000067CC  4E93      18924          jsr       (A3)
000067CE  504F      18925          addq.w    #8,A7
000067D0  5286      18926          addq.l    #1,D6
000067D2  60E6      18927          bra       doprint_108
                    18928   doprint_110:
000067D4  2043      18929          move.l    D3,A0
000067D6  4A10      18930          tst.b     (A0)
000067D8  6700 0048 18931          beq       doprint_113
000067DC  206E 000C 18932          move.l    12(A6),A0
000067E0  1010      18933          move.b    (A0),D0
000067E2  4880      18934          ext.w     D0
000067E4  48C0      18935          ext.l     D0
000067E6  0C80 0000 18936          cmp.l     #115,D0
000067EA  0073      
000067EC  670C      18937          beq.s     doprint_116
000067EE  6E18      18938          bgt.s     doprint_119
000067F0  0C80 0000 18939          cmp.l     #99,D0
000067F4  0063      
000067F6  6702      18940          beq.s     doprint_116
000067F8  600E      18941          bra.s     doprint_119
                    18942   doprint_116:
000067FA  2005      18943          move.l    D5,D0
000067FC  5385      18944          subq.l    #1,D5
000067FE  0C80 0000 18945          cmp.l     #0,D0
00006802  0000      
00006804  6E02      18946          bgt.s     doprint_119
00006806  6016      18947          bra.s     doprint_115
                    18948   doprint_119:
00006808  2043      18949          move.l    D3,A0
0000680A  5283      18950          addq.l    #1,D3
0000680C  1210      18951          move.b    (A0),D1
0000680E  4881      18952          ext.w     D1
00006810  48C1      18953          ext.l     D1
00006812  2F01      18954          move.l    D1,-(A7)
00006814  2F0A      18955          move.l    A2,-(A7)
00006816  4E93      18956          jsr       (A3)
00006818  504F      18957          addq.w    #8,A7
0000681A  5286      18958          addq.l    #1,D6
0000681C  6002      18959          bra.s     doprint_112
                    18960   doprint_115:
0000681E  6002      18961          bra.s     doprint_113
                    18962   doprint_112:
00006820  60B2      18963          bra       doprint_110
                    18964   doprint_113:
00006822  4A2E FFCD 18965          tst.b     -51(A6)
00006826  6700 0030 18966          beq       doprint_125
0000682A  1004      18967          move.b    D4,D0
0000682C  4880      18968          ext.w     D0
0000682E  48C0      18969          ext.l     D0
00006830  D0AE FFFC 18970          add.l     -4(A6),D0
00006834  D087      18971          add.l     D7,D0
00006836  1D40 FFD1 18972          move.b    D0,-47(A6)
                    18973   doprint_123:
0000683A  102E FFD1 18974          move.b    -47(A6),D0
0000683E  4880      18975          ext.w     D0
00006840  48C0      18976          ext.l     D0
00006842  220D      18977          move.l    A5,D1
00006844  534D      18978          subq.w    #1,A5
00006846  B081      18979          cmp.l     D1,D0
00006848  6C0E      18980          bge.s     doprint_125
0000684A  4878 0020 18981          pea       32
0000684E  2F0A      18982          move.l    A2,-(A7)
00006850  4E93      18983          jsr       (A3)
00006852  504F      18984          addq.w    #8,A7
00006854  5386      18985          subq.l    #1,D6
00006856  60E2      18986          bra       doprint_123
                    18987   doprint_125:
00006858  6014      18988          bra.s     doprint_81
                    18989   doprint_80:
0000685A  206E 000C 18990          move.l    12(A6),A0
0000685E  1210      18991          move.b    (A0),D1
00006860  4881      18992          ext.w     D1
00006862  48C1      18993          ext.l     D1
00006864  2F01      18994          move.l    D1,-(A7)
00006866  2F0A      18995          move.l    A2,-(A7)
00006868  4E93      18996          jsr       (A3)
0000686A  504F      18997          addq.w    #8,A7
0000686C  5286      18998          addq.l    #1,D6
                    18999   doprint_81:
0000686E  52AE 000C 19000          addq.l    #1,12(A6)
                    19001   doprint_2:
00006872  6000 FA0E 19002          bra       doprint_1
                    19003   doprint_3:
00006876  4A92      19004          tst.l     (A2)
00006878  6710      19005          beq.s     doprint_126
0000687A  4201      19006          clr.b     D1
0000687C  C2BC 0000 19007          and.l     #255,D1
00006880  00FF      
00006882  2F01      19008          move.l    D1,-(A7)
00006884  2F0A      19009          move.l    A2,-(A7)
00006886  4E93      19010          jsr       (A3)
00006888  504F      19011          addq.w    #8,A7
                    19012   doprint_126:
0000688A  2006      19013          move.l    D6,D0
0000688C  4CDF 3CFC 19014          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00006890  4E5E      19015          unlk      A6
00006892  4E75      19016          rts
                    19017   @itoa_convert:
00006894  4E56 0000 19018          link      A6,#0
00006898  48E7 3C00 19019          movem.l   D2/D3/D4/D5,-(A7)
0000689C  242E 0008 19020          move.l    8(A6),D2
000068A0  262E 0010 19021          move.l    16(A6),D3
000068A4  2A2E 000C 19022          move.l    12(A6),D5
000068A8  2F05      19023          move.l    D5,-(A7)
000068AA  2F03      19024          move.l    D3,-(A7)
000068AC  4EB8 60E6 19025          jsr       ULDIV
000068B0  202F 0004 19026          move.l    4(A7),D0
000068B4  504F      19027          addq.w    #8,A7
000068B6  2800      19028          move.l    D0,D4
000068B8  BA83      19029          cmp.l     D3,D5
000068BA  651C      19030          blo.s     @itoa_convert_1
000068BC  2F03      19031          move.l    D3,-(A7)
000068BE  2F05      19032          move.l    D5,-(A7)
000068C0  2F03      19033          move.l    D3,-(A7)
000068C2  4EB8 60E6 19034          jsr       ULDIV
000068C6  2217      19035          move.l    (A7),D1
000068C8  504F      19036          addq.w    #8,A7
000068CA  2F01      19037          move.l    D1,-(A7)
000068CC  2F02      19038          move.l    D2,-(A7)
000068CE  4EB8 6894 19039          jsr       @itoa_convert
000068D2  DEFC 000C 19040          add.w     #12,A7
000068D6  2400      19041          move.l    D0,D2
                    19042   @itoa_convert_1:
000068D8  0C84 0000 19043          cmp.l     #9,D4
000068DC  0009      
000068DE  6E0E      19044          bgt.s     @itoa_convert_3
000068E0  2004      19045          move.l    D4,D0
000068E2  7230      19046          moveq     #48,D1
000068E4  C2BC 0000 19047          and.l     #255,D1
000068E8  00FF      
000068EA  D081      19048          add.l     D1,D0
000068EC  6012      19049          bra.s     @itoa_convert_4
                    19050   @itoa_convert_3:
000068EE  2004      19051          move.l    D4,D0
000068F0  7261      19052          moveq     #97,D1
000068F2  C2BC 0000 19053          and.l     #255,D1
000068F6  00FF      
000068F8  D081      19054          add.l     D1,D0
000068FA  0480 0000 19055          sub.l     #10,D0
000068FE  000A      
                    19056   @itoa_convert_4:
00006900  2042      19057          move.l    D2,A0
00006902  1080      19058          move.b    D0,(A0)
00006904  2002      19059          move.l    D2,D0
00006906  5280      19060          addq.l    #1,D0
00006908  4CDF 003C 19061          movem.l   (A7)+,D2/D3/D4/D5
0000690C  4E5E      19062          unlk      A6
0000690E  4E75      19063          rts
                    19064   _ltoa:
00006910  4E56 0000 19065          link      A6,#0
00006914  48E7 3C00 19066          movem.l   D2/D3/D4/D5,-(A7)
00006918  242E 0008 19067          move.l    8(A6),D2
0000691C  262E 000C 19068          move.l    12(A6),D3
00006920  2A2E 0010 19069          move.l    16(A6),D5
00006924  2803      19070          move.l    D3,D4
00006926  0C85 0000 19071          cmp.l     #2,D5
0000692A  0002      
0000692C  6D08      19072          blt.s     ltoa_3
0000692E  0C85 0000 19073          cmp.l     #36,D5
00006932  0024      
00006934  6F06      19074          ble.s     ltoa_1
                    19075   ltoa_3:
00006936  2003      19076          move.l    D3,D0
00006938  6000 0054 19077          bra       ltoa_4
                    19078   ltoa_1:
0000693C  0C85 0000 19079          cmp.l     #10,D5
00006940  000A      
00006942  6600 0034 19080          bne       ltoa_5
00006946  0C82 0000 19081          cmp.l     #0,D2
0000694A  0000      
0000694C  6C2A      19082          bge.s     ltoa_5
0000694E  2002      19083          move.l    D2,D0
00006950  4480      19084          neg.l     D0
00006952  2400      19085          move.l    D0,D2
00006954  0C82 0000 19086          cmp.l     #0,D2
00006958  0000      
0000695A  6C14      19087          bge.s     ltoa_7
0000695C  4879 0000 19088          pea       @itoa_1.L
00006960  6C22      
00006962  2F03      19089          move.l    D3,-(A7)
00006964  4EB9 0000 19090          jsr       _strcpy
00006968  6A52      
0000696A  504F      19091          addq.w    #8,A7
0000696C  2003      19092          move.l    D3,D0
0000696E  601E      19093          bra.s     ltoa_4
                    19094   ltoa_7:
00006970  2044      19095          move.l    D4,A0
00006972  5284      19096          addq.l    #1,D4
00006974  10BC 002D 19097          move.b    #45,(A0)
                    19098   ltoa_5:
00006978  2F05      19099          move.l    D5,-(A7)
0000697A  2F02      19100          move.l    D2,-(A7)
0000697C  2F04      19101          move.l    D4,-(A7)
0000697E  4EB8 6894 19102          jsr       @itoa_convert
00006982  DEFC 000C 19103          add.w     #12,A7
00006986  2800      19104          move.l    D0,D4
00006988  2044      19105          move.l    D4,A0
0000698A  4210      19106          clr.b     (A0)
0000698C  2003      19107          move.l    D3,D0
                    19108   ltoa_4:
0000698E  4CDF 003C 19109          movem.l   (A7)+,D2/D3/D4/D5
00006992  4E5E      19110          unlk      A6
00006994  4E75      19111          rts
                    19112   _ultoa:
00006996  4E56 0000 19113          link      A6,#0
0000699A  48E7 3800 19114          movem.l   D2/D3/D4,-(A7)
0000699E  262E 0010 19115          move.l    16(A6),D3
000069A2  282E 000C 19116          move.l    12(A6),D4
000069A6  2404      19117          move.l    D4,D2
000069A8  0C83 0000 19118          cmp.l     #2,D3
000069AC  0002      
000069AE  6D08      19119          blt.s     ultoa_3
000069B0  0C83 0000 19120          cmp.l     #36,D3
000069B4  0024      
000069B6  6F04      19121          ble.s     ultoa_1
                    19122   ultoa_3:
000069B8  2004      19123          move.l    D4,D0
000069BA  6018      19124          bra.s     ultoa_4
                    19125   ultoa_1:
000069BC  2F03      19126          move.l    D3,-(A7)
000069BE  2F2E 0008 19127          move.l    8(A6),-(A7)
000069C2  2F02      19128          move.l    D2,-(A7)
000069C4  4EB8 6894 19129          jsr       @itoa_convert
000069C8  DEFC 000C 19130          add.w     #12,A7
000069CC  2400      19131          move.l    D0,D2
000069CE  2042      19132          move.l    D2,A0
000069D0  4210      19133          clr.b     (A0)
000069D2  2004      19134          move.l    D4,D0
                    19135   ultoa_4:
000069D4  4CDF 001C 19136          movem.l   (A7)+,D2/D3/D4
000069D8  4E5E      19137          unlk      A6
000069DA  4E75      19138          rts
                    19139   _itoa:
000069DC  4E56 0000 19140          link      A6,#0
000069E0  2F2E 0010 19141          move.l    16(A6),-(A7)
000069E4  2F2E 000C 19142          move.l    12(A6),-(A7)
000069E8  2F2E 0008 19143          move.l    8(A6),-(A7)
000069EC  4EB8 6910 19144          jsr       _ltoa
000069F0  DEFC 000C 19145          add.w     #12,A7
000069F4  4E5E      19146          unlk      A6
000069F6  4E75      19147          rts
                    19148   _strlen:
000069F8  206F 0004 19149          move.l    (4,A7),A0
000069FC  2248      19150          move.l    A0,A1
                    19151   strlen_1:
000069FE  4A19      19152          tst.b     (A1)+
00006A00  66FC      19153          bne       strlen_1
00006A02  2009      19154          move.l    A1,D0
00006A04  9088      19155          sub.l     A0,D0
00006A06  5380      19156          subq.l    #1,D0
00006A08  4E75      19157          rts
                    19158   _putch:
00006A0A  4E56 0000 19159          link      A6,#0
00006A0E  2F02      19160          move.l    D2,-(A7)
00006A10  242E 0008 19161          move.l    8(A6),D2
00006A14  0C82 0000 19162          cmp.l     #10,D2
00006A18  000A      
00006A1A  660A      19163          bne.s     putch_1
00006A1C  4878 000D 19164          pea       13
00006A20  4EB8 5E8E 19165          jsr       __putch
00006A24  584F      19166          addq.w    #4,A7
                    19167   putch_1:
00006A26  2F02      19168          move.l    D2,-(A7)
00006A28  4EB8 5E8E 19169          jsr       __putch
00006A2C  584F      19170          addq.w    #4,A7
00006A2E  2002      19171          move.l    D2,D0
00006A30  241F      19172          move.l    (A7)+,D2
00006A32  4E5E      19173          unlk      A6
00006A34  4E75      19174          rts
                    19175   _toupper:
00006A36  202F 0004 19176          move.l    4(A7),D0
00006A3A  0C80 0000 19177          cmp.l     #'a',D0
00006A3E  0061      
00006A40  6D0E      19178          blt.s     toupper_1
00006A42  0C80 0000 19179          cmp.l     #'z',D0
00006A46  007A      
00006A48  6E06      19180          bgt.s     toupper_1
00006A4A  0480 0000 19181          sub.l     #$20,D0
00006A4E  0020      
                    19182   toupper_1:
00006A50  4E75      19183          rts
                    19184   _strcpy:
00006A52  206F 0004 19185          move.l    (4,A7),A0
00006A56  226F 0008 19186          move.l    (8,A7),A1
00006A5A  2008      19187          move.l    A0,D0
                    19188   strcpy_1:
00006A5C  10D9      19189          move.b    (A1)+,(A0)+
00006A5E  66FC      19190          bne.s     strcpy_1
00006A60  4E75      19191          rts
                    19192          section   const
          0000 6A62 19193   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    19194   
                    19195   @asn6b_~1_1:
00006A62  416C 7465 19196          dc.b      65,108,116,101,114,97,32,68,69,49,47,54,56,75
00006A66  7261 2044 
00006A6A  4531 2F36 
00006A6E  384B      
00006A70  00        19197          dc.b      0
                    19198   @asn6b_~1_2:
00006A72  4D69 6372 19199          dc.b      77,105,99,114,105,117,109,32,117,67,47,79,83
00006A76  6975 6D20 
00006A7A  7543 2F4F 
00006A7E  53        
00006A7F  2D49 4920 19200          dc.b      45,73,73,32,82,84,79,83,0
00006A83  5254 4F53 
00006A87  00        
                    19201   @canbus~1_1:
00006A88  4341 4E30 19202          dc.b      67,65,78,48,32,82,101,99,101,105,118,101,100
00006A8C  2052 6563 
00006A90  6569 7665 
00006A94  64        
00006A95  3A20 2558 19203          dc.b      58,32,37,88,13,10,0
00006A99  0D0A 00   
                    19204   @canbus~1_2:
00006A9C  4341 4E31 19205          dc.b      67,65,78,49,32,82,101,99,101,105,118,101,100
00006AA0  2052 6563 
00006AA4  6569 7665 
00006AA8  64        
00006AA9  3A20 2558 19206          dc.b      58,32,37,88,13,10,0
00006AAD  0D0A 00   
                    19207   @canbus~1_3:
00006AB0  0D0A 0D0A 19208          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
00006AB4  2D2D 2D2D 
00006AB8  2043 414E 
00006ABC  4255 53   
00006ABF  2054 6573 19209          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
00006AC3  7420 2D2D 
00006AC7  2D2D 0D0A 
00006ACB  00        
                    19210   @canbus~1_4:
00006ACC  0D0A 00   19211          dc.b      13,10,0
                    19212   @ucos_ii_1:
00006AD0  3F00      19213          dc.b      63,0
                    19214   @ucos_ii_2:
00006AD2  7543 2F4F 19215          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
00006AD6  532D 4949 
00006ADA  2049 646C 
00006ADE  6500      
                    19216   @ucos_ii_3:
00006AE0  7543 2F4F 19217          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
00006AE4  532D 4949 
00006AE8  2053 7461 
00006AEC  7400      
                    19218   @ucos_ii_4:
00006AEE  7543 2F4F 19219          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
00006AF2  532D 4949 
00006AF6  2054 6D72 
00006AFA  4C6F      
00006AFC  636B 00   19220          dc.b      99,107,0
                    19221   @ucos_ii_5:
00006B00  7543 2F4F 19222          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
00006B04  532D 4949 
00006B08  2054 6D72 
00006B0C  5369      
00006B0E  676E 616C 19223          dc.b      103,110,97,108,0
00006B12  00        
                    19224   @ucos_ii_6:
00006B14  7543 2F4F 19225          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
00006B18  532D 4949 
00006B1C  2054 6D72 
00006B20  00        
                    19226   _OSUnMapTbl:
00006B22  0000 0100 19227          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
00006B26  0200 0100 
00006B2A  0300 0100 
00006B2E  0200 0100 
00006B32  0400 0100 
00006B36  0200      
00006B38  0100 0300 19228          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
00006B3C  0100 0200 
00006B40  0100 0500 
00006B44  0100 0200 
00006B48  0100 0300 
00006B4C  0100      
00006B4E  0200 0100 19229          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
00006B52  0400 0100 
00006B56  0200 0100 
00006B5A  0300 0100 
00006B5E  0200 0100 
00006B62  0600      
00006B64  0100 0200 19230          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
00006B68  0100 0300 
00006B6C  0100 0200 
00006B70  0100 0400 
00006B74  0100 0200 
00006B78  0100      
00006B7A  0300 0100 19231          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
00006B7E  0200 0100 
00006B82  0500 0100 
00006B86  0200 0100 
00006B8A  0300 0100 
00006B8E  0200      
00006B90  0100 0400 19232          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
00006B94  0100 0200 
00006B98  0100 0300 
00006B9C  0100 0200 
00006BA0  0100 0700 
00006BA4  0100      
00006BA6  0200 0100 19233          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
00006BAA  0300 0100 
00006BAE  0200 0100 
00006BB2  0400 0100 
00006BB6  0200 0100 
00006BBA  0300      
00006BBC  0100 0200 19234          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
00006BC0  0100 0500 
00006BC4  0100 0200 
00006BC8  0100 0300 
00006BCC  0100 0200 
00006BD0  0100      
00006BD2  0400 0100 19235          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
00006BD6  0200 0100 
00006BDA  0300 0100 
00006BDE  0200 0100 
00006BE2  0600 0100 
00006BE6  0200      
00006BE8  0100 0300 19236          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
00006BEC  0100 0200 
00006BF0  0100 0400 
00006BF4  0100 0200 
00006BF8  0100 0300 
00006BFC  0100      
00006BFE  0200 0100 19237          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
00006C02  0500 0100 
00006C06  0200 0100 
00006C0A  0300 0100 
00006C0E  0200 0100 
00006C12  0400      
00006C14  0100 0200 19238          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
00006C18  0100 0300 
00006C1C  0100 0200 
00006C20  0100      
                    19239   @itoa_1:
00006C22  2D32 3134 19240          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00006C26  3734 3833 
00006C2A  3634 3800 
                    19241   __ctype:
00006C2E  0040 4040 19242          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
00006C32  4040 4040 
00006C36  4040 5050 
00006C3A  5050 50   
00006C3D  4040 4040 19243          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
00006C41  4040 4040 
00006C45  4040 4040 
00006C49  4040 40   
00006C4C  4040 40D0 19244          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
00006C50  A0A0 A0A0 
00006C54  A0A0 A0A0 
00006C58  A0A0 A0A0 19245          dc.b      160,160,160,160,160,160,160,140,140,140,140
00006C5C  A0A0 A08C 
00006C60  8C8C 8C   
00006C63  8C8C 8C8C 19246          dc.b      140,140,140,140,140,140,160,160,160,160,160
00006C67  8C8C A0A0 
00006C6B  A0A0 A0   
00006C6E  A0A0 8A8A 19247          dc.b      160,160,138,138,138,138,138,138,130,130,130
00006C72  8A8A 8A8A 
00006C76  8282 82   
00006C79  8282 8282 19248          dc.b      130,130,130,130,130,130,130,130,130,130,130
00006C7D  8282 8282 
00006C81  8282 82   
00006C84  8282 8282 19249          dc.b      130,130,130,130,130,130,160,160,160,160,160
00006C88  8282 A0A0 
00006C8C  A0A0 A0   
00006C8F  A089 8989 19250          dc.b      160,137,137,137,137,137,137,129,129,129,129
00006C93  8989 8981 
00006C97  8181 81   
00006C9A  8181 8181 19251          dc.b      129,129,129,129,129,129,129,129,129,129,129
00006C9E  8181 8181 
00006CA2  8181 81   
00006CA5  8181 8181 19252          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
00006CA9  81A0 A0A0 
00006CAD  A040 0000 
00006CB1  00        
00006CB2  0000 0000 19253          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006CB6  0000 0000 
00006CBA  0000 0000 
00006CBE  0000 0000 
00006CC2  0000 0000 
00006CC6  0000      
00006CC8  0000 0000 19254          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006CCC  0000 0000 
00006CD0  0000 0000 
00006CD4  0000 0000 
00006CD8  0000 0000 
00006CDC  0000      
00006CDE  0000 0000 19255          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006CE2  0000 0000 
00006CE6  0000 0000 
00006CEA  0000 0000 
00006CEE  0000 0000 
00006CF2  0000      
00006CF4  0000 0000 19256          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006CF8  0000 0000 
00006CFC  0000 0000 
00006D00  0000 0000 
00006D04  0000 0000 
00006D08  0000      
00006D0A  0000 0000 19257          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006D0E  0000 0000 
00006D12  0000 0000 
00006D16  0000 0000 
00006D1A  0000 0000 
00006D1E  0000      
00006D20  0000 0000 19258          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006D24  0000 0000 
00006D28  0000 0000 
00006D2C  0000 00   
                    19259          section   data
          0000 6D30 19260   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    19261   
08000000            19262              org         RAM				; starting at address $08000000
          0800 0000 19263   begin_RAM  equ         *				; begin ram starts here
          0800 0000 19264   data       equ         *				; data starts here also
                    19265   
                    19266          section   bss
          0800 0000 19267   bss        equ         *
                    19268   
                    19269   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    19270   
                    19271   *********************************************************************************************************
                    19272   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    19273   * install the exception handler using the C function InstallExceptionHandler()
                    19274   *********************************************************************************************************
                    19275   
08000000            19276   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08000004            19277   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08000008            19278   VBusError        ds.l    1      storage for address of Bus Error Handler
0800000C            19279   VAddressError    ds.l    1      storage for address of Address Error Handler
08000010            19280   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08000014            19281   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08000018            19282   VCheck           ds.l    1      ditto
0800001C            19283   VTrapV           ds.l    1      ditto
08000020            19284   VPrivilege       ds.l    1      ditto
08000024            19285   VTrace           ds.l    1
08000028            19286   VLine1010emul    ds.l    1
0800002C            19287   VLine1111emul    ds.l    1
08000030            19288   VUnassigned1     ds.l    1
08000034            19289   VUnassigned2     ds.l    1
08000038            19290   VUnassigned3     ds.l    1
0800003C            19291   VUninit_IRQ      ds.l    1
08000040            19292   VUnassigned4     ds.l    1
08000044            19293   VUnassigned5     ds.l    1
08000048            19294   VUnassigned6     ds.l    1
0800004C            19295   VUnassigned7     ds.l    1
08000050            19296   VUnassigned8     ds.l    1
08000054            19297   VUnassigned9     ds.l    1
08000058            19298   VUnassigned10    ds.l    1
0800005C            19299   VUnassigned11    ds.l    1
08000060            19300   VSpuriousIRQ     ds.l    1
                    19301   
                    19302   * Interrupt handlers Vector 25-31
08000064            19303   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000068            19304   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800006C            19305   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000070            19306   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000074            19307   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000078            19308   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800007C            19309   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    19310   
                    19311   * Trap Handler vectors 32-47
08000080            19312   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000084            19313   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000088            19314   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800008C            19315   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000090            19316   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000094            19317   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000098            19318   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800009C            19319   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A0            19320   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A4            19321   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A8            19322   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000AC            19323   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B0            19324   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B4            19325   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B8            19326   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000BC            19327   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    19328   
                    19329   __ungetbuf:                            ; ungetbuffer for stdio functions
080000C0            19330              ds.l        1
                    19331   __timezone:                            ; difference, in seconds, between local time and UTC
080000C4            19332              ds.l        1
                    19333   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080000C8            19334              ds.l        1
                    19335   __romsize:                             ; size of ROM used by program
080000CC            19336              ds.l        1
                    19337   __ramsize:                             ; size of RAM used by program
080000D0            19338              ds.l        1
                    19339   
                    19340   _Task1Stk:
080000D4            19341          ds.b      512
                    19342   _Task2Stk:
080002D4            19343          ds.b      512
                    19344   _Task3Stk:
080004D4            19345          ds.b      512
                    19346   _Task4Stk:
080006D4            19347          ds.b      512
                    19348   _Task5Stk:
080008D4            19349          ds.b      512
                    19350   _Task6Stk:
08000AD4            19351          ds.b      512
                    19352   _OSTmrTickCtr:
08000CD4            19353          ds.b      1
                    19354   _OSCtxSwCtr:
08000CD6            19355          ds.b      4
                    19356   _OSEventFreeList:
08000CDA            19357          ds.b      4
                    19358   _OSEventTbl:
08000CDE            19359          ds.b      220
                    19360   _OSFlagTbl:
08000DBA            19361          ds.b      60
                    19362   _OSFlagFreeList:
08000DF6            19363          ds.b      4
                    19364   _OSCPUUsage:
08000DFA            19365          ds.b      1
                    19366   _OSIdleCtrMax:
08000DFC            19367          ds.b      4
                    19368   _OSIdleCtrRun:
08000E00            19369          ds.b      4
                    19370   _OSStatRdy:
08000E04            19371          ds.b      1
                    19372   _OSTaskStatStk:
08000E06            19373          ds.b      256
                    19374   _OSIntNesting:
08000F06            19375          ds.b      1
                    19376   _OSLockNesting:
08000F08            19377          ds.b      1
                    19378   _OSPrioCur:
08000F0A            19379          ds.b      1
                    19380   _OSPrioHighRdy:
08000F0C            19381          ds.b      1
                    19382   _OSRdyGrp:
08000F0E            19383          ds.b      1
                    19384   _OSRdyTbl:
08000F10            19385          ds.b      8
                    19386   _OSRunning:
08000F18            19387          ds.b      1
                    19388   _OSTaskCtr:
08000F1A            19389          ds.b      1
                    19390   _OSIdleCtr:
08000F1C            19391          ds.b      4
                    19392   _OSTaskIdleStk:
08000F20            19393          ds.b      256
                    19394   _OSTCBCur:
08001020            19395          ds.b      4
                    19396   _OSTCBFreeList:
08001024            19397          ds.b      4
                    19398   _OSTCBHighRdy:
08001028            19399          ds.b      4
                    19400   _OSTCBList:
0800102C            19401          ds.b      4
                    19402   _OSTCBPrioTbl:
08001030            19403          ds.b      256
                    19404   _OSTCBTbl:
08001130            19405          ds.b      1892
                    19406   _OSMemFreeList:
08001894            19407          ds.b      4
                    19408   _OSMemTbl:
08001898            19409          ds.b      120
                    19410   _OSQFreeList:
08001910            19411          ds.b      4
                    19412   _OSQTbl:
08001914            19413          ds.b      96
                    19414   _OSTaskRegNextAvailID:
08001974            19415          ds.b      1
                    19416   _OSTime:
08001976            19417          ds.b      4
                    19418   _OSTmrFree:
0800197A            19419          ds.b      2
                    19420   _OSTmrUsed:
0800197C            19421          ds.b      2
                    19422   _OSTmrTime:
0800197E            19423          ds.b      4
                    19424   _OSTmrSem:
08001982            19425          ds.b      4
                    19426   _OSTmrSemSignal:
08001986            19427          ds.b      4
                    19428   _OSTmrTbl:
0800198A            19429          ds.b      576
                    19430   _OSTmrFreeList:
08001BCA            19431          ds.b      4
                    19432   _OSTmrTaskStk:
08001BCE            19433          ds.b      256
                    19434   _OSTmrWheelTbl:
08001CCE            19435          ds.b      32
                    19436          section   heap
          0800 1CEE 19437   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 1CEE 19438   heap       equ         *
                    19439   
          0801 0000 19440   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
