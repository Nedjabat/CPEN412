680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 16 Apr 2023      Time: 11:03:42          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\MK68KDEBUGGERASN5.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0546 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  30DC      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2056      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG-NO-DISASSEMBLER-WITH-NO-ADDRESS-LOGIC.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     478   ; unsigned int i, x, y, z, PortA_Count;
                     479   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     480   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     481   ; unsigned int d0, d1, d2, d3, d4, d5, d6, d7;
                     482   ; unsigned int a0, a1, a2, a3, a4, a5, a6;
                     483   ; unsigned int PC, SSP, USP;
                     484   ; unsigned short int SR;
                     485   ; // Breakpoint variables
                     486   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     487   ; unsigned short int BreakPointInstruction[8];           // to hold the instruction opcode at the breakpoint
                     488   ; unsigned int BreakPointSetOrCleared[8];
                     489   ; unsigned int InstructionSize;
                     490   ; // watchpoint variables
                     491   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     492   ; unsigned int WatchPointSetOrCleared[8];
                     493   ; char WatchPointString[8][100];
                     494   ; char    TempString[100];
                     495   ; /************************************************************************************
                     496   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     497   ; ************************************************************************************/
                     498   ; void Wait1ms(void)
                     499   ; {
                     500   _Wait1ms:
00000932  2F02       501          move.l    D2,-(A7)
                     502   ; long int  i;
                     503   ; for (i = 0; i < 1000; i++)
00000934  4282       504          clr.l     D2
                     505   Wait1ms_1:
00000936  0C82 0000  506          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       507          bge.s     Wait1ms_3
0000093E  5282       508          addq.l    #1,D2
00000940  60F4       509          bra       Wait1ms_1
                     510   Wait1ms_3:
00000942  241F       511          move.l    (A7)+,D2
00000944  4E75       512          rts
                     513   ; ;
                     514   ; }
                     515   ; /************************************************************************************
                     516   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     517   ; **************************************************************************************/
                     518   ; void Wait3ms(void)
                     519   ; {
                     520   _Wait3ms:
00000946  2F02       521          move.l    D2,-(A7)
                     522   ; int i;
                     523   ; for (i = 0; i < 3; i++)
00000948  4282       524          clr.l     D2
                     525   Wait3ms_1:
0000094A  0C82 0000  526          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       527          bge.s     Wait3ms_3
                     528   ; Wait1ms();
00000952  4EB8 0932  529          jsr       _Wait1ms
00000956  5282       530          addq.l    #1,D2
00000958  60F0       531          bra       Wait3ms_1
                     532   Wait3ms_3:
0000095A  241F       533          move.l    (A7)+,D2
0000095C  4E75       534          rts
                     535   ; }
                     536   ; /*********************************************************************************************
                     537   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     538   ; *********************************************************************************************/
                     539   ; void Init_LCD(void)
                     540   ; {
                     541   _Init_LCD:
                     542   ; LCDcommand = (char)(0x0c);
0000095E  13FC 000C  543          move.b    #12,4194336
00000962  0040 0020 
                     544   ; Wait3ms();
00000966  4EB8 0946  545          jsr       _Wait3ms
                     546   ; LCDcommand = (char)(0x38);
0000096A  13FC 0038  547          move.b    #56,4194336
0000096E  0040 0020 
                     548   ; Wait3ms();
00000972  4EB8 0946  549          jsr       _Wait3ms
00000976  4E75       550          rts
                     551   ; }
                     552   ; /******************************************************************************
                     553   ; *subroutine to output a single character held in d1 to the LCD display
                     554   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     555   ; *current cursor position
                     556   ; *******************************************************************************/
                     557   ; void Outchar(int c)
                     558   ; {
                     559   _Outchar:
00000978  4E56 0000  560          link      A6,#0
                     561   ; LCDdata = (char)(c);
0000097C  202E 0008  562          move.l    8(A6),D0
00000980  13C0 0040  563          move.b    D0,4194338
00000984  0022      
                     564   ; Wait1ms();
00000986  4EB8 0932  565          jsr       _Wait1ms
0000098A  4E5E       566          unlk      A6
0000098C  4E75       567          rts
                     568   ; }
                     569   ; /**********************************************************************************
                     570   ; *subroutine to output a message at the current cursor position of the LCD display
                     571   ; ************************************************************************************/
                     572   ; void OutMess(char* theMessage)
                     573   ; {
                     574   _OutMess:
0000098E  4E56 FFFC  575          link      A6,#-4
                     576   ; char c;
                     577   ; while ((c = *theMessage++) != (char)(0))
                     578   OutMess_1:
00000992  206E 0008  579          move.l    8(A6),A0
00000996  52AE 0008  580          addq.l    #1,8(A6)
0000099A  1D50 FFFF  581          move.b    (A0),-1(A6)
0000099E  1010       582          move.b    (A0),D0
000009A0  6712       583          beq.s     OutMess_3
                     584   ; Outchar(c);
000009A2  122E FFFF  585          move.b    -1(A6),D1
000009A6  4881       586          ext.w     D1
000009A8  48C1       587          ext.l     D1
000009AA  2F01       588          move.l    D1,-(A7)
000009AC  4EB8 0978  589          jsr       _Outchar
000009B0  584F       590          addq.w    #4,A7
000009B2  60DE       591          bra       OutMess_1
                     592   OutMess_3:
000009B4  4E5E       593          unlk      A6
000009B6  4E75       594          rts
                     595   ; }
                     596   ; /******************************************************************************
                     597   ; *subroutine to clear the line by issuing 24 space characters
                     598   ; *******************************************************************************/
                     599   ; void Clearln(void)
                     600   ; {
                     601   _Clearln:
000009B8  2F02       602          move.l    D2,-(A7)
                     603   ; unsigned char i;
                     604   ; for (i = 0; i < 24; i++)
000009BA  4202       605          clr.b     D2
                     606   Clearln_1:
000009BC  0C02 0018  607          cmp.b     #24,D2
000009C0  640E       608          bhs.s     Clearln_3
                     609   ; Outchar(' ');  /* write a space char to the LCD display */
000009C2  4878 0020  610          pea       32
000009C6  4EB8 0978  611          jsr       _Outchar
000009CA  584F       612          addq.w    #4,A7
000009CC  5202       613          addq.b    #1,D2
000009CE  60EC       614          bra       Clearln_1
                     615   Clearln_3:
000009D0  241F       616          move.l    (A7)+,D2
000009D2  4E75       617          rts
                     618   ; }
                     619   ; /******************************************************************************
                     620   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     621   ; *******************************************************************************/
                     622   ; void Oline0(char* theMessage)
                     623   ; {
                     624   _Oline0:
000009D4  4E56 0000  625          link      A6,#0
                     626   ; LCDcommand = (char)(0x80);
000009D8  13FC 0080  627          move.b    #128,4194336
000009DC  0040 0020 
                     628   ; Wait3ms();
000009E0  4EB8 0946  629          jsr       _Wait3ms
                     630   ; Clearln();
000009E4  4EB8 09B8  631          jsr       _Clearln
                     632   ; LCDcommand = (char)(0x80);
000009E8  13FC 0080  633          move.b    #128,4194336
000009EC  0040 0020 
                     634   ; Wait3ms();
000009F0  4EB8 0946  635          jsr       _Wait3ms
                     636   ; OutMess(theMessage);
000009F4  2F2E 0008  637          move.l    8(A6),-(A7)
000009F8  4EB8 098E  638          jsr       _OutMess
000009FC  584F       639          addq.w    #4,A7
000009FE  4E5E       640          unlk      A6
00000A00  4E75       641          rts
                     642   ; }
                     643   ; /******************************************************************************
                     644   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     645   ; *******************************************************************************/
                     646   ; void Oline1(char* theMessage)
                     647   ; {
                     648   _Oline1:
00000A02  4E56 0000  649          link      A6,#0
                     650   ; LCDcommand = (char)(0xC0);
00000A06  13FC 00C0  651          move.b    #192,4194336
00000A0A  0040 0020 
                     652   ; Wait3ms();
00000A0E  4EB8 0946  653          jsr       _Wait3ms
                     654   ; Clearln();
00000A12  4EB8 09B8  655          jsr       _Clearln
                     656   ; LCDcommand = (char)(0xC0);
00000A16  13FC 00C0  657          move.b    #192,4194336
00000A1A  0040 0020 
                     658   ; Wait3ms();
00000A1E  4EB8 0946  659          jsr       _Wait3ms
                     660   ; OutMess(theMessage);
00000A22  2F2E 0008  661          move.l    8(A6),-(A7)
00000A26  4EB8 098E  662          jsr       _OutMess
00000A2A  584F       663          addq.w    #4,A7
00000A2C  4E5E       664          unlk      A6
00000A2E  4E75       665          rts
                     666   ; }
                     667   ; void InstallExceptionHandler(void (*function_ptr)(), int level)
                     668   ; {
                     669   _InstallExceptionHandler:
00000A30  4E56 FFFC  670          link      A6,#-4
                     671   ; volatile long int* RamVectorAddress = (volatile long int*)(StartOfExceptionVectorTable);   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  672          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     673   ; RamVectorAddress[level] = (long int*)(function_ptr);
00000A3C  206E FFFC  674          move.l    -4(A6),A0
00000A40  202E 000C  675          move.l    12(A6),D0
00000A44  E588       676          lsl.l     #2,D0
00000A46  21AE 0008  677          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       678          unlk      A6
00000A4E  4E75       679          rts
                     680   ; }
                     681   ; void TestLEDS(void)
                     682   ; {
                     683   _TestLEDS:
00000A50  48E7 3000  684          movem.l   D2/D3,-(A7)
                     685   ; int delay;
                     686   ; unsigned char count = 0;
00000A54  4202       687          clr.b     D2
                     688   ; while (1) {
                     689   TestLEDS_1:
                     690   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f));
00000A56  1002       691          move.b    D2,D0
00000A58  E908       692          lsl.b     #4,D0
00000A5A  1202       693          move.b    D2,D1
00000A5C  C23C 000F  694          and.b     #15,D1
00000A60  D001       695          add.b     D1,D0
00000A62  13C0 0040  696          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  697          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  698          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  699          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  700          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  701          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  702          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  703          move.b    D0,4194304
00000A90  0000      
                     704   ; for (delay = 0; delay < 200000; delay++)
00000A92  4283       705          clr.l     D3
                     706   TestLEDS_4:
00000A94  0C83 0003  707          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       708          bge.s     TestLEDS_6
00000A9C  5283       709          addq.l    #1,D3
00000A9E  60F4       710          bra       TestLEDS_4
                     711   TestLEDS_6:
                     712   ; ;
                     713   ; count++;
00000AA0  5202       714          addq.b    #1,D2
00000AA2  60B2       715          bra       TestLEDS_1
                     716   ; }
                     717   ; }
                     718   ; void SwitchTest(void)
                     719   ; {
                     720   _SwitchTest:
00000AA4  48E7 3020  721          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  722          lea       _printf.L,A2
00000AAC  4084      
                     723   ; int i, switches = 0;
00000AAE  4283       724          clr.l     D3
                     725   ; printf("\r\n");
00000AB0  4879 0000  726          pea       @m68kde~3_1.L
00000AB4  49D4      
00000AB6  4E92       727          jsr       (A2)
00000AB8  584F       728          addq.w    #4,A7
                     729   ; while (1) {
                     730   SwitchTest_1:
                     731   ; switches = (PortB << 8) | (PortA);
00000ABA  1039 0040  732          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  733          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       734          lsl.l     #8,D0
00000AC8  1239 0040  735          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  736          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       737          or.l      D1,D0
00000AD6  2600       738          move.l    D0,D3
                     739   ; printf("\rSwitches SW[7-0] = ");
00000AD8  4879 0000  740          pea       @m68kde~3_2.L
00000ADC  49D8      
00000ADE  4E92       741          jsr       (A2)
00000AE0  584F       742          addq.w    #4,A7
                     743   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00000AE2  243C 0000  744          move.l    #128,D2
00000AE6  0080      
                     745   SwitchTest_4:
00000AE8  0C82 0000  746          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       747          ble.s     SwitchTest_6
                     748   ; if ((switches & i) == 0)
00000AF0  2003       749          move.l    D3,D0
00000AF2  C082       750          and.l     D2,D0
00000AF4  660C       751          bne.s     SwitchTest_7
                     752   ; printf("0");
00000AF6  4879 0000  753          pea       @m68kde~3_3.L
00000AFA  49EE      
00000AFC  4E92       754          jsr       (A2)
00000AFE  584F       755          addq.w    #4,A7
00000B00  600A       756          bra.s     SwitchTest_8
                     757   SwitchTest_7:
                     758   ; else
                     759   ; printf("1");
00000B02  4879 0000  760          pea       @m68kde~3_4.L
00000B06  49F0      
00000B08  4E92       761          jsr       (A2)
00000B0A  584F       762          addq.w    #4,A7
                     763   SwitchTest_8:
00000B0C  E282       764          asr.l     #1,D2
00000B0E  60D8       765          bra       SwitchTest_4
                     766   SwitchTest_6:
00000B10  60A8       767          bra       SwitchTest_1
                     768   ; }
                     769   ; }
                     770   ; }
                     771   ; /*********************************************************************************************
                     772   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     773   ; *********************************************************************************************/
                     774   ; void Init_RS232(void)
                     775   ; {
                     776   _Init_RS232:
                     777   ; RS232_Control = (char)(0x15); //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  778          move.b    #21,4194368
00000B16  0040 0040 
                     779   ; RS232_Baud = (char)(0x1);      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  780          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       781          rts
                     782   ; }
                     783   ; int kbhit(void)
                     784   ; {
                     785   _kbhit:
                     786   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  787          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  788          and.b     #1,D0
00000B2E  0C00 0001  789          cmp.b     #1,D0
00000B32  6604       790          bne.s     kbhit_1
                     791   ; return 1;
00000B34  7001       792          moveq     #1,D0
00000B36  6002       793          bra.s     kbhit_3
                     794   kbhit_1:
                     795   ; else
                     796   ; return 0;
00000B38  4280       797          clr.l     D0
                     798   kbhit_3:
00000B3A  4E75       799          rts
                     800   ; }
                     801   ; /*********************************************************************************************************
                     802   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     803   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     804   ; **  to allow the board to communicate with HyperTerminal Program
                     805   ; **
                     806   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     807   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     808   ; **  call _putch() also
                     809   ; *********************************************************************************************************/
                     810   ; int _putch(int c)
                     811   ; {
                     812   __putch:
00000B3C  4E56 0000  813          link      A6,#0
                     814   ; while (((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     815   _putch_1:
00000B40  1039 0040  816          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  817          and.b     #2,D0
00000B4A  0C00 0002  818          cmp.b     #2,D0
00000B4E  6702       819          beq.s     _putch_3
00000B50  60EE       820          bra       _putch_1
                     821   _putch_3:
                     822   ; ;
                     823   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  824          move.l    8(A6),D0
00000B56  C03C 007F  825          and.b     #127,D0
00000B5A  13C0 0040  826          move.b    D0,4194370
00000B5E  0042      
                     827   ; return c;                                              // putchar() expects the character to be returned
00000B60  202E 0008  828          move.l    8(A6),D0
00000B64  4E5E       829          unlk      A6
00000B66  4E75       830          rts
                     831   ; }
                     832   ; /*********************************************************************************************************
                     833   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     834   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     835   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     836   ; **
                     837   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     838   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     839   ; **  call _getch() also
                     840   ; *********************************************************************************************************/
                     841   ; int _getch(void)
                     842   ; {
                     843   __getch:
00000B68  2F02       844          move.l    D2,-(A7)
                     845   ; int c;
                     846   ; while (((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     847   _getch_1:
00000B6A  1039 0040  848          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  849          and.b     #1,D0
00000B74  0C00 0001  850          cmp.b     #1,D0
00000B78  6702       851          beq.s     _getch_3
00000B7A  60EE       852          bra       _getch_1
                     853   _getch_3:
                     854   ; ;
                     855   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  856          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  857          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  858          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       859          move.l    D0,D2
                     860   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     861   ; if (Echo)
00000B90  4AB9 0B00  862          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       863          beq.s     _getch_4
                     864   ; _putch(c);
00000B98  2F02       865          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  866          jsr       __putch
00000B9E  584F       867          addq.w    #4,A7
                     868   _getch_4:
                     869   ; return c;
00000BA0  2002       870          move.l    D2,D0
00000BA2  241F       871          move.l    (A7)+,D2
00000BA4  4E75       872          rts
                     873   ; }
                     874   ; // flush the input stream for any unread characters
                     875   ; void FlushKeyboard(void)
                     876   ; {
                     877   _FlushKeyboard:
00000BA6  4E56 FFFC  878          link      A6,#-4
                     879   ; char c;
                     880   ; while (1) {
                     881   FlushKeyboard_1:
                     882   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  883          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  884          and.b     #1,D0
00000BB4  0C00 0001  885          cmp.b     #1,D0
00000BB8  6610       886          bne.s     FlushKeyboard_4
                     887   ; c = ((char)(RS232_RxData) & (char)(0x7f));
00000BBA  1039 0040  888          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  889          and.b     #127,D0
00000BC4  1D40 FFFF  890          move.b    D0,-1(A6)
00000BC8  6002       891          bra.s     FlushKeyboard_5
                     892   FlushKeyboard_4:
                     893   ; else
                     894   ; return;
00000BCA  6002       895          bra.s     FlushKeyboard_6
                     896   FlushKeyboard_5:
00000BCC  60DC       897          bra       FlushKeyboard_1
                     898   FlushKeyboard_6:
00000BCE  4E5E       899          unlk      A6
00000BD0  4E75       900          rts
                     901   ; }
                     902   ; }
                     903   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     904   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     905   ; char xtod(int c)
                     906   ; {
                     907   _xtod:
00000BD2  4E56 0000  908          link      A6,#0
00000BD6  2F02       909          move.l    D2,-(A7)
00000BD8  242E 0008  910          move.l    8(A6),D2
                     911   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  912          cmp.b     #57,D2
00000BE0  6E08       913          bgt.s     xtod_1
                     914   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       915          move.b    D2,D0
00000BE4  0400 0030  916          sub.b     #48,D0
00000BE8  6014       917          bra.s     xtod_3
                     918   xtod_1:
                     919   ; else if ((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  920          cmp.b     #70,D2
00000BEE  6F08       921          ble.s     xtod_4
                     922   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       923          move.b    D2,D0
00000BF2  0400 0057  924          sub.b     #87,D0
00000BF6  6006       925          bra.s     xtod_3
                     926   xtod_4:
                     927   ; else
                     928   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       929          move.b    D2,D0
00000BFA  0400 0037  930          sub.b     #55,D0
                     931   xtod_3:
00000BFE  241F       932          move.l    (A7)+,D2
00000C00  4E5E       933          unlk      A6
00000C02  4E75       934          rts
                     935   ; }
                     936   ; int Get2HexDigits(char* CheckSumPtr)
                     937   ; {
                     938   _Get2HexDigits:
00000C04  4E56 0000  939          link      A6,#0
00000C08  2F02       940          move.l    D2,-(A7)
                     941   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       942          move.l    D0,-(A7)
00000C0C  4EB8 0B68  943          jsr       __getch
00000C10  2200       944          move.l    D0,D1
00000C12  201F       945          move.l    (A7)+,D0
00000C14  2F01       946          move.l    D1,-(A7)
00000C16  4EB8 0BD2  947          jsr       _xtod
00000C1A  584F       948          addq.w    #4,A7
00000C1C  C0BC 0000  949          and.l     #255,D0
00000C20  00FF      
00000C22  E980       950          asl.l     #4,D0
00000C24  2F00       951          move.l    D0,-(A7)
00000C26  2F01       952          move.l    D1,-(A7)
00000C28  4EB8 0B68  953          jsr       __getch
00000C2C  221F       954          move.l    (A7)+,D1
00000C2E  2F00       955          move.l    D0,-(A7)
00000C30  4EB8 0BD2  956          jsr       _xtod
00000C34  584F       957          addq.w    #4,A7
00000C36  2200       958          move.l    D0,D1
00000C38  201F       959          move.l    (A7)+,D0
00000C3A  C2BC 0000  960          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       961          or.l      D1,D0
00000C42  2400       962          move.l    D0,D2
                     963   ; if (CheckSumPtr)
00000C44  4AAE 0008  964          tst.l     8(A6)
00000C48  6706       965          beq.s     Get2HexDigits_1
                     966   ; *CheckSumPtr += i;
00000C4A  206E 0008  967          move.l    8(A6),A0
00000C4E  D510       968          add.b     D2,(A0)
                     969   Get2HexDigits_1:
                     970   ; return i;
00000C50  2002       971          move.l    D2,D0
00000C52  241F       972          move.l    (A7)+,D2
00000C54  4E5E       973          unlk      A6
00000C56  4E75       974          rts
                     975   ; }
                     976   ; int Get4HexDigits(char* CheckSumPtr)
                     977   ; {
                     978   _Get4HexDigits:
00000C58  4E56 0000  979          link      A6,#0
                     980   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  981          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  982          jsr       _Get2HexDigits
00000C64  584F       983          addq.w    #4,A7
00000C66  E180       984          asl.l     #8,D0
00000C68  2F00       985          move.l    D0,-(A7)
00000C6A  2F2E 0008  986          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04  987          jsr       _Get2HexDigits
00000C72  584F       988          addq.w    #4,A7
00000C74  2200       989          move.l    D0,D1
00000C76  201F       990          move.l    (A7)+,D0
00000C78  8081       991          or.l      D1,D0
00000C7A  4E5E       992          unlk      A6
00000C7C  4E75       993          rts
                     994   ; }
                     995   ; int Get6HexDigits(char* CheckSumPtr)
                     996   ; {
                     997   _Get6HexDigits:
00000C7E  4E56 0000  998          link      A6,#0
                     999   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1000          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1001          jsr       _Get4HexDigits
00000C8A  584F      1002          addq.w    #4,A7
00000C8C  E180      1003          asl.l     #8,D0
00000C8E  2F00      1004          move.l    D0,-(A7)
00000C90  2F2E 0008 1005          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1006          jsr       _Get2HexDigits
00000C98  584F      1007          addq.w    #4,A7
00000C9A  2200      1008          move.l    D0,D1
00000C9C  201F      1009          move.l    (A7)+,D0
00000C9E  8081      1010          or.l      D1,D0
00000CA0  4E5E      1011          unlk      A6
00000CA2  4E75      1012          rts
                    1013   ; }
                    1014   ; int Get8HexDigits(char* CheckSumPtr)
                    1015   ; {
                    1016   _Get8HexDigits:
00000CA4  4E56 0000 1017          link      A6,#0
                    1018   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1019          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1020          jsr       _Get4HexDigits
00000CB0  584F      1021          addq.w    #4,A7
00000CB2  E180      1022          asl.l     #8,D0
00000CB4  E180      1023          asl.l     #8,D0
00000CB6  2F00      1024          move.l    D0,-(A7)
00000CB8  2F2E 0008 1025          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1026          jsr       _Get4HexDigits
00000CC0  584F      1027          addq.w    #4,A7
00000CC2  2200      1028          move.l    D0,D1
00000CC4  201F      1029          move.l    (A7)+,D0
00000CC6  8081      1030          or.l      D1,D0
00000CC8  4E5E      1031          unlk      A6
00000CCA  4E75      1032          rts
                    1033   ; }
                    1034   ; void DumpMemory(void)   // simple dump memory fn
                    1035   ; {
                    1036   _DumpMemory:
00000CCC  48E7 3C30 1037          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000CD0  45F9 0000 1038          lea       _printf.L,A2
00000CD4  4084      
00000CD6  47F9 0000 1039          lea       _putch.L,A3
00000CDA  3F76      
                    1040   ; int i, j;
                    1041   ; unsigned char* RamPtr, c; // pointer to where the program is download (assumed)
                    1042   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue");
00000CDC  4879 0000 1043          pea       @m68kde~3_5.L
00000CE0  49F2      
00000CE2  4E92      1044          jsr       (A2)
00000CE4  584F      1045          addq.w    #4,A7
                    1046   ; printf("\r\nEnter Start Address: ");
00000CE6  4879 0000 1047          pea       @m68kde~3_6.L
00000CEA  4A2C      
00000CEC  4E92      1048          jsr       (A2)
00000CEE  584F      1049          addq.w    #4,A7
                    1050   ; RamPtr = Get8HexDigits(0);
00000CF0  42A7      1051          clr.l     -(A7)
00000CF2  4EB8 0CA4 1052          jsr       _Get8HexDigits
00000CF6  584F      1053          addq.w    #4,A7
00000CF8  2600      1054          move.l    D0,D3
                    1055   ; while (1) {
                    1056   DumpMemory_1:
                    1057   ; for (i = 0; i < 16; i++) {
00000CFA  4285      1058          clr.l     D5
                    1059   DumpMemory_4:
00000CFC  0C85 0000 1060          cmp.l     #16,D5
00000D00  0010      
00000D02  6C00 0096 1061          bge       DumpMemory_6
                    1062   ; printf("\r\n%08x ", RamPtr);
00000D06  2F03      1063          move.l    D3,-(A7)
00000D08  4879 0000 1064          pea       @m68kde~3_7.L
00000D0C  4A44      
00000D0E  4E92      1065          jsr       (A2)
00000D10  504F      1066          addq.w    #8,A7
                    1067   ; for (j = 0; j < 16; j++) {
00000D12  4282      1068          clr.l     D2
                    1069   DumpMemory_7:
00000D14  0C82 0000 1070          cmp.l     #16,D2
00000D18  0010      
00000D1A  6C24      1071          bge.s     DumpMemory_9
                    1072   ; printf("%02X", RamPtr[j]);
00000D1C  2043      1073          move.l    D3,A0
00000D1E  1230 2800 1074          move.b    0(A0,D2.L),D1
00000D22  C2BC 0000 1075          and.l     #255,D1
00000D26  00FF      
00000D28  2F01      1076          move.l    D1,-(A7)
00000D2A  4879 0000 1077          pea       @m68kde~3_8.L
00000D2E  4A4C      
00000D30  4E92      1078          jsr       (A2)
00000D32  504F      1079          addq.w    #8,A7
                    1080   ; putchar(' ');
00000D34  4878 0020 1081          pea       32
00000D38  4E93      1082          jsr       (A3)
00000D3A  584F      1083          addq.w    #4,A7
00000D3C  5282      1084          addq.l    #1,D2
00000D3E  60D4      1085          bra       DumpMemory_7
                    1086   DumpMemory_9:
                    1087   ; }
                    1088   ; // now display the data as ASCII at the end
                    1089   ; printf("  ");
00000D40  4879 0000 1090          pea       @m68kde~3_9.L
00000D44  4A52      
00000D46  4E92      1091          jsr       (A2)
00000D48  584F      1092          addq.w    #4,A7
                    1093   ; for (j = 0; j < 16; j++) {
00000D4A  4282      1094          clr.l     D2
                    1095   DumpMemory_10:
00000D4C  0C82 0000 1096          cmp.l     #16,D2
00000D50  0010      
00000D52  6C00 003A 1097          bge       DumpMemory_12
                    1098   ; c = ((char)(RamPtr[j]) & 0x7f);
00000D56  2043      1099          move.l    D3,A0
00000D58  1030 2800 1100          move.b    0(A0,D2.L),D0
00000D5C  C03C 007F 1101          and.b     #127,D0
00000D60  1800      1102          move.b    D0,D4
                    1103   ; if ((c > (char)(0x7f)) || (c < ' '))
00000D62  0C04 007F 1104          cmp.b     #127,D4
00000D66  6206      1105          bhi.s     DumpMemory_15
00000D68  0C04 0020 1106          cmp.b     #32,D4
00000D6C  640A      1107          bhs.s     DumpMemory_13
                    1108   DumpMemory_15:
                    1109   ; putchar('.');
00000D6E  4878 002E 1110          pea       46
00000D72  4E93      1111          jsr       (A3)
00000D74  584F      1112          addq.w    #4,A7
00000D76  6012      1113          bra.s     DumpMemory_14
                    1114   DumpMemory_13:
                    1115   ; else
                    1116   ; putchar(RamPtr[j]);
00000D78  2043      1117          move.l    D3,A0
00000D7A  1230 2800 1118          move.b    0(A0,D2.L),D1
00000D7E  C2BC 0000 1119          and.l     #255,D1
00000D82  00FF      
00000D84  2F01      1120          move.l    D1,-(A7)
00000D86  4E93      1121          jsr       (A3)
00000D88  584F      1122          addq.w    #4,A7
                    1123   DumpMemory_14:
00000D8A  5282      1124          addq.l    #1,D2
00000D8C  60BE      1125          bra       DumpMemory_10
                    1126   DumpMemory_12:
                    1127   ; }
                    1128   ; RamPtr = RamPtr + 16;
00000D8E  0683 0000 1129          add.l     #16,D3
00000D92  0010      
00000D94  5285      1130          addq.l    #1,D5
00000D96  6000 FF64 1131          bra       DumpMemory_4
                    1132   DumpMemory_6:
                    1133   ; }
                    1134   ; printf("\r\n");
00000D9A  4879 0000 1135          pea       @m68kde~3_1.L
00000D9E  49D4      
00000DA0  4E92      1136          jsr       (A2)
00000DA2  584F      1137          addq.w    #4,A7
                    1138   ; c = _getch();
00000DA4  4EB8 0B68 1139          jsr       __getch
00000DA8  1800      1140          move.b    D0,D4
                    1141   ; if (c == 0x1b)          // break on ESC
00000DAA  0C04 001B 1142          cmp.b     #27,D4
00000DAE  6602      1143          bne.s     DumpMemory_16
                    1144   ; break;
00000DB0  6004      1145          bra.s     DumpMemory_3
                    1146   DumpMemory_16:
00000DB2  6000 FF46 1147          bra       DumpMemory_1
                    1148   DumpMemory_3:
00000DB6  4CDF 0C3C 1149          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DBA  4E75      1150          rts
                    1151   ; }
                    1152   ; }
                    1153   ; void FillMemory()
                    1154   ; {
                    1155   _FillMemory:
00000DBC  48E7 3820 1156          movem.l   D2/D3/D4/A2,-(A7)
00000DC0  45F9 0000 1157          lea       _printf.L,A2
00000DC4  4084      
                    1158   ; char* StartRamPtr, * EndRamPtr;
                    1159   ; unsigned char FillData;
                    1160   ; printf("\r\nFill Memory Block");
00000DC6  4879 0000 1161          pea       @m68kde~3_10.L
00000DCA  4A56      
00000DCC  4E92      1162          jsr       (A2)
00000DCE  584F      1163          addq.w    #4,A7
                    1164   ; printf("\r\nEnter Start Address: ");
00000DD0  4879 0000 1165          pea       @m68kde~3_6.L
00000DD4  4A2C      
00000DD6  4E92      1166          jsr       (A2)
00000DD8  584F      1167          addq.w    #4,A7
                    1168   ; StartRamPtr = Get8HexDigits(0);
00000DDA  42A7      1169          clr.l     -(A7)
00000DDC  4EB8 0CA4 1170          jsr       _Get8HexDigits
00000DE0  584F      1171          addq.w    #4,A7
00000DE2  2400      1172          move.l    D0,D2
                    1173   ; printf("\r\nEnter End Address: ");
00000DE4  4879 0000 1174          pea       @m68kde~3_11.L
00000DE8  4A6A      
00000DEA  4E92      1175          jsr       (A2)
00000DEC  584F      1176          addq.w    #4,A7
                    1177   ; EndRamPtr = Get8HexDigits(0);
00000DEE  42A7      1178          clr.l     -(A7)
00000DF0  4EB8 0CA4 1179          jsr       _Get8HexDigits
00000DF4  584F      1180          addq.w    #4,A7
00000DF6  2800      1181          move.l    D0,D4
                    1182   ; printf("\r\nEnter Fill Data: ");
00000DF8  4879 0000 1183          pea       @m68kde~3_12.L
00000DFC  4A80      
00000DFE  4E92      1184          jsr       (A2)
00000E00  584F      1185          addq.w    #4,A7
                    1186   ; FillData = Get2HexDigits(0);
00000E02  42A7      1187          clr.l     -(A7)
00000E04  4EB8 0C04 1188          jsr       _Get2HexDigits
00000E08  584F      1189          addq.w    #4,A7
00000E0A  1600      1190          move.b    D0,D3
                    1191   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData);
00000E0C  C6BC 0000 1192          and.l     #255,D3
00000E10  00FF      
00000E12  2F03      1193          move.l    D3,-(A7)
00000E14  2F04      1194          move.l    D4,-(A7)
00000E16  2F02      1195          move.l    D2,-(A7)
00000E18  4879 0000 1196          pea       @m68kde~3_13.L
00000E1C  4A94      
00000E1E  4E92      1197          jsr       (A2)
00000E20  DEFC 0010 1198          add.w     #16,A7
                    1199   ; while (StartRamPtr < EndRamPtr)
                    1200   FillMemory_1:
00000E24  B484      1201          cmp.l     D4,D2
00000E26  6408      1202          bhs.s     FillMemory_3
                    1203   ; *StartRamPtr++ = FillData;
00000E28  2042      1204          move.l    D2,A0
00000E2A  5282      1205          addq.l    #1,D2
00000E2C  1083      1206          move.b    D3,(A0)
00000E2E  60F4      1207          bra       FillMemory_1
                    1208   FillMemory_3:
00000E30  4CDF 041C 1209          movem.l   (A7)+,D2/D3/D4/A2
00000E34  4E75      1210          rts
                    1211   ; }
                    1212   ; void Load_SRecordFile()
                    1213   ; {
                    1214   _Load_SRecordFile:
00000E36  4E56 FFDC 1215          link      A6,#-36
00000E3A  48E7 3F3C 1216          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E3E  45EE FFFA 1217          lea       -6(A6),A2
00000E42  47F8 0C04 1218          lea       _Get2HexDigits.L,A3
00000E46  49F9 0000 1219          lea       _printf.L,A4
00000E4A  4084      
                    1220   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0;
00000E4C  42AE FFEE 1221          clr.l     -18(A6)
00000E50  3A7C 0000 1222          move.w    #0,A5
                    1223   ; int result, ByteCount;
                    1224   ; char c, CheckSum, ReadCheckSum, HeaderType;
                    1225   ; char* RamPtr;                          // pointer to Memory where downloaded program will be stored
                    1226   ; LoadFailed = 0;                        //assume LOAD operation will pass
00000E54  7E00      1227          moveq     #0,D7
                    1228   ; AddressFail = 0;
00000E56  42AE FFEA 1229          clr.l     -22(A6)
                    1230   ; Echo = 0;                              // don't echo S records during download
00000E5A  42B9 0B00 1231          clr.l     _Echo.L
00000E5E  00E0      
                    1232   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n");
00000E60  4879 0000 1233          pea       @m68kde~3_14.L
00000E64  4AC4      
00000E66  4E94      1234          jsr       (A4)
00000E68  584F      1235          addq.w    #4,A7
                    1236   ; while (1) {
                    1237   Load_SRecordFile_1:
                    1238   ; CheckSum = 0;
00000E6A  4212      1239          clr.b     (A2)
                    1240   ; do {
                    1241   Load_SRecordFile_4:
                    1242   ; c = toupper(_getch());
00000E6C  2F00      1243          move.l    D0,-(A7)
00000E6E  4EB8 0B68 1244          jsr       __getch
00000E72  2200      1245          move.l    D0,D1
00000E74  201F      1246          move.l    (A7)+,D0
00000E76  2F01      1247          move.l    D1,-(A7)
00000E78  4EB9 0000 1248          jsr       _toupper
00000E7C  4058      
00000E7E  584F      1249          addq.w    #4,A7
00000E80  1C00      1250          move.b    D0,D6
                    1251   ; if (c == 0x1b)      // if break
00000E82  0C06 001B 1252          cmp.b     #27,D6
00000E86  6604      1253          bne.s     Load_SRecordFile_6
                    1254   ; return;
00000E88  6000 0132 1255          bra       Load_SRecordFile_8
                    1256   Load_SRecordFile_6:
00000E8C  0C06 0053 1257          cmp.b     #83,D6
00000E90  66DA      1258          bne       Load_SRecordFile_4
                    1259   ; } while (c != (char)('S'));   // wait for S start of header
                    1260   ; HeaderType = _getch();
00000E92  4EB8 0B68 1261          jsr       __getch
00000E96  1600      1262          move.b    D0,D3
                    1263   ; if (HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000E98  0C03 0030 1264          cmp.b     #48,D3
00000E9C  6706      1265          beq.s     Load_SRecordFile_11
00000E9E  0C03 0035 1266          cmp.b     #53,D3
00000EA2  6604      1267          bne.s     Load_SRecordFile_9
                    1268   Load_SRecordFile_11:
                    1269   ; continue;
00000EA4  6000 00D2 1270          bra       Load_SRecordFile_23
                    1271   Load_SRecordFile_9:
                    1272   ; if (HeaderType >= (char)('7'))
00000EA8  0C03 0037 1273          cmp.b     #55,D3
00000EAC  6D04      1274          blt.s     Load_SRecordFile_12
                    1275   ; break;                 // end load on s7,s8,s9 records
00000EAE  6000 00CC 1276          bra       Load_SRecordFile_3
                    1277   Load_SRecordFile_12:
                    1278   ; // get the bytecount
                    1279   ; ByteCount = Get2HexDigits(&CheckSum);
00000EB2  2F0A      1280          move.l    A2,-(A7)
00000EB4  4E93      1281          jsr       (A3)
00000EB6  584F      1282          addq.w    #4,A7
00000EB8  2D40 FFF6 1283          move.l    D0,-10(A6)
                    1284   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1285   ; if (HeaderType == (char)('1')) {
00000EBC  0C03 0031 1286          cmp.b     #49,D3
00000EC0  660E      1287          bne.s     Load_SRecordFile_14
                    1288   ; AddressSize = 2;       // 2 byte address
00000EC2  7A02      1289          moveq     #2,D5
                    1290   ; Address = Get4HexDigits(&CheckSum);
00000EC4  2F0A      1291          move.l    A2,-(A7)
00000EC6  4EB8 0C58 1292          jsr       _Get4HexDigits
00000ECA  584F      1293          addq.w    #4,A7
00000ECC  2800      1294          move.l    D0,D4
00000ECE  6020      1295          bra.s     Load_SRecordFile_17
                    1296   Load_SRecordFile_14:
                    1297   ; }
                    1298   ; else if (HeaderType == (char)('2')) {
00000ED0  0C03 0032 1299          cmp.b     #50,D3
00000ED4  660E      1300          bne.s     Load_SRecordFile_16
                    1301   ; AddressSize = 3;       // 3 byte address
00000ED6  7A03      1302          moveq     #3,D5
                    1303   ; Address = Get6HexDigits(&CheckSum);
00000ED8  2F0A      1304          move.l    A2,-(A7)
00000EDA  4EB8 0C7E 1305          jsr       _Get6HexDigits
00000EDE  584F      1306          addq.w    #4,A7
00000EE0  2800      1307          move.l    D0,D4
00000EE2  600C      1308          bra.s     Load_SRecordFile_17
                    1309   Load_SRecordFile_16:
                    1310   ; }
                    1311   ; else {
                    1312   ; AddressSize = 4;       // 4 byte address
00000EE4  7A04      1313          moveq     #4,D5
                    1314   ; Address = Get8HexDigits(&CheckSum);
00000EE6  2F0A      1315          move.l    A2,-(A7)
00000EE8  4EB8 0CA4 1316          jsr       _Get8HexDigits
00000EEC  584F      1317          addq.w    #4,A7
00000EEE  2800      1318          move.l    D0,D4
                    1319   Load_SRecordFile_17:
                    1320   ; }
                    1321   ; RamPtr = (char*)(Address);                            // point to download area
00000EF0  2D44 FFFC 1322          move.l    D4,-4(A6)
                    1323   ; NumDataBytesToRead = ByteCount - AddressSize - 1;
00000EF4  202E FFF6 1324          move.l    -10(A6),D0
00000EF8  9085      1325          sub.l     D5,D0
00000EFA  5380      1326          subq.l    #1,D0
00000EFC  2D40 FFE2 1327          move.l    D0,-30(A6)
                    1328   ; for (i = 0; i < NumDataBytesToRead; i++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F00  4282      1329          clr.l     D2
                    1330   Load_SRecordFile_18:
00000F02  B4AE FFE2 1331          cmp.l     -30(A6),D2
00000F06  6C1E      1332          bge.s     Load_SRecordFile_20
                    1333   ; DataByte = Get2HexDigits(&CheckSum);
00000F08  2F0A      1334          move.l    A2,-(A7)
00000F0A  4E93      1335          jsr       (A3)
00000F0C  584F      1336          addq.w    #4,A7
00000F0E  2D40 FFDE 1337          move.l    D0,-34(A6)
                    1338   ; *RamPtr++ = DataByte;                      // store downloaded byte in Ram at specified address
00000F12  202E FFDE 1339          move.l    -34(A6),D0
00000F16  206E FFFC 1340          move.l    -4(A6),A0
00000F1A  52AE FFFC 1341          addq.l    #1,-4(A6)
00000F1E  1080      1342          move.b    D0,(A0)
                    1343   ; ByteTotal++;
00000F20  524D      1344          addq.w    #1,A5
00000F22  5282      1345          addq.l    #1,D2
00000F24  60DC      1346          bra       Load_SRecordFile_18
                    1347   Load_SRecordFile_20:
                    1348   ; }
                    1349   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1350   ; ReadCheckSum = Get2HexDigits(0);
00000F26  42A7      1351          clr.l     -(A7)
00000F28  4E93      1352          jsr       (A3)
00000F2A  584F      1353          addq.w    #4,A7
00000F2C  1D40 FFFB 1354          move.b    D0,-5(A6)
                    1355   ; if ((~CheckSum & 0Xff) != (ReadCheckSum & 0Xff)) {
00000F30  1012      1356          move.b    (A2),D0
00000F32  4600      1357          not.b     D0
00000F34  4880      1358          ext.w     D0
00000F36  C07C 00FF 1359          and.w     #255,D0
00000F3A  122E FFFB 1360          move.b    -5(A6),D1
00000F3E  4881      1361          ext.w     D1
00000F40  C27C 00FF 1362          and.w     #255,D1
00000F44  B041      1363          cmp.w     D1,D0
00000F46  6708      1364          beq.s     Load_SRecordFile_21
                    1365   ; LoadFailed = 1;
00000F48  7E01      1366          moveq     #1,D7
                    1367   ; FailedAddress = Address;
00000F4A  2D44 FFE6 1368          move.l    D4,-26(A6)
                    1369   ; break;
00000F4E  602C      1370          bra.s     Load_SRecordFile_3
                    1371   Load_SRecordFile_21:
                    1372   ; }
                    1373   ; SRecordCount++;
00000F50  52AE FFEE 1374          addq.l    #1,-18(A6)
                    1375   ; // display feedback on progress
                    1376   ; if (SRecordCount % 25 == 0)
00000F54  2F2E FFEE 1377          move.l    -18(A6),-(A7)
00000F58  4878 0019 1378          pea       25
00000F5C  4EB9 0000 1379          jsr       LDIV
00000F60  3EAA      
00000F62  202F 0004 1380          move.l    4(A7),D0
00000F66  504F      1381          addq.w    #8,A7
00000F68  4A80      1382          tst.l     D0
00000F6A  660C      1383          bne.s     Load_SRecordFile_23
                    1384   ; putchar('.');
00000F6C  4878 002E 1385          pea       46
00000F70  4EB9 0000 1386          jsr       _putch
00000F74  3F76      
00000F76  584F      1387          addq.w    #4,A7
                    1388   Load_SRecordFile_23:
00000F78  6000 FEF0 1389          bra       Load_SRecordFile_1
                    1390   Load_SRecordFile_3:
                    1391   ; }
                    1392   ; if (LoadFailed == 1) {
00000F7C  0C87 0000 1393          cmp.l     #1,D7
00000F80  0001      
00000F82  6610      1394          bne.s     Load_SRecordFile_25
                    1395   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress);
00000F84  2F2E FFE6 1396          move.l    -26(A6),-(A7)
00000F88  4879 0000 1397          pea       @m68kde~3_15.L
00000F8C  4AF4      
00000F8E  4E94      1398          jsr       (A4)
00000F90  504F      1399          addq.w    #8,A7
00000F92  600C      1400          bra.s     Load_SRecordFile_26
                    1401   Load_SRecordFile_25:
                    1402   ; }
                    1403   ; else
                    1404   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal);
00000F94  2F0D      1405          move.l    A5,-(A7)
00000F96  4879 0000 1406          pea       @m68kde~3_16.L
00000F9A  4B1A      
00000F9C  4E94      1407          jsr       (A4)
00000F9E  504F      1408          addq.w    #8,A7
                    1409   Load_SRecordFile_26:
                    1410   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1411   ; for (i = 0; i < 400000; i++)
00000FA0  4282      1412          clr.l     D2
                    1413   Load_SRecordFile_27:
00000FA2  0C82 0006 1414          cmp.l     #400000,D2
00000FA6  1A80      
00000FA8  6C04      1415          bge.s     Load_SRecordFile_29
00000FAA  5282      1416          addq.l    #1,D2
00000FAC  60F4      1417          bra       Load_SRecordFile_27
                    1418   Load_SRecordFile_29:
                    1419   ; ;
                    1420   ; FlushKeyboard();
00000FAE  4EB8 0BA6 1421          jsr       _FlushKeyboard
                    1422   ; Echo = 1;
00000FB2  23FC 0000 1423          move.l    #1,_Echo.L
00000FB6  0001 0B00 
00000FBA  00E0      
                    1424   Load_SRecordFile_8:
00000FBC  4CDF 3CFC 1425          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FC0  4E5E      1426          unlk      A6
00000FC2  4E75      1427          rts
                    1428   ; }
                    1429   ; void MemoryChange(void)
                    1430   ; {
                    1431   _MemoryChange:
00000FC4  48E7 3820 1432          movem.l   D2/D3/D4/A2,-(A7)
00000FC8  45F9 0000 1433          lea       _printf.L,A2
00000FCC  4084      
                    1434   ; unsigned char* RamPtr, c; // pointer to memory
                    1435   ; int Data;
                    1436   ; printf("\r\nExamine and Change Memory");
00000FCE  4879 0000 1437          pea       @m68kde~3_17.L
00000FD2  4B3C      
00000FD4  4E92      1438          jsr       (A2)
00000FD6  584F      1439          addq.w    #4,A7
                    1440   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change");
00000FD8  4879 0000 1441          pea       @m68kde~3_18.L
00000FDC  4B58      
00000FDE  4E92      1442          jsr       (A2)
00000FE0  584F      1443          addq.w    #4,A7
                    1444   ; printf("\r\nEnter Address: ");
00000FE2  4879 0000 1445          pea       @m68kde~3_19.L
00000FE6  4B9E      
00000FE8  4E92      1446          jsr       (A2)
00000FEA  584F      1447          addq.w    #4,A7
                    1448   ; RamPtr = Get8HexDigits(0);
00000FEC  42A7      1449          clr.l     -(A7)
00000FEE  4EB8 0CA4 1450          jsr       _Get8HexDigits
00000FF2  584F      1451          addq.w    #4,A7
00000FF4  2600      1452          move.l    D0,D3
                    1453   ; while (1) {
                    1454   MemoryChange_1:
                    1455   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr);
00000FF6  2043      1456          move.l    D3,A0
00000FF8  1210      1457          move.b    (A0),D1
00000FFA  C2BC 0000 1458          and.l     #255,D1
00000FFE  00FF      
00001000  2F01      1459          move.l    D1,-(A7)
00001002  2F03      1460          move.l    D3,-(A7)
00001004  4879 0000 1461          pea       @m68kde~3_20.L
00001008  4BB0      
0000100A  4E92      1462          jsr       (A2)
0000100C  DEFC 000C 1463          add.w     #12,A7
                    1464   ; c = tolower(_getch());
00001010  2F00      1465          move.l    D0,-(A7)
00001012  4EB8 0B68 1466          jsr       __getch
00001016  2200      1467          move.l    D0,D1
00001018  201F      1468          move.l    (A7)+,D0
0000101A  2F01      1469          move.l    D1,-(A7)
0000101C  4EB9 0000 1470          jsr       _tolower
00001020  3FE2      
00001022  584F      1471          addq.w    #4,A7
00001024  1400      1472          move.b    D0,D2
                    1473   ; if (c == (char)(0x1b))
00001026  0C02 001B 1474          cmp.b     #27,D2
0000102A  6604      1475          bne.s     MemoryChange_4
                    1476   ; return;                                // abort on escape
0000102C  6000 0090 1477          bra       MemoryChange_6
                    1478   MemoryChange_4:
                    1479   ; else if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001030  0C02 0030 1480          cmp.b     #48,D2
00001034  6506      1481          blo.s     MemoryChange_10
00001036  0C02 0039 1482          cmp.b     #57,D2
0000103A  6310      1483          bls.s     MemoryChange_9
                    1484   MemoryChange_10:
0000103C  0C02 0061 1485          cmp.b     #97,D2
00001040  6500 006E 1486          blo       MemoryChange_7
00001044  0C02 0066 1487          cmp.b     #102,D2
00001048  6200 0066 1488          bhi       MemoryChange_7
                    1489   MemoryChange_9:
                    1490   ; Data = (xtod(c) << 4) | (xtod(_getch()));
0000104C  C4BC 0000 1491          and.l     #255,D2
00001050  00FF      
00001052  2F02      1492          move.l    D2,-(A7)
00001054  4EB8 0BD2 1493          jsr       _xtod
00001058  584F      1494          addq.w    #4,A7
0000105A  C0BC 0000 1495          and.l     #255,D0
0000105E  00FF      
00001060  E980      1496          asl.l     #4,D0
00001062  2F00      1497          move.l    D0,-(A7)
00001064  2F01      1498          move.l    D1,-(A7)
00001066  4EB8 0B68 1499          jsr       __getch
0000106A  221F      1500          move.l    (A7)+,D1
0000106C  2F00      1501          move.l    D0,-(A7)
0000106E  4EB8 0BD2 1502          jsr       _xtod
00001072  584F      1503          addq.w    #4,A7
00001074  2200      1504          move.l    D0,D1
00001076  201F      1505          move.l    (A7)+,D0
00001078  C2BC 0000 1506          and.l     #255,D1
0000107C  00FF      
0000107E  8081      1507          or.l      D1,D0
00001080  2800      1508          move.l    D0,D4
                    1509   ; *RamPtr = (char)(Data);
00001082  2043      1510          move.l    D3,A0
00001084  1084      1511          move.b    D4,(A0)
                    1512   ; if (*RamPtr != Data) {
00001086  2043      1513          move.l    D3,A0
00001088  1010      1514          move.b    (A0),D0
0000108A  C0BC 0000 1515          and.l     #255,D0
0000108E  00FF      
00001090  B084      1516          cmp.l     D4,D0
00001092  671A      1517          beq.s     MemoryChange_11
                    1518   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr);
00001094  2043      1519          move.l    D3,A0
00001096  1210      1520          move.b    (A0),D1
00001098  C2BC 0000 1521          and.l     #255,D1
0000109C  00FF      
0000109E  2F01      1522          move.l    D1,-(A7)
000010A0  2F04      1523          move.l    D4,-(A7)
000010A2  4879 0000 1524          pea       @m68kde~3_21.L
000010A6  4BC2      
000010A8  4E92      1525          jsr       (A2)
000010AA  DEFC 000C 1526          add.w     #12,A7
                    1527   MemoryChange_11:
000010AE  6008      1528          bra.s     MemoryChange_13
                    1529   MemoryChange_7:
                    1530   ; }
                    1531   ; }
                    1532   ; else if (c == (char)('-'))
000010B0  0C02 002D 1533          cmp.b     #45,D2
000010B4  6602      1534          bne.s     MemoryChange_13
                    1535   ; RamPtr -= 2; ;
000010B6  5583      1536          subq.l    #2,D3
                    1537   MemoryChange_13:
                    1538   ; RamPtr++;
000010B8  5283      1539          addq.l    #1,D3
000010BA  6000 FF3A 1540          bra       MemoryChange_1
                    1541   MemoryChange_6:
000010BE  4CDF 041C 1542          movem.l   (A7)+,D2/D3/D4/A2
000010C2  4E75      1543          rts
                    1544   ; }
                    1545   ; }
                    1546   ; /*******************************************************************
                    1547   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1548   ; ********************************************************************/
                    1549   ; void ProgramFlashChip(void)
                    1550   ; {
                    1551   _ProgramFlashChip:
000010C4  48E7 3C20 1552          movem.l   D2/D3/D4/D5/A2,-(A7)
000010C8  45F9 0000 1553          lea       _printf.L,A2
000010CC  4084      
                    1554   ; int count;
                    1555   ; unsigned char *Memaddress;
                    1556   ; int check;
                    1557   ; unsigned char a;
                    1558   ; printf("\r\nProgramming SPI Flash....");
000010CE  4879 0000 1559          pea       @m68kde~3_22.L
000010D2  4BF6      
000010D4  4E92      1560          jsr       (A2)
000010D6  584F      1561          addq.w    #4,A7
                    1562   ; //
                    1563   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1564   ; // TODO : then verify by reading it back and comparing to memory
                    1565   ; //
                    1566   ; //Erase the flash memory first
                    1567   ; EraseSPIFlashChip();
000010D8  4EB9 0000 1568          jsr       _EraseSPIFlashChip
000010DC  3C34      
                    1569   ; //Program from RAM to SPI flash chip
                    1570   ; WriteSPIFlashData(0, 0x08000000, 256 * 1000);
000010DE  4879 0003 1571          pea       256000
000010E2  E800      
000010E4  4879 0800 1572          pea       134217728
000010E8  0000      
000010EA  42A7      1573          clr.l     -(A7)
000010EC  4EB9 0000 1574          jsr       _WriteSPIFlashData
000010F0  3C96      
000010F2  DEFC 000C 1575          add.w     #12,A7
                    1576   ; Memaddress = 0x08000000;
000010F6  263C 0800 1577          move.l    #134217728,D3
000010FA  0000      
                    1578   ; check = 0;
000010FC  4285      1579          clr.l     D5
                    1580   ; for(count=0;count<256000;count++){
000010FE  4282      1581          clr.l     D2
                    1582   ProgramFlashChip_1:
00001100  0C82 0003 1583          cmp.l     #256000,D2
00001104  E800      
00001106  6C00 0040 1584          bge       ProgramFlashChip_3
                    1585   ; a = ReadSPIFlashByte(count);
0000110A  2F02      1586          move.l    D2,-(A7)
0000110C  4EB9 0000 1587          jsr       _ReadSPIFlashByte
00001110  3E06      
00001112  584F      1588          addq.w    #4,A7
00001114  1800      1589          move.b    D0,D4
                    1590   ; if(*Memaddress != a){
00001116  2043      1591          move.l    D3,A0
00001118  B810      1592          cmp.b     (A0),D4
0000111A  6726      1593          beq.s     ProgramFlashChip_4
                    1594   ; printf("\r\nThe value %x at address %x in SDRAM is not equal to the value %x at Flash Address %x",*Memaddress,Memaddress,a,count);
0000111C  2F02      1595          move.l    D2,-(A7)
0000111E  C8BC 0000 1596          and.l     #255,D4
00001122  00FF      
00001124  2F04      1597          move.l    D4,-(A7)
00001126  2F03      1598          move.l    D3,-(A7)
00001128  2043      1599          move.l    D3,A0
0000112A  1210      1600          move.b    (A0),D1
0000112C  C2BC 0000 1601          and.l     #255,D1
00001130  00FF      
00001132  2F01      1602          move.l    D1,-(A7)
00001134  4879 0000 1603          pea       @m68kde~3_23.L
00001138  4C12      
0000113A  4E92      1604          jsr       (A2)
0000113C  DEFC 0014 1605          add.w     #20,A7
                    1606   ; check++;
00001140  5285      1607          addq.l    #1,D5
                    1608   ProgramFlashChip_4:
                    1609   ; }
                    1610   ; Memaddress++;
00001142  5283      1611          addq.l    #1,D3
00001144  5282      1612          addq.l    #1,D2
00001146  60B8      1613          bra       ProgramFlashChip_1
                    1614   ProgramFlashChip_3:
                    1615   ; }
                    1616   ; if(check == 0){
00001148  4A85      1617          tst.l     D5
0000114A  660A      1618          bne.s     ProgramFlashChip_6
                    1619   ; printf("\r\nAll addresses have been copied into SPI Flash correctly");
0000114C  4879 0000 1620          pea       @m68kde~3_24.L
00001150  4C6A      
00001152  4E92      1621          jsr       (A2)
00001154  584F      1622          addq.w    #4,A7
                    1623   ProgramFlashChip_6:
00001156  4CDF 043C 1624          movem.l   (A7)+,D2/D3/D4/D5/A2
0000115A  4E75      1625          rts
                    1626   ; }
                    1627   ; }
                    1628   ; /*************************************************************************
                    1629   ; ** Load a program from SPI Flash Chip and copy to Dram
                    1630   ; **************************************************************************/
                    1631   ; void LoadFromFlashChip(void)
                    1632   ; {
                    1633   _LoadFromFlashChip:
0000115C  48E7 3000 1634          movem.l   D2/D3,-(A7)
                    1635   ; unsigned char *Memaddress;
                    1636   ; int count;
                    1637   ; Memaddress = 0x08000000;
00001160  263C 0800 1638          move.l    #134217728,D3
00001164  0000      
                    1639   ; printf("\r\nLoading Program From SPI Flash....");
00001166  4879 0000 1640          pea       @m68kde~3_25.L
0000116A  4CA4      
0000116C  4EB9 0000 1641          jsr       _printf
00001170  4084      
00001172  584F      1642          addq.w    #4,A7
                    1643   ; for (count=0;count<256000;count++){
00001174  4282      1644          clr.l     D2
                    1645   LoadFromFlashChip_1:
00001176  0C82 0003 1646          cmp.l     #256000,D2
0000117A  E800      
0000117C  6C14      1647          bge.s     LoadFromFlashChip_3
                    1648   ; *Memaddress = ReadSPIFlashByte(count);
0000117E  2F02      1649          move.l    D2,-(A7)
00001180  4EB9 0000 1650          jsr       _ReadSPIFlashByte
00001184  3E06      
00001186  584F      1651          addq.w    #4,A7
00001188  2043      1652          move.l    D3,A0
0000118A  1080      1653          move.b    D0,(A0)
                    1654   ; Memaddress++;
0000118C  5283      1655          addq.l    #1,D3
0000118E  5282      1656          addq.l    #1,D2
00001190  60E4      1657          bra       LoadFromFlashChip_1
                    1658   LoadFromFlashChip_3:
                    1659   ; }
                    1660   ; printf("\r\nProgram done loading");
00001192  4879 0000 1661          pea       @m68kde~3_26.L
00001196  4CCA      
00001198  4EB9 0000 1662          jsr       _printf
0000119C  4084      
0000119E  584F      1663          addq.w    #4,A7
000011A0  4CDF 000C 1664          movem.l   (A7)+,D2/D3
000011A4  4E75      1665          rts
                    1666   ; //
                    1667   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    1668   ; //
                    1669   ; // ReadSPIFlashData(0, 0x08000000, 256 * 1000);
                    1670   ; }
                    1671   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    1672   ; // IMPORTANT
                    1673   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    1674   ; // has to be done with an interrupt (IRQ Level 6)
                    1675   ; //
                    1676   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    1677   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    1678   ; //
                    1679   ; // on return from the IRQ service handler, the first access to the user memory program space
                    1680   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    1681   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    1682   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    1683   ; // program area
                    1684   ; //
                    1685   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    1686   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    1687   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    1688   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    1689   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    1690   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    1691   ; void DumpRegisters()
                    1692   ; {
                    1693   _DumpRegisters:
000011A6  48E7 3F3C 1694          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000011AA  45F9 0000 1695          lea       _putch.L,A2
000011AE  3F76      
000011B0  47F9 0000 1696          lea       _printf.L,A3
000011B4  4084      
000011B6  49F9 0B00 1697          lea       _SR.L,A4
000011BA  012C      
000011BC  4BF9 0B00 1698          lea       _WatchPointString.L,A5
000011C0  01C2      
                    1699   ; short i, x, j, k;
                    1700   ; unsigned char c, * BytePointer;
                    1701   ; // buld up strings for displaying watchpoints
                    1702   ; for (x = 0; x < (short)(8); x++)
000011C2  4242      1703          clr.w     D2
                    1704   DumpRegisters_1:
000011C4  0C42 0008 1705          cmp.w     #8,D2
000011C8  6C00 01C6 1706          bge       DumpRegisters_3
                    1707   ; {
                    1708   ; if (WatchPointSetOrCleared[x] == 1)
000011CC  48C2      1709          ext.l     D2
000011CE  2002      1710          move.l    D2,D0
000011D0  E588      1711          lsl.l     #2,D0
000011D2  41F9 0B00 1712          lea       _WatchPointSetOrCleared.L,A0
000011D6  01A2      
000011D8  2030 0800 1713          move.l    0(A0,D0.L),D0
000011DC  0C80 0000 1714          cmp.l     #1,D0
000011E0  0001      
000011E2  6600 0186 1715          bne       DumpRegisters_4
                    1716   ; {
                    1717   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]);
000011E6  48C2      1718          ext.l     D2
000011E8  2202      1719          move.l    D2,D1
000011EA  E589      1720          lsl.l     #2,D1
000011EC  41F9 0B00 1721          lea       _WatchPointAddress.L,A0
000011F0  0182      
000011F2  2F30 1800 1722          move.l    0(A0,D1.L),-(A7)
000011F6  4879 0000 1723          pea       @m68kde~3_27.L
000011FA  4CE2      
000011FC  220D      1724          move.l    A5,D1
000011FE  48C2      1725          ext.l     D2
00001200  2F00      1726          move.l    D0,-(A7)
00001202  2002      1727          move.l    D2,D0
00001204  C1FC 0064 1728          muls      #100,D0
00001208  D280      1729          add.l     D0,D1
0000120A  201F      1730          move.l    (A7)+,D0
0000120C  2F01      1731          move.l    D1,-(A7)
0000120E  4EB9 0000 1732          jsr       _sprintf
00001212  400E      
00001214  DEFC 000C 1733          add.w     #12,A7
                    1734   ; BytePointer = (char*)(WatchPointAddress[x]);
00001218  48C2      1735          ext.l     D2
0000121A  2002      1736          move.l    D2,D0
0000121C  E588      1737          lsl.l     #2,D0
0000121E  41F9 0B00 1738          lea       _WatchPointAddress.L,A0
00001222  0182      
00001224  2A30 0800 1739          move.l    0(A0,D0.L),D5
                    1740   ; for (j = 0; j < (short)(16); j += 2)
00001228  4243      1741          clr.w     D3
                    1742   DumpRegisters_6:
0000122A  0C43 0010 1743          cmp.w     #16,D3
0000122E  6C00 0082 1744          bge       DumpRegisters_8
                    1745   ; {
                    1746   ; for (k = 0; k < (short)(2); k++)
00001232  4246      1747          clr.w     D6
                    1748   DumpRegisters_9:
00001234  0C46 0002 1749          cmp.w     #2,D6
00001238  6C00 0052 1750          bge       DumpRegisters_11
                    1751   ; {
                    1752   ; sprintf(TempString, "%02X", BytePointer[j + k]);
0000123C  2045      1753          move.l    D5,A0
0000123E  48C3      1754          ext.l     D3
00001240  2203      1755          move.l    D3,D1
00001242  48C6      1756          ext.l     D6
00001244  D286      1757          add.l     D6,D1
00001246  1230 1800 1758          move.b    0(A0,D1.L),D1
0000124A  C2BC 0000 1759          and.l     #255,D1
0000124E  00FF      
00001250  2F01      1760          move.l    D1,-(A7)
00001252  4879 0000 1761          pea       @m68kde~3_8.L
00001256  4A4C      
00001258  4879 0B00 1762          pea       _TempString.L
0000125C  04E2      
0000125E  4EB9 0000 1763          jsr       _sprintf
00001262  400E      
00001264  DEFC 000C 1764          add.w     #12,A7
                    1765   ; strcat(WatchPointString[x], TempString);
00001268  4879 0B00 1766          pea       _TempString.L
0000126C  04E2      
0000126E  220D      1767          move.l    A5,D1
00001270  48C2      1768          ext.l     D2
00001272  2F00      1769          move.l    D0,-(A7)
00001274  2002      1770          move.l    D2,D0
00001276  C1FC 0064 1771          muls      #100,D0
0000127A  D280      1772          add.l     D0,D1
0000127C  201F      1773          move.l    (A7)+,D0
0000127E  2F01      1774          move.l    D1,-(A7)
00001280  4EB9 0000 1775          jsr       _strcat
00001284  4042      
00001286  504F      1776          addq.w    #8,A7
00001288  5246      1777          addq.w    #1,D6
0000128A  60A8      1778          bra       DumpRegisters_9
                    1779   DumpRegisters_11:
                    1780   ; }
                    1781   ; strcat(WatchPointString[x], " ");
0000128C  4879 0000 1782          pea       @m68kde~3_28.L
00001290  4CEA      
00001292  220D      1783          move.l    A5,D1
00001294  48C2      1784          ext.l     D2
00001296  2F00      1785          move.l    D0,-(A7)
00001298  2002      1786          move.l    D2,D0
0000129A  C1FC 0064 1787          muls      #100,D0
0000129E  D280      1788          add.l     D0,D1
000012A0  201F      1789          move.l    (A7)+,D0
000012A2  2F01      1790          move.l    D1,-(A7)
000012A4  4EB9 0000 1791          jsr       _strcat
000012A8  4042      
000012AA  504F      1792          addq.w    #8,A7
000012AC  5443      1793          addq.w    #2,D3
000012AE  6000 FF7A 1794          bra       DumpRegisters_6
                    1795   DumpRegisters_8:
                    1796   ; }
                    1797   ; strcat(WatchPointString[x], "  ");
000012B2  4879 0000 1798          pea       @m68kde~3_9.L
000012B6  4A52      
000012B8  220D      1799          move.l    A5,D1
000012BA  48C2      1800          ext.l     D2
000012BC  2F00      1801          move.l    D0,-(A7)
000012BE  2002      1802          move.l    D2,D0
000012C0  C1FC 0064 1803          muls      #100,D0
000012C4  D280      1804          add.l     D0,D1
000012C6  201F      1805          move.l    (A7)+,D0
000012C8  2F01      1806          move.l    D1,-(A7)
000012CA  4EB9 0000 1807          jsr       _strcat
000012CE  4042      
000012D0  504F      1808          addq.w    #8,A7
                    1809   ; BytePointer = (char*)(WatchPointAddress[x]);
000012D2  48C2      1810          ext.l     D2
000012D4  2002      1811          move.l    D2,D0
000012D6  E588      1812          lsl.l     #2,D0
000012D8  41F9 0B00 1813          lea       _WatchPointAddress.L,A0
000012DC  0182      
000012DE  2A30 0800 1814          move.l    0(A0,D0.L),D5
                    1815   ; for (j = 0; j < (short)(16); j++)
000012E2  4243      1816          clr.w     D3
                    1817   DumpRegisters_12:
000012E4  0C43 0010 1818          cmp.w     #16,D3
000012E8  6C00 007E 1819          bge       DumpRegisters_14
                    1820   ; {
                    1821   ; c = ((char)(BytePointer[j]) & 0x7f);
000012EC  2045      1822          move.l    D5,A0
000012EE  48C3      1823          ext.l     D3
000012F0  1030 3800 1824          move.b    0(A0,D3.L),D0
000012F4  C03C 007F 1825          and.b     #127,D0
000012F8  1E00      1826          move.b    D0,D7
                    1827   ; if ((c > (char)(0x7f)) || (c < (char)(' ')))
000012FA  0C07 007F 1828          cmp.b     #127,D7
000012FE  6206      1829          bhi.s     DumpRegisters_17
00001300  0C07 0020 1830          cmp.b     #32,D7
00001304  6416      1831          bhs.s     DumpRegisters_15
                    1832   DumpRegisters_17:
                    1833   ; sprintf(TempString, ".");
00001306  4879 0000 1834          pea       @m68kde~3_29.L
0000130A  4CEC      
0000130C  4879 0B00 1835          pea       _TempString.L
00001310  04E2      
00001312  4EB9 0000 1836          jsr       _sprintf
00001316  400E      
00001318  504F      1837          addq.w    #8,A7
0000131A  6026      1838          bra.s     DumpRegisters_16
                    1839   DumpRegisters_15:
                    1840   ; else
                    1841   ; sprintf(TempString, "%c", BytePointer[j]);
0000131C  2045      1842          move.l    D5,A0
0000131E  48C3      1843          ext.l     D3
00001320  1230 3800 1844          move.b    0(A0,D3.L),D1
00001324  C2BC 0000 1845          and.l     #255,D1
00001328  00FF      
0000132A  2F01      1846          move.l    D1,-(A7)
0000132C  4879 0000 1847          pea       @m68kde~3_30.L
00001330  4CEE      
00001332  4879 0B00 1848          pea       _TempString.L
00001336  04E2      
00001338  4EB9 0000 1849          jsr       _sprintf
0000133C  400E      
0000133E  DEFC 000C 1850          add.w     #12,A7
                    1851   DumpRegisters_16:
                    1852   ; strcat(WatchPointString[x], TempString);
00001342  4879 0B00 1853          pea       _TempString.L
00001346  04E2      
00001348  220D      1854          move.l    A5,D1
0000134A  48C2      1855          ext.l     D2
0000134C  2F00      1856          move.l    D0,-(A7)
0000134E  2002      1857          move.l    D2,D0
00001350  C1FC 0064 1858          muls      #100,D0
00001354  D280      1859          add.l     D0,D1
00001356  201F      1860          move.l    (A7)+,D0
00001358  2F01      1861          move.l    D1,-(A7)
0000135A  4EB9 0000 1862          jsr       _strcat
0000135E  4042      
00001360  504F      1863          addq.w    #8,A7
00001362  5243      1864          addq.w    #1,D3
00001364  6000 FF7E 1865          bra       DumpRegisters_12
                    1866   DumpRegisters_14:
00001368  6020      1867          bra.s     DumpRegisters_5
                    1868   DumpRegisters_4:
                    1869   ; }
                    1870   ; }
                    1871   ; else
                    1872   ; strcpy(WatchPointString[x], "");
0000136A  4879 0000 1873          pea       @m68kde~3_31.L
0000136E  4CF2      
00001370  220D      1874          move.l    A5,D1
00001372  48C2      1875          ext.l     D2
00001374  2F00      1876          move.l    D0,-(A7)
00001376  2002      1877          move.l    D2,D0
00001378  C1FC 0064 1878          muls      #100,D0
0000137C  D280      1879          add.l     D0,D1
0000137E  201F      1880          move.l    (A7)+,D0
00001380  2F01      1881          move.l    D1,-(A7)
00001382  4EB9 0000 1882          jsr       _strcpy
00001386  3E88      
00001388  504F      1883          addq.w    #8,A7
                    1884   DumpRegisters_5:
0000138A  5242      1885          addq.w    #1,D2
0000138C  6000 FE36 1886          bra       DumpRegisters_1
                    1887   DumpRegisters_3:
                    1888   ; }
                    1889   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X", d0, a0);
00001390  2F39 0B00 1890          move.l    _a0.L,-(A7)
00001394  0104      
00001396  2F39 0B00 1891          move.l    _d0.L,-(A7)
0000139A  00E4      
0000139C  4879 0000 1892          pea       @m68kde~3_32.L
000013A0  4CF4      
000013A2  4E93      1893          jsr       (A3)
000013A4  DEFC 000C 1894          add.w     #12,A7
                    1895   ; printf("\r\n D1 = $%08X  A1 = $%08X", d1, a1);
000013A8  2F39 0B00 1896          move.l    _a1.L,-(A7)
000013AC  0108      
000013AE  2F39 0B00 1897          move.l    _d1.L,-(A7)
000013B2  00E8      
000013B4  4879 0000 1898          pea       @m68kde~3_33.L
000013B8  4D10      
000013BA  4E93      1899          jsr       (A3)
000013BC  DEFC 000C 1900          add.w     #12,A7
                    1901   ; printf("\r\n D2 = $%08X  A2 = $%08X", d2, a2);
000013C0  2F39 0B00 1902          move.l    _a2.L,-(A7)
000013C4  010C      
000013C6  2F39 0B00 1903          move.l    _d2.L,-(A7)
000013CA  00EC      
000013CC  4879 0000 1904          pea       @m68kde~3_34.L
000013D0  4D2A      
000013D2  4E93      1905          jsr       (A3)
000013D4  DEFC 000C 1906          add.w     #12,A7
                    1907   ; printf("\r\n D3 = $%08X  A3 = $%08X", d3, a3);
000013D8  2F39 0B00 1908          move.l    _a3.L,-(A7)
000013DC  0110      
000013DE  2F39 0B00 1909          move.l    _d3.L,-(A7)
000013E2  00F0      
000013E4  4879 0000 1910          pea       @m68kde~3_35.L
000013E8  4D44      
000013EA  4E93      1911          jsr       (A3)
000013EC  DEFC 000C 1912          add.w     #12,A7
                    1913   ; printf("\r\n D4 = $%08X  A4 = $%08X", d4, a4);
000013F0  2F39 0B00 1914          move.l    _a4.L,-(A7)
000013F4  0114      
000013F6  2F39 0B00 1915          move.l    _d4.L,-(A7)
000013FA  00F4      
000013FC  4879 0000 1916          pea       @m68kde~3_36.L
00001400  4D5E      
00001402  4E93      1917          jsr       (A3)
00001404  DEFC 000C 1918          add.w     #12,A7
                    1919   ; printf("\r\n D5 = $%08X  A5 = $%08X", d5, a5);
00001408  2F39 0B00 1920          move.l    _a5.L,-(A7)
0000140C  0118      
0000140E  2F39 0B00 1921          move.l    _d5.L,-(A7)
00001412  00F8      
00001414  4879 0000 1922          pea       @m68kde~3_37.L
00001418  4D78      
0000141A  4E93      1923          jsr       (A3)
0000141C  DEFC 000C 1924          add.w     #12,A7
                    1925   ; printf("\r\n D6 = $%08X  A6 = $%08X", d6, a6);
00001420  2F39 0B00 1926          move.l    _a6.L,-(A7)
00001424  011C      
00001426  2F39 0B00 1927          move.l    _d6.L,-(A7)
0000142A  00FC      
0000142C  4879 0000 1928          pea       @m68kde~3_38.L
00001430  4D92      
00001432  4E93      1929          jsr       (A3)
00001434  DEFC 000C 1930          add.w     #12,A7
                    1931   ; printf("\r\n D7 = $%08X  A7 = $%08X", d7, ((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP);
00001438  3214      1932          move.w    (A4),D1
0000143A  C27C 2000 1933          and.w     #8192,D1
0000143E  0C41 2000 1934          cmp.w     #8192,D1
00001442  6608      1935          bne.s     DumpRegisters_18
00001444  2239 0B00 1936          move.l    _SSP.L,D1
00001448  0124      
0000144A  6006      1937          bra.s     DumpRegisters_19
                    1938   DumpRegisters_18:
0000144C  2239 0B00 1939          move.l    _USP.L,D1
00001450  0128      
                    1940   DumpRegisters_19:
00001452  2F01      1941          move.l    D1,-(A7)
00001454  2F39 0B00 1942          move.l    _d7.L,-(A7)
00001458  0100      
0000145A  4879 0000 1943          pea       @m68kde~3_39.L
0000145E  4DAC      
00001460  4E93      1944          jsr       (A3)
00001462  DEFC 000C 1945          add.w     #12,A7
                    1946   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP);
00001466  2F39 0B00 1947          move.l    _USP.L,-(A7)
0000146A  0128      
0000146C  4879 0000 1948          pea       @m68kde~3_40.L
00001470  4DC6      
00001472  4E93      1949          jsr       (A3)
00001474  504F      1950          addq.w    #8,A7
                    1951   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP);
00001476  2F39 0B00 1952          move.l    _SSP.L,-(A7)
0000147A  0124      
0000147C  4879 0000 1953          pea       @m68kde~3_41.L
00001480  4DE4      
00001482  4E93      1954          jsr       (A3)
00001484  504F      1955          addq.w    #8,A7
                    1956   ; printf("\r\n SR = $%04X   ", SR);
00001486  3214      1957          move.w    (A4),D1
00001488  C2BC 0000 1958          and.l     #65535,D1
0000148C  FFFF      
0000148E  2F01      1959          move.l    D1,-(A7)
00001490  4879 0000 1960          pea       @m68kde~3_42.L
00001494  4E06      
00001496  4E93      1961          jsr       (A3)
00001498  504F      1962          addq.w    #8,A7
                    1963   ; // display the status word in characters etc.
                    1964   ; printf("   [");
0000149A  4879 0000 1965          pea       @m68kde~3_43.L
0000149E  4E18      
000014A0  4E93      1966          jsr       (A3)
000014A2  584F      1967          addq.w    #4,A7
                    1968   ; if ((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T'); else putchar('-');      // Trace bit(bit 15)
000014A4  3014      1969          move.w    (A4),D0
000014A6  C07C 8000 1970          and.w     #32768,D0
000014AA  0C40 8000 1971          cmp.w     #32768,D0
000014AE  660A      1972          bne.s     DumpRegisters_20
000014B0  4878 0054 1973          pea       84
000014B4  4E92      1974          jsr       (A2)
000014B6  584F      1975          addq.w    #4,A7
000014B8  6008      1976          bra.s     DumpRegisters_21
                    1977   DumpRegisters_20:
000014BA  4878 002D 1978          pea       45
000014BE  4E92      1979          jsr       (A2)
000014C0  584F      1980          addq.w    #4,A7
                    1981   DumpRegisters_21:
                    1982   ; if ((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S'); else putchar('U');      // supervisor bit  (bit 13)
000014C2  3014      1983          move.w    (A4),D0
000014C4  C07C 2000 1984          and.w     #8192,D0
000014C8  0C40 2000 1985          cmp.w     #8192,D0
000014CC  660A      1986          bne.s     DumpRegisters_22
000014CE  4878 0053 1987          pea       83
000014D2  4E92      1988          jsr       (A2)
000014D4  584F      1989          addq.w    #4,A7
000014D6  6008      1990          bra.s     DumpRegisters_23
                    1991   DumpRegisters_22:
000014D8  4878 0055 1992          pea       85
000014DC  4E92      1993          jsr       (A2)
000014DE  584F      1994          addq.w    #4,A7
                    1995   DumpRegisters_23:
                    1996   ; if ((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1'); else putchar('0');      // IRQ2 Bit (bit 10)
000014E0  3014      1997          move.w    (A4),D0
000014E2  C07C 0400 1998          and.w     #1024,D0
000014E6  0C40 0400 1999          cmp.w     #1024,D0
000014EA  660A      2000          bne.s     DumpRegisters_24
000014EC  4878 0031 2001          pea       49
000014F0  4E92      2002          jsr       (A2)
000014F2  584F      2003          addq.w    #4,A7
000014F4  6008      2004          bra.s     DumpRegisters_25
                    2005   DumpRegisters_24:
000014F6  4878 0030 2006          pea       48
000014FA  4E92      2007          jsr       (A2)
000014FC  584F      2008          addq.w    #4,A7
                    2009   DumpRegisters_25:
                    2010   ; if ((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1'); else putchar('0');      // IRQ1 Bit (bit 9)
000014FE  3014      2011          move.w    (A4),D0
00001500  C07C 0200 2012          and.w     #512,D0
00001504  0C40 0200 2013          cmp.w     #512,D0
00001508  660A      2014          bne.s     DumpRegisters_26
0000150A  4878 0031 2015          pea       49
0000150E  4E92      2016          jsr       (A2)
00001510  584F      2017          addq.w    #4,A7
00001512  6008      2018          bra.s     DumpRegisters_27
                    2019   DumpRegisters_26:
00001514  4878 0030 2020          pea       48
00001518  4E92      2021          jsr       (A2)
0000151A  584F      2022          addq.w    #4,A7
                    2023   DumpRegisters_27:
                    2024   ; if ((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1'); else putchar('0');      // IRQ0 Bit (bit 8)
0000151C  3014      2025          move.w    (A4),D0
0000151E  C07C 0100 2026          and.w     #256,D0
00001522  0C40 0100 2027          cmp.w     #256,D0
00001526  660A      2028          bne.s     DumpRegisters_28
00001528  4878 0031 2029          pea       49
0000152C  4E92      2030          jsr       (A2)
0000152E  584F      2031          addq.w    #4,A7
00001530  6008      2032          bra.s     DumpRegisters_29
                    2033   DumpRegisters_28:
00001532  4878 0030 2034          pea       48
00001536  4E92      2035          jsr       (A2)
00001538  584F      2036          addq.w    #4,A7
                    2037   DumpRegisters_29:
                    2038   ; if ((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X'); else putchar('-');      // X Bit (bit 4)
0000153A  3014      2039          move.w    (A4),D0
0000153C  C07C 0010 2040          and.w     #16,D0
00001540  0C40 0010 2041          cmp.w     #16,D0
00001544  660A      2042          bne.s     DumpRegisters_30
00001546  4878 0058 2043          pea       88
0000154A  4E92      2044          jsr       (A2)
0000154C  584F      2045          addq.w    #4,A7
0000154E  6008      2046          bra.s     DumpRegisters_31
                    2047   DumpRegisters_30:
00001550  4878 002D 2048          pea       45
00001554  4E92      2049          jsr       (A2)
00001556  584F      2050          addq.w    #4,A7
                    2051   DumpRegisters_31:
                    2052   ; if ((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N'); else putchar('-');      // N Bit (bit 3)
00001558  3014      2053          move.w    (A4),D0
0000155A  C07C 0008 2054          and.w     #8,D0
0000155E  0C40 0008 2055          cmp.w     #8,D0
00001562  660A      2056          bne.s     DumpRegisters_32
00001564  4878 004E 2057          pea       78
00001568  4E92      2058          jsr       (A2)
0000156A  584F      2059          addq.w    #4,A7
0000156C  6008      2060          bra.s     DumpRegisters_33
                    2061   DumpRegisters_32:
0000156E  4878 002D 2062          pea       45
00001572  4E92      2063          jsr       (A2)
00001574  584F      2064          addq.w    #4,A7
                    2065   DumpRegisters_33:
                    2066   ; if ((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z'); else putchar('-');      // Z Bit (bit 2)
00001576  3014      2067          move.w    (A4),D0
00001578  C07C 0004 2068          and.w     #4,D0
0000157C  0C40 0004 2069          cmp.w     #4,D0
00001580  660A      2070          bne.s     DumpRegisters_34
00001582  4878 005A 2071          pea       90
00001586  4E92      2072          jsr       (A2)
00001588  584F      2073          addq.w    #4,A7
0000158A  6008      2074          bra.s     DumpRegisters_35
                    2075   DumpRegisters_34:
0000158C  4878 002D 2076          pea       45
00001590  4E92      2077          jsr       (A2)
00001592  584F      2078          addq.w    #4,A7
                    2079   DumpRegisters_35:
                    2080   ; if ((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V'); else putchar('-');      // V Bit (bit 1)
00001594  3014      2081          move.w    (A4),D0
00001596  C07C 0002 2082          and.w     #2,D0
0000159A  0C40 0002 2083          cmp.w     #2,D0
0000159E  660A      2084          bne.s     DumpRegisters_36
000015A0  4878 0056 2085          pea       86
000015A4  4E92      2086          jsr       (A2)
000015A6  584F      2087          addq.w    #4,A7
000015A8  6008      2088          bra.s     DumpRegisters_37
                    2089   DumpRegisters_36:
000015AA  4878 002D 2090          pea       45
000015AE  4E92      2091          jsr       (A2)
000015B0  584F      2092          addq.w    #4,A7
                    2093   DumpRegisters_37:
                    2094   ; if ((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C'); else putchar('-');      // C Bit (bit 0)
000015B2  3014      2095          move.w    (A4),D0
000015B4  C07C 0001 2096          and.w     #1,D0
000015B8  0C40 0001 2097          cmp.w     #1,D0
000015BC  660A      2098          bne.s     DumpRegisters_38
000015BE  4878 0043 2099          pea       67
000015C2  4E92      2100          jsr       (A2)
000015C4  584F      2101          addq.w    #4,A7
000015C6  6008      2102          bra.s     DumpRegisters_39
                    2103   DumpRegisters_38:
000015C8  4878 002D 2104          pea       45
000015CC  4E92      2105          jsr       (A2)
000015CE  584F      2106          addq.w    #4,A7
                    2107   DumpRegisters_39:
                    2108   ; putchar(']');
000015D0  4878 005D 2109          pea       93
000015D4  4E92      2110          jsr       (A2)
000015D6  584F      2111          addq.w    #4,A7
                    2112   ; printf("\r\n PC = $%08X  ", PC);
000015D8  2F39 0B00 2113          move.l    _PC.L,-(A7)
000015DC  0120      
000015DE  4879 0000 2114          pea       @m68kde~3_44.L
000015E2  4E1E      
000015E4  4E93      2115          jsr       (A3)
000015E6  504F      2116          addq.w    #8,A7
                    2117   ; if (*(unsigned short int*)(PC) == 0x4e4e)
000015E8  2039 0B00 2118          move.l    _PC.L,D0
000015EC  0120      
000015EE  2040      2119          move.l    D0,A0
000015F0  3010      2120          move.w    (A0),D0
000015F2  0C40 4E4E 2121          cmp.w     #20046,D0
000015F6  660A      2122          bne.s     DumpRegisters_40
                    2123   ; printf("[@ BREAKPOINT]");
000015F8  4879 0000 2124          pea       @m68kde~3_45.L
000015FC  4E2E      
000015FE  4E93      2125          jsr       (A3)
00001600  584F      2126          addq.w    #4,A7
                    2127   DumpRegisters_40:
                    2128   ; printf("\r\n");
00001602  4879 0000 2129          pea       @m68kde~3_1.L
00001606  49D4      
00001608  4E93      2130          jsr       (A3)
0000160A  584F      2131          addq.w    #4,A7
                    2132   ; for (i = 0; i < 8; i++) {
0000160C  4244      2133          clr.w     D4
                    2134   DumpRegisters_42:
0000160E  0C44 0008 2135          cmp.w     #8,D4
00001612  6C00 0040 2136          bge       DumpRegisters_44
                    2137   ; if (WatchPointSetOrCleared[i] == 1)
00001616  48C4      2138          ext.l     D4
00001618  2004      2139          move.l    D4,D0
0000161A  E588      2140          lsl.l     #2,D0
0000161C  41F9 0B00 2141          lea       _WatchPointSetOrCleared.L,A0
00001620  01A2      
00001622  2030 0800 2142          move.l    0(A0,D0.L),D0
00001626  0C80 0000 2143          cmp.l     #1,D0
0000162A  0001      
0000162C  6622      2144          bne.s     DumpRegisters_45
                    2145   ; printf("\r\nWP%d = %s", i, WatchPointString[i]);
0000162E  220D      2146          move.l    A5,D1
00001630  48C4      2147          ext.l     D4
00001632  2F00      2148          move.l    D0,-(A7)
00001634  2004      2149          move.l    D4,D0
00001636  C1FC 0064 2150          muls      #100,D0
0000163A  D280      2151          add.l     D0,D1
0000163C  201F      2152          move.l    (A7)+,D0
0000163E  2F01      2153          move.l    D1,-(A7)
00001640  48C4      2154          ext.l     D4
00001642  2F04      2155          move.l    D4,-(A7)
00001644  4879 0000 2156          pea       @m68kde~3_46.L
00001648  4E3E      
0000164A  4E93      2157          jsr       (A3)
0000164C  DEFC 000C 2158          add.w     #12,A7
                    2159   DumpRegisters_45:
00001650  5244      2160          addq.w    #1,D4
00001652  60BA      2161          bra       DumpRegisters_42
                    2162   DumpRegisters_44:
00001654  4CDF 3CFC 2163          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001658  4E75      2164          rts
                    2165   ; }
                    2166   ; }
                    2167   ; // Trace Exception Handler
                    2168   ; void DumpRegistersandPause(void)
                    2169   ; {
                    2170   _DumpRegistersandPause:
0000165A  2F0A      2171          move.l    A2,-(A7)
0000165C  45F9 0000 2172          lea       _printf.L,A2
00001660  4084      
                    2173   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]");
00001662  4879 0000 2174          pea       @m68kde~3_47.L
00001666  4E4A      
00001668  4E92      2175          jsr       (A2)
0000166A  584F      2176          addq.w    #4,A7
                    2177   ; printf("\r\nBreak Points :[Disabled]");
0000166C  4879 0000 2178          pea       @m68kde~3_48.L
00001670  4E6A      
00001672  4E92      2179          jsr       (A2)
00001674  584F      2180          addq.w    #4,A7
                    2181   ; DumpRegisters();
00001676  4EB8 11A6 2182          jsr       _DumpRegisters
                    2183   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000167A  4879 0000 2184          pea       @m68kde~3_49.L
0000167E  4E86      
00001680  4E92      2185          jsr       (A2)
00001682  584F      2186          addq.w    #4,A7
                    2187   ; printf("\r\nPress <ESC> to Resume Program");
00001684  4879 0000 2188          pea       @m68kde~3_50.L
00001688  4EB2      
0000168A  4E92      2189          jsr       (A2)
0000168C  584F      2190          addq.w    #4,A7
                    2191   ; menu();
0000168E  4EB9 0000 2192          jsr       _menu
00001692  223E      
00001694  245F      2193          move.l    (A7)+,A2
00001696  4E75      2194          rts
                    2195   ; }
                    2196   ; void ChangeRegisters(void)
                    2197   ; {
                    2198   _ChangeRegisters:
00001698  4E56 FFFC 2199          link      A6,#-4
0000169C  48E7 303C 2200          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000016A0  45F9 0000 2201          lea       _printf.L,A2
000016A4  4084      
000016A6  47EE FFFC 2202          lea       -4(A6),A3
000016AA  49F8 0CA4 2203          lea       _Get8HexDigits.L,A4
000016AE  4BF8 0B68 2204          lea       __getch.L,A5
                    2205   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2206   ; int reg_val;
                    2207   ; char c, reg[3];
                    2208   ; reg[0] = tolower(_getch());
000016B2  2F00      2209          move.l    D0,-(A7)
000016B4  4E95      2210          jsr       (A5)
000016B6  2200      2211          move.l    D0,D1
000016B8  201F      2212          move.l    (A7)+,D0
000016BA  2F01      2213          move.l    D1,-(A7)
000016BC  4EB9 0000 2214          jsr       _tolower
000016C0  3FE2      
000016C2  584F      2215          addq.w    #4,A7
000016C4  1680      2216          move.b    D0,(A3)
                    2217   ; reg[1] = c = tolower(_getch());
000016C6  2F00      2218          move.l    D0,-(A7)
000016C8  4E95      2219          jsr       (A5)
000016CA  2200      2220          move.l    D0,D1
000016CC  201F      2221          move.l    (A7)+,D0
000016CE  2F01      2222          move.l    D1,-(A7)
000016D0  4EB9 0000 2223          jsr       _tolower
000016D4  3FE2      
000016D6  584F      2224          addq.w    #4,A7
000016D8  1400      2225          move.b    D0,D2
000016DA  1740 0001 2226          move.b    D0,1(A3)
                    2227   ; if (reg[0] == (char)('d')) {    // change data register
000016DE  1013      2228          move.b    (A3),D0
000016E0  0C00 0064 2229          cmp.b     #100,D0
000016E4  6600 00AE 2230          bne       ChangeRegisters_1
                    2231   ; if ((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
000016E8  102B 0001 2232          move.b    1(A3),D0
000016EC  0C00 0037 2233          cmp.b     #55,D0
000016F0  6E0A      2234          bgt.s     ChangeRegisters_5
000016F2  102B 0001 2235          move.b    1(A3),D0
000016F6  0C00 0030 2236          cmp.b     #48,D0
000016FA  6C0E      2237          bge.s     ChangeRegisters_3
                    2238   ChangeRegisters_5:
                    2239   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n");
000016FC  4879 0000 2240          pea       @m68kde~3_51.L
00001700  4ED2      
00001702  4E92      2241          jsr       (A2)
00001704  584F      2242          addq.w    #4,A7
                    2243   ; return;
00001706  6000 0244 2244          bra       ChangeRegisters_6
                    2245   ChangeRegisters_3:
                    2246   ; }
                    2247   ; else {
                    2248   ; printf("\r\nD%c = ", c);
0000170A  4882      2249          ext.w     D2
0000170C  48C2      2250          ext.l     D2
0000170E  2F02      2251          move.l    D2,-(A7)
00001710  4879 0000 2252          pea       @m68kde~3_52.L
00001714  4EFE      
00001716  4E92      2253          jsr       (A2)
00001718  504F      2254          addq.w    #8,A7
                    2255   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
0000171A  42A7      2256          clr.l     -(A7)
0000171C  4E94      2257          jsr       (A4)
0000171E  584F      2258          addq.w    #4,A7
00001720  2600      2259          move.l    D0,D3
                    2260   ; }
                    2261   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2262   ; if (c == (char)('0'))
00001722  0C02 0030 2263          cmp.b     #48,D2
00001726  660A      2264          bne.s     ChangeRegisters_7
                    2265   ; d0 = reg_val;
00001728  23C3 0B00 2266          move.l    D3,_d0.L
0000172C  00E4      
0000172E  6000 0060 2267          bra       ChangeRegisters_20
                    2268   ChangeRegisters_7:
                    2269   ; else if (c == (char)('1'))
00001732  0C02 0031 2270          cmp.b     #49,D2
00001736  660A      2271          bne.s     ChangeRegisters_9
                    2272   ; d1 = reg_val;
00001738  23C3 0B00 2273          move.l    D3,_d1.L
0000173C  00E8      
0000173E  6000 0050 2274          bra       ChangeRegisters_20
                    2275   ChangeRegisters_9:
                    2276   ; else if (c == (char)('2'))
00001742  0C02 0032 2277          cmp.b     #50,D2
00001746  660A      2278          bne.s     ChangeRegisters_11
                    2279   ; d2 = reg_val;
00001748  23C3 0B00 2280          move.l    D3,_d2.L
0000174C  00EC      
0000174E  6000 0040 2281          bra       ChangeRegisters_20
                    2282   ChangeRegisters_11:
                    2283   ; else if (c == (char)('3'))
00001752  0C02 0033 2284          cmp.b     #51,D2
00001756  6608      2285          bne.s     ChangeRegisters_13
                    2286   ; d3 = reg_val;
00001758  23C3 0B00 2287          move.l    D3,_d3.L
0000175C  00F0      
0000175E  6030      2288          bra.s     ChangeRegisters_20
                    2289   ChangeRegisters_13:
                    2290   ; else if (c == (char)('4'))
00001760  0C02 0034 2291          cmp.b     #52,D2
00001764  6608      2292          bne.s     ChangeRegisters_15
                    2293   ; d4 = reg_val;
00001766  23C3 0B00 2294          move.l    D3,_d4.L
0000176A  00F4      
0000176C  6022      2295          bra.s     ChangeRegisters_20
                    2296   ChangeRegisters_15:
                    2297   ; else if (c == (char)('5'))
0000176E  0C02 0035 2298          cmp.b     #53,D2
00001772  6608      2299          bne.s     ChangeRegisters_17
                    2300   ; d5 = reg_val;
00001774  23C3 0B00 2301          move.l    D3,_d5.L
00001778  00F8      
0000177A  6014      2302          bra.s     ChangeRegisters_20
                    2303   ChangeRegisters_17:
                    2304   ; else if (c == (char)('6'))
0000177C  0C02 0036 2305          cmp.b     #54,D2
00001780  6608      2306          bne.s     ChangeRegisters_19
                    2307   ; d6 = reg_val;
00001782  23C3 0B00 2308          move.l    D3,_d6.L
00001786  00FC      
00001788  6006      2309          bra.s     ChangeRegisters_20
                    2310   ChangeRegisters_19:
                    2311   ; else
                    2312   ; d7 = reg_val;
0000178A  23C3 0B00 2313          move.l    D3,_d7.L
0000178E  0100      
                    2314   ChangeRegisters_20:
00001790  6000 01B6 2315          bra       ChangeRegisters_51
                    2316   ChangeRegisters_1:
                    2317   ; }
                    2318   ; else if (reg[0] == (char)('a')) {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001794  1013      2319          move.b    (A3),D0
00001796  0C00 0061 2320          cmp.b     #97,D0
0000179A  6600 00A6 2321          bne       ChangeRegisters_21
                    2322   ; if ((c > (char)('7')) || (c < (char)('0'))) {
0000179E  0C02 0037 2323          cmp.b     #55,D2
000017A2  6E06      2324          bgt.s     ChangeRegisters_25
000017A4  0C02 0030 2325          cmp.b     #48,D2
000017A8  6C0E      2326          bge.s     ChangeRegisters_23
                    2327   ChangeRegisters_25:
                    2328   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n");
000017AA  4879 0000 2329          pea       @m68kde~3_53.L
000017AE  4F08      
000017B0  4E92      2330          jsr       (A2)
000017B2  584F      2331          addq.w    #4,A7
                    2332   ; return;
000017B4  6000 0196 2333          bra       ChangeRegisters_6
                    2334   ChangeRegisters_23:
                    2335   ; }
                    2336   ; else {
                    2337   ; printf("\r\nA%c = ", c);
000017B8  4882      2338          ext.w     D2
000017BA  48C2      2339          ext.l     D2
000017BC  2F02      2340          move.l    D2,-(A7)
000017BE  4879 0000 2341          pea       @m68kde~3_54.L
000017C2  4F36      
000017C4  4E92      2342          jsr       (A2)
000017C6  504F      2343          addq.w    #8,A7
                    2344   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
000017C8  42A7      2345          clr.l     -(A7)
000017CA  4E94      2346          jsr       (A4)
000017CC  584F      2347          addq.w    #4,A7
000017CE  2600      2348          move.l    D0,D3
                    2349   ; }
                    2350   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2351   ; if (c == (char)('0'))
000017D0  0C02 0030 2352          cmp.b     #48,D2
000017D4  660A      2353          bne.s     ChangeRegisters_26
                    2354   ; a0 = reg_val;
000017D6  23C3 0B00 2355          move.l    D3,_a0.L
000017DA  0104      
000017DC  6000 0060 2356          bra       ChangeRegisters_39
                    2357   ChangeRegisters_26:
                    2358   ; else if (c == (char)('1'))
000017E0  0C02 0031 2359          cmp.b     #49,D2
000017E4  660A      2360          bne.s     ChangeRegisters_28
                    2361   ; a1 = reg_val;
000017E6  23C3 0B00 2362          move.l    D3,_a1.L
000017EA  0108      
000017EC  6000 0050 2363          bra       ChangeRegisters_39
                    2364   ChangeRegisters_28:
                    2365   ; else if (c == (char)('2'))
000017F0  0C02 0032 2366          cmp.b     #50,D2
000017F4  660A      2367          bne.s     ChangeRegisters_30
                    2368   ; a2 = reg_val;
000017F6  23C3 0B00 2369          move.l    D3,_a2.L
000017FA  010C      
000017FC  6000 0040 2370          bra       ChangeRegisters_39
                    2371   ChangeRegisters_30:
                    2372   ; else if (c == (char)('3'))
00001800  0C02 0033 2373          cmp.b     #51,D2
00001804  6608      2374          bne.s     ChangeRegisters_32
                    2375   ; a3 = reg_val;
00001806  23C3 0B00 2376          move.l    D3,_a3.L
0000180A  0110      
0000180C  6030      2377          bra.s     ChangeRegisters_39
                    2378   ChangeRegisters_32:
                    2379   ; else if (c == (char)('4'))
0000180E  0C02 0034 2380          cmp.b     #52,D2
00001812  6608      2381          bne.s     ChangeRegisters_34
                    2382   ; a4 = reg_val;
00001814  23C3 0B00 2383          move.l    D3,_a4.L
00001818  0114      
0000181A  6022      2384          bra.s     ChangeRegisters_39
                    2385   ChangeRegisters_34:
                    2386   ; else if (c == (char)('5'))
0000181C  0C02 0035 2387          cmp.b     #53,D2
00001820  6608      2388          bne.s     ChangeRegisters_36
                    2389   ; a5 = reg_val;
00001822  23C3 0B00 2390          move.l    D3,_a5.L
00001826  0118      
00001828  6014      2391          bra.s     ChangeRegisters_39
                    2392   ChangeRegisters_36:
                    2393   ; else if (c == (char)('6'))
0000182A  0C02 0036 2394          cmp.b     #54,D2
0000182E  6608      2395          bne.s     ChangeRegisters_38
                    2396   ; a6 = reg_val;
00001830  23C3 0B00 2397          move.l    D3,_a6.L
00001834  011C      
00001836  6006      2398          bra.s     ChangeRegisters_39
                    2399   ChangeRegisters_38:
                    2400   ; else
                    2401   ; USP = reg_val;
00001838  23C3 0B00 2402          move.l    D3,_USP.L
0000183C  0128      
                    2403   ChangeRegisters_39:
0000183E  6000 0108 2404          bra       ChangeRegisters_51
                    2405   ChangeRegisters_21:
                    2406   ; }
                    2407   ; else if ((reg[0] == (char)('u')) && (c == (char)('s'))) {
00001842  1013      2408          move.b    (A3),D0
00001844  0C00 0075 2409          cmp.b     #117,D0
00001848  6600 004E 2410          bne       ChangeRegisters_40
0000184C  0C02 0073 2411          cmp.b     #115,D2
00001850  6600 0046 2412          bne       ChangeRegisters_40
                    2413   ; if (tolower(_getch()) == 'p') {    // change user stack pointer
00001854  2F00      2414          move.l    D0,-(A7)
00001856  4E95      2415          jsr       (A5)
00001858  2200      2416          move.l    D0,D1
0000185A  201F      2417          move.l    (A7)+,D0
0000185C  2F01      2418          move.l    D1,-(A7)
0000185E  4EB9 0000 2419          jsr       _tolower
00001862  3FE2      
00001864  584F      2420          addq.w    #4,A7
00001866  0C80 0000 2421          cmp.l     #112,D0
0000186A  0070      
0000186C  6618      2422          bne.s     ChangeRegisters_42
                    2423   ; printf("\r\nUser SP = ");
0000186E  4879 0000 2424          pea       @m68kde~3_55.L
00001872  4F40      
00001874  4E92      2425          jsr       (A2)
00001876  584F      2426          addq.w    #4,A7
                    2427   ; USP = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001878  42A7      2428          clr.l     -(A7)
0000187A  4E94      2429          jsr       (A4)
0000187C  584F      2430          addq.w    #4,A7
0000187E  23C0 0B00 2431          move.l    D0,_USP.L
00001882  0128      
00001884  600E      2432          bra.s     ChangeRegisters_43
                    2433   ChangeRegisters_42:
                    2434   ; }
                    2435   ; else {
                    2436   ; printf("\r\nIllegal Register....");
00001886  4879 0000 2437          pea       @m68kde~3_56.L
0000188A  4F4E      
0000188C  4E92      2438          jsr       (A2)
0000188E  584F      2439          addq.w    #4,A7
                    2440   ; return;
00001890  6000 00BA 2441          bra       ChangeRegisters_6
                    2442   ChangeRegisters_43:
00001894  6000 00B2 2443          bra       ChangeRegisters_51
                    2444   ChangeRegisters_40:
                    2445   ; }
                    2446   ; }
                    2447   ; else if ((reg[0] == (char)('s')) && (c == (char)('s'))) {
00001898  1013      2448          move.b    (A3),D0
0000189A  0C00 0073 2449          cmp.b     #115,D0
0000189E  6600 004E 2450          bne       ChangeRegisters_44
000018A2  0C02 0073 2451          cmp.b     #115,D2
000018A6  6600 0046 2452          bne       ChangeRegisters_44
                    2453   ; if (tolower(_getch()) == 'p') {    // change system stack pointer
000018AA  2F00      2454          move.l    D0,-(A7)
000018AC  4E95      2455          jsr       (A5)
000018AE  2200      2456          move.l    D0,D1
000018B0  201F      2457          move.l    (A7)+,D0
000018B2  2F01      2458          move.l    D1,-(A7)
000018B4  4EB9 0000 2459          jsr       _tolower
000018B8  3FE2      
000018BA  584F      2460          addq.w    #4,A7
000018BC  0C80 0000 2461          cmp.l     #112,D0
000018C0  0070      
000018C2  6618      2462          bne.s     ChangeRegisters_46
                    2463   ; printf("\r\nSystem SP = ");
000018C4  4879 0000 2464          pea       @m68kde~3_57.L
000018C8  4F66      
000018CA  4E92      2465          jsr       (A2)
000018CC  584F      2466          addq.w    #4,A7
                    2467   ; SSP = Get8HexDigits(0);    // read 32 bit value from user keyboard
000018CE  42A7      2468          clr.l     -(A7)
000018D0  4E94      2469          jsr       (A4)
000018D2  584F      2470          addq.w    #4,A7
000018D4  23C0 0B00 2471          move.l    D0,_SSP.L
000018D8  0124      
000018DA  600E      2472          bra.s     ChangeRegisters_47
                    2473   ChangeRegisters_46:
                    2474   ; }
                    2475   ; else {
                    2476   ; printf("\r\nIllegal Register....");
000018DC  4879 0000 2477          pea       @m68kde~3_56.L
000018E0  4F4E      
000018E2  4E92      2478          jsr       (A2)
000018E4  584F      2479          addq.w    #4,A7
                    2480   ; return;
000018E6  6000 0064 2481          bra       ChangeRegisters_6
                    2482   ChangeRegisters_47:
000018EA  6000 005C 2483          bra       ChangeRegisters_51
                    2484   ChangeRegisters_44:
                    2485   ; }
                    2486   ; }
                    2487   ; else if ((reg[0] == (char)('p')) && (c == (char)('c'))) {    // change program counter
000018EE  1013      2488          move.b    (A3),D0
000018F0  0C00 0070 2489          cmp.b     #112,D0
000018F4  6620      2490          bne.s     ChangeRegisters_48
000018F6  0C02 0063 2491          cmp.b     #99,D2
000018FA  661A      2492          bne.s     ChangeRegisters_48
                    2493   ; printf("\r\nPC = ");
000018FC  4879 0000 2494          pea       @m68kde~3_58.L
00001900  4F76      
00001902  4E92      2495          jsr       (A2)
00001904  584F      2496          addq.w    #4,A7
                    2497   ; PC = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001906  42A7      2498          clr.l     -(A7)
00001908  4E94      2499          jsr       (A4)
0000190A  584F      2500          addq.w    #4,A7
0000190C  23C0 0B00 2501          move.l    D0,_PC.L
00001910  0120      
00001912  6000 0034 2502          bra       ChangeRegisters_51
                    2503   ChangeRegisters_48:
                    2504   ; }
                    2505   ; else if ((reg[0] == (char)('s')) && (c == (char)('r'))) {    // change status register
00001916  1013      2506          move.b    (A3),D0
00001918  0C00 0073 2507          cmp.b     #115,D0
0000191C  6620      2508          bne.s     ChangeRegisters_50
0000191E  0C02 0072 2509          cmp.b     #114,D2
00001922  661A      2510          bne.s     ChangeRegisters_50
                    2511   ; printf("\r\nSR = ");
00001924  4879 0000 2512          pea       @m68kde~3_59.L
00001928  4F7E      
0000192A  4E92      2513          jsr       (A2)
0000192C  584F      2514          addq.w    #4,A7
                    2515   ; SR = Get4HexDigits(0);    // read 16 bit value from user keyboard
0000192E  42A7      2516          clr.l     -(A7)
00001930  4EB8 0C58 2517          jsr       _Get4HexDigits
00001934  584F      2518          addq.w    #4,A7
00001936  33C0 0B00 2519          move.w    D0,_SR.L
0000193A  012C      
0000193C  600A      2520          bra.s     ChangeRegisters_51
                    2521   ChangeRegisters_50:
                    2522   ; }
                    2523   ; else
                    2524   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n");
0000193E  4879 0000 2525          pea       @m68kde~3_60.L
00001942  4F86      
00001944  4E92      2526          jsr       (A2)
00001946  584F      2527          addq.w    #4,A7
                    2528   ChangeRegisters_51:
                    2529   ; DumpRegisters();
00001948  4EB8 11A6 2530          jsr       _DumpRegisters
                    2531   ChangeRegisters_6:
0000194C  4CDF 3C0C 2532          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001950  4E5E      2533          unlk      A6
00001952  4E75      2534          rts
                    2535   ; }
                    2536   ; void BreakPointDisplay(void)
                    2537   ; {
                    2538   _BreakPointDisplay:
00001954  48E7 3030 2539          movem.l   D2/D3/A2/A3,-(A7)
00001958  45F9 0000 2540          lea       _printf.L,A2
0000195C  4084      
0000195E  47F9 0B00 2541          lea       _BreakPointAddress.L,A3
00001962  012E      
                    2542   ; int i, BreakPointsSet = 0;
00001964  4283      2543          clr.l     D3
                    2544   ; // any break points  set
                    2545   ; for (i = 0; i < 8; i++) {
00001966  4282      2546          clr.l     D2
                    2547   BreakPointDisplay_1:
00001968  0C82 0000 2548          cmp.l     #8,D2
0000196C  0008      
0000196E  6C1C      2549          bge.s     BreakPointDisplay_3
                    2550   ; if (BreakPointSetOrCleared[i] == 1)
00001970  2002      2551          move.l    D2,D0
00001972  E588      2552          lsl.l     #2,D0
00001974  41F9 0B00 2553          lea       _BreakPointSetOrCleared.L,A0
00001978  015E      
0000197A  2030 0800 2554          move.l    0(A0,D0.L),D0
0000197E  0C80 0000 2555          cmp.l     #1,D0
00001982  0001      
00001984  6602      2556          bne.s     BreakPointDisplay_4
                    2557   ; BreakPointsSet = 1;
00001986  7601      2558          moveq     #1,D3
                    2559   BreakPointDisplay_4:
00001988  5282      2560          addq.l    #1,D2
0000198A  60DC      2561          bra       BreakPointDisplay_1
                    2562   BreakPointDisplay_3:
                    2563   ; }
                    2564   ; if (BreakPointsSet == 1) {
0000198C  0C83 0000 2565          cmp.l     #1,D3
00001990  0001      
00001992  6616      2566          bne.s     BreakPointDisplay_6
                    2567   ; printf("\r\n\r\nNum     Address      Instruction");
00001994  4879 0000 2568          pea       @m68kde~3_61.L
00001998  4FC2      
0000199A  4E92      2569          jsr       (A2)
0000199C  584F      2570          addq.w    #4,A7
                    2571   ; printf("\r\n---     ---------    -----------");
0000199E  4879 0000 2572          pea       @m68kde~3_62.L
000019A2  4FE8      
000019A4  4E92      2573          jsr       (A2)
000019A6  584F      2574          addq.w    #4,A7
000019A8  600A      2575          bra.s     BreakPointDisplay_7
                    2576   BreakPointDisplay_6:
                    2577   ; }
                    2578   ; else
                    2579   ; printf("\r\nNo BreakPoints Set");
000019AA  4879 0000 2580          pea       @m68kde~3_63.L
000019AE  500C      
000019B0  4E92      2581          jsr       (A2)
000019B2  584F      2582          addq.w    #4,A7
                    2583   BreakPointDisplay_7:
                    2584   ; for (i = 0; i < 8; i++) {
000019B4  4282      2585          clr.l     D2
                    2586   BreakPointDisplay_8:
000019B6  0C82 0000 2587          cmp.l     #8,D2
000019BA  0008      
000019BC  6C00 005A 2588          bge       BreakPointDisplay_10
                    2589   ; // put opcode back, then put break point back
                    2590   ; if (BreakPointSetOrCleared[i] == 1) {
000019C0  2002      2591          move.l    D2,D0
000019C2  E588      2592          lsl.l     #2,D0
000019C4  41F9 0B00 2593          lea       _BreakPointSetOrCleared.L,A0
000019C8  015E      
000019CA  2030 0800 2594          move.l    0(A0,D0.L),D0
000019CE  0C80 0000 2595          cmp.l     #1,D0
000019D2  0001      
000019D4  6600 003E 2596          bne       BreakPointDisplay_11
                    2597   ; *(unsigned short int*)(BreakPointAddress[i]) = BreakPointInstruction[i];
000019D8  2002      2598          move.l    D2,D0
000019DA  E388      2599          lsl.l     #1,D0
000019DC  41F9 0B00 2600          lea       _BreakPointInstruction.L,A0
000019E0  014E      
000019E2  2202      2601          move.l    D2,D1
000019E4  E589      2602          lsl.l     #2,D1
000019E6  2233 1800 2603          move.l    0(A3,D1.L),D1
000019EA  2241      2604          move.l    D1,A1
000019EC  32B0 0800 2605          move.w    0(A0,D0.L),(A1)
                    2606   ; *(unsigned short int*)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e);
000019F0  2002      2607          move.l    D2,D0
000019F2  E588      2608          lsl.l     #2,D0
000019F4  2033 0800 2609          move.l    0(A3,D0.L),D0
000019F8  2040      2610          move.l    D0,A0
000019FA  30BC 4E4E 2611          move.w    #20046,(A0)
                    2612   ; printf("\r\n%3d     $%08x", i, BreakPointAddress[i]);
000019FE  2202      2613          move.l    D2,D1
00001A00  E589      2614          lsl.l     #2,D1
00001A02  2F33 1800 2615          move.l    0(A3,D1.L),-(A7)
00001A06  2F02      2616          move.l    D2,-(A7)
00001A08  4879 0000 2617          pea       @m68kde~3_64.L
00001A0C  5022      
00001A0E  4E92      2618          jsr       (A2)
00001A10  DEFC 000C 2619          add.w     #12,A7
                    2620   BreakPointDisplay_11:
00001A14  5282      2621          addq.l    #1,D2
00001A16  609E      2622          bra       BreakPointDisplay_8
                    2623   BreakPointDisplay_10:
                    2624   ; }
                    2625   ; }
                    2626   ; printf("\r\n");
00001A18  4879 0000 2627          pea       @m68kde~3_1.L
00001A1C  49D4      
00001A1E  4E92      2628          jsr       (A2)
00001A20  584F      2629          addq.w    #4,A7
00001A22  4CDF 0C0C 2630          movem.l   (A7)+,D2/D3/A2/A3
00001A26  4E75      2631          rts
                    2632   ; }
                    2633   ; void WatchPointDisplay(void)
                    2634   ; {
                    2635   _WatchPointDisplay:
00001A28  48E7 3020 2636          movem.l   D2/D3/A2,-(A7)
00001A2C  45F9 0000 2637          lea       _printf.L,A2
00001A30  4084      
                    2638   ; int i;
                    2639   ; int WatchPointsSet = 0;
00001A32  4283      2640          clr.l     D3
                    2641   ; // any watchpoints set
                    2642   ; for (i = 0; i < 8; i++) {
00001A34  4282      2643          clr.l     D2
                    2644   WatchPointDisplay_1:
00001A36  0C82 0000 2645          cmp.l     #8,D2
00001A3A  0008      
00001A3C  6C1C      2646          bge.s     WatchPointDisplay_3
                    2647   ; if (WatchPointSetOrCleared[i] == 1)
00001A3E  2002      2648          move.l    D2,D0
00001A40  E588      2649          lsl.l     #2,D0
00001A42  41F9 0B00 2650          lea       _WatchPointSetOrCleared.L,A0
00001A46  01A2      
00001A48  2030 0800 2651          move.l    0(A0,D0.L),D0
00001A4C  0C80 0000 2652          cmp.l     #1,D0
00001A50  0001      
00001A52  6602      2653          bne.s     WatchPointDisplay_4
                    2654   ; WatchPointsSet = 1;
00001A54  7601      2655          moveq     #1,D3
                    2656   WatchPointDisplay_4:
00001A56  5282      2657          addq.l    #1,D2
00001A58  60DC      2658          bra       WatchPointDisplay_1
                    2659   WatchPointDisplay_3:
                    2660   ; }
                    2661   ; if (WatchPointsSet == 1) {
00001A5A  0C83 0000 2662          cmp.l     #1,D3
00001A5E  0001      
00001A60  6616      2663          bne.s     WatchPointDisplay_6
                    2664   ; printf("\r\nNum     Address");
00001A62  4879 0000 2665          pea       @m68kde~3_65.L
00001A66  5032      
00001A68  4E92      2666          jsr       (A2)
00001A6A  584F      2667          addq.w    #4,A7
                    2668   ; printf("\r\n---     ---------");
00001A6C  4879 0000 2669          pea       @m68kde~3_66.L
00001A70  5044      
00001A72  4E92      2670          jsr       (A2)
00001A74  584F      2671          addq.w    #4,A7
00001A76  600A      2672          bra.s     WatchPointDisplay_7
                    2673   WatchPointDisplay_6:
                    2674   ; }
                    2675   ; else
                    2676   ; printf("\r\nNo WatchPoints Set");
00001A78  4879 0000 2677          pea       @m68kde~3_67.L
00001A7C  5058      
00001A7E  4E92      2678          jsr       (A2)
00001A80  584F      2679          addq.w    #4,A7
                    2680   WatchPointDisplay_7:
                    2681   ; for (i = 0; i < 8; i++) {
00001A82  4282      2682          clr.l     D2
                    2683   WatchPointDisplay_8:
00001A84  0C82 0000 2684          cmp.l     #8,D2
00001A88  0008      
00001A8A  6C00 0038 2685          bge       WatchPointDisplay_10
                    2686   ; if (WatchPointSetOrCleared[i] == 1)
00001A8E  2002      2687          move.l    D2,D0
00001A90  E588      2688          lsl.l     #2,D0
00001A92  41F9 0B00 2689          lea       _WatchPointSetOrCleared.L,A0
00001A96  01A2      
00001A98  2030 0800 2690          move.l    0(A0,D0.L),D0
00001A9C  0C80 0000 2691          cmp.l     #1,D0
00001AA0  0001      
00001AA2  661C      2692          bne.s     WatchPointDisplay_11
                    2693   ; printf("\r\n%3d     $%08x", i, WatchPointAddress[i]);
00001AA4  2202      2694          move.l    D2,D1
00001AA6  E589      2695          lsl.l     #2,D1
00001AA8  41F9 0B00 2696          lea       _WatchPointAddress.L,A0
00001AAC  0182      
00001AAE  2F30 1800 2697          move.l    0(A0,D1.L),-(A7)
00001AB2  2F02      2698          move.l    D2,-(A7)
00001AB4  4879 0000 2699          pea       @m68kde~3_64.L
00001AB8  5022      
00001ABA  4E92      2700          jsr       (A2)
00001ABC  DEFC 000C 2701          add.w     #12,A7
                    2702   WatchPointDisplay_11:
00001AC0  5282      2703          addq.l    #1,D2
00001AC2  60C0      2704          bra       WatchPointDisplay_8
                    2705   WatchPointDisplay_10:
                    2706   ; }
                    2707   ; printf("\r\n");
00001AC4  4879 0000 2708          pea       @m68kde~3_1.L
00001AC8  49D4      
00001ACA  4E92      2709          jsr       (A2)
00001ACC  584F      2710          addq.w    #4,A7
00001ACE  4CDF 040C 2711          movem.l   (A7)+,D2/D3/A2
00001AD2  4E75      2712          rts
                    2713   ; }
                    2714   ; void BreakPointClear(void)
                    2715   ; {
                    2716   _BreakPointClear:
00001AD4  4E56 FFFC 2717          link      A6,#-4
00001AD8  48E7 2020 2718          movem.l   D2/A2,-(A7)
00001ADC  45F9 0000 2719          lea       _printf.L,A2
00001AE0  4084      
                    2720   ; unsigned int i;
                    2721   ; volatile unsigned short int* ProgramBreakPointAddress;
                    2722   ; BreakPointDisplay();
00001AE2  4EB8 1954 2723          jsr       _BreakPointDisplay
                    2724   ; printf("\r\nEnter Break Point Number: ");
00001AE6  4879 0000 2725          pea       @m68kde~3_68.L
00001AEA  506E      
00001AEC  4E92      2726          jsr       (A2)
00001AEE  584F      2727          addq.w    #4,A7
                    2728   ; i = xtod(_getch());           // get break pointer number
00001AF0  2F00      2729          move.l    D0,-(A7)
00001AF2  4EB8 0B68 2730          jsr       __getch
00001AF6  2200      2731          move.l    D0,D1
00001AF8  201F      2732          move.l    (A7)+,D0
00001AFA  2F01      2733          move.l    D1,-(A7)
00001AFC  4EB8 0BD2 2734          jsr       _xtod
00001B00  584F      2735          addq.w    #4,A7
00001B02  C0BC 0000 2736          and.l     #255,D0
00001B06  00FF      
00001B08  2400      2737          move.l    D0,D2
                    2738   ; if ((i < 0) || (i > 7)) {
00001B0A  0C82 0000 2739          cmp.l     #0,D2
00001B0E  0000      
00001B10  6508      2740          blo.s     BreakPointClear_3
00001B12  0C82 0000 2741          cmp.l     #7,D2
00001B16  0007      
00001B18  630E      2742          bls.s     BreakPointClear_1
                    2743   BreakPointClear_3:
                    2744   ; printf("\r\nIllegal Range : Use 0 - 7");
00001B1A  4879 0000 2745          pea       @m68kde~3_69.L
00001B1E  508C      
00001B20  4E92      2746          jsr       (A2)
00001B22  584F      2747          addq.w    #4,A7
                    2748   ; return;
00001B24  6000 0080 2749          bra       BreakPointClear_4
                    2750   BreakPointClear_1:
                    2751   ; }
                    2752   ; if (BreakPointSetOrCleared[i] == 1) {       // if break point set
00001B28  2002      2753          move.l    D2,D0
00001B2A  E588      2754          lsl.l     #2,D0
00001B2C  41F9 0B00 2755          lea       _BreakPointSetOrCleared.L,A0
00001B30  015E      
00001B32  2030 0800 2756          move.l    0(A0,D0.L),D0
00001B36  0C80 0000 2757          cmp.l     #1,D0
00001B3A  0001      
00001B3C  6600 005A 2758          bne       BreakPointClear_5
                    2759   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program we are about to change
00001B40  2002      2760          move.l    D2,D0
00001B42  E588      2761          lsl.l     #2,D0
00001B44  41F9 0B00 2762          lea       _BreakPointAddress.L,A0
00001B48  012E      
00001B4A  2D70 0800 2763          move.l    0(A0,D0.L),-4(A6)
00001B4E  FFFC      
                    2764   ; BreakPointAddress[i] = 0;
00001B50  2002      2765          move.l    D2,D0
00001B52  E588      2766          lsl.l     #2,D0
00001B54  41F9 0B00 2767          lea       _BreakPointAddress.L,A0
00001B58  012E      
00001B5A  42B0 0800 2768          clr.l     0(A0,D0.L)
                    2769   ; BreakPointSetOrCleared[i] = 0;
00001B5E  2002      2770          move.l    D2,D0
00001B60  E588      2771          lsl.l     #2,D0
00001B62  41F9 0B00 2772          lea       _BreakPointSetOrCleared.L,A0
00001B66  015E      
00001B68  42B0 0800 2773          clr.l     0(A0,D0.L)
                    2774   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
00001B6C  2002      2775          move.l    D2,D0
00001B6E  E388      2776          lsl.l     #1,D0
00001B70  41F9 0B00 2777          lea       _BreakPointInstruction.L,A0
00001B74  014E      
00001B76  226E FFFC 2778          move.l    -4(A6),A1
00001B7A  32B0 0800 2779          move.w    0(A0,D0.L),(A1)
                    2780   ; BreakPointInstruction[i] = 0;
00001B7E  2002      2781          move.l    D2,D0
00001B80  E388      2782          lsl.l     #1,D0
00001B82  41F9 0B00 2783          lea       _BreakPointInstruction.L,A0
00001B86  014E      
00001B88  4270 0800 2784          clr.w     0(A0,D0.L)
                    2785   ; printf("\r\nBreak Point Cleared.....\r\n");
00001B8C  4879 0000 2786          pea       @m68kde~3_70.L
00001B90  50A8      
00001B92  4E92      2787          jsr       (A2)
00001B94  584F      2788          addq.w    #4,A7
00001B96  600A      2789          bra.s     BreakPointClear_6
                    2790   BreakPointClear_5:
                    2791   ; }
                    2792   ; else
                    2793   ; printf("\r\nBreak Point wasn't Set.....");
00001B98  4879 0000 2794          pea       @m68kde~3_71.L
00001B9C  50C6      
00001B9E  4E92      2795          jsr       (A2)
00001BA0  584F      2796          addq.w    #4,A7
                    2797   BreakPointClear_6:
                    2798   ; BreakPointDisplay();
00001BA2  4EB8 1954 2799          jsr       _BreakPointDisplay
                    2800   ; return;
                    2801   BreakPointClear_4:
00001BA6  4CDF 0404 2802          movem.l   (A7)+,D2/A2
00001BAA  4E5E      2803          unlk      A6
00001BAC  4E75      2804          rts
                    2805   ; }
                    2806   ; void WatchPointClear(void)
                    2807   ; {
                    2808   _WatchPointClear:
00001BAE  48E7 2020 2809          movem.l   D2/A2,-(A7)
00001BB2  45F9 0000 2810          lea       _printf.L,A2
00001BB6  4084      
                    2811   ; unsigned int i;
                    2812   ; WatchPointDisplay();
00001BB8  4EB8 1A28 2813          jsr       _WatchPointDisplay
                    2814   ; printf("\r\nEnter Watch Point Number: ");
00001BBC  4879 0000 2815          pea       @m68kde~3_72.L
00001BC0  50E4      
00001BC2  4E92      2816          jsr       (A2)
00001BC4  584F      2817          addq.w    #4,A7
                    2818   ; i = xtod(_getch());           // get watch pointer number
00001BC6  2F00      2819          move.l    D0,-(A7)
00001BC8  4EB8 0B68 2820          jsr       __getch
00001BCC  2200      2821          move.l    D0,D1
00001BCE  201F      2822          move.l    (A7)+,D0
00001BD0  2F01      2823          move.l    D1,-(A7)
00001BD2  4EB8 0BD2 2824          jsr       _xtod
00001BD6  584F      2825          addq.w    #4,A7
00001BD8  C0BC 0000 2826          and.l     #255,D0
00001BDC  00FF      
00001BDE  2400      2827          move.l    D0,D2
                    2828   ; if ((i < 0) || (i > 7)) {
00001BE0  0C82 0000 2829          cmp.l     #0,D2
00001BE4  0000      
00001BE6  6508      2830          blo.s     WatchPointClear_3
00001BE8  0C82 0000 2831          cmp.l     #7,D2
00001BEC  0007      
00001BEE  630E      2832          bls.s     WatchPointClear_1
                    2833   WatchPointClear_3:
                    2834   ; printf("\r\nIllegal Range : Use 0 - 7");
00001BF0  4879 0000 2835          pea       @m68kde~3_69.L
00001BF4  508C      
00001BF6  4E92      2836          jsr       (A2)
00001BF8  584F      2837          addq.w    #4,A7
                    2838   ; return;
00001BFA  6000 004E 2839          bra       WatchPointClear_4
                    2840   WatchPointClear_1:
                    2841   ; }
                    2842   ; if (WatchPointSetOrCleared[i] == 1) {       // if watch point set
00001BFE  2002      2843          move.l    D2,D0
00001C00  E588      2844          lsl.l     #2,D0
00001C02  41F9 0B00 2845          lea       _WatchPointSetOrCleared.L,A0
00001C06  01A2      
00001C08  2030 0800 2846          move.l    0(A0,D0.L),D0
00001C0C  0C80 0000 2847          cmp.l     #1,D0
00001C10  0001      
00001C12  6628      2848          bne.s     WatchPointClear_5
                    2849   ; WatchPointAddress[i] = 0;
00001C14  2002      2850          move.l    D2,D0
00001C16  E588      2851          lsl.l     #2,D0
00001C18  41F9 0B00 2852          lea       _WatchPointAddress.L,A0
00001C1C  0182      
00001C1E  42B0 0800 2853          clr.l     0(A0,D0.L)
                    2854   ; WatchPointSetOrCleared[i] = 0;
00001C22  2002      2855          move.l    D2,D0
00001C24  E588      2856          lsl.l     #2,D0
00001C26  41F9 0B00 2857          lea       _WatchPointSetOrCleared.L,A0
00001C2A  01A2      
00001C2C  42B0 0800 2858          clr.l     0(A0,D0.L)
                    2859   ; printf("\r\nWatch Point Cleared.....\r\n");
00001C30  4879 0000 2860          pea       @m68kde~3_73.L
00001C34  5102      
00001C36  4E92      2861          jsr       (A2)
00001C38  584F      2862          addq.w    #4,A7
00001C3A  600A      2863          bra.s     WatchPointClear_6
                    2864   WatchPointClear_5:
                    2865   ; }
                    2866   ; else
                    2867   ; printf("\r\nWatch Point Was not Set.....");
00001C3C  4879 0000 2868          pea       @m68kde~3_74.L
00001C40  5120      
00001C42  4E92      2869          jsr       (A2)
00001C44  584F      2870          addq.w    #4,A7
                    2871   WatchPointClear_6:
                    2872   ; WatchPointDisplay();
00001C46  4EB8 1A28 2873          jsr       _WatchPointDisplay
                    2874   ; return;
                    2875   WatchPointClear_4:
00001C4A  4CDF 0404 2876          movem.l   (A7)+,D2/A2
00001C4E  4E75      2877          rts
                    2878   ; }
                    2879   ; void DisableBreakPoints(void)
                    2880   ; {
                    2881   _DisableBreakPoints:
00001C50  4E56 FFFC 2882          link      A6,#-4
00001C54  2F02      2883          move.l    D2,-(A7)
                    2884   ; int i;
                    2885   ; volatile unsigned short int* ProgramBreakPointAddress;
                    2886   ; for (i = 0; i < 8; i++) {
00001C56  4282      2887          clr.l     D2
                    2888   DisableBreakPoints_1:
00001C58  0C82 0000 2889          cmp.l     #8,D2
00001C5C  0008      
00001C5E  6C00 003E 2890          bge       DisableBreakPoints_3
                    2891   ; if (BreakPointSetOrCleared[i] == 1) {                                                    // if break point set
00001C62  2002      2892          move.l    D2,D0
00001C64  E588      2893          lsl.l     #2,D0
00001C66  41F9 0B00 2894          lea       _BreakPointSetOrCleared.L,A0
00001C6A  015E      
00001C6C  2030 0800 2895          move.l    0(A0,D0.L),D0
00001C70  0C80 0000 2896          cmp.l     #1,D0
00001C74  0001      
00001C76  6622      2897          bne.s     DisableBreakPoints_4
                    2898   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001C78  2002      2899          move.l    D2,D0
00001C7A  E588      2900          lsl.l     #2,D0
00001C7C  41F9 0B00 2901          lea       _BreakPointAddress.L,A0
00001C80  012E      
00001C82  2D70 0800 2902          move.l    0(A0,D0.L),-4(A6)
00001C86  FFFC      
                    2903   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001C88  2002      2904          move.l    D2,D0
00001C8A  E388      2905          lsl.l     #1,D0
00001C8C  41F9 0B00 2906          lea       _BreakPointInstruction.L,A0
00001C90  014E      
00001C92  226E FFFC 2907          move.l    -4(A6),A1
00001C96  32B0 0800 2908          move.w    0(A0,D0.L),(A1)
                    2909   DisableBreakPoints_4:
00001C9A  5282      2910          addq.l    #1,D2
00001C9C  60BA      2911          bra       DisableBreakPoints_1
                    2912   DisableBreakPoints_3:
00001C9E  241F      2913          move.l    (A7)+,D2
00001CA0  4E5E      2914          unlk      A6
00001CA2  4E75      2915          rts
                    2916   ; }
                    2917   ; }
                    2918   ; }
                    2919   ; void EnableBreakPoints(void)
                    2920   ; {
                    2921   _EnableBreakPoints:
00001CA4  4E56 FFFC 2922          link      A6,#-4
00001CA8  2F02      2923          move.l    D2,-(A7)
                    2924   ; int i;
                    2925   ; volatile unsigned short int* ProgramBreakPointAddress;
                    2926   ; for (i = 0; i < 8; i++) {
00001CAA  4282      2927          clr.l     D2
                    2928   EnableBreakPoints_1:
00001CAC  0C82 0000 2929          cmp.l     #8,D2
00001CB0  0008      
00001CB2  6C32      2930          bge.s     EnableBreakPoints_3
                    2931   ; if (BreakPointSetOrCleared[i] == 1) {                                                     // if break point set
00001CB4  2002      2932          move.l    D2,D0
00001CB6  E588      2933          lsl.l     #2,D0
00001CB8  41F9 0B00 2934          lea       _BreakPointSetOrCleared.L,A0
00001CBC  015E      
00001CBE  2030 0800 2935          move.l    0(A0,D0.L),D0
00001CC2  0C80 0000 2936          cmp.l     #1,D0
00001CC6  0001      
00001CC8  6618      2937          bne.s     EnableBreakPoints_4
                    2938   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001CCA  2002      2939          move.l    D2,D0
00001CCC  E588      2940          lsl.l     #2,D0
00001CCE  41F9 0B00 2941          lea       _BreakPointAddress.L,A0
00001CD2  012E      
00001CD4  2D70 0800 2942          move.l    0(A0,D0.L),-4(A6)
00001CD8  FFFC      
                    2943   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001CDA  206E FFFC 2944          move.l    -4(A6),A0
00001CDE  30BC 4E4E 2945          move.w    #20046,(A0)
                    2946   EnableBreakPoints_4:
00001CE2  5282      2947          addq.l    #1,D2
00001CE4  60C6      2948          bra       EnableBreakPoints_1
                    2949   EnableBreakPoints_3:
00001CE6  241F      2950          move.l    (A7)+,D2
00001CE8  4E5E      2951          unlk      A6
00001CEA  4E75      2952          rts
                    2953   ; }
                    2954   ; }
                    2955   ; }
                    2956   ; void KillAllBreakPoints(void)
                    2957   ; {
                    2958   _KillAllBreakPoints:
00001CEC  4E56 FFFC 2959          link      A6,#-4
00001CF0  2F02      2960          move.l    D2,-(A7)
                    2961   ; int i;
                    2962   ; volatile unsigned short int* ProgramBreakPointAddress;
                    2963   ; for (i = 0; i < 8; i++) {
00001CF2  4282      2964          clr.l     D2
                    2965   KillAllBreakPoints_1:
00001CF4  0C82 0000 2966          cmp.l     #8,D2
00001CF8  0008      
00001CFA  6C00 0052 2967          bge       KillAllBreakPoints_3
                    2968   ; // clear BP
                    2969   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001CFE  2002      2970          move.l    D2,D0
00001D00  E588      2971          lsl.l     #2,D0
00001D02  41F9 0B00 2972          lea       _BreakPointAddress.L,A0
00001D06  012E      
00001D08  2D70 0800 2973          move.l    0(A0,D0.L),-4(A6)
00001D0C  FFFC      
                    2974   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00001D0E  2002      2975          move.l    D2,D0
00001D10  E388      2976          lsl.l     #1,D0
00001D12  41F9 0B00 2977          lea       _BreakPointInstruction.L,A0
00001D16  014E      
00001D18  226E FFFC 2978          move.l    -4(A6),A1
00001D1C  32B0 0800 2979          move.w    0(A0,D0.L),(A1)
                    2980   ; BreakPointAddress[i] = 0;                                                             // set BP address to NULL
00001D20  2002      2981          move.l    D2,D0
00001D22  E588      2982          lsl.l     #2,D0
00001D24  41F9 0B00 2983          lea       _BreakPointAddress.L,A0
00001D28  012E      
00001D2A  42B0 0800 2984          clr.l     0(A0,D0.L)
                    2985   ; BreakPointInstruction[i] = 0;
00001D2E  2002      2986          move.l    D2,D0
00001D30  E388      2987          lsl.l     #1,D0
00001D32  41F9 0B00 2988          lea       _BreakPointInstruction.L,A0
00001D36  014E      
00001D38  4270 0800 2989          clr.w     0(A0,D0.L)
                    2990   ; BreakPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
00001D3C  2002      2991          move.l    D2,D0
00001D3E  E588      2992          lsl.l     #2,D0
00001D40  41F9 0B00 2993          lea       _BreakPointSetOrCleared.L,A0
00001D44  015E      
00001D46  42B0 0800 2994          clr.l     0(A0,D0.L)
00001D4A  5282      2995          addq.l    #1,D2
00001D4C  60A6      2996          bra       KillAllBreakPoints_1
                    2997   KillAllBreakPoints_3:
00001D4E  241F      2998          move.l    (A7)+,D2
00001D50  4E5E      2999          unlk      A6
00001D52  4E75      3000          rts
                    3001   ; }
                    3002   ; //BreakPointDisplay() ;       // display the break points
                    3003   ; }
                    3004   ; void KillAllWatchPoints(void)
                    3005   ; {
                    3006   _KillAllWatchPoints:
00001D54  2F02      3007          move.l    D2,-(A7)
                    3008   ; int i;
                    3009   ; for (i = 0; i < 8; i++) {
00001D56  4282      3010          clr.l     D2
                    3011   KillAllWatchPoints_1:
00001D58  0C82 0000 3012          cmp.l     #8,D2
00001D5C  0008      
00001D5E  6C20      3013          bge.s     KillAllWatchPoints_3
                    3014   ; WatchPointAddress[i] = 0;                                                             // set BP address to NULL
00001D60  2002      3015          move.l    D2,D0
00001D62  E588      3016          lsl.l     #2,D0
00001D64  41F9 0B00 3017          lea       _WatchPointAddress.L,A0
00001D68  0182      
00001D6A  42B0 0800 3018          clr.l     0(A0,D0.L)
                    3019   ; WatchPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
00001D6E  2002      3020          move.l    D2,D0
00001D70  E588      3021          lsl.l     #2,D0
00001D72  41F9 0B00 3022          lea       _WatchPointSetOrCleared.L,A0
00001D76  01A2      
00001D78  42B0 0800 3023          clr.l     0(A0,D0.L)
00001D7C  5282      3024          addq.l    #1,D2
00001D7E  60D8      3025          bra       KillAllWatchPoints_1
                    3026   KillAllWatchPoints_3:
00001D80  241F      3027          move.l    (A7)+,D2
00001D82  4E75      3028          rts
                    3029   ; }
                    3030   ; //WatchPointDisplay() ;       // display the break points
                    3031   ; }
                    3032   ; void SetBreakPoint(void)
                    3033   ; {
                    3034   _SetBreakPoint:
00001D84  4E56 FFFC 3035          link      A6,#-4
00001D88  48E7 3830 3036          movem.l   D2/D3/D4/A2/A3,-(A7)
00001D8C  45F9 0000 3037          lea       _printf.L,A2
00001D90  4084      
00001D92  47F9 0B00 3038          lea       _BreakPointSetOrCleared.L,A3
00001D96  015E      
                    3039   ; int i;
                    3040   ; int BPNumber;
                    3041   ; int BPAddress;
                    3042   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3043   ; // see if any free break points
                    3044   ; for (i = 0; i < 8; i++) {
00001D98  4282      3045          clr.l     D2
                    3046   SetBreakPoint_1:
00001D9A  0C82 0000 3047          cmp.l     #8,D2
00001D9E  0008      
00001DA0  6C10      3048          bge.s     SetBreakPoint_3
                    3049   ; if (BreakPointSetOrCleared[i] == 0)
00001DA2  2002      3050          move.l    D2,D0
00001DA4  E588      3051          lsl.l     #2,D0
00001DA6  2033 0800 3052          move.l    0(A3,D0.L),D0
00001DAA  6602      3053          bne.s     SetBreakPoint_4
                    3054   ; break;         // if spare BP found allow user to set it
00001DAC  6004      3055          bra.s     SetBreakPoint_3
                    3056   SetBreakPoint_4:
00001DAE  5282      3057          addq.l    #1,D2
00001DB0  60E8      3058          bra       SetBreakPoint_1
                    3059   SetBreakPoint_3:
                    3060   ; }
                    3061   ; if (i == 8) {
00001DB2  0C82 0000 3062          cmp.l     #8,D2
00001DB6  0008      
00001DB8  660E      3063          bne.s     SetBreakPoint_6
                    3064   ; printf("\r\nNo FREE Break Points.....");
00001DBA  4879 0000 3065          pea       @m68kde~3_75.L
00001DBE  5140      
00001DC0  4E92      3066          jsr       (A2)
00001DC2  584F      3067          addq.w    #4,A7
                    3068   ; return;
00001DC4  6000 00D6 3069          bra       SetBreakPoint_15
                    3070   SetBreakPoint_6:
                    3071   ; }
                    3072   ; printf("\r\nBreak Point Address: ");
00001DC8  4879 0000 3073          pea       @m68kde~3_76.L
00001DCC  515C      
00001DCE  4E92      3074          jsr       (A2)
00001DD0  584F      3075          addq.w    #4,A7
                    3076   ; BPAddress = Get8HexDigits(0);
00001DD2  42A7      3077          clr.l     -(A7)
00001DD4  4EB8 0CA4 3078          jsr       _Get8HexDigits
00001DD8  584F      3079          addq.w    #4,A7
00001DDA  2600      3080          move.l    D0,D3
                    3081   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BPAddress);     // point to the instruction in the user program we are about to change
00001DDC  2803      3082          move.l    D3,D4
                    3083   ; if ((BPAddress & 0x00000001) == 0x00000001) {   // cannot set BP at an odd address
00001DDE  2003      3084          move.l    D3,D0
00001DE0  C0BC 0000 3085          and.l     #1,D0
00001DE4  0001      
00001DE6  0C80 0000 3086          cmp.l     #1,D0
00001DEA  0001      
00001DEC  660E      3087          bne.s     SetBreakPoint_9
                    3088   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses");
00001DEE  4879 0000 3089          pea       @m68kde~3_77.L
00001DF2  5174      
00001DF4  4E92      3090          jsr       (A2)
00001DF6  584F      3091          addq.w    #4,A7
                    3092   ; return;
00001DF8  6000 00A2 3093          bra       SetBreakPoint_15
                    3094   SetBreakPoint_9:
                    3095   ; }
                    3096   ; if (BPAddress < 0x00008000) {   // cannot set BP in ROM
00001DFC  0C83 0000 3097          cmp.l     #32768,D3
00001E00  8000      
00001E02  640E      3098          bhs.s     SetBreakPoint_11
                    3099   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]");
00001E04  4879 0000 3100          pea       @m68kde~3_78.L
00001E08  51AA      
00001E0A  4E92      3101          jsr       (A2)
00001E0C  584F      3102          addq.w    #4,A7
                    3103   ; return;
00001E0E  6000 008C 3104          bra       SetBreakPoint_15
                    3105   SetBreakPoint_11:
                    3106   ; }
                    3107   ; // search for first free bp or existing same BP
                    3108   ; for (i = 0; i < 8; i++) {
00001E12  4282      3109          clr.l     D2
                    3110   SetBreakPoint_13:
00001E14  0C82 0000 3111          cmp.l     #8,D2
00001E18  0008      
00001E1A  6C00 0080 3112          bge       SetBreakPoint_15
                    3113   ; if (BreakPointAddress[i] == BPAddress) {
00001E1E  2002      3114          move.l    D2,D0
00001E20  E588      3115          lsl.l     #2,D0
00001E22  41F9 0B00 3116          lea       _BreakPointAddress.L,A0
00001E26  012E      
00001E28  B6B0 0800 3117          cmp.l     0(A0,D0.L),D3
00001E2C  6610      3118          bne.s     SetBreakPoint_16
                    3119   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress);
00001E2E  2F03      3120          move.l    D3,-(A7)
00001E30  4879 0000 3121          pea       @m68kde~3_79.L
00001E34  51F2      
00001E36  4E92      3122          jsr       (A2)
00001E38  504F      3123          addq.w    #8,A7
                    3124   ; return;
00001E3A  6000 0060 3125          bra       SetBreakPoint_15
                    3126   SetBreakPoint_16:
                    3127   ; }
                    3128   ; if (BreakPointSetOrCleared[i] == 0) {
00001E3E  2002      3129          move.l    D2,D0
00001E40  E588      3130          lsl.l     #2,D0
00001E42  2033 0800 3131          move.l    0(A3,D0.L),D0
00001E46  6600 004E 3132          bne       SetBreakPoint_18
                    3133   ; // set BP here
                    3134   ; BreakPointSetOrCleared[i] = 1;                                 // mark this breakpoint as set
00001E4A  2002      3135          move.l    D2,D0
00001E4C  E588      3136          lsl.l     #2,D0
00001E4E  27BC 0000 3137          move.l    #1,0(A3,D0.L)
00001E52  0001 0800 
                    3138   ; BreakPointInstruction[i] = *ProgramBreakPointAddress;          // copy the user program instruction here so we can put it back afterwards
00001E56  2044      3139          move.l    D4,A0
00001E58  2002      3140          move.l    D2,D0
00001E5A  E388      3141          lsl.l     #1,D0
00001E5C  43F9 0B00 3142          lea       _BreakPointInstruction.L,A1
00001E60  014E      
00001E62  3390 0800 3143          move.w    (A0),0(A1,D0.L)
                    3144   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress);
00001E66  2F04      3145          move.l    D4,-(A7)
00001E68  4879 0000 3146          pea       @m68kde~3_80.L
00001E6C  522A      
00001E6E  4E92      3147          jsr       (A2)
00001E70  504F      3148          addq.w    #8,A7
                    3149   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);   // put a Trap14 instruction at the user specified address
00001E72  2044      3150          move.l    D4,A0
00001E74  30BC 4E4E 3151          move.w    #20046,(A0)
                    3152   ; BreakPointAddress[i] = BPAddress;                              // record the address of this break point in the debugger
00001E78  2002      3153          move.l    D2,D0
00001E7A  E588      3154          lsl.l     #2,D0
00001E7C  41F9 0B00 3155          lea       _BreakPointAddress.L,A0
00001E80  012E      
00001E82  2183 0800 3156          move.l    D3,0(A0,D0.L)
                    3157   ; printf("\r\n");
00001E86  4879 0000 3158          pea       @m68kde~3_1.L
00001E8A  49D4      
00001E8C  4E92      3159          jsr       (A2)
00001E8E  584F      3160          addq.w    #4,A7
                    3161   ; BreakPointDisplay();       // display the break points
00001E90  4EB8 1954 3162          jsr       _BreakPointDisplay
                    3163   ; return;
00001E94  6006      3164          bra.s     SetBreakPoint_15
                    3165   SetBreakPoint_18:
00001E96  5282      3166          addq.l    #1,D2
00001E98  6000 FF7A 3167          bra       SetBreakPoint_13
                    3168   SetBreakPoint_15:
00001E9C  4CDF 0C1C 3169          movem.l   (A7)+,D2/D3/D4/A2/A3
00001EA0  4E5E      3170          unlk      A6
00001EA2  4E75      3171          rts
                    3172   ; }
                    3173   ; }
                    3174   ; }
                    3175   ; void SetWatchPoint(void)
                    3176   ; {
                    3177   _SetWatchPoint:
00001EA4  4E56 FFF8 3178          link      A6,#-8
00001EA8  48E7 3030 3179          movem.l   D2/D3/A2/A3,-(A7)
00001EAC  45F9 0000 3180          lea       _printf.L,A2
00001EB0  4084      
00001EB2  47F9 0B00 3181          lea       _WatchPointSetOrCleared.L,A3
00001EB6  01A2      
                    3182   ; int i;
                    3183   ; int WPNumber;
                    3184   ; int WPAddress;
                    3185   ; volatile unsigned short int* ProgramWatchPointAddress;
                    3186   ; // see if any free break points
                    3187   ; for (i = 0; i < 8; i++) {
00001EB8  4282      3188          clr.l     D2
                    3189   SetWatchPoint_1:
00001EBA  0C82 0000 3190          cmp.l     #8,D2
00001EBE  0008      
00001EC0  6C10      3191          bge.s     SetWatchPoint_3
                    3192   ; if (WatchPointSetOrCleared[i] == 0)
00001EC2  2002      3193          move.l    D2,D0
00001EC4  E588      3194          lsl.l     #2,D0
00001EC6  2033 0800 3195          move.l    0(A3,D0.L),D0
00001ECA  6602      3196          bne.s     SetWatchPoint_4
                    3197   ; break;         // if spare WP found allow user to set it
00001ECC  6004      3198          bra.s     SetWatchPoint_3
                    3199   SetWatchPoint_4:
00001ECE  5282      3200          addq.l    #1,D2
00001ED0  60E8      3201          bra       SetWatchPoint_1
                    3202   SetWatchPoint_3:
                    3203   ; }
                    3204   ; if (i == 8) {
00001ED2  0C82 0000 3205          cmp.l     #8,D2
00001ED6  0008      
00001ED8  660E      3206          bne.s     SetWatchPoint_6
                    3207   ; printf("\r\nNo FREE Watch Points.....");
00001EDA  4879 0000 3208          pea       @m68kde~3_81.L
00001EDE  5250      
00001EE0  4E92      3209          jsr       (A2)
00001EE2  584F      3210          addq.w    #4,A7
                    3211   ; return;
00001EE4  6000 008C 3212          bra       SetWatchPoint_11
                    3213   SetWatchPoint_6:
                    3214   ; }
                    3215   ; printf("\r\nWatch Point Address: ");
00001EE8  4879 0000 3216          pea       @m68kde~3_82.L
00001EEC  526C      
00001EEE  4E92      3217          jsr       (A2)
00001EF0  584F      3218          addq.w    #4,A7
                    3219   ; WPAddress = Get8HexDigits(0);
00001EF2  42A7      3220          clr.l     -(A7)
00001EF4  4EB8 0CA4 3221          jsr       _Get8HexDigits
00001EF8  584F      3222          addq.w    #4,A7
00001EFA  2600      3223          move.l    D0,D3
                    3224   ; // search for first free wp or existing same wp
                    3225   ; for (i = 0; i < 8; i++) {
00001EFC  4282      3226          clr.l     D2
                    3227   SetWatchPoint_9:
00001EFE  0C82 0000 3228          cmp.l     #8,D2
00001F02  0008      
00001F04  6C00 006C 3229          bge       SetWatchPoint_11
                    3230   ; if (WatchPointAddress[i] == WPAddress && WPAddress != 0) {     //so we can set a wp at 0
00001F08  2002      3231          move.l    D2,D0
00001F0A  E588      3232          lsl.l     #2,D0
00001F0C  41F9 0B00 3233          lea       _WatchPointAddress.L,A0
00001F10  0182      
00001F12  B6B0 0800 3234          cmp.l     0(A0,D0.L),D3
00001F16  6614      3235          bne.s     SetWatchPoint_12
00001F18  4A83      3236          tst.l     D3
00001F1A  6710      3237          beq.s     SetWatchPoint_12
                    3238   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress);
00001F1C  2F03      3239          move.l    D3,-(A7)
00001F1E  4879 0000 3240          pea       @m68kde~3_83.L
00001F22  5284      
00001F24  4E92      3241          jsr       (A2)
00001F26  504F      3242          addq.w    #8,A7
                    3243   ; return;
00001F28  6000 0048 3244          bra       SetWatchPoint_11
                    3245   SetWatchPoint_12:
                    3246   ; }
                    3247   ; if (WatchPointSetOrCleared[i] == 0) {
00001F2C  2002      3248          move.l    D2,D0
00001F2E  E588      3249          lsl.l     #2,D0
00001F30  2033 0800 3250          move.l    0(A3,D0.L),D0
00001F34  6600 0038 3251          bne       SetWatchPoint_14
                    3252   ; WatchPointSetOrCleared[i] = 1;                                 // mark this watchpoint as set
00001F38  2002      3253          move.l    D2,D0
00001F3A  E588      3254          lsl.l     #2,D0
00001F3C  27BC 0000 3255          move.l    #1,0(A3,D0.L)
00001F40  0001 0800 
                    3256   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress);
00001F44  2F03      3257          move.l    D3,-(A7)
00001F46  4879 0000 3258          pea       @m68kde~3_84.L
00001F4A  52BA      
00001F4C  4E92      3259          jsr       (A2)
00001F4E  504F      3260          addq.w    #8,A7
                    3261   ; WatchPointAddress[i] = WPAddress;                              // record the address of this watch point in the debugger
00001F50  2002      3262          move.l    D2,D0
00001F52  E588      3263          lsl.l     #2,D0
00001F54  41F9 0B00 3264          lea       _WatchPointAddress.L,A0
00001F58  0182      
00001F5A  2183 0800 3265          move.l    D3,0(A0,D0.L)
                    3266   ; printf("\r\n");
00001F5E  4879 0000 3267          pea       @m68kde~3_1.L
00001F62  49D4      
00001F64  4E92      3268          jsr       (A2)
00001F66  584F      3269          addq.w    #4,A7
                    3270   ; WatchPointDisplay();       // display the break points
00001F68  4EB8 1A28 3271          jsr       _WatchPointDisplay
                    3272   ; return;
00001F6C  6004      3273          bra.s     SetWatchPoint_11
                    3274   SetWatchPoint_14:
00001F6E  5282      3275          addq.l    #1,D2
00001F70  608C      3276          bra       SetWatchPoint_9
                    3277   SetWatchPoint_11:
00001F72  4CDF 0C0C 3278          movem.l   (A7)+,D2/D3/A2/A3
00001F76  4E5E      3279          unlk      A6
00001F78  4E75      3280          rts
                    3281   ; }
                    3282   ; }
                    3283   ; }
                    3284   ; void HandleBreakPoint(void)
                    3285   ; {
                    3286   _HandleBreakPoint:
00001F7A  4E56 FFFC 3287          link      A6,#-4
00001F7E  48E7 0038 3288          movem.l   A2/A3/A4,-(A7)
00001F82  45F9 0B00 3289          lea       _i.L,A2
00001F86  00C4      
00001F88  47F9 0000 3290          lea       _printf.L,A3
00001F8C  4084      
00001F8E  49F9 0B00 3291          lea       _PC.L,A4
00001F92  0120      
                    3292   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3293   ; // now we have to put the break point back to run the instruction
                    3294   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3295   ; PC = PC - 2;  // ready for user to resume after reaching breakpoint
00001F94  5594      3296          subq.l    #2,(A4)
                    3297   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT");
00001F96  4879 0000 3298          pea       @m68kde~3_85.L
00001F9A  52E0      
00001F9C  4E93      3299          jsr       (A3)
00001F9E  584F      3300          addq.w    #4,A7
                    3301   ; printf("\r\nSingle Step : [ON]");
00001FA0  4879 0000 3302          pea       @m68kde~3_86.L
00001FA4  52F4      
00001FA6  4E93      3303          jsr       (A3)
00001FA8  584F      3304          addq.w    #4,A7
                    3305   ; printf("\r\nBreakPoints : [Enabled]");
00001FAA  4879 0000 3306          pea       @m68kde~3_87.L
00001FAE  530A      
00001FB0  4E93      3307          jsr       (A3)
00001FB2  584F      3308          addq.w    #4,A7
                    3309   ; // now clear the break point (put original instruction back)
                    3310   ; ProgramBreakPointAddress = PC;
00001FB4  2D54 FFFC 3311          move.l    (A4),-4(A6)
                    3312   ; for (i = 0; i < 8; i++) {
00001FB8  4292      3313          clr.l     (A2)
                    3314   HandleBreakPoint_1:
00001FBA  2012      3315          move.l    (A2),D0
00001FBC  0C80 0000 3316          cmp.l     #8,D0
00001FC0  0008      
00001FC2  6400 0056 3317          bhs       HandleBreakPoint_3
                    3318   ; if (BreakPointAddress[i] == PC) {        // if we have found the breakpoint
00001FC6  2012      3319          move.l    (A2),D0
00001FC8  E588      3320          lsl.l     #2,D0
00001FCA  41F9 0B00 3321          lea       _BreakPointAddress.L,A0
00001FCE  012E      
00001FD0  2230 0800 3322          move.l    0(A0,D0.L),D1
00001FD4  B294      3323          cmp.l     (A4),D1
00001FD6  6600 003E 3324          bne       HandleBreakPoint_4
                    3325   ; BreakPointAddress[i] = 0;
00001FDA  2012      3326          move.l    (A2),D0
00001FDC  E588      3327          lsl.l     #2,D0
00001FDE  41F9 0B00 3328          lea       _BreakPointAddress.L,A0
00001FE2  012E      
00001FE4  42B0 0800 3329          clr.l     0(A0,D0.L)
                    3330   ; BreakPointSetOrCleared[i] = 0;
00001FE8  2012      3331          move.l    (A2),D0
00001FEA  E588      3332          lsl.l     #2,D0
00001FEC  41F9 0B00 3333          lea       _BreakPointSetOrCleared.L,A0
00001FF0  015E      
00001FF2  42B0 0800 3334          clr.l     0(A0,D0.L)
                    3335   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
00001FF6  2012      3336          move.l    (A2),D0
00001FF8  E388      3337          lsl.l     #1,D0
00001FFA  41F9 0B00 3338          lea       _BreakPointInstruction.L,A0
00001FFE  014E      
00002000  226E FFFC 3339          move.l    -4(A6),A1
00002004  32B0 0800 3340          move.w    0(A0,D0.L),(A1)
                    3341   ; BreakPointInstruction[i] = 0;
00002008  2012      3342          move.l    (A2),D0
0000200A  E388      3343          lsl.l     #1,D0
0000200C  41F9 0B00 3344          lea       _BreakPointInstruction.L,A0
00002010  014E      
00002012  4270 0800 3345          clr.w     0(A0,D0.L)
                    3346   HandleBreakPoint_4:
00002016  5292      3347          addq.l    #1,(A2)
00002018  60A0      3348          bra       HandleBreakPoint_1
                    3349   HandleBreakPoint_3:
                    3350   ; }
                    3351   ; }
                    3352   ; DumpRegisters();
0000201A  4EB8 11A6 3353          jsr       _DumpRegisters
                    3354   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000201E  4879 0000 3355          pea       @m68kde~3_49.L
00002022  4E86      
00002024  4E93      3356          jsr       (A3)
00002026  584F      3357          addq.w    #4,A7
                    3358   ; printf("\r\nPress <ESC> to Resume User Program\r\n");
00002028  4879 0000 3359          pea       @m68kde~3_88.L
0000202C  5324      
0000202E  4E93      3360          jsr       (A3)
00002030  584F      3361          addq.w    #4,A7
                    3362   ; menu();
00002032  4EB9 0000 3363          jsr       _menu
00002036  223E      
00002038  4CDF 1C00 3364          movem.l   (A7)+,A2/A3/A4
0000203C  4E5E      3365          unlk      A6
0000203E  4E75      3366          rts
                    3367   ; }
                    3368   ; void UnknownCommand()
                    3369   ; {
                    3370   _UnknownCommand:
                    3371   ; printf("\r\nUnknown Command.....\r\n");
00002040  4879 0000 3372          pea       @m68kde~3_89.L
00002044  534C      
00002046  4EB9 0000 3373          jsr       _printf
0000204A  4084      
0000204C  584F      3374          addq.w    #4,A7
                    3375   ; Help();
0000204E  4EB9 0000 3376          jsr       _Help
00002052  2164      
00002054  4E75      3377          rts
                    3378   ; }
                    3379   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3380   ; void CallDebugMonitor(void)
                    3381   ; {
                    3382   _CallDebugMonitor:
                    3383   ; printf("\r\nProgram Ended (TRAP #15)....");
00002056  4879 0000 3384          pea       @m68kde~3_90.L
0000205A  5366      
0000205C  4EB9 0000 3385          jsr       _printf
00002060  4084      
00002062  584F      3386          addq.w    #4,A7
                    3387   ; menu();
00002064  4EB9 0000 3388          jsr       _menu
00002068  223E      
0000206A  4E75      3389          rts
                    3390   ; }
                    3391   ; void Breakpoint(void)
                    3392   ; {
                    3393   _Breakpoint:
0000206C  2F02      3394          move.l    D2,-(A7)
                    3395   ; char c;
                    3396   ; c = toupper(_getch());
0000206E  2F00      3397          move.l    D0,-(A7)
00002070  4EB8 0B68 3398          jsr       __getch
00002074  2200      3399          move.l    D0,D1
00002076  201F      3400          move.l    (A7)+,D0
00002078  2F01      3401          move.l    D1,-(A7)
0000207A  4EB9 0000 3402          jsr       _toupper
0000207E  4058      
00002080  584F      3403          addq.w    #4,A7
00002082  1400      3404          move.b    D0,D2
                    3405   ; if (c == (char)('D'))                                      // BreakPoint Display
00002084  0C02 0044 3406          cmp.b     #68,D2
00002088  6608      3407          bne.s     Breakpoint_1
                    3408   ; BreakPointDisplay();
0000208A  4EB8 1954 3409          jsr       _BreakPointDisplay
0000208E  6000 0054 3410          bra       Breakpoint_10
                    3411   Breakpoint_1:
                    3412   ; else if (c == (char)('K')) {                                 // breakpoint Kill
00002092  0C02 004B 3413          cmp.b     #75,D2
00002096  6630      3414          bne.s     Breakpoint_3
                    3415   ; printf("\r\nKill All Break Points...(y/n)?");
00002098  4879 0000 3416          pea       @m68kde~3_91.L
0000209C  5386      
0000209E  4EB9 0000 3417          jsr       _printf
000020A2  4084      
000020A4  584F      3418          addq.w    #4,A7
                    3419   ; c = toupper(_getch());
000020A6  2F00      3420          move.l    D0,-(A7)
000020A8  4EB8 0B68 3421          jsr       __getch
000020AC  2200      3422          move.l    D0,D1
000020AE  201F      3423          move.l    (A7)+,D0
000020B0  2F01      3424          move.l    D1,-(A7)
000020B2  4EB9 0000 3425          jsr       _toupper
000020B6  4058      
000020B8  584F      3426          addq.w    #4,A7
000020BA  1400      3427          move.b    D0,D2
                    3428   ; if (c == (char)('Y'))
000020BC  0C02 0059 3429          cmp.b     #89,D2
000020C0  6604      3430          bne.s     Breakpoint_5
                    3431   ; KillAllBreakPoints();
000020C2  4EB8 1CEC 3432          jsr       _KillAllBreakPoints
                    3433   Breakpoint_5:
000020C6  601C      3434          bra.s     Breakpoint_10
                    3435   Breakpoint_3:
                    3436   ; }
                    3437   ; else if (c == (char)('S')) {
000020C8  0C02 0053 3438          cmp.b     #83,D2
000020CC  6606      3439          bne.s     Breakpoint_7
                    3440   ; SetBreakPoint();
000020CE  4EB8 1D84 3441          jsr       _SetBreakPoint
000020D2  6010      3442          bra.s     Breakpoint_10
                    3443   Breakpoint_7:
                    3444   ; }
                    3445   ; else if (c == (char)('C')) {
000020D4  0C02 0043 3446          cmp.b     #67,D2
000020D8  6606      3447          bne.s     Breakpoint_9
                    3448   ; BreakPointClear();
000020DA  4EB8 1AD4 3449          jsr       _BreakPointClear
000020DE  6004      3450          bra.s     Breakpoint_10
                    3451   Breakpoint_9:
                    3452   ; }
                    3453   ; else
                    3454   ; UnknownCommand();
000020E0  4EB8 2040 3455          jsr       _UnknownCommand
                    3456   Breakpoint_10:
000020E4  241F      3457          move.l    (A7)+,D2
000020E6  4E75      3458          rts
                    3459   ; }
                    3460   ; void Watchpoint(void)
                    3461   ; {
                    3462   _Watchpoint:
000020E8  2F02      3463          move.l    D2,-(A7)
                    3464   ; char c;
                    3465   ; c = toupper(_getch());
000020EA  2F00      3466          move.l    D0,-(A7)
000020EC  4EB8 0B68 3467          jsr       __getch
000020F0  2200      3468          move.l    D0,D1
000020F2  201F      3469          move.l    (A7)+,D0
000020F4  2F01      3470          move.l    D1,-(A7)
000020F6  4EB9 0000 3471          jsr       _toupper
000020FA  4058      
000020FC  584F      3472          addq.w    #4,A7
000020FE  1400      3473          move.b    D0,D2
                    3474   ; if (c == (char)('D'))                                      // WatchPoint Display
00002100  0C02 0044 3475          cmp.b     #68,D2
00002104  6608      3476          bne.s     Watchpoint_1
                    3477   ; WatchPointDisplay();
00002106  4EB8 1A28 3478          jsr       _WatchPointDisplay
0000210A  6000 0054 3479          bra       Watchpoint_10
                    3480   Watchpoint_1:
                    3481   ; else if (c == (char)('K')) {                                 // wtahcpoint Kill
0000210E  0C02 004B 3482          cmp.b     #75,D2
00002112  6630      3483          bne.s     Watchpoint_3
                    3484   ; printf("\r\nKill All Watch Points...(y/n)?");
00002114  4879 0000 3485          pea       @m68kde~3_92.L
00002118  53A8      
0000211A  4EB9 0000 3486          jsr       _printf
0000211E  4084      
00002120  584F      3487          addq.w    #4,A7
                    3488   ; c = toupper(_getch());
00002122  2F00      3489          move.l    D0,-(A7)
00002124  4EB8 0B68 3490          jsr       __getch
00002128  2200      3491          move.l    D0,D1
0000212A  201F      3492          move.l    (A7)+,D0
0000212C  2F01      3493          move.l    D1,-(A7)
0000212E  4EB9 0000 3494          jsr       _toupper
00002132  4058      
00002134  584F      3495          addq.w    #4,A7
00002136  1400      3496          move.b    D0,D2
                    3497   ; if (c == (char)('Y'))
00002138  0C02 0059 3498          cmp.b     #89,D2
0000213C  6604      3499          bne.s     Watchpoint_5
                    3500   ; KillAllWatchPoints();
0000213E  4EB8 1D54 3501          jsr       _KillAllWatchPoints
                    3502   Watchpoint_5:
00002142  601C      3503          bra.s     Watchpoint_10
                    3504   Watchpoint_3:
                    3505   ; }
                    3506   ; else if (c == (char)('S')) {
00002144  0C02 0053 3507          cmp.b     #83,D2
00002148  6606      3508          bne.s     Watchpoint_7
                    3509   ; SetWatchPoint();
0000214A  4EB8 1EA4 3510          jsr       _SetWatchPoint
0000214E  6010      3511          bra.s     Watchpoint_10
                    3512   Watchpoint_7:
                    3513   ; }
                    3514   ; else if (c == (char)('C')) {
00002150  0C02 0043 3515          cmp.b     #67,D2
00002154  6606      3516          bne.s     Watchpoint_9
                    3517   ; WatchPointClear();
00002156  4EB8 1BAE 3518          jsr       _WatchPointClear
0000215A  6004      3519          bra.s     Watchpoint_10
                    3520   Watchpoint_9:
                    3521   ; }
                    3522   ; else
                    3523   ; UnknownCommand();
0000215C  4EB8 2040 3524          jsr       _UnknownCommand
                    3525   Watchpoint_10:
00002160  241F      3526          move.l    (A7)+,D2
00002162  4E75      3527          rts
                    3528   ; }
                    3529   ; void Help(void)
                    3530   ; {
                    3531   _Help:
00002164  48E7 2020 3532          movem.l   D2/A2,-(A7)
00002168  45F9 0000 3533          lea       _printf.L,A2
0000216C  4084      
                    3534   ; char* banner = "\r\n----------------------------------------------------------------";
0000216E  41F9 0000 3535          lea       @m68kde~3_93.L,A0
00002172  53CA      
00002174  2408      3536          move.l    A0,D2
                    3537   ; printf(banner);
00002176  2F02      3538          move.l    D2,-(A7)
00002178  4E92      3539          jsr       (A2)
0000217A  584F      3540          addq.w    #4,A7
                    3541   ; printf("\r\n  Debugger Command Summary");
0000217C  4879 0000 3542          pea       @m68kde~3_94.L
00002180  540E      
00002182  4E92      3543          jsr       (A2)
00002184  584F      3544          addq.w    #4,A7
                    3545   ; printf(banner);
00002186  2F02      3546          move.l    D2,-(A7)
00002188  4E92      3547          jsr       (A2)
0000218A  584F      3548          addq.w    #4,A7
                    3549   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
0000218C  4879 0000 3550          pea       @m68kde~3_95.L
00002190  542C      
00002192  4E92      3551          jsr       (A2)
00002194  584F      3552          addq.w    #4,A7
                    3553   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill");
00002196  4879 0000 3554          pea       @m68kde~3_96.L
0000219A  5470      
0000219C  4E92      3555          jsr       (A2)
0000219E  584F      3556          addq.w    #4,A7
                    3557   ; printf("\r\n  C            - Copy Program from Flash to Main Memory");
000021A0  4879 0000 3558          pea       @m68kde~3_97.L
000021A4  54A8      
000021A6  4E92      3559          jsr       (A2)
000021A8  584F      3560          addq.w    #4,A7
                    3561   ; printf("\r\n  D            - Dump Memory Contents to Screen");
000021AA  4879 0000 3562          pea       @m68kde~3_98.L
000021AE  54E2      
000021B0  4E92      3563          jsr       (A2)
000021B2  584F      3564          addq.w    #4,A7
                    3565   ; printf("\r\n  E            - Enter String into Memory");
000021B4  4879 0000 3566          pea       @m68kde~3_99.L
000021B8  5514      
000021BA  4E92      3567          jsr       (A2)
000021BC  584F      3568          addq.w    #4,A7
                    3569   ; printf("\r\n  F            - Fill Memory with Data");
000021BE  4879 0000 3570          pea       @m68kde~3_100.L
000021C2  5540      
000021C4  4E92      3571          jsr       (A2)
000021C6  584F      3572          addq.w    #4,A7
                    3573   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC);
000021C8  2F39 0B00 3574          move.l    _PC.L,-(A7)
000021CC  0120      
000021CE  4879 0000 3575          pea       @m68kde~3_101.L
000021D2  556A      
000021D4  4E92      3576          jsr       (A2)
000021D6  504F      3577          addq.w    #8,A7
                    3578   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop");
000021D8  4879 0000 3579          pea       @m68kde~3_102.L
000021DC  55A4      
000021DE  4E92      3580          jsr       (A2)
000021E0  584F      3581          addq.w    #4,A7
                    3582   ; printf("\r\n  M            - Memory Examine and Change");
000021E2  4879 0000 3583          pea       @m68kde~3_103.L
000021E6  55DC      
000021E8  4E92      3584          jsr       (A2)
000021EA  584F      3585          addq.w    #4,A7
                    3586   ; printf("\r\n  P            - Program Flash Memory with User Program");
000021EC  4879 0000 3587          pea       @m68kde~3_104.L
000021F0  560A      
000021F2  4E92      3588          jsr       (A2)
000021F4  584F      3589          addq.w    #4,A7
                    3590   ; printf("\r\n  R            - Display 68000 Registers");
000021F6  4879 0000 3591          pea       @m68kde~3_105.L
000021FA  5644      
000021FC  4E92      3592          jsr       (A2)
000021FE  584F      3593          addq.w    #4,A7
                    3594   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode");
00002200  4879 0000 3595          pea       @m68kde~3_106.L
00002204  5670      
00002206  4E92      3596          jsr       (A2)
00002208  584F      3597          addq.w    #4,A7
                    3598   ; printf("\r\n  TM           - Test Memory");
0000220A  4879 0000 3599          pea       @m68kde~3_107.L
0000220E  56A2      
00002210  4E92      3600          jsr       (A2)
00002212  584F      3601          addq.w    #4,A7
                    3602   ; printf("\r\n  TS           - Test Switches: SW7-0");
00002214  4879 0000 3603          pea       @m68kde~3_108.L
00002218  56C2      
0000221A  4E92      3604          jsr       (A2)
0000221C  584F      3605          addq.w    #4,A7
                    3606   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment");
0000221E  4879 0000 3607          pea       @m68kde~3_109.L
00002222  56EA      
00002224  4E92      3608          jsr       (A2)
00002226  584F      3609          addq.w    #4,A7
                    3610   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill");
00002228  4879 0000 3611          pea       @m68kde~3_110.L
0000222C  5720      
0000222E  4E92      3612          jsr       (A2)
00002230  584F      3613          addq.w    #4,A7
                    3614   ; printf(banner);
00002232  2F02      3615          move.l    D2,-(A7)
00002234  4E92      3616          jsr       (A2)
00002236  584F      3617          addq.w    #4,A7
00002238  4CDF 0404 3618          movem.l   (A7)+,D2/A2
0000223C  4E75      3619          rts
                    3620   ; }
                    3621   ; void menu(void)
                    3622   ; {
                    3623   _menu:
0000223E  48E7 303C 3624          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002242  45F9 0000 3625          lea       _printf.L,A2
00002246  4084      
00002248  47F9 0B00 3626          lea       _Trace.L,A3
0000224C  00D8      
0000224E  49F9 0B00 3627          lea       _x.L,A4
00002252  00C8      
00002254  4BF9 0B00 3628          lea       _SR.L,A5
00002258  012C      
                    3629   ; char c, c1;
                    3630   ; while (1) {
                    3631   menu_1:
                    3632   ; FlushKeyboard();               // dump unread characters from keyboard
0000225A  4EB8 0BA6 3633          jsr       _FlushKeyboard
                    3634   ; printf("\r\n#");
0000225E  4879 0000 3635          pea       @m68kde~3_111.L
00002262  5758      
00002264  4E92      3636          jsr       (A2)
00002266  584F      3637          addq.w    #4,A7
                    3638   ; c = toupper(_getch());
00002268  2F00      3639          move.l    D0,-(A7)
0000226A  4EB8 0B68 3640          jsr       __getch
0000226E  2200      3641          move.l    D0,D1
00002270  201F      3642          move.l    (A7)+,D0
00002272  2F01      3643          move.l    D1,-(A7)
00002274  4EB9 0000 3644          jsr       _toupper
00002278  4058      
0000227A  584F      3645          addq.w    #4,A7
0000227C  1400      3646          move.b    D0,D2
                    3647   ; if (c == (char)('L'))                  // load s record file
0000227E  0C02 004C 3648          cmp.b     #76,D2
00002282  6608      3649          bne.s     menu_4
                    3650   ; Load_SRecordFile();
00002284  4EB8 0E36 3651          jsr       _Load_SRecordFile
00002288  6000 0284 3652          bra       menu_60
                    3653   menu_4:
                    3654   ; else if (c == (char)('D'))             // dump memory
0000228C  0C02 0044 3655          cmp.b     #68,D2
00002290  6608      3656          bne.s     menu_6
                    3657   ; DumpMemory();
00002292  4EB8 0CCC 3658          jsr       _DumpMemory
00002296  6000 0276 3659          bra       menu_60
                    3660   menu_6:
                    3661   ; else if (c == (char)('E'))             // Enter String into memory
0000229A  0C02 0045 3662          cmp.b     #69,D2
0000229E  660A      3663          bne.s     menu_8
                    3664   ; EnterString();
000022A0  4EB9 0000 3665          jsr       _EnterString
000022A4  2656      
000022A6  6000 0266 3666          bra       menu_60
                    3667   menu_8:
                    3668   ; else if (c == (char)('F'))             // fill memory
000022AA  0C02 0046 3669          cmp.b     #70,D2
000022AE  6608      3670          bne.s     menu_10
                    3671   ; FillMemory();
000022B0  4EB8 0DBC 3672          jsr       _FillMemory
000022B4  6000 0258 3673          bra       menu_60
                    3674   menu_10:
                    3675   ; else if (c == (char)('G')) {           // go user program
000022B8  0C02 0047 3676          cmp.b     #71,D2
000022BC  6626      3677          bne.s     menu_12
                    3678   ; printf("\r\nProgram Running.....");
000022BE  4879 0000 3679          pea       @m68kde~3_112.L
000022C2  575C      
000022C4  4E92      3680          jsr       (A2)
000022C6  584F      3681          addq.w    #4,A7
                    3682   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
000022C8  4879 0000 3683          pea       @m68kde~3_113.L
000022CC  5774      
000022CE  4E92      3684          jsr       (A2)
000022D0  584F      3685          addq.w    #4,A7
                    3686   ; GoFlag = 1;
000022D2  23FC 0000 3687          move.l    #1,_GoFlag.L
000022D6  0001 0B00 
000022DA  00DC      
                    3688   ; go();
000022DC  4EB8 08B8 3689          jsr       _go
000022E0  6000 022C 3690          bra       menu_60
                    3691   menu_12:
                    3692   ; }
                    3693   ; else if (c == (char)('M'))           // memory examine and modify
000022E4  0C02 004D 3694          cmp.b     #77,D2
000022E8  6608      3695          bne.s     menu_14
                    3696   ; MemoryChange();
000022EA  4EB8 0FC4 3697          jsr       _MemoryChange
000022EE  6000 021E 3698          bra       menu_60
                    3699   menu_14:
                    3700   ; else if (c == (char)('P'))            // Program Flash Chip
000022F2  0C02 0050 3701          cmp.b     #80,D2
000022F6  6608      3702          bne.s     menu_16
                    3703   ; ProgramFlashChip();
000022F8  4EB8 10C4 3704          jsr       _ProgramFlashChip
000022FC  6000 0210 3705          bra       menu_60
                    3706   menu_16:
                    3707   ; else if (c == (char)('C'))             // copy flash chip to ram and go
00002300  0C02 0043 3708          cmp.b     #67,D2
00002304  6608      3709          bne.s     menu_18
                    3710   ; LoadFromFlashChip();
00002306  4EB8 115C 3711          jsr       _LoadFromFlashChip
0000230A  6000 0202 3712          bra       menu_60
                    3713   menu_18:
                    3714   ; else if (c == (char)('R'))             // dump registers
0000230E  0C02 0052 3715          cmp.b     #82,D2
00002312  6608      3716          bne.s     menu_20
                    3717   ; DumpRegisters();
00002314  4EB8 11A6 3718          jsr       _DumpRegisters
00002318  6000 01F4 3719          bra       menu_60
                    3720   menu_20:
                    3721   ; else if (c == (char)('.'))           // change registers
0000231C  0C02 002E 3722          cmp.b     #46,D2
00002320  6608      3723          bne.s     menu_22
                    3724   ; ChangeRegisters();
00002322  4EB8 1698 3725          jsr       _ChangeRegisters
00002326  6000 01E6 3726          bra       menu_60
                    3727   menu_22:
                    3728   ; else if (c == (char)('B'))              // breakpoint command
0000232A  0C02 0042 3729          cmp.b     #66,D2
0000232E  6608      3730          bne.s     menu_24
                    3731   ; Breakpoint();
00002330  4EB8 206C 3732          jsr       _Breakpoint
00002334  6000 01D8 3733          bra       menu_60
                    3734   menu_24:
                    3735   ; else if (c == (char)('T')) {          // Test command
00002338  0C02 0054 3736          cmp.b     #84,D2
0000233C  6600 0046 3737          bne       menu_26
                    3738   ; c1 = toupper(_getch());
00002340  2F00      3739          move.l    D0,-(A7)
00002342  4EB8 0B68 3740          jsr       __getch
00002346  2200      3741          move.l    D0,D1
00002348  201F      3742          move.l    (A7)+,D0
0000234A  2F01      3743          move.l    D1,-(A7)
0000234C  4EB9 0000 3744          jsr       _toupper
00002350  4058      
00002352  584F      3745          addq.w    #4,A7
00002354  1600      3746          move.b    D0,D3
                    3747   ; if (c1 == (char)('M'))                    // memory test
00002356  0C03 004D 3748          cmp.b     #77,D3
0000235A  6608      3749          bne.s     menu_28
                    3750   ; MemoryTest();
0000235C  4EB9 0000 3751          jsr       _MemoryTest
00002360  26A6      
00002362  601C      3752          bra.s     menu_33
                    3753   menu_28:
                    3754   ; else if (c1 == (char)('S'))              // Switch Test command
00002364  0C03 0053 3755          cmp.b     #83,D3
00002368  6606      3756          bne.s     menu_30
                    3757   ; SwitchTest();
0000236A  4EB8 0AA4 3758          jsr       _SwitchTest
0000236E  6010      3759          bra.s     menu_33
                    3760   menu_30:
                    3761   ; else if (c1 == (char)('D'))              // display Test command
00002370  0C03 0044 3762          cmp.b     #68,D3
00002374  6606      3763          bne.s     menu_32
                    3764   ; TestLEDS();
00002376  4EB8 0A50 3765          jsr       _TestLEDS
0000237A  6004      3766          bra.s     menu_33
                    3767   menu_32:
                    3768   ; else
                    3769   ; UnknownCommand();
0000237C  4EB8 2040 3770          jsr       _UnknownCommand
                    3771   menu_33:
00002380  6000 018C 3772          bra       menu_60
                    3773   menu_26:
                    3774   ; }
                    3775   ; else if (c == (char)(' ')) {             // Next instruction command
00002384  0C02 0020 3776          cmp.b     #32,D2
00002388  6636      3777          bne.s     menu_34
                    3778   ; DisableBreakPoints();
0000238A  4EB8 1C50 3779          jsr       _DisableBreakPoints
                    3780   ; if (Trace == 1 && GoFlag == 1) {    // if the program is running and trace mode on then 'N' is valid
0000238E  2013      3781          move.l    (A3),D0
00002390  0C80 0000 3782          cmp.l     #1,D0
00002394  0001      
00002396  661A      3783          bne.s     menu_36
00002398  2039 0B00 3784          move.l    _GoFlag.L,D0
0000239C  00DC      
0000239E  0C80 0000 3785          cmp.l     #1,D0
000023A2  0001      
000023A4  660C      3786          bne.s     menu_36
                    3787   ; TraceException = 1;             // generate a trace exception for the next instruction if user wants to single step though next instruction
000023A6  13FC 0001 3788          move.b    #1,4194314
000023AA  0040 000A 
                    3789   ; return;
000023AE  6000 0162 3790          bra       menu_38
                    3791   menu_36:
                    3792   ; }
                    3793   ; else
                    3794   ; printf("\r\nError: Press 'G' first to start program");
000023B2  4879 0000 3795          pea       @m68kde~3_114.L
000023B6  57A2      
000023B8  4E92      3796          jsr       (A2)
000023BA  584F      3797          addq.w    #4,A7
000023BC  6000 0150 3798          bra       menu_60
                    3799   menu_34:
                    3800   ; }
                    3801   ; else if (c == (char)('S')) {             // single step
000023C0  0C02 0053 3802          cmp.b     #83,D2
000023C4  6600 008C 3803          bne       menu_39
                    3804   ; if (Trace == 0) {
000023C8  2013      3805          move.l    (A3),D0
000023CA  6600 0050 3806          bne       menu_41
                    3807   ; DisableBreakPoints();
000023CE  4EB8 1C50 3808          jsr       _DisableBreakPoints
                    3809   ; printf("\r\nSingle Step  :[ON]");
000023D2  4879 0000 3810          pea       @m68kde~3_115.L
000023D6  57CC      
000023D8  4E92      3811          jsr       (A2)
000023DA  584F      3812          addq.w    #4,A7
                    3813   ; printf("\r\nBreak Points :[Disabled]");
000023DC  4879 0000 3814          pea       @m68kde~3_48.L
000023E0  4E6A      
000023E2  4E92      3815          jsr       (A2)
000023E4  584F      3816          addq.w    #4,A7
                    3817   ; SR = SR | (unsigned short int)(0x8000);    // set T bit in status register
000023E6  0055 8000 3818          or.w      #32768,(A5)
                    3819   ; printf("\r\nPress 'G' to Trace Program from address $%X.....", PC);
000023EA  2F39 0B00 3820          move.l    _PC.L,-(A7)
000023EE  0120      
000023F0  4879 0000 3821          pea       @m68kde~3_116.L
000023F4  57E2      
000023F6  4E92      3822          jsr       (A2)
000023F8  504F      3823          addq.w    #8,A7
                    3824   ; printf("\r\nPush <RESET Button> to Stop.....");
000023FA  4879 0000 3825          pea       @m68kde~3_117.L
000023FE  5816      
00002400  4E92      3826          jsr       (A2)
00002402  584F      3827          addq.w    #4,A7
                    3828   ; DumpRegisters();
00002404  4EB8 11A6 3829          jsr       _DumpRegisters
                    3830   ; Trace = 1;
00002408  26BC 0000 3831          move.l    #1,(A3)
0000240C  0001      
                    3832   ; TraceException = 1;
0000240E  13FC 0001 3833          move.b    #1,4194314
00002412  0040 000A 
                    3834   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002416  28B8 0074 3835          move.l    116,(A4)
0000241A  6032      3836          bra.s     menu_42
                    3837   menu_41:
                    3838   ; }
                    3839   ; else {
                    3840   ; Trace = 0;
0000241C  4293      3841          clr.l     (A3)
                    3842   ; TraceException = 0;
0000241E  4239 0040 3843          clr.b     4194314
00002422  000A      
                    3844   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002424  28B8 0074 3845          move.l    116,(A4)
                    3846   ; EnableBreakPoints();
00002428  4EB8 1CA4 3847          jsr       _EnableBreakPoints
                    3848   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000242C  0255 7FFF 3849          and.w     #32767,(A5)
                    3850   ; printf("\r\nSingle Step : [OFF]");
00002430  4879 0000 3851          pea       @m68kde~3_118.L
00002434  583A      
00002436  4E92      3852          jsr       (A2)
00002438  584F      3853          addq.w    #4,A7
                    3854   ; printf("\r\nBreak Points :[Enabled]");
0000243A  4879 0000 3855          pea       @m68kde~3_119.L
0000243E  5850      
00002440  4E92      3856          jsr       (A2)
00002442  584F      3857          addq.w    #4,A7
                    3858   ; printf("\r\nPress <ESC> to Resume User Program.....");
00002444  4879 0000 3859          pea       @m68kde~3_120.L
00002448  586A      
0000244A  4E92      3860          jsr       (A2)
0000244C  584F      3861          addq.w    #4,A7
                    3862   menu_42:
0000244E  6000 00BE 3863          bra       menu_60
                    3864   menu_39:
                    3865   ; }
                    3866   ; }
                    3867   ; else if (c == (char)(0x1b)) {   // if user choses to end trace and run program
00002452  0C02 001B 3868          cmp.b     #27,D2
00002456  6600 0042 3869          bne       menu_43
                    3870   ; Trace = 0;
0000245A  4293      3871          clr.l     (A3)
                    3872   ; TraceException = 0;
0000245C  4239 0040 3873          clr.b     4194314
00002460  000A      
                    3874   ; x = *(unsigned int*)(0x00000074);   // read IRQ 5 vector to reset trace vector generator
00002462  28B8 0074 3875          move.l    116,(A4)
                    3876   ; EnableBreakPoints();
00002466  4EB8 1CA4 3877          jsr       _EnableBreakPoints
                    3878   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000246A  0255 7FFF 3879          and.w     #32767,(A5)
                    3880   ; printf("\r\nSingle Step  :[OFF]");
0000246E  4879 0000 3881          pea       @m68kde~3_121.L
00002472  5894      
00002474  4E92      3882          jsr       (A2)
00002476  584F      3883          addq.w    #4,A7
                    3884   ; printf("\r\nBreak Points :[Enabled]");
00002478  4879 0000 3885          pea       @m68kde~3_119.L
0000247C  5850      
0000247E  4E92      3886          jsr       (A2)
00002480  584F      3887          addq.w    #4,A7
                    3888   ; printf("\r\nProgram Running.....");
00002482  4879 0000 3889          pea       @m68kde~3_112.L
00002486  575C      
00002488  4E92      3890          jsr       (A2)
0000248A  584F      3891          addq.w    #4,A7
                    3892   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
0000248C  4879 0000 3893          pea       @m68kde~3_113.L
00002490  5774      
00002492  4E92      3894          jsr       (A2)
00002494  584F      3895          addq.w    #4,A7
                    3896   ; return;
00002496  6000 007A 3897          bra       menu_38
                    3898   menu_43:
                    3899   ; }
                    3900   ; else if (c == (char)('W'))              // Watchpoint command
0000249A  0C02 0057 3901          cmp.b     #87,D2
0000249E  6608      3902          bne.s     menu_45
                    3903   ; Watchpoint();
000024A0  4EB8 20E8 3904          jsr       _Watchpoint
000024A4  6000 0068 3905          bra       menu_60
                    3906   menu_45:
                    3907   ; else if (c == (char)('1')){ //I2C Write 
000024A8  0C02 0031 3908          cmp.b     #49,D2
000024AC  660A      3909          bne.s     menu_47
                    3910   ; WriteI2C();
000024AE  4EB9 0000 3911          jsr       _WriteI2C
000024B2  2DE8      
000024B4  6000 0058 3912          bra       menu_60
                    3913   menu_47:
                    3914   ; }
                    3915   ; else if (c == (char)('2')){  //I2C Read
000024B8  0C02 0032 3916          cmp.b     #50,D2
000024BC  660A      3917          bne.s     menu_49
                    3918   ; ReadI2C();
000024BE  4EB9 0000 3919          jsr       _ReadI2C
000024C2  2ED8      
000024C4  6000 0048 3920          bra       menu_60
                    3921   menu_49:
                    3922   ; }
                    3923   ; else if (c == (char)('3')){  //I2C Page Write
000024C8  0C02 0033 3924          cmp.b     #51,D2
000024CC  660A      3925          bne.s     menu_51
                    3926   ; PageWriteI2C();
000024CE  4EB9 0000 3927          jsr       _PageWriteI2C
000024D2  2F9E      
000024D4  6000 0038 3928          bra       menu_60
                    3929   menu_51:
                    3930   ; }
                    3931   ; else if (c == (char)('4')){  //I2C Sequential Read
000024D8  0C02 0034 3932          cmp.b     #52,D2
000024DC  6608      3933          bne.s     menu_53
                    3934   ; SeqReadI2C();
000024DE  4EB9 0000 3935          jsr       _SeqReadI2C
000024E2  3040      
000024E4  6028      3936          bra.s     menu_60
                    3937   menu_53:
                    3938   ; }
                    3939   ; else if (c == (char)('5')){  //ADC/DAC Operation
000024E6  0C02 0035 3940          cmp.b     #53,D2
000024EA  6608      3941          bne.s     menu_55
                    3942   ; DACWrite();
000024EC  4EB9 0000 3943          jsr       _DACWrite
000024F0  39FC      
000024F2  601A      3944          bra.s     menu_60
                    3945   menu_55:
                    3946   ; }
                    3947   ; else if (c == (char)('6')){  //ADC/DAC Operation
000024F4  0C02 0036 3948          cmp.b     #54,D2
000024F8  6608      3949          bne.s     menu_57
                    3950   ; ADCWrite();
000024FA  4EB9 0000 3951          jsr       _ADCWrite
000024FE  3A9C      
00002500  600C      3952          bra.s     menu_60
                    3953   menu_57:
                    3954   ; }
                    3955   ; else if (c == (char)('7')){  //CanBusTest
00002502  0C02 0037 3956          cmp.b     #55,D2
00002506  6602      3957          bne.s     menu_59
                    3958   ; //CanBusTest();
                    3959   ; }
00002508  6004      3960          bra.s     menu_60
                    3961   menu_59:
                    3962   ; else
                    3963   ; UnknownCommand();
0000250A  4EB8 2040 3964          jsr       _UnknownCommand
                    3965   menu_60:
0000250E  6000 FD4A 3966          bra       menu_1
                    3967   menu_38:
00002512  4CDF 3C0C 3968          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00002516  4E75      3969          rts
                    3970   ; }
                    3971   ; }
                    3972   ; void PrintErrorMessageandAbort(char* string) {
                    3973   _PrintErrorMessageandAbort:
00002518  4E56 0000 3974          link      A6,#0
                    3975   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n");
0000251C  4879 0000 3976          pea       @m68kde~3_122.L
00002520  58AA      
00002522  4EB9 0000 3977          jsr       _printf
00002526  4084      
00002528  584F      3978          addq.w    #4,A7
                    3979   ; printf("%s\r\n", string);
0000252A  2F2E 0008 3980          move.l    8(A6),-(A7)
0000252E  4879 0000 3981          pea       @m68kde~3_123.L
00002532  58C6      
00002534  4EB9 0000 3982          jsr       _printf
00002538  4084      
0000253A  504F      3983          addq.w    #8,A7
                    3984   ; menu();
0000253C  4EB8 223E 3985          jsr       _menu
00002540  4E5E      3986          unlk      A6
00002542  4E75      3987          rts
                    3988   ; }
                    3989   ; void IRQMessage(int level) {
                    3990   _IRQMessage:
00002544  4E56 0000 3991          link      A6,#0
                    3992   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002548  4879 0000 3993          pea       @m68kde~3_124.L
0000254C  58CC      
0000254E  4EB9 0000 3994          jsr       _printf
00002552  4084      
00002554  584F      3995          addq.w    #4,A7
                    3996   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level);
00002556  2F2E 0008 3997          move.l    8(A6),-(A7)
0000255A  4879 0000 3998          pea       @m68kde~3_125.L
0000255E  58E4      
00002560  4EB9 0000 3999          jsr       _printf
00002564  4084      
00002566  504F      4000          addq.w    #8,A7
                    4001   ; menu();
00002568  4EB8 223E 4002          jsr       _menu
0000256C  4E5E      4003          unlk      A6
0000256E  4E75      4004          rts
                    4005   ; }
                    4006   ; void UnhandledIRQ1(void) {
                    4007   _UnhandledIRQ1:
                    4008   ; IRQMessage(1);
00002570  4878 0001 4009          pea       1
00002574  4EB8 2544 4010          jsr       _IRQMessage
00002578  584F      4011          addq.w    #4,A7
0000257A  4E75      4012          rts
                    4013   ; }
                    4014   ; void UnhandledIRQ2(void) {
                    4015   _UnhandledIRQ2:
                    4016   ; IRQMessage(2);
0000257C  4878 0002 4017          pea       2
00002580  4EB8 2544 4018          jsr       _IRQMessage
00002584  584F      4019          addq.w    #4,A7
00002586  4E75      4020          rts
                    4021   ; }
                    4022   ; void UnhandledIRQ3(void) {
                    4023   _UnhandledIRQ3:
                    4024   ; IRQMessage(3);
00002588  4878 0003 4025          pea       3
0000258C  4EB8 2544 4026          jsr       _IRQMessage
00002590  584F      4027          addq.w    #4,A7
00002592  4E75      4028          rts
                    4029   ; }
                    4030   ; void UnhandledIRQ4(void) {
                    4031   _UnhandledIRQ4:
                    4032   ; IRQMessage(4);
00002594  4878 0004 4033          pea       4
00002598  4EB8 2544 4034          jsr       _IRQMessage
0000259C  584F      4035          addq.w    #4,A7
0000259E  4E75      4036          rts
                    4037   ; }
                    4038   ; void UnhandledIRQ5(void) {
                    4039   _UnhandledIRQ5:
                    4040   ; IRQMessage(5);
000025A0  4878 0005 4041          pea       5
000025A4  4EB8 2544 4042          jsr       _IRQMessage
000025A8  584F      4043          addq.w    #4,A7
000025AA  4E75      4044          rts
                    4045   ; }
                    4046   ; void UnhandledIRQ6(void) {
                    4047   _UnhandledIRQ6:
                    4048   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....");
000025AC  4879 0000 4049          pea       @m68kde~3_126.L
000025B0  5908      
000025B2  4EB8 2518 4050          jsr       _PrintErrorMessageandAbort
000025B6  584F      4051          addq.w    #4,A7
                    4052   ; menu();
000025B8  4EB8 223E 4053          jsr       _menu
000025BC  4E75      4054          rts
                    4055   ; }
                    4056   ; void UnhandledIRQ7(void) {
                    4057   _UnhandledIRQ7:
                    4058   ; IRQMessage(7);
000025BE  4878 0007 4059          pea       7
000025C2  4EB8 2544 4060          jsr       _IRQMessage
000025C6  584F      4061          addq.w    #4,A7
000025C8  4E75      4062          rts
                    4063   ; }
                    4064   ; void UnhandledTrap(void) {
                    4065   _UnhandledTrap:
                    4066   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!");
000025CA  4879 0000 4067          pea       @m68kde~3_127.L
000025CE  5948      
000025D0  4EB8 2518 4068          jsr       _PrintErrorMessageandAbort
000025D4  584F      4069          addq.w    #4,A7
000025D6  4E75      4070          rts
                    4071   ; }
                    4072   ; void BusError() {
                    4073   _BusError:
                    4074   ; PrintErrorMessageandAbort("BUS Error!");
000025D8  4879 0000 4075          pea       @m68kde~3_128.L
000025DC  595E      
000025DE  4EB8 2518 4076          jsr       _PrintErrorMessageandAbort
000025E2  584F      4077          addq.w    #4,A7
000025E4  4E75      4078          rts
                    4079   ; }
                    4080   ; void AddressError() {
                    4081   _AddressError:
                    4082   ; PrintErrorMessageandAbort("ADDRESS Error!");
000025E6  4879 0000 4083          pea       @m68kde~3_129.L
000025EA  596A      
000025EC  4EB8 2518 4084          jsr       _PrintErrorMessageandAbort
000025F0  584F      4085          addq.w    #4,A7
000025F2  4E75      4086          rts
                    4087   ; }
                    4088   ; void IllegalInstruction() {
                    4089   _IllegalInstruction:
                    4090   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION");
000025F4  4879 0000 4091          pea       @m68kde~3_130.L
000025F8  597A      
000025FA  4EB8 2518 4092          jsr       _PrintErrorMessageandAbort
000025FE  584F      4093          addq.w    #4,A7
00002600  4E75      4094          rts
                    4095   ; }
                    4096   ; void Dividebyzero() {
                    4097   _Dividebyzero:
                    4098   ; PrintErrorMessageandAbort("DIVIDE BY ZERO");
00002602  4879 0000 4099          pea       @m68kde~3_131.L
00002606  598E      
00002608  4EB8 2518 4100          jsr       _PrintErrorMessageandAbort
0000260C  584F      4101          addq.w    #4,A7
0000260E  4E75      4102          rts
                    4103   ; }
                    4104   ; void Check() {
                    4105   _Check:
                    4106   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION");
00002610  4879 0000 4107          pea       @m68kde~3_132.L
00002614  599E      
00002616  4EB8 2518 4108          jsr       _PrintErrorMessageandAbort
0000261A  584F      4109          addq.w    #4,A7
0000261C  4E75      4110          rts
                    4111   ; }
                    4112   ; void Trapv() {
                    4113   _Trapv:
                    4114   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION");
0000261E  4879 0000 4115          pea       @m68kde~3_133.L
00002622  59B0      
00002624  4EB8 2518 4116          jsr       _PrintErrorMessageandAbort
00002628  584F      4117          addq.w    #4,A7
0000262A  4E75      4118          rts
                    4119   ; }
                    4120   ; void PrivError() {
                    4121   _PrivError:
                    4122   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION");
0000262C  4879 0000 4123          pea       @m68kde~3_134.L
00002630  59C2      
00002632  4EB8 2518 4124          jsr       _PrintErrorMessageandAbort
00002636  584F      4125          addq.w    #4,A7
00002638  4E75      4126          rts
                    4127   ; }
                    4128   ; void UnitIRQ() {
                    4129   _UnitIRQ:
                    4130   ; PrintErrorMessageandAbort("UNINITIALISED IRQ");
0000263A  4879 0000 4131          pea       @m68kde~3_135.L
0000263E  59D6      
00002640  4EB8 2518 4132          jsr       _PrintErrorMessageandAbort
00002644  584F      4133          addq.w    #4,A7
00002646  4E75      4134          rts
                    4135   ; }
                    4136   ; void Spurious() {
                    4137   _Spurious:
                    4138   ; PrintErrorMessageandAbort("SPURIOUS IRQ");
00002648  4879 0000 4139          pea       @m68kde~3_136.L
0000264C  59E8      
0000264E  4EB8 2518 4140          jsr       _PrintErrorMessageandAbort
00002652  584F      4141          addq.w    #4,A7
00002654  4E75      4142          rts
                    4143   ; }
                    4144   ; void EnterString(void)
                    4145   ; {
                    4146   _EnterString:
00002656  4E56 FFFC 4147          link      A6,#-4
0000265A  2F02      4148          move.l    D2,-(A7)
                    4149   ; unsigned char* Start;
                    4150   ; unsigned char c;
                    4151   ; printf("\r\nStart Address in Memory: ");
0000265C  4879 0000 4152          pea       @m68kde~3_137.L
00002660  59F6      
00002662  4EB9 0000 4153          jsr       _printf
00002666  4084      
00002668  584F      4154          addq.w    #4,A7
                    4155   ; Start = Get8HexDigits(0);
0000266A  42A7      4156          clr.l     -(A7)
0000266C  4EB8 0CA4 4157          jsr       _Get8HexDigits
00002670  584F      4158          addq.w    #4,A7
00002672  2400      4159          move.l    D0,D2
                    4160   ; printf("\r\nEnter String (ESC to end) :");
00002674  4879 0000 4161          pea       @m68kde~3_138.L
00002678  5A12      
0000267A  4EB9 0000 4162          jsr       _printf
0000267E  4084      
00002680  584F      4163          addq.w    #4,A7
                    4164   ; while ((c = getchar()) != 0x1b)
                    4165   EnterString_1:
00002682  4EB9 0000 4166          jsr       _getch
00002686  3FA6      
00002688  1D40 FFFF 4167          move.b    D0,-1(A6)
0000268C  0C00 001B 4168          cmp.b     #27,D0
00002690  670A      4169          beq.s     EnterString_3
                    4170   ; *Start++ = c;
00002692  2042      4171          move.l    D2,A0
00002694  5282      4172          addq.l    #1,D2
00002696  10AE FFFF 4173          move.b    -1(A6),(A0)
0000269A  60E6      4174          bra       EnterString_1
                    4175   EnterString_3:
                    4176   ; *Start = 0x00;  // terminate with a null
0000269C  2042      4177          move.l    D2,A0
0000269E  4210      4178          clr.b     (A0)
000026A0  241F      4179          move.l    (A7)+,D2
000026A2  4E5E      4180          unlk      A6
000026A4  4E75      4181          rts
                    4182   ; }
                    4183   ; void MemoryTest(void)
                    4184   ; {
                    4185   _MemoryTest:
000026A6  4E56 FFBC 4186          link      A6,#-68
000026AA  48E7 3F3C 4187          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000026AE  45F9 0000 4188          lea       _printf.L,A2
000026B2  4084      
000026B4  47F8 0CA4 4189          lea       _Get8HexDigits.L,A3
                    4190   ; char data_type_num;
                    4191   ; unsigned int test_data_num;
                    4192   ; unsigned char* StartPtrByte, * EndPtrByte, * TempPtrByte;
                    4193   ; unsigned short int* StartPtrWord, * EndPtrWord, * TempPtrWord;
                    4194   ; unsigned int* StartPtrLongWord, * EndPtrLongWord, * TempPtrLongWord;
                    4195   ; int StartPtrLongWordTruc, EndPtrLongWordTruc;
                    4196   ; unsigned char test_data_byte_list[] = { 0xAA, 0xAB, 0xCC, 0xCD };
000026B8  41EE FFD8 4197          lea       -40(A6),A0
000026BC  43F9 0000 4198          lea       MemoryTest_test_data_byte_list.L,A1
000026C0  6746      
000026C2  20D9      4199          move.l    (A1)+,(A0)+
                    4200   ; unsigned char test_data_byte;
                    4201   ; unsigned char read_data_byte;
                    4202   ; unsigned  int test_data_word_list[] = { 0xAAAA, 0xBABA, 0xCCDD, 0xDDDD };
000026C4  41EE FFDE 4203          lea       -34(A6),A0
000026C8  43F9 0000 4204          lea       MemoryTest_test_data_word_list.L,A1
000026CC  6600      
000026CE  7003      4205          moveq     #3,D0
000026D0  20D9      4206          move.l    (A1)+,(A0)+
000026D2  51C8 FFFC 4207          dbra      D0,*-2
                    4208   ; unsigned  int test_data_word;
                    4209   ; unsigned int test_data_long_word_list[] = { 0xAAAAAAAA, 0xABABABAB, 0xCCCCDDDD, 0xAABBCCDD };
000026D6  41EE FFEE 4210          lea       -18(A6),A0
000026DA  43F9 0000 4211          lea       MemoryTest_test_data_long_word_list.L,A1
000026DE  674A      
000026E0  7003      4212          moveq     #3,D0
000026E2  20D9      4213          move.l    (A1)+,(A0)+
000026E4  51C8 FFFC 4214          dbra      D0,*-2
                    4215   ; unsigned int test_data_long_word;
                    4216   ; unsigned short truncated_data;
                    4217   ; printf("\r\nEnter the value below for the size of the test you would like to use?\n1 = bytes (8 bits)\n2 = words (16 bits)\n3 = long words (32 bits)\n");
000026E8  4879 0000 4218          pea       @m68kde~3_139.L
000026EC  5A30      
000026EE  4E92      4219          jsr       (A2)
000026F0  584F      4220          addq.w    #4,A7
                    4221   ; data_type_num = _getch();
000026F2  4EB8 0B68 4222          jsr       __getch
000026F6  1D40 FFBF 4223          move.b    D0,-65(A6)
                    4224   ; switch (data_type_num) {
000026FA  102E FFBF 4225          move.b    -65(A6),D0
000026FE  4880      4226          ext.w     D0
00002700  48C0      4227          ext.l     D0
00002702  0C80 0000 4228          cmp.l     #50,D0
00002706  0032      
00002708  6700 0218 4229          beq       MemoryTest_4
0000270C  6E0C      4230          bgt.s     MemoryTest_7
0000270E  0C80 0000 4231          cmp.l     #49,D0
00002712  0031      
00002714  6712      4232          beq.s     MemoryTest_3
00002716  6000 06BE 4233          bra       MemoryTest_1
                    4234   MemoryTest_7:
0000271A  0C80 0000 4235          cmp.l     #51,D0
0000271E  0033      
00002720  6700 0422 4236          beq       MemoryTest_5
00002724  6000 06B0 4237          bra       MemoryTest_1
                    4238   MemoryTest_3:
                    4239   ; case (char)('1') :
                    4240   ; printf("\nYou have selcted to use bytes size data to test your memory\n");
00002728  4879 0000 4241          pea       @m68kde~3_140.L
0000272C  5ABA      
0000272E  4E92      4242          jsr       (A2)
00002730  584F      4243          addq.w    #4,A7
                    4244   ; printf("Out of the below example test data, please select one by entering the value associated to each example:\n");
00002732  4879 0000 4245          pea       @m68kde~3_141.L
00002736  5AF8      
00002738  4E92      4246          jsr       (A2)
0000273A  584F      4247          addq.w    #4,A7
                    4248   ; printf("1 = \"AA\"\n2 = \"AB\"\n3 = \"CC\"\n4 = \"CD\"\n");
0000273C  4879 0000 4249          pea       @m68kde~3_142.L
00002740  5B62      
00002742  4E92      4250          jsr       (A2)
00002744  584F      4251          addq.w    #4,A7
                    4252   ; do {
                    4253   MemoryTest_8:
                    4254   ; test_data_num = (int)(_getch());
00002746  4EB8 0B68 4255          jsr       __getch
0000274A  2400      4256          move.l    D0,D2
                    4257   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
0000274C  0C82 0000 4258          cmp.l     #49,D2
00002750  0031      
00002752  6722      4259          beq.s     MemoryTest_10
00002754  0C82 0000 4260          cmp.l     #50,D2
00002758  0032      
0000275A  671A      4261          beq.s     MemoryTest_10
0000275C  0C82 0000 4262          cmp.l     #51,D2
00002760  0033      
00002762  6712      4263          beq.s     MemoryTest_10
00002764  0C82 0000 4264          cmp.l     #52,D2
00002768  0034      
0000276A  670A      4265          beq.s     MemoryTest_10
                    4266   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
0000276C  4879 0000 4267          pea       @m68kde~3_143.L
00002770  5B88      
00002772  4E92      4268          jsr       (A2)
00002774  584F      4269          addq.w    #4,A7
                    4270   MemoryTest_10:
00002776  0C82 0000 4271          cmp.l     #49,D2
0000277A  0031      
0000277C  6718      4272          beq.s     MemoryTest_12
0000277E  0C82 0000 4273          cmp.l     #50,D2
00002782  0032      
00002784  6710      4274          beq.s     MemoryTest_12
00002786  0C82 0000 4275          cmp.l     #51,D2
0000278A  0033      
0000278C  6708      4276          beq.s     MemoryTest_12
0000278E  0C82 0000 4277          cmp.l     #52,D2
00002792  0034      
00002794  66B0      4278          bne       MemoryTest_8
                    4279   MemoryTest_12:
                    4280   ; }
                    4281   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    4282   ; if (test_data_num == (int)('1')) {
00002796  0C82 0000 4283          cmp.l     #49,D2
0000279A  0031      
0000279C  660A      4284          bne.s     MemoryTest_13
                    4285   ; test_data_byte = test_data_byte_list[0];
0000279E  1D6E FFD8 4286          move.b    -40+0(A6),-36(A6)
000027A2  FFDC      
000027A4  6000 0040 4287          bra       MemoryTest_20
                    4288   MemoryTest_13:
                    4289   ; }
                    4290   ; else if (test_data_num == (int)('2')) {
000027A8  0C82 0000 4291          cmp.l     #50,D2
000027AC  0032      
000027AE  6608      4292          bne.s     MemoryTest_15
                    4293   ; test_data_byte = test_data_byte_list[1];
000027B0  1D6E FFD9 4294          move.b    -40+1(A6),-36(A6)
000027B4  FFDC      
000027B6  602E      4295          bra.s     MemoryTest_20
                    4296   MemoryTest_15:
                    4297   ; }
                    4298   ; else if (test_data_num == (int)('3')) {
000027B8  0C82 0000 4299          cmp.l     #51,D2
000027BC  0033      
000027BE  6608      4300          bne.s     MemoryTest_17
                    4301   ; test_data_byte = test_data_byte_list[2];
000027C0  1D6E FFDA 4302          move.b    -40+2(A6),-36(A6)
000027C4  FFDC      
000027C6  601E      4303          bra.s     MemoryTest_20
                    4304   MemoryTest_17:
                    4305   ; }
                    4306   ; else if (test_data_num == (int)('4')) {
000027C8  0C82 0000 4307          cmp.l     #52,D2
000027CC  0034      
000027CE  6608      4308          bne.s     MemoryTest_19
                    4309   ; test_data_byte = test_data_byte_list[3];
000027D0  1D6E FFDB 4310          move.b    -40+3(A6),-36(A6)
000027D4  FFDC      
000027D6  600E      4311          bra.s     MemoryTest_20
                    4312   MemoryTest_19:
                    4313   ; }
                    4314   ; else {
                    4315   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
000027D8  4879 0000 4316          pea       @m68kde~3_144.L
000027DC  5BF6      
000027DE  4E92      4317          jsr       (A2)
000027E0  584F      4318          addq.w    #4,A7
                    4319   ; return;
000027E2  6000 05FC 4320          bra       MemoryTest_2
                    4321   MemoryTest_20:
                    4322   ; }
                    4323   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory\r\n");
000027E6  4879 0000 4324          pea       @m68kde~3_145.L
000027EA  5C34      
000027EC  4E92      4325          jsr       (A2)
000027EE  584F      4326          addq.w    #4,A7
                    4327   ; do{
                    4328   MemoryTest_22:
                    4329   ; StartPtrByte = (int)Get8HexDigits(0);
000027F0  42A7      4330          clr.l     -(A7)
000027F2  4E93      4331          jsr       (A3)
000027F4  584F      4332          addq.w    #4,A7
000027F6  2A00      4333          move.l    D0,D5
                    4334   ; if(StartPtrByte < (int)(0x09000000) || StartPtrByte > (int)(0x09800000)){
000027F8  0C85 0900 4335          cmp.l     #150994944,D5
000027FC  0000      
000027FE  6508      4336          blo.s     MemoryTest_26
00002800  0C85 0980 4337          cmp.l     #159383552,D5
00002804  0000      
00002806  630A      4338          bls.s     MemoryTest_24
                    4339   MemoryTest_26:
                    4340   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x08020000 - 0x097FFFFF\r\n");
00002808  4879 0000 4341          pea       @m68kde~3_146.L
0000280C  5C8C      
0000280E  4E92      4342          jsr       (A2)
00002810  584F      4343          addq.w    #4,A7
                    4344   MemoryTest_24:
00002812  0C85 0900 4345          cmp.l     #150994944,D5
00002816  0000      
00002818  65D6      4346          blo       MemoryTest_22
0000281A  0C85 0980 4347          cmp.l     #159383552,D5
0000281E  0000      
00002820  62CE      4348          bhi       MemoryTest_22
                    4349   ; }
                    4350   ; } while(StartPtrByte < (int)(0x09000000) || StartPtrByte > (int)(0x09800000));
                    4351   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory\r\n");
00002822  4879 0000 4352          pea       @m68kde~3_147.L
00002826  5D12      
00002828  4E92      4353          jsr       (A2)
0000282A  584F      4354          addq.w    #4,A7
                    4355   ; do{
                    4356   MemoryTest_27:
                    4357   ; EndPtrByte = (int)Get8HexDigits(0);
0000282C  42A7      4358          clr.l     -(A7)
0000282E  4E93      4359          jsr       (A3)
00002830  584F      4360          addq.w    #4,A7
00002832  2D40 FFC0 4361          move.l    D0,-64(A6)
                    4362   ; if(EndPtrByte < (int)(0x09000000) || EndPtrByte > (int)(0x09800000)){
00002836  202E FFC0 4363          move.l    -64(A6),D0
0000283A  0C80 0900 4364          cmp.l     #150994944,D0
0000283E  0000      
00002840  650C      4365          blo.s     MemoryTest_31
00002842  202E FFC0 4366          move.l    -64(A6),D0
00002846  0C80 0980 4367          cmp.l     #159383552,D0
0000284A  0000      
0000284C  630A      4368          bls.s     MemoryTest_29
                    4369   MemoryTest_31:
                    4370   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x08020000 - 0x097FFFFF\r\n");
0000284E  4879 0000 4371          pea       @m68kde~3_148.L
00002852  5D66      
00002854  4E92      4372          jsr       (A2)
00002856  584F      4373          addq.w    #4,A7
                    4374   MemoryTest_29:
00002858  202E FFC0 4375          move.l    -64(A6),D0
0000285C  0C80 0900 4376          cmp.l     #150994944,D0
00002860  0000      
00002862  65C8      4377          blo       MemoryTest_27
00002864  202E FFC0 4378          move.l    -64(A6),D0
00002868  0C80 0980 4379          cmp.l     #159383552,D0
0000286C  0000      
0000286E  62BC      4380          bhi       MemoryTest_27
                    4381   ; }
                    4382   ; } while(EndPtrByte < (int)(0x09000000) || EndPtrByte > (int)(0x09800000));
                    4383   ; printf("\r\n\r\nWriting to memory");
00002870  4879 0000 4384          pea       @m68kde~3_149.L
00002874  5DE6      
00002876  4E92      4385          jsr       (A2)
00002878  584F      4386          addq.w    #4,A7
                    4387   ; TempPtrByte = StartPtrByte;
0000287A  2D45 FFC4 4388          move.l    D5,-60(A6)
                    4389   ; while (StartPtrByte < EndPtrByte) {
                    4390   MemoryTest_32:
0000287E  BAAE FFC0 4391          cmp.l     -64(A6),D5
00002882  6424      4392          bhs.s     MemoryTest_34
                    4393   ; *StartPtrByte = test_data_byte;
00002884  2045      4394          move.l    D5,A0
00002886  10AE FFDC 4395          move.b    -36(A6),(A0)
                    4396   ; printf("\r\nWRITE: [%02X to %08x]", test_data_byte, StartPtrByte);
0000288A  2F05      4397          move.l    D5,-(A7)
0000288C  122E FFDC 4398          move.b    -36(A6),D1
00002890  C2BC 0000 4399          and.l     #255,D1
00002894  00FF      
00002896  2F01      4400          move.l    D1,-(A7)
00002898  4879 0000 4401          pea       @m68kde~3_150.L
0000289C  5DFC      
0000289E  4E92      4402          jsr       (A2)
000028A0  DEFC 000C 4403          add.w     #12,A7
                    4404   ; StartPtrByte++;
000028A4  5285      4405          addq.l    #1,D5
000028A6  60D6      4406          bra       MemoryTest_32
                    4407   MemoryTest_34:
                    4408   ; }
                    4409   ; printf("\r\n\r\nStarting memory validation test");
000028A8  4879 0000 4410          pea       @m68kde~3_151.L
000028AC  5E14      
000028AE  4E92      4411          jsr       (A2)
000028B0  584F      4412          addq.w    #4,A7
                    4413   ; StartPtrByte = TempPtrByte;
000028B2  2A2E FFC4 4414          move.l    -60(A6),D5
                    4415   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrByte, EndPtrByte, test_data_byte);
000028B6  122E FFDC 4416          move.b    -36(A6),D1
000028BA  C2BC 0000 4417          and.l     #255,D1
000028BE  00FF      
000028C0  2F01      4418          move.l    D1,-(A7)
000028C2  2F2E FFC0 4419          move.l    -64(A6),-(A7)
000028C6  2F05      4420          move.l    D5,-(A7)
000028C8  4879 0000 4421          pea       @m68kde~3_152.L
000028CC  5E38      
000028CE  4E92      4422          jsr       (A2)
000028D0  DEFC 0010 4423          add.w     #16,A7
                    4424   ; while (StartPtrByte < EndPtrByte) {
                    4425   MemoryTest_35:
000028D4  BAAE FFC0 4426          cmp.l     -64(A6),D5
000028D8  6400 003A 4427          bhs       MemoryTest_37
                    4428   ; if (*StartPtrByte != test_data_byte) {
000028DC  2045      4429          move.l    D5,A0
000028DE  1010      4430          move.b    (A0),D0
000028E0  B02E FFDC 4431          cmp.b     -36(A6),D0
000028E4  672A      4432          beq.s     MemoryTest_38
                    4433   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %02X Expected Data: %02X] Exiting memory test...\r\n", StartPtrByte, *StartPtrByte, test_data_byte);
000028E6  122E FFDC 4434          move.b    -36(A6),D1
000028EA  C2BC 0000 4435          and.l     #255,D1
000028EE  00FF      
000028F0  2F01      4436          move.l    D1,-(A7)
000028F2  2045      4437          move.l    D5,A0
000028F4  1210      4438          move.b    (A0),D1
000028F6  C2BC 0000 4439          and.l     #255,D1
000028FA  00FF      
000028FC  2F01      4440          move.l    D1,-(A7)
000028FE  2F05      4441          move.l    D5,-(A7)
00002900  4879 0000 4442          pea       @m68kde~3_153.L
00002904  5E80      
00002906  4E92      4443          jsr       (A2)
00002908  DEFC 0010 4444          add.w     #16,A7
                    4445   ; return;
0000290C  6000 04D2 4446          bra       MemoryTest_2
                    4447   MemoryTest_38:
                    4448   ; }
                    4449   ; StartPtrByte++;
00002910  5285      4450          addq.l    #1,D5
00002912  60C0      4451          bra       MemoryTest_35
                    4452   MemoryTest_37:
                    4453   ; }
                    4454   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
00002914  4879 0000 4455          pea       @m68kde~3_154.L
00002918  5F0E      
0000291A  4E92      4456          jsr       (A2)
0000291C  584F      4457          addq.w    #4,A7
                    4458   ; break;
0000291E  6000 04C0 4459          bra       MemoryTest_2
                    4460   MemoryTest_4:
                    4461   ; case (char)('2') :
                    4462   ; printf("\r\nYou have selcted to use word size data to test your memory");
00002922  4879 0000 4463          pea       @m68kde~3_155.L
00002926  5F3C      
00002928  4E92      4464          jsr       (A2)
0000292A  584F      4465          addq.w    #4,A7
                    4466   ; printf("\r\nOut of the below example test data, please select one by entering the value associated to each example:");
0000292C  4879 0000 4467          pea       @m68kde~3_156.L
00002930  5F7A      
00002932  4E92      4468          jsr       (A2)
00002934  584F      4469          addq.w    #4,A7
                    4470   ; printf("\r\n1 = \"AAAA\"\n2 = \"BABA\"\n3 = \"CCDD\"\n4 = \"DDDD\"\r\n");
00002936  4879 0000 4471          pea       @m68kde~3_157.L
0000293A  5FE4      
0000293C  4E92      4472          jsr       (A2)
0000293E  584F      4473          addq.w    #4,A7
                    4474   ; do {
                    4475   MemoryTest_40:
                    4476   ; test_data_num = (int)(_getch());
00002940  4EB8 0B68 4477          jsr       __getch
00002944  2400      4478          move.l    D0,D2
                    4479   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
00002946  0C82 0000 4480          cmp.l     #49,D2
0000294A  0031      
0000294C  6722      4481          beq.s     MemoryTest_42
0000294E  0C82 0000 4482          cmp.l     #50,D2
00002952  0032      
00002954  671A      4483          beq.s     MemoryTest_42
00002956  0C82 0000 4484          cmp.l     #51,D2
0000295A  0033      
0000295C  6712      4485          beq.s     MemoryTest_42
0000295E  0C82 0000 4486          cmp.l     #52,D2
00002962  0034      
00002964  670A      4487          beq.s     MemoryTest_42
                    4488   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
00002966  4879 0000 4489          pea       @m68kde~3_143.L
0000296A  5B88      
0000296C  4E92      4490          jsr       (A2)
0000296E  584F      4491          addq.w    #4,A7
                    4492   MemoryTest_42:
00002970  0C82 0000 4493          cmp.l     #49,D2
00002974  0031      
00002976  6718      4494          beq.s     MemoryTest_44
00002978  0C82 0000 4495          cmp.l     #50,D2
0000297C  0032      
0000297E  6710      4496          beq.s     MemoryTest_44
00002980  0C82 0000 4497          cmp.l     #51,D2
00002984  0033      
00002986  6708      4498          beq.s     MemoryTest_44
00002988  0C82 0000 4499          cmp.l     #52,D2
0000298C  0034      
0000298E  66B0      4500          bne       MemoryTest_40
                    4501   MemoryTest_44:
                    4502   ; }
                    4503   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    4504   ; if (test_data_num == (int)('1')) {
00002990  0C82 0000 4505          cmp.l     #49,D2
00002994  0031      
00002996  6608      4506          bne.s     MemoryTest_45
                    4507   ; test_data_word = test_data_word_list[0];
00002998  2A6E FFDE 4508          move.l    -34+0(A6),A5
0000299C  6000 003A 4509          bra       MemoryTest_52
                    4510   MemoryTest_45:
                    4511   ; }
                    4512   ; else if (test_data_num == (int)('2')) {
000029A0  0C82 0000 4513          cmp.l     #50,D2
000029A4  0032      
000029A6  6606      4514          bne.s     MemoryTest_47
                    4515   ; test_data_word = test_data_word_list[1];
000029A8  2A6E FFE2 4516          move.l    -34+4(A6),A5
000029AC  602A      4517          bra.s     MemoryTest_52
                    4518   MemoryTest_47:
                    4519   ; }
                    4520   ; else if (test_data_num == (int)('3')) {
000029AE  0C82 0000 4521          cmp.l     #51,D2
000029B2  0033      
000029B4  6606      4522          bne.s     MemoryTest_49
                    4523   ; test_data_word = test_data_word_list[2];
000029B6  2A6E FFE6 4524          move.l    -34+8(A6),A5
000029BA  601C      4525          bra.s     MemoryTest_52
                    4526   MemoryTest_49:
                    4527   ; }
                    4528   ; else if (test_data_num == (int)('4')) {
000029BC  0C82 0000 4529          cmp.l     #52,D2
000029C0  0034      
000029C2  6606      4530          bne.s     MemoryTest_51
                    4531   ; test_data_word = test_data_word_list[3];
000029C4  2A6E FFEA 4532          move.l    -34+12(A6),A5
000029C8  600E      4533          bra.s     MemoryTest_52
                    4534   MemoryTest_51:
                    4535   ; }
                    4536   ; else {
                    4537   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
000029CA  4879 0000 4538          pea       @m68kde~3_144.L
000029CE  5BF6      
000029D0  4E92      4539          jsr       (A2)
000029D2  584F      4540          addq.w    #4,A7
                    4541   ; return;
000029D4  6000 040A 4542          bra       MemoryTest_2
                    4543   MemoryTest_52:
                    4544   ; }
                    4545   ; do {
                    4546   MemoryTest_53:
                    4547   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory (Ensure to enter an even number)\r\n");
000029D8  4879 0000 4548          pea       @m68kde~3_158.L
000029DC  6014      
000029DE  4E92      4549          jsr       (A2)
000029E0  584F      4550          addq.w    #4,A7
                    4551   ; StartPtrWord = Get8HexDigits(0);
000029E2  42A7      4552          clr.l     -(A7)
000029E4  4E93      4553          jsr       (A3)
000029E6  584F      4554          addq.w    #4,A7
000029E8  2800      4555          move.l    D0,D4
                    4556   ; while(StartPtrWord < (int)(0x09000000) || StartPtrWord > (int)(0x09800000)){
                    4557   MemoryTest_55:
000029EA  0C84 0900 4558          cmp.l     #150994944,D4
000029EE  0000      
000029F0  6508      4559          blo.s     MemoryTest_58
000029F2  0C84 0980 4560          cmp.l     #159383552,D4
000029F6  0000      
000029F8  6314      4561          bls.s     MemoryTest_57
                    4562   MemoryTest_58:
                    4563   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
000029FA  4879 0000 4564          pea       @m68kde~3_159.L
000029FE  608C      
00002A00  4E92      4565          jsr       (A2)
00002A02  584F      4566          addq.w    #4,A7
                    4567   ; StartPtrWord = Get8HexDigits(0);
00002A04  42A7      4568          clr.l     -(A7)
00002A06  4E93      4569          jsr       (A3)
00002A08  584F      4570          addq.w    #4,A7
00002A0A  2800      4571          move.l    D0,D4
00002A0C  60DC      4572          bra       MemoryTest_55
                    4573   MemoryTest_57:
                    4574   ; }
                    4575   ; if (StartPtrWord % 2 != 0) {
00002A0E  2F04      4576          move.l    D4,-(A7)
00002A10  4878 0002 4577          pea       2
00002A14  4EB9 0000 4578          jsr       ULDIV
00002A18  3E98      
00002A1A  202F 0004 4579          move.l    4(A7),D0
00002A1E  504F      4580          addq.w    #8,A7
00002A20  4A80      4581          tst.l     D0
00002A22  670A      4582          beq.s     MemoryTest_59
                    4583   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002A24  4879 0000 4584          pea       @m68kde~3_160.L
00002A28  6112      
00002A2A  4E92      4585          jsr       (A2)
00002A2C  584F      4586          addq.w    #4,A7
                    4587   MemoryTest_59:
00002A2E  2F04      4588          move.l    D4,-(A7)
00002A30  4878 0002 4589          pea       2
00002A34  4EB9 0000 4590          jsr       ULDIV
00002A38  3E98      
00002A3A  202F 0004 4591          move.l    4(A7),D0
00002A3E  504F      4592          addq.w    #8,A7
00002A40  4A80      4593          tst.l     D0
00002A42  6694      4594          bne       MemoryTest_53
                    4595   ; }
                    4596   ; } while (StartPtrWord % 2 != 0);
                    4597   ; do {
                    4598   MemoryTest_61:
                    4599   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory (Ensure to enter an even number)\r\n");
00002A44  4879 0000 4600          pea       @m68kde~3_161.L
00002A48  6158      
00002A4A  4E92      4601          jsr       (A2)
00002A4C  584F      4602          addq.w    #4,A7
                    4603   ; EndPtrWord = Get8HexDigits(0);
00002A4E  42A7      4604          clr.l     -(A7)
00002A50  4E93      4605          jsr       (A3)
00002A52  584F      4606          addq.w    #4,A7
00002A54  2840      4607          move.l    D0,A4
                    4608   ; while(EndPtrWord < (int)(0x09000000) || EndPtrWord > (int)(0x09800000)){
                    4609   MemoryTest_63:
00002A56  200C      4610          move.l    A4,D0
00002A58  0C80 0900 4611          cmp.l     #150994944,D0
00002A5C  0000      
00002A5E  650A      4612          blo.s     MemoryTest_66
00002A60  200C      4613          move.l    A4,D0
00002A62  0C80 0980 4614          cmp.l     #159383552,D0
00002A66  0000      
00002A68  6314      4615          bls.s     MemoryTest_65
                    4616   MemoryTest_66:
                    4617   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002A6A  4879 0000 4618          pea       @m68kde~3_162.L
00002A6E  61CC      
00002A70  4E92      4619          jsr       (A2)
00002A72  584F      4620          addq.w    #4,A7
                    4621   ; EndPtrWord = Get8HexDigits(0);
00002A74  42A7      4622          clr.l     -(A7)
00002A76  4E93      4623          jsr       (A3)
00002A78  584F      4624          addq.w    #4,A7
00002A7A  2840      4625          move.l    D0,A4
00002A7C  60D8      4626          bra       MemoryTest_63
                    4627   MemoryTest_65:
                    4628   ; }
                    4629   ; if (EndPtrWord % 2 != 0) {
00002A7E  2F0C      4630          move.l    A4,-(A7)
00002A80  4878 0002 4631          pea       2
00002A84  4EB9 0000 4632          jsr       ULDIV
00002A88  3E98      
00002A8A  202F 0004 4633          move.l    4(A7),D0
00002A8E  504F      4634          addq.w    #8,A7
00002A90  4A80      4635          tst.l     D0
00002A92  670A      4636          beq.s     MemoryTest_67
                    4637   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002A94  4879 0000 4638          pea       @m68kde~3_160.L
00002A98  6112      
00002A9A  4E92      4639          jsr       (A2)
00002A9C  584F      4640          addq.w    #4,A7
                    4641   MemoryTest_67:
00002A9E  2F0C      4642          move.l    A4,-(A7)
00002AA0  4878 0002 4643          pea       2
00002AA4  4EB9 0000 4644          jsr       ULDIV
00002AA8  3E98      
00002AAA  202F 0004 4645          move.l    4(A7),D0
00002AAE  504F      4646          addq.w    #8,A7
00002AB0  4A80      4647          tst.l     D0
00002AB2  6690      4648          bne       MemoryTest_61
                    4649   ; }
                    4650   ; } while (EndPtrWord % 2 != 0);
                    4651   ; printf("\r\n\r\nWriting to memory");
00002AB4  4879 0000 4652          pea       @m68kde~3_149.L
00002AB8  5DE6      
00002ABA  4E92      4653          jsr       (A2)
00002ABC  584F      4654          addq.w    #4,A7
                    4655   ; TempPtrWord = StartPtrWord;
00002ABE  2D44 FFC8 4656          move.l    D4,-56(A6)
                    4657   ; while (StartPtrWord < EndPtrWord) {
                    4658   MemoryTest_69:
00002AC2  B88C      4659          cmp.l     A4,D4
00002AC4  6418      4660          bhs.s     MemoryTest_71
                    4661   ; *StartPtrWord = test_data_word;
00002AC6  2044      4662          move.l    D4,A0
00002AC8  308D      4663          move.w    A5,(A0)
                    4664   ; printf("\r\nWRITE: [%04X to %08x]", test_data_word, StartPtrWord);
00002ACA  2F04      4665          move.l    D4,-(A7)
00002ACC  2F0D      4666          move.l    A5,-(A7)
00002ACE  4879 0000 4667          pea       @m68kde~3_163.L
00002AD2  624C      
00002AD4  4E92      4668          jsr       (A2)
00002AD6  DEFC 000C 4669          add.w     #12,A7
                    4670   ; StartPtrWord++;
00002ADA  5484      4671          addq.l    #2,D4
00002ADC  60E4      4672          bra       MemoryTest_69
                    4673   MemoryTest_71:
                    4674   ; }
                    4675   ; printf("\r\n\r\nStarting memory validation test");
00002ADE  4879 0000 4676          pea       @m68kde~3_151.L
00002AE2  5E14      
00002AE4  4E92      4677          jsr       (A2)
00002AE6  584F      4678          addq.w    #4,A7
                    4679   ; StartPtrWord = TempPtrWord;
00002AE8  282E FFC8 4680          move.l    -56(A6),D4
                    4681   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrWord, EndPtrWord, test_data_word);
00002AEC  2F0D      4682          move.l    A5,-(A7)
00002AEE  2F0C      4683          move.l    A4,-(A7)
00002AF0  2F04      4684          move.l    D4,-(A7)
00002AF2  4879 0000 4685          pea       @m68kde~3_152.L
00002AF6  5E38      
00002AF8  4E92      4686          jsr       (A2)
00002AFA  DEFC 0010 4687          add.w     #16,A7
                    4688   ; while (StartPtrWord < EndPtrWord) {
                    4689   MemoryTest_72:
00002AFE  B88C      4690          cmp.l     A4,D4
00002B00  6400 0034 4691          bhs       MemoryTest_74
                    4692   ; if (*StartPtrWord != test_data_word) {
00002B04  2044      4693          move.l    D4,A0
00002B06  3010      4694          move.w    (A0),D0
00002B08  C0BC 0000 4695          and.l     #65535,D0
00002B0C  FFFF      
00002B0E  B08D      4696          cmp.l     A5,D0
00002B10  6720      4697          beq.s     MemoryTest_75
                    4698   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %02X Expected Data: %02X] Exiting memory test...", StartPtrWord, *StartPtrWord, test_data_word);
00002B12  2F0D      4699          move.l    A5,-(A7)
00002B14  2044      4700          move.l    D4,A0
00002B16  3210      4701          move.w    (A0),D1
00002B18  C2BC 0000 4702          and.l     #65535,D1
00002B1C  FFFF      
00002B1E  2F01      4703          move.l    D1,-(A7)
00002B20  2F04      4704          move.l    D4,-(A7)
00002B22  4879 0000 4705          pea       @m68kde~3_164.L
00002B26  6264      
00002B28  4E92      4706          jsr       (A2)
00002B2A  DEFC 0010 4707          add.w     #16,A7
                    4708   ; return;
00002B2E  6000 02B0 4709          bra       MemoryTest_2
                    4710   MemoryTest_75:
                    4711   ; }
                    4712   ; StartPtrWord++;
00002B32  5484      4713          addq.l    #2,D4
00002B34  60C8      4714          bra       MemoryTest_72
                    4715   MemoryTest_74:
                    4716   ; }
                    4717   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
00002B36  4879 0000 4718          pea       @m68kde~3_154.L
00002B3A  5F0E      
00002B3C  4E92      4719          jsr       (A2)
00002B3E  584F      4720          addq.w    #4,A7
                    4721   ; break;
00002B40  6000 029E 4722          bra       MemoryTest_2
                    4723   MemoryTest_5:
                    4724   ; case (char)('3') :
                    4725   ; printf("\r\nYou have selcted to use bytes size data to test your memory");
00002B44  4879 0000 4726          pea       @m68kde~3_165.L
00002B48  62F0      
00002B4A  4E92      4727          jsr       (A2)
00002B4C  584F      4728          addq.w    #4,A7
                    4729   ; printf("\r\nOut of the below example test data, please select one by entering the value associated to each example:");
00002B4E  4879 0000 4730          pea       @m68kde~3_156.L
00002B52  5F7A      
00002B54  4E92      4731          jsr       (A2)
00002B56  584F      4732          addq.w    #4,A7
                    4733   ; printf("\r\n1 = \"AAAAAAAA\"\n2 = \"ABABABAB\"\n3 = \"CCCCDDDD\"\n4 = \"AABBCCDD\"\r\n");
00002B58  4879 0000 4734          pea       @m68kde~3_166.L
00002B5C  632E      
00002B5E  4E92      4735          jsr       (A2)
00002B60  584F      4736          addq.w    #4,A7
                    4737   ; do {
                    4738   MemoryTest_77:
                    4739   ; test_data_num = (int)(_getch());
00002B62  4EB8 0B68 4740          jsr       __getch
00002B66  2400      4741          move.l    D0,D2
                    4742   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
00002B68  0C82 0000 4743          cmp.l     #49,D2
00002B6C  0031      
00002B6E  6722      4744          beq.s     MemoryTest_79
00002B70  0C82 0000 4745          cmp.l     #50,D2
00002B74  0032      
00002B76  671A      4746          beq.s     MemoryTest_79
00002B78  0C82 0000 4747          cmp.l     #51,D2
00002B7C  0033      
00002B7E  6712      4748          beq.s     MemoryTest_79
00002B80  0C82 0000 4749          cmp.l     #52,D2
00002B84  0034      
00002B86  670A      4750          beq.s     MemoryTest_79
                    4751   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
00002B88  4879 0000 4752          pea       @m68kde~3_143.L
00002B8C  5B88      
00002B8E  4E92      4753          jsr       (A2)
00002B90  584F      4754          addq.w    #4,A7
                    4755   MemoryTest_79:
00002B92  0C82 0000 4756          cmp.l     #49,D2
00002B96  0031      
00002B98  6718      4757          beq.s     MemoryTest_81
00002B9A  0C82 0000 4758          cmp.l     #50,D2
00002B9E  0032      
00002BA0  6710      4759          beq.s     MemoryTest_81
00002BA2  0C82 0000 4760          cmp.l     #51,D2
00002BA6  0033      
00002BA8  6708      4761          beq.s     MemoryTest_81
00002BAA  0C82 0000 4762          cmp.l     #52,D2
00002BAE  0034      
00002BB0  66B0      4763          bne       MemoryTest_77
                    4764   MemoryTest_81:
                    4765   ; }
                    4766   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    4767   ; if (test_data_num == (int)('1')) {
00002BB2  0C82 0000 4768          cmp.l     #49,D2
00002BB6  0031      
00002BB8  6608      4769          bne.s     MemoryTest_82
                    4770   ; test_data_long_word = test_data_long_word_list[0];
00002BBA  2C2E FFEE 4771          move.l    -18+0(A6),D6
00002BBE  6000 003A 4772          bra       MemoryTest_89
                    4773   MemoryTest_82:
                    4774   ; }
                    4775   ; else if (test_data_num == (int)('2')) {
00002BC2  0C82 0000 4776          cmp.l     #50,D2
00002BC6  0032      
00002BC8  6606      4777          bne.s     MemoryTest_84
                    4778   ; test_data_long_word = test_data_long_word_list[1];
00002BCA  2C2E FFF2 4779          move.l    -18+4(A6),D6
00002BCE  602A      4780          bra.s     MemoryTest_89
                    4781   MemoryTest_84:
                    4782   ; }
                    4783   ; else if (test_data_num == (int)('3')) {
00002BD0  0C82 0000 4784          cmp.l     #51,D2
00002BD4  0033      
00002BD6  6606      4785          bne.s     MemoryTest_86
                    4786   ; test_data_long_word = test_data_long_word_list[2];
00002BD8  2C2E FFF6 4787          move.l    -18+8(A6),D6
00002BDC  601C      4788          bra.s     MemoryTest_89
                    4789   MemoryTest_86:
                    4790   ; }
                    4791   ; else if (test_data_num == (int)('4')) {
00002BDE  0C82 0000 4792          cmp.l     #52,D2
00002BE2  0034      
00002BE4  6606      4793          bne.s     MemoryTest_88
                    4794   ; test_data_long_word = test_data_long_word_list[3];
00002BE6  2C2E FFFA 4795          move.l    -18+12(A6),D6
00002BEA  600E      4796          bra.s     MemoryTest_89
                    4797   MemoryTest_88:
                    4798   ; }
                    4799   ; else {
                    4800   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
00002BEC  4879 0000 4801          pea       @m68kde~3_144.L
00002BF0  5BF6      
00002BF2  4E92      4802          jsr       (A2)
00002BF4  584F      4803          addq.w    #4,A7
                    4804   ; return;
00002BF6  6000 01E8 4805          bra       MemoryTest_2
                    4806   MemoryTest_89:
                    4807   ; }
                    4808   ; do {
                    4809   MemoryTest_90:
                    4810   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory (Ensure to enter an even number)\r\n");
00002BFA  4879 0000 4811          pea       @m68kde~3_158.L
00002BFE  6014      
00002C00  4E92      4812          jsr       (A2)
00002C02  584F      4813          addq.w    #4,A7
                    4814   ; StartPtrLongWord = Get8HexDigits(0);
00002C04  42A7      4815          clr.l     -(A7)
00002C06  4E93      4816          jsr       (A3)
00002C08  584F      4817          addq.w    #4,A7
00002C0A  2600      4818          move.l    D0,D3
                    4819   ; while(StartPtrLongWord < (int)(0x09000000) || StartPtrLongWord > (int)(0x09800000)){
                    4820   MemoryTest_92:
00002C0C  0C83 0900 4821          cmp.l     #150994944,D3
00002C10  0000      
00002C12  6508      4822          blo.s     MemoryTest_95
00002C14  0C83 0980 4823          cmp.l     #159383552,D3
00002C18  0000      
00002C1A  6314      4824          bls.s     MemoryTest_94
                    4825   MemoryTest_95:
                    4826   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002C1C  4879 0000 4827          pea       @m68kde~3_159.L
00002C20  608C      
00002C22  4E92      4828          jsr       (A2)
00002C24  584F      4829          addq.w    #4,A7
                    4830   ; StartPtrLongWord = Get8HexDigits(0);
00002C26  42A7      4831          clr.l     -(A7)
00002C28  4E93      4832          jsr       (A3)
00002C2A  584F      4833          addq.w    #4,A7
00002C2C  2600      4834          move.l    D0,D3
00002C2E  60DC      4835          bra       MemoryTest_92
                    4836   MemoryTest_94:
                    4837   ; }
                    4838   ; if (StartPtrLongWord % 2 != 0) {
00002C30  2F03      4839          move.l    D3,-(A7)
00002C32  4878 0002 4840          pea       2
00002C36  4EB9 0000 4841          jsr       ULDIV
00002C3A  3E98      
00002C3C  202F 0004 4842          move.l    4(A7),D0
00002C40  504F      4843          addq.w    #8,A7
00002C42  4A80      4844          tst.l     D0
00002C44  670A      4845          beq.s     MemoryTest_96
                    4846   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002C46  4879 0000 4847          pea       @m68kde~3_160.L
00002C4A  6112      
00002C4C  4E92      4848          jsr       (A2)
00002C4E  584F      4849          addq.w    #4,A7
                    4850   MemoryTest_96:
00002C50  2F03      4851          move.l    D3,-(A7)
00002C52  4878 0002 4852          pea       2
00002C56  4EB9 0000 4853          jsr       ULDIV
00002C5A  3E98      
00002C5C  202F 0004 4854          move.l    4(A7),D0
00002C60  504F      4855          addq.w    #8,A7
00002C62  4A80      4856          tst.l     D0
00002C64  6694      4857          bne       MemoryTest_90
                    4858   ; }
                    4859   ; } while (StartPtrLongWord % 2 != 0);
                    4860   ; do {
                    4861   MemoryTest_98:
                    4862   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory (Ensure to enter an even number)\r\n");
00002C66  4879 0000 4863          pea       @m68kde~3_161.L
00002C6A  6158      
00002C6C  4E92      4864          jsr       (A2)
00002C6E  584F      4865          addq.w    #4,A7
                    4866   ; EndPtrLongWord = Get8HexDigits(0);
00002C70  42A7      4867          clr.l     -(A7)
00002C72  4E93      4868          jsr       (A3)
00002C74  584F      4869          addq.w    #4,A7
00002C76  2E00      4870          move.l    D0,D7
                    4871   ; while(EndPtrLongWord < (int)(0x09000000) || EndPtrLongWord > (int)(0x09800000)){
                    4872   MemoryTest_100:
00002C78  0C87 0900 4873          cmp.l     #150994944,D7
00002C7C  0000      
00002C7E  6508      4874          blo.s     MemoryTest_103
00002C80  0C87 0980 4875          cmp.l     #159383552,D7
00002C84  0000      
00002C86  6314      4876          bls.s     MemoryTest_102
                    4877   MemoryTest_103:
                    4878   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002C88  4879 0000 4879          pea       @m68kde~3_162.L
00002C8C  61CC      
00002C8E  4E92      4880          jsr       (A2)
00002C90  584F      4881          addq.w    #4,A7
                    4882   ; EndPtrLongWord = Get8HexDigits(0);
00002C92  42A7      4883          clr.l     -(A7)
00002C94  4E93      4884          jsr       (A3)
00002C96  584F      4885          addq.w    #4,A7
00002C98  2E00      4886          move.l    D0,D7
00002C9A  60DC      4887          bra       MemoryTest_100
                    4888   MemoryTest_102:
                    4889   ; }
                    4890   ; if (EndPtrLongWord % 2 != 0) {
00002C9C  2F07      4891          move.l    D7,-(A7)
00002C9E  4878 0002 4892          pea       2
00002CA2  4EB9 0000 4893          jsr       ULDIV
00002CA6  3E98      
00002CA8  202F 0004 4894          move.l    4(A7),D0
00002CAC  504F      4895          addq.w    #8,A7
00002CAE  4A80      4896          tst.l     D0
00002CB0  670A      4897          beq.s     MemoryTest_104
                    4898   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002CB2  4879 0000 4899          pea       @m68kde~3_160.L
00002CB6  6112      
00002CB8  4E92      4900          jsr       (A2)
00002CBA  584F      4901          addq.w    #4,A7
                    4902   MemoryTest_104:
00002CBC  2F07      4903          move.l    D7,-(A7)
00002CBE  4878 0002 4904          pea       2
00002CC2  4EB9 0000 4905          jsr       ULDIV
00002CC6  3E98      
00002CC8  202F 0004 4906          move.l    4(A7),D0
00002CCC  504F      4907          addq.w    #8,A7
00002CCE  4A80      4908          tst.l     D0
00002CD0  6694      4909          bne       MemoryTest_98
                    4910   ; }
                    4911   ; } while (EndPtrLongWord % 2 != 0);
                    4912   ; printf("\r\n\r\nWriting to memory");
00002CD2  4879 0000 4913          pea       @m68kde~3_149.L
00002CD6  5DE6      
00002CD8  4E92      4914          jsr       (A2)
00002CDA  584F      4915          addq.w    #4,A7
                    4916   ; StartPtrLongWordTruc = StartPtrLongWord;
00002CDC  2D43 FFD0 4917          move.l    D3,-48(A6)
                    4918   ; EndPtrLongWordTruc = EndPtrLongWord;
00002CE0  2D47 FFD4 4919          move.l    D7,-44(A6)
                    4920   ; TempPtrLongWord = StartPtrLongWord;
00002CE4  2D43 FFCC 4921          move.l    D3,-52(A6)
                    4922   ; if((EndPtrLongWordTruc-StartPtrLongWordTruc) % 0x4 != 0){
00002CE8  202E FFD4 4923          move.l    -44(A6),D0
00002CEC  90AE FFD0 4924          sub.l     -48(A6),D0
00002CF0  2F00      4925          move.l    D0,-(A7)
00002CF2  4878 0004 4926          pea       4
00002CF6  4EB9 0000 4927          jsr       LDIV
00002CFA  3EAA      
00002CFC  202F 0004 4928          move.l    4(A7),D0
00002D00  504F      4929          addq.w    #8,A7
00002D02  4A80      4930          tst.l     D0
00002D04  670E      4931          beq.s     MemoryTest_106
                    4932   ; printf("\r\nWARNING: Memory will contain truncated data"); 
00002D06  4879 0000 4933          pea       @m68kde~3_167.L
00002D0A  636E      
00002D0C  4E92      4934          jsr       (A2)
00002D0E  584F      4935          addq.w    #4,A7
                    4936   ; truncated_data = test_data_long_word;   
00002D10  3D46 FFFE 4937          move.w    D6,-2(A6)
                    4938   MemoryTest_106:
                    4939   ; }
                    4940   ; while (StartPtrLongWord < EndPtrLongWord) {
                    4941   MemoryTest_108:
00002D14  B687      4942          cmp.l     D7,D3
00002D16  6400 0050 4943          bhs       MemoryTest_110
                    4944   ; if(EndPtrLongWordTruc - StartPtrLongWordTruc < 4){
00002D1A  202E FFD4 4945          move.l    -44(A6),D0
00002D1E  90AE FFD0 4946          sub.l     -48(A6),D0
00002D22  0C80 0000 4947          cmp.l     #4,D0
00002D26  0004      
00002D28  6C22      4948          bge.s     MemoryTest_111
                    4949   ; StartPtrWord = StartPtrLongWord;
00002D2A  2803      4950          move.l    D3,D4
                    4951   ; *StartPtrWord = test_data_long_word;
00002D2C  2044      4952          move.l    D4,A0
00002D2E  3086      4953          move.w    D6,(A0)
                    4954   ; printf("\r\nWRITE: [%08X to %08x]", *StartPtrWord, StartPtrWord);
00002D30  2F04      4955          move.l    D4,-(A7)
00002D32  2044      4956          move.l    D4,A0
00002D34  3210      4957          move.w    (A0),D1
00002D36  C2BC 0000 4958          and.l     #65535,D1
00002D3A  FFFF      
00002D3C  2F01      4959          move.l    D1,-(A7)
00002D3E  4879 0000 4960          pea       @m68kde~3_168.L
00002D42  639C      
00002D44  4E92      4961          jsr       (A2)
00002D46  DEFC 000C 4962          add.w     #12,A7
00002D4A  6014      4963          bra.s     MemoryTest_112
                    4964   MemoryTest_111:
                    4965   ; }else{
                    4966   ; *StartPtrLongWord = test_data_long_word;
00002D4C  2043      4967          move.l    D3,A0
00002D4E  2086      4968          move.l    D6,(A0)
                    4969   ; printf("\r\nWRITE: [%08X to %08x]", test_data_long_word, StartPtrLongWord);
00002D50  2F03      4970          move.l    D3,-(A7)
00002D52  2F06      4971          move.l    D6,-(A7)
00002D54  4879 0000 4972          pea       @m68kde~3_168.L
00002D58  639C      
00002D5A  4E92      4973          jsr       (A2)
00002D5C  DEFC 000C 4974          add.w     #12,A7
                    4975   MemoryTest_112:
                    4976   ; }
                    4977   ; StartPtrLongWord++;
00002D60  5883      4978          addq.l    #4,D3
                    4979   ; StartPtrLongWordTruc = StartPtrLongWord;
00002D62  2D43 FFD0 4980          move.l    D3,-48(A6)
00002D66  60AC      4981          bra       MemoryTest_108
                    4982   MemoryTest_110:
                    4983   ; }
                    4984   ; printf("\r\n\r\nStarting memory validation test");
00002D68  4879 0000 4985          pea       @m68kde~3_151.L
00002D6C  5E14      
00002D6E  4E92      4986          jsr       (A2)
00002D70  584F      4987          addq.w    #4,A7
                    4988   ; StartPtrLongWord = TempPtrLongWord;
00002D72  262E FFCC 4989          move.l    -52(A6),D3
                    4990   ; truncated_data = test_data_long_word;
00002D76  3D46 FFFE 4991          move.w    D6,-2(A6)
                    4992   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrLongWord, EndPtrLongWord, test_data_long_word);
00002D7A  2F06      4993          move.l    D6,-(A7)
00002D7C  2F07      4994          move.l    D7,-(A7)
00002D7E  2F03      4995          move.l    D3,-(A7)
00002D80  4879 0000 4996          pea       @m68kde~3_152.L
00002D84  5E38      
00002D86  4E92      4997          jsr       (A2)
00002D88  DEFC 0010 4998          add.w     #16,A7
                    4999   ; while (StartPtrLongWord < EndPtrLongWord) {
                    5000   MemoryTest_113:
00002D8C  B687      5001          cmp.l     D7,D3
00002D8E  6400 003A 5002          bhs       MemoryTest_115
                    5003   ; if(EndPtrLongWordTruc - StartPtrLongWordTruc < 4){
00002D92  202E FFD4 5004          move.l    -44(A6),D0
00002D96  90AE FFD0 5005          sub.l     -48(A6),D0
00002D9A  0C80 0000 5006          cmp.l     #4,D0
00002D9E  0004      
00002DA0  6C04      5007          bge.s     MemoryTest_116
                    5008   ; StartPtrWord = StartPtrLongWord;
00002DA2  2803      5009          move.l    D3,D4
00002DA4  601C      5010          bra.s     MemoryTest_118
                    5011   MemoryTest_116:
                    5012   ; }else{
                    5013   ; if (*StartPtrLongWord != test_data_long_word) {
00002DA6  2043      5014          move.l    D3,A0
00002DA8  BC90      5015          cmp.l     (A0),D6
00002DAA  6716      5016          beq.s     MemoryTest_118
                    5017   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %08X Expected Data: %08X] Exiting memory test...\r\n", StartPtrLongWord, *StartPtrLongWord, test_data_long_word);
00002DAC  2F06      5018          move.l    D6,-(A7)
00002DAE  2043      5019          move.l    D3,A0
00002DB0  2F10      5020          move.l    (A0),-(A7)
00002DB2  2F03      5021          move.l    D3,-(A7)
00002DB4  4879 0000 5022          pea       @m68kde~3_169.L
00002DB8  63B4      
00002DBA  4E92      5023          jsr       (A2)
00002DBC  DEFC 0010 5024          add.w     #16,A7
                    5025   ; return;
00002DC0  601E      5026          bra.s     MemoryTest_2
                    5027   MemoryTest_118:
                    5028   ; }
                    5029   ; }
                    5030   ; StartPtrLongWord++;
00002DC2  5883      5031          addq.l    #4,D3
                    5032   ; StartPtrLongWordTruc = StartPtrLongWord;
00002DC4  2D43 FFD0 5033          move.l    D3,-48(A6)
00002DC8  60C2      5034          bra       MemoryTest_113
                    5035   MemoryTest_115:
                    5036   ; }
                    5037   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
00002DCA  4879 0000 5038          pea       @m68kde~3_154.L
00002DCE  5F0E      
00002DD0  4E92      5039          jsr       (A2)
00002DD2  584F      5040          addq.w    #4,A7
                    5041   ; break;
00002DD4  600A      5042          bra.s     MemoryTest_2
                    5043   MemoryTest_1:
                    5044   ; default:
                    5045   ; printf("\r\nYou failed to select a data type to use! Click open memory test again to try again.\r\n");
00002DD6  4879 0000 5046          pea       @m68kde~3_170.L
00002DDA  6442      
00002DDC  4E92      5047          jsr       (A2)
00002DDE  584F      5048          addq.w    #4,A7
                    5049   MemoryTest_2:
00002DE0  4CDF 3CFC 5050          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002DE4  4E5E      5051          unlk      A6
00002DE6  4E75      5052          rts
                    5053   ; }   
                    5054   ; }
                    5055   ; void WriteI2C(void){
                    5056   _WriteI2C:
00002DE8  48E7 3C20 5057          movem.l   D2/D3/D4/D5/A2,-(A7)
00002DEC  45F9 0000 5058          lea       _printf.L,A2
00002DF0  4084      
                    5059   ; unsigned int Address;
                    5060   ; unsigned char AddressLSB;
                    5061   ; unsigned char AddressMSB;
                    5062   ; unsigned char c;
                    5063   ; printf("\r\nI2C Write:");
00002DF2  4879 0000 5064          pea       @m68kde~3_171.L
00002DF6  649A      
00002DF8  4E92      5065          jsr       (A2)
00002DFA  584F      5066          addq.w    #4,A7
                    5067   ; printf("\r\nEnter Address: ");
00002DFC  4879 0000 5068          pea       @m68kde~3_19.L
00002E00  4B9E      
00002E02  4E92      5069          jsr       (A2)
00002E04  584F      5070          addq.w    #4,A7
                    5071   ; Address = Get8HexDigits(0);
00002E06  42A7      5072          clr.l     -(A7)
00002E08  4EB8 0CA4 5073          jsr       _Get8HexDigits
00002E0C  584F      5074          addq.w    #4,A7
00002E0E  2400      5075          move.l    D0,D2
                    5076   ; if(Address > 131071 ){ //Chip is 128kB therefore can not be greater
00002E10  0C82 0001 5077          cmp.l     #131071,D2
00002E14  FFFF      
00002E16  630E      5078          bls.s     WriteI2C_1
                    5079   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00002E18  4879 0000 5080          pea       @m68kde~3_172.L
00002E1C  64A8      
00002E1E  4E92      5081          jsr       (A2)
00002E20  584F      5082          addq.w    #4,A7
                    5083   ; return;
00002E22  6000 00AE 5084          bra       WriteI2C_3
                    5085   WriteI2C_1:
                    5086   ; } 
                    5087   ; printf("\r\nEnter Data: ");
00002E26  4879 0000 5088          pea       @m68kde~3_173.L
00002E2A  6516      
00002E2C  4E92      5089          jsr       (A2)
00002E2E  584F      5090          addq.w    #4,A7
                    5091   ; c = Get2HexDigits(0);
00002E30  42A7      5092          clr.l     -(A7)
00002E32  4EB8 0C04 5093          jsr       _Get2HexDigits
00002E36  584F      5094          addq.w    #4,A7
00002E38  1A00      5095          move.b    D0,D5
                    5096   ; if(Address > 65535){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
00002E3A  0C82 0000 5097          cmp.l     #65535,D2
00002E3E  FFFF      
00002E40  6300 0052 5098          bls       WriteI2C_4
                    5099   ; //Adjusting address values to high block and onwards
                    5100   ; AddressMSB = ((Address - 0x10000) >> 8) & 0xFF;
00002E44  2002      5101          move.l    D2,D0
00002E46  0480 0001 5102          sub.l     #65536,D0
00002E4A  0000      
00002E4C  E088      5103          lsr.l     #8,D0
00002E4E  C0BC 0000 5104          and.l     #255,D0
00002E52  00FF      
00002E54  1800      5105          move.b    D0,D4
                    5106   ; AddressLSB = (Address - 0x10000) & 0xFF;    
00002E56  2002      5107          move.l    D2,D0
00002E58  0480 0001 5108          sub.l     #65536,D0
00002E5C  0000      
00002E5E  C0BC 0000 5109          and.l     #255,D0
00002E62  00FF      
00002E64  1600      5110          move.b    D0,D3
                    5111   ; WriteI2CInteraction(1, Address, AddressMSB, AddressLSB, c, 0);
00002E66  42A7      5112          clr.l     -(A7)
00002E68  CABC 0000 5113          and.l     #255,D5
00002E6C  00FF      
00002E6E  2F05      5114          move.l    D5,-(A7)
00002E70  C6BC 0000 5115          and.l     #255,D3
00002E74  00FF      
00002E76  2F03      5116          move.l    D3,-(A7)
00002E78  C8BC 0000 5117          and.l     #255,D4
00002E7C  00FF      
00002E7E  2F04      5118          move.l    D4,-(A7)
00002E80  2F02      5119          move.l    D2,-(A7)
00002E82  4878 0001 5120          pea       1
00002E86  4EB9 0000 5121          jsr       _WriteI2CInteraction
00002E8A  3414      
00002E8C  DEFC 0018 5122          add.w     #24,A7
00002E90  6000 0040 5123          bra       WriteI2C_5
                    5124   WriteI2C_4:
                    5125   ; }else{
                    5126   ; AddressMSB = (Address >> 8) & 0xFF;
00002E94  2002      5127          move.l    D2,D0
00002E96  E088      5128          lsr.l     #8,D0
00002E98  C0BC 0000 5129          and.l     #255,D0
00002E9C  00FF      
00002E9E  1800      5130          move.b    D0,D4
                    5131   ; AddressLSB = Address & 0xFF;
00002EA0  2002      5132          move.l    D2,D0
00002EA2  C0BC 0000 5133          and.l     #255,D0
00002EA6  00FF      
00002EA8  1600      5134          move.b    D0,D3
                    5135   ; WriteI2CInteraction(0, Address, AddressMSB, AddressLSB, c, 0);
00002EAA  42A7      5136          clr.l     -(A7)
00002EAC  CABC 0000 5137          and.l     #255,D5
00002EB0  00FF      
00002EB2  2F05      5138          move.l    D5,-(A7)
00002EB4  C6BC 0000 5139          and.l     #255,D3
00002EB8  00FF      
00002EBA  2F03      5140          move.l    D3,-(A7)
00002EBC  C8BC 0000 5141          and.l     #255,D4
00002EC0  00FF      
00002EC2  2F04      5142          move.l    D4,-(A7)
00002EC4  2F02      5143          move.l    D2,-(A7)
00002EC6  42A7      5144          clr.l     -(A7)
00002EC8  4EB9 0000 5145          jsr       _WriteI2CInteraction
00002ECC  3414      
00002ECE  DEFC 0018 5146          add.w     #24,A7
                    5147   WriteI2C_5:
                    5148   ; }
                    5149   ; return;
                    5150   WriteI2C_3:
00002ED2  4CDF 043C 5151          movem.l   (A7)+,D2/D3/D4/D5/A2
00002ED6  4E75      5152          rts
                    5153   ; }
                    5154   ; void ReadI2C(void){
                    5155   _ReadI2C:
00002ED8  48E7 3820 5156          movem.l   D2/D3/D4/A2,-(A7)
00002EDC  45F9 0000 5157          lea       _printf.L,A2
00002EE0  4084      
                    5158   ; unsigned int Address;
                    5159   ; unsigned char AddressLSB;
                    5160   ; unsigned char AddressMSB;
                    5161   ; printf("\r\nI2C Read:");
00002EE2  4879 0000 5162          pea       @m68kde~3_174.L
00002EE6  6526      
00002EE8  4E92      5163          jsr       (A2)
00002EEA  584F      5164          addq.w    #4,A7
                    5165   ; printf("\r\nEnter Address: ");
00002EEC  4879 0000 5166          pea       @m68kde~3_19.L
00002EF0  4B9E      
00002EF2  4E92      5167          jsr       (A2)
00002EF4  584F      5168          addq.w    #4,A7
                    5169   ; Address = Get8HexDigits(0);
00002EF6  42A7      5170          clr.l     -(A7)
00002EF8  4EB8 0CA4 5171          jsr       _Get8HexDigits
00002EFC  584F      5172          addq.w    #4,A7
00002EFE  2400      5173          move.l    D0,D2
                    5174   ; if(Address > 131071){ //Chip is 128kB therefore can not be greater
00002F00  0C82 0001 5175          cmp.l     #131071,D2
00002F04  FFFF      
00002F06  630E      5176          bls.s     ReadI2C_1
                    5177   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00002F08  4879 0000 5178          pea       @m68kde~3_172.L
00002F0C  64A8      
00002F0E  4E92      5179          jsr       (A2)
00002F10  584F      5180          addq.w    #4,A7
                    5181   ; return;
00002F12  6000 0084 5182          bra       ReadI2C_3
                    5183   ReadI2C_1:
                    5184   ; } 
                    5185   ; if(Address > 65535){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
00002F16  0C82 0000 5186          cmp.l     #65535,D2
00002F1A  FFFF      
00002F1C  6300 0046 5187          bls       ReadI2C_4
                    5188   ; //Adjusting address values to high block and onwards
                    5189   ; AddressMSB = ((Address - 0x10000) >> 8) & 0xFF;
00002F20  2002      5190          move.l    D2,D0
00002F22  0480 0001 5191          sub.l     #65536,D0
00002F26  0000      
00002F28  E088      5192          lsr.l     #8,D0
00002F2A  C0BC 0000 5193          and.l     #255,D0
00002F2E  00FF      
00002F30  1800      5194          move.b    D0,D4
                    5195   ; AddressLSB = (Address - 0x10000) & 0xFF;    
00002F32  2002      5196          move.l    D2,D0
00002F34  0480 0001 5197          sub.l     #65536,D0
00002F38  0000      
00002F3A  C0BC 0000 5198          and.l     #255,D0
00002F3E  00FF      
00002F40  1600      5199          move.b    D0,D3
                    5200   ; ReadI2CByteInteraction(1, Address, AddressMSB, AddressLSB);
00002F42  C6BC 0000 5201          and.l     #255,D3
00002F46  00FF      
00002F48  2F03      5202          move.l    D3,-(A7)
00002F4A  C8BC 0000 5203          and.l     #255,D4
00002F4E  00FF      
00002F50  2F04      5204          move.l    D4,-(A7)
00002F52  2F02      5205          move.l    D2,-(A7)
00002F54  4878 0001 5206          pea       1
00002F58  4EB9 0000 5207          jsr       _ReadI2CByteInteraction
00002F5C  3782      
00002F5E  DEFC 0010 5208          add.w     #16,A7
00002F62  6034      5209          bra.s     ReadI2C_5
                    5210   ReadI2C_4:
                    5211   ; }else{
                    5212   ; AddressMSB = (Address >> 8) & 0xFF;
00002F64  2002      5213          move.l    D2,D0
00002F66  E088      5214          lsr.l     #8,D0
00002F68  C0BC 0000 5215          and.l     #255,D0
00002F6C  00FF      
00002F6E  1800      5216          move.b    D0,D4
                    5217   ; AddressLSB = Address & 0xFF;
00002F70  2002      5218          move.l    D2,D0
00002F72  C0BC 0000 5219          and.l     #255,D0
00002F76  00FF      
00002F78  1600      5220          move.b    D0,D3
                    5221   ; ReadI2CByteInteraction(0, Address, AddressMSB, AddressLSB);
00002F7A  C6BC 0000 5222          and.l     #255,D3
00002F7E  00FF      
00002F80  2F03      5223          move.l    D3,-(A7)
00002F82  C8BC 0000 5224          and.l     #255,D4
00002F86  00FF      
00002F88  2F04      5225          move.l    D4,-(A7)
00002F8A  2F02      5226          move.l    D2,-(A7)
00002F8C  42A7      5227          clr.l     -(A7)
00002F8E  4EB9 0000 5228          jsr       _ReadI2CByteInteraction
00002F92  3782      
00002F94  DEFC 0010 5229          add.w     #16,A7
                    5230   ReadI2C_5:
                    5231   ; }
                    5232   ; return;
                    5233   ReadI2C_3:
00002F98  4CDF 041C 5234          movem.l   (A7)+,D2/D3/D4/A2
00002F9C  4E75      5235          rts
                    5236   ; }
                    5237   ; void PageWriteI2C(void){
                    5238   _PageWriteI2C:
00002F9E  4E56 FFFC 5239          link      A6,#-4
00002FA2  48E7 3020 5240          movem.l   D2/D3/A2,-(A7)
00002FA6  45F9 0000 5241          lea       _printf.L,A2
00002FAA  4084      
                    5242   ; unsigned int AddressFrom;
                    5243   ; unsigned int AddressTo;
                    5244   ; unsigned char c;
                    5245   ; printf("\r\nI2C Page Write:");
00002FAC  4879 0000 5246          pea       @m68kde~3_175.L
00002FB0  6532      
00002FB2  4E92      5247          jsr       (A2)
00002FB4  584F      5248          addq.w    #4,A7
                    5249   ; printf("\r\nEnter Address From: ");
00002FB6  4879 0000 5250          pea       @m68kde~3_176.L
00002FBA  6544      
00002FBC  4E92      5251          jsr       (A2)
00002FBE  584F      5252          addq.w    #4,A7
                    5253   ; AddressFrom = Get8HexDigits(0);
00002FC0  42A7      5254          clr.l     -(A7)
00002FC2  4EB8 0CA4 5255          jsr       _Get8HexDigits
00002FC6  584F      5256          addq.w    #4,A7
00002FC8  2600      5257          move.l    D0,D3
                    5258   ; if(AddressFrom > 131071 ){ //Chip is 128kB therefore can not be greater
00002FCA  0C83 0001 5259          cmp.l     #131071,D3
00002FCE  FFFF      
00002FD0  630E      5260          bls.s     PageWriteI2C_1
                    5261   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00002FD2  4879 0000 5262          pea       @m68kde~3_172.L
00002FD6  64A8      
00002FD8  4E92      5263          jsr       (A2)
00002FDA  584F      5264          addq.w    #4,A7
                    5265   ; return;
00002FDC  6000 005A 5266          bra       PageWriteI2C_3
                    5267   PageWriteI2C_1:
                    5268   ; } 
                    5269   ; printf("\r\nEnter Address To: ");
00002FE0  4879 0000 5270          pea       @m68kde~3_177.L
00002FE4  655C      
00002FE6  4E92      5271          jsr       (A2)
00002FE8  584F      5272          addq.w    #4,A7
                    5273   ; AddressTo = Get8HexDigits(0);
00002FEA  42A7      5274          clr.l     -(A7)
00002FEC  4EB8 0CA4 5275          jsr       _Get8HexDigits
00002FF0  584F      5276          addq.w    #4,A7
00002FF2  2400      5277          move.l    D0,D2
                    5278   ; if(AddressTo > 131071 ){ //Chip is 128kB therefore can not be greater
00002FF4  0C82 0001 5279          cmp.l     #131071,D2
00002FF8  FFFF      
00002FFA  630C      5280          bls.s     PageWriteI2C_4
                    5281   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00002FFC  4879 0000 5282          pea       @m68kde~3_172.L
00003000  64A8      
00003002  4E92      5283          jsr       (A2)
00003004  584F      5284          addq.w    #4,A7
                    5285   ; return;
00003006  6030      5286          bra.s     PageWriteI2C_3
                    5287   PageWriteI2C_4:
                    5288   ; } 
                    5289   ; printf("\r\nEnter Data: ");
00003008  4879 0000 5290          pea       @m68kde~3_173.L
0000300C  6516      
0000300E  4E92      5291          jsr       (A2)
00003010  584F      5292          addq.w    #4,A7
                    5293   ; c = Get2HexDigits(0);
00003012  42A7      5294          clr.l     -(A7)
00003014  4EB8 0C04 5295          jsr       _Get2HexDigits
00003018  584F      5296          addq.w    #4,A7
0000301A  1D40 FFFF 5297          move.b    D0,-1(A6)
                    5298   ; PageWriteI2CInteraction(AddressFrom, AddressTo, c);
0000301E  122E FFFF 5299          move.b    -1(A6),D1
00003022  C2BC 0000 5300          and.l     #255,D1
00003026  00FF      
00003028  2F01      5301          move.l    D1,-(A7)
0000302A  2F02      5302          move.l    D2,-(A7)
0000302C  2F03      5303          move.l    D3,-(A7)
0000302E  4EB9 0000 5304          jsr       _PageWriteI2CInteraction
00003032  34B8      
00003034  DEFC 000C 5305          add.w     #12,A7
                    5306   ; return;
                    5307   PageWriteI2C_3:
00003038  4CDF 040C 5308          movem.l   (A7)+,D2/D3/A2
0000303C  4E5E      5309          unlk      A6
0000303E  4E75      5310          rts
                    5311   ; }
                    5312   ; void SeqReadI2C(void){
                    5313   _SeqReadI2C:
00003040  48E7 3020 5314          movem.l   D2/D3/A2,-(A7)
00003044  45F9 0000 5315          lea       _printf.L,A2
00003048  4084      
                    5316   ; int AddressFrom;
                    5317   ; int AddressTo;
                    5318   ; printf("\r\nI2C Seq Read:");
0000304A  4879 0000 5319          pea       @m68kde~3_178.L
0000304E  6572      
00003050  4E92      5320          jsr       (A2)
00003052  584F      5321          addq.w    #4,A7
                    5322   ; printf("\r\nEnter Address From: ");
00003054  4879 0000 5323          pea       @m68kde~3_176.L
00003058  6544      
0000305A  4E92      5324          jsr       (A2)
0000305C  584F      5325          addq.w    #4,A7
                    5326   ; AddressFrom = Get8HexDigits(0);
0000305E  42A7      5327          clr.l     -(A7)
00003060  4EB8 0CA4 5328          jsr       _Get8HexDigits
00003064  584F      5329          addq.w    #4,A7
00003066  2400      5330          move.l    D0,D2
                    5331   ; if(AddressFrom > 131071){ //Chip is 128kB therefore can not be greater
00003068  0C82 0001 5332          cmp.l     #131071,D2
0000306C  FFFF      
0000306E  6F0E      5333          ble.s     SeqReadI2C_1
                    5334   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00003070  4879 0000 5335          pea       @m68kde~3_172.L
00003074  64A8      
00003076  4E92      5336          jsr       (A2)
00003078  584F      5337          addq.w    #4,A7
                    5338   ; return;
0000307A  6000 005A 5339          bra       SeqReadI2C_3
                    5340   SeqReadI2C_1:
                    5341   ; } 
                    5342   ; printf("\r\nEnter Address To: ");
0000307E  4879 0000 5343          pea       @m68kde~3_177.L
00003082  655C      
00003084  4E92      5344          jsr       (A2)
00003086  584F      5345          addq.w    #4,A7
                    5346   ; AddressTo = Get8HexDigits(0);
00003088  42A7      5347          clr.l     -(A7)
0000308A  4EB8 0CA4 5348          jsr       _Get8HexDigits
0000308E  584F      5349          addq.w    #4,A7
00003090  2600      5350          move.l    D0,D3
                    5351   ; if(AddressTo > 131071){ //Chip is 128kB therefore can not be greater
00003092  0C83 0001 5352          cmp.l     #131071,D3
00003096  FFFF      
00003098  6F0C      5353          ble.s     SeqReadI2C_4
                    5354   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
0000309A  4879 0000 5355          pea       @m68kde~3_172.L
0000309E  64A8      
000030A0  4E92      5356          jsr       (A2)
000030A2  584F      5357          addq.w    #4,A7
                    5358   ; return;
000030A4  6030      5359          bra.s     SeqReadI2C_3
                    5360   SeqReadI2C_4:
                    5361   ; } 
                    5362   ; if(AddressFrom > 65535){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
000030A6  0C82 0000 5363          cmp.l     #65535,D2
000030AA  FFFF      
000030AC  6F16      5364          ble.s     SeqReadI2C_6
                    5365   ; ReadI2CSequential(1, AddressTo, AddressFrom, AddressFrom);
000030AE  2F02      5366          move.l    D2,-(A7)
000030B0  2F02      5367          move.l    D2,-(A7)
000030B2  2F03      5368          move.l    D3,-(A7)
000030B4  4878 0001 5369          pea       1
000030B8  4EB9 0000 5370          jsr       _ReadI2CSequential
000030BC  3850      
000030BE  DEFC 0010 5371          add.w     #16,A7
000030C2  6012      5372          bra.s     SeqReadI2C_7
                    5373   SeqReadI2C_6:
                    5374   ; }else{
                    5375   ; ReadI2CSequential(0, AddressTo, AddressFrom, AddressFrom);
000030C4  2F02      5376          move.l    D2,-(A7)
000030C6  2F02      5377          move.l    D2,-(A7)
000030C8  2F03      5378          move.l    D3,-(A7)
000030CA  42A7      5379          clr.l     -(A7)
000030CC  4EB9 0000 5380          jsr       _ReadI2CSequential
000030D0  3850      
000030D2  DEFC 0010 5381          add.w     #16,A7
                    5382   SeqReadI2C_7:
                    5383   ; }
                    5384   ; return;
                    5385   SeqReadI2C_3:
000030D6  4CDF 040C 5386          movem.l   (A7)+,D2/D3/A2
000030DA  4E75      5387          rts
                    5388   ; }
                    5389   ; void main(void)
                    5390   ; {
                    5391   _main:
000030DC  4E56 FFF0 5392          link      A6,#-16
000030E0  48E7 3030 5393          movem.l   D2/D3/A2/A3,-(A7)
000030E4  45F8 0A30 5394          lea       _InstallExceptionHandler.L,A2
000030E8  47F9 0000 5395          lea       _printf.L,A3
000030EC  4084      
                    5396   ; char c;
                    5397   ; int i, j;
                    5398   ; char* BugMessage = "DE1-68k Bug V1.77";
000030EE  41F9 0000 5399          lea       @m68kde~3_179.L,A0
000030F2  6582      
000030F4  2608      5400          move.l    A0,D3
                    5401   ; char* CopyrightMessage = "Copyright (C) PJ Davies 2016";
000030F6  41F9 0000 5402          lea       @m68kde~3_180.L,A0
000030FA  6594      
000030FC  2D48 FFF8 5403          move.l    A0,-8(A6)
                    5404   ; char* NameAndStudentNumber = "\r\n\r\nMatthew Tong - 59264408";
00003100  41F9 0000 5405          lea       @m68kde~3_181.L,A0
00003104  65B2      
00003106  2D48 FFFC 5406          move.l    A0,-4(A6)
                    5407   ; KillAllBreakPoints();
0000310A  4EB8 1CEC 5408          jsr       _KillAllBreakPoints
                    5409   ; i = x = y = z = PortA_Count = 0;
0000310E  42B9 0B00 5410          clr.l     _PortA_Count.L
00003112  00D4      
00003114  42B9 0B00 5411          clr.l     _z.L
00003118  00D0      
0000311A  42B9 0B00 5412          clr.l     _y.L
0000311E  00CC      
00003120  42B9 0B00 5413          clr.l     _x.L
00003124  00C8      
00003126  4282      5414          clr.l     D2
                    5415   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
00003128  42B9 0B00 5416          clr.l     _GoFlag.L
0000312C  00DC      
0000312E  42B9 0B00 5417          clr.l     _Trace.L
00003132  00D8      
                    5418   ; Echo = 1;
00003134  23FC 0000 5419          move.l    #1,_Echo.L
00003138  0001 0B00 
0000313C  00E0      
                    5420   ; d0 = d1 = d2 = d3 = d4 = d5 = d6 = d7 = 0;
0000313E  42B9 0B00 5421          clr.l     _d7.L
00003142  0100      
00003144  42B9 0B00 5422          clr.l     _d6.L
00003148  00FC      
0000314A  42B9 0B00 5423          clr.l     _d5.L
0000314E  00F8      
00003150  42B9 0B00 5424          clr.l     _d4.L
00003154  00F4      
00003156  42B9 0B00 5425          clr.l     _d3.L
0000315A  00F0      
0000315C  42B9 0B00 5426          clr.l     _d2.L
00003160  00EC      
00003162  42B9 0B00 5427          clr.l     _d1.L
00003166  00E8      
00003168  42B9 0B00 5428          clr.l     _d0.L
0000316C  00E4      
                    5429   ; a0 = a1 = a2 = a3 = a4 = a5 = a6 = 0;
0000316E  42B9 0B00 5430          clr.l     _a6.L
00003172  011C      
00003174  42B9 0B00 5431          clr.l     _a5.L
00003178  0118      
0000317A  42B9 0B00 5432          clr.l     _a4.L
0000317E  0114      
00003180  42B9 0B00 5433          clr.l     _a3.L
00003184  0110      
00003186  42B9 0B00 5434          clr.l     _a2.L
0000318A  010C      
0000318C  42B9 0B00 5435          clr.l     _a1.L
00003190  0108      
00003192  42B9 0B00 5436          clr.l     _a0.L
00003196  0104      
                    5437   ; PC = ProgramStart, SSP = TopOfStack, USP = TopOfStack;
00003198  23FC 0800 5438          move.l    #134217728,_PC.L
0000319C  0000 0B00 
000031A0  0120      
000031A2  23FC 0C00 5439          move.l    #201326592,_SSP.L
000031A6  0000 0B00 
000031AA  0124      
000031AC  23FC 0C00 5440          move.l    #201326592,_USP.L
000031B0  0000 0B00 
000031B4  0128      
                    5441   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
000031B6  33FC 2000 5442          move.w    #8192,_SR.L
000031BA  0B00 012C 
                    5443   ; // Initialise Breakpoint variables
                    5444   ; for (i = 0; i < 8; i++) {
000031BE  4282      5445          clr.l     D2
                    5446   main_1:
000031C0  0C82 0000 5447          cmp.l     #8,D2
000031C4  0008      
000031C6  6C00 004C 5448          bge       main_3
                    5449   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
000031CA  2002      5450          move.l    D2,D0
000031CC  E588      5451          lsl.l     #2,D0
000031CE  41F9 0B00 5452          lea       _BreakPointAddress.L,A0
000031D2  012E      
000031D4  42B0 0800 5453          clr.l     0(A0,D0.L)
                    5454   ; WatchPointAddress[i] = 0;
000031D8  2002      5455          move.l    D2,D0
000031DA  E588      5456          lsl.l     #2,D0
000031DC  41F9 0B00 5457          lea       _WatchPointAddress.L,A0
000031E0  0182      
000031E2  42B0 0800 5458          clr.l     0(A0,D0.L)
                    5459   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
000031E6  2002      5460          move.l    D2,D0
000031E8  E388      5461          lsl.l     #1,D0
000031EA  41F9 0B00 5462          lea       _BreakPointInstruction.L,A0
000031EE  014E      
000031F0  4270 0800 5463          clr.w     0(A0,D0.L)
                    5464   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
000031F4  2002      5465          move.l    D2,D0
000031F6  E588      5466          lsl.l     #2,D0
000031F8  41F9 0B00 5467          lea       _BreakPointSetOrCleared.L,A0
000031FC  015E      
000031FE  42B0 0800 5468          clr.l     0(A0,D0.L)
                    5469   ; WatchPointSetOrCleared[i] = 0;
00003202  2002      5470          move.l    D2,D0
00003204  E588      5471          lsl.l     #2,D0
00003206  41F9 0B00 5472          lea       _WatchPointSetOrCleared.L,A0
0000320A  01A2      
0000320C  42B0 0800 5473          clr.l     0(A0,D0.L)
00003210  5282      5474          addq.l    #1,D2
00003212  60AC      5475          bra       main_1
                    5476   main_3:
                    5477   ; }
                    5478   ; Init_RS232();     // initialise the RS232 port
00003214  4EB8 0B12 5479          jsr       _Init_RS232
                    5480   ; Init_LCD();
00003218  4EB8 095E 5481          jsr       _Init_LCD
                    5482   ; for (i = 32; i < 48; i++)
0000321C  7420      5483          moveq     #32,D2
                    5484   main_4:
0000321E  0C82 0000 5485          cmp.l     #48,D2
00003222  0030      
00003224  6C0E      5486          bge.s     main_6
                    5487   ; InstallExceptionHandler(UnhandledTrap, i);		        // install Trap exception handler on vector 32-47
00003226  2F02      5488          move.l    D2,-(A7)
00003228  4878 25CA 5489          pea       _UnhandledTrap.L
0000322C  4E92      5490          jsr       (A2)
0000322E  504F      5491          addq.w    #8,A7
00003230  5282      5492          addq.l    #1,D2
00003232  60EA      5493          bra       main_4
                    5494   main_6:
                    5495   ; InstallExceptionHandler(menu, 47);		                   // TRAP #15 call debug and end program
00003234  4878 002F 5496          pea       47
00003238  4878 223E 5497          pea       _menu.L
0000323C  4E92      5498          jsr       (A2)
0000323E  504F      5499          addq.w    #8,A7
                    5500   ; InstallExceptionHandler(UnhandledIRQ1, 25);		      // install handler for interrupts
00003240  4878 0019 5501          pea       25
00003244  4878 2570 5502          pea       _UnhandledIRQ1.L
00003248  4E92      5503          jsr       (A2)
0000324A  504F      5504          addq.w    #8,A7
                    5505   ; InstallExceptionHandler(UnhandledIRQ2, 26);		      // install handler for interrupts
0000324C  4878 001A 5506          pea       26
00003250  4878 257C 5507          pea       _UnhandledIRQ2.L
00003254  4E92      5508          jsr       (A2)
00003256  504F      5509          addq.w    #8,A7
                    5510   ; InstallExceptionHandler(UnhandledIRQ3, 27);		      // install handler for interrupts
00003258  4878 001B 5511          pea       27
0000325C  4878 2588 5512          pea       _UnhandledIRQ3.L
00003260  4E92      5513          jsr       (A2)
00003262  504F      5514          addq.w    #8,A7
                    5515   ; InstallExceptionHandler(UnhandledIRQ4, 28);		      // install handler for interrupts
00003264  4878 001C 5516          pea       28
00003268  4878 2594 5517          pea       _UnhandledIRQ4.L
0000326C  4E92      5518          jsr       (A2)
0000326E  504F      5519          addq.w    #8,A7
                    5520   ; InstallExceptionHandler(UnhandledIRQ5, 29);		      // install handler for interrupts
00003270  4878 001D 5521          pea       29
00003274  4878 25A0 5522          pea       _UnhandledIRQ5.L
00003278  4E92      5523          jsr       (A2)
0000327A  504F      5524          addq.w    #8,A7
                    5525   ; InstallExceptionHandler(UnhandledIRQ6, 30);		      // install handler for interrupts
0000327C  4878 001E 5526          pea       30
00003280  4878 25AC 5527          pea       _UnhandledIRQ6.L
00003284  4E92      5528          jsr       (A2)
00003286  504F      5529          addq.w    #8,A7
                    5530   ; InstallExceptionHandler(UnhandledIRQ7, 31);		      // install handler for interrupts
00003288  4878 001F 5531          pea       31
0000328C  4878 25BE 5532          pea       _UnhandledIRQ7.L
00003290  4E92      5533          jsr       (A2)
00003292  504F      5534          addq.w    #8,A7
                    5535   ; InstallExceptionHandler(HandleBreakPoint, 46);		           // install Trap 14 Break Point exception handler on vector 46
00003294  4878 002E 5536          pea       46
00003298  4878 1F7A 5537          pea       _HandleBreakPoint.L
0000329C  4E92      5538          jsr       (A2)
0000329E  504F      5539          addq.w    #8,A7
                    5540   ; InstallExceptionHandler(DumpRegistersandPause, 29);		   // install TRACE handler for IRQ5 on vector 29
000032A0  4878 001D 5541          pea       29
000032A4  4878 165A 5542          pea       _DumpRegistersandPause.L
000032A8  4E92      5543          jsr       (A2)
000032AA  504F      5544          addq.w    #8,A7
                    5545   ; InstallExceptionHandler(BusError, 2);                          // install Bus error handler
000032AC  4878 0002 5546          pea       2
000032B0  4878 25D8 5547          pea       _BusError.L
000032B4  4E92      5548          jsr       (A2)
000032B6  504F      5549          addq.w    #8,A7
                    5550   ; InstallExceptionHandler(AddressError, 3);                      // install address error handler (doesn't work on soft core 68k implementation)
000032B8  4878 0003 5551          pea       3
000032BC  4878 25E6 5552          pea       _AddressError.L
000032C0  4E92      5553          jsr       (A2)
000032C2  504F      5554          addq.w    #8,A7
                    5555   ; InstallExceptionHandler(IllegalInstruction, 4);                // install illegal instruction exception handler
000032C4  4878 0004 5556          pea       4
000032C8  4878 25F4 5557          pea       _IllegalInstruction.L
000032CC  4E92      5558          jsr       (A2)
000032CE  504F      5559          addq.w    #8,A7
                    5560   ; InstallExceptionHandler(Dividebyzero, 5);                      // install /0 exception handler
000032D0  4878 0005 5561          pea       5
000032D4  4878 2602 5562          pea       _Dividebyzero.L
000032D8  4E92      5563          jsr       (A2)
000032DA  504F      5564          addq.w    #8,A7
                    5565   ; InstallExceptionHandler(Check, 6);                             // install check instruction exception handler
000032DC  4878 0006 5566          pea       6
000032E0  4878 2610 5567          pea       _Check.L
000032E4  4E92      5568          jsr       (A2)
000032E6  504F      5569          addq.w    #8,A7
                    5570   ; InstallExceptionHandler(Trapv, 7);                             // install trapv instruction exception handler
000032E8  4878 0007 5571          pea       7
000032EC  4878 261E 5572          pea       _Trapv.L
000032F0  4E92      5573          jsr       (A2)
000032F2  504F      5574          addq.w    #8,A7
                    5575   ; InstallExceptionHandler(PrivError, 8);                         // install Priv Violation exception handler
000032F4  4878 0008 5576          pea       8
000032F8  4878 262C 5577          pea       _PrivError.L
000032FC  4E92      5578          jsr       (A2)
000032FE  504F      5579          addq.w    #8,A7
                    5580   ; InstallExceptionHandler(UnitIRQ, 15);                          // install uninitialised IRQ exception handler
00003300  4878 000F 5581          pea       15
00003304  4878 263A 5582          pea       _UnitIRQ.L
00003308  4E92      5583          jsr       (A2)
0000330A  504F      5584          addq.w    #8,A7
                    5585   ; InstallExceptionHandler(Check, 24);                            // install spurious IRQ exception handler
0000330C  4878 0018 5586          pea       24
00003310  4878 2610 5587          pea       _Check.L
00003314  4E92      5588          jsr       (A2)
00003316  504F      5589          addq.w    #8,A7
                    5590   ; FlushKeyboard();                        // dump unread characters from keyboard
00003318  4EB8 0BA6 5591          jsr       _FlushKeyboard
                    5592   ; TraceException = 0;                     // clear trace exception port to remove any software generated single step/trace
0000331C  4239 0040 5593          clr.b     4194314
00003320  000A      
                    5594   ; //Initialize SPI
                    5595   ; //SPI_Init();
                    5596   ; //Initialize I2C
                    5597   ; I2C_Init();
00003322  4EB9 0000 5598          jsr       _I2C_Init
00003326  3406      
                    5599   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5600   ; while (((char)(PortB & 0x02)) == (char)(0x02)) {
                    5601   main_7:
00003328  1039 0040 5602          move.b    4194306,D0
0000332C  0002      
0000332E  C03C 0002 5603          and.b     #2,D0
00003332  0C00 0002 5604          cmp.b     #2,D0
00003336  662A      5605          bne.s     main_9
                    5606   ; LoadFromFlashChip();
00003338  4EB8 115C 5607          jsr       _LoadFromFlashChip
                    5608   ; printf("\r\nRunning.....");
0000333C  4879 0000 5609          pea       @m68kde~3_182.L
00003340  65CE      
00003342  4E93      5610          jsr       (A3)
00003344  584F      5611          addq.w    #4,A7
                    5612   ; Oline1("Running.....");
00003346  4879 0000 5613          pea       @m68kde~3_183.L
0000334A  65DE      
0000334C  4EB8 0A02 5614          jsr       _Oline1
00003350  584F      5615          addq.w    #4,A7
                    5616   ; GoFlag = 1;
00003352  23FC 0000 5617          move.l    #1,_GoFlag.L
00003356  0001 0B00 
0000335A  00DC      
                    5618   ; go();
0000335C  4EB8 08B8 5619          jsr       _go
00003360  60C6      5620          bra       main_7
                    5621   main_9:
                    5622   ; }
                    5623   ; // otherwise start the debug monitor
                    5624   ; Oline0(BugMessage);
00003362  2F03      5625          move.l    D3,-(A7)
00003364  4EB8 09D4 5626          jsr       _Oline0
00003368  584F      5627          addq.w    #4,A7
                    5628   ; Oline1("By: PJ Davies");
0000336A  4879 0000 5629          pea       @m68kde~3_184.L
0000336E  65EC      
00003370  4EB8 0A02 5630          jsr       _Oline1
00003374  584F      5631          addq.w    #4,A7
                    5632   ; printf("\r\n%s", BugMessage);
00003376  2F03      5633          move.l    D3,-(A7)
00003378  4879 0000 5634          pea       @m68kde~3_185.L
0000337C  65FA      
0000337E  4E93      5635          jsr       (A3)
00003380  504F      5636          addq.w    #8,A7
                    5637   ; printf("\r\n%s", CopyrightMessage);
00003382  2F2E FFF8 5638          move.l    -8(A6),-(A7)
00003386  4879 0000 5639          pea       @m68kde~3_185.L
0000338A  65FA      
0000338C  4E93      5640          jsr       (A3)
0000338E  504F      5641          addq.w    #8,A7
                    5642   ; printf("\r\n%s", NameAndStudentNumber);
00003390  2F2E FFFC 5643          move.l    -4(A6),-(A7)
00003394  4879 0000 5644          pea       @m68kde~3_185.L
00003398  65FA      
0000339A  4E93      5645          jsr       (A3)
0000339C  504F      5646          addq.w    #8,A7
                    5647   ; menu();
0000339E  4EB8 223E 5648          jsr       _menu
000033A2  4CDF 0C0C 5649          movem.l   (A7)+,D2/D3/A2/A3
000033A6  4E5E      5650          unlk      A6
000033A8  4E75      5651          rts
                    5652   ; }
                    5653   ; C:\CPEN412\ASN5\IIC_CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    5654   ; #include <stdio.h>
                    5655   ; /*************************************************************
                    5656   ; ** I2C Controller registers
                    5657   ; **************************************************************/
                    5658   ; // I2C Registers
                    5659   ; #define I2C_Clock_PrerLo (*(volatile unsigned char *)(0x00408000))
                    5660   ; #define I2C_Clock_PrerHi (*(volatile unsigned char *)(0x00408002))
                    5661   ; #define I2C_Control (*(volatile unsigned char *)(0x00408004))
                    5662   ; #define I2C_Transmit (*(volatile unsigned char *)(0x00408006))
                    5663   ; #define I2C_Receive (*(volatile unsigned char *)(0x00408006))
                    5664   ; #define I2C_Command (*(volatile unsigned char *)(0x00408008))
                    5665   ; #define I2C_Status (*(volatile unsigned char *)(0x00408008))
                    5666   ; /************************************************************************************/
                    5667   ; /*************************************************************
                    5668   ; ** I2C Commands
                    5669   ; **************************************************************/
                    5670   ; // I2C Commands
                    5671   ; #define I2C_Slave_Write_Start_Command 0x91  //1001 0001
                    5672   ; #define I2C_Slave_Read_Start_Command 0xA9   //1010 1001
                    5673   ; #define I2C_Slave_Write_Stop_Command 0x51   //0101 0001
                    5674   ; #define I2C_Slave_Read_Stop_Command 0x69    //0110 1001
                    5675   ; #define I2C_Slave_Write_Command 0x11        //0001 0001
                    5676   ; #define I2C_Slave_Read_Command 0x21         //0010 1001
                    5677   ; /************************************************************************************/
                    5678   ; /*************************************************************
                    5679   ; ** EEPROM Commands
                    5680   ; **************************************************************/
                    5681   ; // EEPROM Commands
                    5682   ; #define EEPROM_READ_HI_BLK 0xA3     //1010 0011
                    5683   ; #define EEPROM_READ_LO_BLK 0xA1     //1010 0001
                    5684   ; #define EEPROM_WRITE_HI_BLK 0xA2    //1010 0010
                    5685   ; #define EEPROM_WRITE_LO_BLK 0xA0    //1010 0000
                    5686   ; /************************************************************************************/
                    5687   ; /*************************************************************
                    5688   ; ** ADC/DAC Commands
                    5689   ; **************************************************************/
                    5690   ; // ADC/DAC Commands
                    5691   ; #define ADC_DAC_WRITE_ADDRESS 0x92      //1001 0010
                    5692   ; #define DAC_ENABLE_COMMAND 0x40         //0100 0000
                    5693   ; #define ADC_ENABLE_COMMAND 0x44         //0100 0100
                    5694   ; #define ADC_READ_ADDRESS 0x93           //1001 0011
                    5695   ; /************************************************************************************/
                    5696   ; /************************************************************************************
                    5697   ; ** 
                    5698   ; This register is used to prescale the SCL clock line. Due to the structure of the I2C
                    5699   ; interface, the core uses a 5*SCL clock internally. The prescale register must be
                    5700   ; programmed to this 5*SCL frequency (minus 1). Change the value of the prescale
                    5701   ; register only when the ‘EN’ bit is cleared.
                    5702   ; The core responds to new commands only when the ‘EN’ bit is set. Pending commands
                    5703   ; are finished. Clear the ‘EN’ bit only when no transfer is in progress, i.e. after a STOP
                    5704   ; command, or when the command register has the STO bit set. When halted during a
                    5705   ; transfer, the core can hang the I2
                    5706   ; C bus. 
                    5707   ; for 25Mhz, 100KHz SCL Clock line 
                    5708   ; ************************************************************************************/
                    5709   ; #define Enable_I2C_CS() I2C_Control = 0x80 // 0x80 | 1000 0000 | 00xx xxxx
                    5710   ; /***********************************************************************************/
                    5711   ; /************************************************************************************
                    5712   ; ** Subfunctions for I2C
                    5713   ; ************************************************************************************/
                    5714   ; void Enable_SCL_Clock(void){
                    5715   _Enable_SCL_Clock:
                    5716   ; I2C_Clock_PrerLo = 0x31;
000033AA  13FC 0031 5717          move.b    #49,4227072
000033AE  0040 8000 
                    5718   ; I2C_Clock_PrerHi = 0x00;
000033B2  4239 0040 5719          clr.b     4227074
000033B6  8002      
                    5720   ; return;
000033B8  4E75      5721          rts
                    5722   ; }
                    5723   ; void WaitForI2C_TIP(void){
                    5724   _WaitForI2C_TIP:
000033BA  4E56 FFFC 5725          link      A6,#-4
                    5726   ; int TIP_bit;
                    5727   ; do{
                    5728   WaitForI2C_TIP_1:
                    5729   ; TIP_bit = (I2C_Status >> 1) & 0x01; 
000033BE  1039 0040 5730          move.b    4227080,D0
000033C2  8008      
000033C4  C0BC 0000 5731          and.l     #255,D0
000033C8  00FF      
000033CA  E288      5732          lsr.l     #1,D0
000033CC  C0BC 0000 5733          and.l     #1,D0
000033D0  0001      
000033D2  2D40 FFFC 5734          move.l    D0,-4(A6)
000033D6  202E FFFC 5735          move.l    -4(A6),D0
000033DA  66E2      5736          bne       WaitForI2C_TIP_1
                    5737   ; }while(TIP_bit != 0);
                    5738   ; return;
000033DC  4E5E      5739          unlk      A6
000033DE  4E75      5740          rts
                    5741   ; }
                    5742   ; void WaitForI2C_RxACK(void){
                    5743   _WaitForI2C_RxACK:
000033E0  4E56 FFFC 5744          link      A6,#-4
                    5745   ; int RxACK_bit;
                    5746   ; do{
                    5747   WaitForI2C_RxACK_1:
                    5748   ; RxACK_bit = (I2C_Status >> 7) & 0x01;
000033E4  1039 0040 5749          move.b    4227080,D0
000033E8  8008      
000033EA  C0BC 0000 5750          and.l     #255,D0
000033EE  00FF      
000033F0  EE88      5751          lsr.l     #7,D0
000033F2  C0BC 0000 5752          and.l     #1,D0
000033F6  0001      
000033F8  2D40 FFFC 5753          move.l    D0,-4(A6)
000033FC  202E FFFC 5754          move.l    -4(A6),D0
00003400  66E2      5755          bne       WaitForI2C_RxACK_1
                    5756   ; }while(RxACK_bit != 0);
                    5757   ; return;
00003402  4E5E      5758          unlk      A6
00003404  4E75      5759          rts
                    5760   ; }
                    5761   ; /************************************************************************************
                    5762   ; ** initialises the I2C controller 
                    5763   ; ************************************************************************************/
                    5764   ; void I2C_Init(void){
                    5765   _I2C_Init:
                    5766   ; //Enabling 100Khz SCL Clock Line
                    5767   ; Enable_SCL_Clock();
00003406  4EB8 33AA 5768          jsr       _Enable_SCL_Clock
                    5769   ; //Enabling I2C for no interupts and enabling core
                    5770   ; Enable_I2C_CS();
0000340A  13FC 0080 5771          move.b    #128,4227076
0000340E  0040 8004 
                    5772   ; return;
00003412  4E75      5773          rts
                    5774   ; }
                    5775   ; /************************************************************************************
                    5776   ; ** Write with I2C (byte)
                    5777   ; ************************************************************************************/
                    5778   ; void WriteI2CInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB, unsigned char c, int flag){
                    5779   _WriteI2CInteraction:
00003414  4E56 0000 5780          link      A6,#0
00003418  48E7 2030 5781          movem.l   D2/A2/A3,-(A7)
0000341C  45F8 33BA 5782          lea       _WaitForI2C_TIP.L,A2
00003420  47F8 33E0 5783          lea       _WaitForI2C_RxACK.L,A3
                    5784   ; //////////////////////////////Control Byte//////////////////////////////
                    5785   ; unsigned char controlByte;
                    5786   ; if(block == 1){
00003424  202E 0008 5787          move.l    8(A6),D0
00003428  0C80 0000 5788          cmp.l     #1,D0
0000342C  0001      
0000342E  6606      5789          bne.s     WriteI2CInteraction_1
                    5790   ; controlByte = EEPROM_WRITE_HI_BLK;
00003430  143C 00A2 5791          move.b    #162,D2
00003434  6004      5792          bra.s     WriteI2CInteraction_2
                    5793   WriteI2CInteraction_1:
                    5794   ; }else{
                    5795   ; controlByte = EEPROM_WRITE_LO_BLK;
00003436  143C 00A0 5796          move.b    #160,D2
                    5797   WriteI2CInteraction_2:
                    5798   ; }
                    5799   ; //Wait for TIP and RxACK bit in Status Register 
                    5800   ; WaitForI2C_TIP();
0000343A  4E92      5801          jsr       (A2)
                    5802   ; //Send data to Transmit register
                    5803   ; I2C_Transmit = controlByte;
0000343C  13C2 0040 5804          move.b    D2,4227078
00003440  8006      
                    5805   ; //Set Control Register to start write
                    5806   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003442  13FC 0091 5807          move.b    #145,4227080
00003446  0040 8008 
                    5808   ; //Wait for TIP bit in Status Register 
                    5809   ; WaitForI2C_TIP();
0000344A  4E92      5810          jsr       (A2)
                    5811   ; //Wait RxACK bit in Status Register 
                    5812   ; WaitForI2C_RxACK();
0000344C  4E93      5813          jsr       (A3)
                    5814   ; //////////////////////////////MSB of Address//////////////////////////////
                    5815   ; //Send data to Transmit register
                    5816   ; I2C_Transmit = AddressMSB;
0000344E  13EE 0013 5817          move.b    19(A6),4227078
00003452  0040 8006 
                    5818   ; //Set Control Register to start write
                    5819   ; I2C_Command = I2C_Slave_Write_Command;
00003456  13FC 0011 5820          move.b    #17,4227080
0000345A  0040 8008 
                    5821   ; //Wait for TIP bit in Status Register 
                    5822   ; WaitForI2C_TIP();
0000345E  4E92      5823          jsr       (A2)
                    5824   ; //Wait RxACK bit in Status Register 
                    5825   ; WaitForI2C_RxACK();
00003460  4E93      5826          jsr       (A3)
                    5827   ; ////////////////////////////LSB of Address////////////////////////////////
                    5828   ; //Send data to Transmit register
                    5829   ; I2C_Transmit = AddressLSB;
00003462  13EE 0017 5830          move.b    23(A6),4227078
00003466  0040 8006 
                    5831   ; //Set Control Register to start write
                    5832   ; I2C_Command = I2C_Slave_Write_Command;
0000346A  13FC 0011 5833          move.b    #17,4227080
0000346E  0040 8008 
                    5834   ; //Wait for TIP bit in Status Register 
                    5835   ; WaitForI2C_TIP();
00003472  4E92      5836          jsr       (A2)
                    5837   ; //Wait RxACK bit in Status Register 
                    5838   ; WaitForI2C_RxACK();
00003474  4E93      5839          jsr       (A3)
                    5840   ; //////////////////////////////Data//////////////////////////////
                    5841   ; //Send data to Transmit register
                    5842   ; I2C_Transmit = c;
00003476  13EE 001B 5843          move.b    27(A6),4227078
0000347A  0040 8006 
                    5844   ; //Set Control Register to start write
                    5845   ; I2C_Command = I2C_Slave_Write_Stop_Command;
0000347E  13FC 0051 5846          move.b    #81,4227080
00003482  0040 8008 
                    5847   ; //Wait for TIP bit in Status Register 
                    5848   ; WaitForI2C_TIP();
00003486  4E92      5849          jsr       (A2)
                    5850   ; //Wait RxACK bit in Status Register 
                    5851   ; WaitForI2C_RxACK();
00003488  4E93      5852          jsr       (A3)
                    5853   ; if(flag == 0){
0000348A  202E 001C 5854          move.l    28(A6),D0
0000348E  6620      5855          bne.s     WriteI2CInteraction_3
                    5856   ; printf("\r\nWrote [%x] to Address[%x]", c, Address);
00003490  2F2E 000C 5857          move.l    12(A6),-(A7)
00003494  122E 001B 5858          move.b    27(A6),D1
00003498  C2BC 0000 5859          and.l     #255,D1
0000349C  00FF      
0000349E  2F01      5860          move.l    D1,-(A7)
000034A0  4879 0000 5861          pea       @iic_co~1_1.L
000034A4  6610      
000034A6  4EB9 0000 5862          jsr       _printf
000034AA  4084      
000034AC  DEFC 000C 5863          add.w     #12,A7
                    5864   WriteI2CInteraction_3:
                    5865   ; }
                    5866   ; return;
000034B0  4CDF 0C04 5867          movem.l   (A7)+,D2/A2/A3
000034B4  4E5E      5868          unlk      A6
000034B6  4E75      5869          rts
                    5870   ; }
                    5871   ; /************************************************************************************
                    5872   ; ** Write with I2C (Page)
                    5873   ; ************************************************************************************/
                    5874   ; void PageWriteI2CInteraction(unsigned int AddressFrom, unsigned int AddressTo, unsigned char c){
                    5875   _PageWriteI2CInteraction:
000034B8  4E56 FFF8 5876          link      A6,#-8
000034BC  48E7 3F3C 5877          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000034C0  242E 0008 5878          move.l    8(A6),D2
000034C4  45F8 33BA 5879          lea       _WaitForI2C_TIP.L,A2
000034C8  47F8 33E0 5880          lea       _WaitForI2C_RxACK.L,A3
000034CC  1E2E 0013 5881          move.b    19(A6),D7
000034D0  CEBC 0000 5882          and.l     #255,D7
000034D4  00FF      
000034D6  286E 000C 5883          move.l    12(A6),A4
                    5884   ; int flag = 0;
000034DA  3A7C 0000 5885          move.w    #0,A5
                    5886   ; int flag_special = 0;
000034DE  42AE FFF8 5887          clr.l     -8(A6)
                    5888   ; int i = 0;
000034E2  4283      5889          clr.l     D3
                    5890   ; unsigned char controlByte;
                    5891   ; unsigned char AddressFromMSB, AddressFromLSB;
                    5892   ; unsigned int AddressFrom_Initial;
                    5893   ; AddressFrom_Initial = AddressFrom;
000034E4  2D42 FFFC 5894          move.l    D2,-4(A6)
                    5895   ; while(AddressFrom < AddressTo){
                    5896   PageWriteI2CInteraction_1:
000034E8  B48C      5897          cmp.l     A4,D2
000034EA  6400 0270 5898          bhs       PageWriteI2CInteraction_3
                    5899   ; if(AddressFrom + 128 > AddressTo){
000034EE  2002      5900          move.l    D2,D0
000034F0  0680 0000 5901          add.l     #128,D0
000034F4  0080      
000034F6  B08C      5902          cmp.l     A4,D0
000034F8  6304      5903          bls.s     PageWriteI2CInteraction_4
                    5904   ; flag = 1;
000034FA  3A7C 0001 5905          move.w    #1,A5
                    5906   PageWriteI2CInteraction_4:
                    5907   ; }
                    5908   ; if(AddressFrom > 63999){
000034FE  0C82 0000 5909          cmp.l     #63999,D2
00003502  F9FF      
00003504  6328      5910          bls.s     PageWriteI2CInteraction_6
                    5911   ; controlByte = EEPROM_WRITE_HI_BLK;
00003506  1C3C 00A2 5912          move.b    #162,D6
                    5913   ; AddressFromMSB = ((AddressFrom - 0xFA00) >> 8) & 0xFF;
0000350A  2002      5914          move.l    D2,D0
0000350C  0480 0000 5915          sub.l     #64000,D0
00003510  FA00      
00003512  E088      5916          lsr.l     #8,D0
00003514  C0BC 0000 5917          and.l     #255,D0
00003518  00FF      
0000351A  1A00      5918          move.b    D0,D5
                    5919   ; AddressFromLSB = (AddressFrom - 0xFA00) & 0xFF;         
0000351C  2002      5920          move.l    D2,D0
0000351E  0480 0000 5921          sub.l     #64000,D0
00003522  FA00      
00003524  C0BC 0000 5922          and.l     #255,D0
00003528  00FF      
0000352A  1800      5923          move.b    D0,D4
0000352C  601A      5924          bra.s     PageWriteI2CInteraction_7
                    5925   PageWriteI2CInteraction_6:
                    5926   ; }else{
                    5927   ; controlByte = EEPROM_WRITE_LO_BLK;
0000352E  1C3C 00A0 5928          move.b    #160,D6
                    5929   ; AddressFromMSB = (AddressFrom >> 8) & 0xFF;
00003532  2002      5930          move.l    D2,D0
00003534  E088      5931          lsr.l     #8,D0
00003536  C0BC 0000 5932          and.l     #255,D0
0000353A  00FF      
0000353C  1A00      5933          move.b    D0,D5
                    5934   ; AddressFromLSB = AddressFrom & 0xFF;
0000353E  2002      5935          move.l    D2,D0
00003540  C0BC 0000 5936          and.l     #255,D0
00003544  00FF      
00003546  1800      5937          move.b    D0,D4
                    5938   PageWriteI2CInteraction_7:
                    5939   ; }
                    5940   ; //Wait for TIP and RxACK bit in Status Register 
                    5941   ; WaitForI2C_TIP();
00003548  4E92      5942          jsr       (A2)
                    5943   ; //Send data to Transmit register
                    5944   ; I2C_Transmit = controlByte;
0000354A  13C6 0040 5945          move.b    D6,4227078
0000354E  8006      
                    5946   ; //Set Control Register to start write
                    5947   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003550  13FC 0091 5948          move.b    #145,4227080
00003554  0040 8008 
                    5949   ; //Wait for TIP bit in Status Register
                    5950   ; WaitForI2C_TIP();
00003558  4E92      5951          jsr       (A2)
                    5952   ; //Wait RxACK bit in Status Register 
                    5953   ; WaitForI2C_RxACK();
0000355A  4E93      5954          jsr       (A3)
                    5955   ; //Send data to Transmit register
                    5956   ; I2C_Transmit = AddressFromMSB;
0000355C  13C5 0040 5957          move.b    D5,4227078
00003560  8006      
                    5958   ; //Set Control Register to start write
                    5959   ; I2C_Command = I2C_Slave_Write_Command;
00003562  13FC 0011 5960          move.b    #17,4227080
00003566  0040 8008 
                    5961   ; //Wait for TIP bit in Status Register 
                    5962   ; WaitForI2C_TIP();
0000356A  4E92      5963          jsr       (A2)
                    5964   ; //Wait RxACK bit in Status Register 
                    5965   ; WaitForI2C_RxACK();
0000356C  4E93      5966          jsr       (A3)
                    5967   ; //Send data to Transmit register
                    5968   ; I2C_Transmit = AddressFromLSB;
0000356E  13C4 0040 5969          move.b    D4,4227078
00003572  8006      
                    5970   ; //Set Control Register to start write
                    5971   ; I2C_Command = I2C_Slave_Write_Command;
00003574  13FC 0011 5972          move.b    #17,4227080
00003578  0040 8008 
                    5973   ; //Wait for TIP bit in Status Register 
                    5974   ; WaitForI2C_TIP();
0000357C  4E92      5975          jsr       (A2)
                    5976   ; //Wait RxACK bit in Status Register 
                    5977   ; WaitForI2C_RxACK();
0000357E  4E93      5978          jsr       (A3)
                    5979   ; if(flag == 0){
00003580  200D      5980          move.l    A5,D0
00003582  6600 007C 5981          bne       PageWriteI2CInteraction_8
                    5982   ; for(i = 0; i < 128; i++){
00003586  4283      5983          clr.l     D3
                    5984   PageWriteI2CInteraction_10:
00003588  0C83 0000 5985          cmp.l     #128,D3
0000358C  0080      
0000358E  6C00 0042 5986          bge       PageWriteI2CInteraction_12
                    5987   ; //Send data to Transmit register
                    5988   ; I2C_Transmit = c;
00003592  13C7 0040 5989          move.b    D7,4227078
00003596  8006      
                    5990   ; //Set Control Register to start write
                    5991   ; I2C_Command = I2C_Slave_Write_Command;
00003598  13FC 0011 5992          move.b    #17,4227080
0000359C  0040 8008 
                    5993   ; //Wait for TIP bit in Status Register 
                    5994   ; WaitForI2C_TIP();
000035A0  4E92      5995          jsr       (A2)
                    5996   ; //Wait RxACK bit in Status Register 
                    5997   ; WaitForI2C_RxACK();
000035A2  4E93      5998          jsr       (A3)
                    5999   ; if((AddressFrom + i) % 128 == 0){
000035A4  2002      6000          move.l    D2,D0
000035A6  D083      6001          add.l     D3,D0
000035A8  2F00      6002          move.l    D0,-(A7)
000035AA  4878 0080 6003          pea       128
000035AE  4EB9 0000 6004          jsr       ULDIV
000035B2  3E98      
000035B4  202F 0004 6005          move.l    4(A7),D0
000035B8  504F      6006          addq.w    #8,A7
000035BA  4A80      6007          tst.l     D0
000035BC  6602      6008          bne.s     PageWriteI2CInteraction_13
                    6009   ; break;
000035BE  6012      6010          bra.s     PageWriteI2CInteraction_12
                    6011   PageWriteI2CInteraction_13:
                    6012   ; }
                    6013   ; //Checking if required to switch blocks
                    6014   ; if(AddressFrom + i == 63999){
000035C0  2002      6015          move.l    D2,D0
000035C2  D083      6016          add.l     D3,D0
000035C4  0C80 0000 6017          cmp.l     #63999,D0
000035C8  F9FF      
000035CA  6602      6018          bne.s     PageWriteI2CInteraction_15
                    6019   ; break;
000035CC  6004      6020          bra.s     PageWriteI2CInteraction_12
                    6021   PageWriteI2CInteraction_15:
000035CE  5283      6022          addq.l    #1,D3
000035D0  60B6      6023          bra       PageWriteI2CInteraction_10
                    6024   PageWriteI2CInteraction_12:
                    6025   ; }
                    6026   ; }
                    6027   ; //Set Control Register to start write
                    6028   ; I2C_Command = I2C_Slave_Write_Stop_Command;
000035D2  13FC 0051 6029          move.b    #81,4227080
000035D6  0040 8008 
                    6030   ; //Wait for TIP bit in Status Register 
                    6031   ; WaitForI2C_TIP();
000035DA  4E92      6032          jsr       (A2)
                    6033   ; //Wait RxACK bit in Status Register 
                    6034   ; WaitForI2C_RxACK();
000035DC  4E93      6035          jsr       (A3)
                    6036   ; do{
                    6037   PageWriteI2CInteraction_17:
                    6038   ; I2C_Transmit = controlByte;
000035DE  13C6 0040 6039          move.b    D6,4227078
000035E2  8006      
                    6040   ; I2C_Command = I2C_Slave_Write_Start_Command;
000035E4  13FC 0091 6041          move.b    #145,4227080
000035E8  0040 8008 
                    6042   ; WaitForI2C_TIP();
000035EC  4E92      6043          jsr       (A2)
000035EE  1039 0040 6044          move.b    4227080,D0
000035F2  8008      
000035F4  EE08      6045          lsr.b     #7,D0
000035F6  C03C 0001 6046          and.b     #1,D0
000035FA  66E2      6047          bne       PageWriteI2CInteraction_17
000035FC  6000 0078 6048          bra       PageWriteI2CInteraction_9
                    6049   PageWriteI2CInteraction_8:
                    6050   ; }while(((I2C_Status >> 7) & 0x01) != 0);
                    6051   ; }else{
                    6052   ; for(i = 0; i < ((AddressTo - AddressFrom)); i++){
00003600  4283      6053          clr.l     D3
                    6054   PageWriteI2CInteraction_19:
00003602  200C      6055          move.l    A4,D0
00003604  9082      6056          sub.l     D2,D0
00003606  B680      6057          cmp.l     D0,D3
00003608  6400 0042 6058          bhs       PageWriteI2CInteraction_21
                    6059   ; //Send data to Transmit register
                    6060   ; I2C_Transmit = c;
0000360C  13C7 0040 6061          move.b    D7,4227078
00003610  8006      
                    6062   ; //Set Control Register to start write
                    6063   ; I2C_Command = I2C_Slave_Write_Command;
00003612  13FC 0011 6064          move.b    #17,4227080
00003616  0040 8008 
                    6065   ; //Wait for TIP bit in Status Register 
                    6066   ; WaitForI2C_TIP();
0000361A  4E92      6067          jsr       (A2)
                    6068   ; //Wait RxACK bit in Status Register 
                    6069   ; WaitForI2C_RxACK();
0000361C  4E93      6070          jsr       (A3)
                    6071   ; if((AddressFrom + i) % 128 == 0){
0000361E  2002      6072          move.l    D2,D0
00003620  D083      6073          add.l     D3,D0
00003622  2F00      6074          move.l    D0,-(A7)
00003624  4878 0080 6075          pea       128
00003628  4EB9 0000 6076          jsr       ULDIV
0000362C  3E98      
0000362E  202F 0004 6077          move.l    4(A7),D0
00003632  504F      6078          addq.w    #8,A7
00003634  4A80      6079          tst.l     D0
00003636  6602      6080          bne.s     PageWriteI2CInteraction_22
                    6081   ; break;
00003638  6012      6082          bra.s     PageWriteI2CInteraction_21
                    6083   PageWriteI2CInteraction_22:
                    6084   ; }
                    6085   ; //Checking if required to switch blocks
                    6086   ; if(AddressFrom + i == 63999){
0000363A  2002      6087          move.l    D2,D0
0000363C  D083      6088          add.l     D3,D0
0000363E  0C80 0000 6089          cmp.l     #63999,D0
00003642  F9FF      
00003644  6602      6090          bne.s     PageWriteI2CInteraction_24
                    6091   ; break;
00003646  6004      6092          bra.s     PageWriteI2CInteraction_21
                    6093   PageWriteI2CInteraction_24:
00003648  5283      6094          addq.l    #1,D3
0000364A  60B6      6095          bra       PageWriteI2CInteraction_19
                    6096   PageWriteI2CInteraction_21:
                    6097   ; }
                    6098   ; }
                    6099   ; //Set Control Register to start write
                    6100   ; I2C_Command = I2C_Slave_Write_Stop_Command;
0000364C  13FC 0051 6101          move.b    #81,4227080
00003650  0040 8008 
                    6102   ; //Wait for TIP bit in Status Register 
                    6103   ; WaitForI2C_TIP();
00003654  4E92      6104          jsr       (A2)
                    6105   ; //Wait RxACK bit in Status Register 
                    6106   ; WaitForI2C_RxACK();
00003656  4E93      6107          jsr       (A3)
                    6108   ; do{
                    6109   PageWriteI2CInteraction_26:
                    6110   ; I2C_Transmit = controlByte;
00003658  13C6 0040 6111          move.b    D6,4227078
0000365C  8006      
                    6112   ; I2C_Command = I2C_Slave_Write_Start_Command;
0000365E  13FC 0091 6113          move.b    #145,4227080
00003662  0040 8008 
                    6114   ; WaitForI2C_TIP();
00003666  4E92      6115          jsr       (A2)
00003668  1039 0040 6116          move.b    4227080,D0
0000366C  8008      
0000366E  EE08      6117          lsr.b     #7,D0
00003670  C03C 0001 6118          and.b     #1,D0
00003674  66E2      6119          bne       PageWriteI2CInteraction_26
                    6120   PageWriteI2CInteraction_9:
                    6121   ; }while(((I2C_Status >> 7) & 0x01) != 0);
                    6122   ; }
                    6123   ; //Special case for end address being the first byte of the next/last page
                    6124   ; if(((AddressFrom + i) % 128 == 0) && (flag == 1)){
00003676  2002      6125          move.l    D2,D0
00003678  D083      6126          add.l     D3,D0
0000367A  2F00      6127          move.l    D0,-(A7)
0000367C  4878 0080 6128          pea       128
00003680  4EB9 0000 6129          jsr       ULDIV
00003684  3E98      
00003686  202F 0004 6130          move.l    4(A7),D0
0000368A  504F      6131          addq.w    #8,A7
0000368C  4A80      6132          tst.l     D0
0000368E  6600 00C2 6133          bne       PageWriteI2CInteraction_31
00003692  200D      6134          move.l    A5,D0
00003694  0C80 0000 6135          cmp.l     #1,D0
00003698  0001      
0000369A  6600 00B6 6136          bne       PageWriteI2CInteraction_31
                    6137   ; if((AddressFrom + i) > 63999){
0000369E  2002      6138          move.l    D2,D0
000036A0  D083      6139          add.l     D3,D0
000036A2  0C80 0000 6140          cmp.l     #63999,D0
000036A6  F9FF      
000036A8  6300 005E 6141          bls       PageWriteI2CInteraction_30
                    6142   ; controlByte = EEPROM_WRITE_HI_BLK;
000036AC  1C3C 00A2 6143          move.b    #162,D6
                    6144   ; AddressFromMSB = (((AddressFrom + i) - 0xFA00) >> 8) & 0xFF;
000036B0  2002      6145          move.l    D2,D0
000036B2  D083      6146          add.l     D3,D0
000036B4  0480 0000 6147          sub.l     #64000,D0
000036B8  FA00      
000036BA  E088      6148          lsr.l     #8,D0
000036BC  C0BC 0000 6149          and.l     #255,D0
000036C0  00FF      
000036C2  1A00      6150          move.b    D0,D5
                    6151   ; AddressFromLSB = ((AddressFrom + i) - 0xFA00) & 0xFF;   
000036C4  2002      6152          move.l    D2,D0
000036C6  D083      6153          add.l     D3,D0
000036C8  0480 0000 6154          sub.l     #64000,D0
000036CC  FA00      
000036CE  C0BC 0000 6155          and.l     #255,D0
000036D2  00FF      
000036D4  1800      6156          move.b    D0,D4
                    6157   ; WriteI2CInteraction(1, (AddressFrom + i), AddressFromMSB, AddressFromLSB, c, 1);     
000036D6  4878 0001 6158          pea       1
000036DA  CEBC 0000 6159          and.l     #255,D7
000036DE  00FF      
000036E0  2F07      6160          move.l    D7,-(A7)
000036E2  C8BC 0000 6161          and.l     #255,D4
000036E6  00FF      
000036E8  2F04      6162          move.l    D4,-(A7)
000036EA  CABC 0000 6163          and.l     #255,D5
000036EE  00FF      
000036F0  2F05      6164          move.l    D5,-(A7)
000036F2  2202      6165          move.l    D2,D1
000036F4  D283      6166          add.l     D3,D1
000036F6  2F01      6167          move.l    D1,-(A7)
000036F8  4878 0001 6168          pea       1
000036FC  4EB8 3414 6169          jsr       _WriteI2CInteraction
00003700  DEFC 0018 6170          add.w     #24,A7
00003704  6000 004C 6171          bra       PageWriteI2CInteraction_31
                    6172   PageWriteI2CInteraction_30:
                    6173   ; }else{
                    6174   ; controlByte = EEPROM_WRITE_LO_BLK;
00003708  1C3C 00A0 6175          move.b    #160,D6
                    6176   ; AddressFromMSB = ((AddressFrom + i) >> 8) & 0xFF;
0000370C  2002      6177          move.l    D2,D0
0000370E  D083      6178          add.l     D3,D0
00003710  E088      6179          lsr.l     #8,D0
00003712  C0BC 0000 6180          and.l     #255,D0
00003716  00FF      
00003718  1A00      6181          move.b    D0,D5
                    6182   ; AddressFromLSB = (AddressFrom + i) & 0xFF;
0000371A  2002      6183          move.l    D2,D0
0000371C  D083      6184          add.l     D3,D0
0000371E  C0BC 0000 6185          and.l     #255,D0
00003722  00FF      
00003724  1800      6186          move.b    D0,D4
                    6187   ; WriteI2CInteraction(0, (AddressFrom + i), AddressFromMSB, AddressFromLSB, c, 1); 
00003726  4878 0001 6188          pea       1
0000372A  CEBC 0000 6189          and.l     #255,D7
0000372E  00FF      
00003730  2F07      6190          move.l    D7,-(A7)
00003732  C8BC 0000 6191          and.l     #255,D4
00003736  00FF      
00003738  2F04      6192          move.l    D4,-(A7)
0000373A  CABC 0000 6193          and.l     #255,D5
0000373E  00FF      
00003740  2F05      6194          move.l    D5,-(A7)
00003742  2202      6195          move.l    D2,D1
00003744  D283      6196          add.l     D3,D1
00003746  2F01      6197          move.l    D1,-(A7)
00003748  42A7      6198          clr.l     -(A7)
0000374A  4EB8 3414 6199          jsr       _WriteI2CInteraction
0000374E  DEFC 0018 6200          add.w     #24,A7
                    6201   PageWriteI2CInteraction_31:
                    6202   ; }
                    6203   ; }
                    6204   ; AddressFrom += (i + 1);
00003752  2003      6205          move.l    D3,D0
00003754  5280      6206          addq.l    #1,D0
00003756  D480      6207          add.l     D0,D2
00003758  6000 FD8E 6208          bra       PageWriteI2CInteraction_1
                    6209   PageWriteI2CInteraction_3:
                    6210   ; }
                    6211   ; printf("\r\nWrote [%x] from Address[%x] to Address[%x]", c, AddressFrom_Initial, AddressTo);
0000375C  2F0C      6212          move.l    A4,-(A7)
0000375E  2F2E FFFC 6213          move.l    -4(A6),-(A7)
00003762  CEBC 0000 6214          and.l     #255,D7
00003766  00FF      
00003768  2F07      6215          move.l    D7,-(A7)
0000376A  4879 0000 6216          pea       @iic_co~1_2.L
0000376E  662C      
00003770  4EB9 0000 6217          jsr       _printf
00003774  4084      
00003776  DEFC 0010 6218          add.w     #16,A7
                    6219   ; return;
0000377A  4CDF 3CFC 6220          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000377E  4E5E      6221          unlk      A6
00003780  4E75      6222          rts
                    6223   ; }
                    6224   ; void ReadI2CByteInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB, unsigned char c){
                    6225   _ReadI2CByteInteraction:
00003782  4E56 FFFC 6226          link      A6,#-4
00003786  48E7 3030 6227          movem.l   D2/D3/A2/A3,-(A7)
0000378A  45F8 33BA 6228          lea       _WaitForI2C_TIP.L,A2
0000378E  47F8 33E0 6229          lea       _WaitForI2C_RxACK.L,A3
                    6230   ; unsigned char controleByte_ForWrite;
                    6231   ; unsigned char controlByte_ForRead;
                    6232   ; unsigned char readData;
                    6233   ; if(block == 1){
00003792  202E 0008 6234          move.l    8(A6),D0
00003796  0C80 0000 6235          cmp.l     #1,D0
0000379A  0001      
0000379C  660A      6236          bne.s     ReadI2CByteInteraction_1
                    6237   ; controleByte_ForWrite= EEPROM_WRITE_HI_BLK;
0000379E  163C 00A2 6238          move.b    #162,D3
                    6239   ; controlByte_ForRead = EEPROM_READ_HI_BLK;
000037A2  143C 00A3 6240          move.b    #163,D2
000037A6  6008      6241          bra.s     ReadI2CByteInteraction_2
                    6242   ReadI2CByteInteraction_1:
                    6243   ; }else{
                    6244   ; controleByte_ForWrite = EEPROM_WRITE_LO_BLK;
000037A8  163C 00A0 6245          move.b    #160,D3
                    6246   ; controlByte_ForRead = EEPROM_READ_LO_BLK;
000037AC  143C 00A1 6247          move.b    #161,D2
                    6248   ReadI2CByteInteraction_2:
                    6249   ; }
                    6250   ; //////////////////////////////???//////////////////////////////
                    6251   ; //Wait for TIP and RxACK bit in Status Register 
                    6252   ; WaitForI2C_TIP();
000037B0  4E92      6253          jsr       (A2)
                    6254   ; //Send data to Transmit register
                    6255   ; I2C_Transmit = controleByte_ForWrite;
000037B2  13C3 0040 6256          move.b    D3,4227078
000037B6  8006      
                    6257   ; //Set Control Register to start write
                    6258   ; I2C_Command = I2C_Slave_Write_Start_Command;
000037B8  13FC 0091 6259          move.b    #145,4227080
000037BC  0040 8008 
                    6260   ; //Wait for TIP bit in Status Register 
                    6261   ; WaitForI2C_TIP();
000037C0  4E92      6262          jsr       (A2)
                    6263   ; //Wait RxACK bit in Status Register 
                    6264   ; WaitForI2C_RxACK();
000037C2  4E93      6265          jsr       (A3)
                    6266   ; //////////////////////////////???//////////////////////////////
                    6267   ; //Send data to Transmit register
                    6268   ; I2C_Transmit = AddressMSB;
000037C4  13EE 0013 6269          move.b    19(A6),4227078
000037C8  0040 8006 
                    6270   ; //Set Control Register to start write
                    6271   ; I2C_Command = I2C_Slave_Write_Command;
000037CC  13FC 0011 6272          move.b    #17,4227080
000037D0  0040 8008 
                    6273   ; //Wait for TIP bit in Status Register 
                    6274   ; WaitForI2C_TIP();
000037D4  4E92      6275          jsr       (A2)
                    6276   ; //Wait RxACK bit in Status Register 
                    6277   ; WaitForI2C_RxACK();
000037D6  4E93      6278          jsr       (A3)
                    6279   ; //////////////////////////////???//////////////////////////////
                    6280   ; //Send data to Transmit register
                    6281   ; I2C_Transmit = AddressLSB;
000037D8  13EE 0017 6282          move.b    23(A6),4227078
000037DC  0040 8006 
                    6283   ; //Set Control Register to start write
                    6284   ; I2C_Command = I2C_Slave_Write_Command;
000037E0  13FC 0011 6285          move.b    #17,4227080
000037E4  0040 8008 
                    6286   ; //Wait for TIP bit in Status Register 
                    6287   ; WaitForI2C_TIP();
000037E8  4E92      6288          jsr       (A2)
                    6289   ; //Wait RxACK bit in Status Register 
                    6290   ; WaitForI2C_RxACK();
000037EA  4E93      6291          jsr       (A3)
                    6292   ; //////////////////////////////???//////////////////////////////
                    6293   ; //Send data to Transmit register
                    6294   ; I2C_Transmit = controlByte_ForRead;
000037EC  13C2 0040 6295          move.b    D2,4227078
000037F0  8006      
                    6296   ; //Set Control Register to start write
                    6297   ; I2C_Command = I2C_Slave_Write_Start_Command;
000037F2  13FC 0091 6298          move.b    #145,4227080
000037F6  0040 8008 
                    6299   ; //Wait for TIP bit in Status Register 
                    6300   ; WaitForI2C_TIP();
000037FA  4E92      6301          jsr       (A2)
                    6302   ; //Wait RxACK bit in Status Register 
                    6303   ; WaitForI2C_RxACK();
000037FC  4E93      6304          jsr       (A3)
                    6305   ; //Set Control Register to start write
                    6306   ; I2C_Command = I2C_Slave_Read_Stop_Command;
000037FE  13FC 0069 6307          move.b    #105,4227080
00003802  0040 8008 
                    6308   ; //Wait for TIP bit in Status Register 
                    6309   ; WaitForI2C_TIP();
00003806  4E92      6310          jsr       (A2)
                    6311   ; //////////////////////////////???//////////////////////////////
                    6312   ; //poll for reading and clear after
                    6313   ; while((I2C_Status & 0x01) != 0x01) {
                    6314   ReadI2CByteInteraction_3:
00003808  1039 0040 6315          move.b    4227080,D0
0000380C  8008      
0000380E  C03C 0001 6316          and.b     #1,D0
00003812  0C00 0001 6317          cmp.b     #1,D0
00003816  6702      6318          beq.s     ReadI2CByteInteraction_5
                    6319   ; // Do nothing and wait for I2C_Status[0] to become 1
                    6320   ; }   
00003818  60EE      6321          bra       ReadI2CByteInteraction_3
                    6322   ReadI2CByteInteraction_5:
                    6323   ; I2C_Status = 0;
0000381A  4239 0040 6324          clr.b     4227080
0000381E  8008      
                    6325   ; //Grab data from Receive Register
                    6326   ; readData = I2C_Receive;
00003820  1D79 0040 6327          move.b    4227078,-1(A6)
00003824  8006 FFFF 
                    6328   ; printf("\r\nRead [%x] from Address[%x]", readData, Address);
00003828  2F2E 000C 6329          move.l    12(A6),-(A7)
0000382C  122E FFFF 6330          move.b    -1(A6),D1
00003830  C2BC 0000 6331          and.l     #255,D1
00003834  00FF      
00003836  2F01      6332          move.l    D1,-(A7)
00003838  4879 0000 6333          pea       @iic_co~1_3.L
0000383C  665A      
0000383E  4EB9 0000 6334          jsr       _printf
00003842  4084      
00003844  DEFC 000C 6335          add.w     #12,A7
                    6336   ; return;
00003848  4CDF 0C0C 6337          movem.l   (A7)+,D2/D3/A2/A3
0000384C  4E5E      6338          unlk      A6
0000384E  4E75      6339          rts
                    6340   ; }
                    6341   ; void ReadI2CSequential(int block, int AddressTo, int AddressFrom,  unsigned int ChipAddress){
                    6342   _ReadI2CSequential:
00003850  4E56 FFF8 6343          link      A6,#-8
00003854  48E7 3F30 6344          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
00003858  45F8 33BA 6345          lea       _WaitForI2C_TIP.L,A2
0000385C  242E 0014 6346          move.l    20(A6),D2
00003860  47F8 33E0 6347          lea       _WaitForI2C_RxACK.L,A3
                    6348   ; unsigned char controleWriteByte;
                    6349   ; unsigned char controlReadByte;
                    6350   ; unsigned char readData;
                    6351   ; unsigned char AddressLSB;
                    6352   ; unsigned char AddressMSB;
                    6353   ; int i;
                    6354   ; int size;
                    6355   ; size = AddressTo - AddressFrom;
00003864  202E 000C 6356          move.l    12(A6),D0
00003868  90AE 0010 6357          sub.l     16(A6),D0
0000386C  2D40 FFFC 6358          move.l    D0,-4(A6)
                    6359   ; AddressMSB = (ChipAddress >> 8) & 0xFF;
00003870  2002      6360          move.l    D2,D0
00003872  E088      6361          lsr.l     #8,D0
00003874  C0BC 0000 6362          and.l     #255,D0
00003878  00FF      
0000387A  1C00      6363          move.b    D0,D6
                    6364   ; AddressLSB = ChipAddress & 0xFF;
0000387C  2002      6365          move.l    D2,D0
0000387E  C0BC 0000 6366          and.l     #255,D0
00003882  00FF      
00003884  1A00      6367          move.b    D0,D5
                    6368   ; if(block == 1){
00003886  202E 0008 6369          move.l    8(A6),D0
0000388A  0C80 0000 6370          cmp.l     #1,D0
0000388E  0001      
00003890  662C      6371          bne.s     ReadI2CSequential_1
                    6372   ; controleWriteByte = EEPROM_WRITE_HI_BLK;
00003892  183C 00A2 6373          move.b    #162,D4
                    6374   ; controlReadByte = EEPROM_READ_HI_BLK;
00003896  163C 00A3 6375          move.b    #163,D3
                    6376   ; AddressMSB = ((ChipAddress-0xFA00) >> 8) & 0xFF;
0000389A  2002      6377          move.l    D2,D0
0000389C  0480 0000 6378          sub.l     #64000,D0
000038A0  FA00      
000038A2  E088      6379          lsr.l     #8,D0
000038A4  C0BC 0000 6380          and.l     #255,D0
000038A8  00FF      
000038AA  1C00      6381          move.b    D0,D6
                    6382   ; AddressLSB = (ChipAddress-0xFA00) & 0xFF;
000038AC  2002      6383          move.l    D2,D0
000038AE  0480 0000 6384          sub.l     #64000,D0
000038B2  FA00      
000038B4  C0BC 0000 6385          and.l     #255,D0
000038B8  00FF      
000038BA  1A00      6386          move.b    D0,D5
000038BC  6008      6387          bra.s     ReadI2CSequential_2
                    6388   ReadI2CSequential_1:
                    6389   ; }else{
                    6390   ; controleWriteByte = EEPROM_WRITE_LO_BLK;
000038BE  183C 00A0 6391          move.b    #160,D4
                    6392   ; controlReadByte = EEPROM_READ_LO_BLK;
000038C2  163C 00A1 6393          move.b    #161,D3
                    6394   ReadI2CSequential_2:
                    6395   ; }
                    6396   ; //Wait for TIP and RxACK bit in Status Register 
                    6397   ; WaitForI2C_TIP();
000038C6  4E92      6398          jsr       (A2)
                    6399   ; //Send data to Transmit register
                    6400   ; I2C_Transmit = controleWriteByte;
000038C8  13C4 0040 6401          move.b    D4,4227078
000038CC  8006      
                    6402   ; //Set Control Register to start write
                    6403   ; I2C_Command = I2C_Slave_Write_Start_Command;
000038CE  13FC 0091 6404          move.b    #145,4227080
000038D2  0040 8008 
                    6405   ; //Wait for TIP bit in Status Register 
                    6406   ; WaitForI2C_TIP();
000038D6  4E92      6407          jsr       (A2)
                    6408   ; //Wait RxACK bit in Status Register 
                    6409   ; WaitForI2C_RxACK();
000038D8  4E93      6410          jsr       (A3)
                    6411   ; //Send data to Transmit register
                    6412   ; I2C_Transmit = AddressMSB;
000038DA  13C6 0040 6413          move.b    D6,4227078
000038DE  8006      
                    6414   ; //Set Control Register to start write
                    6415   ; I2C_Command = I2C_Slave_Write_Command;
000038E0  13FC 0011 6416          move.b    #17,4227080
000038E4  0040 8008 
                    6417   ; //Wait for TIP bit in Status Register 
                    6418   ; WaitForI2C_TIP();
000038E8  4E92      6419          jsr       (A2)
                    6420   ; //Wait RxACK bit in Status Register 
                    6421   ; WaitForI2C_RxACK();
000038EA  4E93      6422          jsr       (A3)
                    6423   ; //////////////////////////////???//////////////////////////////
                    6424   ; //Send data to Transmit register
                    6425   ; I2C_Transmit = AddressLSB;
000038EC  13C5 0040 6426          move.b    D5,4227078
000038F0  8006      
                    6427   ; //Set Control Register to start write
                    6428   ; I2C_Command = I2C_Slave_Write_Command;
000038F2  13FC 0011 6429          move.b    #17,4227080
000038F6  0040 8008 
                    6430   ; //Wait for TIP bit in Status Register 
                    6431   ; WaitForI2C_TIP();
000038FA  4E92      6432          jsr       (A2)
                    6433   ; //Wait RxACK bit in Status Register 
                    6434   ; WaitForI2C_RxACK();
000038FC  4E93      6435          jsr       (A3)
                    6436   ; //Send data to Transmit register
                    6437   ; I2C_Transmit = controlReadByte;
000038FE  13C3 0040 6438          move.b    D3,4227078
00003902  8006      
                    6439   ; //Set Control Register to start read
                    6440   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003904  13FC 0091 6441          move.b    #145,4227080
00003908  0040 8008 
                    6442   ; //Wait for TIP bit in Status Register
                    6443   ; WaitForI2C_TIP();
0000390C  4E92      6444          jsr       (A2)
                    6445   ; //Wait RxACK bit in Status Register 
                    6446   ; WaitForI2C_RxACK();
0000390E  4E93      6447          jsr       (A3)
                    6448   ; for (i = 0; i<=size; i++){
00003910  7E00      6449          moveq     #0,D7
                    6450   ReadI2CSequential_3:
00003912  BEAE FFFC 6451          cmp.l     -4(A6),D7
00003916  6E00 00D2 6452          bgt       ReadI2CSequential_5
                    6453   ; if(ChipAddress == 64000 && (controlReadByte == EEPROM_READ_LO_BLK)){
0000391A  0C82 0000 6454          cmp.l     #64000,D2
0000391E  FA00      
00003920  6600 007E 6455          bne       ReadI2CSequential_6
00003924  C67C 00FF 6456          and.w     #255,D3
00003928  0C43 00A1 6457          cmp.w     #161,D3
0000392C  6600 0072 6458          bne       ReadI2CSequential_6
                    6459   ; //Stop command to switch blocks
                    6460   ; I2C_Command = I2C_Slave_Read_Stop_Command;
00003930  13FC 0069 6461          move.b    #105,4227080
00003934  0040 8008 
                    6462   ; WaitForI2C_TIP();
00003938  4E92      6463          jsr       (A2)
                    6464   ; AddressMSB = (ChipAddress - 0xFA00) >> 8;
0000393A  2002      6465          move.l    D2,D0
0000393C  0480 0000 6466          sub.l     #64000,D0
00003940  FA00      
00003942  E088      6467          lsr.l     #8,D0
00003944  1C00      6468          move.b    D0,D6
                    6469   ; AddressLSB = (ChipAddress - 0xFA00);     
00003946  2002      6470          move.l    D2,D0
00003948  0480 0000 6471          sub.l     #64000,D0
0000394C  FA00      
0000394E  1A00      6472          move.b    D0,D5
                    6473   ; controleWriteByte = EEPROM_WRITE_HI_BLK;
00003950  183C 00A2 6474          move.b    #162,D4
                    6475   ; controlReadByte = EEPROM_READ_HI_BLK;
00003954  163C 00A3 6476          move.b    #163,D3
                    6477   ; I2C_Transmit = controleWriteByte;
00003958  13C4 0040 6478          move.b    D4,4227078
0000395C  8006      
                    6479   ; I2C_Command = I2C_Slave_Write_Start_Command; 
0000395E  13FC 0091 6480          move.b    #145,4227080
00003962  0040 8008 
                    6481   ; //Wait for TIP bit in Status Register 
                    6482   ; WaitForI2C_TIP();
00003966  4E92      6483          jsr       (A2)
                    6484   ; //Wait RxACK bit in Status Register 
                    6485   ; WaitForI2C_RxACK();
00003968  4E93      6486          jsr       (A3)
                    6487   ; //Send data to Transmit register
                    6488   ; I2C_Transmit = AddressMSB;
0000396A  13C6 0040 6489          move.b    D6,4227078
0000396E  8006      
                    6490   ; //Set Control Register to start write
                    6491   ; I2C_Command = I2C_Slave_Write_Command;
00003970  13FC 0011 6492          move.b    #17,4227080
00003974  0040 8008 
                    6493   ; //Wait for TIP bit in Status Register 
                    6494   ; WaitForI2C_TIP();
00003978  4E92      6495          jsr       (A2)
                    6496   ; //Wait RxACK bit in Status Register 
                    6497   ; WaitForI2C_RxACK();
0000397A  4E93      6498          jsr       (A3)
                    6499   ; //////////////////////////////???//////////////////////////////
                    6500   ; //Send data to Transmit register
                    6501   ; I2C_Transmit = AddressLSB;
0000397C  13C5 0040 6502          move.b    D5,4227078
00003980  8006      
                    6503   ; //Set Control Register to start write
                    6504   ; I2C_Command = I2C_Slave_Write_Command;
00003982  13FC 0011 6505          move.b    #17,4227080
00003986  0040 8008 
                    6506   ; //Wait for TIP bit in Status Register 
                    6507   ; WaitForI2C_TIP();
0000398A  4E92      6508          jsr       (A2)
                    6509   ; //Wait RxACK bit in Status Register 
                    6510   ; WaitForI2C_RxACK();
0000398C  4E93      6511          jsr       (A3)
                    6512   ; //Send data to Transmit register
                    6513   ; I2C_Transmit = controlReadByte;
0000398E  13C3 0040 6514          move.b    D3,4227078
00003992  8006      
                    6515   ; //Set Control Register to start read
                    6516   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003994  13FC 0091 6517          move.b    #145,4227080
00003998  0040 8008 
                    6518   ; //Wait for TIP bit in Status Register 
                    6519   ; WaitForI2C_TIP();
0000399C  4E92      6520          jsr       (A2)
                    6521   ; //Wait RxACK bit in Status Register 
                    6522   ; WaitForI2C_RxACK();
0000399E  4E93      6523          jsr       (A3)
                    6524   ReadI2CSequential_6:
                    6525   ; }
                    6526   ; //Wait for TIP bit in Status Register 
                    6527   ; //Wait RxACK bit in Status Register 
                    6528   ; I2C_Command = I2C_Slave_Read_Command;
000039A0  13FC 0021 6529          move.b    #33,4227080
000039A4  0040 8008 
                    6530   ; WaitForI2C_TIP();
000039A8  4E92      6531          jsr       (A2)
                    6532   ; // WaitForI2C_RxACK();
                    6533   ; //poll for reading and clear after
                    6534   ; while((I2C_Status & 0x01) != 0x01) {
                    6535   ReadI2CSequential_8:
000039AA  1039 0040 6536          move.b    4227080,D0
000039AE  8008      
000039B0  C03C 0001 6537          and.b     #1,D0
000039B4  0C00 0001 6538          cmp.b     #1,D0
000039B8  6702      6539          beq.s     ReadI2CSequential_10
                    6540   ; // Do nothing and wait for I2C_Status[0] to become 1
                    6541   ; }   
000039BA  60EE      6542          bra       ReadI2CSequential_8
                    6543   ReadI2CSequential_10:
                    6544   ; // I2C_Status  &= ~(1<<0);
                    6545   ; //Grab data from Receive Register
                    6546   ; readData = I2C_Receive;
000039BC  1D79 0040 6547          move.b    4227078,-5(A6)
000039C0  8006 FFFB 
                    6548   ; printf("\r\nRead [%x] from Address[%x]", readData, ChipAddress);
000039C4  2F02      6549          move.l    D2,-(A7)
000039C6  122E FFFB 6550          move.b    -5(A6),D1
000039CA  C2BC 0000 6551          and.l     #255,D1
000039CE  00FF      
000039D0  2F01      6552          move.l    D1,-(A7)
000039D2  4879 0000 6553          pea       @iic_co~1_3.L
000039D6  665A      
000039D8  4EB9 0000 6554          jsr       _printf
000039DC  4084      
000039DE  DEFC 000C 6555          add.w     #12,A7
                    6556   ; ChipAddress++;
000039E2  5282      6557          addq.l    #1,D2
000039E4  5287      6558          addq.l    #1,D7
000039E6  6000 FF2A 6559          bra       ReadI2CSequential_3
                    6560   ReadI2CSequential_5:
                    6561   ; }
                    6562   ; I2C_Command = I2C_Slave_Read_Stop_Command;
000039EA  13FC 0069 6563          move.b    #105,4227080
000039EE  0040 8008 
                    6564   ; WaitForI2C_TIP();
000039F2  4E92      6565          jsr       (A2)
000039F4  4CDF 0CFC 6566          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
000039F8  4E5E      6567          unlk      A6
000039FA  4E75      6568          rts
                    6569   ; }
                    6570   ; void DACWrite(void) {
                    6571   _DACWrite:
000039FC  48E7 3830 6572          movem.l   D2/D3/D4/A2/A3,-(A7)
00003A00  45F8 33BA 6573          lea       _WaitForI2C_TIP.L,A2
00003A04  47F8 33E0 6574          lea       _WaitForI2C_RxACK.L,A3
                    6575   ; int i;
                    6576   ; unsigned int delay = 0xFFFFF;
00003A08  283C 000F 6577          move.l    #1048575,D4
00003A0C  FFFF      
                    6578   ; unsigned int val;
                    6579   ; printf("\nI2C DAC Write: Please check LED\n");
00003A0E  4879 0000 6580          pea       @iic_co~1_4.L
00003A12  6678      
00003A14  4EB9 0000 6581          jsr       _printf
00003A18  4084      
00003A1A  584F      6582          addq.w    #4,A7
                    6583   ; //Wait for TIP bit in Status Register 
                    6584   ; WaitForI2C_TIP();
00003A1C  4E92      6585          jsr       (A2)
                    6586   ; //Send data to Transmit register
                    6587   ; I2C_Transmit = ADC_DAC_WRITE_ADDRESS;
00003A1E  13FC 0092 6588          move.b    #146,4227078
00003A22  0040 8006 
                    6589   ; //Set Command register
                    6590   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003A26  13FC 0091 6591          move.b    #145,4227080
00003A2A  0040 8008 
                    6592   ; //Wait for TIP bit in Status Register 
                    6593   ; WaitForI2C_TIP();
00003A2E  4E92      6594          jsr       (A2)
                    6595   ; //Wait RxACK bit in Status Register 
                    6596   ; WaitForI2C_RxACK();
00003A30  4E93      6597          jsr       (A3)
                    6598   ; //Send data to Transmit register
                    6599   ; I2C_Transmit = DAC_ENABLE_COMMAND;
00003A32  13FC 0040 6600          move.b    #64,4227078
00003A36  0040 8006 
                    6601   ; //Set Command register
                    6602   ; I2C_Command = I2C_Slave_Write_Command;
00003A3A  13FC 0011 6603          move.b    #17,4227080
00003A3E  0040 8008 
                    6604   ; //Wait for TIP bit in Status Register 
                    6605   ; WaitForI2C_TIP();
00003A42  4E92      6606          jsr       (A2)
                    6607   ; //Wait RxACK bit in Status Register 
                    6608   ; WaitForI2C_RxACK();
00003A44  4E93      6609          jsr       (A3)
                    6610   ; //Send data to Transmit register
                    6611   ; I2C_Transmit = 0xFF;
00003A46  13FC 00FF 6612          move.b    #255,4227078
00003A4A  0040 8006 
                    6613   ; //Set Command register
                    6614   ; I2C_Command = I2C_Slave_Write_Command;
00003A4E  13FC 0011 6615          move.b    #17,4227080
00003A52  0040 8008 
                    6616   ; //Wait for TIP bit in Status Register 
                    6617   ; WaitForI2C_TIP();
00003A56  4E92      6618          jsr       (A2)
                    6619   ; //Wait RxACK bit in Status Register 
                    6620   ; WaitForI2C_RxACK();
00003A58  4E93      6621          jsr       (A3)
                    6622   ; while(1){
                    6623   DACWrite_1:
                    6624   ; val = 0xFF;
00003A5A  263C 0000 6625          move.l    #255,D3
00003A5E  00FF      
                    6626   ; //Send data to Transmit register
                    6627   ; I2C_Transmit = val;
00003A60  13C3 0040 6628          move.b    D3,4227078
00003A64  8006      
                    6629   ; //Set Command register
                    6630   ; I2C_Command = I2C_Slave_Write_Command;
00003A66  13FC 0011 6631          move.b    #17,4227080
00003A6A  0040 8008 
                    6632   ; //Wait for TIP bit in Status Register 
                    6633   ; WaitForI2C_TIP();
00003A6E  4E92      6634          jsr       (A2)
                    6635   ; //Wait RxACK bit in Status Register 
                    6636   ; WaitForI2C_RxACK();
00003A70  4E93      6637          jsr       (A3)
                    6638   ; //Add a delay
                    6639   ; for(i = 0; i < delay; i++);
00003A72  4282      6640          clr.l     D2
                    6641   DACWrite_4:
00003A74  B484      6642          cmp.l     D4,D2
00003A76  6404      6643          bhs.s     DACWrite_6
00003A78  5282      6644          addq.l    #1,D2
00003A7A  60F8      6645          bra       DACWrite_4
                    6646   DACWrite_6:
                    6647   ; val = 0x00;
00003A7C  4283      6648          clr.l     D3
                    6649   ; //Send data to Transmit register
                    6650   ; I2C_Transmit = val;
00003A7E  13C3 0040 6651          move.b    D3,4227078
00003A82  8006      
                    6652   ; //Set Command register
                    6653   ; I2C_Command = I2C_Slave_Write_Command;
00003A84  13FC 0011 6654          move.b    #17,4227080
00003A88  0040 8008 
                    6655   ; //Wait for TIP bit in Status Register 
                    6656   ; WaitForI2C_TIP();
00003A8C  4E92      6657          jsr       (A2)
                    6658   ; //Wait RxACK bit in Status Register 
                    6659   ; WaitForI2C_RxACK();
00003A8E  4E93      6660          jsr       (A3)
                    6661   ; //Add a delay
                    6662   ; for(i = 0; i < delay; i++);
00003A90  4282      6663          clr.l     D2
                    6664   DACWrite_7:
00003A92  B484      6665          cmp.l     D4,D2
00003A94  6404      6666          bhs.s     DACWrite_9
00003A96  5282      6667          addq.l    #1,D2
00003A98  60F8      6668          bra       DACWrite_7
                    6669   DACWrite_9:
00003A9A  60BE      6670          bra       DACWrite_1
                    6671   ; }
                    6672   ; }
                    6673   ; void ADCWrite(void){
                    6674   _ADCWrite:
00003A9C  4E56 FFFC 6675          link      A6,#-4
00003AA0  48E7 3038 6676          movem.l   D2/D3/A2/A3/A4,-(A7)
00003AA4  45F8 33BA 6677          lea       _WaitForI2C_TIP.L,A2
00003AA8  47F9 0000 6678          lea       _printf.L,A3
00003AAC  4084      
00003AAE  49F8 33E0 6679          lea       _WaitForI2C_RxACK.L,A4
                    6680   ; int i;
                    6681   ; unsigned char c;
                    6682   ; unsigned int delay = 0xFFFFF;
00003AB2  2D7C 000F 6683          move.l    #1048575,-4(A6)
00003AB6  FFFF FFFC 
                    6684   ; printf("I2C ADC Read:\n");
00003ABA  4879 0000 6685          pea       @iic_co~1_5.L
00003ABE  669A      
00003AC0  4E93      6686          jsr       (A3)
00003AC2  584F      6687          addq.w    #4,A7
                    6688   ; while(1){
                    6689   ADCWrite_1:
                    6690   ; printf("\n==============================Measuring==============================\n");
00003AC4  4879 0000 6691          pea       @iic_co~1_6.L
00003AC8  66AA      
00003ACA  4E93      6692          jsr       (A3)
00003ACC  584F      6693          addq.w    #4,A7
                    6694   ; //Wait for TIP bit in Status Register 
                    6695   ; WaitForI2C_TIP();
00003ACE  4E92      6696          jsr       (A2)
                    6697   ; //Send data to Transmit register
                    6698   ; I2C_Transmit = ADC_DAC_WRITE_ADDRESS;
00003AD0  13FC 0092 6699          move.b    #146,4227078
00003AD4  0040 8006 
                    6700   ; //Set Command register
                    6701   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003AD8  13FC 0091 6702          move.b    #145,4227080
00003ADC  0040 8008 
                    6703   ; //Wait for TIP bit in Status Register 
                    6704   ; WaitForI2C_TIP();
00003AE0  4E92      6705          jsr       (A2)
                    6706   ; //Wait RxACK bit in Status Register 
                    6707   ; WaitForI2C_RxACK();
00003AE2  4E94      6708          jsr       (A4)
                    6709   ; //Send data to Transmit register
                    6710   ; I2C_Transmit = ADC_ENABLE_COMMAND;
00003AE4  13FC 0044 6711          move.b    #68,4227078
00003AE8  0040 8006 
                    6712   ; //Set Command register
                    6713   ; I2C_Command = I2C_Slave_Write_Command;
00003AEC  13FC 0011 6714          move.b    #17,4227080
00003AF0  0040 8008 
                    6715   ; //Wait for TIP bit in Status Register 
                    6716   ; WaitForI2C_TIP();
00003AF4  4E92      6717          jsr       (A2)
                    6718   ; //Wait RxACK bit in Status Register 
                    6719   ; WaitForI2C_RxACK();
00003AF6  4E94      6720          jsr       (A4)
                    6721   ; //Send data to Transmit register
                    6722   ; I2C_Transmit = ADC_READ_ADDRESS;
00003AF8  13FC 0093 6723          move.b    #147,4227078
00003AFC  0040 8006 
                    6724   ; //Set Command register
                    6725   ; I2C_Command = I2C_Slave_Write_Start_Command;
00003B00  13FC 0091 6726          move.b    #145,4227080
00003B04  0040 8008 
                    6727   ; //Wait for TIP bit in Status Register 
                    6728   ; WaitForI2C_TIP();
00003B08  4E92      6729          jsr       (A2)
                    6730   ; //Wait RxACK bit in Status Register 
                    6731   ; WaitForI2C_RxACK();
00003B0A  4E94      6732          jsr       (A4)
                    6733   ; //Set Command register to skip
                    6734   ; I2C_Command = I2C_Slave_Read_Command;
00003B0C  13FC 0021 6735          move.b    #33,4227080
00003B10  0040 8008 
                    6736   ; //Wait for TIP bit in Status Register 
                    6737   ; WaitForI2C_TIP();
00003B14  4E92      6738          jsr       (A2)
                    6739   ; //Set Command register to skip
                    6740   ; I2C_Command = I2C_Slave_Read_Command;
00003B16  13FC 0021 6741          move.b    #33,4227080
00003B1A  0040 8008 
                    6742   ; //Wait for TIP bit in Status Register 
                    6743   ; WaitForI2C_TIP();
00003B1E  4E92      6744          jsr       (A2)
                    6745   ; //Grabbing read data from Receive Register for Thermistor
                    6746   ; c = I2C_Receive;
00003B20  1439 0040 6747          move.b    4227078,D2
00003B24  8006      
                    6748   ; printf("Value of Thermistor: %d\n", c);
00003B26  C4BC 0000 6749          and.l     #255,D2
00003B2A  00FF      
00003B2C  2F02      6750          move.l    D2,-(A7)
00003B2E  4879 0000 6751          pea       @iic_co~1_7.L
00003B32  66F2      
00003B34  4E93      6752          jsr       (A3)
00003B36  504F      6753          addq.w    #8,A7
                    6754   ; //Set Command register to skip
                    6755   ; I2C_Command = I2C_Slave_Read_Command;
00003B38  13FC 0021 6756          move.b    #33,4227080
00003B3C  0040 8008 
                    6757   ; //Wait for TIP bit in Status Register 
                    6758   ; WaitForI2C_TIP();
00003B40  4E92      6759          jsr       (A2)
                    6760   ; //Grabbing read data from Receive Register for Potentiometer
                    6761   ; c = I2C_Receive;
00003B42  1439 0040 6762          move.b    4227078,D2
00003B46  8006      
                    6763   ; printf("Value of Potentiometer: %d\n", c);
00003B48  C4BC 0000 6764          and.l     #255,D2
00003B4C  00FF      
00003B4E  2F02      6765          move.l    D2,-(A7)
00003B50  4879 0000 6766          pea       @iic_co~1_8.L
00003B54  670C      
00003B56  4E93      6767          jsr       (A3)
00003B58  504F      6768          addq.w    #8,A7
                    6769   ; //Set Command register to skip
                    6770   ; I2C_Command = I2C_Slave_Read_Command;
00003B5A  13FC 0021 6771          move.b    #33,4227080
00003B5E  0040 8008 
                    6772   ; //Wait for TIP bit in Status Register 
                    6773   ; WaitForI2C_TIP();
00003B62  4E92      6774          jsr       (A2)
                    6775   ; //Grabbing read data from Receive Register for Photo-resister
                    6776   ; c = I2C_Receive;
00003B64  1439 0040 6777          move.b    4227078,D2
00003B68  8006      
                    6778   ; printf("Value of Photo-resister: %d\n", c);
00003B6A  C4BC 0000 6779          and.l     #255,D2
00003B6E  00FF      
00003B70  2F02      6780          move.l    D2,-(A7)
00003B72  4879 0000 6781          pea       @iic_co~1_9.L
00003B76  6728      
00003B78  4E93      6782          jsr       (A3)
00003B7A  504F      6783          addq.w    #8,A7
                    6784   ; //Add a delay
                    6785   ; for(i = 0; i < delay; i++);
00003B7C  4283      6786          clr.l     D3
                    6787   ADCWrite_4:
00003B7E  B6AE FFFC 6788          cmp.l     -4(A6),D3
00003B82  6404      6789          bhs.s     ADCWrite_6
00003B84  5283      6790          addq.l    #1,D3
00003B86  60F6      6791          bra       ADCWrite_4
                    6792   ADCWrite_6:
00003B88  6000 FF3A 6793          bra       ADCWrite_1
                    6794   ; }
                    6795   ; }
                    6796   ; C:\CPEN412\ASN3\SPI_CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    6797   ; /*************************************************************
                    6798   ; ** SPI Controller registers
                    6799   ; **************************************************************/
                    6800   ; // SPI Registers
                    6801   ; #define SPI_Control (*(volatile unsigned char *)(0x00408020))
                    6802   ; #define SPI_Status (*(volatile unsigned char *)(0x00408022))
                    6803   ; #define SPI_Data (*(volatile unsigned char *)(0x00408024))
                    6804   ; #define SPI_Ext (*(volatile unsigned char *)(0x00408026))
                    6805   ; #define SPI_CS (*(volatile unsigned char *)(0x00408028))
                    6806   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                    6807   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                    6808   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                    6809   ; // and write FF to disable it
                    6810   ; #define Enable_SPI_CS() SPI_CS = 0xFE
                    6811   ; #define Disable_SPI_CS() SPI_CS = 0xFF
                    6812   ; /******************************************************************************************
                    6813   ; ** The following code is for the SPI controller
                    6814   ; *******************************************************************************************/
                    6815   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    6816   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    6817   ; int TestForSPITransmitDataComplete(void) {
                    6818   _TestForSPITransmitDataComplete:
00003B8C  2F02      6819          move.l    D2,-(A7)
                    6820   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    6821   ; int status_bit = (SPI_Status >> 7) & 0x01;      //Used bit-shift to read Bit 7 of the SPI_Status (SPIF)
00003B8E  1039 0040 6822          move.b    4227106,D0
00003B92  8022      
00003B94  C0BC 0000 6823          and.l     #255,D0
00003B98  00FF      
00003B9A  EE88      6824          lsr.l     #7,D0
00003B9C  C0BC 0000 6825          and.l     #1,D0
00003BA0  0001      
00003BA2  2400      6826          move.l    D0,D2
                    6827   ; //Return 1 if SPIF = 1, Return 0 if SPIF = 0 or others
                    6828   ; if(status_bit == 1)
00003BA4  0C82 0000 6829          cmp.l     #1,D2
00003BA8  0001      
00003BAA  6604      6830          bne.s     TestForSPITransmitDataComplete_1
                    6831   ; return 1;
00003BAC  7001      6832          moveq     #1,D0
00003BAE  600A      6833          bra.s     TestForSPITransmitDataComplete_3
                    6834   TestForSPITransmitDataComplete_1:
                    6835   ; else if (status_bit == 0)
00003BB0  4A82      6836          tst.l     D2
00003BB2  6604      6837          bne.s     TestForSPITransmitDataComplete_4
                    6838   ; return 0;
00003BB4  4280      6839          clr.l     D0
00003BB6  6002      6840          bra.s     TestForSPITransmitDataComplete_3
                    6841   TestForSPITransmitDataComplete_4:
                    6842   ; else
                    6843   ; return 0;
00003BB8  4280      6844          clr.l     D0
                    6845   TestForSPITransmitDataComplete_3:
00003BBA  241F      6846          move.l    (A7)+,D2
00003BBC  4E75      6847          rts
                    6848   ; }
                    6849   ; /************************************************************************************
                    6850   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    6851   ; ************************************************************************************/
                    6852   ; void SPI_Init(void)
                    6853   ; {
                    6854   _SPI_Init:
                    6855   ; //TODO
                    6856   ; //
                    6857   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    6858   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    6859   ; //
                    6860   ; // Here are some settings we want to create
                    6861   ; //
                    6862   ; // Control Reg - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed = divide by 32 = approx 700Khz
                    6863   ; // Ext Reg - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    6864   ; // SPI_CS Reg - control selection of slave SPI chips via their CS# signals
                    6865   ; // Status Reg - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    6866   ; // SPI_CS Reg - control selection of slave SPI chips via their CS# signals
                    6867   ; Enable_SPI_CS();                        //1111 1110       PROBABLY DONT NEED, LEAVE IT FOR NOW, UNCOMMENT IF WRONG BEHAVIOUR
00003BBE  13FC 00FE 6868          move.b    #254,4227112
00003BC2  0040 8028 
                    6869   ; // Control Reg - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed = divide by 32 = approx 700Khz
                    6870   ; SPI_Control = (unsigned char) 0x53;     //01_1 0011
00003BC6  13FC 0053 6871          move.b    #83,4227104
00003BCA  0040 8020 
                    6872   ; // Ext Reg - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    6873   ; SPI_Ext = (unsigned char) 0x0;          //00__ __00
00003BCE  4239 0040 6874          clr.b     4227110
00003BD2  8026      
                    6875   ; // Status Reg - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    6876   ; SPI_Status = (unsigned char) 0xC0;      //1100 0000
00003BD4  13FC 00C0 6877          move.b    #192,4227106
00003BD8  0040 8022 
                    6878   ; //Disable SPI_CS after every command
                    6879   ; Disable_SPI_CS();                       //1111 1111
00003BDC  13FC 00FF 6880          move.b    #255,4227112
00003BE0  0040 8028 
                    6881   ; return;
00003BE4  4E75      6882          rts
                    6883   ; }
                    6884   ; /************************************************************************************
                    6885   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    6886   ; ************************************************************************************/
                    6887   ; void WaitForSPITransmitComplete(void)
                    6888   ; {
                    6889   _WaitForSPITransmitComplete:
00003BE6  4E56 FFFC 6890          link      A6,#-4
                    6891   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    6892   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    6893   ; // just in case they were set
                    6894   ; int status_bit;
                    6895   ; do{
                    6896   WaitForSPITransmitComplete_1:
                    6897   ; status_bit = (SPI_Status >> 7) & 0x01; 
00003BEA  1039 0040 6898          move.b    4227106,D0
00003BEE  8022      
00003BF0  C0BC 0000 6899          and.l     #255,D0
00003BF4  00FF      
00003BF6  EE88      6900          lsr.l     #7,D0
00003BF8  C0BC 0000 6901          and.l     #1,D0
00003BFC  0001      
00003BFE  2D40 FFFC 6902          move.l    D0,-4(A6)
00003C02  202E FFFC 6903          move.l    -4(A6),D0
00003C06  0C80 0000 6904          cmp.l     #1,D0
00003C0A  0001      
00003C0C  66DC      6905          bne       WaitForSPITransmitComplete_1
                    6906   ; }while( status_bit != 1);
                    6907   ; SPI_Status = (unsigned char) 0xC0;      //1100 0000
00003C0E  13FC 00C0 6908          move.b    #192,4227106
00003C12  0040 8022 
                    6909   ; return;
00003C16  4E5E      6910          unlk      A6
00003C18  4E75      6911          rts
                    6912   ; }
                    6913   ; /************************************************************************************
                    6914   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    6915   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    6916   ; ************************************************************************************/
                    6917   ; unsigned char WriteSPIChar(unsigned char c)
                    6918   ; {
                    6919   _WriteSPIChar:
00003C1A  4E56 0000 6920          link      A6,#0
                    6921   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    6922   ; // wait for completion of transmission
                    6923   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    6924   ; // by reading fom the SPI controller Data Register.
                    6925   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    6926   ; //
                    6927   ; // modify '0' below to return back read byte from data register
                    6928   ; //
                    6929   ; SPI_Data = c;
00003C1E  13EE 000B 6930          move.b    11(A6),4227108
00003C22  0040 8024 
                    6931   ; WaitForSPITransmitComplete();
00003C26  4EB8 3BE6 6932          jsr       _WaitForSPITransmitComplete
                    6933   ; return SPI_Data;
00003C2A  1039 0040 6934          move.b    4227108,D0
00003C2E  8024      
00003C30  4E5E      6935          unlk      A6
00003C32  4E75      6936          rts
                    6937   ; }
                    6938   ; void EraseSPIFlashChip(void)
                    6939   ; {
                    6940   _EraseSPIFlashChip:
00003C34  2F0A      6941          move.l    A2,-(A7)
00003C36  45F8 3C1A 6942          lea       _WriteSPIChar.L,A2
                    6943   ; Enable_SPI_CS();
00003C3A  13FC 00FE 6944          move.b    #254,4227112
00003C3E  0040 8028 
                    6945   ; WriteSPIChar(0x06); //Enabling the Device for Writing/Erasing
00003C42  4878 0006 6946          pea       6
00003C46  4E92      6947          jsr       (A2)
00003C48  584F      6948          addq.w    #4,A7
                    6949   ; Disable_SPI_CS();
00003C4A  13FC 00FF 6950          move.b    #255,4227112
00003C4E  0040 8028 
                    6951   ; Enable_SPI_CS();
00003C52  13FC 00FE 6952          move.b    #254,4227112
00003C56  0040 8028 
                    6953   ; WriteSPIChar(0x60); //Erasing the chip or 0x60?
00003C5A  4878 0060 6954          pea       96
00003C5E  4E92      6955          jsr       (A2)
00003C60  584F      6956          addq.w    #4,A7
                    6957   ; Disable_SPI_CS();
00003C62  13FC 00FF 6958          move.b    #255,4227112
00003C66  0040 8028 
                    6959   ; Enable_SPI_CS();
00003C6A  13FC 00FE 6960          move.b    #254,4227112
00003C6E  0040 8028 
                    6961   ; WriteSPIChar(0x05); //Polling for completion of commands in the Flash Memory chip
00003C72  4878 0005 6962          pea       5
00003C76  4E92      6963          jsr       (A2)
00003C78  584F      6964          addq.w    #4,A7
                    6965   ; while(WriteSPIChar(0xEE) & 1){}; //Using random data to write and test until we get an idle response back
                    6966   EraseSPIFlashChip_1:
00003C7A  4878 00EE 6967          pea       238
00003C7E  4E92      6968          jsr       (A2)
00003C80  584F      6969          addq.w    #4,A7
00003C82  C03C 0001 6970          and.b     #1,D0
00003C86  6702      6971          beq.s     EraseSPIFlashChip_3
00003C88  60F0      6972          bra       EraseSPIFlashChip_1
                    6973   EraseSPIFlashChip_3:
                    6974   ; Disable_SPI_CS();
00003C8A  13FC 00FF 6975          move.b    #255,4227112
00003C8E  0040 8028 
                    6976   ; return;
00003C92  245F      6977          move.l    (A7)+,A2
00003C94  4E75      6978          rts
                    6979   ; }
                    6980   ; void WriteSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size)
                    6981   ; {
                    6982   _WriteSPIFlashData:
00003C96  4E56 0000 6983          link      A6,#0
00003C9A  48E7 3820 6984          movem.l   D2/D3/D4/A2,-(A7)
00003C9E  45F8 3C1A 6985          lea       _WriteSPIChar.L,A2
00003CA2  242E 0008 6986          move.l    8(A6),D2
                    6987   ; int count;
                    6988   ; int w_count;
                    6989   ; for(count = 0; count < 1000; count++){
00003CA6  4284      6990          clr.l     D4
                    6991   WriteSPIFlashData_1:
00003CA8  0C84 0000 6992          cmp.l     #1000,D4
00003CAC  03E8      
00003CAE  6C00 00CA 6993          bge       WriteSPIFlashData_3
                    6994   ; Enable_SPI_CS();
00003CB2  13FC 00FE 6995          move.b    #254,4227112
00003CB6  0040 8028 
                    6996   ; WriteSPIChar(0x06); //Enabling the Device for Writing/Erasing
00003CBA  4878 0006 6997          pea       6
00003CBE  4E92      6998          jsr       (A2)
00003CC0  584F      6999          addq.w    #4,A7
                    7000   ; Disable_SPI_CS();
00003CC2  13FC 00FF 7001          move.b    #255,4227112
00003CC6  0040 8028 
                    7002   ; Enable_SPI_CS();
00003CCA  13FC 00FE 7003          move.b    #254,4227112
00003CCE  0040 8028 
                    7004   ; WriteSPIChar(0x02);
00003CD2  4878 0002 7005          pea       2
00003CD6  4E92      7006          jsr       (A2)
00003CD8  584F      7007          addq.w    #4,A7
                    7008   ; WriteSPIChar((FlashAddress >> 16)&0xFF);
00003CDA  2202      7009          move.l    D2,D1
00003CDC  E081      7010          asr.l     #8,D1
00003CDE  E081      7011          asr.l     #8,D1
00003CE0  C2BC 0000 7012          and.l     #255,D1
00003CE4  00FF      
00003CE6  C2BC 0000 7013          and.l     #255,D1
00003CEA  00FF      
00003CEC  2F01      7014          move.l    D1,-(A7)
00003CEE  4E92      7015          jsr       (A2)
00003CF0  584F      7016          addq.w    #4,A7
                    7017   ; WriteSPIChar((FlashAddress >> 8)&0xFF);
00003CF2  2202      7018          move.l    D2,D1
00003CF4  E081      7019          asr.l     #8,D1
00003CF6  C2BC 0000 7020          and.l     #255,D1
00003CFA  00FF      
00003CFC  C2BC 0000 7021          and.l     #255,D1
00003D00  00FF      
00003D02  2F01      7022          move.l    D1,-(A7)
00003D04  4E92      7023          jsr       (A2)
00003D06  584F      7024          addq.w    #4,A7
                    7025   ; WriteSPIChar(FlashAddress & 0x00);
00003D08  2202      7026          move.l    D2,D1
00003D0A  C2BC 0000 7027          and.l     #0,D1
00003D0E  0000      
00003D10  C2BC 0000 7028          and.l     #255,D1
00003D14  00FF      
00003D16  2F01      7029          move.l    D1,-(A7)
00003D18  4E92      7030          jsr       (A2)
00003D1A  584F      7031          addq.w    #4,A7
                    7032   ; for(w_count = 0;w_count<256;w_count++){
00003D1C  4283      7033          clr.l     D3
                    7034   WriteSPIFlashData_4:
00003D1E  0C83 0000 7035          cmp.l     #256,D3
00003D22  0100      
00003D24  6C1A      7036          bge.s     WriteSPIFlashData_6
                    7037   ; WriteSPIChar(*MemoryAddress);
00003D26  206E 000C 7038          move.l    12(A6),A0
00003D2A  1210      7039          move.b    (A0),D1
00003D2C  C2BC 0000 7040          and.l     #255,D1
00003D30  00FF      
00003D32  2F01      7041          move.l    D1,-(A7)
00003D34  4E92      7042          jsr       (A2)
00003D36  584F      7043          addq.w    #4,A7
                    7044   ; MemoryAddress++;
00003D38  52AE 000C 7045          addq.l    #1,12(A6)
00003D3C  5283      7046          addq.l    #1,D3
00003D3E  60DE      7047          bra       WriteSPIFlashData_4
                    7048   WriteSPIFlashData_6:
                    7049   ; }
                    7050   ; Disable_SPI_CS();
00003D40  13FC 00FF 7051          move.b    #255,4227112
00003D44  0040 8028 
                    7052   ; Enable_SPI_CS();
00003D48  13FC 00FE 7053          move.b    #254,4227112
00003D4C  0040 8028 
                    7054   ; WriteSPIChar(0x05);
00003D50  4878 0005 7055          pea       5
00003D54  4E92      7056          jsr       (A2)
00003D56  584F      7057          addq.w    #4,A7
                    7058   ; while(WriteSPIChar(0xFF));
                    7059   WriteSPIFlashData_7:
00003D58  4878 00FF 7060          pea       255
00003D5C  4E92      7061          jsr       (A2)
00003D5E  584F      7062          addq.w    #4,A7
00003D60  4A00      7063          tst.b     D0
00003D62  6702      7064          beq.s     WriteSPIFlashData_9
00003D64  60F2      7065          bra       WriteSPIFlashData_7
                    7066   WriteSPIFlashData_9:
                    7067   ; Disable_SPI_CS();
00003D66  13FC 00FF 7068          move.b    #255,4227112
00003D6A  0040 8028 
                    7069   ; FlashAddress = FlashAddress + 256;
00003D6E  0682 0000 7070          add.l     #256,D2
00003D72  0100      
00003D74  5284      7071          addq.l    #1,D4
00003D76  6000 FF30 7072          bra       WriteSPIFlashData_1
                    7073   WriteSPIFlashData_3:
                    7074   ; }
                    7075   ; return;
00003D7A  4CDF 041C 7076          movem.l   (A7)+,D2/D3/D4/A2
00003D7E  4E5E      7077          unlk      A6
00003D80  4E75      7078          rts
                    7079   ; }
                    7080   ; void ReadSPIFlashData( int FlashAddress, unsigned char *MemoryAddress, int size)
                    7081   ; {
                    7082   _ReadSPIFlashData:
00003D82  4E56 FFFC 7083          link      A6,#-4
00003D86  48E7 2020 7084          movem.l   D2/A2,-(A7)
00003D8A  45F8 3C1A 7085          lea       _WriteSPIChar.L,A2
00003D8E  242E 0008 7086          move.l    8(A6),D2
                    7087   ; int value;
                    7088   ; Enable_SPI_CS();
00003D92  13FC 00FE 7089          move.b    #254,4227112
00003D96  0040 8028 
                    7090   ; WriteSPIChar(0x03);
00003D9A  4878 0003 7091          pea       3
00003D9E  4E92      7092          jsr       (A2)
00003DA0  584F      7093          addq.w    #4,A7
                    7094   ; WriteSPIChar((FlashAddress >> 16)&0xFF);
00003DA2  2202      7095          move.l    D2,D1
00003DA4  E081      7096          asr.l     #8,D1
00003DA6  E081      7097          asr.l     #8,D1
00003DA8  C2BC 0000 7098          and.l     #255,D1
00003DAC  00FF      
00003DAE  C2BC 0000 7099          and.l     #255,D1
00003DB2  00FF      
00003DB4  2F01      7100          move.l    D1,-(A7)
00003DB6  4E92      7101          jsr       (A2)
00003DB8  584F      7102          addq.w    #4,A7
                    7103   ; WriteSPIChar((FlashAddress >> 8)&0xFF);
00003DBA  2202      7104          move.l    D2,D1
00003DBC  E081      7105          asr.l     #8,D1
00003DBE  C2BC 0000 7106          and.l     #255,D1
00003DC2  00FF      
00003DC4  C2BC 0000 7107          and.l     #255,D1
00003DC8  00FF      
00003DCA  2F01      7108          move.l    D1,-(A7)
00003DCC  4E92      7109          jsr       (A2)
00003DCE  584F      7110          addq.w    #4,A7
                    7111   ; WriteSPIChar(FlashAddress & 0xFF);
00003DD0  2202      7112          move.l    D2,D1
00003DD2  C2BC 0000 7113          and.l     #255,D1
00003DD6  00FF      
00003DD8  C2BC 0000 7114          and.l     #255,D1
00003DDC  00FF      
00003DDE  2F01      7115          move.l    D1,-(A7)
00003DE0  4E92      7116          jsr       (A2)
00003DE2  584F      7117          addq.w    #4,A7
                    7118   ; value = WriteSPIChar(0xFF);
00003DE4  4878 00FF 7119          pea       255
00003DE8  4E92      7120          jsr       (A2)
00003DEA  584F      7121          addq.w    #4,A7
00003DEC  C0BC 0000 7122          and.l     #255,D0
00003DF0  00FF      
00003DF2  2D40 FFFC 7123          move.l    D0,-4(A6)
                    7124   ; /*for(count=0;count<size;count++){
                    7125   ; *MemoryAddress = WriteSPIChar(0xFF);
                    7126   ; MemoryAddress++; 
                    7127   ; }*/
                    7128   ; Disable_SPI_CS();
00003DF6  13FC 00FF 7129          move.b    #255,4227112
00003DFA  0040 8028 
                    7130   ; return;
00003DFE  4CDF 0404 7131          movem.l   (A7)+,D2/A2
00003E02  4E5E      7132          unlk      A6
00003E04  4E75      7133          rts
                    7134   ; }
                    7135   ; unsigned char ReadSPIFlashByte( int FlashAddress)
                    7136   ; {
                    7137   _ReadSPIFlashByte:
00003E06  4E56 FFFC 7138          link      A6,#-4
00003E0A  48E7 2020 7139          movem.l   D2/A2,-(A7)
00003E0E  45F8 3C1A 7140          lea       _WriteSPIChar.L,A2
00003E12  242E 0008 7141          move.l    8(A6),D2
                    7142   ; unsigned char value;
                    7143   ; Enable_SPI_CS();
00003E16  13FC 00FE 7144          move.b    #254,4227112
00003E1A  0040 8028 
                    7145   ; WriteSPIChar(0x03);
00003E1E  4878 0003 7146          pea       3
00003E22  4E92      7147          jsr       (A2)
00003E24  584F      7148          addq.w    #4,A7
                    7149   ; WriteSPIChar((FlashAddress >> 16)&0xFF);
00003E26  2202      7150          move.l    D2,D1
00003E28  E081      7151          asr.l     #8,D1
00003E2A  E081      7152          asr.l     #8,D1
00003E2C  C2BC 0000 7153          and.l     #255,D1
00003E30  00FF      
00003E32  C2BC 0000 7154          and.l     #255,D1
00003E36  00FF      
00003E38  2F01      7155          move.l    D1,-(A7)
00003E3A  4E92      7156          jsr       (A2)
00003E3C  584F      7157          addq.w    #4,A7
                    7158   ; WriteSPIChar((FlashAddress >> 8)&0xFF);
00003E3E  2202      7159          move.l    D2,D1
00003E40  E081      7160          asr.l     #8,D1
00003E42  C2BC 0000 7161          and.l     #255,D1
00003E46  00FF      
00003E48  C2BC 0000 7162          and.l     #255,D1
00003E4C  00FF      
00003E4E  2F01      7163          move.l    D1,-(A7)
00003E50  4E92      7164          jsr       (A2)
00003E52  584F      7165          addq.w    #4,A7
                    7166   ; WriteSPIChar(FlashAddress & 0xFF);
00003E54  2202      7167          move.l    D2,D1
00003E56  C2BC 0000 7168          and.l     #255,D1
00003E5A  00FF      
00003E5C  C2BC 0000 7169          and.l     #255,D1
00003E60  00FF      
00003E62  2F01      7170          move.l    D1,-(A7)
00003E64  4E92      7171          jsr       (A2)
00003E66  584F      7172          addq.w    #4,A7
                    7173   ; value = WriteSPIChar(0xFF);
00003E68  4878 00FF 7174          pea       255
00003E6C  4E92      7175          jsr       (A2)
00003E6E  584F      7176          addq.w    #4,A7
00003E70  1D40 FFFF 7177          move.b    D0,-1(A6)
                    7178   ; Disable_SPI_CS();
00003E74  13FC 00FF 7179          move.b    #255,4227112
00003E78  0040 8028 
                    7180   ; return value;
00003E7C  102E FFFF 7181          move.b    -1(A6),D0
00003E80  4CDF 0404 7182          movem.l   (A7)+,D2/A2
00003E84  4E5E      7183          unlk      A6
00003E86  4E75      7184          rts
                    7185   ; }
                    7186   _strcpy:
00003E88  206F 0004 7187          move.l    (4,A7),A0
00003E8C  226F 0008 7188          move.l    (8,A7),A1
00003E90  2008      7189          move.l    A0,D0
                    7190   strcpy_1:
00003E92  10D9      7191          move.b    (A1)+,(A0)+
00003E94  66FC      7192          bne       strcpy_1
00003E96  4E75      7193          rts
                    7194   ULDIV:
00003E98  4E56 0000 7195          link    A6,#0
00003E9C  48E7 C000 7196          movem.l D0/D1,-(A7)
00003EA0  222E 0008 7197          move.l  8(A6),D1
00003EA4  202E 000C 7198          move.l  12(A6),D0
00003EA8  6036      7199          bra.s   ldiv_3
                    7200   LDIV:
00003EAA  4E56 0000 7201          link    A6,#0
00003EAE  48E7 C000 7202          movem.l D0/D1,-(A7)
00003EB2  222E 0008 7203          move.l  8(A6),D1
00003EB6  202E 000C 7204          move.l  12(A6),D0
00003EBA  4A80      7205          tst.l   D0
00003EBC  6A0E      7206          bpl.s   ldiv_1
00003EBE  4480      7207          neg.l   D0
00003EC0  4A81      7208          tst.l   D1
00003EC2  6A14      7209          bpl.s   ldiv_2
00003EC4  4481      7210          neg.l   D1
00003EC6  612A      7211          bsr.s   dodiv
00003EC8  4481      7212          neg.l   D1
00003ECA  6016      7213          bra.s   ldiv_4
                    7214   ldiv_1:
00003ECC  4A81      7215          tst.l   D1
00003ECE  6A10      7216          bpl.s   ldiv_3
00003ED0  4481      7217          neg.l   D1
00003ED2  611E      7218          bsr.s   dodiv
00003ED4  4480      7219          neg.l   D0
00003ED6  600A      7220          bra.s   ldiv_4
                    7221   ldiv_2:
00003ED8  6118      7222          bsr.s   dodiv
00003EDA  4480      7223          neg.l   D0
00003EDC  4481      7224          neg.l   D1
00003EDE  6002      7225          bra.s   ldiv_4
                    7226   ldiv_3:
00003EE0  6110      7227          bsr.s   dodiv
                    7228   ldiv_4:
00003EE2  2D40 0008 7229          move.l  D0,8(A6)
00003EE6  2D41 000C 7230          move.l  D1,12(A6)
00003EEA  4CDF 0003 7231          movem.l (A7)+,D0/D1
00003EEE  4E5E      7232          unlk    A6
00003EF0  4E75      7233          rts
                    7234   dodiv:
00003EF2  0C81 0000 7235          cmpi.l  #$FFFF,D1
00003EF6  FFFF      
00003EF8  6236      7236          bhi.s   dodiv_2
00003EFA  0C80 0000 7237          cmpi.l  #$FFFF,D0
00003EFE  FFFF      
00003F00  6210      7238          bhi.s   dodiv_1
00003F02  80C1      7239          divu    D1,D0
00003F04  2200      7240          move.l  D0,D1
00003F06  4241      7241          clr.w   D1
00003F08  4841      7242          swap    D1
00003F0A  0280 0000 7243          andi.l  #$FFFF,D0
00003F0E  FFFF      
00003F10  4E75      7244          rts
                    7245   dodiv_1:
00003F12  48A7 A000 7246          movem.w D0/D2,-(A7)
00003F16  4240      7247          clr.w   D0
00003F18  4840      7248          swap    D0
00003F1A  80C1      7249          divu    D1,D0
00003F1C  3400      7250          move.w  D0,D2
00003F1E  301F      7251          move.w  (A7)+,D0
00003F20  80C1      7252          divu    D1,D0
00003F22  4840      7253          swap    D0
00003F24  4281      7254          clr.l   D1
00003F26  3200      7255          move.w  D0,D1
00003F28  3002      7256          move.w  D2,D0
00003F2A  4840      7257          swap    D0
00003F2C  341F      7258          move.w  (A7)+,D2
00003F2E  4E75      7259          rts
                    7260   dodiv_2:
00003F30  48E7 3800 7261          movem.l D2/D3/D4,-(A7)
00003F34  2401      7262          move.l  D1,D2
00003F36  4242      7263          clr.w   D2
00003F38  4842      7264          swap    D2
00003F3A  5282      7265          addq.l  #1,D2
00003F3C  2600      7266          move.l  D0,D3
00003F3E  2801      7267          move.l  D1,D4
00003F40  2202      7268          move.l  D2,D1
00003F42  61CE      7269          bsr.s   dodiv_1
00003F44  2204      7270          move.l  D4,D1
00003F46  82C2      7271          divu    D2,D1
00003F48  80C1      7272          divu    D1,D0
00003F4A  0280 0000 7273          andi.l  #$FFFF,D0
00003F4E  FFFF      
                    7274   dodiv_3:
00003F50  2204      7275          move.l  D4,D1
00003F52  2404      7276          move.l  D4,D2
00003F54  4842      7277          swap    D2
00003F56  C2C0      7278          mulu    D0,D1
00003F58  C4C0      7279          mulu    D0,D2
00003F5A  4842      7280          swap    D2
00003F5C  D282      7281          add.l   D2,D1
00003F5E  9283      7282          sub.l   D3,D1
00003F60  620A      7283          bhi.s   dodiv_4
00003F62  4481      7284          neg.l   D1
00003F64  B881      7285          cmp.l   D1,D4
00003F66  6208      7286          bhi.s   dodiv_5
00003F68  5280      7287          addq.l  #1,D0
00003F6A  60E4      7288          bra.s   dodiv_3
                    7289   dodiv_4:
00003F6C  5380      7290          subq.l  #1,D0
00003F6E  60E0      7291          bra.s   dodiv_3
                    7292   dodiv_5:
00003F70  4CDF 001C 7293          movem.l (A7)+,D2/D3/D4
00003F74  4E75      7294          rts
                    7295   _putch:
00003F76  4E56 0000 7296          link      A6,#0
00003F7A  48E7 2000 7297          movem.l   D2,-(A7)
00003F7E  242E 0008 7298          move.l    8(A6),D2
00003F82  0C82 0000 7299          cmp.l     #10,D2
00003F86  000A      
00003F88  660A      7300          bne.s     putch_1
00003F8A  4878 000D 7301          pea       13
00003F8E  6100 CBAC 7302          bsr       __putch
00003F92  584F      7303          addq.w    #4,A7
                    7304   putch_1:
00003F94  2F02      7305          move.l    D2,-(A7)
00003F96  6100 CBA4 7306          bsr       __putch
00003F9A  584F      7307          addq.w    #4,A7
00003F9C  2002      7308          move.l    D2,D0
00003F9E  4CDF 0004 7309          movem.l   (A7)+,D2
00003FA2  4E5E      7310          unlk      A6
00003FA4  4E75      7311          rts
                    7312   _getch:
00003FA6  48E7 2000 7313          movem.l   D2,-(A7)
00003FAA  2439 0B00 7314          move.l    __ungetbuf,D2
00003FAE  00C0      
00003FB0  2039 0B00 7315          move.l    __ungetbuf,D0
00003FB4  00C0      
00003FB6  0C80 FFFF 7316          cmp.l     #-1,D0
00003FBA  FFFF      
00003FBC  670C      7317          beq.s     getch_1
00003FBE  23FC FFFF 7318          move.l    #-1,__ungetbuf
00003FC2  FFFF 0B00 
00003FC6  00C0      
00003FC8  6010      7319          bra.s     getch_3
                    7320   getch_1:
00003FCA  6100 CB9C 7321          bsr       __getch
00003FCE  2400      7322          move.l    D0,D2
00003FD0  0C80 0000 7323          cmp.l     #13,D0
00003FD4  000D      
00003FD6  6602      7324          bne.s     getch_3
00003FD8  740A      7325          moveq     #10,D2
                    7326   getch_3:
00003FDA  2002      7327          move.l    D2,D0
00003FDC  4CDF 0004 7328          movem.l   (A7)+,D2
00003FE0  4E75      7329          rts
                    7330   _tolower:
00003FE2  4E56 0000 7331          link      A6,#0
00003FE6  48E7 2000 7332          movem.l   D2,-(A7)
00003FEA  242E 0008 7333          move.l    8(A6),D2
00003FEE  0C82 0000 7334          cmp.l     #65,D2
00003FF2  0041      
00003FF4  6D0E      7335          blt.s     tolower_1
00003FF6  0C82 0000 7336          cmp.l     #90,D2
00003FFA  005A      
00003FFC  6E06      7337          bgt.s     tolower_1
00003FFE  84BC 0000 7338          or.l      #32,D2
00004002  0020      
                    7339   tolower_1:
00004004  2002      7340          move.l    D2,D0
00004006  4CDF 0004 7341          movem.l   (A7)+,D2
0000400A  4E5E      7342          unlk      A6
0000400C  4E75      7343          rts
                    7344   _sprintf:
0000400E  4E56 FFFC 7345          link      A6,#-4
00004012  48E7 2000 7346          movem.l   D2,-(A7)
00004016  41EE 000C 7347          lea       12(A6),A0
0000401A  5848      7348          addq.w    #4,A0
0000401C  2408      7349          move.l    A0,D2
0000401E  2F02      7350          move.l    D2,-(A7)
00004020  2F2E 000C 7351          move.l    12(A6),-(A7)
00004024  2F2E 0008 7352          move.l    8(A6),-(A7)
00004028  6100 013E 7353          bsr       _vsprintf
0000402C  DEFC 000C 7354          add.w     #12,A7
00004030  2D40 FFFC 7355          move.l    D0,-4(A6)
00004034  4282      7356          clr.l     D2
00004036  202E FFFC 7357          move.l    -4(A6),D0
0000403A  4CDF 0004 7358          movem.l   (A7)+,D2
0000403E  4E5E      7359          unlk      A6
00004040  4E75      7360          rts
                    7361   _strcat:
00004042  206F 0004 7362          move.l    (4,A7),A0	
00004046  226F 0008 7363          move.l    (8,A7),A1	
0000404A  2008      7364          move.l    A0,D0		
                    7365   strcat_0:
0000404C  4A18      7366          tst.b     (A0)+
0000404E  66FC      7367          bne       strcat_0
00004050  5348      7368          subq      #1,A0
                    7369   strcat_1:
00004052  10D9      7370          move.b    (A1)+,(A0)+
00004054  66FC      7371          bne       strcat_1
00004056  4E75      7372          rts
                    7373   _toupper:
00004058  4E56 0000 7374          link      A6,#0
0000405C  48E7 2000 7375          movem.l   D2,-(A7)
00004060  242E 0008 7376          move.l    8(A6),D2
00004064  0C82 0000 7377          cmp.l     #97,D2
00004068  0061      
0000406A  6D0E      7378          blt.s     toupper_1
0000406C  0C82 0000 7379          cmp.l     #122,D2
00004070  007A      
00004072  6E06      7380          bgt.s     toupper_1
00004074  C4BC 0000 7381          and.l     #95,D2
00004078  005F      
                    7382   toupper_1:
0000407A  2002      7383          move.l    D2,D0
0000407C  4CDF 0004 7384          movem.l   (A7)+,D2
00004080  4E5E      7385          unlk      A6
00004082  4E75      7386          rts
                    7387   _printf:
00004084  4E56 FFFC 7388          link      A6,#-4
00004088  48E7 2000 7389          movem.l   D2,-(A7)
0000408C  41EE 0008 7390          lea       8(A6),A0
00004090  5848      7391          addq.w    #4,A0
00004092  2408      7392          move.l    A0,D2
00004094  2F02      7393          move.l    D2,-(A7)
00004096  2F2E 0008 7394          move.l    8(A6),-(A7)
0000409A  42A7      7395          clr.l     -(A7)
0000409C  6100 00CA 7396          bsr       _vsprintf
000040A0  DEFC 000C 7397          add.w     #12,A7
000040A4  2D40 FFFC 7398          move.l    D0,-4(A6)
000040A8  4282      7399          clr.l     D2
000040AA  202E FFFC 7400          move.l    -4(A6),D0
000040AE  4CDF 0004 7401          movem.l   (A7)+,D2
000040B2  4E5E      7402          unlk      A6
000040B4  4E75      7403          rts
                    7404   @vsprintf_copy:
000040B6  4E56 0000 7405          link      A6,#0
000040BA  206E 0008 7406          move.l    8(A6),A0
000040BE  4A90      7407          tst.l     (A0)
000040C0  6710      7408          beq.s     @vsprintf_copy_1
000040C2  202E 000C 7409          move.l    12(A6),D0
000040C6  206E 0008 7410          move.l    8(A6),A0
000040CA  2250      7411          move.l    (A0),A1
000040CC  5290      7412          addq.l    #1,(A0)
000040CE  1280      7413          move.b    D0,(A1)
000040D0  600A      7414          bra.s     @vsprintf_copy_2
                    7415   @vsprintf_copy_1:
000040D2  2F2E 000C 7416          move.l    12(A6),-(A7)
000040D6  6100 FE9E 7417          bsr       _putch
000040DA  584F      7418          addq.w    #4,A7
                    7419   @vsprintf_copy_2:
000040DC  4E5E      7420          unlk      A6
000040DE  4E75      7421          rts
                    7422   @vsprintf_getval:
000040E0  4E56 0000 7423          link      A6,#0
000040E4  48E7 3000 7424          movem.l   D2/D3,-(A7)
000040E8  242E 0008 7425          move.l    8(A6),D2
000040EC  4283      7426          clr.l     D3
000040EE  2042      7427          move.l    D2,A0
000040F0  2050      7428          move.l    (A0),A0
000040F2  1010      7429          move.b    (A0),D0
000040F4  4880      7430          ext.w     D0
000040F6  48C0      7431          ext.l     D0
000040F8  0C80 0000 7432          cmp.l     #42,D0
000040FC  002A      
000040FE  6612      7433          bne.s     @vsprintf_getval_1
00004100  206E 000C 7434          move.l    12(A6),A0
00004104  2250      7435          move.l    (A0),A1
00004106  5890      7436          addq.l    #4,(A0)
00004108  2611      7437          move.l    (A1),D3
0000410A  2042      7438          move.l    D2,A0
0000410C  5290      7439          addq.l    #1,(A0)
0000410E  6000 004E 7440          bra       @vsprintf_getval_5
                    7441   @vsprintf_getval_1:
00004112  2042      7442          move.l    D2,A0
00004114  2050      7443          move.l    (A0),A0
00004116  1010      7444          move.b    (A0),D0
00004118  4880      7445          ext.w     D0
0000411A  48C0      7446          ext.l     D0
0000411C  0C80 0000 7447          cmp.l     #48,D0
00004120  0030      
00004122  6D00 003A 7448          blt       @vsprintf_getval_5
00004126  2042      7449          move.l    D2,A0
00004128  2050      7450          move.l    (A0),A0
0000412A  1010      7451          move.b    (A0),D0
0000412C  4880      7452          ext.w     D0
0000412E  48C0      7453          ext.l     D0
00004130  0C80 0000 7454          cmp.l     #57,D0
00004134  0039      
00004136  6E26      7455          bgt.s     @vsprintf_getval_5
00004138  2F03      7456          move.l    D3,-(A7)
0000413A  4878 000A 7457          pea       10
0000413E  6100 07F4 7458          bsr       LMUL
00004142  2017      7459          move.l    (A7),D0
00004144  504F      7460          addq.w    #8,A7
00004146  2042      7461          move.l    D2,A0
00004148  2250      7462          move.l    (A0),A1
0000414A  5290      7463          addq.l    #1,(A0)
0000414C  1211      7464          move.b    (A1),D1
0000414E  4881      7465          ext.w     D1
00004150  48C1      7466          ext.l     D1
00004152  D081      7467          add.l     D1,D0
00004154  0480 0000 7468          sub.l     #48,D0
00004158  0030      
0000415A  2600      7469          move.l    D0,D3
0000415C  60B4      7470          bra       @vsprintf_getval_1
                    7471   @vsprintf_getval_5:
0000415E  2003      7472          move.l    D3,D0
00004160  4CDF 000C 7473          movem.l   (A7)+,D2/D3
00004164  4E5E      7474          unlk      A6
00004166  4E75      7475          rts
                    7476   _vsprintf:
00004168  4E56 FFCC 7477          link      A6,#-52
0000416C  48E7 3F3C 7478          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00004170  45EE 0008 7479          lea       8(A6),A2
00004174  47F8 40B6 7480          lea       @vsprintf_copy,A3
00004178  49F9 0000 7481          lea       _ultoa,A4
0000417C  48C0      
0000417E  4286      7482          clr.l     D6
                    7483   vsprintf_1:
00004180  206E 000C 7484          move.l    12(A6),A0
00004184  4A10      7485          tst.b     (A0)
00004186  6700 0624 7486          beq       vsprintf_3
0000418A  206E 000C 7487          move.l    12(A6),A0
0000418E  1010      7488          move.b    (A0),D0
00004190  4880      7489          ext.w     D0
00004192  48C0      7490          ext.l     D0
00004194  0C80 0000 7491          cmp.l     #37,D0
00004198  0025      
0000419A  671C      7492          beq.s     vsprintf_4
0000419C  206E 000C 7493          move.l    12(A6),A0
000041A0  52AE 000C 7494          addq.l    #1,12(A6)
000041A4  1210      7495          move.b    (A0),D1
000041A6  4881      7496          ext.w     D1
000041A8  48C1      7497          ext.l     D1
000041AA  2F01      7498          move.l    D1,-(A7)
000041AC  2F0A      7499          move.l    A2,-(A7)
000041AE  4E93      7500          jsr       (A3)
000041B0  504F      7501          addq.w    #8,A7
000041B2  5286      7502          addq.l    #1,D6
000041B4  6000 05F2 7503          bra       vsprintf_2
                    7504   vsprintf_4:
000041B8  52AE 000C 7505          addq.l    #1,12(A6)
000041BC  422E FFD3 7506          clr.b     -45(A6)
000041C0  422E FFD2 7507          clr.b     -46(A6)
000041C4  422E FFD0 7508          clr.b     -48(A6)
000041C8  422E FFCF 7509          clr.b     -49(A6)
000041CC  422E FFCE 7510          clr.b     -50(A6)
000041D0  422E FFCD 7511          clr.b     -51(A6)
000041D4  42AE FFFC 7512          clr.l     -4(A6)
000041D8  7AFF      7513          moveq     #-1,D5
000041DA  41EE FFDC 7514          lea       -36(A6),A0
000041DE  2608      7515          move.l    A0,D3
000041E0  2408      7516          move.l    A0,D2
                    7517   vsprintf_6:
000041E2  206E 000C 7518          move.l    12(A6),A0
000041E6  1010      7519          move.b    (A0),D0
000041E8  4880      7520          ext.w     D0
000041EA  48C0      7521          ext.l     D0
000041EC  0C80 0000 7522          cmp.l     #43,D0
000041F0  002B      
000041F2  6730      7523          beq.s     vsprintf_12
000041F4  6E18      7524          bgt.s     vsprintf_15
000041F6  0C80 0000 7525          cmp.l     #35,D0
000041FA  0023      
000041FC  6700 003E 7526          beq       vsprintf_14
00004200  6E00 0046 7527          bgt       vsprintf_9
00004204  0C80 0000 7528          cmp.l     #32,D0
00004208  0020      
0000420A  6724      7529          beq.s     vsprintf_13
0000420C  603A      7530          bra.s     vsprintf_9
                    7531   vsprintf_15:
0000420E  0C80 0000 7532          cmp.l     #45,D0
00004212  002D      
00004214  6702      7533          beq.s     vsprintf_11
00004216  6030      7534          bra.s     vsprintf_9
                    7535   vsprintf_11:
00004218  1D7C 0001 7536          move.b    #1,-51(A6)
0000421C  FFCD      
0000421E  52AE 000C 7537          addq.l    #1,12(A6)
00004222  6026      7538          bra.s     vsprintf_7
                    7539   vsprintf_12:
00004224  1D7C 0001 7540          move.b    #1,-50(A6)
00004228  FFCE      
0000422A  52AE 000C 7541          addq.l    #1,12(A6)
0000422E  601A      7542          bra.s     vsprintf_7
                    7543   vsprintf_13:
00004230  1D7C 0001 7544          move.b    #1,-49(A6)
00004234  FFCF      
00004236  52AE 000C 7545          addq.l    #1,12(A6)
0000423A  600E      7546          bra.s     vsprintf_7
                    7547   vsprintf_14:
0000423C  1D7C 0001 7548          move.b    #1,-48(A6)
00004240  FFD0      
00004242  52AE 000C 7549          addq.l    #1,12(A6)
00004246  6002      7550          bra.s     vsprintf_7
                    7551   vsprintf_9:
00004248  6002      7552          bra.s     vsprintf_8
                    7553   vsprintf_7:
0000424A  6096      7554          bra       vsprintf_6
                    7555   vsprintf_8:
0000424C  206E 000C 7556          move.l    12(A6),A0
00004250  1010      7557          move.b    (A0),D0
00004252  4880      7558          ext.w     D0
00004254  48C0      7559          ext.l     D0
00004256  0C80 0000 7560          cmp.l     #48,D0
0000425A  0030      
0000425C  660A      7561          bne.s     vsprintf_16
0000425E  52AE 000C 7562          addq.l    #1,12(A6)
00004262  1D7C 0001 7563          move.b    #1,-46(A6)
00004266  FFD2      
                    7564   vsprintf_16:
00004268  486E 0010 7565          pea       16(A6)
0000426C  486E 000C 7566          pea       12(A6)
00004270  6100 FE6E 7567          bsr       @vsprintf_getval
00004274  504F      7568          addq.w    #8,A7
00004276  2A40      7569          move.l    D0,A5
00004278  206E 000C 7570          move.l    12(A6),A0
0000427C  1010      7571          move.b    (A0),D0
0000427E  4880      7572          ext.w     D0
00004280  48C0      7573          ext.l     D0
00004282  0C80 0000 7574          cmp.l     #46,D0
00004286  002E      
00004288  6614      7575          bne.s     vsprintf_18
0000428A  52AE 000C 7576          addq.l    #1,12(A6)
0000428E  486E 0010 7577          pea       16(A6)
00004292  486E 000C 7578          pea       12(A6)
00004296  6100 FE48 7579          bsr       @vsprintf_getval
0000429A  504F      7580          addq.w    #8,A7
0000429C  2A00      7581          move.l    D0,D5
                    7582   vsprintf_18:
0000429E  206E 000C 7583          move.l    12(A6),A0
000042A2  1010      7584          move.b    (A0),D0
000042A4  4880      7585          ext.w     D0
000042A6  48C0      7586          ext.l     D0
000042A8  0C80 0000 7587          cmp.l     #108,D0
000042AC  006C      
000042AE  660A      7588          bne.s     vsprintf_20
000042B0  52AE 000C 7589          addq.l    #1,12(A6)
000042B4  1D7C 0001 7590          move.b    #1,-45(A6)
000042B8  FFD3      
                    7591   vsprintf_20:
000042BA  206E 000C 7592          move.l    12(A6),A0
000042BE  1010      7593          move.b    (A0),D0
000042C0  4880      7594          ext.w     D0
000042C2  48C0      7595          ext.l     D0
000042C4  0C80 0000 7596          cmp.l     #111,D0
000042C8  006F      
000042CA  6700 00D4 7597          beq       vsprintf_27
000042CE  6E34      7598          bgt.s     vsprintf_33
000042D0  0C80 0000 7599          cmp.l     #100,D0
000042D4  0064      
000042D6  6700 0054 7600          beq       vsprintf_24
000042DA  6E1C      7601          bgt.s     vsprintf_34
000042DC  0C80 0000 7602          cmp.l     #99,D0
000042E0  0063      
000042E2  6700 012C 7603          beq       vsprintf_30
000042E6  6E00 016A 7604          bgt       vsprintf_22
000042EA  0C80 0000 7605          cmp.l     #88,D0
000042EE  0058      
000042F0  6700 00E6 7606          beq       vsprintf_28
000042F4  6000 015C 7607          bra       vsprintf_22
                    7608   vsprintf_34:
000042F8  0C80 0000 7609          cmp.l     #105,D0
000042FC  0069      
000042FE  672C      7610          beq.s     vsprintf_24
00004300  6000 0150 7611          bra       vsprintf_22
                    7612   vsprintf_33:
00004304  0C80 0000 7613          cmp.l     #117,D0
00004308  0075      
0000430A  6700 005C 7614          beq       vsprintf_26
0000430E  6E0E      7615          bgt.s     vsprintf_35
00004310  0C80 0000 7616          cmp.l     #115,D0
00004314  0073      
00004316  6700 011C 7617          beq       vsprintf_31
0000431A  6000 0136 7618          bra       vsprintf_22
                    7619   vsprintf_35:
0000431E  0C80 0000 7620          cmp.l     #120,D0
00004322  0078      
00004324  6700 00B2 7621          beq       vsprintf_28
00004328  6000 0128 7622          bra       vsprintf_22
                    7623   vsprintf_24:
0000432C  4A2E FFD3 7624          tst.b     -45(A6)
00004330  671A      7625          beq.s     vsprintf_36
00004332  4878 000A 7626          pea       10
00004336  2F03      7627          move.l    D3,-(A7)
00004338  206E 0010 7628          move.l    16(A6),A0
0000433C  58AE 0010 7629          addq.l    #4,16(A6)
00004340  2F10      7630          move.l    (A0),-(A7)
00004342  6100 04F8 7631          bsr       _ltoa
00004346  DEFC 000C 7632          add.w     #12,A7
0000434A  6018      7633          bra.s     vsprintf_37
                    7634   vsprintf_36:
0000434C  4878 000A 7635          pea       10
00004350  2F03      7636          move.l    D3,-(A7)
00004352  206E 0010 7637          move.l    16(A6),A0
00004356  58AE 0010 7638          addq.l    #4,16(A6)
0000435A  2F10      7639          move.l    (A0),-(A7)
0000435C  6100 04DE 7640          bsr       _ltoa
00004360  DEFC 000C 7641          add.w     #12,A7
                    7642   vsprintf_37:
00004364  6000 00FA 7643          bra       vsprintf_23
                    7644   vsprintf_26:
00004368  4A2E FFD3 7645          tst.b     -45(A6)
0000436C  6718      7646          beq.s     vsprintf_38
0000436E  4878 000A 7647          pea       10
00004372  2F03      7648          move.l    D3,-(A7)
00004374  206E 0010 7649          move.l    16(A6),A0
00004378  58AE 0010 7650          addq.l    #4,16(A6)
0000437C  2F10      7651          move.l    (A0),-(A7)
0000437E  4E94      7652          jsr       (A4)
00004380  DEFC 000C 7653          add.w     #12,A7
00004384  6016      7654          bra.s     vsprintf_39
                    7655   vsprintf_38:
00004386  4878 000A 7656          pea       10
0000438A  2F03      7657          move.l    D3,-(A7)
0000438C  206E 0010 7658          move.l    16(A6),A0
00004390  58AE 0010 7659          addq.l    #4,16(A6)
00004394  2F10      7660          move.l    (A0),-(A7)
00004396  4E94      7661          jsr       (A4)
00004398  DEFC 000C 7662          add.w     #12,A7
                    7663   vsprintf_39:
0000439C  6000 00C2 7664          bra       vsprintf_23
                    7665   vsprintf_27:
000043A0  4A2E FFD3 7666          tst.b     -45(A6)
000043A4  6718      7667          beq.s     vsprintf_40
000043A6  4878 0008 7668          pea       8
000043AA  2F03      7669          move.l    D3,-(A7)
000043AC  206E 0010 7670          move.l    16(A6),A0
000043B0  58AE 0010 7671          addq.l    #4,16(A6)
000043B4  2F10      7672          move.l    (A0),-(A7)
000043B6  4E94      7673          jsr       (A4)
000043B8  DEFC 000C 7674          add.w     #12,A7
000043BC  6016      7675          bra.s     vsprintf_41
                    7676   vsprintf_40:
000043BE  4878 0008 7677          pea       8
000043C2  2F03      7678          move.l    D3,-(A7)
000043C4  206E 0010 7679          move.l    16(A6),A0
000043C8  58AE 0010 7680          addq.l    #4,16(A6)
000043CC  2F10      7681          move.l    (A0),-(A7)
000043CE  4E94      7682          jsr       (A4)
000043D0  DEFC 000C 7683          add.w     #12,A7
                    7684   vsprintf_41:
000043D4  6000 008A 7685          bra       vsprintf_23
                    7686   vsprintf_28:
000043D8  4A2E FFD3 7687          tst.b     -45(A6)
000043DC  6718      7688          beq.s     vsprintf_42
000043DE  4878 0010 7689          pea       16
000043E2  2F03      7690          move.l    D3,-(A7)
000043E4  206E 0010 7691          move.l    16(A6),A0
000043E8  58AE 0010 7692          addq.l    #4,16(A6)
000043EC  2F10      7693          move.l    (A0),-(A7)
000043EE  4E94      7694          jsr       (A4)
000043F0  DEFC 000C 7695          add.w     #12,A7
000043F4  6016      7696          bra.s     vsprintf_43
                    7697   vsprintf_42:
000043F6  4878 0010 7698          pea       16
000043FA  2F03      7699          move.l    D3,-(A7)
000043FC  206E 0010 7700          move.l    16(A6),A0
00004400  58AE 0010 7701          addq.l    #4,16(A6)
00004404  2F10      7702          move.l    (A0),-(A7)
00004406  4E94      7703          jsr       (A4)
00004408  DEFC 000C 7704          add.w     #12,A7
                    7705   vsprintf_43:
0000440C  6000 0052 7706          bra       vsprintf_23
                    7707   vsprintf_30:
00004410  206E 0010 7708          move.l    16(A6),A0
00004414  58AE 0010 7709          addq.l    #4,16(A6)
00004418  2010      7710          move.l    (A0),D0
0000441A  2042      7711          move.l    D2,A0
0000441C  5282      7712          addq.l    #1,D2
0000441E  1080      7713          move.b    D0,(A0)
00004420  2042      7714          move.l    D2,A0
00004422  4210      7715          clr.b     (A0)
00004424  200D      7716          move.l    A5,D0
00004426  6704      7717          beq.s     vsprintf_44
00004428  200D      7718          move.l    A5,D0
0000442A  6002      7719          bra.s     vsprintf_45
                    7720   vsprintf_44:
0000442C  7001      7721          moveq     #1,D0
                    7722   vsprintf_45:
0000442E  2A00      7723          move.l    D0,D5
00004430  6000 002E 7724          bra       vsprintf_23
                    7725   vsprintf_31:
00004434  206E 0010 7726          move.l    16(A6),A0
00004438  58AE 0010 7727          addq.l    #4,16(A6)
0000443C  2610      7728          move.l    (A0),D3
0000443E  0C85 FFFF 7729          cmp.l     #-1,D5
00004442  FFFF      
00004444  660A      7730          bne.s     vsprintf_46
00004446  2F03      7731          move.l    D3,-(A7)
00004448  6100 0578 7732          bsr       _strlen
0000444C  584F      7733          addq.w    #4,A7
0000444E  2A00      7734          move.l    D0,D5
                    7735   vsprintf_46:
00004450  600E      7736          bra.s     vsprintf_23
                    7737   vsprintf_22:
00004452  206E 000C 7738          move.l    12(A6),A0
00004456  2242      7739          move.l    D2,A1
00004458  5282      7740          addq.l    #1,D2
0000445A  1290      7741          move.b    (A0),(A1)
0000445C  2042      7742          move.l    D2,A0
0000445E  4210      7743          clr.b     (A0)
                    7744   vsprintf_23:
00004460  2F03      7745          move.l    D3,-(A7)
00004462  6100 055E 7746          bsr       _strlen
00004466  584F      7747          addq.w    #4,A7
00004468  1800      7748          move.b    D0,D4
0000446A  206E 000C 7749          move.l    12(A6),A0
0000446E  1010      7750          move.b    (A0),D0
00004470  4880      7751          ext.w     D0
00004472  48C0      7752          ext.l     D0
00004474  0C80 0000 7753          cmp.l     #115,D0
00004478  0073      
0000447A  6618      7754          bne.s     vsprintf_48
0000447C  0C85 0000 7755          cmp.l     #0,D5
00004480  0000      
00004482  6D10      7756          blt.s     vsprintf_48
00004484  4884      7757          ext.w     D4
00004486  48C4      7758          ext.l     D4
00004488  B885      7759          cmp.l     D5,D4
0000448A  6F04      7760          ble.s     vsprintf_50
0000448C  1005      7761          move.b    D5,D0
0000448E  6002      7762          bra.s     vsprintf_51
                    7763   vsprintf_50:
00004490  1004      7764          move.b    D4,D0
                    7765   vsprintf_51:
00004492  1800      7766          move.b    D0,D4
                    7767   vsprintf_48:
00004494  206E 000C 7768          move.l    12(A6),A0
00004498  1010      7769          move.b    (A0),D0
0000449A  4880      7770          ext.w     D0
0000449C  48C0      7771          ext.l     D0
0000449E  0C80 0000 7772          cmp.l     #88,D0
000044A2  0058      
000044A4  6600 0026 7773          bne       vsprintf_56
000044A8  41EE FFDC 7774          lea       -36(A6),A0
000044AC  2408      7775          move.l    A0,D2
                    7776   vsprintf_54:
000044AE  2042      7777          move.l    D2,A0
000044B0  4A10      7778          tst.b     (A0)
000044B2  6718      7779          beq.s     vsprintf_56
000044B4  2042      7780          move.l    D2,A0
000044B6  1210      7781          move.b    (A0),D1
000044B8  4881      7782          ext.w     D1
000044BA  48C1      7783          ext.l     D1
000044BC  2F01      7784          move.l    D1,-(A7)
000044BE  6100 FB98 7785          bsr       _toupper
000044C2  584F      7786          addq.w    #4,A7
000044C4  2042      7787          move.l    D2,A0
000044C6  1080      7788          move.b    D0,(A0)
000044C8  5282      7789          addq.l    #1,D2
000044CA  60E2      7790          bra       vsprintf_54
                    7791   vsprintf_56:
000044CC  7E00      7792          moveq     #0,D7
000044CE  41EE FFD4 7793          lea       -44(A6),A0
000044D2  2408      7794          move.l    A0,D2
000044D4  206E 000C 7795          move.l    12(A6),A0
000044D8  1010      7796          move.b    (A0),D0
000044DA  4880      7797          ext.w     D0
000044DC  48C0      7798          ext.l     D0
000044DE  0C80 0000 7799          cmp.l     #100,D0
000044E2  0064      
000044E4  6714      7800          beq.s     vsprintf_59
000044E6  206E 000C 7801          move.l    12(A6),A0
000044EA  1010      7802          move.b    (A0),D0
000044EC  4880      7803          ext.w     D0
000044EE  48C0      7804          ext.l     D0
000044F0  0C80 0000 7805          cmp.l     #105,D0
000044F4  0069      
000044F6  6600 0076 7806          bne       vsprintf_65
                    7807   vsprintf_59:
000044FA  4A2E FFCE 7808          tst.b     -50(A6)
000044FE  6612      7809          bne.s     vsprintf_62
00004500  2043      7810          move.l    D3,A0
00004502  1010      7811          move.b    (A0),D0
00004504  4880      7812          ext.w     D0
00004506  48C0      7813          ext.l     D0
00004508  0C80 0000 7814          cmp.l     #45,D0
0000450C  002D      
0000450E  6600 002E 7815          bne       vsprintf_60
                    7816   vsprintf_62:
00004512  2043      7817          move.l    D3,A0
00004514  1010      7818          move.b    (A0),D0
00004516  4880      7819          ext.w     D0
00004518  48C0      7820          ext.l     D0
0000451A  0C80 0000 7821          cmp.l     #45,D0
0000451E  002D      
00004520  660E      7822          bne.s     vsprintf_63
00004522  2043      7823          move.l    D3,A0
00004524  5283      7824          addq.l    #1,D3
00004526  2242      7825          move.l    D2,A1
00004528  5282      7826          addq.l    #1,D2
0000452A  1290      7827          move.b    (A0),(A1)
0000452C  5304      7828          subq.b    #1,D4
0000452E  6008      7829          bra.s     vsprintf_64
                    7830   vsprintf_63:
00004530  2042      7831          move.l    D2,A0
00004532  5282      7832          addq.l    #1,D2
00004534  10BC 002B 7833          move.b    #43,(A0)
                    7834   vsprintf_64:
00004538  5287      7835          addq.l    #1,D7
0000453A  6000 0032 7836          bra       vsprintf_65
                    7837   vsprintf_60:
0000453E  4A2E FFCF 7838          tst.b     -49(A6)
00004542  6700 002A 7839          beq       vsprintf_65
00004546  2043      7840          move.l    D3,A0
00004548  1010      7841          move.b    (A0),D0
0000454A  4880      7842          ext.w     D0
0000454C  48C0      7843          ext.l     D0
0000454E  0C80 0000 7844          cmp.l     #45,D0
00004552  002D      
00004554  660E      7845          bne.s     vsprintf_67
00004556  2043      7846          move.l    D3,A0
00004558  5283      7847          addq.l    #1,D3
0000455A  2242      7848          move.l    D2,A1
0000455C  5282      7849          addq.l    #1,D2
0000455E  1290      7850          move.b    (A0),(A1)
00004560  5304      7851          subq.b    #1,D4
00004562  6008      7852          bra.s     vsprintf_68
                    7853   vsprintf_67:
00004564  2042      7854          move.l    D2,A0
00004566  5282      7855          addq.l    #1,D2
00004568  10BC 0020 7856          move.b    #32,(A0)
                    7857   vsprintf_68:
0000456C  5287      7858          addq.l    #1,D7
                    7859   vsprintf_65:
0000456E  4A2E FFD0 7860          tst.b     -48(A6)
00004572  6700 0066 7861          beq       vsprintf_77
00004576  206E 000C 7862          move.l    12(A6),A0
0000457A  1010      7863          move.b    (A0),D0
0000457C  4880      7864          ext.w     D0
0000457E  48C0      7865          ext.l     D0
00004580  0C80 0000 7866          cmp.l     #111,D0
00004584  006F      
00004586  671A      7867          beq.s     vsprintf_73
00004588  6E0C      7868          bgt.s     vsprintf_76
0000458A  0C80 0000 7869          cmp.l     #88,D0
0000458E  0058      
00004590  6710      7870          beq.s     vsprintf_73
00004592  6000 0046 7871          bra       vsprintf_77
                    7872   vsprintf_76:
00004596  0C80 0000 7873          cmp.l     #120,D0
0000459A  0078      
0000459C  6704      7874          beq.s     vsprintf_73
0000459E  6000 003A 7875          bra       vsprintf_77
                    7876   vsprintf_73:
000045A2  2042      7877          move.l    D2,A0
000045A4  5282      7878          addq.l    #1,D2
000045A6  10BC 0030 7879          move.b    #48,(A0)
000045AA  5287      7880          addq.l    #1,D7
000045AC  206E 000C 7881          move.l    12(A6),A0
000045B0  1010      7882          move.b    (A0),D0
000045B2  4880      7883          ext.w     D0
000045B4  48C0      7884          ext.l     D0
000045B6  0C80 0000 7885          cmp.l     #120,D0
000045BA  0078      
000045BC  6712      7886          beq.s     vsprintf_79
000045BE  206E 000C 7887          move.l    12(A6),A0
000045C2  1010      7888          move.b    (A0),D0
000045C4  4880      7889          ext.w     D0
000045C6  48C0      7890          ext.l     D0
000045C8  0C80 0000 7891          cmp.l     #88,D0
000045CC  0058      
000045CE  660A      7892          bne.s     vsprintf_77
                    7893   vsprintf_79:
000045D0  2042      7894          move.l    D2,A0
000045D2  5282      7895          addq.l    #1,D2
000045D4  10BC 0078 7896          move.b    #120,(A0)
000045D8  5287      7897          addq.l    #1,D7
                    7898   vsprintf_77:
000045DA  2042      7899          move.l    D2,A0
000045DC  4210      7900          clr.b     (A0)
000045DE  206E 000C 7901          move.l    12(A6),A0
000045E2  1010      7902          move.b    (A0),D0
000045E4  4880      7903          ext.w     D0
000045E6  48C0      7904          ext.l     D0
000045E8  0C80 0000 7905          cmp.l     #105,D0
000045EC  0069      
000045EE  6700 0076 7906          beq       vsprintf_82
000045F2  6E42      7907          bgt.s     vsprintf_93
000045F4  0C80 0000 7908          cmp.l     #99,D0
000045F8  0063      
000045FA  6700 0084 7909          beq       vsprintf_96
000045FE  6E1C      7910          bgt.s     vsprintf_94
00004600  0C80 0000 7911          cmp.l     #88,D0
00004604  0058      
00004606  6700 005E 7912          beq       vsprintf_82
0000460A  6E00 0184 7913          bgt       vsprintf_80
0000460E  0C80 0000 7914          cmp.l     #69,D0
00004612  0045      
00004614  6700 0050 7915          beq       vsprintf_82
00004618  6000 0176 7916          bra       vsprintf_80
                    7917   vsprintf_94:
0000461C  0C80 0000 7918          cmp.l     #101,D0
00004620  0065      
00004622  6700 0042 7919          beq       vsprintf_82
00004626  6E00 0168 7920          bgt       vsprintf_80
0000462A  0C80 0000 7921          cmp.l     #100,D0
0000462E  0064      
00004630  6734      7922          beq.s     vsprintf_82
00004632  6000 015C 7923          bra       vsprintf_80
                    7924   vsprintf_93:
00004636  0C80 0000 7925          cmp.l     #117,D0
0000463A  0075      
0000463C  6728      7926          beq.s     vsprintf_82
0000463E  6E1A      7927          bgt.s     vsprintf_95
00004640  0C80 0000 7928          cmp.l     #115,D0
00004644  0073      
00004646  6700 0038 7929          beq       vsprintf_96
0000464A  6E00 0144 7930          bgt       vsprintf_80
0000464E  0C80 0000 7931          cmp.l     #111,D0
00004652  006F      
00004654  6710      7932          beq.s     vsprintf_82
00004656  6000 0138 7933          bra       vsprintf_80
                    7934   vsprintf_95:
0000465A  0C80 0000 7935          cmp.l     #120,D0
0000465E  0078      
00004660  6704      7936          beq.s     vsprintf_82
00004662  6000 012C 7937          bra       vsprintf_80
                    7938   vsprintf_82:
00004666  4A2E FFD2 7939          tst.b     -46(A6)
0000466A  6714      7940          beq.s     vsprintf_96
0000466C  4A2E FFCD 7941          tst.b     -51(A6)
00004670  660E      7942          bne.s     vsprintf_96
00004672  200D      7943          move.l    A5,D0
00004674  9087      7944          sub.l     D7,D0
00004676  4884      7945          ext.w     D4
00004678  48C4      7946          ext.l     D4
0000467A  9084      7947          sub.l     D4,D0
0000467C  2D40 FFFC 7948          move.l    D0,-4(A6)
                    7949   vsprintf_96:
00004680  202E FFFC 7950          move.l    -4(A6),D0
00004684  0C80 0000 7951          cmp.l     #0,D0
00004688  0000      
0000468A  6C04      7952          bge.s     vsprintf_98
0000468C  42AE FFFC 7953          clr.l     -4(A6)
                    7954   vsprintf_98:
00004690  4A2E FFCD 7955          tst.b     -51(A6)
00004694  6600 0030 7956          bne       vsprintf_104
00004698  4884      7957          ext.w     D4
0000469A  48C4      7958          ext.l     D4
0000469C  2004      7959          move.l    D4,D0
0000469E  D0AE FFFC 7960          add.l     -4(A6),D0
000046A2  D087      7961          add.l     D7,D0
000046A4  1D40 FFD1 7962          move.b    D0,-47(A6)
                    7963   vsprintf_102:
000046A8  102E FFD1 7964          move.b    -47(A6),D0
000046AC  4880      7965          ext.w     D0
000046AE  48C0      7966          ext.l     D0
000046B0  220D      7967          move.l    A5,D1
000046B2  534D      7968          subq.w    #1,A5
000046B4  B081      7969          cmp.l     D1,D0
000046B6  6C0E      7970          bge.s     vsprintf_104
000046B8  4878 0020 7971          pea       32
000046BC  2F0A      7972          move.l    A2,-(A7)
000046BE  4E93      7973          jsr       (A3)
000046C0  504F      7974          addq.w    #8,A7
000046C2  5286      7975          addq.l    #1,D6
000046C4  60E2      7976          bra       vsprintf_102
                    7977   vsprintf_104:
000046C6  41EE FFD4 7978          lea       -44(A6),A0
000046CA  2408      7979          move.l    A0,D2
                    7980   vsprintf_105:
000046CC  2042      7981          move.l    D2,A0
000046CE  4A10      7982          tst.b     (A0)
000046D0  6716      7983          beq.s     vsprintf_107
000046D2  2042      7984          move.l    D2,A0
000046D4  5282      7985          addq.l    #1,D2
000046D6  1210      7986          move.b    (A0),D1
000046D8  4881      7987          ext.w     D1
000046DA  48C1      7988          ext.l     D1
000046DC  2F01      7989          move.l    D1,-(A7)
000046DE  2F0A      7990          move.l    A2,-(A7)
000046E0  4E93      7991          jsr       (A3)
000046E2  504F      7992          addq.w    #8,A7
000046E4  5286      7993          addq.l    #1,D6
000046E6  60E4      7994          bra       vsprintf_105
                    7995   vsprintf_107:
000046E8  202E FFFC 7996          move.l    -4(A6),D0
000046EC  1D40 FFD1 7997          move.b    D0,-47(A6)
                    7998   vsprintf_108:
000046F0  102E FFD1 7999          move.b    -47(A6),D0
000046F4  532E FFD1 8000          subq.b    #1,-47(A6)
000046F8  4A00      8001          tst.b     D0
000046FA  670E      8002          beq.s     vsprintf_110
000046FC  4878 0030 8003          pea       48
00004700  2F0A      8004          move.l    A2,-(A7)
00004702  4E93      8005          jsr       (A3)
00004704  504F      8006          addq.w    #8,A7
00004706  5286      8007          addq.l    #1,D6
00004708  60E6      8008          bra       vsprintf_108
                    8009   vsprintf_110:
0000470A  2043      8010          move.l    D3,A0
0000470C  4A10      8011          tst.b     (A0)
0000470E  6700 0048 8012          beq       vsprintf_113
00004712  206E 000C 8013          move.l    12(A6),A0
00004716  1010      8014          move.b    (A0),D0
00004718  4880      8015          ext.w     D0
0000471A  48C0      8016          ext.l     D0
0000471C  0C80 0000 8017          cmp.l     #115,D0
00004720  0073      
00004722  670C      8018          beq.s     vsprintf_116
00004724  6E18      8019          bgt.s     vsprintf_119
00004726  0C80 0000 8020          cmp.l     #99,D0
0000472A  0063      
0000472C  6702      8021          beq.s     vsprintf_116
0000472E  600E      8022          bra.s     vsprintf_119
                    8023   vsprintf_116:
00004730  2005      8024          move.l    D5,D0
00004732  5385      8025          subq.l    #1,D5
00004734  0C80 0000 8026          cmp.l     #0,D0
00004738  0000      
0000473A  6E02      8027          bgt.s     vsprintf_119
0000473C  6016      8028          bra.s     vsprintf_115
                    8029   vsprintf_119:
0000473E  2043      8030          move.l    D3,A0
00004740  5283      8031          addq.l    #1,D3
00004742  1210      8032          move.b    (A0),D1
00004744  4881      8033          ext.w     D1
00004746  48C1      8034          ext.l     D1
00004748  2F01      8035          move.l    D1,-(A7)
0000474A  2F0A      8036          move.l    A2,-(A7)
0000474C  4E93      8037          jsr       (A3)
0000474E  504F      8038          addq.w    #8,A7
00004750  5286      8039          addq.l    #1,D6
00004752  6002      8040          bra.s     vsprintf_112
                    8041   vsprintf_115:
00004754  6002      8042          bra.s     vsprintf_113
                    8043   vsprintf_112:
00004756  60B2      8044          bra       vsprintf_110
                    8045   vsprintf_113:
00004758  4A2E FFCD 8046          tst.b     -51(A6)
0000475C  6700 0030 8047          beq       vsprintf_125
00004760  4884      8048          ext.w     D4
00004762  48C4      8049          ext.l     D4
00004764  2004      8050          move.l    D4,D0
00004766  D0AE FFFC 8051          add.l     -4(A6),D0
0000476A  D087      8052          add.l     D7,D0
0000476C  1D40 FFD1 8053          move.b    D0,-47(A6)
                    8054   vsprintf_123:
00004770  102E FFD1 8055          move.b    -47(A6),D0
00004774  4880      8056          ext.w     D0
00004776  48C0      8057          ext.l     D0
00004778  220D      8058          move.l    A5,D1
0000477A  534D      8059          subq.w    #1,A5
0000477C  B081      8060          cmp.l     D1,D0
0000477E  6C0E      8061          bge.s     vsprintf_125
00004780  4878 0020 8062          pea       32
00004784  2F0A      8063          move.l    A2,-(A7)
00004786  4E93      8064          jsr       (A3)
00004788  504F      8065          addq.w    #8,A7
0000478A  5386      8066          subq.l    #1,D6
0000478C  60E2      8067          bra       vsprintf_123
                    8068   vsprintf_125:
0000478E  6014      8069          bra.s     vsprintf_81
                    8070   vsprintf_80:
00004790  206E 000C 8071          move.l    12(A6),A0
00004794  1210      8072          move.b    (A0),D1
00004796  4881      8073          ext.w     D1
00004798  48C1      8074          ext.l     D1
0000479A  2F01      8075          move.l    D1,-(A7)
0000479C  2F0A      8076          move.l    A2,-(A7)
0000479E  4E93      8077          jsr       (A3)
000047A0  504F      8078          addq.w    #8,A7
000047A2  5286      8079          addq.l    #1,D6
                    8080   vsprintf_81:
000047A4  52AE 000C 8081          addq.l    #1,12(A6)
                    8082   vsprintf_2:
000047A8  6000 F9D6 8083          bra       vsprintf_1
                    8084   vsprintf_3:
000047AC  4A92      8085          tst.l     (A2)
000047AE  6710      8086          beq.s     vsprintf_126
000047B0  4201      8087          clr.b     D1
000047B2  C2BC 0000 8088          and.l     #255,D1
000047B6  00FF      
000047B8  2F01      8089          move.l    D1,-(A7)
000047BA  2F0A      8090          move.l    A2,-(A7)
000047BC  4E93      8091          jsr       (A3)
000047BE  504F      8092          addq.w    #8,A7
                    8093   vsprintf_126:
000047C0  2006      8094          move.l    D6,D0
000047C2  4CDF 3CFC 8095          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000047C6  4E5E      8096          unlk      A6
000047C8  4E75      8097          rts
                    8098   @itoa_convert:
000047CA  4E56 0000 8099          link      A6,#0
000047CE  48E7 3C00 8100          movem.l   D2/D3/D4/D5,-(A7)
000047D2  242E 0008 8101          move.l    8(A6),D2
000047D6  262E 0010 8102          move.l    16(A6),D3
000047DA  2A2E 000C 8103          move.l    12(A6),D5
000047DE  2F05      8104          move.l    D5,-(A7)
000047E0  2F03      8105          move.l    D3,-(A7)
000047E2  6100 F6B4 8106          bsr       ULDIV
000047E6  202F 0004 8107          move.l    4(A7),D0
000047EA  504F      8108          addq.w    #8,A7
000047EC  2800      8109          move.l    D0,D4
000047EE  BA83      8110          cmp.l     D3,D5
000047F0  651A      8111          blo.s     @itoa_convert_1
000047F2  2F03      8112          move.l    D3,-(A7)
000047F4  2F05      8113          move.l    D5,-(A7)
000047F6  2F03      8114          move.l    D3,-(A7)
000047F8  6100 F69E 8115          bsr       ULDIV
000047FC  2217      8116          move.l    (A7),D1
000047FE  504F      8117          addq.w    #8,A7
00004800  2F01      8118          move.l    D1,-(A7)
00004802  2F02      8119          move.l    D2,-(A7)
00004804  61C4      8120          bsr       @itoa_convert
00004806  DEFC 000C 8121          add.w     #12,A7
0000480A  2400      8122          move.l    D0,D2
                    8123   @itoa_convert_1:
0000480C  0C84 0000 8124          cmp.l     #9,D4
00004810  0009      
00004812  6E0A      8125          bgt.s     @itoa_convert_3
00004814  2004      8126          move.l    D4,D0
00004816  0680 0000 8127          add.l     #48,D0
0000481A  0030      
0000481C  600E      8128          bra.s     @itoa_convert_4
                    8129   @itoa_convert_3:
0000481E  2004      8130          move.l    D4,D0
00004820  0680 0000 8131          add.l     #97,D0
00004824  0061      
00004826  0480 0000 8132          sub.l     #10,D0
0000482A  000A      
                    8133   @itoa_convert_4:
0000482C  2042      8134          move.l    D2,A0
0000482E  1080      8135          move.b    D0,(A0)
00004830  2002      8136          move.l    D2,D0
00004832  5280      8137          addq.l    #1,D0
00004834  4CDF 003C 8138          movem.l   (A7)+,D2/D3/D4/D5
00004838  4E5E      8139          unlk      A6
0000483A  4E75      8140          rts
                    8141   _ltoa:
0000483C  4E56 0000 8142          link      A6,#0
00004840  48E7 3C00 8143          movem.l   D2/D3/D4/D5,-(A7)
00004844  242E 0008 8144          move.l    8(A6),D2
00004848  262E 000C 8145          move.l    12(A6),D3
0000484C  2A2E 0010 8146          move.l    16(A6),D5
00004850  2803      8147          move.l    D3,D4
00004852  0C85 0000 8148          cmp.l     #2,D5
00004856  0002      
00004858  6D08      8149          blt.s     ltoa_3
0000485A  0C85 0000 8150          cmp.l     #36,D5
0000485E  0024      
00004860  6F06      8151          ble.s     ltoa_1
                    8152   ltoa_3:
00004862  2003      8153          move.l    D3,D0
00004864  6000 0052 8154          bra       ltoa_4
                    8155   ltoa_1:
00004868  0C85 0000 8156          cmp.l     #10,D5
0000486C  000A      
0000486E  6600 0032 8157          bne       ltoa_5
00004872  0C82 0000 8158          cmp.l     #0,D2
00004876  0000      
00004878  6C28      8159          bge.s     ltoa_5
0000487A  2002      8160          move.l    D2,D0
0000487C  4480      8161          neg.l     D0
0000487E  2400      8162          move.l    D0,D2
00004880  0C82 0000 8163          cmp.l     #0,D2
00004884  0000      
00004886  6C12      8164          bge.s     ltoa_7
00004888  4879 0000 8165          pea       @itoa_1
0000488C  675A      
0000488E  2F03      8166          move.l    D3,-(A7)
00004890  6100 F5F6 8167          bsr       _strcpy
00004894  504F      8168          addq.w    #8,A7
00004896  2003      8169          move.l    D3,D0
00004898  601E      8170          bra.s     ltoa_4
                    8171   ltoa_7:
0000489A  2044      8172          move.l    D4,A0
0000489C  5284      8173          addq.l    #1,D4
0000489E  10BC 002D 8174          move.b    #45,(A0)
                    8175   ltoa_5:
000048A2  2F05      8176          move.l    D5,-(A7)
000048A4  2F02      8177          move.l    D2,-(A7)
000048A6  2F04      8178          move.l    D4,-(A7)
000048A8  6100 FF20 8179          bsr       @itoa_convert
000048AC  DEFC 000C 8180          add.w     #12,A7
000048B0  2800      8181          move.l    D0,D4
000048B2  2044      8182          move.l    D4,A0
000048B4  4210      8183          clr.b     (A0)
000048B6  2003      8184          move.l    D3,D0
                    8185   ltoa_4:
000048B8  4CDF 003C 8186          movem.l   (A7)+,D2/D3/D4/D5
000048BC  4E5E      8187          unlk      A6
000048BE  4E75      8188          rts
                    8189   _ultoa:
000048C0  4E56 0000 8190          link      A6,#0
000048C4  48E7 3800 8191          movem.l   D2/D3/D4,-(A7)
000048C8  262E 0010 8192          move.l    16(A6),D3
000048CC  282E 000C 8193          move.l    12(A6),D4
000048D0  2404      8194          move.l    D4,D2
000048D2  0C83 0000 8195          cmp.l     #2,D3
000048D6  0002      
000048D8  6D08      8196          blt.s     ultoa_3
000048DA  0C83 0000 8197          cmp.l     #36,D3
000048DE  0024      
000048E0  6F04      8198          ble.s     ultoa_1
                    8199   ultoa_3:
000048E2  2004      8200          move.l    D4,D0
000048E4  6018      8201          bra.s     ultoa_4
                    8202   ultoa_1:
000048E6  2F03      8203          move.l    D3,-(A7)
000048E8  2F2E 0008 8204          move.l    8(A6),-(A7)
000048EC  2F02      8205          move.l    D2,-(A7)
000048EE  6100 FEDA 8206          bsr       @itoa_convert
000048F2  DEFC 000C 8207          add.w     #12,A7
000048F6  2400      8208          move.l    D0,D2
000048F8  2042      8209          move.l    D2,A0
000048FA  4210      8210          clr.b     (A0)
000048FC  2004      8211          move.l    D4,D0
                    8212   ultoa_4:
000048FE  4CDF 001C 8213          movem.l   (A7)+,D2/D3/D4
00004902  4E5E      8214          unlk      A6
00004904  4E75      8215          rts
                    8216   _itoa:
00004906  4E56 0000 8217          link      A6,#0
0000490A  2F2E 0010 8218          move.l    16(A6),-(A7)
0000490E  2F2E 000C 8219          move.l    12(A6),-(A7)
00004912  2F2E 0008 8220          move.l    8(A6),-(A7)
00004916  6100 FF24 8221          bsr       _ltoa
0000491A  DEFC 000C 8222          add.w     #12,A7
0000491E  4E5E      8223          unlk      A6
00004920  4E75      8224          rts
                    8225   ULMUL:
00004922  4E56 0000 8226          link    A6,#0
00004926  48E7 C000 8227          movem.l D0/D1,-(A7)
0000492A  222E 0008 8228          move.l  8(A6),D1
0000492E  202E 000C 8229          move.l  12(A6),D0
00004932  602C      8230          bra.s   lmul_3
                    8231   LMUL:
00004934  4E56 0000 8232          link    A6,#0
00004938  48E7 C000 8233          movem.l D0/D1,-(A7)
0000493C  222E 0008 8234          move.l  8(A6),D1
00004940  202E 000C 8235          move.l  12(A6),D0
00004944  4A80      8236          tst.l   D0
00004946  6A0A      8237          bpl.s   lmul_1
00004948  4480      8238          neg.l   D0
0000494A  4A81      8239          tst.l   D1
0000494C  6A0A      8240          bpl.s   lmul_2
0000494E  4481      8241          neg.l   D1
00004950  600E      8242          bra.s   lmul_3
                    8243   lmul_1:
00004952  4A81      8244          tst.l   D1
00004954  6A0A      8245          bpl.s   lmul_3
00004956  4481      8246          neg.l   D1
                    8247   lmul_2:
00004958  6114      8248          bsr.s   domul
0000495A  4481      8249          neg.l   D1
0000495C  4080      8250          negx.l  D0
0000495E  6002      8251          bra.s   lmul_4
                    8252   lmul_3:
00004960  610C      8253          bsr.s   domul
                    8254   lmul_4:
00004962  2D41 0008 8255          move.l  D1,8(A6)
00004966  4CDF 0003 8256          movem.l (A7)+,D0/D1
0000496A  4E5E      8257          unlk    A6
0000496C  4E75      8258          rts
                    8259   domul:
0000496E  0C81 0000 8260          cmpi.l  #$FFFF,D1
00004972  FFFF      
00004974  620C      8261          bhi.s   domul_1
00004976  0C80 0000 8262          cmpi.l  #$FFFF,D0
0000497A  FFFF      
0000497C  620E      8263          bhi.s   domul_2
0000497E  C2C0      8264          mulu    D0,D1
00004980  4E75      8265          rts
                    8266   domul_1:
00004982  0C80 0000 8267          cmpi.l  #$FFFF,D0
00004986  FFFF      
00004988  6218      8268          bhi.s   domul_4
0000498A  6002      8269          bra.s   domul_3
                    8270   domul_2
0000498C  C141      8271          exg     D0,D1
                    8272   domul_3:
0000498E  2F02      8273          move.l  D2,-(A7)
00004990  2401      8274          move.l  D1,D2
00004992  4842      8275          swap    D2
00004994  C2C0      8276          mulu    D0,D1
00004996  C4C0      8277          mulu    D0,D2
00004998  4842      8278          swap    D2
0000499A  4242      8279          clr.w   D2
0000499C  D282      8280          add.l   D2,D1
0000499E  241F      8281          move.l  (A7)+,D2
000049A0  4E75      8282          rts
                    8283   domul_4:
000049A2  48E7 3000 8284          movem.l D2/D3,-(A7)
000049A6  2401      8285          move.l  D1,D2
000049A8  2601      8286          move.l  D1,D3
000049AA  C2C0      8287          mulu    D0,D1
000049AC  4842      8288          swap    D2
000049AE  C4C0      8289          mulu    D0,D2
000049B0  4840      8290          swap    D0
000049B2  C6C0      8291          mulu    D0,D3
000049B4  D483      8292          add.l   D3,D2
000049B6  4842      8293          swap    D2
000049B8  4242      8294          clr.w   D2
000049BA  D282      8295          add.l   D2,D1
000049BC  4CDF 000C 8296          movem.l (A7)+,D2/D3
000049C0  4E75      8297          rts
                    8298   _strlen:
000049C2  206F 0004 8299          move.l    (4,A7),A0
000049C6  2248      8300          move.l    A0,A1
                    8301   strlen_1:
000049C8  4A19      8302          tst.b     (A1)+
000049CA  66FC      8303          bne       strlen_1
000049CC  2009      8304          move.l    A1,D0
000049CE  9088      8305          sub.l     A0,D0
000049D0  5380      8306          subq.l    #1,D0
000049D2  4E75      8307          rts
                    8308          section   const
                    8309   
                    8310   @m68kde~3_1:
000049D4  0D0A 00   8311          dc.b      13,10,0
                    8312   @m68kde~3_2:
000049D8  0D53 7769 8313          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
000049DC  7463 6865 
000049E0  7320 5357 
000049E4  5B        
000049E5  372D 305D 8314          dc.b      55,45,48,93,32,61,32,0
000049E9  203D 2000 
                    8315   @m68kde~3_3:
000049EE  3000      8316          dc.b      48,0
                    8317   @m68kde~3_4:
000049F0  3100      8318          dc.b      49,0
                    8319   @m68kde~3_5:
000049F2  0D0A 4475 8320          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
000049F6  6D70 204D 
000049FA  656D 6F72 
000049FE  79        
000049FF  2042 6C6F 8321          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00004A03  636B 3A20 
00004A07  3C45 5343 
00004A0B  3E20      
00004A0D  746F 2041 8322          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00004A11  626F 7274 
00004A15  2C20 3C53 
00004A19  50        
00004A1A  4143 453E 8323          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00004A1E  2074 6F20 
00004A22  436F 6E74 
00004A26  69        
00004A27  6E75 6500 8324          dc.b      110,117,101,0
                    8325   @m68kde~3_6:
00004A2C  0D0A 456E 8326          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00004A30  7465 7220 
00004A34  5374 6172 
00004A38  74        
00004A39  2041 6464 8327          dc.b      32,65,100,100,114,101,115,115,58,32,0
00004A3D  7265 7373 
00004A41  3A20 00   
                    8328   @m68kde~3_7:
00004A44  0D0A 2530 8329          dc.b      13,10,37,48,56,120,32,0
00004A48  3878 2000 
                    8330   @m68kde~3_8:
00004A4C  2530 3258 8331          dc.b      37,48,50,88,0
00004A50  00        
                    8332   @m68kde~3_9:
00004A52  2020 00   8333          dc.b      32,32,0
                    8334   @m68kde~3_10:
00004A56  0D0A 4669 8335          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00004A5A  6C6C 204D 
00004A5E  656D 6F72 
00004A62  79        
00004A63  2042 6C6F 8336          dc.b      32,66,108,111,99,107,0
00004A67  636B 00   
                    8337   @m68kde~3_11:
00004A6A  0D0A 456E 8338          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00004A6E  7465 7220 
00004A72  456E 6420 
00004A76  41        
00004A77  6464 7265 8339          dc.b      100,100,114,101,115,115,58,32,0
00004A7B  7373 3A20 
00004A7F  00        
                    8340   @m68kde~3_12:
00004A80  0D0A 456E 8341          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00004A84  7465 7220 
00004A88  4669 6C6C 
00004A8C  20        
00004A8D  4461 7461 8342          dc.b      68,97,116,97,58,32,0
00004A91  3A20 00   
                    8343   @m68kde~3_13:
00004A94  0D0A 4669 8344          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00004A98  6C6C 696E 
00004A9C  6720 4164 
00004AA0  64        
00004AA1  7265 7373 8345          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00004AA5  6573 205B 
00004AA9  2425 3038 
00004AAD  58        
00004AAE  202D 2024 8346          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00004AB2  2530 3858 
00004AB6  5D20 7769 
00004ABA  7468      
00004ABC  2024 2530 8347          dc.b      32,36,37,48,50,88,0
00004AC0  3258 00   
                    8348   @m68kde~3_14:
00004AC4  0D0A 5573 8349          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00004AC8  6520 4879 
00004ACC  7065 7254 
00004AD0  65        
00004AD1  726D 696E 8350          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00004AD5  616C 2074 
00004AD9  6F20 5365 
00004ADD  6E64 2054 8351          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00004AE1  6578 7420 
00004AE5  4669 6C65 
00004AE9  2028 2E68 8352          dc.b      32,40,46,104,101,120,41,13,10,0
00004AED  6578 290D 
00004AF1  0A00      
                    8353   @m68kde~3_15:
00004AF4  0D0A 4C6F 8354          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00004AF8  6164 2046 
00004AFC  6169 6C65 
00004B00  64        
00004B01  2061 7420 8355          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00004B05  4164 6472 
00004B09  6573 7320 
00004B0D  3D        
00004B0E  205B 2425 8356          dc.b      32,91,36,37,48,56,88,93,13,10,0
00004B12  3038 585D 
00004B16  0D0A 00   
                    8357   @m68kde~3_16:
00004B1A  0D0A 5375 8358          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00004B1E  6363 6573 
00004B22  733A 2044 
00004B26  6F        
00004B27  776E 6C6F 8359          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00004B2B  6164 6564 
00004B2F  2025 6420 
00004B33  6279 7465 8360          dc.b      98,121,116,101,115,13,10,0
00004B37  730D 0A00 
                    8361   @m68kde~3_17:
00004B3C  0D0A 4578 8362          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00004B40  616D 696E 
00004B44  6520 616E 
00004B48  64        
00004B49  2043 6861 8363          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00004B4D  6E67 6520 
00004B51  4D65 6D6F 
00004B55  72        
00004B56  7900      8364          dc.b      121,0
                    8365   @m68kde~3_18:
00004B58  0D0A 3C45 8366          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00004B5C  5343 3E20 
00004B60  746F 2053 
00004B64  746F      
00004B66  702C 203C 8367          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00004B6A  5350 4143 
00004B6E  453E 2074 
00004B72  6F20      
00004B74  4164 7661 8368          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00004B78  6E63 652C 
00004B7C  2027 2D27 
00004B80  2074      
00004B82  6F20 476F 8369          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00004B86  2042 6163 
00004B8A  6B2C 203C 
00004B8E  4441      
00004B90  5441 3E20 8370          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00004B94  746F 2063 
00004B98  6861 6E67 
00004B9C  65        
00004B9D  00        8371          dc.b      0
                    8372   @m68kde~3_19:
00004B9E  0D0A 456E 8373          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00004BA2  7465 7220 
00004BA6  4164 6472 
00004BAA  65        
00004BAB  7373 3A20 8374          dc.b      115,115,58,32,0
00004BAF  00        
                    8375   @m68kde~3_20:
00004BB0  0D0A 5B25 8376          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00004BB4  3038 785D 
00004BB8  203A 2025 
00004BBC  3032 78   
00004BBF  2020 00   8377          dc.b      32,32,0
                    8378   @m68kde~3_21:
00004BC2  0D0A 5761 8379          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00004BC6  726E 696E 
00004BCA  6720 4368 
00004BCE  61        
00004BCF  6E67 6520 8380          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00004BD3  4661 696C 
00004BD7  6564 3A20 
00004BDB  57        
00004BDC  726F 7465 8381          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00004BE0  205B 2530 
00004BE4  3278 5D2C 
00004BE8  20        
00004BE9  5265 6164 8382          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00004BED  205B 2530 
00004BF1  3278 5D00 
                    8383   @m68kde~3_22:
00004BF6  0D0A 5072 8384          dc.b      13,10,80,114,111,103,114,97,109,109,105,110
00004BFA  6F67 7261 
00004BFE  6D6D 696E 
00004C02  6720 5350 8385          dc.b      103,32,83,80,73,32,70,108,97,115,104,46,46,46
00004C06  4920 466C 
00004C0A  6173 682E 
00004C0E  2E2E      
00004C10  2E00      8386          dc.b      46,0
                    8387   @m68kde~3_23:
00004C12  0D0A 5468 8388          dc.b      13,10,84,104,101,32,118,97,108,117,101,32,37
00004C16  6520 7661 
00004C1A  6C75 6520 
00004C1E  25        
00004C1F  7820 6174 8389          dc.b      120,32,97,116,32,97,100,100,114,101,115,115
00004C23  2061 6464 
00004C27  7265 7373 
00004C2B  2025 7820 8390          dc.b      32,37,120,32,105,110,32,83,68,82,65,77,32,105
00004C2F  696E 2053 
00004C33  4452 414D 
00004C37  2069      
00004C39  7320 6E6F 8391          dc.b      115,32,110,111,116,32,101,113,117,97,108,32
00004C3D  7420 6571 
00004C41  7561 6C20 
00004C45  746F 2074 8392          dc.b      116,111,32,116,104,101,32,118,97,108,117,101
00004C49  6865 2076 
00004C4D  616C 7565 
00004C51  2025 7820 8393          dc.b      32,37,120,32,97,116,32,70,108,97,115,104,32
00004C55  6174 2046 
00004C59  6C61 7368 
00004C5D  20        
00004C5E  4164 6472 8394          dc.b      65,100,100,114,101,115,115,32,37,120,0
00004C62  6573 7320 
00004C66  2578 00   
                    8395   @m68kde~3_24:
00004C6A  0D0A 416C 8396          dc.b      13,10,65,108,108,32,97,100,100,114,101,115,115
00004C6E  6C20 6164 
00004C72  6472 6573 
00004C76  73        
00004C77  6573 2068 8397          dc.b      101,115,32,104,97,118,101,32,98,101,101,110
00004C7B  6176 6520 
00004C7F  6265 656E 
00004C83  2063 6F70 8398          dc.b      32,99,111,112,105,101,100,32,105,110,116,111
00004C87  6965 6420 
00004C8B  696E 746F 
00004C8F  2053 5049 8399          dc.b      32,83,80,73,32,70,108,97,115,104,32,99,111,114
00004C93  2046 6C61 
00004C97  7368 2063 
00004C9B  6F72      
00004C9D  7265 6374 8400          dc.b      114,101,99,116,108,121,0
00004CA1  6C79 00   
                    8401   @m68kde~3_25:
00004CA4  0D0A 4C6F 8402          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
00004CA8  6164 696E 
00004CAC  6720 5072 
00004CB0  6F        
00004CB1  6772 616D 8403          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
00004CB5  2046 726F 
00004CB9  6D20 5350 
00004CBD  49        
00004CBE  2046 6C61 8404          dc.b      32,70,108,97,115,104,46,46,46,46,0
00004CC2  7368 2E2E 
00004CC6  2E2E 00   
                    8405   @m68kde~3_26:
00004CCA  0D0A 5072 8406          dc.b      13,10,80,114,111,103,114,97,109,32,100,111,110
00004CCE  6F67 7261 
00004CD2  6D20 646F 
00004CD6  6E        
00004CD7  6520 6C6F 8407          dc.b      101,32,108,111,97,100,105,110,103,0
00004CDB  6164 696E 
00004CDF  6700      
                    8408   @m68kde~3_27:
00004CE2  2425 3038 8409          dc.b      36,37,48,56,88,32,32,0
00004CE6  5820 2000 
                    8410   @m68kde~3_28:
00004CEA  2000      8411          dc.b      32,0
                    8412   @m68kde~3_29:
00004CEC  2E00      8413          dc.b      46,0
                    8414   @m68kde~3_30:
00004CEE  2563 00   8415          dc.b      37,99,0
                    8416   @m68kde~3_31:
00004CF2  00        8417          dc.b      0
                    8418   @m68kde~3_32:
00004CF4  0D0A 0D0A 8419          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
00004CF8  2044 3020 
00004CFC  3D20 2425 
00004D00  3038 58   
00004D03  2020 4130 8420          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
00004D07  203D 2024 
00004D0B  2530 3858 
00004D0F  00        
                    8421   @m68kde~3_33:
00004D10  0D0A 2044 8422          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
00004D14  3120 3D20 
00004D18  2425 3038 
00004D1C  5820 20   
00004D1F  4131 203D 8423          dc.b      65,49,32,61,32,36,37,48,56,88,0
00004D23  2024 2530 
00004D27  3858 00   
                    8424   @m68kde~3_34:
00004D2A  0D0A 2044 8425          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00004D2E  3220 3D20 
00004D32  2425 3038 
00004D36  5820 20   
00004D39  4132 203D 8426          dc.b      65,50,32,61,32,36,37,48,56,88,0
00004D3D  2024 2530 
00004D41  3858 00   
                    8427   @m68kde~3_35:
00004D44  0D0A 2044 8428          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00004D48  3320 3D20 
00004D4C  2425 3038 
00004D50  5820 20   
00004D53  4133 203D 8429          dc.b      65,51,32,61,32,36,37,48,56,88,0
00004D57  2024 2530 
00004D5B  3858 00   
                    8430   @m68kde~3_36:
00004D5E  0D0A 2044 8431          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
00004D62  3420 3D20 
00004D66  2425 3038 
00004D6A  5820 20   
00004D6D  4134 203D 8432          dc.b      65,52,32,61,32,36,37,48,56,88,0
00004D71  2024 2530 
00004D75  3858 00   
                    8433   @m68kde~3_37:
00004D78  0D0A 2044 8434          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
00004D7C  3520 3D20 
00004D80  2425 3038 
00004D84  5820 20   
00004D87  4135 203D 8435          dc.b      65,53,32,61,32,36,37,48,56,88,0
00004D8B  2024 2530 
00004D8F  3858 00   
                    8436   @m68kde~3_38:
00004D92  0D0A 2044 8437          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
00004D96  3620 3D20 
00004D9A  2425 3038 
00004D9E  5820 20   
00004DA1  4136 203D 8438          dc.b      65,54,32,61,32,36,37,48,56,88,0
00004DA5  2024 2530 
00004DA9  3858 00   
                    8439   @m68kde~3_39:
00004DAC  0D0A 2044 8440          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
00004DB0  3720 3D20 
00004DB4  2425 3038 
00004DB8  5820 20   
00004DBB  4137 203D 8441          dc.b      65,55,32,61,32,36,37,48,56,88,0
00004DBF  2024 2530 
00004DC3  3858 00   
                    8442   @m68kde~3_40:
00004DC6  0D0A 0D0A 8443          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
00004DCA  5553 5020 
00004DCE  3D20 2425 
00004DD2  3038 58   
00004DD5  2020 2841 8444          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
00004DD9  3729 2055 
00004DDD  7365 7220 
00004DE1  5350      
00004DE3  00        8445          dc.b      0
                    8446   @m68kde~3_41:
00004DE4  0D0A 5353 8447          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
00004DE8  5020 3D20 
00004DEC  2425 3038 
00004DF0  5820 20   
00004DF3  2841 3729 8448          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
00004DF7  2053 7570 
00004DFB  6572 7669 
00004DFF  73        
00004E00  6F72 2053 8449          dc.b      111,114,32,83,80,0
00004E04  5000      
                    8450   @m68kde~3_42:
00004E06  0D0A 2053 8451          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
00004E0A  5220 3D20 
00004E0E  2425 3034 
00004E12  5820 20   
00004E15  2000      8452          dc.b      32,0
                    8453   @m68kde~3_43:
00004E18  2020 205B 8454          dc.b      32,32,32,91,0
00004E1C  00        
                    8455   @m68kde~3_44:
00004E1E  0D0A 2050 8456          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00004E22  4320 3D20 
00004E26  2425 3038 
00004E2A  5820 20   
00004E2D  00        8457          dc.b      0
                    8458   @m68kde~3_45:
00004E2E  5B40 2042 8459          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
00004E32  5245 414B 
00004E36  504F 494E 
00004E3A  545D 00   
                    8460   @m68kde~3_46:
00004E3E  0D0A 5750 8461          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00004E42  2564 203D 
00004E46  2025 7300 
                    8462   @m68kde~3_47:
00004E4A  0D0A 0D0A 8463          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00004E4E  0D0A 0D0A 
00004E52  0D0A 0D0A 
00004E56  5369 6E   
00004E59  676C 6520 8464          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
00004E5D  5374 6570 
00004E61  2020 3A5B 
00004E65  4F        
00004E66  4E5D 00   8465          dc.b      78,93,0
                    8466   @m68kde~3_48:
00004E6A  0D0A 4272 8467          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004E6E  6561 6B20 
00004E72  506F 696E 
00004E76  74        
00004E77  7320 3A5B 8468          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00004E7B  4469 7361 
00004E7F  626C 6564 
00004E83  5D        
00004E84  00        8469          dc.b      0
                    8470   @m68kde~3_49:
00004E86  0D0A 5072 8471          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00004E8A  6573 7320 
00004E8E  3C53 5041 
00004E92  4345      
00004E94  3E20 746F 8472          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00004E98  2045 7865 
00004E9C  6375 7465 
00004EA0  20        
00004EA1  4E65 7874 8473          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
00004EA5  2049 6E73 
00004EA9  7472 7563 
00004EAD  7469 6F6E 8474          dc.b      116,105,111,110,0
00004EB1  00        
                    8475   @m68kde~3_50:
00004EB2  0D0A 5072 8476          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004EB6  6573 7320 
00004EBA  3C45 5343 
00004EBE  3E20      
00004EC0  746F 2052 8477          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
00004EC4  6573 756D 
00004EC8  6520 5072 
00004ECC  6F67 7261 8478          dc.b      111,103,114,97,109,0
00004ED0  6D00      
                    8479   @m68kde~3_51:
00004ED2  0D0A 496C 8480          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00004ED6  6C65 6761 
00004EDA  6C20 4461 
00004EDE  74        
00004EDF  6120 5265 8481          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
00004EE3  6769 7374 
00004EE7  6572 203A 
00004EEB  20        
00004EEC  5573 6520 8482          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
00004EF0  4430 2D44 
00004EF4  372E 2E2E 
00004EF8  2E2E      
00004EFA  0D0A 00   8483          dc.b      13,10,0
                    8484   @m68kde~3_52:
00004EFE  0D0A 4425 8485          dc.b      13,10,68,37,99,32,61,32,0
00004F02  6320 3D20 
00004F06  00        
                    8486   @m68kde~3_53:
00004F08  0D0A 496C 8487          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
00004F0C  6C65 6761 
00004F10  6C20 4164 
00004F14  64        
00004F15  7265 7373 8488          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
00004F19  2052 6567 
00004F1D  6973 7465 
00004F21  7220 3A20 8489          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
00004F25  5573 6520 
00004F29  4130 2D41 
00004F2D  372E      
00004F2F  2E2E 2E2E 8490          dc.b      46,46,46,46,13,10,0
00004F33  0D0A 00   
                    8491   @m68kde~3_54:
00004F36  0D0A 4125 8492          dc.b      13,10,65,37,99,32,61,32,0
00004F3A  6320 3D20 
00004F3E  00        
                    8493   @m68kde~3_55:
00004F40  0D0A 5573 8494          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00004F44  6572 2053 
00004F48  5020 3D20 
00004F4C  00        
                    8495   @m68kde~3_56:
00004F4E  0D0A 496C 8496          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004F52  6C65 6761 
00004F56  6C20 5265 
00004F5A  67        
00004F5B  6973 7465 8497          dc.b      105,115,116,101,114,46,46,46,46,0
00004F5F  722E 2E2E 
00004F63  2E00      
                    8498   @m68kde~3_57:
00004F66  0D0A 5379 8499          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00004F6A  7374 656D 
00004F6E  2053 5020 
00004F72  3D        
00004F73  2000      8500          dc.b      32,0
                    8501   @m68kde~3_58:
00004F76  0D0A 5043 8502          dc.b      13,10,80,67,32,61,32,0
00004F7A  203D 2000 
                    8503   @m68kde~3_59:
00004F7E  0D0A 5352 8504          dc.b      13,10,83,82,32,61,32,0
00004F82  203D 2000 
                    8505   @m68kde~3_60:
00004F86  0D0A 496C 8506          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004F8A  6C65 6761 
00004F8E  6C20 5265 
00004F92  67        
00004F93  6973 7465 8507          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00004F97  723A 2055 
00004F9B  7365 2041 
00004F9F  30        
00004FA0  2D41 372C 8508          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00004FA4  2044 302D 
00004FA8  4437 2C20 
00004FAC  5353 50   
00004FAF  2C20 5553 8509          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
00004FB3  502C 2050 
00004FB7  4320 6F72 
00004FBB  2053      
00004FBD  520D 0A00 8510          dc.b      82,13,10,0
                    8511   @m68kde~3_61:
00004FC2  0D0A 0D0A 8512          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00004FC6  4E75 6D20 
00004FCA  2020 2020 
00004FCE  4164      
00004FD0  6472 6573 8513          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
00004FD4  7320 2020 
00004FD8  2020 2049 
00004FDC  6E        
00004FDD  7374 7275 8514          dc.b      115,116,114,117,99,116,105,111,110,0
00004FE1  6374 696F 
00004FE5  6E00      
                    8515   @m68kde~3_62:
00004FE8  0D0A 2D2D 8516          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00004FEC  2D20 2020 
00004FF0  2020 2D2D 
00004FF4  2D2D 2D   
00004FF7  2D2D 2D2D 8517          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
00004FFB  2020 2020 
00004FFF  2D2D 2D2D 
00005003  2D2D 2D   
00005006  2D2D 2D2D 8518          dc.b      45,45,45,45,0
0000500A  00        
                    8519   @m68kde~3_63:
0000500C  0D0A 4E6F 8520          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
00005010  2042 7265 
00005014  616B 506F 
00005018  69        
00005019  6E74 7320 8521          dc.b      110,116,115,32,83,101,116,0
0000501D  5365 7400 
                    8522   @m68kde~3_64:
00005022  0D0A 2533 8523          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00005026  6420 2020 
0000502A  2020 2425 
0000502E  3038 78   
00005031  00        8524          dc.b      0
                    8525   @m68kde~3_65:
00005032  0D0A 4E75 8526          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00005036  6D20 2020 
0000503A  2020 4164 
0000503E  6472      
00005040  6573 7300 8527          dc.b      101,115,115,0
                    8528   @m68kde~3_66:
00005044  0D0A 2D2D 8529          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00005048  2D20 2020 
0000504C  2020 2D2D 
00005050  2D2D 2D   
00005053  2D2D 2D2D 8530          dc.b      45,45,45,45,0
00005057  00        
                    8531   @m68kde~3_67:
00005058  0D0A 4E6F 8532          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
0000505C  2057 6174 
00005060  6368 506F 
00005064  69        
00005065  6E74 7320 8533          dc.b      110,116,115,32,83,101,116,0
00005069  5365 7400 
                    8534   @m68kde~3_68:
0000506E  0D0A 456E 8535          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00005072  7465 7220 
00005076  4272 6561 
0000507A  6B        
0000507B  2050 6F69 8536          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
0000507F  6E74 204E 
00005083  756D 6265 
00005087  72        
00005088  3A20 00   8537          dc.b      58,32,0
                    8538   @m68kde~3_69:
0000508C  0D0A 496C 8539          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00005090  6C65 6761 
00005094  6C20 5261 
00005098  6E        
00005099  6765 203A 8540          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
0000509D  2055 7365 
000050A1  2030 202D 
000050A5  2037      
000050A7  00        8541          dc.b      0
                    8542   @m68kde~3_70:
000050A8  0D0A 4272 8543          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000050AC  6561 6B20 
000050B0  506F 696E 
000050B4  74        
000050B5  2043 6C65 8544          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000050B9  6172 6564 
000050BD  2E2E 2E2E 
000050C1  2E        
000050C2  0D0A 00   8545          dc.b      13,10,0
                    8546   @m68kde~3_71:
000050C6  0D0A 4272 8547          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000050CA  6561 6B20 
000050CE  506F 696E 
000050D2  74        
000050D3  2077 6173 8548          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
000050D7  6E27 7420 
000050DB  5365 742E 
000050DF  2E        
000050E0  2E2E 2E00 8549          dc.b      46,46,46,0
                    8550   @m68kde~3_72:
000050E4  0D0A 456E 8551          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
000050E8  7465 7220 
000050EC  5761 7463 
000050F0  68        
000050F1  2050 6F69 8552          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000050F5  6E74 204E 
000050F9  756D 6265 
000050FD  72        
000050FE  3A20 00   8553          dc.b      58,32,0
                    8554   @m68kde~3_73:
00005102  0D0A 5761 8555          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005106  7463 6820 
0000510A  506F 696E 
0000510E  74        
0000510F  2043 6C65 8556          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00005113  6172 6564 
00005117  2E2E 2E2E 
0000511B  2E        
0000511C  0D0A 00   8557          dc.b      13,10,0
                    8558   @m68kde~3_74:
00005120  0D0A 5761 8559          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005124  7463 6820 
00005128  506F 696E 
0000512C  74        
0000512D  2057 6173 8560          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
00005131  206E 6F74 
00005135  2053 6574 
00005139  2E        
0000513A  2E2E 2E2E 8561          dc.b      46,46,46,46,0
0000513E  00        
                    8562   @m68kde~3_75:
00005140  0D0A 4E6F 8563          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00005144  2046 5245 
00005148  4520 4272 
0000514C  6561      
0000514E  6B20 506F 8564          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00005152  696E 7473 
00005156  2E2E 2E2E 
0000515A  2E        
0000515B  00        8565          dc.b      0
                    8566   @m68kde~3_76:
0000515C  0D0A 4272 8567          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005160  6561 6B20 
00005164  506F 696E 
00005168  74        
00005169  2041 6464 8568          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000516D  7265 7373 
00005171  3A20 00   
                    8569   @m68kde~3_77:
00005174  0D0A 4572 8570          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00005178  726F 7220 
0000517C  3A20 4272 
00005180  65        
00005181  616B 2050 8571          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00005185  6F69 6E74 
00005189  7320 4341 
0000518D  4E        
0000518E  4E4F 5420 8572          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00005192  6265 2073 
00005196  6574 2061 
0000519A  74        
0000519B  204F 4444 8573          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
0000519F  2061 6464 
000051A3  7265 7373 
000051A7  65        
000051A8  7300      8574          dc.b      115,0
                    8575   @m68kde~3_78:
000051AA  0D0A 4572 8576          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
000051AE  726F 7220 
000051B2  3A20 4272 
000051B6  65        
000051B7  616B 2050 8577          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
000051BB  6F69 6E74 
000051BF  7320 4341 
000051C3  4E        
000051C4  4E4F 5420 8578          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
000051C8  6265 2073 
000051CC  6574 2066 
000051D0  6F        
000051D1  7220 524F 8579          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
000051D5  4D20 696E 
000051D9  2052 616E 
000051DD  67        
000051DE  6520 3A20 8580          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
000051E2  5B24 302D 
000051E6  2430 3030 
000051EA  3037 46   
000051ED  4646 5D00 8581          dc.b      70,70,93,0
                    8582   @m68kde~3_79:
000051F2  0D0A 4572 8583          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
000051F6  726F 723A 
000051FA  2042 7265 
000051FE  61        
000051FF  6B20 506F 8584          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
00005203  696E 7420 
00005207  416C 7265 
0000520B  6164 7920 8585          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
0000520F  4578 6973 
00005213  7473 2061 
00005217  74        
00005218  2041 6464 8586          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
0000521C  7265 7373 
00005220  203A 2025 
00005224  30        
00005225  3878 0D0A 8587          dc.b      56,120,13,10,0
00005229  00        
                    8588   @m68kde~3_80:
0000522A  0D0A 4272 8589          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000522E  6561 6B20 
00005232  506F 696E 
00005236  74        
00005237  2053 6574 8590          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
0000523B  2061 7420 
0000523F  4164 6472 
00005243  65        
00005244  7373 3A20 8591          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005248  5B24 2530 
0000524C  3878 5D00 
                    8592   @m68kde~3_81:
00005250  0D0A 4E6F 8593          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00005254  2046 5245 
00005258  4520 5761 
0000525C  7463      
0000525E  6820 506F 8594          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00005262  696E 7473 
00005266  2E2E 2E2E 
0000526A  2E        
0000526B  00        8595          dc.b      0
                    8596   @m68kde~3_82:
0000526C  0D0A 5761 8597          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005270  7463 6820 
00005274  506F 696E 
00005278  74        
00005279  2041 6464 8598          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000527D  7265 7373 
00005281  3A20 00   
                    8599   @m68kde~3_83:
00005284  0D0A 4572 8600          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00005288  726F 723A 
0000528C  2057 6174 
00005290  63        
00005291  6820 506F 8601          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00005295  696E 7420 
00005299  416C 7265 
0000529D  6164 7920 8602          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
000052A1  5365 7420 
000052A5  6174 2041 
000052A9  64        
000052AA  6472 6573 8603          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
000052AE  7320 3A20 
000052B2  2530 3878 
000052B6  0D        
000052B7  0A00      8604          dc.b      10,0
                    8605   @m68kde~3_84:
000052BA  0D0A 5761 8606          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000052BE  7463 6820 
000052C2  506F 696E 
000052C6  74        
000052C7  2053 6574 8607          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000052CB  2061 7420 
000052CF  4164 6472 
000052D3  65        
000052D4  7373 3A20 8608          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
000052D8  5B24 2530 
000052DC  3878 5D00 
                    8609   @m68kde~3_85:
000052E0  0D0A 0D0A 8610          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
000052E4  0D0A 0D0A 
000052E8  4042 5245 
000052EC  414B 50   
000052EF  4F49 4E54 8611          dc.b      79,73,78,84,0
000052F3  00        
                    8612   @m68kde~3_86:
000052F4  0D0A 5369 8613          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000052F8  6E67 6C65 
000052FC  2053 7465 
00005300  70        
00005301  203A 205B 8614          dc.b      32,58,32,91,79,78,93,0
00005305  4F4E 5D00 
                    8615   @m68kde~3_87:
0000530A  0D0A 4272 8616          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
0000530E  6561 6B50 
00005312  6F69 6E74 
00005316  73        
00005317  203A 205B 8617          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
0000531B  456E 6162 
0000531F  6C65 645D 
00005323  00        
                    8618   @m68kde~3_88:
00005324  0D0A 5072 8619          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005328  6573 7320 
0000532C  3C45 5343 
00005330  3E20      
00005332  746F 2052 8620          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00005336  6573 756D 
0000533A  6520 5573 
0000533E  6572 2050 8621          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00005342  726F 6772 
00005346  616D 0D0A 
0000534A  00        
                    8622   @m68kde~3_89:
0000534C  0D0A 556E 8623          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00005350  6B6E 6F77 
00005354  6E20 436F 
00005358  6D        
00005359  6D61 6E64 8624          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
0000535D  2E2E 2E2E 
00005361  2E0D 0A00 
                    8625   @m68kde~3_90:
00005366  0D0A 5072 8626          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
0000536A  6F67 7261 
0000536E  6D20 456E 
00005372  64        
00005373  6564 2028 8627          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00005377  5452 4150 
0000537B  2023 3135 
0000537F  292E      
00005381  2E2E 2E00 8628          dc.b      46,46,46,0
                    8629   @m68kde~3_91:
00005386  0D0A 4B69 8630          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
0000538A  6C6C 2041 
0000538E  6C6C 2042 
00005392  72        
00005393  6561 6B20 8631          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00005397  506F 696E 
0000539B  7473 2E2E 
0000539F  2E        
000053A0  2879 2F6E 8632          dc.b      40,121,47,110,41,63,0
000053A4  293F 00   
                    8633   @m68kde~3_92:
000053A8  0D0A 4B69 8634          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
000053AC  6C6C 2041 
000053B0  6C6C 2057 
000053B4  61        
000053B5  7463 6820 8635          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
000053B9  506F 696E 
000053BD  7473 2E2E 
000053C1  2E        
000053C2  2879 2F6E 8636          dc.b      40,121,47,110,41,63,0
000053C6  293F 00   
                    8637   @m68kde~3_93:
000053CA  0D0A 2D2D 8638          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
000053CE  2D2D 2D2D 
000053D2  2D2D 2D2D 
000053D6  2D2D 2D   
000053D9  2D2D 2D2D 8639          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000053DD  2D2D 2D2D 
000053E1  2D2D 2D2D 
000053E5  2D2D 2D   
000053E8  2D2D 2D2D 8640          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000053EC  2D2D 2D2D 
000053F0  2D2D 2D2D 
000053F4  2D2D 2D   
000053F7  2D2D 2D2D 8641          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000053FB  2D2D 2D2D 
000053FF  2D2D 2D2D 
00005403  2D2D 2D   
00005406  2D2D 2D2D 8642          dc.b      45,45,45,45,45,45,0
0000540A  2D2D 00   
                    8643   @m68kde~3_94:
0000540E  0D0A 2020 8644          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
00005412  4465 6275 
00005416  6767 6572 
0000541A  20        
0000541B  436F 6D6D 8645          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
0000541F  616E 6420 
00005423  5375 6D6D 
00005427  6172 7900 8646          dc.b      97,114,121,0
                    8647   @m68kde~3_95:
0000542C  0D0A 2020 8648          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
00005430  2E28 7265 
00005434  6729 2020 
00005438  2020      
0000543A  2020 202D 8649          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
0000543E  2043 6861 
00005442  6E67 6520 
00005446  5265      
00005448  6769 7374 8650          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
0000544C  6572 733A 
00005450  2065 2E67 
00005454  2041 302D 8651          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00005458  4137 2C44 
0000545C  302D 4437 
00005460  2C50 43   
00005463  2C53 5350 8652          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00005467  2C55 5350 
0000546B  2C53 5200 
                    8653   @m68kde~3_96:
00005470  0D0A 2020 8654          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00005474  4244 2F42 
00005478  532F 4243 
0000547C  2F42 4B   
0000547F  2020 2D20 8655          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00005483  4272 6561 
00005487  6B20 506F 
0000548B  69        
0000548C  6E74 3A20 8656          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00005490  4469 7370 
00005494  6C61 792F 
00005498  53        
00005499  6574 2F43 8657          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
0000549D  6C65 6172 
000054A1  2F4B 696C 
000054A5  6C        
000054A6  00        8658          dc.b      0
                    8659   @m68kde~3_97:
000054A8  0D0A 2020 8660          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
000054AC  4320 2020 
000054B0  2020 2020 
000054B4  2020 20   
000054B7  2020 2D20 8661          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
000054BB  436F 7079 
000054BF  2050 726F 
000054C3  67        
000054C4  7261 6D20 8662          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
000054C8  6672 6F6D 
000054CC  2046 6C61 
000054D0  73        
000054D1  6820 746F 8663          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
000054D5  204D 6169 
000054D9  6E20 4D65 
000054DD  6D        
000054DE  6F72 7900 8664          dc.b      111,114,121,0
                    8665   @m68kde~3_98:
000054E2  0D0A 2020 8666          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
000054E6  4420 2020 
000054EA  2020 2020 
000054EE  2020 20   
000054F1  2020 2D20 8667          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000054F5  4475 6D70 
000054F9  204D 656D 
000054FD  6F        
000054FE  7279 2043 8668          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
00005502  6F6E 7465 
00005506  6E74 7320 
0000550A  746F 2053 8669          dc.b      116,111,32,83,99,114,101,101,110,0
0000550E  6372 6565 
00005512  6E00      
                    8670   @m68kde~3_99:
00005514  0D0A 2020 8671          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
00005518  4520 2020 
0000551C  2020 2020 
00005520  2020 20   
00005523  2020 2D20 8672          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00005527  456E 7465 
0000552B  7220 5374 
0000552F  72        
00005530  696E 6720 8673          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00005534  696E 746F 
00005538  204D 656D 
0000553C  6F72 7900 8674          dc.b      111,114,121,0
                    8675   @m68kde~3_100:
00005540  0D0A 2020 8676          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00005544  4620 2020 
00005548  2020 2020 
0000554C  2020 20   
0000554F  2020 2D20 8677          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00005553  4669 6C6C 
00005557  204D 656D 
0000555B  6F        
0000555C  7279 2077 8678          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00005560  6974 6820 
00005564  4461 7461 
00005568  00        
                    8679   @m68kde~3_101:
0000556A  0D0A 2020 8680          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
0000556E  4720 2020 
00005572  2020 2020 
00005576  2020 20   
00005579  2020 2D20 8681          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
0000557D  476F 2050 
00005581  726F 6772 
00005585  61        
00005586  6D20 5374 8682          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
0000558A  6172 7469 
0000558E  6E67 2061 
00005592  74        
00005593  2041 6464 8683          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00005597  7265 7373 
0000559B  3A20 2425 
0000559F  30        
000055A0  3858 00   8684          dc.b      56,88,0
                    8685   @m68kde~3_102:
000055A4  0D0A 2020 8686          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
000055A8  4C20 2020 
000055AC  2020 2020 
000055B0  2020 20   
000055B3  2020 2D20 8687          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
000055B7  4C6F 6164 
000055BB  2050 726F 
000055BF  67        
000055C0  7261 6D20 8688          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
000055C4  282E 4845 
000055C8  5820 6669 
000055CC  6C        
000055CD  6529 2066 8689          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
000055D1  726F 6D20 
000055D5  4C61 7074 
000055D9  6F        
000055DA  7000      8690          dc.b      112,0
                    8691   @m68kde~3_103:
000055DC  0D0A 2020 8692          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
000055E0  4D20 2020 
000055E4  2020 2020 
000055E8  2020 20   
000055EB  2020 2D20 8693          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
000055EF  4D65 6D6F 
000055F3  7279 2045 
000055F7  78        
000055F8  616D 696E 8694          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
000055FC  6520 616E 
00005600  6420 4368 
00005604  61        
00005605  6E67 6500 8695          dc.b      110,103,101,0
                    8696   @m68kde~3_104:
0000560A  0D0A 2020 8697          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
0000560E  5020 2020 
00005612  2020 2020 
00005616  2020 20   
00005619  2020 2D20 8698          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
0000561D  5072 6F67 
00005621  7261 6D20 
00005625  46        
00005626  6C61 7368 8699          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
0000562A  204D 656D 
0000562E  6F72 7920 
00005632  7769 7468 8700          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00005636  2055 7365 
0000563A  7220 5072 
0000563E  6F67 7261 8701          dc.b      111,103,114,97,109,0
00005642  6D00      
                    8702   @m68kde~3_105:
00005644  0D0A 2020 8703          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00005648  5220 2020 
0000564C  2020 2020 
00005650  2020 20   
00005653  2020 2D20 8704          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00005657  4469 7370 
0000565B  6C61 7920 
0000565F  36        
00005660  3830 3030 8705          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00005664  2052 6567 
00005668  6973 7465 
0000566C  72        
0000566D  7300      8706          dc.b      115,0
                    8707   @m68kde~3_106:
00005670  0D0A 2020 8708          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00005674  5320 2020 
00005678  2020 2020 
0000567C  2020 20   
0000567F  2020 2D20 8709          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00005683  546F 6767 
00005687  6C65 204F 
0000568B  4E        
0000568C  2F4F 4646 8710          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00005690  2053 696E 
00005694  676C 6520 
00005698  53        
00005699  7465 7020 8711          dc.b      116,101,112,32,77,111,100,101,0
0000569D  4D6F 6465 
000056A1  00        
                    8712   @m68kde~3_107:
000056A2  0D0A 2020 8713          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
000056A6  544D 2020 
000056AA  2020 2020 
000056AE  2020 20   
000056B1  2020 2D20 8714          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
000056B5  5465 7374 
000056B9  204D 656D 
000056BD  6F        
000056BE  7279 00   8715          dc.b      114,121,0
                    8716   @m68kde~3_108:
000056C2  0D0A 2020 8717          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
000056C6  5453 2020 
000056CA  2020 2020 
000056CE  2020 20   
000056D1  2020 2D20 8718          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
000056D5  5465 7374 
000056D9  2053 7769 
000056DD  74        
000056DE  6368 6573 8719          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
000056E2  3A20 5357 
000056E6  372D 3000 
                    8720   @m68kde~3_109:
000056EA  0D0A 2020 8721          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
000056EE  5444 2020 
000056F2  2020 2020 
000056F6  2020 20   
000056F9  2020 2D20 8722          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
000056FD  5465 7374 
00005701  2044 6973 
00005705  70        
00005706  6C61 7973 8723          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
0000570A  3A20 4C45 
0000570E  4473 2061 
00005712  6E        
00005713  6420 372D 8724          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00005717  5365 676D 
0000571B  656E 7400 
                    8725   @m68kde~3_110:
00005720  0D0A 2020 8726          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00005724  5744 2F57 
00005728  532F 5743 
0000572C  2F57 4B   
0000572F  2020 2D20 8727          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00005733  5761 7463 
00005737  6820 506F 
0000573B  696E      
0000573D  743A 2044 8728          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00005741  6973 706C 
00005745  6179 2F53 
00005749  65        
0000574A  742F 436C 8729          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
0000574E  6561 722F 
00005752  4B69 6C6C 
00005756  00        
                    8730   @m68kde~3_111:
00005758  0D0A 2300 8731          dc.b      13,10,35,0
                    8732   @m68kde~3_112:
0000575C  0D0A 5072 8733          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00005760  6F67 7261 
00005764  6D20 5275 
00005768  6E        
00005769  6E69 6E67 8734          dc.b      110,105,110,103,46,46,46,46,46,0
0000576D  2E2E 2E2E 
00005771  2E00      
                    8735   @m68kde~3_113:
00005774  0D0A 5072 8736          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00005778  6573 7320 
0000577C  3C52 4553 
00005780  4554      
00005782  3E20 6275 8737          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00005786  7474 6F6E 
0000578A  203C 4B65 
0000578E  79        
0000578F  303E 206F 8738          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00005793  6E20 4445 
00005797  3120 746F 
0000579B  2073      
0000579D  746F 7000 8739          dc.b      116,111,112,0
                    8740   @m68kde~3_114:
000057A2  0D0A 4572 8741          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
000057A6  726F 723A 
000057AA  2050 7265 
000057AE  73        
000057AF  7320 2747 8742          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
000057B3  2720 6669 
000057B7  7273 7420 
000057BB  74        
000057BC  6F20 7374 8743          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
000057C0  6172 7420 
000057C4  7072 6F67 
000057C8  7261 6D00 8744          dc.b      114,97,109,0
                    8745   @m68kde~3_115:
000057CC  0D0A 5369 8746          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000057D0  6E67 6C65 
000057D4  2053 7465 
000057D8  70        
000057D9  2020 3A5B 8747          dc.b      32,32,58,91,79,78,93,0
000057DD  4F4E 5D00 
                    8748   @m68kde~3_116:
000057E2  0D0A 5072 8749          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
000057E6  6573 7320 
000057EA  2747 2720 
000057EE  74        
000057EF  6F20 5472 8750          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
000057F3  6163 6520 
000057F7  5072 6F67 
000057FB  72        
000057FC  616D 2066 8751          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00005800  726F 6D20 
00005804  6164 6472 
00005808  6573 7320 8752          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
0000580C  2425 582E 
00005810  2E2E 2E2E 
00005814  00        
                    8753   @m68kde~3_117:
00005816  0D0A 5075 8754          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
0000581A  7368 203C 
0000581E  5245 5345 
00005822  5420      
00005824  4275 7474 8755          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00005828  6F6E 3E20 
0000582C  746F 2053 
00005830  74        
00005831  6F70 2E2E 8756          dc.b      111,112,46,46,46,46,46,0
00005835  2E2E 2E00 
                    8757   @m68kde~3_118:
0000583A  0D0A 5369 8758          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
0000583E  6E67 6C65 
00005842  2053 7465 
00005846  70        
00005847  203A 205B 8759          dc.b      32,58,32,91,79,70,70,93,0
0000584B  4F46 465D 
0000584F  00        
                    8760   @m68kde~3_119:
00005850  0D0A 4272 8761          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005854  6561 6B20 
00005858  506F 696E 
0000585C  74        
0000585D  7320 3A5B 8762          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00005861  456E 6162 
00005865  6C65 645D 
00005869  00        
                    8763   @m68kde~3_120:
0000586A  0D0A 5072 8764          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
0000586E  6573 7320 
00005872  3C45 5343 
00005876  3E20      
00005878  746F 2052 8765          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
0000587C  6573 756D 
00005880  6520 5573 
00005884  6572 2050 8766          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00005888  726F 6772 
0000588C  616D 2E2E 
00005890  2E        
00005891  2E2E 00   8767          dc.b      46,46,0
                    8768   @m68kde~3_121:
00005894  0D0A 5369 8769          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005898  6E67 6C65 
0000589C  2053 7465 
000058A0  70        
000058A1  2020 3A5B 8770          dc.b      32,32,58,91,79,70,70,93,0
000058A5  4F46 465D 
000058A9  00        
                    8771   @m68kde~3_122:
000058AA  0D0A 0D0A 8772          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000058AE  5072 6F67 
000058B2  7261 6D20 
000058B6  41        
000058B7  424F 5254 8773          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
000058BB  2021 2121 
000058BF  2121 210D 
000058C3  0A00      
                    8774   @m68kde~3_123:
000058C6  2573 0D0A 8775          dc.b      37,115,13,10,0
000058CA  00        
                    8776   @m68kde~3_124:
000058CC  0D0A 0D0A 8777          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000058D0  5072 6F67 
000058D4  7261 6D20 
000058D8  41        
000058D9  424F 5254 8778          dc.b      66,79,82,84,32,33,33,33,33,33,0
000058DD  2021 2121 
000058E1  2121 00   
                    8779   @m68kde~3_125:
000058E4  0D0A 556E 8780          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
000058E8  6861 6E64 
000058EC  6C65 6420 
000058F0  49        
000058F1  6E74 6572 8781          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
000058F5  7275 7074 
000058F9  3A20 4952 
000058FD  5125 6420 8782          dc.b      81,37,100,32,33,33,33,33,33,0
00005901  2121 2121 
00005905  2100      
                    8783   @m68kde~3_126:
00005908  4144 4452 8784          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
0000590C  4553 5320 
00005910  4552 524F 
00005914  523A 20   
00005917  3136 206F 8785          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
0000591B  7220 3332 
0000591F  2042 6974 
00005923  2054      
00005925  7261 6E73 8786          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00005929  6665 7220 
0000592D  746F 2F66 
00005931  726F 6D20 8787          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00005935  616E 204F 
00005939  4444 2041 
0000593D  64        
0000593E  6472 6573 8788          dc.b      100,114,101,115,115,46,46,46,46,0
00005942  732E 2E2E 
00005946  2E00      
                    8789   @m68kde~3_127:
00005948  556E 6861 8790          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
0000594C  6E64 6C65 
00005950  6420 5472 
00005954  6170 2021 8791          dc.b      97,112,32,33,33,33,33,33,0
00005958  2121 2121 
0000595C  00        
                    8792   @m68kde~3_128:
0000595E  4255 5320 8793          dc.b      66,85,83,32,69,114,114,111,114,33,0
00005962  4572 726F 
00005966  7221 00   
                    8794   @m68kde~3_129:
0000596A  4144 4452 8795          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
0000596E  4553 5320 
00005972  4572 726F 
00005976  7221      
00005978  00        8796          dc.b      0
                    8797   @m68kde~3_130:
0000597A  494C 4C45 8798          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
0000597E  4741 4C20 
00005982  494E 5354 
00005986  5255 43   
00005989  5449 4F4E 8799          dc.b      84,73,79,78,0
0000598D  00        
                    8800   @m68kde~3_131:
0000598E  4449 5649 8801          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00005992  4445 2042 
00005996  5920 5A45 
0000599A  524F 00   
                    8802   @m68kde~3_132:
0000599E  2743 484B 8803          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
000059A2  2720 494E 
000059A6  5354 5255 
000059AA  4354 49   
000059AD  4F4E 00   8804          dc.b      79,78,0
                    8805   @m68kde~3_133:
000059B0  5452 4150 8806          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
000059B4  5620 494E 
000059B8  5354 5255 
000059BC  4354 49   
000059BF  4F4E 00   8807          dc.b      79,78,0
                    8808   @m68kde~3_134:
000059C2  5052 4956 8809          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
000059C6  494C 4547 
000059CA  4520 5649 
000059CE  4F4C 41   
000059D1  5449 4F4E 8810          dc.b      84,73,79,78,0
000059D5  00        
                    8811   @m68kde~3_135:
000059D6  554E 494E 8812          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
000059DA  4954 4941 
000059DE  4C49 5345 
000059E2  4420 49   
000059E5  5251 00   8813          dc.b      82,81,0
                    8814   @m68kde~3_136:
000059E8  5350 5552 8815          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
000059EC  494F 5553 
000059F0  2049 5251 
000059F4  00        
                    8816   @m68kde~3_137:
000059F6  0D0A 5374 8817          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
000059FA  6172 7420 
000059FE  4164 6472 
00005A02  65        
00005A03  7373 2069 8818          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00005A07  6E20 4D65 
00005A0B  6D6F 7279 
00005A0F  3A20 00   8819          dc.b      58,32,0
                    8820   @m68kde~3_138:
00005A12  0D0A 456E 8821          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00005A16  7465 7220 
00005A1A  5374 7269 
00005A1E  6E        
00005A1F  6720 2845 8822          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00005A23  5343 2074 
00005A27  6F20 656E 
00005A2B  64        
00005A2C  2920 3A00 8823          dc.b      41,32,58,0
                    8824   @m68kde~3_139:
00005A30  0D0A 456E 8825          dc.b      13,10,69,110,116,101,114,32,116,104,101,32,118
00005A34  7465 7220 
00005A38  7468 6520 
00005A3C  76        
00005A3D  616C 7565 8826          dc.b      97,108,117,101,32,98,101,108,111,119,32,102
00005A41  2062 656C 
00005A45  6F77 2066 
00005A49  6F72 2074 8827          dc.b      111,114,32,116,104,101,32,115,105,122,101,32
00005A4D  6865 2073 
00005A51  697A 6520 
00005A55  6F66 2074 8828          dc.b      111,102,32,116,104,101,32,116,101,115,116,32
00005A59  6865 2074 
00005A5D  6573 7420 
00005A61  796F 7520 8829          dc.b      121,111,117,32,119,111,117,108,100,32,108,105
00005A65  776F 756C 
00005A69  6420 6C69 
00005A6D  6B65 2074 8830          dc.b      107,101,32,116,111,32,117,115,101,63,10,49,32
00005A71  6F20 7573 
00005A75  653F 0A31 
00005A79  20        
00005A7A  3D20 6279 8831          dc.b      61,32,98,121,116,101,115,32,40,56,32,98,105
00005A7E  7465 7320 
00005A82  2838 2062 
00005A86  69        
00005A87  7473 290A 8832          dc.b      116,115,41,10,50,32,61,32,119,111,114,100,115
00005A8B  3220 3D20 
00005A8F  776F 7264 
00005A93  73        
00005A94  2028 3136 8833          dc.b      32,40,49,54,32,98,105,116,115,41,10,51,32,61
00005A98  2062 6974 
00005A9C  7329 0A33 
00005AA0  203D      
00005AA2  206C 6F6E 8834          dc.b      32,108,111,110,103,32,119,111,114,100,115,32
00005AA6  6720 776F 
00005AAA  7264 7320 
00005AAE  2833 3220 8835          dc.b      40,51,50,32,98,105,116,115,41,10,0
00005AB2  6269 7473 
00005AB6  290A 00   
                    8836   @m68kde~3_140:
00005ABA  0A59 6F75 8837          dc.b      10,89,111,117,32,104,97,118,101,32,115,101,108
00005ABE  2068 6176 
00005AC2  6520 7365 
00005AC6  6C        
00005AC7  6374 6564 8838          dc.b      99,116,101,100,32,116,111,32,117,115,101,32
00005ACB  2074 6F20 
00005ACF  7573 6520 
00005AD3  6279 7465 8839          dc.b      98,121,116,101,115,32,115,105,122,101,32,100
00005AD7  7320 7369 
00005ADB  7A65 2064 
00005ADF  6174 6120 8840          dc.b      97,116,97,32,116,111,32,116,101,115,116,32,121
00005AE3  746F 2074 
00005AE7  6573 7420 
00005AEB  79        
00005AEC  6F75 7220 8841          dc.b      111,117,114,32,109,101,109,111,114,121,10,0
00005AF0  6D65 6D6F 
00005AF4  7279 0A00 
                    8842   @m68kde~3_141:
00005AF8  4F75 7420 8843          dc.b      79,117,116,32,111,102,32,116,104,101,32,98,101
00005AFC  6F66 2074 
00005B00  6865 2062 
00005B04  65        
00005B05  6C6F 7720 8844          dc.b      108,111,119,32,101,120,97,109,112,108,101,32
00005B09  6578 616D 
00005B0D  706C 6520 
00005B11  7465 7374 8845          dc.b      116,101,115,116,32,100,97,116,97,44,32,112,108
00005B15  2064 6174 
00005B19  612C 2070 
00005B1D  6C        
00005B1E  6561 7365 8846          dc.b      101,97,115,101,32,115,101,108,101,99,116,32
00005B22  2073 656C 
00005B26  6563 7420 
00005B2A  6F6E 6520 8847          dc.b      111,110,101,32,98,121,32,101,110,116,101,114
00005B2E  6279 2065 
00005B32  6E74 6572 
00005B36  696E 6720 8848          dc.b      105,110,103,32,116,104,101,32,118,97,108,117
00005B3A  7468 6520 
00005B3E  7661 6C75 
00005B42  6520 6173 8849          dc.b      101,32,97,115,115,111,99,105,97,116,101,100
00005B46  736F 6369 
00005B4A  6174 6564 
00005B4E  2074 6F20 8850          dc.b      32,116,111,32,101,97,99,104,32,101,120,97,109
00005B52  6561 6368 
00005B56  2065 7861 
00005B5A  6D        
00005B5B  706C 653A 8851          dc.b      112,108,101,58,10,0
00005B5F  0A00      
                    8852   @m68kde~3_142:
00005B62  3120 3D20 8853          dc.b      49,32,61,32,34,65,65,34,10,50,32,61,32,34,65
00005B66  2241 4122 
00005B6A  0A32 203D 
00005B6E  2022 41   
00005B71  4222 0A33 8854          dc.b      66,34,10,51,32,61,32,34,67,67,34,10,52,32,61
00005B75  203D 2022 
00005B79  4343 220A 
00005B7D  3420 3D   
00005B80  2022 4344 8855          dc.b      32,34,67,68,34,10,0
00005B84  220A 00   
                    8856   @m68kde~3_143:
00005B88  0D0A 4552 8857          dc.b      13,10,69,82,82,79,82,58,32,89,111,117,32,104
00005B8C  524F 523A 
00005B90  2059 6F75 
00005B94  2068      
00005B96  6176 6520 8858          dc.b      97,118,101,32,101,110,116,101,114,101,100,32
00005B9A  656E 7465 
00005B9E  7265 6420 
00005BA2  6120 6B65 8859          dc.b      97,32,107,101,121,98,111,97,114,100,32,105,110
00005BA6  7962 6F61 
00005BAA  7264 2069 
00005BAE  6E        
00005BAF  7075 7420 8860          dc.b      112,117,116,32,116,104,97,116,32,100,111,101
00005BB3  7468 6174 
00005BB7  2064 6F65 
00005BBB  7320 6E6F 8861          dc.b      115,32,110,111,116,32,97,115,115,111,99,105
00005BBF  7420 6173 
00005BC3  736F 6369 
00005BC7  6174 6564 8862          dc.b      97,116,101,100,32,119,105,116,104,32,97,110
00005BCB  2077 6974 
00005BCF  6820 616E 
00005BD3  206F 7074 8863          dc.b      32,111,112,116,105,111,110,32,97,98,111,118
00005BD7  696F 6E20 
00005BDB  6162 6F76 
00005BDF  652C 2070 8864          dc.b      101,44,32,112,108,101,97,115,101,32,116,114
00005BE3  6C65 6173 
00005BE7  6520 7472 
00005BEB  7920 6167 8865          dc.b      121,32,97,103,97,105,110,13,10,0
00005BEF  6169 6E0D 
00005BF3  0A00      
                    8866   @m68kde~3_144:
00005BF6  0D0A 4552 8867          dc.b      13,10,69,82,82,79,82,58,32,79,112,116,105,111
00005BFA  524F 523A 
00005BFE  204F 7074 
00005C02  696F      
00005C04  6E20 6D65 8868          dc.b      110,32,109,101,109,111,114,121,32,99,111,109
00005C08  6D6F 7279 
00005C0C  2063 6F6D 
00005C10  706C 6963 8869          dc.b      112,108,105,99,97,116,105,111,110,46,32,69,120
00005C14  6174 696F 
00005C18  6E2E 2045 
00005C1C  78        
00005C1D  6974 696E 8870          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00005C21  6720 6D65 
00005C25  6D6F 7279 
00005C29  2074 6573 8871          dc.b      32,116,101,115,116,46,46,46,13,10,0
00005C2D  742E 2E2E 
00005C31  0D0A 00   
                    8872   @m68kde~3_145:
00005C34  0D0A 506C 8873          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00005C38  6561 7365 
00005C3C  2065 6E74 
00005C40  65        
00005C41  7220 7468 8874          dc.b      114,32,116,104,101,32,115,116,97,114,116,32
00005C45  6520 7374 
00005C49  6172 7420 
00005C4D  6164 6472 8875          dc.b      97,100,100,114,101,115,115,32,121,111,117,32
00005C51  6573 7320 
00005C55  796F 7520 
00005C59  776F 756C 8876          dc.b      119,111,117,108,100,32,108,105,107,101,32,116
00005C5D  6420 6C69 
00005C61  6B65 2074 
00005C65  6F20 7573 8877          dc.b      111,32,117,115,101,32,102,111,114,32,116,104
00005C69  6520 666F 
00005C6D  7220 7468 
00005C71  6520 7465 8878          dc.b      101,32,116,101,115,116,32,100,97,116,97,32,105
00005C75  7374 2064 
00005C79  6174 6120 
00005C7D  69        
00005C7E  6E74 6F20 8879          dc.b      110,116,111,32,109,101,109,111,114,121,13,10
00005C82  6D65 6D6F 
00005C86  7279 0D0A 
00005C8A  00        8880          dc.b      0
                    8881   @m68kde~3_146:
00005C8C  0D0A 4552 8882          dc.b      13,10,69,82,82,79,82,58,32,83,116,97,114,116
00005C90  524F 523A 
00005C94  2053 7461 
00005C98  7274      
00005C9A  696E 6720 8883          dc.b      105,110,103,32,65,100,100,114,101,115,115,32
00005C9E  4164 6472 
00005CA2  6573 7320 
00005CA6  6973 206F 8884          dc.b      105,115,32,111,117,116,115,105,100,101,32,111
00005CAA  7574 7369 
00005CAE  6465 206F 
00005CB2  6620 3638 8885          dc.b      102,32,54,56,75,32,109,101,109,111,114,121,32
00005CB6  4B20 6D65 
00005CBA  6D6F 7279 
00005CBE  20        
00005CBF  7261 6E67 8886          dc.b      114,97,110,103,101,46,32,80,108,101,97,115,101
00005CC3  652E 2050 
00005CC7  6C65 6173 
00005CCB  65        
00005CCC  2074 7279 8887          dc.b      32,116,114,121,32,97,103,97,105,110,32,97,110
00005CD0  2061 6761 
00005CD4  696E 2061 
00005CD8  6E        
00005CD9  6420 656E 8888          dc.b      100,32,101,110,115,117,114,101,32,116,104,101
00005CDD  7375 7265 
00005CE1  2074 6865 
00005CE5  2061 6464 8889          dc.b      32,97,100,100,114,101,115,115,32,105,115,32
00005CE9  7265 7373 
00005CED  2069 7320 
00005CF1  7769 7468 8890          dc.b      119,105,116,104,110,32,48,120,48,56,48,50,48
00005CF5  6E20 3078 
00005CF9  3038 3032 
00005CFD  30        
00005CFE  3030 3020 8891          dc.b      48,48,48,32,45,32,48,120,48,57,55,70,70,70,70
00005D02  2D20 3078 
00005D06  3039 3746 
00005D0A  4646 46   
00005D0D  460D 0A00 8892          dc.b      70,13,10,0
                    8893   @m68kde~3_147:
00005D12  0D0A 506C 8894          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00005D16  6561 7365 
00005D1A  2065 6E74 
00005D1E  65        
00005D1F  7220 7468 8895          dc.b      114,32,116,104,101,32,101,110,100,32,97,100
00005D23  6520 656E 
00005D27  6420 6164 
00005D2B  6472 6573 8896          dc.b      100,114,101,115,115,32,121,111,117,32,119,111
00005D2F  7320 796F 
00005D33  7520 776F 
00005D37  756C 6420 8897          dc.b      117,108,100,32,108,105,107,101,32,116,111,32
00005D3B  6C69 6B65 
00005D3F  2074 6F20 
00005D43  7573 6520 8898          dc.b      117,115,101,32,102,111,114,32,116,104,101,32
00005D47  666F 7220 
00005D4B  7468 6520 
00005D4F  7465 7374 8899          dc.b      116,101,115,116,32,100,97,116,97,32,105,110
00005D53  2064 6174 
00005D57  6120 696E 
00005D5B  206D 656D 8900          dc.b      32,109,101,109,111,114,121,13,10,0
00005D5F  6F72 790D 
00005D63  0A00      
                    8901   @m68kde~3_148:
00005D66  0D0A 4552 8902          dc.b      13,10,69,82,82,79,82,58,32,69,110,100,32,65
00005D6A  524F 523A 
00005D6E  2045 6E64 
00005D72  2041      
00005D74  6464 7265 8903          dc.b      100,100,114,101,115,115,32,105,115,32,111,117
00005D78  7373 2069 
00005D7C  7320 6F75 
00005D80  7473 6964 8904          dc.b      116,115,105,100,101,32,111,102,32,54,56,75,32
00005D84  6520 6F66 
00005D88  2036 384B 
00005D8C  20        
00005D8D  6D65 6D6F 8905          dc.b      109,101,109,111,114,121,32,114,97,110,103,101
00005D91  7279 2072 
00005D95  616E 6765 
00005D99  2E20 506C 8906          dc.b      46,32,80,108,101,97,115,101,32,116,114,121,32
00005D9D  6561 7365 
00005DA1  2074 7279 
00005DA5  20        
00005DA6  6167 6169 8907          dc.b      97,103,97,105,110,32,97,110,100,32,101,110,115
00005DAA  6E20 616E 
00005DAE  6420 656E 
00005DB2  73        
00005DB3  7572 6520 8908          dc.b      117,114,101,32,116,104,101,32,97,100,100,114
00005DB7  7468 6520 
00005DBB  6164 6472 
00005DBF  6573 7320 8909          dc.b      101,115,115,32,105,115,32,119,105,116,104,110
00005DC3  6973 2077 
00005DC7  6974 686E 
00005DCB  2030 7830 8910          dc.b      32,48,120,48,56,48,50,48,48,48,48,32,45,32,48
00005DCF  3830 3230 
00005DD3  3030 3020 
00005DD7  2D20 30   
00005DDA  7830 3937 8911          dc.b      120,48,57,55,70,70,70,70,70,13,10,0
00005DDE  4646 4646 
00005DE2  460D 0A00 
                    8912   @m68kde~3_149:
00005DE6  0D0A 0D0A 8913          dc.b      13,10,13,10,87,114,105,116,105,110,103,32,116
00005DEA  5772 6974 
00005DEE  696E 6720 
00005DF2  74        
00005DF3  6F20 6D65 8914          dc.b      111,32,109,101,109,111,114,121,0
00005DF7  6D6F 7279 
00005DFB  00        
                    8915   @m68kde~3_150:
00005DFC  0D0A 5752 8916          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,50,88,32
00005E00  4954 453A 
00005E04  205B 2530 
00005E08  3258 20   
00005E0B  746F 2025 8917          dc.b      116,111,32,37,48,56,120,93,0
00005E0F  3038 785D 
00005E13  00        
                    8918   @m68kde~3_151:
00005E14  0D0A 0D0A 8919          dc.b      13,10,13,10,83,116,97,114,116,105,110,103,32
00005E18  5374 6172 
00005E1C  7469 6E67 
00005E20  20        
00005E21  6D65 6D6F 8920          dc.b      109,101,109,111,114,121,32,118,97,108,105,100
00005E25  7279 2076 
00005E29  616C 6964 
00005E2D  6174 696F 8921          dc.b      97,116,105,111,110,32,116,101,115,116,0
00005E31  6E20 7465 
00005E35  7374 00   
                    8922   @m68kde~3_152:
00005E38  0D0A 5665 8923          dc.b      13,10,86,101,114,105,102,121,105,110,103,32
00005E3C  7269 6679 
00005E40  696E 6720 
00005E44  7468 6520 8924          dc.b      116,104,101,32,97,100,100,114,101,115,115,101
00005E48  6164 6472 
00005E4C  6573 7365 
00005E50  7320 5B25 8925          dc.b      115,32,91,37,48,56,120,32,116,111,32,37,48,56
00005E54  3038 7820 
00005E58  746F 2025 
00005E5C  3038      
00005E5E  785D 2063 8926          dc.b      120,93,32,99,111,110,116,97,105,110,115,32,116
00005E62  6F6E 7461 
00005E66  696E 7320 
00005E6A  74        
00005E6B  6573 7420 8927          dc.b      101,115,116,32,100,97,116,97,32,91,37,48,50
00005E6F  6461 7461 
00005E73  205B 2530 
00005E77  32        
00005E78  585D 2E2E 8928          dc.b      88,93,46,46,46,46,46,0
00005E7C  2E2E 2E00 
                    8929   @m68kde~3_153:
00005E80  0D0A 4552 8930          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
00005E84  524F 523A 
00005E88  2044 6174 
00005E8C  6120 77   
00005E8F  6974 6869 8931          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
00005E93  6E20 6D65 
00005E97  6D6F 7279 
00005E9B  2064 6F65 8932          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
00005E9F  7320 6E6F 
00005EA3  7420 6D61 
00005EA7  7463 6820 8933          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
00005EAB  7365 6C65 
00005EAF  6374 6564 
00005EB3  2074 6573 8934          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
00005EB7  7420 6461 
00005EBB  7461 2120 
00005EBF  5B        
00005EC0  4164 6472 8935          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
00005EC4  6573 733A 
00005EC8  2025 3038 
00005ECC  78        
00005ECD  2045 7861 8936          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
00005ED1  6374 2044 
00005ED5  6174 613A 
00005ED9  2025      
00005EDB  3032 5820 8937          dc.b      48,50,88,32,69,120,112,101,99,116,101,100,32
00005EDF  4578 7065 
00005EE3  6374 6564 
00005EE7  20        
00005EE8  4461 7461 8938          dc.b      68,97,116,97,58,32,37,48,50,88,93,32,69,120
00005EEC  3A20 2530 
00005EF0  3258 5D20 
00005EF4  4578      
00005EF6  6974 696E 8939          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00005EFA  6720 6D65 
00005EFE  6D6F 7279 
00005F02  2074 6573 8940          dc.b      32,116,101,115,116,46,46,46,13,10,0
00005F06  742E 2E2E 
00005F0A  0D0A 00   
                    8941   @m68kde~3_154:
00005F0E  0D0A 5041 8942          dc.b      13,10,80,65,83,83,58,32,77,101,109,111,114,121
00005F12  5353 3A20 
00005F16  4D65 6D6F 
00005F1A  7279      
00005F1C  2056 616C 8943          dc.b      32,86,97,108,105,100,97,116,105,111,110,32,116
00005F20  6964 6174 
00005F24  696F 6E20 
00005F28  74        
00005F29  6573 7420 8944          dc.b      101,115,116,32,104,97,115,32,112,97,115,115
00005F2D  6861 7320 
00005F31  7061 7373 
00005F35  6564 210D 8945          dc.b      101,100,33,13,10,0
00005F39  0A00      
                    8946   @m68kde~3_155:
00005F3C  0D0A 596F 8947          dc.b      13,10,89,111,117,32,104,97,118,101,32,115,101
00005F40  7520 6861 
00005F44  7665 2073 
00005F48  65        
00005F49  6C63 7465 8948          dc.b      108,99,116,101,100,32,116,111,32,117,115,101
00005F4D  6420 746F 
00005F51  2075 7365 
00005F55  2077 6F72 8949          dc.b      32,119,111,114,100,32,115,105,122,101,32,100
00005F59  6420 7369 
00005F5D  7A65 2064 
00005F61  6174 6120 8950          dc.b      97,116,97,32,116,111,32,116,101,115,116,32,121
00005F65  746F 2074 
00005F69  6573 7420 
00005F6D  79        
00005F6E  6F75 7220 8951          dc.b      111,117,114,32,109,101,109,111,114,121,0
00005F72  6D65 6D6F 
00005F76  7279 00   
                    8952   @m68kde~3_156:
00005F7A  0D0A 4F75 8953          dc.b      13,10,79,117,116,32,111,102,32,116,104,101,32
00005F7E  7420 6F66 
00005F82  2074 6865 
00005F86  20        
00005F87  6265 6C6F 8954          dc.b      98,101,108,111,119,32,101,120,97,109,112,108
00005F8B  7720 6578 
00005F8F  616D 706C 
00005F93  6520 7465 8955          dc.b      101,32,116,101,115,116,32,100,97,116,97,44,32
00005F97  7374 2064 
00005F9B  6174 612C 
00005F9F  20        
00005FA0  706C 6561 8956          dc.b      112,108,101,97,115,101,32,115,101,108,101,99
00005FA4  7365 2073 
00005FA8  656C 6563 
00005FAC  7420 6F6E 8957          dc.b      116,32,111,110,101,32,98,121,32,101,110,116
00005FB0  6520 6279 
00005FB4  2065 6E74 
00005FB8  6572 696E 8958          dc.b      101,114,105,110,103,32,116,104,101,32,118,97
00005FBC  6720 7468 
00005FC0  6520 7661 
00005FC4  6C75 6520 8959          dc.b      108,117,101,32,97,115,115,111,99,105,97,116
00005FC8  6173 736F 
00005FCC  6369 6174 
00005FD0  6564 2074 8960          dc.b      101,100,32,116,111,32,101,97,99,104,32,101,120
00005FD4  6F20 6561 
00005FD8  6368 2065 
00005FDC  78        
00005FDD  616D 706C 8961          dc.b      97,109,112,108,101,58,0
00005FE1  653A 00   
                    8962   @m68kde~3_157:
00005FE4  0D0A 3120 8963          dc.b      13,10,49,32,61,32,34,65,65,65,65,34,10,50,32
00005FE8  3D20 2241 
00005FEC  4141 4122 
00005FF0  0A32 20   
00005FF3  3D20 2242 8964          dc.b      61,32,34,66,65,66,65,34,10,51,32,61,32,34,67
00005FF7  4142 4122 
00005FFB  0A33 203D 
00005FFF  2022 43   
00006002  4344 4422 8965          dc.b      67,68,68,34,10,52,32,61,32,34,68,68,68,68,34
00006006  0A34 203D 
0000600A  2022 4444 
0000600E  4444 22   
00006011  0D0A 00   8966          dc.b      13,10,0
                    8967   @m68kde~3_158:
00006014  0D0A 506C 8968          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00006018  6561 7365 
0000601C  2065 6E74 
00006020  65        
00006021  7220 7468 8969          dc.b      114,32,116,104,101,32,115,116,97,114,116,32
00006025  6520 7374 
00006029  6172 7420 
0000602D  6164 6472 8970          dc.b      97,100,100,114,101,115,115,32,121,111,117,32
00006031  6573 7320 
00006035  796F 7520 
00006039  776F 756C 8971          dc.b      119,111,117,108,100,32,108,105,107,101,32,116
0000603D  6420 6C69 
00006041  6B65 2074 
00006045  6F20 7573 8972          dc.b      111,32,117,115,101,32,102,111,114,32,116,104
00006049  6520 666F 
0000604D  7220 7468 
00006051  6520 7465 8973          dc.b      101,32,116,101,115,116,32,100,97,116,97,32,105
00006055  7374 2064 
00006059  6174 6120 
0000605D  69        
0000605E  6E74 6F20 8974          dc.b      110,116,111,32,109,101,109,111,114,121,32,40
00006062  6D65 6D6F 
00006066  7279 2028 
0000606A  456E 7375 8975          dc.b      69,110,115,117,114,101,32,116,111,32,101,110
0000606E  7265 2074 
00006072  6F20 656E 
00006076  7465 7220 8976          dc.b      116,101,114,32,97,110,32,101,118,101,110,32
0000607A  616E 2065 
0000607E  7665 6E20 
00006082  6E75 6D62 8977          dc.b      110,117,109,98,101,114,41,13,10,0
00006086  6572 290D 
0000608A  0A00      
                    8978   @m68kde~3_159:
0000608C  0D0A 4552 8979          dc.b      13,10,69,82,82,79,82,58,32,83,116,97,114,116
00006090  524F 523A 
00006094  2053 7461 
00006098  7274      
0000609A  696E 6720 8980          dc.b      105,110,103,32,65,100,100,114,101,115,115,32
0000609E  4164 6472 
000060A2  6573 7320 
000060A6  6973 206F 8981          dc.b      105,115,32,111,117,116,115,105,100,101,32,111
000060AA  7574 7369 
000060AE  6465 206F 
000060B2  6620 3638 8982          dc.b      102,32,54,56,75,32,109,101,109,111,114,121,32
000060B6  4B20 6D65 
000060BA  6D6F 7279 
000060BE  20        
000060BF  7261 6E67 8983          dc.b      114,97,110,103,101,46,32,80,108,101,97,115,101
000060C3  652E 2050 
000060C7  6C65 6173 
000060CB  65        
000060CC  2074 7279 8984          dc.b      32,116,114,121,32,97,103,97,105,110,32,97,110
000060D0  2061 6761 
000060D4  696E 2061 
000060D8  6E        
000060D9  6420 656E 8985          dc.b      100,32,101,110,115,117,114,101,32,116,104,101
000060DD  7375 7265 
000060E1  2074 6865 
000060E5  2061 6464 8986          dc.b      32,97,100,100,114,101,115,115,32,105,115,32
000060E9  7265 7373 
000060ED  2069 7320 
000060F1  7769 7468 8987          dc.b      119,105,116,104,110,32,48,120,48,57,48,48,48
000060F5  6E20 3078 
000060F9  3039 3030 
000060FD  30        
000060FE  3030 3020 8988          dc.b      48,48,48,32,45,32,48,120,48,57,55,70,70,70,70
00006102  2D20 3078 
00006106  3039 3746 
0000610A  4646 46   
0000610D  460D 0A00 8989          dc.b      70,13,10,0
                    8990   @m68kde~3_160:
00006112  0D0A 4552 8991          dc.b      13,10,69,82,82,79,82,58,32,84,104,101,32,97
00006116  524F 523A 
0000611A  2054 6865 
0000611E  2061      
00006120  6464 7265 8992          dc.b      100,100,114,101,115,115,32,121,111,117,32,104
00006124  7373 2079 
00006128  6F75 2068 
0000612C  6176 6520 8993          dc.b      97,118,101,32,101,110,116,101,114,101,100,32
00006130  656E 7465 
00006134  7265 6420 
00006138  6973 206E 8994          dc.b      105,115,32,110,111,116,32,101,118,101,110,46
0000613C  6F74 2065 
00006140  7665 6E2E 
00006144  2050 6C65 8995          dc.b      32,80,108,101,97,115,101,32,116,114,121,32,97
00006148  6173 6520 
0000614C  7472 7920 
00006150  61        
00006151  6761 696E 8996          dc.b      103,97,105,110,13,10,0
00006155  0D0A 00   
                    8997   @m68kde~3_161:
00006158  0D0A 506C 8998          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
0000615C  6561 7365 
00006160  2065 6E74 
00006164  65        
00006165  7220 7468 8999          dc.b      114,32,116,104,101,32,101,110,100,32,97,100
00006169  6520 656E 
0000616D  6420 6164 
00006171  6472 6573 9000          dc.b      100,114,101,115,115,32,121,111,117,32,119,111
00006175  7320 796F 
00006179  7520 776F 
0000617D  756C 6420 9001          dc.b      117,108,100,32,108,105,107,101,32,116,111,32
00006181  6C69 6B65 
00006185  2074 6F20 
00006189  7573 6520 9002          dc.b      117,115,101,32,102,111,114,32,116,104,101,32
0000618D  666F 7220 
00006191  7468 6520 
00006195  7465 7374 9003          dc.b      116,101,115,116,32,100,97,116,97,32,105,110
00006199  2064 6174 
0000619D  6120 696E 
000061A1  206D 656D 9004          dc.b      32,109,101,109,111,114,121,32,40,69,110,115
000061A5  6F72 7920 
000061A9  2845 6E73 
000061AD  7572 6520 9005          dc.b      117,114,101,32,116,111,32,101,110,116,101,114
000061B1  746F 2065 
000061B5  6E74 6572 
000061B9  2061 6E20 9006          dc.b      32,97,110,32,101,118,101,110,32,110,117,109
000061BD  6576 656E 
000061C1  206E 756D 
000061C5  6265 7229 9007          dc.b      98,101,114,41,13,10,0
000061C9  0D0A 00   
                    9008   @m68kde~3_162:
000061CC  0D0A 4552 9009          dc.b      13,10,69,82,82,79,82,58,32,69,110,100,32,65
000061D0  524F 523A 
000061D4  2045 6E64 
000061D8  2041      
000061DA  6464 7265 9010          dc.b      100,100,114,101,115,115,32,105,115,32,111,117
000061DE  7373 2069 
000061E2  7320 6F75 
000061E6  7473 6964 9011          dc.b      116,115,105,100,101,32,111,102,32,54,56,75,32
000061EA  6520 6F66 
000061EE  2036 384B 
000061F2  20        
000061F3  6D65 6D6F 9012          dc.b      109,101,109,111,114,121,32,114,97,110,103,101
000061F7  7279 2072 
000061FB  616E 6765 
000061FF  2E20 506C 9013          dc.b      46,32,80,108,101,97,115,101,32,116,114,121,32
00006203  6561 7365 
00006207  2074 7279 
0000620B  20        
0000620C  6167 6169 9014          dc.b      97,103,97,105,110,32,97,110,100,32,101,110,115
00006210  6E20 616E 
00006214  6420 656E 
00006218  73        
00006219  7572 6520 9015          dc.b      117,114,101,32,116,104,101,32,97,100,100,114
0000621D  7468 6520 
00006221  6164 6472 
00006225  6573 7320 9016          dc.b      101,115,115,32,105,115,32,119,105,116,104,110
00006229  6973 2077 
0000622D  6974 686E 
00006231  2030 7830 9017          dc.b      32,48,120,48,57,48,48,48,48,48,48,32,45,32,48
00006235  3930 3030 
00006239  3030 3020 
0000623D  2D20 30   
00006240  7830 3937 9018          dc.b      120,48,57,55,70,70,70,70,70,13,10,0
00006244  4646 4646 
00006248  460D 0A00 
                    9019   @m68kde~3_163:
0000624C  0D0A 5752 9020          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,52,88,32
00006250  4954 453A 
00006254  205B 2530 
00006258  3458 20   
0000625B  746F 2025 9021          dc.b      116,111,32,37,48,56,120,93,0
0000625F  3038 785D 
00006263  00        
                    9022   @m68kde~3_164:
00006264  0D0A 4552 9023          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
00006268  524F 523A 
0000626C  2044 6174 
00006270  6120 77   
00006273  6974 6869 9024          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
00006277  6E20 6D65 
0000627B  6D6F 7279 
0000627F  2064 6F65 9025          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
00006283  7320 6E6F 
00006287  7420 6D61 
0000628B  7463 6820 9026          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
0000628F  7365 6C65 
00006293  6374 6564 
00006297  2074 6573 9027          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
0000629B  7420 6461 
0000629F  7461 2120 
000062A3  5B        
000062A4  4164 6472 9028          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
000062A8  6573 733A 
000062AC  2025 3038 
000062B0  78        
000062B1  2045 7861 9029          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
000062B5  6374 2044 
000062B9  6174 613A 
000062BD  2025      
000062BF  3032 5820 9030          dc.b      48,50,88,32,69,120,112,101,99,116,101,100,32
000062C3  4578 7065 
000062C7  6374 6564 
000062CB  20        
000062CC  4461 7461 9031          dc.b      68,97,116,97,58,32,37,48,50,88,93,32,69,120
000062D0  3A20 2530 
000062D4  3258 5D20 
000062D8  4578      
000062DA  6974 696E 9032          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
000062DE  6720 6D65 
000062E2  6D6F 7279 
000062E6  2074 6573 9033          dc.b      32,116,101,115,116,46,46,46,0
000062EA  742E 2E2E 
000062EE  00        
                    9034   @m68kde~3_165:
000062F0  0D0A 596F 9035          dc.b      13,10,89,111,117,32,104,97,118,101,32,115,101
000062F4  7520 6861 
000062F8  7665 2073 
000062FC  65        
000062FD  6C63 7465 9036          dc.b      108,99,116,101,100,32,116,111,32,117,115,101
00006301  6420 746F 
00006305  2075 7365 
00006309  2062 7974 9037          dc.b      32,98,121,116,101,115,32,115,105,122,101,32
0000630D  6573 2073 
00006311  697A 6520 
00006315  6461 7461 9038          dc.b      100,97,116,97,32,116,111,32,116,101,115,116
00006319  2074 6F20 
0000631D  7465 7374 
00006321  2079 6F75 9039          dc.b      32,121,111,117,114,32,109,101,109,111,114,121
00006325  7220 6D65 
00006329  6D6F 7279 
0000632D  00        9040          dc.b      0
                    9041   @m68kde~3_166:
0000632E  0D0A 3120 9042          dc.b      13,10,49,32,61,32,34,65,65,65,65,65,65,65,65
00006332  3D20 2241 
00006336  4141 4141 
0000633A  4141 41   
0000633D  220A 3220 9043          dc.b      34,10,50,32,61,32,34,65,66,65,66,65,66,65,66
00006341  3D20 2241 
00006345  4241 4241 
00006349  4241 42   
0000634C  220A 3320 9044          dc.b      34,10,51,32,61,32,34,67,67,67,67,68,68,68,68
00006350  3D20 2243 
00006354  4343 4344 
00006358  4444 44   
0000635B  220A 3420 9045          dc.b      34,10,52,32,61,32,34,65,65,66,66,67,67,68,68
0000635F  3D20 2241 
00006363  4142 4243 
00006367  4344 44   
0000636A  220D 0A00 9046          dc.b      34,13,10,0
                    9047   @m68kde~3_167:
0000636E  0D0A 5741 9048          dc.b      13,10,87,65,82,78,73,78,71,58,32,77,101,109
00006372  524E 494E 
00006376  473A 204D 
0000637A  656D      
0000637C  6F72 7920 9049          dc.b      111,114,121,32,119,105,108,108,32,99,111,110
00006380  7769 6C6C 
00006384  2063 6F6E 
00006388  7461 696E 9050          dc.b      116,97,105,110,32,116,114,117,110,99,97,116
0000638C  2074 7275 
00006390  6E63 6174 
00006394  6564 2064 9051          dc.b      101,100,32,100,97,116,97,0
00006398  6174 6100 
                    9052   @m68kde~3_168:
0000639C  0D0A 5752 9053          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,56,88,32
000063A0  4954 453A 
000063A4  205B 2530 
000063A8  3858 20   
000063AB  746F 2025 9054          dc.b      116,111,32,37,48,56,120,93,0
000063AF  3038 785D 
000063B3  00        
                    9055   @m68kde~3_169:
000063B4  0D0A 4552 9056          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
000063B8  524F 523A 
000063BC  2044 6174 
000063C0  6120 77   
000063C3  6974 6869 9057          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
000063C7  6E20 6D65 
000063CB  6D6F 7279 
000063CF  2064 6F65 9058          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
000063D3  7320 6E6F 
000063D7  7420 6D61 
000063DB  7463 6820 9059          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
000063DF  7365 6C65 
000063E3  6374 6564 
000063E7  2074 6573 9060          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
000063EB  7420 6461 
000063EF  7461 2120 
000063F3  5B        
000063F4  4164 6472 9061          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
000063F8  6573 733A 
000063FC  2025 3038 
00006400  78        
00006401  2045 7861 9062          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
00006405  6374 2044 
00006409  6174 613A 
0000640D  2025      
0000640F  3038 5820 9063          dc.b      48,56,88,32,69,120,112,101,99,116,101,100,32
00006413  4578 7065 
00006417  6374 6564 
0000641B  20        
0000641C  4461 7461 9064          dc.b      68,97,116,97,58,32,37,48,56,88,93,32,69,120
00006420  3A20 2530 
00006424  3858 5D20 
00006428  4578      
0000642A  6974 696E 9065          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
0000642E  6720 6D65 
00006432  6D6F 7279 
00006436  2074 6573 9066          dc.b      32,116,101,115,116,46,46,46,13,10,0
0000643A  742E 2E2E 
0000643E  0D0A 00   
                    9067   @m68kde~3_170:
00006442  0D0A 596F 9068          dc.b      13,10,89,111,117,32,102,97,105,108,101,100,32
00006446  7520 6661 
0000644A  696C 6564 
0000644E  20        
0000644F  746F 2073 9069          dc.b      116,111,32,115,101,108,101,99,116,32,97,32,100
00006453  656C 6563 
00006457  7420 6120 
0000645B  64        
0000645C  6174 6120 9070          dc.b      97,116,97,32,116,121,112,101,32,116,111,32,117
00006460  7479 7065 
00006464  2074 6F20 
00006468  75        
00006469  7365 2120 9071          dc.b      115,101,33,32,67,108,105,99,107,32,111,112,101
0000646D  436C 6963 
00006471  6B20 6F70 
00006475  65        
00006476  6E20 6D65 9072          dc.b      110,32,109,101,109,111,114,121,32,116,101,115
0000647A  6D6F 7279 
0000647E  2074 6573 
00006482  7420 6167 9073          dc.b      116,32,97,103,97,105,110,32,116,111,32,116,114
00006486  6169 6E20 
0000648A  746F 2074 
0000648E  72        
0000648F  7920 6167 9074          dc.b      121,32,97,103,97,105,110,46,13,10,0
00006493  6169 6E2E 
00006497  0D0A 00   
                    9075   @m68kde~3_171:
0000649A  0D0A 4932 9076          dc.b      13,10,73,50,67,32,87,114,105,116,101,58,0
0000649E  4320 5772 
000064A2  6974 653A 
000064A6  00        
                    9077   @m68kde~3_172:
000064A8  0D0A 456E 9078          dc.b      13,10,69,110,116,101,114,101,100,32,65,100,100
000064AC  7465 7265 
000064B0  6420 4164 
000064B4  64        
000064B5  7265 7373 9079          dc.b      114,101,115,115,32,105,115,32,105,110,118,97
000064B9  2069 7320 
000064BD  696E 7661 
000064C1  6C69 642C 9080          dc.b      108,105,100,44,32,112,108,101,97,115,101,32
000064C5  2070 6C65 
000064C9  6173 6520 
000064CD  656E 7465 9081          dc.b      101,110,116,101,114,32,97,32,115,109,97,108
000064D1  7220 6120 
000064D5  736D 616C 
000064D9  6C65 7220 9082          dc.b      108,101,114,32,118,97,108,117,101,100,32,97
000064DD  7661 6C75 
000064E1  6564 2061 
000064E5  6464 7265 9083          dc.b      100,100,114,101,115,115,46,32,82,101,116,117
000064E9  7373 2E20 
000064ED  5265 7475 
000064F1  726E 696E 9084          dc.b      114,110,105,110,103,32,98,97,99,107,32,116,111
000064F5  6720 6261 
000064F9  636B 2074 
000064FD  6F        
000064FE  2074 6865 9085          dc.b      32,116,104,101,32,100,101,98,117,103,32,109
00006502  2064 6562 
00006506  7567 206D 
0000650A  6F6E 6974 9086          dc.b      111,110,105,116,111,114,32,109,101,110,117,0
0000650E  6F72 206D 
00006512  656E 7500 
                    9087   @m68kde~3_173:
00006516  0D0A 456E 9088          dc.b      13,10,69,110,116,101,114,32,68,97,116,97,58
0000651A  7465 7220 
0000651E  4461 7461 
00006522  3A        
00006523  2000      9089          dc.b      32,0
                    9090   @m68kde~3_174:
00006526  0D0A 4932 9091          dc.b      13,10,73,50,67,32,82,101,97,100,58,0
0000652A  4320 5265 
0000652E  6164 3A00 
                    9092   @m68kde~3_175:
00006532  0D0A 4932 9093          dc.b      13,10,73,50,67,32,80,97,103,101,32,87,114,105
00006536  4320 5061 
0000653A  6765 2057 
0000653E  7269      
00006540  7465 3A00 9094          dc.b      116,101,58,0
                    9095   @m68kde~3_176:
00006544  0D0A 456E 9096          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00006548  7465 7220 
0000654C  4164 6472 
00006550  65        
00006551  7373 2046 9097          dc.b      115,115,32,70,114,111,109,58,32,0
00006555  726F 6D3A 
00006559  2000      
                    9098   @m68kde~3_177:
0000655C  0D0A 456E 9099          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00006560  7465 7220 
00006564  4164 6472 
00006568  65        
00006569  7373 2054 9100          dc.b      115,115,32,84,111,58,32,0
0000656D  6F3A 2000 
                    9101   @m68kde~3_178:
00006572  0D0A 4932 9102          dc.b      13,10,73,50,67,32,83,101,113,32,82,101,97,100
00006576  4320 5365 
0000657A  7120 5265 
0000657E  6164      
00006580  3A00      9103          dc.b      58,0
                    9104   @m68kde~3_179:
00006582  4445 312D 9105          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
00006586  3638 6B20 
0000658A  4275 6720 
0000658E  5631      
00006590  2E37 3700 9106          dc.b      46,55,55,0
                    9107   @m68kde~3_180:
00006594  436F 7079 9108          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
00006598  7269 6768 
0000659C  7420 2843 
000065A0  2920 504A 9109          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
000065A4  2044 6176 
000065A8  6965 7320 
000065AC  3230      
000065AE  3136 00   9110          dc.b      49,54,0
                    9111   @m68kde~3_181:
000065B2  0D0A 0D0A 9112          dc.b      13,10,13,10,77,97,116,116,104,101,119,32,84
000065B6  4D61 7474 
000065BA  6865 7720 
000065BE  54        
000065BF  6F6E 6720 9113          dc.b      111,110,103,32,45,32,53,57,50,54,52,52,48,56
000065C3  2D20 3539 
000065C7  3236 3434 
000065CB  3038      
000065CD  00        9114          dc.b      0
                    9115   @m68kde~3_182:
000065CE  0D0A 5275 9116          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
000065D2  6E6E 696E 
000065D6  672E 2E2E 
000065DA  2E        
000065DB  2E00      9117          dc.b      46,0
                    9118   @m68kde~3_183:
000065DE  5275 6E6E 9119          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
000065E2  696E 672E 
000065E6  2E2E 2E2E 
000065EA  00        
                    9120   @m68kde~3_184:
000065EC  4279 3A20 9121          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
000065F0  504A 2044 
000065F4  6176 6965 
000065F8  73        
000065F9  00        9122          dc.b      0
                    9123   @m68kde~3_185:
000065FA  0D0A 2573 9124          dc.b      13,10,37,115,0
000065FE  00        
                    9125   MemoryTest_test_data_word_list:
00006600  0000 AAAA 9126          dc.l      43690,47802,52445,56797
00006604  0000 BABA 
00006608  0000 CCDD 
0000660C  0000 DDDD 
                    9127   @iic_co~1_1:
00006610  0D0A 5772 9128          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
00006614  6F74 6520 
00006618  5B25 785D 
0000661C  20        
0000661D  746F 2041 9129          dc.b      116,111,32,65,100,100,114,101,115,115,91,37
00006621  6464 7265 
00006625  7373 5B25 
00006629  785D 00   9130          dc.b      120,93,0
                    9131   @iic_co~1_2:
0000662C  0D0A 5772 9132          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
00006630  6F74 6520 
00006634  5B25 785D 
00006638  20        
00006639  6672 6F6D 9133          dc.b      102,114,111,109,32,65,100,100,114,101,115,115
0000663D  2041 6464 
00006641  7265 7373 
00006645  5B25 785D 9134          dc.b      91,37,120,93,32,116,111,32,65,100,100,114,101
00006649  2074 6F20 
0000664D  4164 6472 
00006651  65        
00006652  7373 5B25 9135          dc.b      115,115,91,37,120,93,0
00006656  785D 00   
                    9136   @iic_co~1_3:
0000665A  0D0A 5265 9137          dc.b      13,10,82,101,97,100,32,91,37,120,93,32,102,114
0000665E  6164 205B 
00006662  2578 5D20 
00006666  6672      
00006668  6F6D 2041 9138          dc.b      111,109,32,65,100,100,114,101,115,115,91,37
0000666C  6464 7265 
00006670  7373 5B25 
00006674  785D 00   9139          dc.b      120,93,0
                    9140   @iic_co~1_4:
00006678  0A49 3243 9141          dc.b      10,73,50,67,32,68,65,67,32,87,114,105,116,101
0000667C  2044 4143 
00006680  2057 7269 
00006684  7465      
00006686  3A20 506C 9142          dc.b      58,32,80,108,101,97,115,101,32,99,104,101,99
0000668A  6561 7365 
0000668E  2063 6865 
00006692  63        
00006693  6B20 4C45 9143          dc.b      107,32,76,69,68,10,0
00006697  440A 00   
                    9144   @iic_co~1_5:
0000669A  4932 4320 9145          dc.b      73,50,67,32,65,68,67,32,82,101,97,100,58,10
0000669E  4144 4320 
000066A2  5265 6164 
000066A6  3A0A      
000066A8  00        9146          dc.b      0
                    9147   @iic_co~1_6:
000066AA  0A3D 3D3D 9148          dc.b      10,61,61,61,61,61,61,61,61,61,61,61,61,61,61
000066AE  3D3D 3D3D 
000066B2  3D3D 3D3D 
000066B6  3D3D 3D   
000066B9  3D3D 3D3D 9149          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,61,61,61
000066BD  3D3D 3D3D 
000066C1  3D3D 3D3D 
000066C5  3D3D 3D   
000066C8  3D4D 6561 9150          dc.b      61,77,101,97,115,117,114,105,110,103,61,61,61
000066CC  7375 7269 
000066D0  6E67 3D3D 
000066D4  3D        
000066D5  3D3D 3D3D 9151          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,61,61,61
000066D9  3D3D 3D3D 
000066DD  3D3D 3D3D 
000066E1  3D3D 3D   
000066E4  3D3D 3D3D 9152          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,10,0
000066E8  3D3D 3D3D 
000066EC  3D3D 3D3D 
000066F0  0A00      
                    9153   @iic_co~1_7:
000066F2  5661 6C75 9154          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
000066F6  6520 6F66 
000066FA  2054 6865 
000066FE  72        
000066FF  6D69 7374 9155          dc.b      109,105,115,116,111,114,58,32,37,100,10,0
00006703  6F72 3A20 
00006707  2564 0A00 
                    9156   @iic_co~1_8:
0000670C  5661 6C75 9157          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
00006710  6520 6F66 
00006714  2050 6F74 
00006718  65        
00006719  6E74 696F 9158          dc.b      110,116,105,111,109,101,116,101,114,58,32,37
0000671D  6D65 7465 
00006721  723A 2025 
00006725  640A 00   9159          dc.b      100,10,0
                    9160   @iic_co~1_9:
00006728  5661 6C75 9161          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
0000672C  6520 6F66 
00006730  2050 686F 
00006734  74        
00006735  6F2D 7265 9162          dc.b      111,45,114,101,115,105,115,116,101,114,58,32
00006739  7369 7374 
0000673D  6572 3A20 
00006741  2564 0A00 9163          dc.b      37,100,10,0
                    9164          section   data
00006746            9165                   align
          0000 6746 9166   DataStart       equ       *
                    9167   
                    9168   *********************************************************************************************************
                    9169   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    9170   * to ram as part of the CStart routine in this file
                    9171   *********************************************************************************************************
                    9172   
                    9173   MemoryTest_test_data_byte_list:
00006746  AAAB CCCD 9174          dc.b      170,171,204,205
                    9175   MemoryTest_test_data_long_word_list:
0000674A  AAAA AAAA 9176          dc.l      -1431655766,-1414812757,-858989091,-1430532899
0000674E  ABAB ABAB 
00006752  CCCC DDDD 
00006756  AABB CCDD 
                    9177   @itoa_1:
0000675A  2D32 3134 9178          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
0000675E  3734 3833 
00006762  3634 3800 
                    9179          section   bss
00006766            9180                   align
          0000 6766 9181   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    9182   
                    9183   *********************************************************************************************************
                    9184   * Section for Uninitialised Data held in ROM as constants
                    9185   *********************************************************************************************************
                    9186   
0B000000            9187                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0020 9188   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    9189   
                    9190   
0B000000            9191   bss             org       bss
                    9192   
                    9193   *********************************************************************************************************
                    9194   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    9195   * install the exception handler using the C function InstallExceptionHandler()
                    9196   *********************************************************************************************************
                    9197   
                    9198   
                    9199   
0B000000            9200   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            9201   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            9202   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            9203   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            9204   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            9205   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            9206   VCheck           ds.l    1      ditto
0B00001C            9207   VTrapV           ds.l    1      ditto
0B000020            9208   VPrivilege       ds.l    1      ditto
0B000024            9209   VTrace           ds.l    1
0B000028            9210   VLine1010emul    ds.l    1
0B00002C            9211   VLine1111emul    ds.l    1
0B000030            9212   VUnassigned1     ds.l    1
0B000034            9213   VUnassigned2     ds.l    1
0B000038            9214   VUnassigned3     ds.l    1
0B00003C            9215   VUninit_IRQ      ds.l    1
0B000040            9216   VUnassigned4     ds.l    1
0B000044            9217   VUnassigned5     ds.l    1
0B000048            9218   VUnassigned6     ds.l    1
0B00004C            9219   VUnassigned7     ds.l    1
0B000050            9220   VUnassigned8     ds.l    1
0B000054            9221   VUnassigned9     ds.l    1
0B000058            9222   VUnassigned10    ds.l    1
0B00005C            9223   VUnassigned11    ds.l    1
0B000060            9224   VSpuriousIRQ     ds.l    1
                    9225   
                    9226   * Interrupt handlers Vector 25-31
0B000064            9227   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            9228   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            9229   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            9230   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            9231   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            9232   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            9233   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9234   
                    9235   * Trap Handler vectors 32-47
0B000080            9236   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            9237   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            9238   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            9239   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            9240   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            9241   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            9242   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            9243   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            9244   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            9245   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            9246   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            9247   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            9248   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            9249   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            9250   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            9251   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9252   
                    9253   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    9254   
                    9255   ***********************************************************************************************************
                    9256   * Other Variables
                    9257   ***********************************************************************************************************
                    9258   *__DebugA5       ds.l    1
                    9259   *__UserA5        ds.l    1
                    9260   
                    9261   ***********************************************************************************************************
0B0000C0            9262   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            9263   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            9264   __heap:         ds.l    0       ; pointers for malloc functions
                    9265   
                    9266   *__himem:       ds.l    himem            ; highest memory location + 1
                    9267   *__stklen:      ds.l    stklen           ; default stack size
                    9268   
                    9269   *********************************************************************************************************
                    9270   * Section for Heap
                    9271   *********************************************************************************************************
                    9272   
                    9273   _i:
0B0000C4            9274          ds.b      4
                    9275   _x:
0B0000C8            9276          ds.b      4
                    9277   _y:
0B0000CC            9278          ds.b      4
                    9279   _z:
0B0000D0            9280          ds.b      4
                    9281   _PortA_Count:
0B0000D4            9282          ds.b      4
                    9283   _Trace:
0B0000D8            9284          ds.b      4
                    9285   _GoFlag:
0B0000DC            9286          ds.b      4
                    9287   _Echo:
0B0000E0            9288          ds.b      4
                    9289   _d0:
0B0000E4            9290          ds.b      4
                    9291   _d1:
0B0000E8            9292          ds.b      4
                    9293   _d2:
0B0000EC            9294          ds.b      4
                    9295   _d3:
0B0000F0            9296          ds.b      4
                    9297   _d4:
0B0000F4            9298          ds.b      4
                    9299   _d5:
0B0000F8            9300          ds.b      4
                    9301   _d6:
0B0000FC            9302          ds.b      4
                    9303   _d7:
0B000100            9304          ds.b      4
                    9305   _a0:
0B000104            9306          ds.b      4
                    9307   _a1:
0B000108            9308          ds.b      4
                    9309   _a2:
0B00010C            9310          ds.b      4
                    9311   _a3:
0B000110            9312          ds.b      4
                    9313   _a4:
0B000114            9314          ds.b      4
                    9315   _a5:
0B000118            9316          ds.b      4
                    9317   _a6:
0B00011C            9318          ds.b      4
                    9319   _PC:
0B000120            9320          ds.b      4
                    9321   _SSP:
0B000124            9322          ds.b      4
                    9323   _USP:
0B000128            9324          ds.b      4
                    9325   _SR:
0B00012C            9326          ds.b      2
                    9327   _BreakPointAddress:
0B00012E            9328          ds.b      32
                    9329   _BreakPointInstruction:
0B00014E            9330          ds.b      16
                    9331   _BreakPointSetOrCleared:
0B00015E            9332          ds.b      32
                    9333   _InstructionSize:
0B00017E            9334          ds.b      4
                    9335   _WatchPointAddress:
0B000182            9336          ds.b      32
                    9337   _WatchPointSetOrCleared:
0B0001A2            9338          ds.b      32
                    9339   _WatchPointString:
0B0001C2            9340          ds.b      800
                    9341   _TempString:
0B0004E2            9342          ds.b      100
                    9343          section   heap
0B000546            9344                   align
          0B00 0546 9345   bssEnd          equ *                   end of storage space for unitialised variables
                    9346   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0546 9347   heap   equ       *
0B000546            9348                    align
          0000 0000

Assembly errors: 0
