680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 12 Apr 2023      Time: 23:43:19          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\ASN6B_INTERRUPTS.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0000 07BE   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0000 06B2   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  0114      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  125E      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  01D4      
                     116              ;
0000041A  23FC 0000  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  78BC 0800 
00000422  01E0      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  125E 0800 
0000042C  01E4      
0000042E  4EB9 0000  119              jsr         _main							; now call main() from our C program (yeah!!!!)
00000432  0832      
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  0178      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  017C      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  0180      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  0184      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  0188      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  018C      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  0190      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  0194      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  0198      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  019C      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  01A0      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  01A4      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  01A8      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  01AC      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  01B0      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  01B4      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  01B8      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  01BC      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  01C0      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  01C4      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  01C8      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  01CC      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  01D0      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  011C      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  0120      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  0124      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  0128      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  012C      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  0130      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  0134      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  0138      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  013C      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  0140      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   ;********************************************************************************************************
                     352   ;                                               uC/OS-II
                     353   ;                                         The Real-Time Kernel
                     354   ;
                     355   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     356   ;                                          All Rights Reserved
                     357   ;
                     358   ;
                     359   ;                                     68000 Specific assembly code
                     360   ;                                               IDE68K
                     361   ;
                     362   ; File         : OS_CPU_A.ASM
                     363   ; By           : Jean J. Labrosse, Peter J. Fondse
                     364   ;********************************************************************************************************
                     365   
                     366   
                     367   ;********************************************************************************************************
                     368   ;                                            REVISION HISTORY
                     369   ;
                     370   ; $Log$
                     371   ;
                     372   ;********************************************************************************************************
                     373   
                     374   
                     375   ;********************************************************************************************************
                     376   ;                                          PUBLIC DECLARATIONS
                     377   ;********************************************************************************************************
                     378   
                     379   
                     380   ;********************************************************************************************************
                     381   ;                                         EXTERNAL DECLARATIONS
                     382   ;********************************************************************************************************
                     383   
                     384   
                     385   ;********************************************************************************************************
                     386   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     387   ;
                     388   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     389   ;               by your application before calling OSStart().
                     390   ;
                     391   ; Arguments   : none
                     392   ;
                     393   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     394   ;
                     395   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     396   ;                                            +  2         D0    (L)
                     397   ;                                            +  4         D1    (H)
                     398   ;                                            +  6         D1    (L)
                     399   ;                                            +  8         D2    (H)
                     400   ;                                            + 10         D2    (L)
                     401   ;                                            + 12         D3    (H)
                     402   ;                                            + 14         D3    (L)
                     403   ;                                            + 16         D4    (H)
                     404   ;                                            + 18         D4    (L)
                     405   ;                                            + 20         D5    (H)
                     406   ;                                            + 22         D5    (L)
                     407   ;                                            + 24         D6    (H)
                     408   ;                                            + 26         D6    (L)
                     409   ;                                            + 28         D7    (H)
                     410   ;                                            + 30         D7    (L)
                     411   ;                                            + 32         A0    (H)
                     412   ;                                            + 34         A0    (L)
                     413   ;                                            + 36         A1    (H)
                     414   ;                                            + 38         A1    (L)
                     415   ;                                            + 40         A2    (H)
                     416   ;                                            + 42         A2    (L)
                     417   ;                                            + 44         A3    (H)
                     418   ;                                            + 46         A3    (L)
                     419   ;                                            + 48         A4    (H)
                     420   ;                                            + 50         A4    (L)
                     421   ;                                            + 52         A5    (H)
                     422   ;                                            + 54         A5    (L)
                     423   ;                                            + 56         A6    (H)
                     424   ;                                            + 58         A6    (L)
                     425   ;                                            + 60         OS_INITIAL_SR
                     426   ;                                            + 62         task  (H)
                     427   ;                                            + 64         task  (L)
                     428   ;                                            + 66         task  (H)
                     429   ;                                            + 68         task  (L)
                     430   ;                                            + 70         pdata (H)
                     431   ;                                            + 72         pdata (L)        High Memory
                     432   ;
                     433   ;               2) OSStartHighRdy() MUST:
                     434   ;                      a) Call OSTaskSwHook() then,
                     435   ;                      b) Set OSRunning to TRUE,
                     436   ;                      c) Switch to the highest priority task.
                     437   ;********************************************************************************************************
                     438   
                     439   ; Pseudocode for OSStartHighRdy:
                     440   ;          Call OSTaskSwHook();
                     441   ;          Set OSRunning to 1;
                     442   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     443   ;          POP all the processor registers from the stack;
                     444   ;          Execute a Return from Interrupt instruction;
                     445   
                     446   
                     447   _OSStartHighRdy:
00000698  4EB9 0000  448           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
0000069C  09AC      
0000069E  5239 0800  449           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
000006A2  0438      
000006A4  2079 0800  450           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
000006A8  0548      
000006AA  2E50       451           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
000006AC  4CDF 7FFF  452           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
000006B0  4E73       453           rte                                ; Run task
                     454   
                     455   ;********************************************************************************************************
                     456   ;                                       TASK LEVEL CONTEXT SWITCH
                     457   ;
                     458   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     459   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     460   ;
                     461   ; Arguments   : none
                     462   ;
                     463   ; Note(s)     : 1) Upon entry,
                     464   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     465   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     466   ;
                     467   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     468   ;                  task to suspend need to be saved):
                     469   ;
                     470   ;                                         SP +  0  ---->  SR                   Low Memory
                     471   ;                                            +  2         PC of task  (H)
                     472   ;                                            +  4         PC of task  (L)      High Memory
                     473   ;
                     474   ;               3) The stack frame of the task to resume looks as follows:
                     475   ;
                     476   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     477   ;                                            +  2         D0    (L)
                     478   ;                                            +  4         D1    (H)
                     479   ;                                            +  6         D1    (L)
                     480   ;                                            +  8         D2    (H)
                     481   ;                                            + 10         D2    (L)
                     482   ;                                            + 12         D3    (H)
                     483   ;                                            + 14         D3    (L)
                     484   ;                                            + 16         D4    (H)
                     485   ;                                            + 18         D4    (L)
                     486   ;                                            + 20         D5    (H)
                     487   ;                                            + 22         D5    (L)
                     488   ;                                            + 24         D6    (H)
                     489   ;                                            + 26         D6    (L)
                     490   ;                                            + 28         D7    (H)
                     491   ;                                            + 30         D7    (L)
                     492   ;                                            + 32         A0    (H)
                     493   ;                                            + 34         A0    (L)
                     494   ;                                            + 36         A1    (H)
                     495   ;                                            + 38         A1    (L)
                     496   ;                                            + 40         A2    (H)
                     497   ;                                            + 42         A2    (L)
                     498   ;                                            + 44         A3    (H)
                     499   ;                                            + 46         A3    (L)
                     500   ;                                            + 48         A4    (H)
                     501   ;                                            + 50         A4    (L)
                     502   ;                                            + 52         A5    (H)
                     503   ;                                            + 54         A5    (L)
                     504   ;                                            + 56         A6    (H)
                     505   ;                                            + 58         A6    (L)
                     506   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     507   ;                                            + 62         PC of task  (H)
                     508   ;                                            + 64         PC of task  (L)     High Memory
                     509   ;********************************************************************************************************
                     510   
                     511   ; Pseudocode for OSCtxSw:
                     512   ; OSCtxSw:
                     513   ; PUSH processor registers onto the current task’s stack;
                     514   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     515   ; Call OSTaskSwHook(); (1)
                     516   ; OSTCBCur = OSTCBHighRdy;
                     517   ; OSPrioCur = OSPrioHighRdy; (2)
                     518   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     519   ; POP all the processor registers from the stack;
                     520   ; Execute a Return from Interrupt instruction;
                     521   
                     522   _OSCtxSw:
000006B2  48E7 FFFE  523           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
000006B6  2079 0800  524           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
000006BA  0540      
000006BC  208F       525           move.l    A7,(A0)
000006BE  4EB9 0000  526           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006C2  09AC      
000006C4  13F9 0800  527           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
000006C8  042C 0800 
000006CC  042A      
000006CE  2079 0800  528           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
000006D2  0548      
000006D4  23C8 0800  529           move.l    A0,_OSTCBCur
000006D8  0540      
000006DA  2E50       530           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
000006DC  4CDF 7FFF  531           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
000006E0  4E73       532           rte                                      ; Run task
                     533   
                     534   ;********************************************************************************************************
                     535   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     536   ;
                     537   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     538   ;               Provided for backward compatibility.
                     539   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     540   ;********************************************************************************************************
                     541   
                     542   ; Pseudocode for OSIntCtxSw
                     543   ; OSIntCtxSw
                     544   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     545   ;          Call OSTaskSwHook(); (1)
                     546   ;          OSTCBCur = OSTCBHighRdy;
                     547   ;          OSPrioCur = OSPrioHighRdy; (2)
                     548   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     549   ;          POP all the processor registers from the stack;
                     550   ;          Execute a Return from Interrupt instruction;
                     551   
                     552   _OSIntCtxSw:
000006E2  DFFC 0000  553           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
000006E6  000A      
000006E8  2279 0800  554           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
000006EC  0540      
000006EE  228F       555           move.l    A7,(A1)
                     556   ;
000006F0  4EB9 0000  557           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006F4  09AC      
                     558   ;
000006F6  2279 0800  559           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
000006FA  0548      
000006FC  23C9 0800  560           move.l    A1,_OSTCBCur
00000700  0540      
00000702  2E51       561           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                     562   ;
00000704  13F9 0800  563           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000708  042C 0800 
0000070C  042A      
0000070E  4CDF 7FFF  564           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
00000712  4E73       565           rte                                      ; Run task
                     566   
                     567   ;********************************************************************************************************
                     568   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     569   ;
                     570   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     571   ;
                     572   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     573   ;
                     574   ; Stack frame upon entry:
                     575   ;
                     576   ;                  SP +  0  ---->  D0    (H)
                     577   ;                     +  2         D0    (L)
                     578   ;                     +  4         D1    (H)
                     579   ;                     +  6         D1    (L)
                     580   ;                     +  8         D2    (H)
                     581   ;                     + 10         D2    (L)
                     582   ;                     + 12         D3    (H)
                     583   ;                     + 14         D3    (L)
                     584   ;                     + 16         D4    (H)
                     585   ;                     + 18         D4    (L)
                     586   ;                     + 20         D5    (H)
                     587   ;                     + 22         D5    (L)
                     588   ;                     + 24         D6    (H)
                     589   ;                     + 26         D6    (L)
                     590   ;                     + 28         D7    (H)
                     591   ;                     + 30         D7    (L)
                     592   ;                     + 32         A0    (H)
                     593   ;                     + 34         A0    (L)
                     594   ;                     + 36         A1    (H)
                     595   ;                     + 38         A1    (L)
                     596   ;                     + 40         A2    (H)
                     597   ;                     + 42         A2    (L)
                     598   ;                     + 44         A3    (H)
                     599   ;                     + 46         A3    (L)
                     600   ;                     + 48         A4    (H)
                     601   ;                     + 50         A4    (L)
                     602   ;                     + 52         A5    (H)
                     603   ;                     + 54         A5    (L)
                     604   ;                     + 56         A6    (H)
                     605   ;                     + 58         A6    (L)
                     606   ;                     + 60         Task or ISR's SR
                     607   ;                     + 62         PC of task  (H)
                     608   ;                     + 64         PC of task  (L)                   High Memory
                     609   ;********************************************************************************************************
                     610   
                     611   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                     612   
                     613   ; void OSIntExit (void)
                     614   ; {
                     615   ;           OS_ENTER_CRITICAL();
                     616   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                     617   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                     618   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                     619   ;                       if (OSPrioHighRdy != OSPrioCur) {
                     620   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                     621   ;                                       OSCtxSwCtr++;
                     622   ;                                       OSIntCtxSw();
                     623   ;                       }
                     624   ;           }
                     625   ;           OS_EXIT_CRITICAL();
                     626   ; }
                     627   
                     628   OSIntExit68K:
00000714  5339 0800  629           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
00000718  0426      
0000071A  6600 009C  630           bne       OSIntExit68K_1
0000071E  4A39 0800  631           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
00000722  0428      
00000724  6600 0092  632           bne       OSIntExit68K_1
                     633   
                     634   ;       re-enabling interrupts
00000728  302F 003C  635           move.w    (60,A7),D0                    ; must be LAST nested ISR
0000072C  C07C 0700  636           and.w     #$0700,D0                     ; do we want to change S bit in SR
                     637   ;
00000730  6600 0086  638           bne       OSIntExit68K_1
00000734  41F9 0000  639           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000738  768C      
0000073A  4280       640           clr.l     D0
0000073C  1039 0800  641           move.b    _OSRdyGrp,D0
00000740  042E      
00000742  1230 0800  642           move.b    0(A0,D0.L),D1                 ;  y in D1
                     643   ;
00000746  41F9 0800  644           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
0000074A  0430      
0000074C  4280       645           clr.l     D0
0000074E  1001       646           move.b    D1,D0
00000750  41F0 0800  647           lea       0(A0,D0.L),A0
00000754  4280       648           clr.l     D0
00000756  1010       649           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000758  41F9 0000  650           lea       _OSUnMapTbl,A0
0000075C  768C      
0000075E  41F0 0800  651           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
00000762  1001       652           move.b    D1,D0
00000764  E708       653           lsl.b     #3,D0                         ;  (y << 3) in D0
00000766  D010       654           add.b     (A0),D0
00000768  13C0 0800  655           move.b    D0,_OSPrioHighRdy
0000076C  042C      
                     656   ;
0000076E  B039 0800  657           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
00000772  042A      
00000774  6742       658           beq.s     OSIntExit68K_1
                     659   ;
00000776  41F9 0800  660           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
0000077A  0550      
0000077C  4281       661           clr.l     D1
0000077E  1200       662           move.b    D0,D1
00000780  E589       663           lsl.l     #2,D1
00000782  41F0 1800  664           lea       0(A0,D1.L),A0
00000786  23D0 0800  665           move.l    (A0),_OSTCBHighRdy
0000078A  0548      
                     666   ;
0000078C  52B9 0800  667           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
00000790  01F6      
                     668   ;
00000792  2079 0800  669           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
00000796  0540      
00000798  208F       670           move.l    A7,(A0)
0000079A  4EB9 0000  671           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
0000079E  09AC      
000007A0  2079 0800  672           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
000007A4  0548      
000007A6  23C8 0800  673           move.l    A0,_OSTCBCur
000007AA  0540      
000007AC  13F9 0800  674           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
000007B0  042C 0800 
000007B4  042A      
000007B6  2E50       675           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     676   OSIntExit68K_1:
000007B8  4CDF 7FFF  677           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
000007BC  4E73       678           rte                                     ;  Return to task or nested ISR
                     679   
                     680   ;********************************************************************************************************
                     681   ;                                           SYSTEM TICK ISR
                     682   ;
                     683   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     684   ;
                     685   ; Arguments   : none
                     686   ;
                     687   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     688   ;               2) You MUST save ALL the CPU registers as shown below
                     689   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     690   ;********************************************************************************************************
                     691   
                     692   ; C Code for OSInterrupt exit taken from text book on OS example program
                     693   
                     694   ; void OSTickISR(void)
                     695   ; {
                     696   ;          Save processor registers;
                     697   ;          Call OSIntEnter() or increment OSIntNesting;
                     698   ;          Call OSTimeTick();
                     699   ;          Call OSIntExit();
                     700   ;          Restore processor registers;
                     701   ;          Execute a return from interrupt instruction;
                     702   ; }
                     703   
                     704   
                     705   _OSTickISR:
000007BE  007C 0700  706           or.w      #$0700,SR                     ; Disable ALL interrupts
000007C2  5239 0800  707           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
000007C6  0426      
000007C8  48E7 FFFE  708           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                     709           ; call your ISR here to clear the tick interrupt
000007CC  4EB9 0000  710           jsr       _Timer_ISR
000007D0  5C84      
                     711           ;
000007D2  4EB9 0000  712           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
000007D6  100A      
000007D8  6000 FF3A  713           bra       OSIntExit68K                  ; Exit ISR
                     714   ; C:\CPEN412\ASN6\ASN6B_INTERRUPTS\ASN6B_APPLICATION.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     715   ; /*
                     716   ; * EXAMPLE_1.C
                     717   ; *
                     718   ; * This is a minimal program to verify multitasking.
                     719   ; *
                     720   ; */
                     721   ; #include <stdio.h>
                     722   ; #include "Bios.h"
                     723   ; #include "ucos_ii.h"
                     724   ; #include "Canbus-Controller.h"
                     725   ; #define STACKSIZE 256
                     726   ; /*******************************************************************************************
                     727   ; ** ADC Types
                     728   ; *******************************************************************************************/
                     729   ; #define TEMP        0
                     730   ; #define POTENTIAL   1
                     731   ; #define LIGHT       2
                     732   ; #define SWITCHES    3
                     733   ; /***Global Variables for Timer ISR*/
                     734   ; unsigned char Timer5Count;
                     735   ; void Timer_IRQ()
                     736   ; {
                     737   _Timer_IRQ:
                     738   ; if (Timer5Status == 1) {        // Did Timer 5 produce the Interrupt?
000007DC  1039 0040  739          move.b    4194610,D0
000007E0  0132      
000007E2  0C00 0001  740          cmp.b     #1,D0
000007E6  6628       741          bne.s     Timer_IRQ_1
                     742   ; Timer5Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
000007E8  13FC 0003  743          move.b    #3,4194610
000007EC  0040 0132 
                     744   ; PortE = Timer5Count++;      
000007F0  1039 0800  745          move.b    _Timer5Count.L,D0
000007F4  01E8      
000007F6  5239 0800  746          addq.b    #1,_Timer5Count.L
000007FA  01E8      
000007FC  13C0 0040  747          move.b    D0,4194312
00000800  0008      
                     748   ; printf("\r\nHello");
00000802  4879 0000  749          pea       @asn6b_~1_1.L
00000806  760A      
00000808  4EB9 0000  750          jsr       _printf
0000080C  6A6A      
0000080E  584F       751          addq.w    #4,A7
                     752   Timer_IRQ_1:
00000810  4E75       753          rts
                     754   ; }
                     755   ; }
                     756   ; /*******************************************************************************************
                     757   ; ** Global Variables
                     758   ; *******************************************************************************************/
                     759   ; unsigned char temp, potential, light;
                     760   ; int switches;
                     761   ; /*********************************************************************************************************************************
                     762   ; **  IMPORTANT FUNCTION
                     763   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                     764   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                     765   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                     766   ; **  Calling this function allows you to deal with Interrupts for example
                     767   ; ***********************************************************************************************************************************/
                     768   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     769   ; {
                     770   _InstallExceptionHandler:
00000812  4E56 FFFC  771          link      A6,#-4
                     772   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000816  2D7C 0B00  773          move.l    #184549376,-4(A6)
0000081A  0000 FFFC 
                     774   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
0000081E  206E FFFC  775          move.l    -4(A6),A0
00000822  202E 000C  776          move.l    12(A6),D0
00000826  E588       777          lsl.l     #2,D0
00000828  21AE 0008  778          move.l    8(A6),0(A0,D0.L)
0000082C  0800      
0000082E  4E5E       779          unlk      A6
00000830  4E75       780          rts
                     781   ; }
                     782   ; /*
                     783   ; ** Our main application which has to
                     784   ; ** 1) Initialise any peripherals on the board, e.g. RS232 for hyperterminal + LCD
                     785   ; ** 2) Call OSInit() to initialise the OS
                     786   ; ** 3) Create our application task/threads
                     787   ; ** 4) Call OSStart()
                     788   ; */
                     789   ; void main(void)
                     790   ; {
                     791   _main:
00000832  2F02       792          move.l    D2,-(A7)
                     793   ; unsigned char IQR_Check;
                     794   ; // initialise board hardware by calling our routines from the BIOS.C source file
                     795   ; Init_RS232();
00000834  4EB9 0000  796          jsr       _Init_RS232
00000838  5AFA      
                     797   ; Init_LCD();
0000083A  4EB9 0000  798          jsr       _Init_LCD
0000083E  5BB2      
                     799   ; scanflush() ;                       // flush any text that may have been typed ahead
00000840  4EB9 0000  800          jsr       _scanflush
00000844  6460      
                     801   ; // initialise CanBus controllers
                     802   ; Init_CanBus_Controller0();
00000846  4EB9 0000  803          jsr       _Init_CanBus_Controller0
0000084A  5CAC      
                     804   ; Init_CanBus_Controller1();
0000084C  4EB9 0000  805          jsr       _Init_CanBus_Controller1
00000850  5D3C      
                     806   ; printf("Matthew Tong and Ayomibo Awosika\n");
00000852  4879 0000  807          pea       @asn6b_~1_2.L
00000856  7612      
00000858  4EB9 0000  808          jsr       _printf
0000085C  6A6A      
0000085E  584F       809          addq.w    #4,A7
                     810   ; Timer5Count = 0;
00000860  4239 0800  811          clr.b     _Timer5Count.L
00000864  01E8      
                     812   ; InstallExceptionHandler(Timer_IRQ, 30);
00000866  4878 001E  813          pea       30
0000086A  4878 07DC  814          pea       _Timer_IRQ.L
0000086E  4EB8 0812  815          jsr       _InstallExceptionHandler
00000872  504F       816          addq.w    #8,A7
                     817   ; Timer5Data = 0x30;
00000874  13FC 0030  818          move.b    #48,4194608
00000878  0040 0130 
                     819   ; Timer5Control = 3;
0000087C  13FC 0003  820          move.b    #3,4194610
00000880  0040 0132 
                     821   ; IQR_Check = 0;
00000884  4202       822          clr.b     D2
                     823   ; while(1){
                     824   main_1:
                     825   ; if(Timer5Count != IQR_Check){
00000886  B439 0800  826          cmp.b     _Timer5Count.L,D2
0000088A  01E8      
0000088C  672A       827          beq.s     main_4
                     828   ; if (Timer5Count % 1 == 0){
0000088E  1039 0800  829          move.b    _Timer5Count.L,D0
00000892  01E8      
00000894  C0BC 0000  830          and.l     #65535,D0
00000898  FFFF      
0000089A  80FC 0001  831          divu.w    #1,D0
0000089E  4840       832          swap      D0
000008A0  4A00       833          tst.b     D0
000008A2  660E       834          bne.s     main_6
                     835   ; printf("HEHE");
000008A4  4879 0000  836          pea       @asn6b_~1_3.L
000008A8  7634      
000008AA  4EB9 0000  837          jsr       _printf
000008AE  6A6A      
000008B0  584F       838          addq.w    #4,A7
                     839   main_6:
                     840   ; //CanBus0_Transmit(switches) ;       
                     841   ; //CanBus1_Receive(SWITCHES) ; 
                     842   ; }/*
                     843   ; if (Timer5Count % 2 == 0){
                     844   ; CanBus0_Transmit(potential) ;       
                     845   ; CanBus1_Receive(POTENTIAL) ; 
                     846   ; }
                     847   ; if (Timer5Count % 5 == 0){
                     848   ; CanBus0_Transmit(light) ;       
                     849   ; CanBus1_Receive(LIGHT) ; 
                     850   ; }
                     851   ; if (Timer5Count % 20 == 0){
                     852   ; CanBus0_Transmit(temp) ;       
                     853   ; CanBus1_Receive(TEMP) ; 
                     854   ; }
                     855   ; */
                     856   ; IQR_Check = Timer5Count;    
000008B2  1439 0800  857          move.b    _Timer5Count.L,D2
000008B6  01E8      
                     858   main_4:
000008B8  60CC       859          bra       main_1
                     860   ; } 
                     861   ; }
                     862   ; }
                     863   ; C:\CPEN412\ASN6\ASN6B_INTERRUPTS\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     864   ; /*
                     865   ; *********************************************************************************************************
                     866   ; *                                               uC/OS-II
                     867   ; *                                         The Real-Time Kernel
                     868   ; *
                     869   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                     870   ; *                                          All Rights Reserved
                     871   ; *
                     872   ; *
                     873   ; *                                         68000 Specific C code
                     874   ; *                                                IDE68K
                     875   ; *
                     876   ; * File         : OS_CPU_C.C
                     877   ; * By           : Jean J. Labrosse
                     878   ; *********************************************************************************************************
                     879   ; */
                     880   ; #ifndef  OS_MASTER_FILE
                     881   ; #include "ucos_ii.h"
                     882   ; #endif
                     883   ; #include "Bios.h"
                     884   ; /*
                     885   ; *********************************************************************************************************
                     886   ; *                                           REVISION HISTORY
                     887   ; *
                     888   ; * $Log$
                     889   ; *
                     890   ; *********************************************************************************************************
                     891   ; */
                     892   ; #if OS_TMR_EN > 0
                     893   ; INT8U OSTmrTickCtr;
                     894   ; #endif
                     895   ; /*$PAGE*/
                     896   ; /*
                     897   ; *********************************************************************************************************
                     898   ; *                                        INITIALIZE A TASK'S STACK
                     899   ; *
                     900   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                     901   ; *              stack frame of the task being created.  This function is highly processor specific.
                     902   ; *
                     903   ; * Arguments  : task          is a pointer to the task code
                     904   ; *
                     905   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                     906   ; *                            when the task first executes.
                     907   ; *
                     908   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                     909   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                     910   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                     911   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                     912   ; *                            of the stack.
                     913   ; *
                     914   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                     915   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                     916   ; *
                     917   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                     918   ; *              been placed on the stack in the proper order.
                     919   ; *
                     920   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                     921   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                     922   ; *                 mode.
                     923   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                     924   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                     925   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                     926   ; *                 OSTaskIdle() and OSTaskStat().
                     927   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                     928   ; *********************************************************************************************************
                     929   ; */
                     930   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                     931   ; {
                     932   _OSTaskStkInit:
000008BA  4E56 0000  933          link      A6,#0
000008BE  48E7 3000  934          movem.l   D2/D3,-(A7)
                     935   ; INT32U  *pstk32;
                     936   ; INT16U  *pstk16;
                     937   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                     938   ; /* Load stack pointer and align on 32-bit bound  */
                     939   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
000008C2  202E 0010  940          move.l    16(A6),D0
000008C6  C0BC 7FFF  941          and.l     #2147483647,D0
000008CA  FFFF      
000008CC  2400       942          move.l    D0,D2
                     943   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                     944   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
000008CE  5982       945          subq.l    #4,D2
000008D0  2042       946          move.l    D2,A0
000008D2  20AE 000C  947          move.l    12(A6),(A0)
                     948   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
000008D6  5982       949          subq.l    #4,D2
000008D8  2042       950          move.l    D2,A0
000008DA  20AE 0008  951          move.l    8(A6),(A0)
                     952   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                     953   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
000008DE  5982       954          subq.l    #4,D2
000008E0  2042       955          move.l    D2,A0
000008E2  20AE 0008  956          move.l    8(A6),(A0)
                     957   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
000008E6  2602       958          move.l    D2,D3
                     959   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
000008E8  5583       960          subq.l    #2,D3
000008EA  2043       961          move.l    D3,A0
000008EC  30BC 2000  962          move.w    #8192,(A0)
                     963   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
000008F0  2403       964          move.l    D3,D2
                     965   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                     966   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
000008F2  5982       967          subq.l    #4,D2
000008F4  2042       968          move.l    D2,A0
000008F6  20BC 00A6  969          move.l    #10879142,(A0)
000008FA  00A6      
                     970   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
000008FC  5982       971          subq.l    #4,D2
000008FE  2042       972          move.l    D2,A0
00000900  20BC 00A5  973          move.l    #10813605,(A0)
00000904  00A5      
                     974   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
00000906  5982       975          subq.l    #4,D2
00000908  2042       976          move.l    D2,A0
0000090A  20BC 00A4  977          move.l    #10748068,(A0)
0000090E  00A4      
                     978   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
00000910  5982       979          subq.l    #4,D2
00000912  2042       980          move.l    D2,A0
00000914  20BC 00A3  981          move.l    #10682531,(A0)
00000918  00A3      
                     982   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
0000091A  5982       983          subq.l    #4,D2
0000091C  2042       984          move.l    D2,A0
0000091E  20BC 00A2  985          move.l    #10616994,(A0)
00000922  00A2      
                     986   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
00000924  5982       987          subq.l    #4,D2
00000926  2042       988          move.l    D2,A0
00000928  20BC 00A1  989          move.l    #10551457,(A0)
0000092C  00A1      
                     990   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
0000092E  5982       991          subq.l    #4,D2
00000930  2042       992          move.l    D2,A0
00000932  20BC 00A0  993          move.l    #10485920,(A0)
00000936  00A0      
                     994   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
00000938  5982       995          subq.l    #4,D2
0000093A  2042       996          move.l    D2,A0
0000093C  20BC 00D7  997          move.l    #14090455,(A0)
00000940  00D7      
                     998   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000942  5982       999          subq.l    #4,D2
00000944  2042      1000          move.l    D2,A0
00000946  20BC 00D6 1001          move.l    #14024918,(A0)
0000094A  00D6      
                    1002   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
0000094C  5982      1003          subq.l    #4,D2
0000094E  2042      1004          move.l    D2,A0
00000950  20BC 00D5 1005          move.l    #13959381,(A0)
00000954  00D5      
                    1006   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
00000956  5982      1007          subq.l    #4,D2
00000958  2042      1008          move.l    D2,A0
0000095A  20BC 00D4 1009          move.l    #13893844,(A0)
0000095E  00D4      
                    1010   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000960  5982      1011          subq.l    #4,D2
00000962  2042      1012          move.l    D2,A0
00000964  20BC 00D3 1013          move.l    #13828307,(A0)
00000968  00D3      
                    1014   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
0000096A  5982      1015          subq.l    #4,D2
0000096C  2042      1016          move.l    D2,A0
0000096E  20BC 00D2 1017          move.l    #13762770,(A0)
00000972  00D2      
                    1018   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
00000974  5982      1019          subq.l    #4,D2
00000976  2042      1020          move.l    D2,A0
00000978  20BC 00D1 1021          move.l    #13697233,(A0)
0000097C  00D1      
                    1022   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
0000097E  5982      1023          subq.l    #4,D2
00000980  2042      1024          move.l    D2,A0
00000982  20BC 00D0 1025          move.l    #13631696,(A0)
00000986  00D0      
                    1026   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
00000988  2002      1027          move.l    D2,D0
0000098A  4CDF 000C 1028          movem.l   (A7)+,D2/D3
0000098E  4E5E      1029          unlk      A6
00000990  4E75      1030          rts
                    1031   ; }
                    1032   ; /*$PAGE*/
                    1033   ; /*
                    1034   ; *********************************************************************************************************
                    1035   ; *                                             GET ISR VECTOR
                    1036   ; *
                    1037   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                    1038   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                    1039   ; *
                    1040   ; * Arguments  : vect     is the vector number
                    1041   ; *
                    1042   ; * Note(s)    : 1) Interrupts are disabled during this call
                    1043   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                    1044   ; *********************************************************************************************************
                    1045   ; */
                    1046   ; /*$PAGE*/
                    1047   ; #if OS_CPU_HOOKS_EN
                    1048   ; /*
                    1049   ; *********************************************************************************************************
                    1050   ; *                                       OS INITIALIZATION HOOK
                    1051   ; *                                            (BEGINNING)
                    1052   ; *
                    1053   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                    1054   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                    1055   ; *
                    1056   ; * Arguments  : none
                    1057   ; *
                    1058   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1059   ; *********************************************************************************************************
                    1060   ; */
                    1061   ; void OSInitHookBegin(void)
                    1062   ; {
                    1063   _OSInitHookBegin:
00000992  4E75      1064          rts
                    1065   ; }
                    1066   ; /*
                    1067   ; *********************************************************************************************************
                    1068   ; *                                       OS INITIALIZATION HOOK
                    1069   ; *                                               (END)
                    1070   ; *
                    1071   ; * Description: This function is called by OSInit() at the end of OSInit().
                    1072   ; *
                    1073   ; * Arguments  : none
                    1074   ; *
                    1075   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1076   ; *********************************************************************************************************
                    1077   ; */
                    1078   ; void OSInitHookEnd(void)
                    1079   ; {
                    1080   _OSInitHookEnd:
                    1081   ; #if OS_TMR_EN > 0
                    1082   ; OSTmrTickCtr = 0;
00000994  4239 0800 1083          clr.b     _OSTmrTickCtr.L
00000998  01F4      
0000099A  4E75      1084          rts
                    1085   ; #endif
                    1086   ; }
                    1087   ; /*
                    1088   ; *********************************************************************************************************
                    1089   ; *                                          TASK CREATION HOOK
                    1090   ; *
                    1091   ; * Description: This function is called when a task is created.
                    1092   ; *
                    1093   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                    1094   ; *
                    1095   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1096   ; *********************************************************************************************************
                    1097   ; */
                    1098   ; void OSTaskCreateHook(OS_TCB *ptcb)
                    1099   ; {
                    1100   _OSTaskCreateHook:
0000099C  4E56 0000 1101          link      A6,#0
000009A0  4E5E      1102          unlk      A6
000009A2  4E75      1103          rts
                    1104   ; }
                    1105   ; /*
                    1106   ; *********************************************************************************************************
                    1107   ; *                                           TASK DELETION HOOK
                    1108   ; *
                    1109   ; * Description: This function is called when a task is deleted.
                    1110   ; *
                    1111   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                    1112   ; *
                    1113   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1114   ; *********************************************************************************************************
                    1115   ; */
                    1116   ; void OSTaskDelHook(OS_TCB *ptcb)
                    1117   ; {
                    1118   _OSTaskDelHook:
000009A4  4E56 0000 1119          link      A6,#0
000009A8  4E5E      1120          unlk      A6
000009AA  4E75      1121          rts
                    1122   ; }
                    1123   ; /*
                    1124   ; *********************************************************************************************************
                    1125   ; *                                           TASK SWITCH HOOK
                    1126   ; *
                    1127   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                    1128   ; *              operations during a context switch.
                    1129   ; *
                    1130   ; * Arguments  : none
                    1131   ; *
                    1132   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1133   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                    1134   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                    1135   ; *                 task being switched out (i.e. the preempted task).
                    1136   ; *********************************************************************************************************
                    1137   ; */
                    1138   ; void OSTaskSwHook(void)
                    1139   ; {
                    1140   _OSTaskSwHook:
000009AC  4E75      1141          rts
                    1142   ; }
                    1143   ; /*
                    1144   ; *********************************************************************************************************
                    1145   ; *                                           TASK IDLE HOOK
                    1146   ; *
                    1147   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                    1148   ; *              operations during the idle task.
                    1149   ; *
                    1150   ; * Arguments  : none
                    1151   ; *
                    1152   ; * Note(s)    : none
                    1153   ; *********************************************************************************************************
                    1154   ; */
                    1155   ; void OSTaskIdleHook(void)
                    1156   ; {
                    1157   _OSTaskIdleHook:
000009AE  4E75      1158          rts
                    1159   ; }
                    1160   ; /*
                    1161   ; *********************************************************************************************************
                    1162   ; *                                           TASK RETURN HOOK
                    1163   ; *
                    1164   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1165   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1166   ; *
                    1167   ; * Arguments  : Pointer to currently running TCB
                    1168   ; *
                    1169   ; * Note(s)    : none
                    1170   ; *********************************************************************************************************
                    1171   ; */
                    1172   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1173   ; {
                    1174   _OSTaskReturnHook:
000009B0  4E56 0000 1175          link      A6,#0
000009B4  4E5E      1176          unlk      A6
000009B6  4E75      1177          rts
                    1178   ; }
                    1179   ; /*
                    1180   ; *********************************************************************************************************
                    1181   ; *                                           STATISTIC TASK HOOK
                    1182   ; *
                    1183   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1184   ; *              application to add functionality to the statistics task.
                    1185   ; *
                    1186   ; * Arguments  : none
                    1187   ; *********************************************************************************************************
                    1188   ; */
                    1189   ; void OSTaskStatHook(void)
                    1190   ; {
                    1191   _OSTaskStatHook:
000009B8  4E75      1192          rts
                    1193   ; }
                    1194   ; /*
                    1195   ; *********************************************************************************************************
                    1196   ; *                                               TICK HOOK
                    1197   ; *
                    1198   ; * Description: This function is called every tick.
                    1199   ; *
                    1200   ; * Arguments  : none
                    1201   ; *
                    1202   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1203   ; *********************************************************************************************************
                    1204   ; */
                    1205   ; void OSTimeTickHook(void)
                    1206   ; {
                    1207   _OSTimeTickHook:
                    1208   ; #if OS_TMR_EN > 0
                    1209   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
000009BA  3039 0800 1210          move.w    _OSTmrUsed.L,D0
000009BE  0E9C      
000009C0  0C40 0000 1211          cmp.w     #0,D0
000009C4  631E      1212          bls.s     OSTimeTickHook_1
000009C6  5239 0800 1213          addq.b    #1,_OSTmrTickCtr.L
000009CA  01F4      
000009CC  1039 0800 1214          move.b    _OSTmrTickCtr.L,D0
000009D0  01F4      
000009D2  0C00 000A 1215          cmp.b     #10,D0
000009D6  650C      1216          blo.s     OSTimeTickHook_1
                    1217   ; OSTmrTickCtr = 0;
000009D8  4239 0800 1218          clr.b     _OSTmrTickCtr.L
000009DC  01F4      
                    1219   ; OSTmrSignal();
000009DE  4EB9 0000 1220          jsr       _OSTmrSignal
000009E2  5684      
                    1221   OSTimeTickHook_1:
000009E4  4E75      1222          rts
                    1223   ; }
                    1224   ; #endif
                    1225   ; }
                    1226   ; /*
                    1227   ; *********************************************************************************************************
                    1228   ; *                                           OSTCBInit() HOOK
                    1229   ; *
                    1230   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1231   ; *
                    1232   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1233   ; *
                    1234   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1235   ; *********************************************************************************************************
                    1236   ; */
                    1237   ; #if OS_VERSION > 203
                    1238   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1239   ; {
                    1240   _OSTCBInitHook:
000009E6  4E56 0000 1241          link      A6,#0
000009EA  4E5E      1242          unlk      A6
000009EC  4E75      1243          rts
                    1244   ; }
                    1245   ; #endif
                    1246   ; #endif // OS_CPU_HOOKS_EN
                    1247   ; C:\CPEN412\ASN6\ASN6B_INTERRUPTS\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1248   ; /*
                    1249   ; *********************************************************************************************************
                    1250   ; *                                                uC/OS-II
                    1251   ; *                                          The Real-Time Kernel
                    1252   ; *                                             CORE FUNCTIONS
                    1253   ; *
                    1254   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1255   ; *                                           All Rights Reserved
                    1256   ; *
                    1257   ; * File    : OS_CORE.C
                    1258   ; * By      : Jean J. Labrosse
                    1259   ; * Version : V2.92.07
                    1260   ; *
                    1261   ; * LICENSING TERMS:
                    1262   ; * ---------------
                    1263   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1264   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1265   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1266   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1267   ; * licensing fee.
                    1268   ; *********************************************************************************************************
                    1269   ; */
                    1270   ; #define  MICRIUM_SOURCE
                    1271   ; #ifndef  OS_MASTER_FILE
                    1272   ; #define  OS_GLOBALS
                    1273   ; #include <ucos_ii.h>
                    1274   ; #endif
                    1275   ; /*
                    1276   ; *********************************************************************************************************
                    1277   ; *                                      PRIORITY RESOLUTION TABLE
                    1278   ; *
                    1279   ; * Note: Index into table is bit pattern to resolve highest priority
                    1280   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1281   ; *********************************************************************************************************
                    1282   ; */
                    1283   ; INT8U  const  OSUnMapTbl[256] = {
                    1284   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1285   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1286   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1287   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1288   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1289   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1290   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1291   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1292   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1293   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1294   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1295   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1296   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1297   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1298   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1299   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1300   ; };
                    1301   ; /*$PAGE*/
                    1302   ; /*
                    1303   ; *********************************************************************************************************
                    1304   ; *                                         FUNCTION PROTOTYPES
                    1305   ; *********************************************************************************************************
                    1306   ; */
                    1307   ; static  void  OS_InitEventList(void);
                    1308   ; static  void  OS_InitMisc(void);
                    1309   ; static  void  OS_InitRdyList(void);
                    1310   ; static  void  OS_InitTaskIdle(void);
                    1311   ; #if OS_TASK_STAT_EN > 0u
                    1312   ; static  void  OS_InitTaskStat(void);
                    1313   ; #endif
                    1314   ; static  void  OS_InitTCBList(void);
                    1315   ; static  void  OS_SchedNew(void);
                    1316   ; /*$PAGE*/
                    1317   ; /*
                    1318   ; *********************************************************************************************************
                    1319   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1320   ; *
                    1321   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1322   ; *
                    1323   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1324   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1325   ; *                        type is irrelevant.
                    1326   ; *
                    1327   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1328   ; *                        mutex, mailbox or queue.
                    1329   ; *
                    1330   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1331   ; *
                    1332   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1333   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1334   ; *                                                   control block type.
                    1335   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1336   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1337   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1338   ; *
                    1339   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1340   ; *********************************************************************************************************
                    1341   ; */
                    1342   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1343   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1344   ; INT8U     **pname,
                    1345   ; INT8U      *perr)
                    1346   ; {
                    1347   _OSEventNameGet:
000009EE  4E56 FFFC 1348          link      A6,#-4
000009F2  2F02      1349          move.l    D2,-(A7)
000009F4  242E 0010 1350          move.l    16(A6),D2
                    1351   ; INT8U      len;
                    1352   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1353   ; OS_CPU_SR  cpu_sr = 0u;
                    1354   ; #endif
                    1355   ; #ifdef OS_SAFETY_CRITICAL
                    1356   ; if (perr == (INT8U *)0) {
                    1357   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1358   ; return (0u);
                    1359   ; }
                    1360   ; #endif
                    1361   ; #if OS_ARG_CHK_EN > 0u
                    1362   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1363   ; *perr = OS_ERR_PEVENT_NULL;
                    1364   ; return (0u);
                    1365   ; }
                    1366   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1367   ; *perr = OS_ERR_PNAME_NULL;
                    1368   ; return (0u);
                    1369   ; }
                    1370   ; #endif
                    1371   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000009F8  1039 0800 1372          move.b    _OSIntNesting.L,D0
000009FC  0426      
000009FE  0C00 0000 1373          cmp.b     #0,D0
00000A02  630C      1374          bls.s     OSEventNameGet_1
                    1375   ; *perr  = OS_ERR_NAME_GET_ISR;
00000A04  2042      1376          move.l    D2,A0
00000A06  10BC 0011 1377          move.b    #17,(A0)
                    1378   ; return (0u);
00000A0A  4200      1379          clr.b     D0
00000A0C  6000 0066 1380          bra       OSEventNameGet_3
                    1381   OSEventNameGet_1:
                    1382   ; }
                    1383   ; switch (pevent->OSEventType) {
00000A10  206E 0008 1384          move.l    8(A6),A0
00000A14  1010      1385          move.b    (A0),D0
00000A16  C0BC 0000 1386          and.l     #255,D0
00000A1A  00FF      
00000A1C  5380      1387          subq.l    #1,D0
00000A1E  651C      1388          blo.s     OSEventNameGet_4
00000A20  0C80 0000 1389          cmp.l     #4,D0
00000A24  0004      
00000A26  6414      1390          bhs.s     OSEventNameGet_4
00000A28  E380      1391          asl.l     #1,D0
00000A2A  303B 0806 1392          move.w    OSEventNameGet_6(PC,D0.L),D0
00000A2E  4EFB 0002 1393          jmp       OSEventNameGet_6(PC,D0.W)
                    1394   OSEventNameGet_6:
00000A32  0008      1395          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000A34  0008      1396          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000A36  0008      1397          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000A38  0008      1398          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1399   OSEventNameGet_7:
                    1400   ; case OS_EVENT_TYPE_SEM:
                    1401   ; case OS_EVENT_TYPE_MUTEX:
                    1402   ; case OS_EVENT_TYPE_MBOX:
                    1403   ; case OS_EVENT_TYPE_Q:
                    1404   ; break;
00000A3A  600A      1405          bra.s     OSEventNameGet_5
                    1406   OSEventNameGet_4:
                    1407   ; default:
                    1408   ; *perr = OS_ERR_EVENT_TYPE;
00000A3C  2042      1409          move.l    D2,A0
00000A3E  10BC 0001 1410          move.b    #1,(A0)
                    1411   ; return (0u);
00000A42  4200      1412          clr.b     D0
00000A44  602E      1413          bra.s     OSEventNameGet_3
                    1414   OSEventNameGet_5:
                    1415   ; }
                    1416   ; OS_ENTER_CRITICAL();
00000A46  40E7      1417          dc.w      16615
00000A48  007C      1418          dc.w      124
00000A4A  0700      1419          dc.w      1792
                    1420   ; *pname = pevent->OSEventName;
00000A4C  206E 0008 1421          move.l    8(A6),A0
00000A50  226E 000C 1422          move.l    12(A6),A1
00000A54  22A8 0012 1423          move.l    18(A0),(A1)
                    1424   ; len    = OS_StrLen(*pname);
00000A58  206E 000C 1425          move.l    12(A6),A0
00000A5C  2F10      1426          move.l    (A0),-(A7)
00000A5E  4EB9 0000 1427          jsr       _OS_StrLen
00000A62  1762      
00000A64  584F      1428          addq.w    #4,A7
00000A66  1D40 FFFF 1429          move.b    D0,-1(A6)
                    1430   ; OS_EXIT_CRITICAL();
00000A6A  46DF      1431          dc.w      18143
                    1432   ; *perr  = OS_ERR_NONE;
00000A6C  2042      1433          move.l    D2,A0
00000A6E  4210      1434          clr.b     (A0)
                    1435   ; return (len);
00000A70  102E FFFF 1436          move.b    -1(A6),D0
                    1437   OSEventNameGet_3:
00000A74  241F      1438          move.l    (A7)+,D2
00000A76  4E5E      1439          unlk      A6
00000A78  4E75      1440          rts
                    1441   ; }
                    1442   ; #endif
                    1443   ; /*$PAGE*/
                    1444   ; /*
                    1445   ; *********************************************************************************************************
                    1446   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1447   ; *
                    1448   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1449   ; *
                    1450   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1451   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1452   ; *                        matter the actual type.
                    1453   ; *
                    1454   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1455   ; *                        mutex, mailbox or queue.
                    1456   ; *
                    1457   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1458   ; *
                    1459   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1460   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1461   ; *                                                   control block type.
                    1462   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1463   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1464   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1465   ; *
                    1466   ; * Returns    : None
                    1467   ; *********************************************************************************************************
                    1468   ; */
                    1469   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1470   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1471   ; INT8U     *pname,
                    1472   ; INT8U     *perr)
                    1473   ; {
                    1474   _OSEventNameSet:
00000A7A  4E56 0000 1475          link      A6,#0
00000A7E  2F02      1476          move.l    D2,-(A7)
00000A80  242E 0010 1477          move.l    16(A6),D2
                    1478   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1479   ; OS_CPU_SR  cpu_sr = 0u;
                    1480   ; #endif
                    1481   ; #ifdef OS_SAFETY_CRITICAL
                    1482   ; if (perr == (INT8U *)0) {
                    1483   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1484   ; return;
                    1485   ; }
                    1486   ; #endif
                    1487   ; #if OS_ARG_CHK_EN > 0u
                    1488   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1489   ; *perr = OS_ERR_PEVENT_NULL;
                    1490   ; return;
                    1491   ; }
                    1492   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1493   ; *perr = OS_ERR_PNAME_NULL;
                    1494   ; return;
                    1495   ; }
                    1496   ; #endif
                    1497   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000A84  1039 0800 1498          move.b    _OSIntNesting.L,D0
00000A88  0426      
00000A8A  0C00 0000 1499          cmp.b     #0,D0
00000A8E  630A      1500          bls.s     OSEventNameSet_1
                    1501   ; *perr = OS_ERR_NAME_SET_ISR;
00000A90  2042      1502          move.l    D2,A0
00000A92  10BC 0012 1503          move.b    #18,(A0)
                    1504   ; return;
00000A96  6000 004C 1505          bra       OSEventNameSet_3
                    1506   OSEventNameSet_1:
                    1507   ; }
                    1508   ; switch (pevent->OSEventType) {
00000A9A  206E 0008 1509          move.l    8(A6),A0
00000A9E  1010      1510          move.b    (A0),D0
00000AA0  C0BC 0000 1511          and.l     #255,D0
00000AA4  00FF      
00000AA6  5380      1512          subq.l    #1,D0
00000AA8  651C      1513          blo.s     OSEventNameSet_4
00000AAA  0C80 0000 1514          cmp.l     #4,D0
00000AAE  0004      
00000AB0  6414      1515          bhs.s     OSEventNameSet_4
00000AB2  E380      1516          asl.l     #1,D0
00000AB4  303B 0806 1517          move.w    OSEventNameSet_6(PC,D0.L),D0
00000AB8  4EFB 0002 1518          jmp       OSEventNameSet_6(PC,D0.W)
                    1519   OSEventNameSet_6:
00000ABC  0008      1520          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000ABE  0008      1521          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000AC0  0008      1522          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000AC2  0008      1523          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1524   OSEventNameSet_7:
                    1525   ; case OS_EVENT_TYPE_SEM:
                    1526   ; case OS_EVENT_TYPE_MUTEX:
                    1527   ; case OS_EVENT_TYPE_MBOX:
                    1528   ; case OS_EVENT_TYPE_Q:
                    1529   ; break;
00000AC4  6008      1530          bra.s     OSEventNameSet_5
                    1531   OSEventNameSet_4:
                    1532   ; default:
                    1533   ; *perr = OS_ERR_EVENT_TYPE;
00000AC6  2042      1534          move.l    D2,A0
00000AC8  10BC 0001 1535          move.b    #1,(A0)
                    1536   ; return;
00000ACC  6016      1537          bra.s     OSEventNameSet_3
                    1538   OSEventNameSet_5:
                    1539   ; }
                    1540   ; OS_ENTER_CRITICAL();
00000ACE  40E7      1541          dc.w      16615
00000AD0  007C      1542          dc.w      124
00000AD2  0700      1543          dc.w      1792
                    1544   ; pevent->OSEventName = pname;
00000AD4  206E 0008 1545          move.l    8(A6),A0
00000AD8  216E 000C 1546          move.l    12(A6),18(A0)
00000ADC  0012      
                    1547   ; OS_EXIT_CRITICAL();
00000ADE  46DF      1548          dc.w      18143
                    1549   ; *perr = OS_ERR_NONE;
00000AE0  2042      1550          move.l    D2,A0
00000AE2  4210      1551          clr.b     (A0)
                    1552   OSEventNameSet_3:
00000AE4  241F      1553          move.l    (A7)+,D2
00000AE6  4E5E      1554          unlk      A6
00000AE8  4E75      1555          rts
                    1556   ; }
                    1557   ; #endif
                    1558   ; /*$PAGE*/
                    1559   ; /*
                    1560   ; *********************************************************************************************************
                    1561   ; *                                       PEND ON MULTIPLE EVENTS
                    1562   ; *
                    1563   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1564   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1565   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1566   ; *
                    1567   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1568   ; *
                    1569   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1570   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1571   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1572   ; *
                    1573   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1574   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1575   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1576   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1577   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1578   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1579   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1580   ; *
                    1581   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1582   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1583   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1584   ; *                            events or, until the resources becomes available (or the events occur).
                    1585   ; *
                    1586   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1587   ; *                            messages are:
                    1588   ; *
                    1589   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1590   ; *                                                or, the events you are waiting for occurred; check the
                    1591   ; *                                                'pevents_rdy' array for which events are available.
                    1592   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1593   ; *                                                'pevents_rdy' array for which events were aborted.
                    1594   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1595   ; *                                                'timeout'.
                    1596   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1597   ; *                                                NULL pointer.
                    1598   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1599   ; *                                                mailboxes, and/or queues.
                    1600   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1601   ; *                                                would lead to a suspension.
                    1602   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1603   ; *
                    1604   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1605   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1606   ; *
                    1607   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1608   ; *
                    1609   ; *                        semaphores, mailboxes, queues
                    1610   ; *
                    1611   ; *                 b. Return ALL available events and messages, if any
                    1612   ; *
                    1613   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1614   ; *                      Performed in OS_EventTaskWaitMulti()
                    1615   ; *
                    1616   ; *                 d. Wait on any of multiple events
                    1617   ; *
                    1618   ; *                 e. Remove current task priority as pending from each events's wait list
                    1619   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1620   ; *
                    1621   ; *                 f. Return any event posted or aborted, if any
                    1622   ; *                      else
                    1623   ; *                    Return timeout
                    1624   ; *
                    1625   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1626   ; *                 case of any error(s).
                    1627   ; *********************************************************************************************************
                    1628   ; */
                    1629   ; /*$PAGE*/
                    1630   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1631   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1632   ; OS_EVENT  **pevents_rdy,
                    1633   ; void      **pmsgs_rdy,
                    1634   ; INT32U      timeout,
                    1635   ; INT8U      *perr)
                    1636   ; {
                    1637   _OSEventPendMulti:
00000AEA  4E56 FFFC 1638          link      A6,#-4
00000AEE  48E7 3F38 1639          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000AF2  45F9 0800 1640          lea       _OSTCBCur.L,A2
00000AF6  0540      
00000AF8  282E 0018 1641          move.l    24(A6),D4
00000AFC  2A2E 000C 1642          move.l    12(A6),D5
00000B00  266E 0010 1643          move.l    16(A6),A3
00000B04  286E 0008 1644          move.l    8(A6),A4
                    1645   ; OS_EVENT  **pevents;
                    1646   ; OS_EVENT   *pevent;
                    1647   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1648   ; OS_Q       *pq;
                    1649   ; #endif
                    1650   ; BOOLEAN     events_rdy;
                    1651   ; INT16U      events_rdy_nbr;
                    1652   ; INT8U       events_stat;
                    1653   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1654   ; OS_CPU_SR   cpu_sr = 0u;
                    1655   ; #endif
                    1656   ; #ifdef OS_SAFETY_CRITICAL
                    1657   ; if (perr == (INT8U *)0) {
                    1658   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1659   ; return (0u);
                    1660   ; }
                    1661   ; #endif
                    1662   ; #if (OS_ARG_CHK_EN > 0u)
                    1663   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1664   ; *perr =  OS_ERR_PEVENT_NULL;
                    1665   ; return (0u);
                    1666   ; }
                    1667   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1668   ; *perr =  OS_ERR_PEVENT_NULL;
                    1669   ; return (0u);
                    1670   ; }
                    1671   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1672   ; *perr =  OS_ERR_PEVENT_NULL;
                    1673   ; return (0u);
                    1674   ; }
                    1675   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1676   ; *perr =  OS_ERR_PEVENT_NULL;
                    1677   ; return (0u);
                    1678   ; }
                    1679   ; #endif
                    1680   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000B08  2045      1681          move.l    D5,A0
00000B0A  4290      1682          clr.l     (A0)
                    1683   ; pevents     =  pevents_pend;
00000B0C  2E0C      1684          move.l    A4,D7
                    1685   ; pevent      = *pevents;
00000B0E  2047      1686          move.l    D7,A0
00000B10  2410      1687          move.l    (A0),D2
                    1688   ; while  (pevent != (OS_EVENT *)0) {
                    1689   OSEventPendMulti_1:
00000B12  4A82      1690          tst.l     D2
00000B14  6700 0046 1691          beq       OSEventPendMulti_3
                    1692   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000B18  2042      1693          move.l    D2,A0
00000B1A  1010      1694          move.b    (A0),D0
00000B1C  C0BC 0000 1695          and.l     #255,D0
00000B20  00FF      
00000B22  5380      1696          subq.l    #1,D0
00000B24  6522      1697          blo.s     OSEventPendMulti_10
00000B26  0C80 0000 1698          cmp.l     #5,D0
00000B2A  0005      
00000B2C  641A      1699          bhs.s     OSEventPendMulti_10
00000B2E  E380      1700          asl.l     #1,D0
00000B30  303B 0806 1701          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000B34  4EFB 0002 1702          jmp       OSEventPendMulti_6(PC,D0.W)
                    1703   OSEventPendMulti_6:
00000B38  000C      1704          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
00000B3A  000E      1705          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
00000B3C  000A      1706          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
00000B3E  0010      1707          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000B40  0010      1708          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1709   OSEventPendMulti_7:
                    1710   ; #if (OS_SEM_EN  > 0u)
                    1711   ; case OS_EVENT_TYPE_SEM:
                    1712   ; break;
00000B42  6010      1713          bra.s     OSEventPendMulti_5
                    1714   OSEventPendMulti_8:
                    1715   ; #endif
                    1716   ; #if (OS_MBOX_EN > 0u)
                    1717   ; case OS_EVENT_TYPE_MBOX:
                    1718   ; break;
00000B44  600E      1719          bra.s     OSEventPendMulti_5
                    1720   OSEventPendMulti_9:
                    1721   ; #endif
                    1722   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1723   ; case OS_EVENT_TYPE_Q:
                    1724   ; break;
00000B46  600C      1725          bra.s     OSEventPendMulti_5
                    1726   OSEventPendMulti_10:
                    1727   ; #endif
                    1728   ; case OS_EVENT_TYPE_MUTEX:
                    1729   ; case OS_EVENT_TYPE_FLAG:
                    1730   ; default:
                    1731   ; *perr = OS_ERR_EVENT_TYPE;
00000B48  2044      1732          move.l    D4,A0
00000B4A  10BC 0001 1733          move.b    #1,(A0)
                    1734   ; return (0u);
00000B4E  4240      1735          clr.w     D0
00000B50  6000 02C2 1736          bra       OSEventPendMulti_13
                    1737   OSEventPendMulti_5:
                    1738   ; }
                    1739   ; pevents++;
00000B54  5887      1740          addq.l    #4,D7
                    1741   ; pevent = *pevents;
00000B56  2047      1742          move.l    D7,A0
00000B58  2410      1743          move.l    (A0),D2
00000B5A  60B6      1744          bra       OSEventPendMulti_1
                    1745   OSEventPendMulti_3:
                    1746   ; }
                    1747   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00000B5C  1039 0800 1748          move.b    _OSIntNesting.L,D0
00000B60  0426      
00000B62  0C00 0000 1749          cmp.b     #0,D0
00000B66  630C      1750          bls.s     OSEventPendMulti_14
                    1751   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00000B68  2044      1752          move.l    D4,A0
00000B6A  10BC 0002 1753          move.b    #2,(A0)
                    1754   ; return (0u);
00000B6E  4240      1755          clr.w     D0
00000B70  6000 02A2 1756          bra       OSEventPendMulti_13
                    1757   OSEventPendMulti_14:
                    1758   ; }
                    1759   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00000B74  1039 0800 1760          move.b    _OSLockNesting.L,D0
00000B78  0428      
00000B7A  0C00 0000 1761          cmp.b     #0,D0
00000B7E  630C      1762          bls.s     OSEventPendMulti_16
                    1763   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
00000B80  2044      1764          move.l    D4,A0
00000B82  10BC 000D 1765          move.b    #13,(A0)
                    1766   ; return (0u);
00000B86  4240      1767          clr.w     D0
00000B88  6000 028A 1768          bra       OSEventPendMulti_13
                    1769   OSEventPendMulti_16:
                    1770   ; }
                    1771   ; /*$PAGE*/
                    1772   ; events_rdy     =  OS_FALSE;
00000B8C  422E FFFE 1773          clr.b     -2(A6)
                    1774   ; events_rdy_nbr =  0u;
00000B90  4243      1775          clr.w     D3
                    1776   ; events_stat    =  OS_STAT_RDY;
00000B92  422E FFFF 1777          clr.b     -1(A6)
                    1778   ; pevents        =  pevents_pend;
00000B96  2E0C      1779          move.l    A4,D7
                    1780   ; pevent         = *pevents;
00000B98  2047      1781          move.l    D7,A0
00000B9A  2410      1782          move.l    (A0),D2
                    1783   ; OS_ENTER_CRITICAL();
00000B9C  40E7      1784          dc.w      16615
00000B9E  007C      1785          dc.w      124
00000BA0  0700      1786          dc.w      1792
                    1787   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    1788   OSEventPendMulti_18:
00000BA2  4A82      1789          tst.l     D2
00000BA4  6700 010A 1790          beq       OSEventPendMulti_20
                    1791   ; switch (pevent->OSEventType) {
00000BA8  2042      1792          move.l    D2,A0
00000BAA  1010      1793          move.b    (A0),D0
00000BAC  C0BC 0000 1794          and.l     #255,D0
00000BB0  00FF      
00000BB2  5380      1795          subq.l    #1,D0
00000BB4  6500 00DE 1796          blo       OSEventPendMulti_27
00000BB8  0C80 0000 1797          cmp.l     #5,D0
00000BBC  0005      
00000BBE  6400 00D4 1798          bhs       OSEventPendMulti_27
00000BC2  E380      1799          asl.l     #1,D0
00000BC4  303B 0806 1800          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000BC8  4EFB 0002 1801          jmp       OSEventPendMulti_23(PC,D0.W)
                    1802   OSEventPendMulti_23:
00000BCC  003A      1803          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
00000BCE  0068      1804          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000BD0  000A      1805          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000BD2  00C8      1806          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000BD4  00C8      1807          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    1808   OSEventPendMulti_24:
                    1809   ; #if (OS_SEM_EN > 0u)
                    1810   ; case OS_EVENT_TYPE_SEM:
                    1811   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000BD6  2042      1812          move.l    D2,A0
00000BD8  3028 0006 1813          move.w    6(A0),D0
00000BDC  0C40 0000 1814          cmp.w     #0,D0
00000BE0  631A      1815          bls.s     OSEventPendMulti_30
                    1816   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000BE2  2002      1817          move.l    D2,D0
00000BE4  5C80      1818          addq.l    #6,D0
00000BE6  2040      1819          move.l    D0,A0
00000BE8  5350      1820          subq.w    #1,(A0)
                    1821   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00000BEA  2045      1822          move.l    D5,A0
00000BEC  5885      1823          addq.l    #4,D5
00000BEE  2082      1824          move.l    D2,(A0)
                    1825   ; events_rdy   =  OS_TRUE;
00000BF0  1D7C 0001 1826          move.b    #1,-2(A6)
00000BF4  FFFE      
                    1827   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000BF6  429B      1828          clr.l     (A3)+
                    1829   ; events_rdy_nbr++;
00000BF8  5243      1830          addq.w    #1,D3
00000BFA  6006      1831          bra.s     OSEventPendMulti_31
                    1832   OSEventPendMulti_30:
                    1833   ; } else {
                    1834   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
00000BFC  002E 0001 1835          or.b      #1,-1(A6)
00000C00  FFFF      
                    1836   OSEventPendMulti_31:
                    1837   ; }
                    1838   ; break;
00000C02  6000 00A2 1839          bra       OSEventPendMulti_22
                    1840   OSEventPendMulti_25:
                    1841   ; #endif
                    1842   ; #if (OS_MBOX_EN > 0u)
                    1843   ; case OS_EVENT_TYPE_MBOX:
                    1844   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000C06  2042      1845          move.l    D2,A0
00000C08  2028 0002 1846          move.l    2(A0),D0
00000C0C  671C      1847          beq.s     OSEventPendMulti_32
                    1848   ; /* ... return available message,           ... */
                    1849   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
00000C0E  2042      1850          move.l    D2,A0
00000C10  26E8 0002 1851          move.l    2(A0),(A3)+
                    1852   ; pevent->OSEventPtr  = (void *)0;
00000C14  2042      1853          move.l    D2,A0
00000C16  42A8 0002 1854          clr.l     2(A0)
                    1855   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
00000C1A  2045      1856          move.l    D5,A0
00000C1C  5885      1857          addq.l    #4,D5
00000C1E  2082      1858          move.l    D2,(A0)
                    1859   ; events_rdy         =  OS_TRUE;
00000C20  1D7C 0001 1860          move.b    #1,-2(A6)
00000C24  FFFE      
                    1861   ; events_rdy_nbr++;
00000C26  5243      1862          addq.w    #1,D3
00000C28  6006      1863          bra.s     OSEventPendMulti_33
                    1864   OSEventPendMulti_32:
                    1865   ; } else {
                    1866   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
00000C2A  002E 0002 1867          or.b      #2,-1(A6)
00000C2E  FFFF      
                    1868   OSEventPendMulti_33:
                    1869   ; }
                    1870   ; break;
00000C30  6000 0074 1871          bra       OSEventPendMulti_22
                    1872   OSEventPendMulti_26:
                    1873   ; #endif
                    1874   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1875   ; case OS_EVENT_TYPE_Q:
                    1876   ; pq = (OS_Q *)pevent->OSEventPtr;
00000C34  2042      1877          move.l    D2,A0
00000C36  2C28 0002 1878          move.l    2(A0),D6
                    1879   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
00000C3A  2046      1880          move.l    D6,A0
00000C3C  3028 0016 1881          move.w    22(A0),D0
00000C40  0C40 0000 1882          cmp.w     #0,D0
00000C44  6300 0046 1883          bls       OSEventPendMulti_34
                    1884   ; /* ... return available message,           ... */
                    1885   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000C48  2006      1886          move.l    D6,D0
00000C4A  0680 0000 1887          add.l     #16,D0
00000C4E  0010      
00000C50  2040      1888          move.l    D0,A0
00000C52  2250      1889          move.l    (A0),A1
00000C54  5890      1890          addq.l    #4,(A0)
00000C56  26D1      1891          move.l    (A1),(A3)+
                    1892   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000C58  2046      1893          move.l    D6,A0
00000C5A  2246      1894          move.l    D6,A1
00000C5C  2028 0010 1895          move.l    16(A0),D0
00000C60  B0A9 0008 1896          cmp.l     8(A1),D0
00000C64  660A      1897          bne.s     OSEventPendMulti_36
                    1898   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
00000C66  2046      1899          move.l    D6,A0
00000C68  2246      1900          move.l    D6,A1
00000C6A  2368 0004 1901          move.l    4(A0),16(A1)
00000C6E  0010      
                    1902   OSEventPendMulti_36:
                    1903   ; }
                    1904   ; pq->OSQEntries--;                  /* Update number of queue entries              */
00000C70  2006      1905          move.l    D6,D0
00000C72  0680 0000 1906          add.l     #22,D0
00000C76  0016      
00000C78  2040      1907          move.l    D0,A0
00000C7A  5350      1908          subq.w    #1,(A0)
                    1909   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
00000C7C  2045      1910          move.l    D5,A0
00000C7E  5885      1911          addq.l    #4,D5
00000C80  2082      1912          move.l    D2,(A0)
                    1913   ; events_rdy   = OS_TRUE;
00000C82  1D7C 0001 1914          move.b    #1,-2(A6)
00000C86  FFFE      
                    1915   ; events_rdy_nbr++;
00000C88  5243      1916          addq.w    #1,D3
00000C8A  6006      1917          bra.s     OSEventPendMulti_35
                    1918   OSEventPendMulti_34:
                    1919   ; } else {
                    1920   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
00000C8C  002E 0004 1921          or.b      #4,-1(A6)
00000C90  FFFF      
                    1922   OSEventPendMulti_35:
                    1923   ; }
                    1924   ; break;
00000C92  6012      1925          bra.s     OSEventPendMulti_22
                    1926   OSEventPendMulti_27:
                    1927   ; #endif
                    1928   ; case OS_EVENT_TYPE_MUTEX:
                    1929   ; case OS_EVENT_TYPE_FLAG:
                    1930   ; default:
                    1931   ; OS_EXIT_CRITICAL();
00000C94  46DF      1932          dc.w      18143
                    1933   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
00000C96  2045      1934          move.l    D5,A0
00000C98  4290      1935          clr.l     (A0)
                    1936   ; *perr        =  OS_ERR_EVENT_TYPE;
00000C9A  2044      1937          move.l    D4,A0
00000C9C  10BC 0001 1938          move.b    #1,(A0)
                    1939   ; return (events_rdy_nbr);
00000CA0  3003      1940          move.w    D3,D0
00000CA2  6000 0170 1941          bra       OSEventPendMulti_13
                    1942   OSEventPendMulti_22:
                    1943   ; }
                    1944   ; pevents++;
00000CA6  5887      1945          addq.l    #4,D7
                    1946   ; pevent = *pevents;
00000CA8  2047      1947          move.l    D7,A0
00000CAA  2410      1948          move.l    (A0),D2
00000CAC  6000 FEF4 1949          bra       OSEventPendMulti_18
                    1950   OSEventPendMulti_20:
                    1951   ; }
                    1952   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
00000CB0  102E FFFE 1953          move.b    -2(A6),D0
00000CB4  0C00 0001 1954          cmp.b     #1,D0
00000CB8  6610      1955          bne.s     OSEventPendMulti_38
                    1956   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
00000CBA  2045      1957          move.l    D5,A0
00000CBC  4290      1958          clr.l     (A0)
                    1959   ; OS_EXIT_CRITICAL();
00000CBE  46DF      1960          dc.w      18143
                    1961   ; *perr        =  OS_ERR_NONE;
00000CC0  2044      1962          move.l    D4,A0
00000CC2  4210      1963          clr.b     (A0)
                    1964   ; return (events_rdy_nbr);
00000CC4  3003      1965          move.w    D3,D0
00000CC6  6000 014C 1966          bra       OSEventPendMulti_13
                    1967   OSEventPendMulti_38:
                    1968   ; }
                    1969   ; /*$PAGE*/
                    1970   ; /* Otherwise, must wait until any event occurs */
                    1971   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00000CCA  2052      1972          move.l    (A2),A0
00000CCC  102E FFFF 1973          move.b    -1(A6),D0
00000CD0  803C 0080 1974          or.b      #128,D0
00000CD4  8128 0032 1975          or.b      D0,50(A0)
                    1976   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    1977   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00000CD8  2052      1978          move.l    (A2),A0
00000CDA  4228 0033 1979          clr.b     51(A0)
                    1980   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00000CDE  2052      1981          move.l    (A2),A0
00000CE0  216E 0014 1982          move.l    20(A6),46(A0)
00000CE4  002E      
                    1983   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00000CE6  2F0C      1984          move.l    A4,-(A7)
00000CE8  4EB9 0000 1985          jsr       _OS_EventTaskWaitMulti
00000CEC  1240      
00000CEE  584F      1986          addq.w    #4,A7
                    1987   ; OS_EXIT_CRITICAL();
00000CF0  46DF      1988          dc.w      18143
                    1989   ; OS_Sched();                                         /* Find next highest priority task ready       */
00000CF2  4EB9 0000 1990          jsr       _OS_Sched
00000CF6  16B8      
                    1991   ; OS_ENTER_CRITICAL();
00000CF8  40E7      1992          dc.w      16615
00000CFA  007C      1993          dc.w      124
00000CFC  0700      1994          dc.w      1792
                    1995   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00000CFE  2052      1996          move.l    (A2),A0
00000D00  1028 0033 1997          move.b    51(A0),D0
00000D04  C0BC 0000 1998          and.l     #255,D0
00000D08  00FF      
00000D0A  0C80 0000 1999          cmp.l     #1,D0
00000D0E  0001      
00000D10  6700 0046 2000          beq       OSEventPendMulti_44
00000D14  6208      2001          bhi.s     OSEventPendMulti_46
00000D16  4A80      2002          tst.l     D0
00000D18  6710      2003          beq.s     OSEventPendMulti_42
00000D1A  6000 003C 2004          bra       OSEventPendMulti_44
                    2005   OSEventPendMulti_46:
00000D1E  0C80 0000 2006          cmp.l     #2,D0
00000D22  0002      
00000D24  6704      2007          beq.s     OSEventPendMulti_42
00000D26  6000 0030 2008          bra       OSEventPendMulti_44
                    2009   OSEventPendMulti_42:
                    2010   ; case OS_STAT_PEND_OK:
                    2011   ; case OS_STAT_PEND_ABORT:
                    2012   ; pevent = OSTCBCur->OSTCBEventPtr;
00000D2A  2052      2013          move.l    (A2),A0
00000D2C  2428 001C 2014          move.l    28(A0),D2
                    2015   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
00000D30  4A82      2016          tst.l     D2
00000D32  670E      2017          beq.s     OSEventPendMulti_47
                    2018   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
00000D34  2045      2019          move.l    D5,A0
00000D36  5885      2020          addq.l    #4,D5
00000D38  2082      2021          move.l    D2,(A0)
                    2022   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
00000D3A  2045      2023          move.l    D5,A0
00000D3C  4290      2024          clr.l     (A0)
                    2025   ; events_rdy_nbr =  1;
00000D3E  7601      2026          moveq     #1,D3
00000D40  6014      2027          bra.s     OSEventPendMulti_48
                    2028   OSEventPendMulti_47:
                    2029   ; } else {                                   /* Else NO event available, handle as timeout  */
                    2030   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00000D42  2052      2031          move.l    (A2),A0
00000D44  117C 0001 2032          move.b    #1,51(A0)
00000D48  0033      
                    2033   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000D4A  2F0C      2034          move.l    A4,-(A7)
00000D4C  2F12      2035          move.l    (A2),-(A7)
00000D4E  4EB9 0000 2036          jsr       _OS_EventTaskRemoveMulti
00000D52  1330      
00000D54  504F      2037          addq.w    #8,A7
                    2038   OSEventPendMulti_48:
                    2039   ; }
                    2040   ; break;
00000D56  600C      2041          bra.s     OSEventPendMulti_41
                    2042   OSEventPendMulti_44:
                    2043   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    2044   ; default:                                        /* ... remove task from events' wait lists     */
                    2045   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000D58  2F0C      2046          move.l    A4,-(A7)
00000D5A  2F12      2047          move.l    (A2),-(A7)
00000D5C  4EB9 0000 2048          jsr       _OS_EventTaskRemoveMulti
00000D60  1330      
00000D62  504F      2049          addq.w    #8,A7
                    2050   ; break;
                    2051   OSEventPendMulti_41:
                    2052   ; }
                    2053   ; switch (OSTCBCur->OSTCBStatPend) {
00000D64  2052      2054          move.l    (A2),A0
00000D66  1028 0033 2055          move.b    51(A0),D0
00000D6A  C0BC 0000 2056          and.l     #255,D0
00000D6E  00FF      
00000D70  0C80 0000 2057          cmp.l     #1,D0
00000D74  0001      
00000D76  6700 0072 2058          beq       OSEventPendMulti_53
00000D7A  6208      2059          bhi.s     OSEventPendMulti_55
00000D7C  4A80      2060          tst.l     D0
00000D7E  6712      2061          beq.s     OSEventPendMulti_51
00000D80  6000 0068 2062          bra       OSEventPendMulti_53
                    2063   OSEventPendMulti_55:
00000D84  0C80 0000 2064          cmp.l     #2,D0
00000D88  0002      
00000D8A  6700 0054 2065          beq       OSEventPendMulti_52
00000D8E  6000 005A 2066          bra       OSEventPendMulti_53
                    2067   OSEventPendMulti_51:
                    2068   ; case OS_STAT_PEND_OK:
                    2069   ; switch (pevent->OSEventType) {             /* Return event's message                      */
00000D92  2042      2070          move.l    D2,A0
00000D94  1010      2071          move.b    (A0),D0
00000D96  C0BC 0000 2072          and.l     #255,D0
00000D9A  00FF      
00000D9C  5380      2073          subq.l    #1,D0
00000D9E  6528      2074          blo.s     OSEventPendMulti_62
00000DA0  0C80 0000 2075          cmp.l     #5,D0
00000DA4  0005      
00000DA6  6420      2076          bhs.s     OSEventPendMulti_62
00000DA8  E380      2077          asl.l     #1,D0
00000DAA  303B 0806 2078          move.w    OSEventPendMulti_58(PC,D0.L),D0
00000DAE  4EFB 0002 2079          jmp       OSEventPendMulti_58(PC,D0.W)
                    2080   OSEventPendMulti_58:
00000DB2  000E      2081          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000DB4  000E      2082          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000DB6  000A      2083          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
00000DB8  0016      2084          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00000DBA  0016      2085          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    2086   OSEventPendMulti_59:
                    2087   ; #if (OS_SEM_EN > 0u)
                    2088   ; case OS_EVENT_TYPE_SEM:
                    2089   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00000DBC  429B      2090          clr.l     (A3)+
                    2091   ; break;
00000DBE  601A      2092          bra.s     OSEventPendMulti_57
                    2093   OSEventPendMulti_60:
                    2094   ; #endif
                    2095   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2096   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2097   ; case OS_EVENT_TYPE_MBOX:
                    2098   ; case OS_EVENT_TYPE_Q:
                    2099   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
00000DC0  2052      2100          move.l    (A2),A0
00000DC2  26E8 0024 2101          move.l    36(A0),(A3)+
                    2102   ; break;
00000DC6  6012      2103          bra.s     OSEventPendMulti_57
                    2104   OSEventPendMulti_62:
                    2105   ; #endif
                    2106   ; case OS_EVENT_TYPE_MUTEX:
                    2107   ; case OS_EVENT_TYPE_FLAG:
                    2108   ; default:
                    2109   ; OS_EXIT_CRITICAL();
00000DC8  46DF      2110          dc.w      18143
                    2111   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00000DCA  2045      2112          move.l    D5,A0
00000DCC  4290      2113          clr.l     (A0)
                    2114   ; *perr        =  OS_ERR_EVENT_TYPE;
00000DCE  2044      2115          move.l    D4,A0
00000DD0  10BC 0001 2116          move.b    #1,(A0)
                    2117   ; return (events_rdy_nbr);
00000DD4  3003      2118          move.w    D3,D0
00000DD6  6000 003C 2119          bra       OSEventPendMulti_13
                    2120   OSEventPendMulti_57:
                    2121   ; }
                    2122   ; *perr = OS_ERR_NONE;
00000DDA  2044      2123          move.l    D4,A0
00000DDC  4210      2124          clr.b     (A0)
                    2125   ; break;
00000DDE  6012      2126          bra.s     OSEventPendMulti_50
                    2127   OSEventPendMulti_52:
                    2128   ; case OS_STAT_PEND_ABORT:
                    2129   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
00000DE0  429B      2130          clr.l     (A3)+
                    2131   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
00000DE2  2044      2132          move.l    D4,A0
00000DE4  10BC 000E 2133          move.b    #14,(A0)
                    2134   ; break;
00000DE8  6008      2135          bra.s     OSEventPendMulti_50
                    2136   OSEventPendMulti_53:
                    2137   ; case OS_STAT_PEND_TO:
                    2138   ; default:
                    2139   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00000DEA  429B      2140          clr.l     (A3)+
                    2141   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00000DEC  2044      2142          move.l    D4,A0
00000DEE  10BC 000A 2143          move.b    #10,(A0)
                    2144   ; break;
                    2145   OSEventPendMulti_50:
                    2146   ; }
                    2147   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00000DF2  2052      2148          move.l    (A2),A0
00000DF4  4228 0032 2149          clr.b     50(A0)
                    2150   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
00000DF8  2052      2151          move.l    (A2),A0
00000DFA  4228 0033 2152          clr.b     51(A0)
                    2153   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00000DFE  2052      2154          move.l    (A2),A0
00000E00  42A8 001C 2155          clr.l     28(A0)
                    2156   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00000E04  2052      2157          move.l    (A2),A0
00000E06  42A8 0020 2158          clr.l     32(A0)
                    2159   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2160   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2161   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00000E0A  2052      2162          move.l    (A2),A0
00000E0C  42A8 0024 2163          clr.l     36(A0)
                    2164   ; #endif
                    2165   ; OS_EXIT_CRITICAL();
00000E10  46DF      2166          dc.w      18143
                    2167   ; return (events_rdy_nbr);
00000E12  3003      2168          move.w    D3,D0
                    2169   OSEventPendMulti_13:
00000E14  4CDF 1CFC 2170          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00000E18  4E5E      2171          unlk      A6
00000E1A  4E75      2172          rts
                    2173   ; }
                    2174   ; #endif
                    2175   ; /*$PAGE*/
                    2176   ; /*
                    2177   ; *********************************************************************************************************
                    2178   ; *                                           INITIALIZATION
                    2179   ; *
                    2180   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2181   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2182   ; *
                    2183   ; * Arguments  : none
                    2184   ; *
                    2185   ; * Returns    : none
                    2186   ; *********************************************************************************************************
                    2187   ; */
                    2188   ; void  OSInit (void)
                    2189   ; {
                    2190   _OSInit:
                    2191   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00000E1C  4EB8 0992 2192          jsr       _OSInitHookBegin
                    2193   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00000E20  4EB9 0000 2194          jsr       @ucos_ii_OS_InitMisc
00000E24  1478      
                    2195   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
00000E26  4EB9 0000 2196          jsr       @ucos_ii_OS_InitRdyList
00000E2A  14BC      
                    2197   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000E2C  4EB9 0000 2198          jsr       @ucos_ii_OS_InitTCBList
00000E30  15B4      
                    2199   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00000E32  4EB9 0000 2200          jsr       @ucos_ii_OS_InitEventList
00000E36  13D0      
                    2201   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2202   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
00000E38  4EB9 0000 2203          jsr       _OS_FlagInit
00000E3C  23C6      
                    2204   ; #endif
                    2205   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2206   ; OS_MemInit();                                                /* Initialize the memory manager            */
00000E3E  4EB9 0000 2207          jsr       _OS_MemInit
00000E42  2C84      
                    2208   ; #endif
                    2209   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2210   ; OS_QInit();                                                  /* Initialize the message queue structures  */
00000E44  4EB9 0000 2211          jsr       _OS_QInit
00000E48  3DEA      
                    2212   ; #endif
                    2213   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00000E4A  4EB9 0000 2214          jsr       @ucos_ii_OS_InitTaskIdle
00000E4E  14FC      
                    2215   ; #if OS_TASK_STAT_EN > 0u
                    2216   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
00000E50  4EB9 0000 2217          jsr       @ucos_ii_OS_InitTaskStat
00000E54  1558      
                    2218   ; #endif
                    2219   ; #if OS_TMR_EN > 0u
                    2220   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
00000E56  4EB9 0000 2221          jsr       _OSTmr_Init
00000E5A  573C      
                    2222   ; #endif
                    2223   ; OSInitHookEnd();                                             /* Call port specific init. code            */
00000E5C  4EB8 0994 2224          jsr       _OSInitHookEnd
00000E60  4E75      2225          rts
                    2226   ; #if OS_DEBUG_EN > 0u
                    2227   ; OSDebugInit();
                    2228   ; #endif
                    2229   ; }
                    2230   ; /*$PAGE*/
                    2231   ; /*
                    2232   ; *********************************************************************************************************
                    2233   ; *                                              ENTER ISR
                    2234   ; *
                    2235   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2236   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2237   ; *              only perform rescheduling at the last nested ISR.
                    2238   ; *
                    2239   ; * Arguments  : none
                    2240   ; *
                    2241   ; * Returns    : none
                    2242   ; *
                    2243   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2244   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2245   ; *                 OSIntNesting has been declared 'global'.
                    2246   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2247   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2248   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2249   ; *                 end of the ISR.
                    2250   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2251   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2252   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2253   ; *********************************************************************************************************
                    2254   ; */
                    2255   ; void  OSIntEnter (void)
                    2256   ; {
                    2257   _OSIntEnter:
                    2258   ; if (OSRunning == OS_TRUE) {
00000E62  1039 0800 2259          move.b    _OSRunning.L,D0
00000E66  0438      
00000E68  0C00 0001 2260          cmp.b     #1,D0
00000E6C  6612      2261          bne.s     OSIntEnter_3
                    2262   ; if (OSIntNesting < 255u) {
00000E6E  1039 0800 2263          move.b    _OSIntNesting.L,D0
00000E72  0426      
00000E74  0C00 00FF 2264          cmp.b     #255,D0
00000E78  6406      2265          bhs.s     OSIntEnter_3
                    2266   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
00000E7A  5239 0800 2267          addq.b    #1,_OSIntNesting.L
00000E7E  0426      
                    2268   OSIntEnter_3:
00000E80  4E75      2269          rts
                    2270   ; }
                    2271   ; }
                    2272   ; }
                    2273   ; /*$PAGE*/
                    2274   ; /*
                    2275   ; *********************************************************************************************************
                    2276   ; *                                              EXIT ISR
                    2277   ; *
                    2278   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2279   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2280   ; *              a new, high-priority task, is ready to run.
                    2281   ; *
                    2282   ; * Arguments  : none
                    2283   ; *
                    2284   ; * Returns    : none
                    2285   ; *
                    2286   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2287   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2288   ; *                 end of the ISR.
                    2289   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2290   ; *********************************************************************************************************
                    2291   ; */
                    2292   ; void  OSIntExit (void)
                    2293   ; {
                    2294   _OSIntExit:
                    2295   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2296   ; OS_CPU_SR  cpu_sr = 0u;
                    2297   ; #endif
                    2298   ; if (OSRunning == OS_TRUE) {
00000E82  1039 0800 2299          move.b    _OSRunning.L,D0
00000E86  0438      
00000E88  0C00 0001 2300          cmp.b     #1,D0
00000E8C  6600 0078 2301          bne       OSIntExit_1
                    2302   ; OS_ENTER_CRITICAL();
00000E90  40E7      2303          dc.w      16615
00000E92  007C      2304          dc.w      124
00000E94  0700      2305          dc.w      1792
                    2306   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00000E96  1039 0800 2307          move.b    _OSIntNesting.L,D0
00000E9A  0426      
00000E9C  0C00 0000 2308          cmp.b     #0,D0
00000EA0  6306      2309          bls.s     OSIntExit_3
                    2310   ; OSIntNesting--;
00000EA2  5339 0800 2311          subq.b    #1,_OSIntNesting.L
00000EA6  0426      
                    2312   OSIntExit_3:
                    2313   ; }
                    2314   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00000EA8  1039 0800 2315          move.b    _OSIntNesting.L,D0
00000EAC  0426      
00000EAE  6600 0054 2316          bne       OSIntExit_9
                    2317   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00000EB2  1039 0800 2318          move.b    _OSLockNesting.L,D0
00000EB6  0428      
00000EB8  664A      2319          bne.s     OSIntExit_9
                    2320   ; OS_SchedNew();
00000EBA  4EB9 0000 2321          jsr       @ucos_ii_OS_SchedNew
00000EBE  171C      
                    2322   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00000EC0  1039 0800 2323          move.b    _OSPrioHighRdy.L,D0
00000EC4  042C      
00000EC6  C0BC 0000 2324          and.l     #255,D0
00000ECA  00FF      
00000ECC  E588      2325          lsl.l     #2,D0
00000ECE  41F9 0800 2326          lea       _OSTCBPrioTbl.L,A0
00000ED2  0550      
00000ED4  23F0 0800 2327          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000ED8  0800 0548 
                    2328   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00000EDC  1039 0800 2329          move.b    _OSPrioHighRdy.L,D0
00000EE0  042C      
00000EE2  B039 0800 2330          cmp.b     _OSPrioCur.L,D0
00000EE6  042A      
00000EE8  671A      2331          beq.s     OSIntExit_9
                    2332   ; #if OS_TASK_PROFILE_EN > 0u
                    2333   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00000EEA  2039 0800 2334          move.l    _OSTCBHighRdy.L,D0
00000EEE  0548      
00000EF0  0680 0000 2335          add.l     #58,D0
00000EF4  003A      
00000EF6  2040      2336          move.l    D0,A0
00000EF8  5290      2337          addq.l    #1,(A0)
                    2338   ; #endif
                    2339   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00000EFA  52B9 0800 2340          addq.l    #1,_OSCtxSwCtr.L
00000EFE  01F6      
                    2341   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00000F00  4EB8 06E2 2342          jsr       _OSIntCtxSw
                    2343   OSIntExit_9:
                    2344   ; }
                    2345   ; }
                    2346   ; }
                    2347   ; OS_EXIT_CRITICAL();
00000F04  46DF      2348          dc.w      18143
                    2349   OSIntExit_1:
00000F06  4E75      2350          rts
                    2351   ; }
                    2352   ; }
                    2353   ; /*$PAGE*/
                    2354   ; /*
                    2355   ; *********************************************************************************************************
                    2356   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2357   ; *
                    2358   ; * Description: This function is called by the application code to indicate that all initialization has
                    2359   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2360   ; *
                    2361   ; * Arguments  : none
                    2362   ; *
                    2363   ; * Returns    : none
                    2364   ; *
                    2365   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2366   ; *                 create kernel objects.
                    2367   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2368   ; *********************************************************************************************************
                    2369   ; */
                    2370   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2371   ; void  OSSafetyCriticalStart (void)
                    2372   ; {
                    2373   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2374   ; }
                    2375   ; #endif
                    2376   ; /*$PAGE*/
                    2377   ; /*
                    2378   ; *********************************************************************************************************
                    2379   ; *                                         PREVENT SCHEDULING
                    2380   ; *
                    2381   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2382   ; *              to prevent context switches until you are ready to permit context switching.
                    2383   ; *
                    2384   ; * Arguments  : none
                    2385   ; *
                    2386   ; * Returns    : none
                    2387   ; *
                    2388   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2389   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2390   ; *********************************************************************************************************
                    2391   ; */
                    2392   ; #if OS_SCHED_LOCK_EN > 0u
                    2393   ; void  OSSchedLock (void)
                    2394   ; {
                    2395   _OSSchedLock:
                    2396   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2397   ; OS_CPU_SR  cpu_sr = 0u;
                    2398   ; #endif
                    2399   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
00000F08  1039 0800 2400          move.b    _OSRunning.L,D0
00000F0C  0438      
00000F0E  0C00 0001 2401          cmp.b     #1,D0
00000F12  6622      2402          bne.s     OSSchedLock_1
                    2403   ; OS_ENTER_CRITICAL();
00000F14  40E7      2404          dc.w      16615
00000F16  007C      2405          dc.w      124
00000F18  0700      2406          dc.w      1792
                    2407   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00000F1A  1039 0800 2408          move.b    _OSIntNesting.L,D0
00000F1E  0426      
00000F20  6612      2409          bne.s     OSSchedLock_5
                    2410   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
00000F22  1039 0800 2411          move.b    _OSLockNesting.L,D0
00000F26  0428      
00000F28  0C00 00FF 2412          cmp.b     #255,D0
00000F2C  6406      2413          bhs.s     OSSchedLock_5
                    2414   ; OSLockNesting++;                 /* Increment lock nesting level                       */
00000F2E  5239 0800 2415          addq.b    #1,_OSLockNesting.L
00000F32  0428      
                    2416   OSSchedLock_5:
                    2417   ; }
                    2418   ; }
                    2419   ; OS_EXIT_CRITICAL();
00000F34  46DF      2420          dc.w      18143
                    2421   OSSchedLock_1:
00000F36  4E75      2422          rts
                    2423   ; }
                    2424   ; }
                    2425   ; #endif
                    2426   ; /*$PAGE*/
                    2427   ; /*
                    2428   ; *********************************************************************************************************
                    2429   ; *                                          ENABLE SCHEDULING
                    2430   ; *
                    2431   ; * Description: This function is used to re-allow rescheduling.
                    2432   ; *
                    2433   ; * Arguments  : none
                    2434   ; *
                    2435   ; * Returns    : none
                    2436   ; *
                    2437   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2438   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2439   ; *********************************************************************************************************
                    2440   ; */
                    2441   ; #if OS_SCHED_LOCK_EN > 0u
                    2442   ; void  OSSchedUnlock (void)
                    2443   ; {
                    2444   _OSSchedUnlock:
                    2445   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2446   ; OS_CPU_SR  cpu_sr = 0u;
                    2447   ; #endif
                    2448   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
00000F38  1039 0800 2449          move.b    _OSRunning.L,D0
00000F3C  0438      
00000F3E  0C00 0001 2450          cmp.b     #1,D0
00000F42  6600 003E 2451          bne       OSSchedUnlock_4
                    2452   ; OS_ENTER_CRITICAL();
00000F46  40E7      2453          dc.w      16615
00000F48  007C      2454          dc.w      124
00000F4A  0700      2455          dc.w      1792
                    2456   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
00000F4C  1039 0800 2457          move.b    _OSIntNesting.L,D0
00000F50  0426      
00000F52  662C      2458          bne.s     OSSchedUnlock_3
                    2459   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
00000F54  1039 0800 2460          move.b    _OSLockNesting.L,D0
00000F58  0428      
00000F5A  0C00 0000 2461          cmp.b     #0,D0
00000F5E  631C      2462          bls.s     OSSchedUnlock_5
                    2463   ; OSLockNesting--;                           /* Decrement lock nesting level             */
00000F60  5339 0800 2464          subq.b    #1,_OSLockNesting.L
00000F64  0428      
                    2465   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
00000F66  1039 0800 2466          move.b    _OSLockNesting.L,D0
00000F6A  0428      
00000F6C  660A      2467          bne.s     OSSchedUnlock_7
                    2468   ; OS_EXIT_CRITICAL();
00000F6E  46DF      2469          dc.w      18143
                    2470   ; OS_Sched();                            /* See if a HPT is ready                    */
00000F70  4EB9 0000 2471          jsr       _OS_Sched
00000F74  16B8      
00000F76  6002      2472          bra.s     OSSchedUnlock_8
                    2473   OSSchedUnlock_7:
                    2474   ; } else {
                    2475   ; OS_EXIT_CRITICAL();
00000F78  46DF      2476          dc.w      18143
                    2477   OSSchedUnlock_8:
00000F7A  6002      2478          bra.s     OSSchedUnlock_6
                    2479   OSSchedUnlock_5:
                    2480   ; }
                    2481   ; } else {
                    2482   ; OS_EXIT_CRITICAL();
00000F7C  46DF      2483          dc.w      18143
                    2484   OSSchedUnlock_6:
00000F7E  6002      2485          bra.s     OSSchedUnlock_4
                    2486   OSSchedUnlock_3:
                    2487   ; }
                    2488   ; } else {
                    2489   ; OS_EXIT_CRITICAL();
00000F80  46DF      2490          dc.w      18143
                    2491   OSSchedUnlock_4:
00000F82  4E75      2492          rts
                    2493   ; }
                    2494   ; }
                    2495   ; }
                    2496   ; #endif
                    2497   ; /*$PAGE*/
                    2498   ; /*
                    2499   ; *********************************************************************************************************
                    2500   ; *                                         START MULTITASKING
                    2501   ; *
                    2502   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2503   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2504   ; *              and you MUST have created at least one task.
                    2505   ; *
                    2506   ; * Arguments  : none
                    2507   ; *
                    2508   ; * Returns    : none
                    2509   ; *
                    2510   ; * Note       : OSStartHighRdy() MUST:
                    2511   ; *                 a) Call OSTaskSwHook() then,
                    2512   ; *                 b) Set OSRunning to OS_TRUE.
                    2513   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2514   ; *                 d_ Execute the task.
                    2515   ; *********************************************************************************************************
                    2516   ; */
                    2517   ; void  OSStart (void)
                    2518   ; {
                    2519   _OSStart:
                    2520   ; if (OSRunning == OS_FALSE) {
00000F84  1039 0800 2521          move.b    _OSRunning.L,D0
00000F88  0438      
00000F8A  663A      2522          bne.s     OSStart_1
                    2523   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
00000F8C  4EB9 0000 2524          jsr       @ucos_ii_OS_SchedNew
00000F90  171C      
                    2525   ; OSPrioCur     = OSPrioHighRdy;
00000F92  13F9 0800 2526          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
00000F96  042C 0800 
00000F9A  042A      
                    2527   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00000F9C  1039 0800 2528          move.b    _OSPrioHighRdy.L,D0
00000FA0  042C      
00000FA2  C0BC 0000 2529          and.l     #255,D0
00000FA6  00FF      
00000FA8  E588      2530          lsl.l     #2,D0
00000FAA  41F9 0800 2531          lea       _OSTCBPrioTbl.L,A0
00000FAE  0550      
00000FB0  23F0 0800 2532          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000FB4  0800 0548 
                    2533   ; OSTCBCur      = OSTCBHighRdy;
00000FB8  23F9 0800 2534          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
00000FBC  0548 0800 
00000FC0  0540      
                    2535   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
00000FC2  4EB8 0698 2536          jsr       _OSStartHighRdy
                    2537   OSStart_1:
00000FC6  4E75      2538          rts
                    2539   ; }
                    2540   ; }
                    2541   ; /*$PAGE*/
                    2542   ; /*
                    2543   ; *********************************************************************************************************
                    2544   ; *                                      STATISTICS INITIALIZATION
                    2545   ; *
                    2546   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2547   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2548   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2549   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2550   ; *              determined by:
                    2551   ; *
                    2552   ; *                                             OSIdleCtr
                    2553   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2554   ; *                                            OSIdleCtrMax
                    2555   ; *
                    2556   ; * Arguments  : none
                    2557   ; *
                    2558   ; * Returns    : none
                    2559   ; *********************************************************************************************************
                    2560   ; */
                    2561   ; #if OS_TASK_STAT_EN > 0u
                    2562   ; void  OSStatInit (void)
                    2563   ; {
                    2564   _OSStatInit:
                    2565   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2566   ; OS_CPU_SR  cpu_sr = 0u;
                    2567   ; #endif
                    2568   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
00000FC8  4878 0002 2569          pea       2
00000FCC  4EB9 0000 2570          jsr       _OSTimeDly
00000FD0  4EB4      
00000FD2  584F      2571          addq.w    #4,A7
                    2572   ; OS_ENTER_CRITICAL();
00000FD4  40E7      2573          dc.w      16615
00000FD6  007C      2574          dc.w      124
00000FD8  0700      2575          dc.w      1792
                    2576   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00000FDA  42B9 0800 2577          clr.l     _OSIdleCtr.L
00000FDE  043C      
                    2578   ; OS_EXIT_CRITICAL();
00000FE0  46DF      2579          dc.w      18143
                    2580   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00000FE2  4878 000A 2581          pea       10
00000FE6  4EB9 0000 2582          jsr       _OSTimeDly
00000FEA  4EB4      
00000FEC  584F      2583          addq.w    #4,A7
                    2584   ; OS_ENTER_CRITICAL();
00000FEE  40E7      2585          dc.w      16615
00000FF0  007C      2586          dc.w      124
00000FF2  0700      2587          dc.w      1792
                    2588   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00000FF4  23F9 0800 2589          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
00000FF8  043C 0800 
00000FFC  031C      
                    2590   ; OSStatRdy    = OS_TRUE;
00000FFE  13FC 0001 2591          move.b    #1,_OSStatRdy.L
00001002  0800 0324 
                    2592   ; OS_EXIT_CRITICAL();
00001006  46DF      2593          dc.w      18143
00001008  4E75      2594          rts
                    2595   ; }
                    2596   ; #endif
                    2597   ; /*$PAGE*/
                    2598   ; /*
                    2599   ; *********************************************************************************************************
                    2600   ; *                                         PROCESS SYSTEM TICK
                    2601   ; *
                    2602   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2603   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2604   ; *              called by a high priority task.
                    2605   ; *
                    2606   ; * Arguments  : none
                    2607   ; *
                    2608   ; * Returns    : none
                    2609   ; *********************************************************************************************************
                    2610   ; */
                    2611   ; void  OSTimeTick (void)
                    2612   ; {
                    2613   _OSTimeTick:
0000100A  2F02      2614          move.l    D2,-(A7)
                    2615   ; OS_TCB    *ptcb;
                    2616   ; #if OS_TICK_STEP_EN > 0u
                    2617   ; BOOLEAN    step;
                    2618   ; #endif
                    2619   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2620   ; OS_CPU_SR  cpu_sr = 0u;
                    2621   ; #endif
                    2622   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2623   ; OSTimeTickHook();                                      /* Call user definable hook                     */
0000100C  4EB8 09BA 2624          jsr       _OSTimeTickHook
                    2625   ; #endif
                    2626   ; #if OS_TIME_GET_SET_EN > 0u
                    2627   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
00001010  40E7      2628          dc.w      16615
00001012  007C      2629          dc.w      124
00001014  0700      2630          dc.w      1792
                    2631   ; OSTime++;
00001016  52B9 0800 2632          addq.l    #1,_OSTime.L
0000101A  0E96      
                    2633   ; OS_EXIT_CRITICAL();
0000101C  46DF      2634          dc.w      18143
                    2635   ; #endif
                    2636   ; if (OSRunning == OS_TRUE) {
0000101E  1039 0800 2637          move.b    _OSRunning.L,D0
00001022  0438      
00001024  0C00 0001 2638          cmp.b     #1,D0
00001028  6600 00A2 2639          bne       OSTimeTick_5
                    2640   ; #if OS_TICK_STEP_EN > 0u
                    2641   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2642   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2643   ; step = OS_TRUE;
                    2644   ; break;
                    2645   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2646   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2647   ; break;
                    2648   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2649   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2650   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2651   ; break;
                    2652   ; default:                                       /* Invalid case, correct situation              */
                    2653   ; step            = OS_TRUE;
                    2654   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2655   ; break;
                    2656   ; }
                    2657   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2658   ; return;
                    2659   ; }
                    2660   ; #endif
                    2661   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
0000102C  2439 0800 2662          move.l    _OSTCBList.L,D2
00001030  054C      
                    2663   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2664   OSTimeTick_3:
00001032  2042      2665          move.l    D2,A0
00001034  1028 0034 2666          move.b    52(A0),D0
00001038  0C00 003F 2667          cmp.b     #63,D0
0000103C  6700 008E 2668          beq       OSTimeTick_5
                    2669   ; OS_ENTER_CRITICAL();
00001040  40E7      2670          dc.w      16615
00001042  007C      2671          dc.w      124
00001044  0700      2672          dc.w      1792
                    2673   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
00001046  2042      2674          move.l    D2,A0
00001048  2028 002E 2675          move.l    46(A0),D0
0000104C  6700 0072 2676          beq       OSTimeTick_12
                    2677   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
00001050  2002      2678          move.l    D2,D0
00001052  0680 0000 2679          add.l     #46,D0
00001056  002E      
00001058  2040      2680          move.l    D0,A0
0000105A  5390      2681          subq.l    #1,(A0)
                    2682   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
0000105C  2042      2683          move.l    D2,A0
0000105E  2028 002E 2684          move.l    46(A0),D0
00001062  6600 005C 2685          bne       OSTimeTick_12
                    2686   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00001066  2042      2687          move.l    D2,A0
00001068  1028 0032 2688          move.b    50(A0),D0
0000106C  C03C 0037 2689          and.b     #55,D0
00001070  6714      2690          beq.s     OSTimeTick_10
                    2691   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
00001072  2042      2692          move.l    D2,A0
00001074  7037      2693          moveq     #55,D0
00001076  4600      2694          not.b     D0
00001078  C128 0032 2695          and.b     D0,50(A0)
                    2696   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
0000107C  2042      2697          move.l    D2,A0
0000107E  117C 0001 2698          move.b    #1,51(A0)
00001082  0033      
00001084  6006      2699          bra.s     OSTimeTick_11
                    2700   OSTimeTick_10:
                    2701   ; } else {
                    2702   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00001086  2042      2703          move.l    D2,A0
00001088  4228 0033 2704          clr.b     51(A0)
                    2705   OSTimeTick_11:
                    2706   ; }
                    2707   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
0000108C  2042      2708          move.l    D2,A0
0000108E  1028 0032 2709          move.b    50(A0),D0
00001092  C03C 0008 2710          and.b     #8,D0
00001096  6628      2711          bne.s     OSTimeTick_12
                    2712   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
00001098  2042      2713          move.l    D2,A0
0000109A  1028 0038 2714          move.b    56(A0),D0
0000109E  8139 0800 2715          or.b      D0,_OSRdyGrp.L
000010A2  042E      
                    2716   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000010A4  2042      2717          move.l    D2,A0
000010A6  1028 0036 2718          move.b    54(A0),D0
000010AA  C0BC 0000 2719          and.l     #255,D0
000010AE  00FF      
000010B0  41F9 0800 2720          lea       _OSRdyTbl.L,A0
000010B4  0430      
000010B6  2242      2721          move.l    D2,A1
000010B8  1229 0037 2722          move.b    55(A1),D1
000010BC  8330 0800 2723          or.b      D1,0(A0,D0.L)
                    2724   OSTimeTick_12:
                    2725   ; }
                    2726   ; }
                    2727   ; }
                    2728   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
000010C0  2042      2729          move.l    D2,A0
000010C2  2428 0014 2730          move.l    20(A0),D2
                    2731   ; OS_EXIT_CRITICAL();
000010C6  46DF      2732          dc.w      18143
000010C8  6000 FF68 2733          bra       OSTimeTick_3
                    2734   OSTimeTick_5:
000010CC  241F      2735          move.l    (A7)+,D2
000010CE  4E75      2736          rts
                    2737   ; }
                    2738   ; }
                    2739   ; }
                    2740   ; /*$PAGE*/
                    2741   ; /*
                    2742   ; *********************************************************************************************************
                    2743   ; *                                             GET VERSION
                    2744   ; *
                    2745   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2746   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2747   ; *              2.01.00 would be returned as 20100.
                    2748   ; *
                    2749   ; * Arguments  : none
                    2750   ; *
                    2751   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2752   ; *********************************************************************************************************
                    2753   ; */
                    2754   ; INT16U  OSVersion (void)
                    2755   ; {
                    2756   _OSVersion:
                    2757   ; return (OS_VERSION);
000010D0  303C 7217 2758          move.w    #29207,D0
000010D4  4E75      2759          rts
                    2760   ; }
                    2761   ; /*$PAGE*/
                    2762   ; /*
                    2763   ; *********************************************************************************************************
                    2764   ; *                                           DUMMY FUNCTION
                    2765   ; *
                    2766   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2767   ; *
                    2768   ; * Arguments  : none
                    2769   ; *
                    2770   ; * Returns    : none
                    2771   ; *********************************************************************************************************
                    2772   ; */
                    2773   ; #if OS_TASK_DEL_EN > 0u
                    2774   ; void  OS_Dummy (void)
                    2775   ; {
                    2776   _OS_Dummy:
000010D6  4E75      2777          rts
                    2778   ; }
                    2779   ; #endif
                    2780   ; /*$PAGE*/
                    2781   ; /*
                    2782   ; *********************************************************************************************************
                    2783   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    2784   ; *
                    2785   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    2786   ; *              waiting for an event to occur.
                    2787   ; *
                    2788   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    2789   ; *
                    2790   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    2791   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    2792   ; *                          service functions.
                    2793   ; *
                    2794   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    2795   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    2796   ; *
                    2797   ; *              pend_stat   is used to indicate the readied task's pending status:
                    2798   ; *
                    2799   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    2800   ; *                                               an abort.
                    2801   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    2802   ; *
                    2803   ; * Returns    : none
                    2804   ; *
                    2805   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2806   ; *********************************************************************************************************
                    2807   ; */
                    2808   ; #if (OS_EVENT_EN)
                    2809   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    2810   ; void      *pmsg,
                    2811   ; INT8U      msk,
                    2812   ; INT8U      pend_stat)
                    2813   ; {
                    2814   _OS_EventTaskRdy:
000010D8  4E56 FFFC 2815          link      A6,#-4
000010DC  48E7 3C00 2816          movem.l   D2/D3/D4/D5,-(A7)
000010E0  262E 0008 2817          move.l    8(A6),D3
                    2818   ; OS_TCB   *ptcb;
                    2819   ; INT8U     y;
                    2820   ; INT8U     x;
                    2821   ; INT8U     prio;
                    2822   ; #if OS_LOWEST_PRIO > 63u
                    2823   ; OS_PRIO  *ptbl;
                    2824   ; #endif
                    2825   ; #if OS_LOWEST_PRIO <= 63u
                    2826   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000010E4  2043      2827          move.l    D3,A0
000010E6  1028 0008 2828          move.b    8(A0),D0
000010EA  C0BC 0000 2829          and.l     #255,D0
000010EE  00FF      
000010F0  41F9 0000 2830          lea       _OSUnMapTbl.L,A0
000010F4  768C      
000010F6  1830 0800 2831          move.b    0(A0,D0.L),D4
                    2832   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000010FA  2043      2833          move.l    D3,A0
000010FC  C8BC 0000 2834          and.l     #255,D4
00001100  00FF      
00001102  D1C4      2835          add.l     D4,A0
00001104  1028 000A 2836          move.b    10(A0),D0
00001108  C0BC 0000 2837          and.l     #255,D0
0000110C  00FF      
0000110E  41F9 0000 2838          lea       _OSUnMapTbl.L,A0
00001112  768C      
00001114  1D70 0800 2839          move.b    0(A0,D0.L),-1(A6)
00001118  FFFF      
                    2840   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
0000111A  1004      2841          move.b    D4,D0
0000111C  E708      2842          lsl.b     #3,D0
0000111E  D02E FFFF 2843          add.b     -1(A6),D0
00001122  1A00      2844          move.b    D0,D5
                    2845   ; #else
                    2846   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    2847   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    2848   ; } else {
                    2849   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    2850   ; }
                    2851   ; ptbl = &pevent->OSEventTbl[y];
                    2852   ; if ((*ptbl & 0xFFu) != 0u) {
                    2853   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    2854   ; } else {
                    2855   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    2856   ; }
                    2857   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    2858   ; #endif
                    2859   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00001124  CABC 0000 2860          and.l     #255,D5
00001128  00FF      
0000112A  2005      2861          move.l    D5,D0
0000112C  E588      2862          lsl.l     #2,D0
0000112E  41F9 0800 2863          lea       _OSTCBPrioTbl.L,A0
00001132  0550      
00001134  2430 0800 2864          move.l    0(A0,D0.L),D2
                    2865   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00001138  2042      2866          move.l    D2,A0
0000113A  42A8 002E 2867          clr.l     46(A0)
                    2868   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    2869   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
0000113E  2042      2870          move.l    D2,A0
00001140  216E 000C 2871          move.l    12(A6),36(A0)
00001144  0024      
                    2872   ; #else
                    2873   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    2874   ; #endif
                    2875   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
00001146  2042      2876          move.l    D2,A0
00001148  102E 0013 2877          move.b    19(A6),D0
0000114C  4600      2878          not.b     D0
0000114E  C128 0032 2879          and.b     D0,50(A0)
                    2880   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00001152  2042      2881          move.l    D2,A0
00001154  116E 0017 2882          move.b    23(A6),51(A0)
00001158  0033      
                    2883   ; /* See if task is ready (could be susp'd)      */
                    2884   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
0000115A  2042      2885          move.l    D2,A0
0000115C  1028 0032 2886          move.b    50(A0),D0
00001160  C03C 0008 2887          and.b     #8,D0
00001164  6622      2888          bne.s     OS_EventTaskRdy_1
                    2889   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00001166  2042      2890          move.l    D2,A0
00001168  1028 0038 2891          move.b    56(A0),D0
0000116C  8139 0800 2892          or.b      D0,_OSRdyGrp.L
00001170  042E      
                    2893   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
00001172  C8BC 0000 2894          and.l     #255,D4
00001176  00FF      
00001178  41F9 0800 2895          lea       _OSRdyTbl.L,A0
0000117C  0430      
0000117E  2242      2896          move.l    D2,A1
00001180  1029 0037 2897          move.b    55(A1),D0
00001184  8130 4800 2898          or.b      D0,0(A0,D4.L)
                    2899   OS_EventTaskRdy_1:
                    2900   ; }
                    2901   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
00001188  2F03      2902          move.l    D3,-(A7)
0000118A  2F02      2903          move.l    D2,-(A7)
0000118C  4EB9 0000 2904          jsr       _OS_EventTaskRemove
00001190  12DE      
00001192  504F      2905          addq.w    #8,A7
                    2906   ; #if (OS_EVENT_MULTI_EN > 0u)
                    2907   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
00001194  2042      2908          move.l    D2,A0
00001196  2028 0020 2909          move.l    32(A0),D0
0000119A  6716      2910          beq.s     OS_EventTaskRdy_3
                    2911   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0000119C  2042      2912          move.l    D2,A0
0000119E  2F28 0020 2913          move.l    32(A0),-(A7)
000011A2  2F02      2914          move.l    D2,-(A7)
000011A4  4EB9 0000 2915          jsr       _OS_EventTaskRemoveMulti
000011A8  1330      
000011AA  504F      2916          addq.w    #8,A7
                    2917   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000011AC  2042      2918          move.l    D2,A0
000011AE  2143 001C 2919          move.l    D3,28(A0)
                    2920   OS_EventTaskRdy_3:
                    2921   ; }
                    2922   ; #endif
                    2923   ; return (prio);
000011B2  1005      2924          move.b    D5,D0
000011B4  4CDF 003C 2925          movem.l   (A7)+,D2/D3/D4/D5
000011B8  4E5E      2926          unlk      A6
000011BA  4E75      2927          rts
                    2928   ; }
                    2929   ; #endif
                    2930   ; /*$PAGE*/
                    2931   ; /*
                    2932   ; *********************************************************************************************************
                    2933   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    2934   ; *
                    2935   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    2936   ; *              not occurred.
                    2937   ; *
                    2938   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    2939   ; *
                    2940   ; * Returns    : none
                    2941   ; *
                    2942   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2943   ; *********************************************************************************************************
                    2944   ; */
                    2945   ; #if (OS_EVENT_EN)
                    2946   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    2947   ; {
                    2948   _OS_EventTaskWait:
000011BC  4E56 0000 2949          link      A6,#0
000011C0  48E7 3020 2950          movem.l   D2/D3/A2,-(A7)
000011C4  45F9 0800 2951          lea       _OSTCBCur.L,A2
000011C8  0540      
000011CA  262E 0008 2952          move.l    8(A6),D3
                    2953   ; INT8U  y;
                    2954   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000011CE  2052      2955          move.l    (A2),A0
000011D0  2143 001C 2956          move.l    D3,28(A0)
                    2957   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000011D4  2043      2958          move.l    D3,A0
000011D6  2252      2959          move.l    (A2),A1
000011D8  1029 0036 2960          move.b    54(A1),D0
000011DC  C0BC 0000 2961          and.l     #255,D0
000011E0  00FF      
000011E2  D1C0      2962          add.l     D0,A0
000011E4  2252      2963          move.l    (A2),A1
000011E6  1029 0037 2964          move.b    55(A1),D0
000011EA  8128 000A 2965          or.b      D0,10(A0)
                    2966   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000011EE  2043      2967          move.l    D3,A0
000011F0  2252      2968          move.l    (A2),A1
000011F2  1029 0038 2969          move.b    56(A1),D0
000011F6  8128 0008 2970          or.b      D0,8(A0)
                    2971   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000011FA  2052      2972          move.l    (A2),A0
000011FC  1428 0036 2973          move.b    54(A0),D2
                    2974   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00001200  C4BC 0000 2975          and.l     #255,D2
00001204  00FF      
00001206  41F9 0800 2976          lea       _OSRdyTbl.L,A0
0000120A  0430      
0000120C  2252      2977          move.l    (A2),A1
0000120E  1029 0037 2978          move.b    55(A1),D0
00001212  4600      2979          not.b     D0
00001214  C130 2800 2980          and.b     D0,0(A0,D2.L)
                    2981   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00001218  C4BC 0000 2982          and.l     #255,D2
0000121C  00FF      
0000121E  41F9 0800 2983          lea       _OSRdyTbl.L,A0
00001222  0430      
00001224  1030 2800 2984          move.b    0(A0,D2.L),D0
00001228  660E      2985          bne.s     OS_EventTaskWait_1
                    2986   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000122A  2052      2987          move.l    (A2),A0
0000122C  1028 0038 2988          move.b    56(A0),D0
00001230  4600      2989          not.b     D0
00001232  C139 0800 2990          and.b     D0,_OSRdyGrp.L
00001236  042E      
                    2991   OS_EventTaskWait_1:
00001238  4CDF 040C 2992          movem.l   (A7)+,D2/D3/A2
0000123C  4E5E      2993          unlk      A6
0000123E  4E75      2994          rts
                    2995   ; }
                    2996   ; }
                    2997   ; #endif
                    2998   ; /*$PAGE*/
                    2999   ; /*
                    3000   ; *********************************************************************************************************
                    3001   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    3002   ; *
                    3003   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    3004   ; *              multiple events has not occurred.
                    3005   ; *
                    3006   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    3007   ; *                               which the task will be waiting for.
                    3008   ; *
                    3009   ; * Returns    : none.
                    3010   ; *
                    3011   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3012   ; *********************************************************************************************************
                    3013   ; */
                    3014   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3015   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    3016   ; {
                    3017   _OS_EventTaskWaitMulti:
00001240  4E56 0000 3018          link      A6,#0
00001244  48E7 3820 3019          movem.l   D2/D3/D4/A2,-(A7)
00001248  45F9 0800 3020          lea       _OSTCBCur.L,A2
0000124C  0540      
                    3021   ; OS_EVENT **pevents;
                    3022   ; OS_EVENT  *pevent;
                    3023   ; INT8U      y;
                    3024   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
0000124E  2052      3025          move.l    (A2),A0
00001250  42A8 001C 3026          clr.l     28(A0)
                    3027   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00001254  2052      3028          move.l    (A2),A0
00001256  216E 0008 3029          move.l    8(A6),32(A0)
0000125A  0020      
                    3030   ; pevents =  pevents_wait;
0000125C  262E 0008 3031          move.l    8(A6),D3
                    3032   ; pevent  = *pevents;
00001260  2043      3033          move.l    D3,A0
00001262  2410      3034          move.l    (A0),D2
                    3035   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    3036   OS_EventTaskWaitMulti_1:
00001264  4A82      3037          tst.l     D2
00001266  6700 0030 3038          beq       OS_EventTaskWaitMulti_3
                    3039   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
0000126A  2042      3040          move.l    D2,A0
0000126C  2252      3041          move.l    (A2),A1
0000126E  1029 0036 3042          move.b    54(A1),D0
00001272  C0BC 0000 3043          and.l     #255,D0
00001276  00FF      
00001278  D1C0      3044          add.l     D0,A0
0000127A  2252      3045          move.l    (A2),A1
0000127C  1029 0037 3046          move.b    55(A1),D0
00001280  8128 000A 3047          or.b      D0,10(A0)
                    3048   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00001284  2042      3049          move.l    D2,A0
00001286  2252      3050          move.l    (A2),A1
00001288  1029 0038 3051          move.b    56(A1),D0
0000128C  8128 0008 3052          or.b      D0,8(A0)
                    3053   ; pevents++;
00001290  5883      3054          addq.l    #4,D3
                    3055   ; pevent = *pevents;
00001292  2043      3056          move.l    D3,A0
00001294  2410      3057          move.l    (A0),D2
00001296  60CC      3058          bra       OS_EventTaskWaitMulti_1
                    3059   OS_EventTaskWaitMulti_3:
                    3060   ; }
                    3061   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00001298  2052      3062          move.l    (A2),A0
0000129A  1828 0036 3063          move.b    54(A0),D4
                    3064   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0000129E  C8BC 0000 3065          and.l     #255,D4
000012A2  00FF      
000012A4  41F9 0800 3066          lea       _OSRdyTbl.L,A0
000012A8  0430      
000012AA  2252      3067          move.l    (A2),A1
000012AC  1029 0037 3068          move.b    55(A1),D0
000012B0  4600      3069          not.b     D0
000012B2  C130 4800 3070          and.b     D0,0(A0,D4.L)
                    3071   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000012B6  C8BC 0000 3072          and.l     #255,D4
000012BA  00FF      
000012BC  41F9 0800 3073          lea       _OSRdyTbl.L,A0
000012C0  0430      
000012C2  1030 4800 3074          move.b    0(A0,D4.L),D0
000012C6  660E      3075          bne.s     OS_EventTaskWaitMulti_4
                    3076   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000012C8  2052      3077          move.l    (A2),A0
000012CA  1028 0038 3078          move.b    56(A0),D0
000012CE  4600      3079          not.b     D0
000012D0  C139 0800 3080          and.b     D0,_OSRdyGrp.L
000012D4  042E      
                    3081   OS_EventTaskWaitMulti_4:
000012D6  4CDF 041C 3082          movem.l   (A7)+,D2/D3/D4/A2
000012DA  4E5E      3083          unlk      A6
000012DC  4E75      3084          rts
                    3085   ; }
                    3086   ; }
                    3087   ; #endif
                    3088   ; /*$PAGE*/
                    3089   ; /*
                    3090   ; *********************************************************************************************************
                    3091   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    3092   ; *
                    3093   ; * Description: Remove a task from an event's wait list.
                    3094   ; *
                    3095   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    3096   ; *
                    3097   ; *              pevent   is a pointer to the event control block.
                    3098   ; *
                    3099   ; * Returns    : none
                    3100   ; *
                    3101   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3102   ; *********************************************************************************************************
                    3103   ; */
                    3104   ; #if (OS_EVENT_EN)
                    3105   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    3106   ; OS_EVENT *pevent)
                    3107   ; {
                    3108   _OS_EventTaskRemove:
000012DE  4E56 0000 3109          link      A6,#0
000012E2  48E7 3800 3110          movem.l   D2/D3/D4,-(A7)
000012E6  242E 000C 3111          move.l    12(A6),D2
000012EA  262E 0008 3112          move.l    8(A6),D3
                    3113   ; INT8U  y;
                    3114   ; y                       =  ptcb->OSTCBY;
000012EE  2043      3115          move.l    D3,A0
000012F0  1828 0036 3116          move.b    54(A0),D4
                    3117   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000012F4  2042      3118          move.l    D2,A0
000012F6  C8BC 0000 3119          and.l     #255,D4
000012FA  00FF      
000012FC  D1C4      3120          add.l     D4,A0
000012FE  2243      3121          move.l    D3,A1
00001300  1029 0037 3122          move.b    55(A1),D0
00001304  4600      3123          not.b     D0
00001306  C128 000A 3124          and.b     D0,10(A0)
                    3125   ; if (pevent->OSEventTbl[y] == 0u) {
0000130A  2042      3126          move.l    D2,A0
0000130C  C8BC 0000 3127          and.l     #255,D4
00001310  00FF      
00001312  D1C4      3128          add.l     D4,A0
00001314  1028 000A 3129          move.b    10(A0),D0
00001318  660E      3130          bne.s     OS_EventTaskRemove_1
                    3131   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000131A  2042      3132          move.l    D2,A0
0000131C  2243      3133          move.l    D3,A1
0000131E  1029 0038 3134          move.b    56(A1),D0
00001322  4600      3135          not.b     D0
00001324  C128 0008 3136          and.b     D0,8(A0)
                    3137   OS_EventTaskRemove_1:
00001328  4CDF 001C 3138          movem.l   (A7)+,D2/D3/D4
0000132C  4E5E      3139          unlk      A6
0000132E  4E75      3140          rts
                    3141   ; }
                    3142   ; }
                    3143   ; #endif
                    3144   ; /*$PAGE*/
                    3145   ; /*
                    3146   ; *********************************************************************************************************
                    3147   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    3148   ; *
                    3149   ; * Description: Remove a task from multiple events' wait lists.
                    3150   ; *
                    3151   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3152   ; *
                    3153   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3154   ; *
                    3155   ; * Returns    : none
                    3156   ; *
                    3157   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3158   ; *********************************************************************************************************
                    3159   ; */
                    3160   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3161   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3162   ; OS_EVENT **pevents_multi)
                    3163   ; {
                    3164   _OS_EventTaskRemoveMulti:
00001330  4E56 FFFC 3165          link      A6,#-4
00001334  48E7 3C00 3166          movem.l   D2/D3/D4/D5,-(A7)
00001338  282E 0008 3167          move.l    8(A6),D4
                    3168   ; OS_EVENT **pevents;
                    3169   ; OS_EVENT  *pevent;
                    3170   ; INT8U      y;
                    3171   ; OS_PRIO    bity;
                    3172   ; OS_PRIO    bitx;
                    3173   ; y       =  ptcb->OSTCBY;
0000133C  2044      3174          move.l    D4,A0
0000133E  1A28 0036 3175          move.b    54(A0),D5
                    3176   ; bity    =  ptcb->OSTCBBitY;
00001342  2044      3177          move.l    D4,A0
00001344  1D68 0038 3178          move.b    56(A0),-2(A6)
00001348  FFFE      
                    3179   ; bitx    =  ptcb->OSTCBBitX;
0000134A  2044      3180          move.l    D4,A0
0000134C  1D68 0037 3181          move.b    55(A0),-1(A6)
00001350  FFFF      
                    3182   ; pevents =  pevents_multi;
00001352  262E 000C 3183          move.l    12(A6),D3
                    3184   ; pevent  = *pevents;
00001356  2043      3185          move.l    D3,A0
00001358  2410      3186          move.l    (A0),D2
                    3187   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3188   OS_EventTaskRemoveMulti_1:
0000135A  4A82      3189          tst.l     D2
0000135C  6700 003A 3190          beq       OS_EventTaskRemoveMulti_3
                    3191   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
00001360  2042      3192          move.l    D2,A0
00001362  CABC 0000 3193          and.l     #255,D5
00001366  00FF      
00001368  D1C5      3194          add.l     D5,A0
0000136A  102E FFFF 3195          move.b    -1(A6),D0
0000136E  4600      3196          not.b     D0
00001370  C128 000A 3197          and.b     D0,10(A0)
                    3198   ; if (pevent->OSEventTbl[y] == 0u) {
00001374  2042      3199          move.l    D2,A0
00001376  CABC 0000 3200          and.l     #255,D5
0000137A  00FF      
0000137C  D1C5      3201          add.l     D5,A0
0000137E  1028 000A 3202          move.b    10(A0),D0
00001382  660C      3203          bne.s     OS_EventTaskRemoveMulti_4
                    3204   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
00001384  2042      3205          move.l    D2,A0
00001386  102E FFFE 3206          move.b    -2(A6),D0
0000138A  4600      3207          not.b     D0
0000138C  C128 0008 3208          and.b     D0,8(A0)
                    3209   OS_EventTaskRemoveMulti_4:
                    3210   ; }
                    3211   ; pevents++;
00001390  5883      3212          addq.l    #4,D3
                    3213   ; pevent = *pevents;
00001392  2043      3214          move.l    D3,A0
00001394  2410      3215          move.l    (A0),D2
00001396  60C2      3216          bra       OS_EventTaskRemoveMulti_1
                    3217   OS_EventTaskRemoveMulti_3:
00001398  4CDF 003C 3218          movem.l   (A7)+,D2/D3/D4/D5
0000139C  4E5E      3219          unlk      A6
0000139E  4E75      3220          rts
                    3221   ; }
                    3222   ; }
                    3223   ; #endif
                    3224   ; /*$PAGE*/
                    3225   ; /*
                    3226   ; *********************************************************************************************************
                    3227   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3228   ; *
                    3229   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3230   ; *
                    3231   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3232   ; *
                    3233   ; * Returns    : none
                    3234   ; *
                    3235   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3236   ; *********************************************************************************************************
                    3237   ; */
                    3238   ; #if (OS_EVENT_EN)
                    3239   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3240   ; {
                    3241   _OS_EventWaitListInit:
000013A0  4E56 0000 3242          link      A6,#0
000013A4  2F02      3243          move.l    D2,-(A7)
                    3244   ; INT8U  i;
                    3245   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000013A6  206E 0008 3246          move.l    8(A6),A0
000013AA  4228 0008 3247          clr.b     8(A0)
                    3248   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000013AE  4202      3249          clr.b     D2
                    3250   OS_EventWaitListInit_1:
000013B0  0C02 0008 3251          cmp.b     #8,D2
000013B4  6414      3252          bhs.s     OS_EventWaitListInit_3
                    3253   ; pevent->OSEventTbl[i] = 0u;
000013B6  206E 0008 3254          move.l    8(A6),A0
000013BA  C4BC 0000 3255          and.l     #255,D2
000013BE  00FF      
000013C0  D1C2      3256          add.l     D2,A0
000013C2  4228 000A 3257          clr.b     10(A0)
000013C6  5202      3258          addq.b    #1,D2
000013C8  60E6      3259          bra       OS_EventWaitListInit_1
                    3260   OS_EventWaitListInit_3:
000013CA  241F      3261          move.l    (A7)+,D2
000013CC  4E5E      3262          unlk      A6
000013CE  4E75      3263          rts
                    3264   ; }
                    3265   ; }
                    3266   ; #endif
                    3267   ; /*$PAGE*/
                    3268   ; /*
                    3269   ; *********************************************************************************************************
                    3270   ; *                                             INITIALIZATION
                    3271   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3272   ; *
                    3273   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3274   ; *
                    3275   ; * Arguments  : none
                    3276   ; *
                    3277   ; * Returns    : none
                    3278   ; *********************************************************************************************************
                    3279   ; */
                    3280   ; static  void  OS_InitEventList (void)
                    3281   ; {
                    3282   @ucos_ii_OS_InitEventList:
000013D0  4E56 FFF8 3283          link      A6,#-8
000013D4  48E7 3020 3284          movem.l   D2/D3/A2,-(A7)
000013D8  45F9 0800 3285          lea       _OSEventTbl.L,A2
000013DC  01FE      
                    3286   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3287   ; #if (OS_MAX_EVENTS > 1u)
                    3288   ; INT16U     ix;
                    3289   ; INT16U     ix_next;
                    3290   ; OS_EVENT  *pevent1;
                    3291   ; OS_EVENT  *pevent2;
                    3292   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000013DE  4878 00DC 3293          pea       220
000013E2  2F0A      3294          move.l    A2,-(A7)
000013E4  4EB9 0000 3295          jsr       _OS_MemClr
000013E8  166C      
000013EA  504F      3296          addq.w    #8,A7
                    3297   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
000013EC  4243      3298          clr.w     D3
                    3299   @ucos_ii_OS_InitEventList_1:
000013EE  0C43 0009 3300          cmp.w     #9,D3
000013F2  6400 004E 3301          bhs       @ucos_ii_OS_InitEventList_3
                    3302   ; ix_next = ix + 1u;
000013F6  3003      3303          move.w    D3,D0
000013F8  5240      3304          addq.w    #1,D0
000013FA  3D40 FFFA 3305          move.w    D0,-6(A6)
                    3306   ; pevent1 = &OSEventTbl[ix];
000013FE  200A      3307          move.l    A2,D0
00001400  C6BC 0000 3308          and.l     #65535,D3
00001404  FFFF      
00001406  2203      3309          move.l    D3,D1
00001408  C3FC 0016 3310          muls      #22,D1
0000140C  D081      3311          add.l     D1,D0
0000140E  2400      3312          move.l    D0,D2
                    3313   ; pevent2 = &OSEventTbl[ix_next];
00001410  200A      3314          move.l    A2,D0
00001412  322E FFFA 3315          move.w    -6(A6),D1
00001416  C2BC 0000 3316          and.l     #65535,D1
0000141A  FFFF      
0000141C  C3FC 0016 3317          muls      #22,D1
00001420  D081      3318          add.l     D1,D0
00001422  2D40 FFFC 3319          move.l    D0,-4(A6)
                    3320   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00001426  2042      3321          move.l    D2,A0
00001428  4210      3322          clr.b     (A0)
                    3323   ; pevent1->OSEventPtr     = pevent2;
0000142A  2042      3324          move.l    D2,A0
0000142C  216E FFFC 3325          move.l    -4(A6),2(A0)
00001430  0002      
                    3326   ; #if OS_EVENT_NAME_EN > 0u
                    3327   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00001432  41F9 0000 3328          lea       @ucos_ii_1.L,A0
00001436  763A      
00001438  2242      3329          move.l    D2,A1
0000143A  2348 0012 3330          move.l    A0,18(A1)
0000143E  5243      3331          addq.w    #1,D3
00001440  60AC      3332          bra       @ucos_ii_OS_InitEventList_1
                    3333   @ucos_ii_OS_InitEventList_3:
                    3334   ; #endif
                    3335   ; }
                    3336   ; pevent1                         = &OSEventTbl[ix];
00001442  200A      3337          move.l    A2,D0
00001444  C6BC 0000 3338          and.l     #65535,D3
00001448  FFFF      
0000144A  2203      3339          move.l    D3,D1
0000144C  C3FC 0016 3340          muls      #22,D1
00001450  D081      3341          add.l     D1,D0
00001452  2400      3342          move.l    D0,D2
                    3343   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00001454  2042      3344          move.l    D2,A0
00001456  4210      3345          clr.b     (A0)
                    3346   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
00001458  2042      3347          move.l    D2,A0
0000145A  42A8 0002 3348          clr.l     2(A0)
                    3349   ; #if OS_EVENT_NAME_EN > 0u
                    3350   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
0000145E  41F9 0000 3351          lea       @ucos_ii_1.L,A0
00001462  763A      
00001464  2242      3352          move.l    D2,A1
00001466  2348 0012 3353          move.l    A0,18(A1)
                    3354   ; #endif
                    3355   ; OSEventFreeList                 = &OSEventTbl[0];
0000146A  23CA 0800 3356          move.l    A2,_OSEventFreeList.L
0000146E  01FA      
00001470  4CDF 040C 3357          movem.l   (A7)+,D2/D3/A2
00001474  4E5E      3358          unlk      A6
00001476  4E75      3359          rts
                    3360   ; #else
                    3361   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3362   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3363   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3364   ; #if OS_EVENT_NAME_EN > 0u
                    3365   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3366   ; #endif
                    3367   ; #endif
                    3368   ; #endif
                    3369   ; }
                    3370   ; /*$PAGE*/
                    3371   ; /*
                    3372   ; *********************************************************************************************************
                    3373   ; *                                             INITIALIZATION
                    3374   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3375   ; *
                    3376   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3377   ; *
                    3378   ; * Arguments  : none
                    3379   ; *
                    3380   ; * Returns    : none
                    3381   ; *********************************************************************************************************
                    3382   ; */
                    3383   ; static  void  OS_InitMisc (void)
                    3384   ; {
                    3385   @ucos_ii_OS_InitMisc:
                    3386   ; #if OS_TIME_GET_SET_EN > 0u
                    3387   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
00001478  42B9 0800 3388          clr.l     _OSTime.L
0000147C  0E96      
                    3389   ; #endif
                    3390   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
0000147E  4239 0800 3391          clr.b     _OSIntNesting.L
00001482  0426      
                    3392   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
00001484  4239 0800 3393          clr.b     _OSLockNesting.L
00001488  0428      
                    3394   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
0000148A  4239 0800 3395          clr.b     _OSTaskCtr.L
0000148E  043A      
                    3396   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
00001490  4239 0800 3397          clr.b     _OSRunning.L
00001494  0438      
                    3398   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
00001496  42B9 0800 3399          clr.l     _OSCtxSwCtr.L
0000149A  01F6      
                    3400   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
0000149C  42B9 0800 3401          clr.l     _OSIdleCtr.L
000014A0  043C      
                    3402   ; #if OS_TASK_STAT_EN > 0u
                    3403   ; OSIdleCtrRun              = 0uL;
000014A2  42B9 0800 3404          clr.l     _OSIdleCtrRun.L
000014A6  0320      
                    3405   ; OSIdleCtrMax              = 0uL;
000014A8  42B9 0800 3406          clr.l     _OSIdleCtrMax.L
000014AC  031C      
                    3407   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000014AE  4239 0800 3408          clr.b     _OSStatRdy.L
000014B2  0324      
                    3409   ; #endif
                    3410   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3411   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3412   ; #endif
                    3413   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3414   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
000014B4  4239 0800 3415          clr.b     _OSTaskRegNextAvailID.L
000014B8  0E94      
000014BA  4E75      3416          rts
                    3417   ; #endif
                    3418   ; }
                    3419   ; /*$PAGE*/
                    3420   ; /*
                    3421   ; *********************************************************************************************************
                    3422   ; *                                             INITIALIZATION
                    3423   ; *                                       INITIALIZE THE READY LIST
                    3424   ; *
                    3425   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3426   ; *
                    3427   ; * Arguments  : none
                    3428   ; *
                    3429   ; * Returns    : none
                    3430   ; *********************************************************************************************************
                    3431   ; */
                    3432   ; static  void  OS_InitRdyList (void)
                    3433   ; {
                    3434   @ucos_ii_OS_InitRdyList:
000014BC  2F02      3435          move.l    D2,-(A7)
                    3436   ; INT8U  i;
                    3437   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000014BE  4239 0800 3438          clr.b     _OSRdyGrp.L
000014C2  042E      
                    3439   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000014C4  4202      3440          clr.b     D2
                    3441   @ucos_ii_OS_InitRdyList_1:
000014C6  0C02 0008 3442          cmp.b     #8,D2
000014CA  6414      3443          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3444   ; OSRdyTbl[i] = 0u;
000014CC  C4BC 0000 3445          and.l     #255,D2
000014D0  00FF      
000014D2  41F9 0800 3446          lea       _OSRdyTbl.L,A0
000014D6  0430      
000014D8  4230 2800 3447          clr.b     0(A0,D2.L)
000014DC  5202      3448          addq.b    #1,D2
000014DE  60E6      3449          bra       @ucos_ii_OS_InitRdyList_1
                    3450   @ucos_ii_OS_InitRdyList_3:
                    3451   ; }
                    3452   ; OSPrioCur     = 0u;
000014E0  4239 0800 3453          clr.b     _OSPrioCur.L
000014E4  042A      
                    3454   ; OSPrioHighRdy = 0u;
000014E6  4239 0800 3455          clr.b     _OSPrioHighRdy.L
000014EA  042C      
                    3456   ; OSTCBHighRdy  = (OS_TCB *)0;
000014EC  42B9 0800 3457          clr.l     _OSTCBHighRdy.L
000014F0  0548      
                    3458   ; OSTCBCur      = (OS_TCB *)0;
000014F2  42B9 0800 3459          clr.l     _OSTCBCur.L
000014F6  0540      
000014F8  241F      3460          move.l    (A7)+,D2
000014FA  4E75      3461          rts
                    3462   ; }
                    3463   ; /*$PAGE*/
                    3464   ; /*
                    3465   ; *********************************************************************************************************
                    3466   ; *                                             INITIALIZATION
                    3467   ; *                                         CREATING THE IDLE TASK
                    3468   ; *
                    3469   ; * Description: This function creates the Idle Task.
                    3470   ; *
                    3471   ; * Arguments  : none
                    3472   ; *
                    3473   ; * Returns    : none
                    3474   ; *********************************************************************************************************
                    3475   ; */
                    3476   ; static  void  OS_InitTaskIdle (void)
                    3477   ; {
                    3478   @ucos_ii_OS_InitTaskIdle:
000014FC  4E56 FFFC 3479          link      A6,#-4
                    3480   ; #if OS_TASK_NAME_EN > 0u
                    3481   ; INT8U  err;
                    3482   ; #endif
                    3483   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3484   ; #if OS_STK_GROWTH == 1u
                    3485   ; (void)OSTaskCreateExt(OS_TaskIdle,
00001500  4878 0003 3486          pea       3
00001504  42A7      3487          clr.l     -(A7)
00001506  4878 0080 3488          pea       128
0000150A  4879 0800 3489          pea       _OSTaskIdleStk.L
0000150E  0440      
00001510  4878 FFFF 3490          pea       65535
00001514  4878 003F 3491          pea       63
00001518  41F9 0800 3492          lea       _OSTaskIdleStk.L,A0
0000151C  0440      
0000151E  D0FC 00FE 3493          add.w     #254,A0
00001522  2F08      3494          move.l    A0,-(A7)
00001524  42A7      3495          clr.l     -(A7)
00001526  4879 0000 3496          pea       _OS_TaskIdle.L
0000152A  1782      
0000152C  4EB9 0000 3497          jsr       _OSTaskCreateExt
00001530  4622      
00001532  DEFC 0024 3498          add.w     #36,A7
00001536  C0BC 0000 3499          and.l     #255,D0
0000153A  00FF      
                    3500   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3501   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3502   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3503   ; OS_TASK_IDLE_ID,
                    3504   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3505   ; OS_TASK_IDLE_STK_SIZE,
                    3506   ; (void *)0,                                 /* No TCB extension                     */
                    3507   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3508   ; #else
                    3509   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3510   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3511   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3512   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3513   ; OS_TASK_IDLE_ID,
                    3514   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3515   ; OS_TASK_IDLE_STK_SIZE,
                    3516   ; (void *)0,                                 /* No TCB extension                     */
                    3517   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3518   ; #endif
                    3519   ; #else
                    3520   ; #if OS_STK_GROWTH == 1u
                    3521   ; (void)OSTaskCreate(OS_TaskIdle,
                    3522   ; (void *)0,
                    3523   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3524   ; OS_TASK_IDLE_PRIO);
                    3525   ; #else
                    3526   ; (void)OSTaskCreate(OS_TaskIdle,
                    3527   ; (void *)0,
                    3528   ; &OSTaskIdleStk[0],
                    3529   ; OS_TASK_IDLE_PRIO);
                    3530   ; #endif
                    3531   ; #endif
                    3532   ; #if OS_TASK_NAME_EN > 0u
                    3533   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
0000153C  486E FFFF 3534          pea       -1(A6)
00001540  4879 0000 3535          pea       @ucos_ii_2.L
00001544  763C      
00001546  4878 003F 3536          pea       63
0000154A  4EB9 0000 3537          jsr       _OSTaskNameSet
0000154E  4A2E      
00001550  DEFC 000C 3538          add.w     #12,A7
00001554  4E5E      3539          unlk      A6
00001556  4E75      3540          rts
                    3541   ; #endif
                    3542   ; }
                    3543   ; /*$PAGE*/
                    3544   ; /*
                    3545   ; *********************************************************************************************************
                    3546   ; *                                             INITIALIZATION
                    3547   ; *                                      CREATING THE STATISTIC TASK
                    3548   ; *
                    3549   ; * Description: This function creates the Statistic Task.
                    3550   ; *
                    3551   ; * Arguments  : none
                    3552   ; *
                    3553   ; * Returns    : none
                    3554   ; *********************************************************************************************************
                    3555   ; */
                    3556   ; #if OS_TASK_STAT_EN > 0u
                    3557   ; static  void  OS_InitTaskStat (void)
                    3558   ; {
                    3559   @ucos_ii_OS_InitTaskStat:
00001558  4E56 FFFC 3560          link      A6,#-4
                    3561   ; #if OS_TASK_NAME_EN > 0u
                    3562   ; INT8U  err;
                    3563   ; #endif
                    3564   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3565   ; #if OS_STK_GROWTH == 1u
                    3566   ; (void)OSTaskCreateExt(OS_TaskStat,
0000155C  4878 0003 3567          pea       3
00001560  42A7      3568          clr.l     -(A7)
00001562  4878 0080 3569          pea       128
00001566  4879 0800 3570          pea       _OSTaskStatStk.L
0000156A  0326      
0000156C  4878 FFFE 3571          pea       65534
00001570  4878 003E 3572          pea       62
00001574  41F9 0800 3573          lea       _OSTaskStatStk.L,A0
00001578  0326      
0000157A  D0FC 00FE 3574          add.w     #254,A0
0000157E  2F08      3575          move.l    A0,-(A7)
00001580  42A7      3576          clr.l     -(A7)
00001582  4879 0000 3577          pea       _OS_TaskStat.L
00001586  179A      
00001588  4EB9 0000 3578          jsr       _OSTaskCreateExt
0000158C  4622      
0000158E  DEFC 0024 3579          add.w     #36,A7
00001592  C0BC 0000 3580          and.l     #255,D0
00001596  00FF      
                    3581   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3582   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3583   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3584   ; OS_TASK_STAT_ID,
                    3585   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3586   ; OS_TASK_STAT_STK_SIZE,
                    3587   ; (void *)0,                                   /* No TCB extension               */
                    3588   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3589   ; #else
                    3590   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3591   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3592   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3593   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3594   ; OS_TASK_STAT_ID,
                    3595   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3596   ; OS_TASK_STAT_STK_SIZE,
                    3597   ; (void *)0,                                   /* No TCB extension               */
                    3598   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3599   ; #endif
                    3600   ; #else
                    3601   ; #if OS_STK_GROWTH == 1u
                    3602   ; (void)OSTaskCreate(OS_TaskStat,
                    3603   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3604   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3605   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3606   ; #else
                    3607   ; (void)OSTaskCreate(OS_TaskStat,
                    3608   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3609   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3610   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3611   ; #endif
                    3612   ; #endif
                    3613   ; #if OS_TASK_NAME_EN > 0u
                    3614   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
00001598  486E FFFF 3615          pea       -1(A6)
0000159C  4879 0000 3616          pea       @ucos_ii_3.L
000015A0  764A      
000015A2  4878 003E 3617          pea       62
000015A6  4EB9 0000 3618          jsr       _OSTaskNameSet
000015AA  4A2E      
000015AC  DEFC 000C 3619          add.w     #12,A7
000015B0  4E5E      3620          unlk      A6
000015B2  4E75      3621          rts
                    3622   ; #endif
                    3623   ; }
                    3624   ; #endif
                    3625   ; /*$PAGE*/
                    3626   ; /*
                    3627   ; *********************************************************************************************************
                    3628   ; *                                             INITIALIZATION
                    3629   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3630   ; *
                    3631   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3632   ; *
                    3633   ; * Arguments  : none
                    3634   ; *
                    3635   ; * Returns    : none
                    3636   ; *********************************************************************************************************
                    3637   ; */
                    3638   ; static  void  OS_InitTCBList (void)
                    3639   ; {
                    3640   @ucos_ii_OS_InitTCBList:
000015B4  4E56 FFF8 3641          link      A6,#-8
000015B8  48E7 3020 3642          movem.l   D2/D3/A2,-(A7)
000015BC  45F9 0800 3643          lea       _OSTCBTbl.L,A2
000015C0  0650      
                    3644   ; INT8U    ix;
                    3645   ; INT8U    ix_next;
                    3646   ; OS_TCB  *ptcb1;
                    3647   ; OS_TCB  *ptcb2;
                    3648   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000015C2  4878 0764 3649          pea       1892
000015C6  2F0A      3650          move.l    A2,-(A7)
000015C8  4EB9 0000 3651          jsr       _OS_MemClr
000015CC  166C      
000015CE  504F      3652          addq.w    #8,A7
                    3653   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
000015D0  4878 0100 3654          pea       256
000015D4  4879 0800 3655          pea       _OSTCBPrioTbl.L
000015D8  0550      
000015DA  4EB9 0000 3656          jsr       _OS_MemClr
000015DE  166C      
000015E0  504F      3657          addq.w    #8,A7
                    3658   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000015E2  4203      3659          clr.b     D3
                    3660   @ucos_ii_OS_InitTCBList_1:
000015E4  0C03 0015 3661          cmp.b     #21,D3
000015E8  6400 004A 3662          bhs       @ucos_ii_OS_InitTCBList_3
                    3663   ; ix_next =  ix + 1u;
000015EC  7001      3664          moveq     #1,D0
000015EE  D003      3665          add.b     D3,D0
000015F0  1D40 FFFB 3666          move.b    D0,-5(A6)
                    3667   ; ptcb1   = &OSTCBTbl[ix];
000015F4  200A      3668          move.l    A2,D0
000015F6  C6BC 0000 3669          and.l     #255,D3
000015FA  00FF      
000015FC  2203      3670          move.l    D3,D1
000015FE  C3FC 0056 3671          muls      #86,D1
00001602  D081      3672          add.l     D1,D0
00001604  2400      3673          move.l    D0,D2
                    3674   ; ptcb2   = &OSTCBTbl[ix_next];
00001606  200A      3675          move.l    A2,D0
00001608  122E FFFB 3676          move.b    -5(A6),D1
0000160C  C2BC 0000 3677          and.l     #255,D1
00001610  00FF      
00001612  C3FC 0056 3678          muls      #86,D1
00001616  D081      3679          add.l     D1,D0
00001618  2D40 FFFC 3680          move.l    D0,-4(A6)
                    3681   ; ptcb1->OSTCBNext = ptcb2;
0000161C  2042      3682          move.l    D2,A0
0000161E  216E FFFC 3683          move.l    -4(A6),20(A0)
00001622  0014      
                    3684   ; #if OS_TASK_NAME_EN > 0u
                    3685   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00001624  41F9 0000 3686          lea       @ucos_ii_1.L,A0
00001628  763A      
0000162A  2242      3687          move.l    D2,A1
0000162C  2348 004E 3688          move.l    A0,78(A1)
00001630  5203      3689          addq.b    #1,D3
00001632  60B0      3690          bra       @ucos_ii_OS_InitTCBList_1
                    3691   @ucos_ii_OS_InitTCBList_3:
                    3692   ; #endif
                    3693   ; }
                    3694   ; ptcb1                   = &OSTCBTbl[ix];
00001634  200A      3695          move.l    A2,D0
00001636  C6BC 0000 3696          and.l     #255,D3
0000163A  00FF      
0000163C  2203      3697          move.l    D3,D1
0000163E  C3FC 0056 3698          muls      #86,D1
00001642  D081      3699          add.l     D1,D0
00001644  2400      3700          move.l    D0,D2
                    3701   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
00001646  2042      3702          move.l    D2,A0
00001648  42A8 0014 3703          clr.l     20(A0)
                    3704   ; #if OS_TASK_NAME_EN > 0u
                    3705   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
0000164C  41F9 0000 3706          lea       @ucos_ii_1.L,A0
00001650  763A      
00001652  2242      3707          move.l    D2,A1
00001654  2348 004E 3708          move.l    A0,78(A1)
                    3709   ; #endif
                    3710   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00001658  42B9 0800 3711          clr.l     _OSTCBList.L
0000165C  054C      
                    3712   ; OSTCBFreeList           = &OSTCBTbl[0];
0000165E  23CA 0800 3713          move.l    A2,_OSTCBFreeList.L
00001662  0544      
00001664  4CDF 040C 3714          movem.l   (A7)+,D2/D3/A2
00001668  4E5E      3715          unlk      A6
0000166A  4E75      3716          rts
                    3717   ; }
                    3718   ; /*$PAGE*/
                    3719   ; /*
                    3720   ; *********************************************************************************************************
                    3721   ; *                                      CLEAR A SECTION OF MEMORY
                    3722   ; *
                    3723   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3724   ; *
                    3725   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3726   ; *
                    3727   ; *              size     is the number of bytes to clear.
                    3728   ; *
                    3729   ; * Returns    : none
                    3730   ; *
                    3731   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3732   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3733   ; *                 of the uses of this function gets close to this limit.
                    3734   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3735   ; *                 of the alignment of the destination.
                    3736   ; *********************************************************************************************************
                    3737   ; */
                    3738   ; void  OS_MemClr (INT8U  *pdest,
                    3739   ; INT16U  size)
                    3740   ; {
                    3741   _OS_MemClr:
0000166C  4E56 0000 3742          link      A6,#0
                    3743   ; while (size > 0u) {
                    3744   OS_MemClr_1:
00001670  302E 000E 3745          move.w    14(A6),D0
00001674  0C40 0000 3746          cmp.w     #0,D0
00001678  6310      3747          bls.s     OS_MemClr_3
                    3748   ; *pdest++ = (INT8U)0;
0000167A  206E 0008 3749          move.l    8(A6),A0
0000167E  52AE 0008 3750          addq.l    #1,8(A6)
00001682  4210      3751          clr.b     (A0)
                    3752   ; size--;
00001684  536E 000E 3753          subq.w    #1,14(A6)
00001688  60E6      3754          bra       OS_MemClr_1
                    3755   OS_MemClr_3:
0000168A  4E5E      3756          unlk      A6
0000168C  4E75      3757          rts
                    3758   ; }
                    3759   ; }
                    3760   ; /*$PAGE*/
                    3761   ; /*
                    3762   ; *********************************************************************************************************
                    3763   ; *                                       COPY A BLOCK OF MEMORY
                    3764   ; *
                    3765   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3766   ; *              location to another.
                    3767   ; *
                    3768   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    3769   ; *
                    3770   ; *              psrc     is a pointer to the 'source'      memory block
                    3771   ; *
                    3772   ; *              size     is the number of bytes to copy.
                    3773   ; *
                    3774   ; * Returns    : none
                    3775   ; *
                    3776   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    3777   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    3778   ; *                 is not a situation that will happen.
                    3779   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    3780   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    3781   ; *                 of the alignment of the source and destination.
                    3782   ; *********************************************************************************************************
                    3783   ; */
                    3784   ; void  OS_MemCopy (INT8U  *pdest,
                    3785   ; INT8U  *psrc,
                    3786   ; INT16U  size)
                    3787   ; {
                    3788   _OS_MemCopy:
0000168E  4E56 0000 3789          link      A6,#0
                    3790   ; while (size > 0u) {
                    3791   OS_MemCopy_1:
00001692  302E 0012 3792          move.w    18(A6),D0
00001696  0C40 0000 3793          cmp.w     #0,D0
0000169A  6318      3794          bls.s     OS_MemCopy_3
                    3795   ; *pdest++ = *psrc++;
0000169C  206E 000C 3796          move.l    12(A6),A0
000016A0  52AE 000C 3797          addq.l    #1,12(A6)
000016A4  226E 0008 3798          move.l    8(A6),A1
000016A8  52AE 0008 3799          addq.l    #1,8(A6)
000016AC  1290      3800          move.b    (A0),(A1)
                    3801   ; size--;
000016AE  536E 0012 3802          subq.w    #1,18(A6)
000016B2  60DE      3803          bra       OS_MemCopy_1
                    3804   OS_MemCopy_3:
000016B4  4E5E      3805          unlk      A6
000016B6  4E75      3806          rts
                    3807   ; }
                    3808   ; }
                    3809   ; /*$PAGE*/
                    3810   ; /*
                    3811   ; *********************************************************************************************************
                    3812   ; *                                              SCHEDULER
                    3813   ; *
                    3814   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    3815   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    3816   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    3817   ; *
                    3818   ; * Arguments  : none
                    3819   ; *
                    3820   ; * Returns    : none
                    3821   ; *
                    3822   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3823   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    3824   ; *********************************************************************************************************
                    3825   ; */
                    3826   ; void  OS_Sched (void)
                    3827   ; {
                    3828   _OS_Sched:
                    3829   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    3830   ; OS_CPU_SR  cpu_sr = 0u;
                    3831   ; #endif
                    3832   ; OS_ENTER_CRITICAL();
000016B8  40E7      3833          dc.w      16615
000016BA  007C      3834          dc.w      124
000016BC  0700      3835          dc.w      1792
                    3836   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
000016BE  1039 0800 3837          move.b    _OSIntNesting.L,D0
000016C2  0426      
000016C4  6600 0052 3838          bne       OS_Sched_5
                    3839   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000016C8  1039 0800 3840          move.b    _OSLockNesting.L,D0
000016CC  0428      
000016CE  6648      3841          bne.s     OS_Sched_5
                    3842   ; OS_SchedNew();
000016D0  4EB9 0000 3843          jsr       @ucos_ii_OS_SchedNew
000016D4  171C      
                    3844   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000016D6  1039 0800 3845          move.b    _OSPrioHighRdy.L,D0
000016DA  042C      
000016DC  C0BC 0000 3846          and.l     #255,D0
000016E0  00FF      
000016E2  E588      3847          lsl.l     #2,D0
000016E4  41F9 0800 3848          lea       _OSTCBPrioTbl.L,A0
000016E8  0550      
000016EA  23F0 0800 3849          move.l    0(A0,D0.L),_OSTCBHighRdy.L
000016EE  0800 0548 
                    3850   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000016F2  1039 0800 3851          move.b    _OSPrioHighRdy.L,D0
000016F6  042C      
000016F8  B039 0800 3852          cmp.b     _OSPrioCur.L,D0
000016FC  042A      
000016FE  6718      3853          beq.s     OS_Sched_5
                    3854   ; #if OS_TASK_PROFILE_EN > 0u
                    3855   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00001700  2039 0800 3856          move.l    _OSTCBHighRdy.L,D0
00001704  0548      
00001706  0680 0000 3857          add.l     #58,D0
0000170A  003A      
0000170C  2040      3858          move.l    D0,A0
0000170E  5290      3859          addq.l    #1,(A0)
                    3860   ; #endif
                    3861   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
00001710  52B9 0800 3862          addq.l    #1,_OSCtxSwCtr.L
00001714  01F6      
                    3863   ; OS_TASK_SW();                          /* Perform a context switch                     */
00001716  4E40      3864          trap      #0
                    3865   OS_Sched_5:
                    3866   ; }
                    3867   ; }
                    3868   ; }
                    3869   ; OS_EXIT_CRITICAL();
00001718  46DF      3870          dc.w      18143
0000171A  4E75      3871          rts
                    3872   ; }
                    3873   ; /*
                    3874   ; *********************************************************************************************************
                    3875   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    3876   ; *
                    3877   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    3878   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    3879   ; *
                    3880   ; * Arguments  : none
                    3881   ; *
                    3882   ; * Returns    : none
                    3883   ; *
                    3884   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3885   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    3886   ; *********************************************************************************************************
                    3887   ; */
                    3888   ; static  void  OS_SchedNew (void)
                    3889   ; {
                    3890   @ucos_ii_OS_SchedNew:
0000171C  2F02      3891          move.l    D2,-(A7)
                    3892   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    3893   ; INT8U   y;
                    3894   ; y             = OSUnMapTbl[OSRdyGrp];
0000171E  1039 0800 3895          move.b    _OSRdyGrp.L,D0
00001722  042E      
00001724  C0BC 0000 3896          and.l     #255,D0
00001728  00FF      
0000172A  41F9 0000 3897          lea       _OSUnMapTbl.L,A0
0000172E  768C      
00001730  1430 0800 3898          move.b    0(A0,D0.L),D2
                    3899   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00001734  1002      3900          move.b    D2,D0
00001736  E708      3901          lsl.b     #3,D0
00001738  C4BC 0000 3902          and.l     #255,D2
0000173C  00FF      
0000173E  41F9 0800 3903          lea       _OSRdyTbl.L,A0
00001742  0430      
00001744  1230 2800 3904          move.b    0(A0,D2.L),D1
00001748  C2BC 0000 3905          and.l     #255,D1
0000174C  00FF      
0000174E  41F9 0000 3906          lea       _OSUnMapTbl.L,A0
00001752  768C      
00001754  D030 1800 3907          add.b     0(A0,D1.L),D0
00001758  13C0 0800 3908          move.b    D0,_OSPrioHighRdy.L
0000175C  042C      
0000175E  241F      3909          move.l    (A7)+,D2
00001760  4E75      3910          rts
                    3911   ; #else                                            /* We support up to 256 tasks                         */
                    3912   ; INT8U     y;
                    3913   ; OS_PRIO  *ptbl;
                    3914   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    3915   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    3916   ; } else {
                    3917   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    3918   ; }
                    3919   ; ptbl = &OSRdyTbl[y];
                    3920   ; if ((*ptbl & 0xFFu) != 0u) {
                    3921   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    3922   ; } else {
                    3923   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    3924   ; }
                    3925   ; #endif
                    3926   ; }
                    3927   ; /*$PAGE*/
                    3928   ; /*
                    3929   ; *********************************************************************************************************
                    3930   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    3931   ; *
                    3932   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    3933   ; *              (excluding the NUL character).
                    3934   ; *
                    3935   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    3936   ; *
                    3937   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    3938   ; *
                    3939   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3940   ; *              2) The string to check must be less than 255 characters long.
                    3941   ; *********************************************************************************************************
                    3942   ; */
                    3943   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    3944   ; INT8U  OS_StrLen (INT8U *psrc)
                    3945   ; {
                    3946   _OS_StrLen:
00001762  4E56 0000 3947          link      A6,#0
00001766  2F02      3948          move.l    D2,-(A7)
                    3949   ; INT8U  len;
                    3950   ; #if OS_ARG_CHK_EN > 0u
                    3951   ; if (psrc == (INT8U *)0) {
                    3952   ; return (0u);
                    3953   ; }
                    3954   ; #endif
                    3955   ; len = 0u;
00001768  4202      3956          clr.b     D2
                    3957   ; while (*psrc != OS_ASCII_NUL) {
                    3958   OS_StrLen_1:
0000176A  206E 0008 3959          move.l    8(A6),A0
0000176E  1010      3960          move.b    (A0),D0
00001770  6708      3961          beq.s     OS_StrLen_3
                    3962   ; psrc++;
00001772  52AE 0008 3963          addq.l    #1,8(A6)
                    3964   ; len++;
00001776  5202      3965          addq.b    #1,D2
00001778  60F0      3966          bra       OS_StrLen_1
                    3967   OS_StrLen_3:
                    3968   ; }
                    3969   ; return (len);
0000177A  1002      3970          move.b    D2,D0
0000177C  241F      3971          move.l    (A7)+,D2
0000177E  4E5E      3972          unlk      A6
00001780  4E75      3973          rts
                    3974   ; }
                    3975   ; #endif
                    3976   ; /*$PAGE*/
                    3977   ; /*
                    3978   ; *********************************************************************************************************
                    3979   ; *                                              IDLE TASK
                    3980   ; *
                    3981   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    3982   ; *              executes because they are ALL waiting for event(s) to occur.
                    3983   ; *
                    3984   ; * Arguments  : none
                    3985   ; *
                    3986   ; * Returns    : none
                    3987   ; *
                    3988   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    3989   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    3990   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    3991   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    3992   ; *                 interrupts.
                    3993   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    3994   ; *                 power.
                    3995   ; *********************************************************************************************************
                    3996   ; */
                    3997   ; void  OS_TaskIdle (void *p_arg)
                    3998   ; {
                    3999   _OS_TaskIdle:
00001782  4E56 0000 4000          link      A6,#0
                    4001   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4002   ; OS_CPU_SR  cpu_sr = 0u;
                    4003   ; #endif
                    4004   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4005   ; for (;;) {
                    4006   OS_TaskIdle_1:
                    4007   ; OS_ENTER_CRITICAL();
00001786  40E7      4008          dc.w      16615
00001788  007C      4009          dc.w      124
0000178A  0700      4010          dc.w      1792
                    4011   ; OSIdleCtr++;
0000178C  52B9 0800 4012          addq.l    #1,_OSIdleCtr.L
00001790  043C      
                    4013   ; OS_EXIT_CRITICAL();
00001792  46DF      4014          dc.w      18143
                    4015   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001794  4EB8 09AE 4016          jsr       _OSTaskIdleHook
00001798  60EC      4017          bra       OS_TaskIdle_1
                    4018   ; }
                    4019   ; }
                    4020   ; /*$PAGE*/
                    4021   ; /*
                    4022   ; *********************************************************************************************************
                    4023   ; *                                           STATISTICS TASK
                    4024   ; *
                    4025   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    4026   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    4027   ; *              CPU usage is determined by:
                    4028   ; *
                    4029   ; *                                          OSIdleCtr
                    4030   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    4031   ; *                                         OSIdleCtrMax
                    4032   ; *
                    4033   ; * Arguments  : parg     this pointer is not used at this time.
                    4034   ; *
                    4035   ; * Returns    : none
                    4036   ; *
                    4037   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    4038   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    4039   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    4040   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    4041   ; *                 maximum value for the idle counter.
                    4042   ; *********************************************************************************************************
                    4043   ; */
                    4044   ; #if OS_TASK_STAT_EN > 0u
                    4045   ; void  OS_TaskStat (void *p_arg)
                    4046   ; {
                    4047   _OS_TaskStat:
0000179A  4E56 0000 4048          link      A6,#0
0000179E  2F0A      4049          move.l    A2,-(A7)
000017A0  45F9 0800 4050          lea       _OSIdleCtrMax.L,A2
000017A4  031C      
                    4051   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4052   ; OS_CPU_SR  cpu_sr = 0u;
                    4053   ; #endif
                    4054   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4055   ; while (OSStatRdy == OS_FALSE) {
                    4056   OS_TaskStat_1:
000017A6  1039 0800 4057          move.b    _OSStatRdy.L,D0
000017AA  0324      
000017AC  660E      4058          bne.s     OS_TaskStat_3
                    4059   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000017AE  4878 0014 4060          pea       20
000017B2  4EB9 0000 4061          jsr       _OSTimeDly
000017B6  4EB4      
000017B8  584F      4062          addq.w    #4,A7
000017BA  60EA      4063          bra       OS_TaskStat_1
                    4064   OS_TaskStat_3:
                    4065   ; }
                    4066   ; OSIdleCtrMax /= 100uL;
000017BC  2F12      4067          move.l    (A2),-(A7)
000017BE  4878 0064 4068          pea       100
000017C2  4EB9 0000 4069          jsr       ULDIV
000017C6  6B3C      
000017C8  2497      4070          move.l    (A7),(A2)
000017CA  504F      4071          addq.w    #8,A7
                    4072   ; if (OSIdleCtrMax == 0uL) {
000017CC  2012      4073          move.l    (A2),D0
000017CE  6618      4074          bne.s     OS_TaskStat_4
                    4075   ; OSCPUUsage = 0u;
000017D0  4239 0800 4076          clr.b     _OSCPUUsage.L
000017D4  031A      
                    4077   ; #if OS_TASK_SUSPEND_EN > 0u
                    4078   ; (void)OSTaskSuspend(OS_PRIO_SELF);
000017D6  4878 00FF 4079          pea       255
000017DA  4EB9 0000 4080          jsr       _OSTaskSuspend
000017DE  4C2C      
000017E0  584F      4081          addq.w    #4,A7
000017E2  C0BC 0000 4082          and.l     #255,D0
000017E6  00FF      
                    4083   OS_TaskStat_4:
                    4084   ; #else
                    4085   ; for (;;) {
                    4086   ; OSTimeDly(OS_TICKS_PER_SEC);
                    4087   ; }
                    4088   ; #endif
                    4089   ; }
                    4090   ; OS_ENTER_CRITICAL();
000017E8  40E7      4091          dc.w      16615
000017EA  007C      4092          dc.w      124
000017EC  0700      4093          dc.w      1792
                    4094   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
000017EE  2F12      4095          move.l    (A2),-(A7)
000017F0  4878 0064 4096          pea       100
000017F4  4EB9 0000 4097          jsr       ULMUL
000017F8  6A9C      
000017FA  2017      4098          move.l    (A7),D0
000017FC  504F      4099          addq.w    #8,A7
000017FE  23C0 0800 4100          move.l    D0,_OSIdleCtr.L
00001802  043C      
                    4101   ; OS_EXIT_CRITICAL();
00001804  46DF      4102          dc.w      18143
                    4103   ; for (;;) {
                    4104   OS_TaskStat_6:
                    4105   ; OS_ENTER_CRITICAL();
00001806  40E7      4106          dc.w      16615
00001808  007C      4107          dc.w      124
0000180A  0700      4108          dc.w      1792
                    4109   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0000180C  23F9 0800 4110          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
00001810  043C 0800 
00001814  0320      
                    4111   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001816  42B9 0800 4112          clr.l     _OSIdleCtr.L
0000181A  043C      
                    4113   ; OS_EXIT_CRITICAL();
0000181C  46DF      4114          dc.w      18143
                    4115   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
0000181E  7064      4116          moveq     #100,D0
00001820  2F39 0800 4117          move.l    _OSIdleCtrRun.L,-(A7)
00001824  0320      
00001826  2F12      4118          move.l    (A2),-(A7)
00001828  4EB9 0000 4119          jsr       ULDIV
0000182C  6B3C      
0000182E  2217      4120          move.l    (A7),D1
00001830  504F      4121          addq.w    #8,A7
00001832  9081      4122          sub.l     D1,D0
00001834  13C0 0800 4123          move.b    D0,_OSCPUUsage.L
00001838  031A      
                    4124   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
0000183A  4EB8 09B8 4125          jsr       _OSTaskStatHook
                    4126   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4127   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
0000183E  4EB9 0000 4128          jsr       _OS_TaskStatStkChk
00001842  1852      
                    4129   ; #endif
                    4130   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00001844  4878 000A 4131          pea       10
00001848  4EB9 0000 4132          jsr       _OSTimeDly
0000184C  4EB4      
0000184E  584F      4133          addq.w    #4,A7
00001850  60B4      4134          bra       OS_TaskStat_6
                    4135   ; }
                    4136   ; }
                    4137   ; #endif
                    4138   ; /*$PAGE*/
                    4139   ; /*
                    4140   ; *********************************************************************************************************
                    4141   ; *                                        CHECK ALL TASK STACKS
                    4142   ; *
                    4143   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    4144   ; *
                    4145   ; * Arguments  : none
                    4146   ; *
                    4147   ; * Returns    : none
                    4148   ; *********************************************************************************************************
                    4149   ; */
                    4150   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4151   ; void  OS_TaskStatStkChk (void)
                    4152   ; {
                    4153   _OS_TaskStatStkChk:
00001852  4E56 FFF4 4154          link      A6,#-12
00001856  48E7 3000 4155          movem.l   D2/D3,-(A7)
                    4156   ; OS_TCB      *ptcb;
                    4157   ; OS_STK_DATA  stk_data;
                    4158   ; INT8U        err;
                    4159   ; INT8U        prio;
                    4160   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
0000185A  4203      4161          clr.b     D3
                    4162   OS_TaskStatStkChk_1:
0000185C  0C03 003F 4163          cmp.b     #63,D3
00001860  6200 0068 4164          bhi       OS_TaskStatStkChk_3
                    4165   ; err = OSTaskStkChk(prio, &stk_data);
00001864  486E FFF6 4166          pea       -10(A6)
00001868  C6BC 0000 4167          and.l     #255,D3
0000186C  00FF      
0000186E  2F03      4168          move.l    D3,-(A7)
00001870  4EB9 0000 4169          jsr       _OSTaskStkChk
00001874  4B74      
00001876  504F      4170          addq.w    #8,A7
00001878  1D40 FFFF 4171          move.b    D0,-1(A6)
                    4172   ; if (err == OS_ERR_NONE) {
0000187C  102E FFFF 4173          move.b    -1(A6),D0
00001880  6600 0044 4174          bne       OS_TaskStatStkChk_8
                    4175   ; ptcb = OSTCBPrioTbl[prio];
00001884  C6BC 0000 4176          and.l     #255,D3
00001888  00FF      
0000188A  2003      4177          move.l    D3,D0
0000188C  E588      4178          lsl.l     #2,D0
0000188E  41F9 0800 4179          lea       _OSTCBPrioTbl.L,A0
00001892  0550      
00001894  2430 0800 4180          move.l    0(A0,D0.L),D2
                    4181   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
00001898  4A82      4182          tst.l     D2
0000189A  672A      4183          beq.s     OS_TaskStatStkChk_8
                    4184   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
0000189C  0C82 0000 4185          cmp.l     #1,D2
000018A0  0001      
000018A2  6722      4186          beq.s     OS_TaskStatStkChk_8
                    4187   ; #if OS_TASK_PROFILE_EN > 0u
                    4188   ; #if OS_STK_GROWTH == 1u
                    4189   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000018A4  2042      4190          move.l    D2,A0
000018A6  2028 0008 4191          move.l    8(A0),D0
000018AA  2042      4192          move.l    D2,A0
000018AC  2228 000C 4193          move.l    12(A0),D1
000018B0  E389      4194          lsl.l     #1,D1
000018B2  D081      4195          add.l     D1,D0
000018B4  2042      4196          move.l    D2,A0
000018B6  2140 0046 4197          move.l    D0,70(A0)
                    4198   ; #else
                    4199   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4200   ; #endif
                    4201   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000018BA  41EE FFF6 4202          lea       -10(A6),A0
000018BE  2242      4203          move.l    D2,A1
000018C0  2368 0004 4204          move.l    4(A0),74(A1)
000018C4  004A      
                    4205   OS_TaskStatStkChk_8:
000018C6  5203      4206          addq.b    #1,D3
000018C8  6092      4207          bra       OS_TaskStatStkChk_1
                    4208   OS_TaskStatStkChk_3:
000018CA  4CDF 000C 4209          movem.l   (A7)+,D2/D3
000018CE  4E5E      4210          unlk      A6
000018D0  4E75      4211          rts
                    4212   ; #endif
                    4213   ; }
                    4214   ; }
                    4215   ; }
                    4216   ; }
                    4217   ; }
                    4218   ; #endif
                    4219   ; /*$PAGE*/
                    4220   ; /*
                    4221   ; *********************************************************************************************************
                    4222   ; *                                           INITIALIZE TCB
                    4223   ; *
                    4224   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4225   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4226   ; *
                    4227   ; * Arguments  : prio          is the priority of the task being created
                    4228   ; *
                    4229   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4230   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4231   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4232   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4233   ; *                            specific.
                    4234   ; *
                    4235   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4236   ; *                            'OSTaskCreate()'.
                    4237   ; *
                    4238   ; *              id            is the task's ID (0..65535)
                    4239   ; *
                    4240   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4241   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4242   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4243   ; *                            units are established by the #define constant OS_STK which is CPU
                    4244   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4245   ; *
                    4246   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4247   ; *                            control block.  This allows you to store the contents of floating-point
                    4248   ; *                            registers, MMU registers or anything else you could find useful during a
                    4249   ; *                            context switch.  You can even assign a name to each task and store this name
                    4250   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4251   ; *
                    4252   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4253   ; *                            0 if called from 'OSTaskCreate()'.
                    4254   ; *
                    4255   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4256   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4257   ; *                                  be created.
                    4258   ; *
                    4259   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4260   ; *********************************************************************************************************
                    4261   ; */
                    4262   ; INT8U  OS_TCBInit (INT8U    prio,
                    4263   ; OS_STK  *ptos,
                    4264   ; OS_STK  *pbos,
                    4265   ; INT16U   id,
                    4266   ; INT32U   stk_size,
                    4267   ; void    *pext,
                    4268   ; INT16U   opt)
                    4269   ; {
                    4270   _OS_TCBInit:
000018D2  4E56 0000 4271          link      A6,#0
000018D6  48E7 3820 4272          movem.l   D2/D3/D4/A2,-(A7)
000018DA  45F9 0800 4273          lea       _OSTCBList.L,A2
000018DE  054C      
000018E0  182E 000B 4274          move.b    11(A6),D4
000018E4  C8BC 0000 4275          and.l     #255,D4
000018E8  00FF      
                    4276   ; OS_TCB    *ptcb;
                    4277   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4278   ; OS_CPU_SR  cpu_sr = 0u;
                    4279   ; #endif
                    4280   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4281   ; INT8U      i;
                    4282   ; #endif
                    4283   ; OS_ENTER_CRITICAL();
000018EA  40E7      4284          dc.w      16615
000018EC  007C      4285          dc.w      124
000018EE  0700      4286          dc.w      1792
                    4287   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000018F0  2439 0800 4288          move.l    _OSTCBFreeList.L,D2
000018F4  0544      
                    4289   ; if (ptcb != (OS_TCB *)0) {
000018F6  4A82      4290          tst.l     D2
000018F8  6700 017A 4291          beq       OS_TCBInit_1
                    4292   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000018FC  2042      4293          move.l    D2,A0
000018FE  23E8 0014 4294          move.l    20(A0),_OSTCBFreeList.L
00001902  0800 0544 
                    4295   ; OS_EXIT_CRITICAL();
00001906  46DF      4296          dc.w      18143
                    4297   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00001908  2042      4298          move.l    D2,A0
0000190A  20AE 000C 4299          move.l    12(A6),(A0)
                    4300   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
0000190E  2042      4301          move.l    D2,A0
00001910  1144 0034 4302          move.b    D4,52(A0)
                    4303   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001914  2042      4304          move.l    D2,A0
00001916  4228 0032 4305          clr.b     50(A0)
                    4306   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
0000191A  2042      4307          move.l    D2,A0
0000191C  4228 0033 4308          clr.b     51(A0)
                    4309   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001920  2042      4310          move.l    D2,A0
00001922  42A8 002E 4311          clr.l     46(A0)
                    4312   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4313   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001926  2042      4314          move.l    D2,A0
00001928  216E 001C 4315          move.l    28(A6),4(A0)
0000192C  0004      
                    4316   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
0000192E  2042      4317          move.l    D2,A0
00001930  216E 0018 4318          move.l    24(A6),12(A0)
00001934  000C      
                    4319   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001936  2042      4320          move.l    D2,A0
00001938  216E 0010 4321          move.l    16(A6),8(A0)
0000193C  0008      
                    4322   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
0000193E  2042      4323          move.l    D2,A0
00001940  316E 0022 4324          move.w    34(A6),16(A0)
00001944  0010      
                    4325   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001946  2042      4326          move.l    D2,A0
00001948  316E 0016 4327          move.w    22(A6),18(A0)
0000194C  0012      
                    4328   ; #else
                    4329   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4330   ; stk_size                 = stk_size;
                    4331   ; pbos                     = pbos;
                    4332   ; opt                      = opt;
                    4333   ; id                       = id;
                    4334   ; #endif
                    4335   ; #if OS_TASK_DEL_EN > 0u
                    4336   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
0000194E  2042      4337          move.l    D2,A0
00001950  4228 0039 4338          clr.b     57(A0)
                    4339   ; #endif
                    4340   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4341   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001954  1004      4342          move.b    D4,D0
00001956  E608      4343          lsr.b     #3,D0
00001958  2042      4344          move.l    D2,A0
0000195A  1140 0036 4345          move.b    D0,54(A0)
                    4346   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
0000195E  1004      4347          move.b    D4,D0
00001960  C03C 0007 4348          and.b     #7,D0
00001964  2042      4349          move.l    D2,A0
00001966  1140 0035 4350          move.b    D0,53(A0)
                    4351   ; #else                                                             /* Pre-compute X, Y                  */
                    4352   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4353   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4354   ; #endif
                    4355   ; /* Pre-compute BitX and BitY         */
                    4356   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000196A  7001      4357          moveq     #1,D0
0000196C  2042      4358          move.l    D2,A0
0000196E  1228 0036 4359          move.b    54(A0),D1
00001972  C2BC 0000 4360          and.l     #255,D1
00001976  00FF      
00001978  E3A8      4361          lsl.l     D1,D0
0000197A  2042      4362          move.l    D2,A0
0000197C  1140 0038 4363          move.b    D0,56(A0)
                    4364   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00001980  7001      4365          moveq     #1,D0
00001982  2042      4366          move.l    D2,A0
00001984  1228 0035 4367          move.b    53(A0),D1
00001988  C2BC 0000 4368          and.l     #255,D1
0000198C  00FF      
0000198E  E3A8      4369          lsl.l     D1,D0
00001990  2042      4370          move.l    D2,A0
00001992  1140 0037 4371          move.b    D0,55(A0)
                    4372   ; #if (OS_EVENT_EN)
                    4373   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
00001996  2042      4374          move.l    D2,A0
00001998  42A8 001C 4375          clr.l     28(A0)
                    4376   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4377   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
0000199C  2042      4378          move.l    D2,A0
0000199E  42A8 0020 4379          clr.l     32(A0)
                    4380   ; #endif
                    4381   ; #endif
                    4382   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4383   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000019A2  2042      4384          move.l    D2,A0
000019A4  42A8 0028 4385          clr.l     40(A0)
                    4386   ; #endif
                    4387   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4388   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000019A8  2042      4389          move.l    D2,A0
000019AA  42A8 0024 4390          clr.l     36(A0)
                    4391   ; #endif
                    4392   ; #if OS_TASK_PROFILE_EN > 0u
                    4393   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000019AE  2042      4394          move.l    D2,A0
000019B0  42A8 003A 4395          clr.l     58(A0)
                    4396   ; ptcb->OSTCBCyclesStart = 0uL;
000019B4  2042      4397          move.l    D2,A0
000019B6  42A8 0042 4398          clr.l     66(A0)
                    4399   ; ptcb->OSTCBCyclesTot   = 0uL;
000019BA  2042      4400          move.l    D2,A0
000019BC  42A8 003E 4401          clr.l     62(A0)
                    4402   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
000019C0  2042      4403          move.l    D2,A0
000019C2  42A8 0046 4404          clr.l     70(A0)
                    4405   ; ptcb->OSTCBStkUsed     = 0uL;
000019C6  2042      4406          move.l    D2,A0
000019C8  42A8 004A 4407          clr.l     74(A0)
                    4408   ; #endif
                    4409   ; #if OS_TASK_NAME_EN > 0u
                    4410   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000019CC  41F9 0000 4411          lea       @ucos_ii_1.L,A0
000019D0  763A      
000019D2  2242      4412          move.l    D2,A1
000019D4  2348 004E 4413          move.l    A0,78(A1)
                    4414   ; #endif
                    4415   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4416   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
000019D8  4203      4417          clr.b     D3
                    4418   OS_TCBInit_3:
000019DA  0C03 0001 4419          cmp.b     #1,D3
000019DE  6416      4420          bhs.s     OS_TCBInit_5
                    4421   ; ptcb->OSTCBRegTbl[i] = 0u;
000019E0  2042      4422          move.l    D2,A0
000019E2  C6BC 0000 4423          and.l     #255,D3
000019E6  00FF      
000019E8  2003      4424          move.l    D3,D0
000019EA  E588      4425          lsl.l     #2,D0
000019EC  D1C0      4426          add.l     D0,A0
000019EE  42A8 0052 4427          clr.l     82(A0)
000019F2  5203      4428          addq.b    #1,D3
000019F4  60E4      4429          bra       OS_TCBInit_3
                    4430   OS_TCBInit_5:
                    4431   ; }
                    4432   ; #endif
                    4433   ; OSTCBInitHook(ptcb);
000019F6  2F02      4434          move.l    D2,-(A7)
000019F8  4EB8 09E6 4435          jsr       _OSTCBInitHook
000019FC  584F      4436          addq.w    #4,A7
                    4437   ; OS_ENTER_CRITICAL();
000019FE  40E7      4438          dc.w      16615
00001A00  007C      4439          dc.w      124
00001A02  0700      4440          dc.w      1792
                    4441   ; OSTCBPrioTbl[prio] = ptcb;
00001A04  C8BC 0000 4442          and.l     #255,D4
00001A08  00FF      
00001A0A  2004      4443          move.l    D4,D0
00001A0C  E588      4444          lsl.l     #2,D0
00001A0E  41F9 0800 4445          lea       _OSTCBPrioTbl.L,A0
00001A12  0550      
00001A14  2182 0800 4446          move.l    D2,0(A0,D0.L)
                    4447   ; OS_EXIT_CRITICAL();
00001A18  46DF      4448          dc.w      18143
                    4449   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00001A1A  2F02      4450          move.l    D2,-(A7)
00001A1C  4EB8 099C 4451          jsr       _OSTaskCreateHook
00001A20  584F      4452          addq.w    #4,A7
                    4453   ; OS_ENTER_CRITICAL();
00001A22  40E7      4454          dc.w      16615
00001A24  007C      4455          dc.w      124
00001A26  0700      4456          dc.w      1792
                    4457   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00001A28  2042      4458          move.l    D2,A0
00001A2A  2152 0014 4459          move.l    (A2),20(A0)
                    4460   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
00001A2E  2042      4461          move.l    D2,A0
00001A30  42A8 0018 4462          clr.l     24(A0)
                    4463   ; if (OSTCBList != (OS_TCB *)0) {
00001A34  2012      4464          move.l    (A2),D0
00001A36  6706      4465          beq.s     OS_TCBInit_6
                    4466   ; OSTCBList->OSTCBPrev = ptcb;
00001A38  2052      4467          move.l    (A2),A0
00001A3A  2142 0018 4468          move.l    D2,24(A0)
                    4469   OS_TCBInit_6:
                    4470   ; }
                    4471   ; OSTCBList               = ptcb;
00001A3E  2482      4472          move.l    D2,(A2)
                    4473   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001A40  2042      4474          move.l    D2,A0
00001A42  1028 0038 4475          move.b    56(A0),D0
00001A46  8139 0800 4476          or.b      D0,_OSRdyGrp.L
00001A4A  042E      
                    4477   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00001A4C  2042      4478          move.l    D2,A0
00001A4E  1028 0036 4479          move.b    54(A0),D0
00001A52  C0BC 0000 4480          and.l     #255,D0
00001A56  00FF      
00001A58  41F9 0800 4481          lea       _OSRdyTbl.L,A0
00001A5C  0430      
00001A5E  2242      4482          move.l    D2,A1
00001A60  1229 0037 4483          move.b    55(A1),D1
00001A64  8330 0800 4484          or.b      D1,0(A0,D0.L)
                    4485   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
00001A68  5239 0800 4486          addq.b    #1,_OSTaskCtr.L
00001A6C  043A      
                    4487   ; OS_EXIT_CRITICAL();
00001A6E  46DF      4488          dc.w      18143
                    4489   ; return (OS_ERR_NONE);
00001A70  4200      4490          clr.b     D0
00001A72  6004      4491          bra.s     OS_TCBInit_8
                    4492   OS_TCBInit_1:
                    4493   ; }
                    4494   ; OS_EXIT_CRITICAL();
00001A74  46DF      4495          dc.w      18143
                    4496   ; return (OS_ERR_TASK_NO_MORE_TCB);
00001A76  7042      4497          moveq     #66,D0
                    4498   OS_TCBInit_8:
00001A78  4CDF 041C 4499          movem.l   (A7)+,D2/D3/D4/A2
00001A7C  4E5E      4500          unlk      A6
00001A7E  4E75      4501          rts
                    4502   ; /*
                    4503   ; *********************************************************************************************************
                    4504   ; *                                                uC/OS-II
                    4505   ; *                                          The Real-Time Kernel
                    4506   ; *                                         EVENT FLAG  MANAGEMENT
                    4507   ; *
                    4508   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4509   ; *                                           All Rights Reserved
                    4510   ; *
                    4511   ; * File    : OS_FLAG.C
                    4512   ; * By      : Jean J. Labrosse
                    4513   ; * Version : V2.92.07
                    4514   ; *
                    4515   ; * LICENSING TERMS:
                    4516   ; * ---------------
                    4517   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4518   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4519   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4520   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4521   ; * licensing fee.
                    4522   ; *********************************************************************************************************
                    4523   ; */
                    4524   ; #define  MICRIUM_SOURCE
                    4525   ; #ifndef  OS_MASTER_FILE
                    4526   ; #include <ucos_ii.h>
                    4527   ; #endif
                    4528   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4529   ; /*
                    4530   ; *********************************************************************************************************
                    4531   ; *                                          LOCAL PROTOTYPES
                    4532   ; *********************************************************************************************************
                    4533   ; */
                    4534   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4535   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4536   ; /*$PAGE*/
                    4537   ; /*
                    4538   ; *********************************************************************************************************
                    4539   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4540   ; *
                    4541   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4542   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4543   ; *              bits to be set/cleared.
                    4544   ; *
                    4545   ; *              This call does not block if the desired flags are not present.
                    4546   ; *
                    4547   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4548   ; *
                    4549   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4550   ; *                            The bits you want are specified by setting the corresponding bits in
                    4551   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4552   ; *                            'flags' would contain 0x03.
                    4553   ; *
                    4554   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4555   ; *                            to be set/cleared.
                    4556   ; *                            You can specify the following argument:
                    4557   ; *
                    4558   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4559   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4560   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4561   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4562   ; *
                    4563   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4564   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4565   ; *                                  the flags that are present, set 'wait_type' to:
                    4566   ; *
                    4567   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4568   ; *
                    4569   ; *              perr          is a pointer to an error code and can be:
                    4570   ; *                            OS_ERR_NONE               No error
                    4571   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4572   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4573   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4574   ; *                                                      group handle.
                    4575   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4576   ; *                                                      available.
                    4577   ; *
                    4578   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4579   ; *              occurred.
                    4580   ; *
                    4581   ; * Called from: Task or ISR
                    4582   ; *
                    4583   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4584   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4585   ; *                 event flags.
                    4586   ; *********************************************************************************************************
                    4587   ; */
                    4588   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4589   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4590   ; OS_FLAGS      flags,
                    4591   ; INT8U         wait_type,
                    4592   ; INT8U        *perr)
                    4593   ; {
                    4594   _OSFlagAccept:
00001A80  4E56 FFFC 4595          link      A6,#-4
00001A84  48E7 3F00 4596          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
00001A88  262E 0008 4597          move.l    8(A6),D3
00001A8C  282E 0014 4598          move.l    20(A6),D4
00001A90  3A2E 000E 4599          move.w    14(A6),D5
00001A94  CABC 0000 4600          and.l     #65535,D5
00001A98  FFFF      
00001A9A  1E2E 0013 4601          move.b    19(A6),D7
00001A9E  CEBC 0000 4602          and.l     #255,D7
00001AA2  00FF      
                    4603   ; OS_FLAGS      flags_rdy;
                    4604   ; INT8U         result;
                    4605   ; BOOLEAN       consume;
                    4606   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4607   ; OS_CPU_SR     cpu_sr = 0u;
                    4608   ; #endif
                    4609   ; #ifdef OS_SAFETY_CRITICAL
                    4610   ; if (perr == (INT8U *)0) {
                    4611   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4612   ; return ((OS_FLAGS)0);
                    4613   ; }
                    4614   ; #endif
                    4615   ; #if OS_ARG_CHK_EN > 0u
                    4616   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4617   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4618   ; return ((OS_FLAGS)0);
                    4619   ; }
                    4620   ; #endif
                    4621   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001AA4  2043      4622          move.l    D3,A0
00001AA6  1010      4623          move.b    (A0),D0
00001AA8  0C00 0005 4624          cmp.b     #5,D0
00001AAC  670C      4625          beq.s     OSFlagAccept_1
                    4626   ; *perr = OS_ERR_EVENT_TYPE;
00001AAE  2044      4627          move.l    D4,A0
00001AB0  10BC 0001 4628          move.b    #1,(A0)
                    4629   ; return ((OS_FLAGS)0);
00001AB4  4240      4630          clr.w     D0
00001AB6  6000 0100 4631          bra       OSFlagAccept_3
                    4632   OSFlagAccept_1:
                    4633   ; }
                    4634   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001ABA  1007      4635          move.b    D7,D0
00001ABC  C03C 0080 4636          and.b     #128,D0
00001AC0  1D40 FFFF 4637          move.b    D0,-1(A6)
                    4638   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001AC4  102E FFFF 4639          move.b    -1(A6),D0
00001AC8  6708      4640          beq.s     OSFlagAccept_4
                    4641   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
00001ACA  CE3C 007F 4642          and.b     #127,D7
                    4643   ; consume    = OS_TRUE;
00001ACE  7C01      4644          moveq     #1,D6
00001AD0  6002      4645          bra.s     OSFlagAccept_5
                    4646   OSFlagAccept_4:
                    4647   ; } else {
                    4648   ; consume    = OS_FALSE;
00001AD2  4206      4649          clr.b     D6
                    4650   OSFlagAccept_5:
                    4651   ; }
                    4652   ; /*$PAGE*/
                    4653   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
00001AD4  2044      4654          move.l    D4,A0
00001AD6  4210      4655          clr.b     (A0)
                    4656   ; OS_ENTER_CRITICAL();
00001AD8  40E7      4657          dc.w      16615
00001ADA  007C      4658          dc.w      124
00001ADC  0700      4659          dc.w      1792
                    4660   ; switch (wait_type) {
00001ADE  CEBC 0000 4661          and.l     #255,D7
00001AE2  00FF      
00001AE4  2007      4662          move.l    D7,D0
00001AE6  0C80 0000 4663          cmp.l     #4,D0
00001AEA  0004      
00001AEC  6400 00BE 4664          bhs       OSFlagAccept_6
00001AF0  E380      4665          asl.l     #1,D0
00001AF2  303B 0806 4666          move.w    OSFlagAccept_8(PC,D0.L),D0
00001AF6  4EFB 0002 4667          jmp       OSFlagAccept_8(PC,D0.W)
                    4668   OSFlagAccept_8:
00001AFA  0060      4669          dc.w      OSFlagAccept_11-OSFlagAccept_8
00001AFC  008A      4670          dc.w      OSFlagAccept_12-OSFlagAccept_8
00001AFE  0008      4671          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001B00  0034      4672          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4673   OSFlagAccept_9:
                    4674   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4675   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001B02  2043      4676          move.l    D3,A0
00001B04  3028 0006 4677          move.w    6(A0),D0
00001B08  C045      4678          and.w     D5,D0
00001B0A  3400      4679          move.w    D0,D2
                    4680   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001B0C  B445      4681          cmp.w     D5,D2
00001B0E  6612      4682          bne.s     OSFlagAccept_14
                    4683   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001B10  0C06 0001 4684          cmp.b     #1,D6
00001B14  660A      4685          bne.s     OSFlagAccept_16
                    4686   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001B16  2043      4687          move.l    D3,A0
00001B18  3002      4688          move.w    D2,D0
00001B1A  4640      4689          not.w     D0
00001B1C  C168 0006 4690          and.w     D0,6(A0)
                    4691   OSFlagAccept_16:
00001B20  6006      4692          bra.s     OSFlagAccept_15
                    4693   OSFlagAccept_14:
                    4694   ; }
                    4695   ; } else {
                    4696   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001B22  2044      4697          move.l    D4,A0
00001B24  10BC 0070 4698          move.b    #112,(A0)
                    4699   OSFlagAccept_15:
                    4700   ; }
                    4701   ; OS_EXIT_CRITICAL();
00001B28  46DF      4702          dc.w      18143
                    4703   ; break;
00001B2A  6000 008A 4704          bra       OSFlagAccept_7
                    4705   OSFlagAccept_10:
                    4706   ; case OS_FLAG_WAIT_SET_ANY:
                    4707   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001B2E  2043      4708          move.l    D3,A0
00001B30  3028 0006 4709          move.w    6(A0),D0
00001B34  C045      4710          and.w     D5,D0
00001B36  3400      4711          move.w    D0,D2
                    4712   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001B38  4A42      4713          tst.w     D2
00001B3A  6712      4714          beq.s     OSFlagAccept_18
                    4715   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001B3C  0C06 0001 4716          cmp.b     #1,D6
00001B40  660A      4717          bne.s     OSFlagAccept_20
                    4718   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001B42  2043      4719          move.l    D3,A0
00001B44  3002      4720          move.w    D2,D0
00001B46  4640      4721          not.w     D0
00001B48  C168 0006 4722          and.w     D0,6(A0)
                    4723   OSFlagAccept_20:
00001B4C  6006      4724          bra.s     OSFlagAccept_19
                    4725   OSFlagAccept_18:
                    4726   ; }
                    4727   ; } else {
                    4728   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001B4E  2044      4729          move.l    D4,A0
00001B50  10BC 0070 4730          move.b    #112,(A0)
                    4731   OSFlagAccept_19:
                    4732   ; }
                    4733   ; OS_EXIT_CRITICAL();
00001B54  46DF      4734          dc.w      18143
                    4735   ; break;
00001B56  6000 005E 4736          bra       OSFlagAccept_7
                    4737   OSFlagAccept_11:
                    4738   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4739   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4740   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001B5A  2043      4741          move.l    D3,A0
00001B5C  3028 0006 4742          move.w    6(A0),D0
00001B60  4640      4743          not.w     D0
00001B62  C045      4744          and.w     D5,D0
00001B64  3400      4745          move.w    D0,D2
                    4746   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001B66  B445      4747          cmp.w     D5,D2
00001B68  660E      4748          bne.s     OSFlagAccept_22
                    4749   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001B6A  0C06 0001 4750          cmp.b     #1,D6
00001B6E  6606      4751          bne.s     OSFlagAccept_24
                    4752   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001B70  2043      4753          move.l    D3,A0
00001B72  8568 0006 4754          or.w      D2,6(A0)
                    4755   OSFlagAccept_24:
00001B76  6006      4756          bra.s     OSFlagAccept_23
                    4757   OSFlagAccept_22:
                    4758   ; }
                    4759   ; } else {
                    4760   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001B78  2044      4761          move.l    D4,A0
00001B7A  10BC 0070 4762          move.b    #112,(A0)
                    4763   OSFlagAccept_23:
                    4764   ; }
                    4765   ; OS_EXIT_CRITICAL();
00001B7E  46DF      4766          dc.w      18143
                    4767   ; break;
00001B80  6000 0034 4768          bra       OSFlagAccept_7
                    4769   OSFlagAccept_12:
                    4770   ; case OS_FLAG_WAIT_CLR_ANY:
                    4771   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001B84  2043      4772          move.l    D3,A0
00001B86  3028 0006 4773          move.w    6(A0),D0
00001B8A  4640      4774          not.w     D0
00001B8C  C045      4775          and.w     D5,D0
00001B8E  3400      4776          move.w    D0,D2
                    4777   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001B90  4A42      4778          tst.w     D2
00001B92  670E      4779          beq.s     OSFlagAccept_26
                    4780   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001B94  0C06 0001 4781          cmp.b     #1,D6
00001B98  6606      4782          bne.s     OSFlagAccept_28
                    4783   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001B9A  2043      4784          move.l    D3,A0
00001B9C  8568 0006 4785          or.w      D2,6(A0)
                    4786   OSFlagAccept_28:
00001BA0  6006      4787          bra.s     OSFlagAccept_27
                    4788   OSFlagAccept_26:
                    4789   ; }
                    4790   ; } else {
                    4791   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001BA2  2044      4792          move.l    D4,A0
00001BA4  10BC 0070 4793          move.b    #112,(A0)
                    4794   OSFlagAccept_27:
                    4795   ; }
                    4796   ; OS_EXIT_CRITICAL();
00001BA8  46DF      4797          dc.w      18143
                    4798   ; break;
00001BAA  600A      4799          bra.s     OSFlagAccept_7
                    4800   OSFlagAccept_6:
                    4801   ; #endif
                    4802   ; default:
                    4803   ; OS_EXIT_CRITICAL();
00001BAC  46DF      4804          dc.w      18143
                    4805   ; flags_rdy = (OS_FLAGS)0;
00001BAE  4242      4806          clr.w     D2
                    4807   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
00001BB0  2044      4808          move.l    D4,A0
00001BB2  10BC 006F 4809          move.b    #111,(A0)
                    4810   ; break;
                    4811   OSFlagAccept_7:
                    4812   ; }
                    4813   ; return (flags_rdy);
00001BB6  3002      4814          move.w    D2,D0
                    4815   OSFlagAccept_3:
00001BB8  4CDF 00FC 4816          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
00001BBC  4E5E      4817          unlk      A6
00001BBE  4E75      4818          rts
                    4819   ; }
                    4820   ; #endif
                    4821   ; /*$PAGE*/
                    4822   ; /*
                    4823   ; *********************************************************************************************************
                    4824   ; *                                        CREATE AN EVENT FLAG
                    4825   ; *
                    4826   ; * Description: This function is called to create an event flag group.
                    4827   ; *
                    4828   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    4829   ; *
                    4830   ; *              perr          is a pointer to an error code which will be returned to your application:
                    4831   ; *                               OS_ERR_NONE               if the call was successful.
                    4832   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    4833   ; *                                                         ISR.
                    4834   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    4835   ; *
                    4836   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    4837   ; *
                    4838   ; * Called from: Task ONLY
                    4839   ; *********************************************************************************************************
                    4840   ; */
                    4841   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    4842   ; INT8U    *perr)
                    4843   ; {
                    4844   _OSFlagCreate:
00001BC0  4E56 0000 4845          link      A6,#0
00001BC4  48E7 3020 4846          movem.l   D2/D3/A2,-(A7)
00001BC8  45F9 0800 4847          lea       _OSFlagFreeList.L,A2
00001BCC  0316      
00001BCE  262E 000C 4848          move.l    12(A6),D3
                    4849   ; OS_FLAG_GRP *pgrp;
                    4850   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    4851   ; OS_CPU_SR    cpu_sr = 0u;
                    4852   ; #endif
                    4853   ; #ifdef OS_SAFETY_CRITICAL
                    4854   ; if (perr == (INT8U *)0) {
                    4855   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4856   ; return ((OS_FLAG_GRP *)0);
                    4857   ; }
                    4858   ; #endif
                    4859   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    4860   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    4861   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4862   ; return ((OS_FLAG_GRP *)0);
                    4863   ; }
                    4864   ; #endif
                    4865   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001BD2  1039 0800 4866          move.b    _OSIntNesting.L,D0
00001BD6  0426      
00001BD8  0C00 0000 4867          cmp.b     #0,D0
00001BDC  630C      4868          bls.s     OSFlagCreate_1
                    4869   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
00001BDE  2043      4870          move.l    D3,A0
00001BE0  10BC 0010 4871          move.b    #16,(A0)
                    4872   ; return ((OS_FLAG_GRP *)0);
00001BE4  4280      4873          clr.l     D0
00001BE6  6000 0046 4874          bra       OSFlagCreate_3
                    4875   OSFlagCreate_1:
                    4876   ; }
                    4877   ; OS_ENTER_CRITICAL();
00001BEA  40E7      4878          dc.w      16615
00001BEC  007C      4879          dc.w      124
00001BEE  0700      4880          dc.w      1792
                    4881   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001BF0  2412      4882          move.l    (A2),D2
                    4883   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001BF2  4A82      4884          tst.l     D2
00001BF4  672E      4885          beq.s     OSFlagCreate_4
                    4886   ; /* Adjust free list                                */
                    4887   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001BF6  2052      4888          move.l    (A2),A0
00001BF8  24A8 0002 4889          move.l    2(A0),(A2)
                    4890   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
00001BFC  2042      4891          move.l    D2,A0
00001BFE  10BC 0005 4892          move.b    #5,(A0)
                    4893   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001C02  2042      4894          move.l    D2,A0
00001C04  316E 000A 4895          move.w    10(A6),6(A0)
00001C08  0006      
                    4896   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
00001C0A  2042      4897          move.l    D2,A0
00001C0C  42A8 0002 4898          clr.l     2(A0)
                    4899   ; #if OS_FLAG_NAME_EN > 0u
                    4900   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001C10  41F9 0000 4901          lea       @ucos_ii_1.L,A0
00001C14  763A      
00001C16  2242      4902          move.l    D2,A1
00001C18  2348 0008 4903          move.l    A0,8(A1)
                    4904   ; #endif
                    4905   ; OS_EXIT_CRITICAL();
00001C1C  46DF      4906          dc.w      18143
                    4907   ; *perr                = OS_ERR_NONE;
00001C1E  2043      4908          move.l    D3,A0
00001C20  4210      4909          clr.b     (A0)
00001C22  6008      4910          bra.s     OSFlagCreate_5
                    4911   OSFlagCreate_4:
                    4912   ; } else {
                    4913   ; OS_EXIT_CRITICAL();
00001C24  46DF      4914          dc.w      18143
                    4915   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001C26  2043      4916          move.l    D3,A0
00001C28  10BC 0072 4917          move.b    #114,(A0)
                    4918   OSFlagCreate_5:
                    4919   ; }
                    4920   ; return (pgrp);                                  /* Return pointer to event flag group              */
00001C2C  2002      4921          move.l    D2,D0
                    4922   OSFlagCreate_3:
00001C2E  4CDF 040C 4923          movem.l   (A7)+,D2/D3/A2
00001C32  4E5E      4924          unlk      A6
00001C34  4E75      4925          rts
                    4926   ; }
                    4927   ; /*$PAGE*/
                    4928   ; /*
                    4929   ; *********************************************************************************************************
                    4930   ; *                                     DELETE AN EVENT FLAG GROUP
                    4931   ; *
                    4932   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    4933   ; *              group.
                    4934   ; *
                    4935   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4936   ; *
                    4937   ; *              opt           determines delete options as follows:
                    4938   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    4939   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    4940   ; *                                                    waiting.  In this case, all the tasks pending will be
                    4941   ; *                                                    readied.
                    4942   ; *
                    4943   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    4944   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    4945   ; *                                                      deleted
                    4946   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    4947   ; *                                                      an ISR
                    4948   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    4949   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    4950   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    4951   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    4952   ; *                                                      group.
                    4953   ; *
                    4954   ; * Returns    : pgrp          upon error
                    4955   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    4956   ; *
                    4957   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    4958   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    4959   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    4960   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    4961   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    4962   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    4963   ; *********************************************************************************************************
                    4964   ; */
                    4965   ; #if OS_FLAG_DEL_EN > 0u
                    4966   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    4967   ; INT8U         opt,
                    4968   ; INT8U        *perr)
                    4969   ; {
                    4970   _OSFlagDel:
00001C36  4E56 0000 4971          link      A6,#0
00001C3A  48E7 3E20 4972          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
00001C3E  242E 0008 4973          move.l    8(A6),D2
00001C42  262E 0010 4974          move.l    16(A6),D3
00001C46  45F9 0800 4975          lea       _OSFlagFreeList.L,A2
00001C4A  0316      
                    4976   ; BOOLEAN       tasks_waiting;
                    4977   ; OS_FLAG_NODE *pnode;
                    4978   ; OS_FLAG_GRP  *pgrp_return;
                    4979   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4980   ; OS_CPU_SR     cpu_sr = 0u;
                    4981   ; #endif
                    4982   ; #ifdef OS_SAFETY_CRITICAL
                    4983   ; if (perr == (INT8U *)0) {
                    4984   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4985   ; return ((OS_FLAG_GRP *)0);
                    4986   ; }
                    4987   ; #endif
                    4988   ; #if OS_ARG_CHK_EN > 0u
                    4989   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4990   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4991   ; return (pgrp);
                    4992   ; }
                    4993   ; #endif
                    4994   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001C4C  1039 0800 4995          move.b    _OSIntNesting.L,D0
00001C50  0426      
00001C52  0C00 0000 4996          cmp.b     #0,D0
00001C56  630C      4997          bls.s     OSFlagDel_1
                    4998   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001C58  2043      4999          move.l    D3,A0
00001C5A  10BC 000F 5000          move.b    #15,(A0)
                    5001   ; return (pgrp);
00001C5E  2002      5002          move.l    D2,D0
00001C60  6000 00EC 5003          bra       OSFlagDel_3
                    5004   OSFlagDel_1:
                    5005   ; }
                    5006   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
00001C64  2042      5007          move.l    D2,A0
00001C66  1010      5008          move.b    (A0),D0
00001C68  0C00 0005 5009          cmp.b     #5,D0
00001C6C  670C      5010          beq.s     OSFlagDel_4
                    5011   ; *perr = OS_ERR_EVENT_TYPE;
00001C6E  2043      5012          move.l    D3,A0
00001C70  10BC 0001 5013          move.b    #1,(A0)
                    5014   ; return (pgrp);
00001C74  2002      5015          move.l    D2,D0
00001C76  6000 00D6 5016          bra       OSFlagDel_3
                    5017   OSFlagDel_4:
                    5018   ; }
                    5019   ; OS_ENTER_CRITICAL();
00001C7A  40E7      5020          dc.w      16615
00001C7C  007C      5021          dc.w      124
00001C7E  0700      5022          dc.w      1792
                    5023   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
00001C80  2042      5024          move.l    D2,A0
00001C82  2028 0002 5025          move.l    2(A0),D0
00001C86  6704      5026          beq.s     OSFlagDel_6
                    5027   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00001C88  7C01      5028          moveq     #1,D6
00001C8A  6002      5029          bra.s     OSFlagDel_7
                    5030   OSFlagDel_6:
                    5031   ; } else {
                    5032   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00001C8C  4206      5033          clr.b     D6
                    5034   OSFlagDel_7:
                    5035   ; }
                    5036   ; switch (opt) {
00001C8E  102E 000F 5037          move.b    15(A6),D0
00001C92  C0BC 0000 5038          and.l     #255,D0
00001C96  00FF      
00001C98  0C80 0000 5039          cmp.l     #1,D0
00001C9C  0001      
00001C9E  6700 0048 5040          beq       OSFlagDel_11
00001CA2  6200 009E 5041          bhi       OSFlagDel_8
00001CA6  4A80      5042          tst.l     D0
00001CA8  6704      5043          beq.s     OSFlagDel_10
00001CAA  6000 0096 5044          bra       OSFlagDel_8
                    5045   OSFlagDel_10:
                    5046   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    5047   ; if (tasks_waiting == OS_FALSE) {
00001CAE  4A06      5048          tst.b     D6
00001CB0  6628      5049          bne.s     OSFlagDel_13
                    5050   ; #if OS_FLAG_NAME_EN > 0u
                    5051   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001CB2  41F9 0000 5052          lea       @ucos_ii_1.L,A0
00001CB6  763A      
00001CB8  2242      5053          move.l    D2,A1
00001CBA  2348 0008 5054          move.l    A0,8(A1)
                    5055   ; #endif
                    5056   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001CBE  2042      5057          move.l    D2,A0
00001CC0  4210      5058          clr.b     (A0)
                    5059   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
00001CC2  2042      5060          move.l    D2,A0
00001CC4  2152 0002 5061          move.l    (A2),2(A0)
                    5062   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001CC8  2042      5063          move.l    D2,A0
00001CCA  4268 0006 5064          clr.w     6(A0)
                    5065   ; OSFlagFreeList       = pgrp;
00001CCE  2482      5066          move.l    D2,(A2)
                    5067   ; OS_EXIT_CRITICAL();
00001CD0  46DF      5068          dc.w      18143
                    5069   ; *perr                = OS_ERR_NONE;
00001CD2  2043      5070          move.l    D3,A0
00001CD4  4210      5071          clr.b     (A0)
                    5072   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00001CD6  4285      5073          clr.l     D5
00001CD8  600A      5074          bra.s     OSFlagDel_14
                    5075   OSFlagDel_13:
                    5076   ; } else {
                    5077   ; OS_EXIT_CRITICAL();
00001CDA  46DF      5078          dc.w      18143
                    5079   ; *perr                = OS_ERR_TASK_WAITING;
00001CDC  2043      5080          move.l    D3,A0
00001CDE  10BC 0049 5081          move.b    #73,(A0)
                    5082   ; pgrp_return          = pgrp;
00001CE2  2A02      5083          move.l    D2,D5
                    5084   OSFlagDel_14:
                    5085   ; }
                    5086   ; break;
00001CE4  6000 0066 5087          bra       OSFlagDel_9
                    5088   OSFlagDel_11:
                    5089   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    5090   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001CE8  2042      5091          move.l    D2,A0
00001CEA  2828 0002 5092          move.l    2(A0),D4
                    5093   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    5094   OSFlagDel_15:
00001CEE  4A84      5095          tst.l     D4
00001CF0  671E      5096          beq.s     OSFlagDel_17
                    5097   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
00001CF2  4878 0002 5098          pea       2
00001CF6  42A7      5099          clr.l     -(A7)
00001CF8  2F04      5100          move.l    D4,-(A7)
00001CFA  4EB9 0000 5101          jsr       @ucos_ii_OS_FlagTaskRdy
00001CFE  246C      
00001D00  DEFC 000C 5102          add.w     #12,A7
00001D04  C0BC 0000 5103          and.l     #255,D0
00001D08  00FF      
                    5104   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00001D0A  2044      5105          move.l    D4,A0
00001D0C  2810      5106          move.l    (A0),D4
00001D0E  60DE      5107          bra       OSFlagDel_15
                    5108   OSFlagDel_17:
                    5109   ; }
                    5110   ; #if OS_FLAG_NAME_EN > 0u
                    5111   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001D10  41F9 0000 5112          lea       @ucos_ii_1.L,A0
00001D14  763A      
00001D16  2242      5113          move.l    D2,A1
00001D18  2348 0008 5114          move.l    A0,8(A1)
                    5115   ; #endif
                    5116   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001D1C  2042      5117          move.l    D2,A0
00001D1E  4210      5118          clr.b     (A0)
                    5119   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
00001D20  2042      5120          move.l    D2,A0
00001D22  2152 0002 5121          move.l    (A2),2(A0)
                    5122   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001D26  2042      5123          move.l    D2,A0
00001D28  4268 0006 5124          clr.w     6(A0)
                    5125   ; OSFlagFreeList       = pgrp;
00001D2C  2482      5126          move.l    D2,(A2)
                    5127   ; OS_EXIT_CRITICAL();
00001D2E  46DF      5128          dc.w      18143
                    5129   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00001D30  0C06 0001 5130          cmp.b     #1,D6
00001D34  6604      5131          bne.s     OSFlagDel_18
                    5132   ; OS_Sched();                               /* Find highest priority task ready to run  */
00001D36  4EB8 16B8 5133          jsr       _OS_Sched
                    5134   OSFlagDel_18:
                    5135   ; }
                    5136   ; *perr = OS_ERR_NONE;
00001D3A  2043      5137          move.l    D3,A0
00001D3C  4210      5138          clr.b     (A0)
                    5139   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
00001D3E  4285      5140          clr.l     D5
                    5141   ; break;
00001D40  600A      5142          bra.s     OSFlagDel_9
                    5143   OSFlagDel_8:
                    5144   ; default:
                    5145   ; OS_EXIT_CRITICAL();
00001D42  46DF      5146          dc.w      18143
                    5147   ; *perr                = OS_ERR_INVALID_OPT;
00001D44  2043      5148          move.l    D3,A0
00001D46  10BC 0007 5149          move.b    #7,(A0)
                    5150   ; pgrp_return          = pgrp;
00001D4A  2A02      5151          move.l    D2,D5
                    5152   ; break;
                    5153   OSFlagDel_9:
                    5154   ; }
                    5155   ; return (pgrp_return);
00001D4C  2005      5156          move.l    D5,D0
                    5157   OSFlagDel_3:
00001D4E  4CDF 047C 5158          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001D52  4E5E      5159          unlk      A6
00001D54  4E75      5160          rts
                    5161   ; }
                    5162   ; #endif
                    5163   ; /*$PAGE*/
                    5164   ; /*
                    5165   ; *********************************************************************************************************
                    5166   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5167   ; *
                    5168   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5169   ; *
                    5170   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5171   ; *
                    5172   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5173   ; *                        group.
                    5174   ; *
                    5175   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5176   ; *
                    5177   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5178   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5179   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5180   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5181   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5182   ; *
                    5183   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5184   ; *********************************************************************************************************
                    5185   ; */
                    5186   ; #if OS_FLAG_NAME_EN > 0u
                    5187   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5188   ; INT8U        **pname,
                    5189   ; INT8U         *perr)
                    5190   ; {
                    5191   _OSFlagNameGet:
00001D56  4E56 FFFC 5192          link      A6,#-4
00001D5A  2F02      5193          move.l    D2,-(A7)
00001D5C  242E 0010 5194          move.l    16(A6),D2
                    5195   ; INT8U      len;
                    5196   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5197   ; OS_CPU_SR  cpu_sr = 0u;
                    5198   ; #endif
                    5199   ; #ifdef OS_SAFETY_CRITICAL
                    5200   ; if (perr == (INT8U *)0) {
                    5201   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5202   ; return (0u);
                    5203   ; }
                    5204   ; #endif
                    5205   ; #if OS_ARG_CHK_EN > 0u
                    5206   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5207   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5208   ; return (0u);
                    5209   ; }
                    5210   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5211   ; *perr = OS_ERR_PNAME_NULL;
                    5212   ; return (0u);
                    5213   ; }
                    5214   ; #endif
                    5215   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001D60  1039 0800 5216          move.b    _OSIntNesting.L,D0
00001D64  0426      
00001D66  0C00 0000 5217          cmp.b     #0,D0
00001D6A  630C      5218          bls.s     OSFlagNameGet_1
                    5219   ; *perr = OS_ERR_NAME_GET_ISR;
00001D6C  2042      5220          move.l    D2,A0
00001D6E  10BC 0011 5221          move.b    #17,(A0)
                    5222   ; return (0u);
00001D72  4200      5223          clr.b     D0
00001D74  6000 0046 5224          bra       OSFlagNameGet_3
                    5225   OSFlagNameGet_1:
                    5226   ; }
                    5227   ; OS_ENTER_CRITICAL();
00001D78  40E7      5228          dc.w      16615
00001D7A  007C      5229          dc.w      124
00001D7C  0700      5230          dc.w      1792
                    5231   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001D7E  206E 0008 5232          move.l    8(A6),A0
00001D82  1010      5233          move.b    (A0),D0
00001D84  0C00 0005 5234          cmp.b     #5,D0
00001D88  670C      5235          beq.s     OSFlagNameGet_4
                    5236   ; OS_EXIT_CRITICAL();
00001D8A  46DF      5237          dc.w      18143
                    5238   ; *perr = OS_ERR_EVENT_TYPE;
00001D8C  2042      5239          move.l    D2,A0
00001D8E  10BC 0001 5240          move.b    #1,(A0)
                    5241   ; return (0u);
00001D92  4200      5242          clr.b     D0
00001D94  6026      5243          bra.s     OSFlagNameGet_3
                    5244   OSFlagNameGet_4:
                    5245   ; }
                    5246   ; *pname = pgrp->OSFlagName;
00001D96  206E 0008 5247          move.l    8(A6),A0
00001D9A  226E 000C 5248          move.l    12(A6),A1
00001D9E  22A8 0008 5249          move.l    8(A0),(A1)
                    5250   ; len    = OS_StrLen(*pname);
00001DA2  206E 000C 5251          move.l    12(A6),A0
00001DA6  2F10      5252          move.l    (A0),-(A7)
00001DA8  4EB8 1762 5253          jsr       _OS_StrLen
00001DAC  584F      5254          addq.w    #4,A7
00001DAE  1D40 FFFF 5255          move.b    D0,-1(A6)
                    5256   ; OS_EXIT_CRITICAL();
00001DB2  46DF      5257          dc.w      18143
                    5258   ; *perr  = OS_ERR_NONE;
00001DB4  2042      5259          move.l    D2,A0
00001DB6  4210      5260          clr.b     (A0)
                    5261   ; return (len);
00001DB8  102E FFFF 5262          move.b    -1(A6),D0
                    5263   OSFlagNameGet_3:
00001DBC  241F      5264          move.l    (A7)+,D2
00001DBE  4E5E      5265          unlk      A6
00001DC0  4E75      5266          rts
                    5267   ; }
                    5268   ; #endif
                    5269   ; /*$PAGE*/
                    5270   ; /*
                    5271   ; *********************************************************************************************************
                    5272   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5273   ; *
                    5274   ; * Description: This function assigns a name to an event flag group.
                    5275   ; *
                    5276   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5277   ; *
                    5278   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5279   ; *                        group.
                    5280   ; *
                    5281   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5282   ; *
                    5283   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5284   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5285   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5286   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5287   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5288   ; *
                    5289   ; * Returns    : None
                    5290   ; *********************************************************************************************************
                    5291   ; */
                    5292   ; #if OS_FLAG_NAME_EN > 0u
                    5293   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5294   ; INT8U        *pname,
                    5295   ; INT8U        *perr)
                    5296   ; {
                    5297   _OSFlagNameSet:
00001DC2  4E56 0000 5298          link      A6,#0
00001DC6  2F02      5299          move.l    D2,-(A7)
00001DC8  242E 0010 5300          move.l    16(A6),D2
                    5301   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5302   ; OS_CPU_SR  cpu_sr = 0u;
                    5303   ; #endif
                    5304   ; #ifdef OS_SAFETY_CRITICAL
                    5305   ; if (perr == (INT8U *)0) {
                    5306   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5307   ; return;
                    5308   ; }
                    5309   ; #endif
                    5310   ; #if OS_ARG_CHK_EN > 0u
                    5311   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5312   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5313   ; return;
                    5314   ; }
                    5315   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5316   ; *perr = OS_ERR_PNAME_NULL;
                    5317   ; return;
                    5318   ; }
                    5319   ; #endif
                    5320   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001DCC  1039 0800 5321          move.b    _OSIntNesting.L,D0
00001DD0  0426      
00001DD2  0C00 0000 5322          cmp.b     #0,D0
00001DD6  630A      5323          bls.s     OSFlagNameSet_1
                    5324   ; *perr = OS_ERR_NAME_SET_ISR;
00001DD8  2042      5325          move.l    D2,A0
00001DDA  10BC 0012 5326          move.b    #18,(A0)
                    5327   ; return;
00001DDE  6000 002E 5328          bra       OSFlagNameSet_3
                    5329   OSFlagNameSet_1:
                    5330   ; }
                    5331   ; OS_ENTER_CRITICAL();
00001DE2  40E7      5332          dc.w      16615
00001DE4  007C      5333          dc.w      124
00001DE6  0700      5334          dc.w      1792
                    5335   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001DE8  206E 0008 5336          move.l    8(A6),A0
00001DEC  1010      5337          move.b    (A0),D0
00001DEE  0C00 0005 5338          cmp.b     #5,D0
00001DF2  670A      5339          beq.s     OSFlagNameSet_4
                    5340   ; OS_EXIT_CRITICAL();
00001DF4  46DF      5341          dc.w      18143
                    5342   ; *perr = OS_ERR_EVENT_TYPE;
00001DF6  2042      5343          move.l    D2,A0
00001DF8  10BC 0001 5344          move.b    #1,(A0)
                    5345   ; return;
00001DFC  6010      5346          bra.s     OSFlagNameSet_3
                    5347   OSFlagNameSet_4:
                    5348   ; }
                    5349   ; pgrp->OSFlagName = pname;
00001DFE  206E 0008 5350          move.l    8(A6),A0
00001E02  216E 000C 5351          move.l    12(A6),8(A0)
00001E06  0008      
                    5352   ; OS_EXIT_CRITICAL();
00001E08  46DF      5353          dc.w      18143
                    5354   ; *perr            = OS_ERR_NONE;
00001E0A  2042      5355          move.l    D2,A0
00001E0C  4210      5356          clr.b     (A0)
                    5357   ; return;
                    5358   OSFlagNameSet_3:
00001E0E  241F      5359          move.l    (A7)+,D2
00001E10  4E5E      5360          unlk      A6
00001E12  4E75      5361          rts
                    5362   ; }
                    5363   ; #endif
                    5364   ; /*$PAGE*/
                    5365   ; /*
                    5366   ; *********************************************************************************************************
                    5367   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5368   ; *
                    5369   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5370   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5371   ; *
                    5372   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5373   ; *
                    5374   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5375   ; *                            The bits you want are specified by setting the corresponding bits in
                    5376   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5377   ; *                            'flags' would contain 0x03.
                    5378   ; *
                    5379   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5380   ; *                            You can specify the following argument:
                    5381   ; *
                    5382   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5383   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5384   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5385   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5386   ; *
                    5387   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5388   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5389   ; *                                  the flags that are present, set 'wait_type' to:
                    5390   ; *
                    5391   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5392   ; *
                    5393   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5394   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5395   ; *                            forever at the specified event flag group or, until a message arrives.
                    5396   ; *
                    5397   ; *              perr          is a pointer to an error code and can be:
                    5398   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5399   ; *                                                      'timeout'.
                    5400   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5401   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5402   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5403   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5404   ; *                                                      'timeout'.
                    5405   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5406   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5407   ; *
                    5408   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5409   ; *              occurred.
                    5410   ; *
                    5411   ; * Called from: Task ONLY
                    5412   ; *
                    5413   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5414   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5415   ; *                 event flags.
                    5416   ; *********************************************************************************************************
                    5417   ; */
                    5418   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5419   ; OS_FLAGS      flags,
                    5420   ; INT8U         wait_type,
                    5421   ; INT32U        timeout,
                    5422   ; INT8U        *perr)
                    5423   ; {
                    5424   _OSFlagPend:
00001E14  4E56 FFE8 5425          link      A6,#-24
00001E18  48E7 3F3C 5426          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001E1C  262E 0008 5427          move.l    8(A6),D3
00001E20  282E 0018 5428          move.l    24(A6),D4
00001E24  3A2E 000E 5429          move.w    14(A6),D5
00001E28  CABC 0000 5430          and.l     #65535,D5
00001E2C  FFFF      
00001E2E  45F9 0800 5431          lea       _OSTCBCur.L,A2
00001E32  0540      
00001E34  1C2E 0013 5432          move.b    19(A6),D6
00001E38  CCBC 0000 5433          and.l     #255,D6
00001E3C  00FF      
00001E3E  47EE FFEA 5434          lea       -22(A6),A3
00001E42  286E 0014 5435          move.l    20(A6),A4
00001E46  4BF9 0000 5436          lea       @ucos_ii_OS_FlagBlock.L,A5
00001E4A  230E      
                    5437   ; OS_FLAG_NODE  node;
                    5438   ; OS_FLAGS      flags_rdy;
                    5439   ; INT8U         result;
                    5440   ; INT8U         pend_stat;
                    5441   ; BOOLEAN       consume;
                    5442   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5443   ; OS_CPU_SR     cpu_sr = 0u;
                    5444   ; #endif
                    5445   ; #ifdef OS_SAFETY_CRITICAL
                    5446   ; if (perr == (INT8U *)0) {
                    5447   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5448   ; return ((OS_FLAGS)0);
                    5449   ; }
                    5450   ; #endif
                    5451   ; #if OS_ARG_CHK_EN > 0u
                    5452   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5453   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5454   ; return ((OS_FLAGS)0);
                    5455   ; }
                    5456   ; #endif
                    5457   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001E4C  1039 0800 5458          move.b    _OSIntNesting.L,D0
00001E50  0426      
00001E52  0C00 0000 5459          cmp.b     #0,D0
00001E56  630C      5460          bls.s     OSFlagPend_1
                    5461   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001E58  2044      5462          move.l    D4,A0
00001E5A  10BC 0002 5463          move.b    #2,(A0)
                    5464   ; return ((OS_FLAGS)0);
00001E5E  4240      5465          clr.w     D0
00001E60  6000 028A 5466          bra       OSFlagPend_3
                    5467   OSFlagPend_1:
                    5468   ; }
                    5469   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00001E64  1039 0800 5470          move.b    _OSLockNesting.L,D0
00001E68  0428      
00001E6A  0C00 0000 5471          cmp.b     #0,D0
00001E6E  630C      5472          bls.s     OSFlagPend_4
                    5473   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00001E70  2044      5474          move.l    D4,A0
00001E72  10BC 000D 5475          move.b    #13,(A0)
                    5476   ; return ((OS_FLAGS)0);
00001E76  4240      5477          clr.w     D0
00001E78  6000 0272 5478          bra       OSFlagPend_3
                    5479   OSFlagPend_4:
                    5480   ; }
                    5481   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001E7C  2043      5482          move.l    D3,A0
00001E7E  1010      5483          move.b    (A0),D0
00001E80  0C00 0005 5484          cmp.b     #5,D0
00001E84  670C      5485          beq.s     OSFlagPend_6
                    5486   ; *perr = OS_ERR_EVENT_TYPE;
00001E86  2044      5487          move.l    D4,A0
00001E88  10BC 0001 5488          move.b    #1,(A0)
                    5489   ; return ((OS_FLAGS)0);
00001E8C  4240      5490          clr.w     D0
00001E8E  6000 025C 5491          bra       OSFlagPend_3
                    5492   OSFlagPend_6:
                    5493   ; }
                    5494   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001E92  1006      5495          move.b    D6,D0
00001E94  C03C 0080 5496          and.b     #128,D0
00001E98  1D40 FFFE 5497          move.b    D0,-2(A6)
                    5498   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001E9C  102E FFFE 5499          move.b    -2(A6),D0
00001EA0  670C      5500          beq.s     OSFlagPend_8
                    5501   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
00001EA2  103C 0080 5502          move.b    #128,D0
00001EA6  4600      5503          not.b     D0
00001EA8  CC00      5504          and.b     D0,D6
                    5505   ; consume    = OS_TRUE;
00001EAA  7E01      5506          moveq     #1,D7
00001EAC  6002      5507          bra.s     OSFlagPend_9
                    5508   OSFlagPend_8:
                    5509   ; } else {
                    5510   ; consume    = OS_FALSE;
00001EAE  7E00      5511          moveq     #0,D7
                    5512   OSFlagPend_9:
                    5513   ; }
                    5514   ; /*$PAGE*/
                    5515   ; OS_ENTER_CRITICAL();
00001EB0  40E7      5516          dc.w      16615
00001EB2  007C      5517          dc.w      124
00001EB4  0700      5518          dc.w      1792
                    5519   ; switch (wait_type) {
00001EB6  CCBC 0000 5520          and.l     #255,D6
00001EBA  00FF      
00001EBC  2006      5521          move.l    D6,D0
00001EBE  0C80 0000 5522          cmp.l     #4,D0
00001EC2  0004      
00001EC4  6400 0156 5523          bhs       OSFlagPend_10
00001EC8  E380      5524          asl.l     #1,D0
00001ECA  303B 0806 5525          move.w    OSFlagPend_12(PC,D0.L),D0
00001ECE  4EFB 0002 5526          jmp       OSFlagPend_12(PC,D0.W)
                    5527   OSFlagPend_12:
00001ED2  00AC      5528          dc.w      OSFlagPend_15-OSFlagPend_12
00001ED4  00FC      5529          dc.w      OSFlagPend_16-OSFlagPend_12
00001ED6  0008      5530          dc.w      OSFlagPend_13-OSFlagPend_12
00001ED8  005A      5531          dc.w      OSFlagPend_14-OSFlagPend_12
                    5532   OSFlagPend_13:
                    5533   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5534   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00001EDA  2043      5535          move.l    D3,A0
00001EDC  3028 0006 5536          move.w    6(A0),D0
00001EE0  C045      5537          and.w     D5,D0
00001EE2  3400      5538          move.w    D0,D2
                    5539   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001EE4  B445      5540          cmp.w     D5,D2
00001EE6  6622      5541          bne.s     OSFlagPend_18
                    5542   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001EE8  0C07 0001 5543          cmp.b     #1,D7
00001EEC  660A      5544          bne.s     OSFlagPend_20
                    5545   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
00001EEE  2043      5546          move.l    D3,A0
00001EF0  3002      5547          move.w    D2,D0
00001EF2  4640      5548          not.w     D0
00001EF4  C168 0006 5549          and.w     D0,6(A0)
                    5550   OSFlagPend_20:
                    5551   ; }
                    5552   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001EF8  2052      5553          move.l    (A2),A0
00001EFA  3142 002C 5554          move.w    D2,44(A0)
                    5555   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001EFE  46DF      5556          dc.w      18143
                    5557   ; *perr                   = OS_ERR_NONE;
00001F00  2044      5558          move.l    D4,A0
00001F02  4210      5559          clr.b     (A0)
                    5560   ; return (flags_rdy);
00001F04  3002      5561          move.w    D2,D0
00001F06  6000 01E4 5562          bra       OSFlagPend_3
                    5563   OSFlagPend_18:
                    5564   ; } else {                                      /* Block task until events occur or timeout */
                    5565   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001F0A  2F0C      5566          move.l    A4,-(A7)
00001F0C  CCBC 0000 5567          and.l     #255,D6
00001F10  00FF      
00001F12  2F06      5568          move.l    D6,-(A7)
00001F14  CABC 0000 5569          and.l     #65535,D5
00001F18  FFFF      
00001F1A  2F05      5570          move.l    D5,-(A7)
00001F1C  2F0B      5571          move.l    A3,-(A7)
00001F1E  2F03      5572          move.l    D3,-(A7)
00001F20  4E95      5573          jsr       (A5)
00001F22  DEFC 0014 5574          add.w     #20,A7
                    5575   ; OS_EXIT_CRITICAL();
00001F26  46DF      5576          dc.w      18143
                    5577   ; }
                    5578   ; break;
00001F28  6000 0102 5579          bra       OSFlagPend_11
                    5580   OSFlagPend_14:
                    5581   ; case OS_FLAG_WAIT_SET_ANY:
                    5582   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
00001F2C  2043      5583          move.l    D3,A0
00001F2E  3028 0006 5584          move.w    6(A0),D0
00001F32  C045      5585          and.w     D5,D0
00001F34  3400      5586          move.w    D0,D2
                    5587   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001F36  4A42      5588          tst.w     D2
00001F38  6722      5589          beq.s     OSFlagPend_22
                    5590   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001F3A  0C07 0001 5591          cmp.b     #1,D7
00001F3E  660A      5592          bne.s     OSFlagPend_24
                    5593   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
00001F40  2043      5594          move.l    D3,A0
00001F42  3002      5595          move.w    D2,D0
00001F44  4640      5596          not.w     D0
00001F46  C168 0006 5597          and.w     D0,6(A0)
                    5598   OSFlagPend_24:
                    5599   ; }
                    5600   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001F4A  2052      5601          move.l    (A2),A0
00001F4C  3142 002C 5602          move.w    D2,44(A0)
                    5603   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001F50  46DF      5604          dc.w      18143
                    5605   ; *perr                   = OS_ERR_NONE;
00001F52  2044      5606          move.l    D4,A0
00001F54  4210      5607          clr.b     (A0)
                    5608   ; return (flags_rdy);
00001F56  3002      5609          move.w    D2,D0
00001F58  6000 0192 5610          bra       OSFlagPend_3
                    5611   OSFlagPend_22:
                    5612   ; } else {                                      /* Block task until events occur or timeout */
                    5613   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001F5C  2F0C      5614          move.l    A4,-(A7)
00001F5E  CCBC 0000 5615          and.l     #255,D6
00001F62  00FF      
00001F64  2F06      5616          move.l    D6,-(A7)
00001F66  CABC 0000 5617          and.l     #65535,D5
00001F6A  FFFF      
00001F6C  2F05      5618          move.l    D5,-(A7)
00001F6E  2F0B      5619          move.l    A3,-(A7)
00001F70  2F03      5620          move.l    D3,-(A7)
00001F72  4E95      5621          jsr       (A5)
00001F74  DEFC 0014 5622          add.w     #20,A7
                    5623   ; OS_EXIT_CRITICAL();
00001F78  46DF      5624          dc.w      18143
                    5625   ; }
                    5626   ; break;
00001F7A  6000 00B0 5627          bra       OSFlagPend_11
                    5628   OSFlagPend_15:
                    5629   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5630   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5631   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001F7E  2043      5632          move.l    D3,A0
00001F80  3028 0006 5633          move.w    6(A0),D0
00001F84  4640      5634          not.w     D0
00001F86  C045      5635          and.w     D5,D0
00001F88  3400      5636          move.w    D0,D2
                    5637   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001F8A  B445      5638          cmp.w     D5,D2
00001F8C  661E      5639          bne.s     OSFlagPend_26
                    5640   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001F8E  0C07 0001 5641          cmp.b     #1,D7
00001F92  6606      5642          bne.s     OSFlagPend_28
                    5643   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001F94  2043      5644          move.l    D3,A0
00001F96  8568 0006 5645          or.w      D2,6(A0)
                    5646   OSFlagPend_28:
                    5647   ; }
                    5648   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001F9A  2052      5649          move.l    (A2),A0
00001F9C  3142 002C 5650          move.w    D2,44(A0)
                    5651   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001FA0  46DF      5652          dc.w      18143
                    5653   ; *perr                   = OS_ERR_NONE;
00001FA2  2044      5654          move.l    D4,A0
00001FA4  4210      5655          clr.b     (A0)
                    5656   ; return (flags_rdy);
00001FA6  3002      5657          move.w    D2,D0
00001FA8  6000 0142 5658          bra       OSFlagPend_3
                    5659   OSFlagPend_26:
                    5660   ; } else {                                      /* Block task until events occur or timeout */
                    5661   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001FAC  2F0C      5662          move.l    A4,-(A7)
00001FAE  CCBC 0000 5663          and.l     #255,D6
00001FB2  00FF      
00001FB4  2F06      5664          move.l    D6,-(A7)
00001FB6  CABC 0000 5665          and.l     #65535,D5
00001FBA  FFFF      
00001FBC  2F05      5666          move.l    D5,-(A7)
00001FBE  2F0B      5667          move.l    A3,-(A7)
00001FC0  2F03      5668          move.l    D3,-(A7)
00001FC2  4E95      5669          jsr       (A5)
00001FC4  DEFC 0014 5670          add.w     #20,A7
                    5671   ; OS_EXIT_CRITICAL();
00001FC8  46DF      5672          dc.w      18143
                    5673   ; }
                    5674   ; break;
00001FCA  6000 0060 5675          bra       OSFlagPend_11
                    5676   OSFlagPend_16:
                    5677   ; case OS_FLAG_WAIT_CLR_ANY:
                    5678   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001FCE  2043      5679          move.l    D3,A0
00001FD0  3028 0006 5680          move.w    6(A0),D0
00001FD4  4640      5681          not.w     D0
00001FD6  C045      5682          and.w     D5,D0
00001FD8  3400      5683          move.w    D0,D2
                    5684   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001FDA  4A42      5685          tst.w     D2
00001FDC  671E      5686          beq.s     OSFlagPend_30
                    5687   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001FDE  0C07 0001 5688          cmp.b     #1,D7
00001FE2  6606      5689          bne.s     OSFlagPend_32
                    5690   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001FE4  2043      5691          move.l    D3,A0
00001FE6  8568 0006 5692          or.w      D2,6(A0)
                    5693   OSFlagPend_32:
                    5694   ; }
                    5695   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001FEA  2052      5696          move.l    (A2),A0
00001FEC  3142 002C 5697          move.w    D2,44(A0)
                    5698   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001FF0  46DF      5699          dc.w      18143
                    5700   ; *perr                   = OS_ERR_NONE;
00001FF2  2044      5701          move.l    D4,A0
00001FF4  4210      5702          clr.b     (A0)
                    5703   ; return (flags_rdy);
00001FF6  3002      5704          move.w    D2,D0
00001FF8  6000 00F2 5705          bra       OSFlagPend_3
                    5706   OSFlagPend_30:
                    5707   ; } else {                                      /* Block task until events occur or timeout */
                    5708   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001FFC  2F0C      5709          move.l    A4,-(A7)
00001FFE  CCBC 0000 5710          and.l     #255,D6
00002002  00FF      
00002004  2F06      5711          move.l    D6,-(A7)
00002006  CABC 0000 5712          and.l     #65535,D5
0000200A  FFFF      
0000200C  2F05      5713          move.l    D5,-(A7)
0000200E  2F0B      5714          move.l    A3,-(A7)
00002010  2F03      5715          move.l    D3,-(A7)
00002012  4E95      5716          jsr       (A5)
00002014  DEFC 0014 5717          add.w     #20,A7
                    5718   ; OS_EXIT_CRITICAL();
00002018  46DF      5719          dc.w      18143
                    5720   ; }
                    5721   ; break;
0000201A  6010      5722          bra.s     OSFlagPend_11
                    5723   OSFlagPend_10:
                    5724   ; #endif
                    5725   ; default:
                    5726   ; OS_EXIT_CRITICAL();
0000201C  46DF      5727          dc.w      18143
                    5728   ; flags_rdy = (OS_FLAGS)0;
0000201E  4242      5729          clr.w     D2
                    5730   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
00002020  2044      5731          move.l    D4,A0
00002022  10BC 006F 5732          move.b    #111,(A0)
                    5733   ; return (flags_rdy);
00002026  3002      5734          move.w    D2,D0
00002028  6000 00C2 5735          bra       OSFlagPend_3
                    5736   OSFlagPend_11:
                    5737   ; }
                    5738   ; /*$PAGE*/
                    5739   ; OS_Sched();                                            /* Find next HPT ready to run               */
0000202C  4EB8 16B8 5740          jsr       _OS_Sched
                    5741   ; OS_ENTER_CRITICAL();
00002030  40E7      5742          dc.w      16615
00002032  007C      5743          dc.w      124
00002034  0700      5744          dc.w      1792
                    5745   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
00002036  2052      5746          move.l    (A2),A0
00002038  1028 0033 5747          move.b    51(A0),D0
0000203C  6700 0056 5748          beq       OSFlagPend_34
                    5749   ; pend_stat                = OSTCBCur->OSTCBStatPend;
00002040  2052      5750          move.l    (A2),A0
00002042  1D68 0033 5751          move.b    51(A0),-1(A6)
00002046  FFFF      
                    5752   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00002048  2052      5753          move.l    (A2),A0
0000204A  4228 0033 5754          clr.b     51(A0)
                    5755   ; OS_FlagUnlink(&node);
0000204E  2F0B      5756          move.l    A3,-(A7)
00002050  4EB9 0000 5757          jsr       _OS_FlagUnlink
00002054  24E8      
00002056  584F      5758          addq.w    #4,A7
                    5759   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
00002058  2052      5760          move.l    (A2),A0
0000205A  4228 0032 5761          clr.b     50(A0)
                    5762   ; OS_EXIT_CRITICAL();
0000205E  46DF      5763          dc.w      18143
                    5764   ; flags_rdy                = (OS_FLAGS)0;
00002060  4242      5765          clr.w     D2
                    5766   ; switch (pend_stat) {
00002062  102E FFFF 5767          move.b    -1(A6),D0
00002066  C0BC 0000 5768          and.l     #255,D0
0000206A  00FF      
0000206C  0C80 0000 5769          cmp.l     #2,D0
00002070  0002      
00002072  670C      5770          beq.s     OSFlagPend_38
00002074  6212      5771          bhi.s     OSFlagPend_39
00002076  0C80 0000 5772          cmp.l     #1,D0
0000207A  0001      
0000207C  670A      5773          beq.s     OSFlagPend_39
0000207E  6008      5774          bra.s     OSFlagPend_39
                    5775   OSFlagPend_38:
                    5776   ; case OS_STAT_PEND_ABORT:
                    5777   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
00002080  2044      5778          move.l    D4,A0
00002082  10BC 000E 5779          move.b    #14,(A0)
                    5780   ; break;
00002086  6006      5781          bra.s     OSFlagPend_37
                    5782   OSFlagPend_39:
                    5783   ; case OS_STAT_PEND_TO:
                    5784   ; default:
                    5785   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
00002088  2044      5786          move.l    D4,A0
0000208A  10BC 000A 5787          move.b    #10,(A0)
                    5788   ; break;
                    5789   OSFlagPend_37:
                    5790   ; }
                    5791   ; return (flags_rdy);
0000208E  3002      5792          move.w    D2,D0
00002090  6000 005A 5793          bra       OSFlagPend_3
                    5794   OSFlagPend_34:
                    5795   ; }
                    5796   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
00002094  2052      5797          move.l    (A2),A0
00002096  3428 002C 5798          move.w    44(A0),D2
                    5799   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
0000209A  0C07 0001 5800          cmp.b     #1,D7
0000209E  6600 0044 5801          bne       OSFlagPend_44
                    5802   ; switch (wait_type) {
000020A2  CCBC 0000 5803          and.l     #255,D6
000020A6  00FF      
000020A8  2006      5804          move.l    D6,D0
000020AA  0C80 0000 5805          cmp.l     #4,D0
000020AE  0004      
000020B0  6426      5806          bhs.s     OSFlagPend_43
000020B2  E380      5807          asl.l     #1,D0
000020B4  303B 0806 5808          move.w    OSFlagPend_45(PC,D0.L),D0
000020B8  4EFB 0002 5809          jmp       OSFlagPend_45(PC,D0.W)
                    5810   OSFlagPend_45:
000020BC  0014      5811          dc.w      OSFlagPend_48-OSFlagPend_45
000020BE  0014      5812          dc.w      OSFlagPend_48-OSFlagPend_45
000020C0  0008      5813          dc.w      OSFlagPend_46-OSFlagPend_45
000020C2  0008      5814          dc.w      OSFlagPend_46-OSFlagPend_45
                    5815   OSFlagPend_46:
                    5816   ; case OS_FLAG_WAIT_SET_ALL:
                    5817   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    5818   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
000020C4  2043      5819          move.l    D3,A0
000020C6  3002      5820          move.w    D2,D0
000020C8  4640      5821          not.w     D0
000020CA  C168 0006 5822          and.w     D0,6(A0)
                    5823   ; break;
000020CE  6014      5824          bra.s     OSFlagPend_44
                    5825   OSFlagPend_48:
                    5826   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5827   ; case OS_FLAG_WAIT_CLR_ALL:
                    5828   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    5829   ; pgrp->OSFlagFlags |=  flags_rdy;
000020D0  2043      5830          move.l    D3,A0
000020D2  8568 0006 5831          or.w      D2,6(A0)
                    5832   ; break;
000020D6  600C      5833          bra.s     OSFlagPend_44
                    5834   OSFlagPend_43:
                    5835   ; #endif
                    5836   ; default:
                    5837   ; OS_EXIT_CRITICAL();
000020D8  46DF      5838          dc.w      18143
                    5839   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
000020DA  2044      5840          move.l    D4,A0
000020DC  10BC 006F 5841          move.b    #111,(A0)
                    5842   ; return ((OS_FLAGS)0);
000020E0  4240      5843          clr.w     D0
000020E2  6008      5844          bra.s     OSFlagPend_3
                    5845   OSFlagPend_44:
                    5846   ; }
                    5847   ; }
                    5848   ; OS_EXIT_CRITICAL();
000020E4  46DF      5849          dc.w      18143
                    5850   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
000020E6  2044      5851          move.l    D4,A0
000020E8  4210      5852          clr.b     (A0)
                    5853   ; return (flags_rdy);
000020EA  3002      5854          move.w    D2,D0
                    5855   OSFlagPend_3:
000020EC  4CDF 3CFC 5856          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000020F0  4E5E      5857          unlk      A6
000020F2  4E75      5858          rts
                    5859   ; }
                    5860   ; /*$PAGE*/
                    5861   ; /*
                    5862   ; *********************************************************************************************************
                    5863   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    5864   ; *
                    5865   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    5866   ; *              In other words, this function allows you to tell "Who done it!".
                    5867   ; *
                    5868   ; * Arguments  : None
                    5869   ; *
                    5870   ; * Returns    : The flags that caused the task to be ready.
                    5871   ; *
                    5872   ; * Called from: Task ONLY
                    5873   ; *********************************************************************************************************
                    5874   ; */
                    5875   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    5876   ; {
                    5877   _OSFlagPendGetFlagsRdy:
000020F4  4E56 FFFC 5878          link      A6,#-4
                    5879   ; OS_FLAGS      flags;
                    5880   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5881   ; OS_CPU_SR     cpu_sr = 0u;
                    5882   ; #endif
                    5883   ; OS_ENTER_CRITICAL();
000020F8  40E7      5884          dc.w      16615
000020FA  007C      5885          dc.w      124
000020FC  0700      5886          dc.w      1792
                    5887   ; flags = OSTCBCur->OSTCBFlagsRdy;
000020FE  2079 0800 5888          move.l    _OSTCBCur.L,A0
00002102  0540      
00002104  3D68 002C 5889          move.w    44(A0),-2(A6)
00002108  FFFE      
                    5890   ; OS_EXIT_CRITICAL();
0000210A  46DF      5891          dc.w      18143
                    5892   ; return (flags);
0000210C  302E FFFE 5893          move.w    -2(A6),D0
00002110  4E5E      5894          unlk      A6
00002112  4E75      5895          rts
                    5896   ; }
                    5897   ; /*$PAGE*/
                    5898   ; /*
                    5899   ; *********************************************************************************************************
                    5900   ; *                                       POST EVENT FLAG BIT(S)
                    5901   ; *
                    5902   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    5903   ; *              set or clear are specified by a 'bit mask'.
                    5904   ; *
                    5905   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5906   ; *
                    5907   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    5908   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    5909   ; *                            and 5 you would set 'flags' to:
                    5910   ; *
                    5911   ; *                                0x31     (note, bit 0 is least significant bit)
                    5912   ; *
                    5913   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    5914   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    5915   ; *                            4 and 5 you would specify 'flags' as:
                    5916   ; *
                    5917   ; *                                0x31     (note, bit 0 is least significant bit)
                    5918   ; *
                    5919   ; *              opt           indicates whether the flags will be:
                    5920   ; *                                set     (OS_FLAG_SET) or
                    5921   ; *                                cleared (OS_FLAG_CLR)
                    5922   ; *
                    5923   ; *              perr          is a pointer to an error code and can be:
                    5924   ; *                            OS_ERR_NONE                The call was successfull
                    5925   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    5926   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    5927   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    5928   ; *
                    5929   ; * Returns    : the new value of the event flags bits that are still set.
                    5930   ; *
                    5931   ; * Called From: Task or ISR
                    5932   ; *
                    5933   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    5934   ; *                 flag group.
                    5935   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    5936   ; *                 the event flag group.
                    5937   ; *********************************************************************************************************
                    5938   ; */
                    5939   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    5940   ; OS_FLAGS      flags,
                    5941   ; INT8U         opt,
                    5942   ; INT8U        *perr)
                    5943   ; {
                    5944   _OSFlagPost:
00002114  4E56 FFFC 5945          link      A6,#-4
00002118  48E7 3F20 5946          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000211C  282E 0008 5947          move.l    8(A6),D4
00002120  45F9 0000 5948          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
00002124  246C      
00002126  2E2E 0014 5949          move.l    20(A6),D7
                    5950   ; OS_FLAG_NODE *pnode;
                    5951   ; BOOLEAN       sched;
                    5952   ; OS_FLAGS      flags_cur;
                    5953   ; OS_FLAGS      flags_rdy;
                    5954   ; BOOLEAN       rdy;
                    5955   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    5956   ; OS_CPU_SR     cpu_sr = 0u;
                    5957   ; #endif
                    5958   ; #ifdef OS_SAFETY_CRITICAL
                    5959   ; if (perr == (INT8U *)0) {
                    5960   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5961   ; return ((OS_FLAGS)0);
                    5962   ; }
                    5963   ; #endif
                    5964   ; #if OS_ARG_CHK_EN > 0u
                    5965   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    5966   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5967   ; return ((OS_FLAGS)0);
                    5968   ; }
                    5969   ; #endif
                    5970   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
0000212A  2044      5971          move.l    D4,A0
0000212C  1010      5972          move.b    (A0),D0
0000212E  0C00 0005 5973          cmp.b     #5,D0
00002132  670C      5974          beq.s     OSFlagPost_1
                    5975   ; *perr = OS_ERR_EVENT_TYPE;
00002134  2047      5976          move.l    D7,A0
00002136  10BC 0001 5977          move.b    #1,(A0)
                    5978   ; return ((OS_FLAGS)0);
0000213A  4240      5979          clr.w     D0
0000213C  6000 018C 5980          bra       OSFlagPost_3
                    5981   OSFlagPost_1:
                    5982   ; }
                    5983   ; /*$PAGE*/
                    5984   ; OS_ENTER_CRITICAL();
00002140  40E7      5985          dc.w      16615
00002142  007C      5986          dc.w      124
00002144  0700      5987          dc.w      1792
                    5988   ; switch (opt) {
00002146  102E 0013 5989          move.b    19(A6),D0
0000214A  C0BC 0000 5990          and.l     #255,D0
0000214E  00FF      
00002150  0C80 0000 5991          cmp.l     #1,D0
00002154  0001      
00002156  6716      5992          beq.s     OSFlagPost_7
00002158  6220      5993          bhi.s     OSFlagPost_4
0000215A  4A80      5994          tst.l     D0
0000215C  6702      5995          beq.s     OSFlagPost_6
0000215E  601A      5996          bra.s     OSFlagPost_4
                    5997   OSFlagPost_6:
                    5998   ; case OS_FLAG_CLR:
                    5999   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
00002160  2044      6000          move.l    D4,A0
00002162  302E 000E 6001          move.w    14(A6),D0
00002166  4640      6002          not.w     D0
00002168  C168 0006 6003          and.w     D0,6(A0)
                    6004   ; break;
0000216C  601A      6005          bra.s     OSFlagPost_5
                    6006   OSFlagPost_7:
                    6007   ; case OS_FLAG_SET:
                    6008   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
0000216E  2044      6009          move.l    D4,A0
00002170  302E 000E 6010          move.w    14(A6),D0
00002174  8168 0006 6011          or.w      D0,6(A0)
                    6012   ; break;
00002178  600E      6013          bra.s     OSFlagPost_5
                    6014   OSFlagPost_4:
                    6015   ; default:
                    6016   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
0000217A  46DF      6017          dc.w      18143
                    6018   ; *perr = OS_ERR_FLAG_INVALID_OPT;
0000217C  2047      6019          move.l    D7,A0
0000217E  10BC 0071 6020          move.b    #113,(A0)
                    6021   ; return ((OS_FLAGS)0);
00002182  4240      6022          clr.w     D0
00002184  6000 0144 6023          bra       OSFlagPost_3
                    6024   OSFlagPost_5:
                    6025   ; }
                    6026   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
00002188  4206      6027          clr.b     D6
                    6028   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
0000218A  2044      6029          move.l    D4,A0
0000218C  2428 0002 6030          move.l    2(A0),D2
                    6031   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    6032   OSFlagPost_9:
00002190  4A82      6033          tst.l     D2
00002192  6700 0112 6034          beq       OSFlagPost_11
                    6035   ; switch (pnode->OSFlagNodeWaitType) {
00002196  2042      6036          move.l    D2,A0
00002198  1028 0012 6037          move.b    18(A0),D0
0000219C  C0BC 0000 6038          and.l     #255,D0
000021A0  00FF      
000021A2  0C80 0000 6039          cmp.l     #4,D0
000021A6  0004      
000021A8  6400 00E6 6040          bhs       OSFlagPost_12
000021AC  E380      6041          asl.l     #1,D0
000021AE  303B 0806 6042          move.w    OSFlagPost_14(PC,D0.L),D0
000021B2  4EFB 0002 6043          jmp       OSFlagPost_14(PC,D0.W)
                    6044   OSFlagPost_14:
000021B6  0070      6045          dc.w      OSFlagPost_17-OSFlagPost_14
000021B8  00A8      6046          dc.w      OSFlagPost_18-OSFlagPost_14
000021BA  0008      6047          dc.w      OSFlagPost_15-OSFlagPost_14
000021BC  003E      6048          dc.w      OSFlagPost_16-OSFlagPost_14
                    6049   OSFlagPost_15:
                    6050   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    6051   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
000021BE  2044      6052          move.l    D4,A0
000021C0  3028 0006 6053          move.w    6(A0),D0
000021C4  2042      6054          move.l    D2,A0
000021C6  C068 0010 6055          and.w     16(A0),D0
000021CA  3600      6056          move.w    D0,D3
                    6057   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
000021CC  2042      6058          move.l    D2,A0
000021CE  B668 0010 6059          cmp.w     16(A0),D3
000021D2  661C      6060          bne.s     OSFlagPost_22
                    6061   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000021D4  42A7      6062          clr.l     -(A7)
000021D6  C6BC 0000 6063          and.l     #65535,D3
000021DA  FFFF      
000021DC  2F03      6064          move.l    D3,-(A7)
000021DE  2F02      6065          move.l    D2,-(A7)
000021E0  4E92      6066          jsr       (A2)
000021E2  DEFC 000C 6067          add.w     #12,A7
000021E6  1A00      6068          move.b    D0,D5
                    6069   ; if (rdy == OS_TRUE) {
000021E8  0C05 0001 6070          cmp.b     #1,D5
000021EC  6602      6071          bne.s     OSFlagPost_22
                    6072   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000021EE  7C01      6073          moveq     #1,D6
                    6074   OSFlagPost_22:
                    6075   ; }
                    6076   ; }
                    6077   ; break;
000021F0  6000 00AC 6078          bra       OSFlagPost_13
                    6079   OSFlagPost_16:
                    6080   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    6081   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
000021F4  2044      6082          move.l    D4,A0
000021F6  3028 0006 6083          move.w    6(A0),D0
000021FA  2042      6084          move.l    D2,A0
000021FC  C068 0010 6085          and.w     16(A0),D0
00002200  3600      6086          move.w    D0,D3
                    6087   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00002202  4A43      6088          tst.w     D3
00002204  671C      6089          beq.s     OSFlagPost_26
                    6090   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002206  42A7      6091          clr.l     -(A7)
00002208  C6BC 0000 6092          and.l     #65535,D3
0000220C  FFFF      
0000220E  2F03      6093          move.l    D3,-(A7)
00002210  2F02      6094          move.l    D2,-(A7)
00002212  4E92      6095          jsr       (A2)
00002214  DEFC 000C 6096          add.w     #12,A7
00002218  1A00      6097          move.b    D0,D5
                    6098   ; if (rdy == OS_TRUE) {
0000221A  0C05 0001 6099          cmp.b     #1,D5
0000221E  6602      6100          bne.s     OSFlagPost_26
                    6101   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002220  7C01      6102          moveq     #1,D6
                    6103   OSFlagPost_26:
                    6104   ; }
                    6105   ; }
                    6106   ; break;
00002222  6000 007A 6107          bra       OSFlagPost_13
                    6108   OSFlagPost_17:
                    6109   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6110   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    6111   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00002226  2044      6112          move.l    D4,A0
00002228  3028 0006 6113          move.w    6(A0),D0
0000222C  4640      6114          not.w     D0
0000222E  2042      6115          move.l    D2,A0
00002230  C068 0010 6116          and.w     16(A0),D0
00002234  3600      6117          move.w    D0,D3
                    6118   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00002236  2042      6119          move.l    D2,A0
00002238  B668 0010 6120          cmp.w     16(A0),D3
0000223C  661C      6121          bne.s     OSFlagPost_30
                    6122   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
0000223E  42A7      6123          clr.l     -(A7)
00002240  C6BC 0000 6124          and.l     #65535,D3
00002244  FFFF      
00002246  2F03      6125          move.l    D3,-(A7)
00002248  2F02      6126          move.l    D2,-(A7)
0000224A  4E92      6127          jsr       (A2)
0000224C  DEFC 000C 6128          add.w     #12,A7
00002250  1A00      6129          move.b    D0,D5
                    6130   ; if (rdy == OS_TRUE) {
00002252  0C05 0001 6131          cmp.b     #1,D5
00002256  6602      6132          bne.s     OSFlagPost_30
                    6133   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002258  7C01      6134          moveq     #1,D6
                    6135   OSFlagPost_30:
                    6136   ; }
                    6137   ; }
                    6138   ; break;
0000225A  6000 0042 6139          bra       OSFlagPost_13
                    6140   OSFlagPost_18:
                    6141   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    6142   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
0000225E  2044      6143          move.l    D4,A0
00002260  3028 0006 6144          move.w    6(A0),D0
00002264  4640      6145          not.w     D0
00002266  2042      6146          move.l    D2,A0
00002268  C068 0010 6147          and.w     16(A0),D0
0000226C  3600      6148          move.w    D0,D3
                    6149   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
0000226E  4A43      6150          tst.w     D3
00002270  671C      6151          beq.s     OSFlagPost_34
                    6152   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002272  42A7      6153          clr.l     -(A7)
00002274  C6BC 0000 6154          and.l     #65535,D3
00002278  FFFF      
0000227A  2F03      6155          move.l    D3,-(A7)
0000227C  2F02      6156          move.l    D2,-(A7)
0000227E  4E92      6157          jsr       (A2)
00002280  DEFC 000C 6158          add.w     #12,A7
00002284  1A00      6159          move.b    D0,D5
                    6160   ; if (rdy == OS_TRUE) {
00002286  0C05 0001 6161          cmp.b     #1,D5
0000228A  6602      6162          bne.s     OSFlagPost_34
                    6163   ; sched = OS_TRUE;                     /* When done we will reschedule          */
0000228C  7C01      6164          moveq     #1,D6
                    6165   OSFlagPost_34:
                    6166   ; }
                    6167   ; }
                    6168   ; break;
0000228E  600E      6169          bra.s     OSFlagPost_13
                    6170   OSFlagPost_12:
                    6171   ; #endif
                    6172   ; default:
                    6173   ; OS_EXIT_CRITICAL();
00002290  46DF      6174          dc.w      18143
                    6175   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00002292  2047      6176          move.l    D7,A0
00002294  10BC 006F 6177          move.b    #111,(A0)
                    6178   ; return ((OS_FLAGS)0);
00002298  4240      6179          clr.w     D0
0000229A  6000 002E 6180          bra       OSFlagPost_3
                    6181   OSFlagPost_13:
                    6182   ; }
                    6183   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
0000229E  2042      6184          move.l    D2,A0
000022A0  2410      6185          move.l    (A0),D2
000022A2  6000 FEEC 6186          bra       OSFlagPost_9
                    6187   OSFlagPost_11:
                    6188   ; }
                    6189   ; OS_EXIT_CRITICAL();
000022A6  46DF      6190          dc.w      18143
                    6191   ; if (sched == OS_TRUE) {
000022A8  0C06 0001 6192          cmp.b     #1,D6
000022AC  6604      6193          bne.s     OSFlagPost_36
                    6194   ; OS_Sched();
000022AE  4EB8 16B8 6195          jsr       _OS_Sched
                    6196   OSFlagPost_36:
                    6197   ; }
                    6198   ; OS_ENTER_CRITICAL();
000022B2  40E7      6199          dc.w      16615
000022B4  007C      6200          dc.w      124
000022B6  0700      6201          dc.w      1792
                    6202   ; flags_cur = pgrp->OSFlagFlags;
000022B8  2044      6203          move.l    D4,A0
000022BA  3D68 0006 6204          move.w    6(A0),-2(A6)
000022BE  FFFE      
                    6205   ; OS_EXIT_CRITICAL();
000022C0  46DF      6206          dc.w      18143
                    6207   ; *perr     = OS_ERR_NONE;
000022C2  2047      6208          move.l    D7,A0
000022C4  4210      6209          clr.b     (A0)
                    6210   ; return (flags_cur);
000022C6  302E FFFE 6211          move.w    -2(A6),D0
                    6212   OSFlagPost_3:
000022CA  4CDF 04FC 6213          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000022CE  4E5E      6214          unlk      A6
000022D0  4E75      6215          rts
                    6216   ; }
                    6217   ; /*$PAGE*/
                    6218   ; /*
                    6219   ; *********************************************************************************************************
                    6220   ; *                                          QUERY EVENT FLAG
                    6221   ; *
                    6222   ; * Description: This function is used to check the value of the event flag group.
                    6223   ; *
                    6224   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6225   ; *
                    6226   ; *              perr          is a pointer to an error code returned to the called:
                    6227   ; *                            OS_ERR_NONE                The call was successfull
                    6228   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6229   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6230   ; *
                    6231   ; * Returns    : The current value of the event flag group.
                    6232   ; *
                    6233   ; * Called From: Task or ISR
                    6234   ; *********************************************************************************************************
                    6235   ; */
                    6236   ; #if OS_FLAG_QUERY_EN > 0u
                    6237   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6238   ; INT8U        *perr)
                    6239   ; {
                    6240   _OSFlagQuery:
000022D2  4E56 FFFC 6241          link      A6,#-4
                    6242   ; OS_FLAGS   flags;
                    6243   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6244   ; OS_CPU_SR  cpu_sr = 0u;
                    6245   ; #endif
                    6246   ; #ifdef OS_SAFETY_CRITICAL
                    6247   ; if (perr == (INT8U *)0) {
                    6248   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6249   ; return ((OS_FLAGS)0);
                    6250   ; }
                    6251   ; #endif
                    6252   ; #if OS_ARG_CHK_EN > 0u
                    6253   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6254   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6255   ; return ((OS_FLAGS)0);
                    6256   ; }
                    6257   ; #endif
                    6258   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
000022D6  206E 0008 6259          move.l    8(A6),A0
000022DA  1010      6260          move.b    (A0),D0
000022DC  0C00 0005 6261          cmp.b     #5,D0
000022E0  670C      6262          beq.s     OSFlagQuery_1
                    6263   ; *perr = OS_ERR_EVENT_TYPE;
000022E2  206E 000C 6264          move.l    12(A6),A0
000022E6  10BC 0001 6265          move.b    #1,(A0)
                    6266   ; return ((OS_FLAGS)0);
000022EA  4240      6267          clr.w     D0
000022EC  601C      6268          bra.s     OSFlagQuery_3
                    6269   OSFlagQuery_1:
                    6270   ; }
                    6271   ; OS_ENTER_CRITICAL();
000022EE  40E7      6272          dc.w      16615
000022F0  007C      6273          dc.w      124
000022F2  0700      6274          dc.w      1792
                    6275   ; flags = pgrp->OSFlagFlags;
000022F4  206E 0008 6276          move.l    8(A6),A0
000022F8  3D68 0006 6277          move.w    6(A0),-2(A6)
000022FC  FFFE      
                    6278   ; OS_EXIT_CRITICAL();
000022FE  46DF      6279          dc.w      18143
                    6280   ; *perr = OS_ERR_NONE;
00002300  206E 000C 6281          move.l    12(A6),A0
00002304  4210      6282          clr.b     (A0)
                    6283   ; return (flags);                               /* Return the current value of the event flags       */
00002306  302E FFFE 6284          move.w    -2(A6),D0
                    6285   OSFlagQuery_3:
0000230A  4E5E      6286          unlk      A6
0000230C  4E75      6287          rts
                    6288   ; }
                    6289   ; #endif
                    6290   ; /*$PAGE*/
                    6291   ; /*
                    6292   ; *********************************************************************************************************
                    6293   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6294   ; *
                    6295   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6296   ; *              event flag bit(s) are set.
                    6297   ; *
                    6298   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6299   ; *
                    6300   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6301   ; *                            event flag bit(s) to be set.
                    6302   ; *
                    6303   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6304   ; *                            The bits you want are specified by setting the corresponding bits in
                    6305   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6306   ; *                            'flags' would contain 0x03.
                    6307   ; *
                    6308   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6309   ; *                            to be set/cleared.
                    6310   ; *                            You can specify the following argument:
                    6311   ; *
                    6312   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6313   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6314   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6315   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6316   ; *
                    6317   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6318   ; *                            bit(s) to be set.
                    6319   ; *
                    6320   ; * Returns    : none
                    6321   ; *
                    6322   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6323   ; *
                    6324   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6325   ; *********************************************************************************************************
                    6326   ; */
                    6327   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6328   ; OS_FLAG_NODE *pnode,
                    6329   ; OS_FLAGS      flags,
                    6330   ; INT8U         wait_type,
                    6331   ; INT32U        timeout)
                    6332   ; {
                    6333   @ucos_ii_OS_FlagBlock:
0000230E  4E56 0000 6334          link      A6,#0
00002312  48E7 3C20 6335          movem.l   D2/D3/D4/D5/A2,-(A7)
00002316  242E 000C 6336          move.l    12(A6),D2
0000231A  45F9 0800 6337          lea       _OSTCBCur.L,A2
0000231E  0540      
00002320  262E 0008 6338          move.l    8(A6),D3
                    6339   ; OS_FLAG_NODE  *pnode_next;
                    6340   ; INT8U          y;
                    6341   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
00002324  2052      6342          move.l    (A2),A0
00002326  0028 0020 6343          or.b      #32,50(A0)
0000232A  0032      
                    6344   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0000232C  2052      6345          move.l    (A2),A0
0000232E  4228 0033 6346          clr.b     51(A0)
                    6347   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002332  2052      6348          move.l    (A2),A0
00002334  216E 0018 6349          move.l    24(A6),46(A0)
00002338  002E      
                    6350   ; #if OS_TASK_DEL_EN > 0u
                    6351   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
0000233A  2052      6352          move.l    (A2),A0
0000233C  2142 0028 6353          move.l    D2,40(A0)
                    6354   ; #endif
                    6355   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
00002340  2042      6356          move.l    D2,A0
00002342  316E 0012 6357          move.w    18(A6),16(A0)
00002346  0010      
                    6358   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00002348  2042      6359          move.l    D2,A0
0000234A  116E 0017 6360          move.b    23(A6),18(A0)
0000234E  0012      
                    6361   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00002350  2042      6362          move.l    D2,A0
00002352  2152 0008 6363          move.l    (A2),8(A0)
                    6364   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
00002356  2043      6365          move.l    D3,A0
00002358  2242      6366          move.l    D2,A1
0000235A  22A8 0002 6367          move.l    2(A0),(A1)
                    6368   ; pnode->OSFlagNodePrev     = (void *)0;
0000235E  2042      6369          move.l    D2,A0
00002360  42A8 0004 6370          clr.l     4(A0)
                    6371   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00002364  2042      6372          move.l    D2,A0
00002366  2143 000C 6373          move.l    D3,12(A0)
                    6374   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
0000236A  2043      6375          move.l    D3,A0
0000236C  2A28 0002 6376          move.l    2(A0),D5
                    6377   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00002370  4A85      6378          tst.l     D5
00002372  6706      6379          beq.s     @ucos_ii_OS_FlagBlock_1
                    6380   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
00002374  2045      6381          move.l    D5,A0
00002376  2142 0004 6382          move.l    D2,4(A0)
                    6383   @ucos_ii_OS_FlagBlock_1:
                    6384   ; }
                    6385   ; pgrp->OSFlagWaitList = (void *)pnode;
0000237A  2043      6386          move.l    D3,A0
0000237C  2142 0002 6387          move.l    D2,2(A0)
                    6388   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
00002380  2052      6389          move.l    (A2),A0
00002382  1828 0036 6390          move.b    54(A0),D4
                    6391   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00002386  C8BC 0000 6392          and.l     #255,D4
0000238A  00FF      
0000238C  41F9 0800 6393          lea       _OSRdyTbl.L,A0
00002390  0430      
00002392  2252      6394          move.l    (A2),A1
00002394  1029 0037 6395          move.b    55(A1),D0
00002398  4600      6396          not.b     D0
0000239A  C130 4800 6397          and.b     D0,0(A0,D4.L)
                    6398   ; if (OSRdyTbl[y] == 0x00u) {
0000239E  C8BC 0000 6399          and.l     #255,D4
000023A2  00FF      
000023A4  41F9 0800 6400          lea       _OSRdyTbl.L,A0
000023A8  0430      
000023AA  1030 4800 6401          move.b    0(A0,D4.L),D0
000023AE  660E      6402          bne.s     @ucos_ii_OS_FlagBlock_3
                    6403   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000023B0  2052      6404          move.l    (A2),A0
000023B2  1028 0038 6405          move.b    56(A0),D0
000023B6  4600      6406          not.b     D0
000023B8  C139 0800 6407          and.b     D0,_OSRdyGrp.L
000023BC  042E      
                    6408   @ucos_ii_OS_FlagBlock_3:
000023BE  4CDF 043C 6409          movem.l   (A7)+,D2/D3/D4/D5/A2
000023C2  4E5E      6410          unlk      A6
000023C4  4E75      6411          rts
                    6412   ; }
                    6413   ; }
                    6414   ; /*$PAGE*/
                    6415   ; /*
                    6416   ; *********************************************************************************************************
                    6417   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6418   ; *
                    6419   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6420   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6421   ; *
                    6422   ; * Arguments  : none
                    6423   ; *
                    6424   ; * Returns    : none
                    6425   ; *
                    6426   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6427   ; *********************************************************************************************************
                    6428   ; */
                    6429   ; void  OS_FlagInit (void)
                    6430   ; {
                    6431   _OS_FlagInit:
000023C6  4E56 FFF8 6432          link      A6,#-8
000023CA  48E7 3020 6433          movem.l   D2/D3/A2,-(A7)
000023CE  45F9 0800 6434          lea       _OSFlagTbl.L,A2
000023D2  02DA      
                    6435   ; #if OS_MAX_FLAGS == 1u
                    6436   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6437   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6438   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6439   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6440   ; #if OS_FLAG_NAME_EN > 0u
                    6441   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6442   ; #endif
                    6443   ; #endif
                    6444   ; #if OS_MAX_FLAGS >= 2u
                    6445   ; INT16U        ix;
                    6446   ; INT16U        ix_next;
                    6447   ; OS_FLAG_GRP  *pgrp1;
                    6448   ; OS_FLAG_GRP  *pgrp2;
                    6449   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000023D4  4878 003C 6450          pea       60
000023D8  2F0A      6451          move.l    A2,-(A7)
000023DA  4EB8 166C 6452          jsr       _OS_MemClr
000023DE  504F      6453          addq.w    #8,A7
                    6454   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
000023E0  4243      6455          clr.w     D3
                    6456   OS_FlagInit_1:
000023E2  0C43 0004 6457          cmp.w     #4,D3
000023E6  6400 004E 6458          bhs       OS_FlagInit_3
                    6459   ; ix_next = ix + 1u;
000023EA  3003      6460          move.w    D3,D0
000023EC  5240      6461          addq.w    #1,D0
000023EE  3D40 FFFA 6462          move.w    D0,-6(A6)
                    6463   ; pgrp1 = &OSFlagTbl[ix];
000023F2  200A      6464          move.l    A2,D0
000023F4  C6BC 0000 6465          and.l     #65535,D3
000023F8  FFFF      
000023FA  2203      6466          move.l    D3,D1
000023FC  C3FC 000C 6467          muls      #12,D1
00002400  D081      6468          add.l     D1,D0
00002402  2400      6469          move.l    D0,D2
                    6470   ; pgrp2 = &OSFlagTbl[ix_next];
00002404  200A      6471          move.l    A2,D0
00002406  322E FFFA 6472          move.w    -6(A6),D1
0000240A  C2BC 0000 6473          and.l     #65535,D1
0000240E  FFFF      
00002410  C3FC 000C 6474          muls      #12,D1
00002414  D081      6475          add.l     D1,D0
00002416  2D40 FFFC 6476          move.l    D0,-4(A6)
                    6477   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0000241A  2042      6478          move.l    D2,A0
0000241C  4210      6479          clr.b     (A0)
                    6480   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
0000241E  2042      6481          move.l    D2,A0
00002420  216E FFFC 6482          move.l    -4(A6),2(A0)
00002424  0002      
                    6483   ; #if OS_FLAG_NAME_EN > 0u
                    6484   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
00002426  41F9 0000 6485          lea       @ucos_ii_1.L,A0
0000242A  763A      
0000242C  2242      6486          move.l    D2,A1
0000242E  2348 0008 6487          move.l    A0,8(A1)
00002432  5243      6488          addq.w    #1,D3
00002434  60AC      6489          bra       OS_FlagInit_1
                    6490   OS_FlagInit_3:
                    6491   ; #endif
                    6492   ; }
                    6493   ; pgrp1                 = &OSFlagTbl[ix];
00002436  200A      6494          move.l    A2,D0
00002438  C6BC 0000 6495          and.l     #65535,D3
0000243C  FFFF      
0000243E  2203      6496          move.l    D3,D1
00002440  C3FC 000C 6497          muls      #12,D1
00002444  D081      6498          add.l     D1,D0
00002446  2400      6499          move.l    D0,D2
                    6500   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002448  2042      6501          move.l    D2,A0
0000244A  4210      6502          clr.b     (A0)
                    6503   ; pgrp1->OSFlagWaitList = (void *)0;
0000244C  2042      6504          move.l    D2,A0
0000244E  42A8 0002 6505          clr.l     2(A0)
                    6506   ; #if OS_FLAG_NAME_EN > 0u
                    6507   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00002452  41F9 0000 6508          lea       @ucos_ii_1.L,A0
00002456  763A      
00002458  2242      6509          move.l    D2,A1
0000245A  2348 0008 6510          move.l    A0,8(A1)
                    6511   ; #endif
                    6512   ; OSFlagFreeList        = &OSFlagTbl[0];
0000245E  23CA 0800 6513          move.l    A2,_OSFlagFreeList.L
00002462  0316      
00002464  4CDF 040C 6514          movem.l   (A7)+,D2/D3/A2
00002468  4E5E      6515          unlk      A6
0000246A  4E75      6516          rts
                    6517   ; #endif
                    6518   ; }
                    6519   ; /*$PAGE*/
                    6520   ; /*
                    6521   ; *********************************************************************************************************
                    6522   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6523   ; *
                    6524   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6525   ; *              desired event flag bits have been set.
                    6526   ; *
                    6527   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6528   ; *                            event flag bit(s) to be set.
                    6529   ; *
                    6530   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6531   ; *                            ready-to-run.
                    6532   ; *
                    6533   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6534   ; *
                    6535   ; *
                    6536   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6537   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6538   ; *
                    6539   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6540   ; *
                    6541   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6542   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6543   ; *********************************************************************************************************
                    6544   ; */
                    6545   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6546   ; OS_FLAGS      flags_rdy,
                    6547   ; INT8U         pend_stat)
                    6548   ; {
                    6549   @ucos_ii_OS_FlagTaskRdy:
0000246C  4E56 0000 6550          link      A6,#0
00002470  48E7 3000 6551          movem.l   D2/D3,-(A7)
                    6552   ; OS_TCB   *ptcb;
                    6553   ; BOOLEAN   sched;
                    6554   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
00002474  206E 0008 6555          move.l    8(A6),A0
00002478  2428 0008 6556          move.l    8(A0),D2
                    6557   ; ptcb->OSTCBDly       = 0u;
0000247C  2042      6558          move.l    D2,A0
0000247E  42A8 002E 6559          clr.l     46(A0)
                    6560   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
00002482  2042      6561          move.l    D2,A0
00002484  316E 000E 6562          move.w    14(A6),44(A0)
00002488  002C      
                    6563   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
0000248A  2042      6564          move.l    D2,A0
0000248C  7020      6565          moveq     #32,D0
0000248E  4600      6566          not.b     D0
00002490  C128 0032 6567          and.b     D0,50(A0)
                    6568   ; ptcb->OSTCBStatPend  = pend_stat;
00002494  2042      6569          move.l    D2,A0
00002496  116E 0013 6570          move.b    19(A6),51(A0)
0000249A  0033      
                    6571   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
0000249C  2042      6572          move.l    D2,A0
0000249E  1028 0032 6573          move.b    50(A0),D0
000024A2  662C      6574          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6575   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000024A4  2042      6576          move.l    D2,A0
000024A6  1028 0038 6577          move.b    56(A0),D0
000024AA  8139 0800 6578          or.b      D0,_OSRdyGrp.L
000024AE  042E      
                    6579   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000024B0  2042      6580          move.l    D2,A0
000024B2  1028 0036 6581          move.b    54(A0),D0
000024B6  C0BC 0000 6582          and.l     #255,D0
000024BA  00FF      
000024BC  41F9 0800 6583          lea       _OSRdyTbl.L,A0
000024C0  0430      
000024C2  2242      6584          move.l    D2,A1
000024C4  1229 0037 6585          move.b    55(A1),D1
000024C8  8330 0800 6586          or.b      D1,0(A0,D0.L)
                    6587   ; sched                   = OS_TRUE;
000024CC  7601      6588          moveq     #1,D3
000024CE  6002      6589          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6590   @ucos_ii_OS_FlagTaskRdy_1:
                    6591   ; } else {
                    6592   ; sched                   = OS_FALSE;
000024D0  4203      6593          clr.b     D3
                    6594   @ucos_ii_OS_FlagTaskRdy_2:
                    6595   ; }
                    6596   ; OS_FlagUnlink(pnode);
000024D2  2F2E 0008 6597          move.l    8(A6),-(A7)
000024D6  4EB9 0000 6598          jsr       _OS_FlagUnlink
000024DA  24E8      
000024DC  584F      6599          addq.w    #4,A7
                    6600   ; return (sched);
000024DE  1003      6601          move.b    D3,D0
000024E0  4CDF 000C 6602          movem.l   (A7)+,D2/D3
000024E4  4E5E      6603          unlk      A6
000024E6  4E75      6604          rts
                    6605   ; }
                    6606   ; /*$PAGE*/
                    6607   ; /*
                    6608   ; *********************************************************************************************************
                    6609   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6610   ; *
                    6611   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6612   ; *              list of tasks waiting for the event flag.
                    6613   ; *
                    6614   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6615   ; *                            event flag bit(s) to be set.
                    6616   ; *
                    6617   ; * Returns    : none
                    6618   ; *
                    6619   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6620   ; *              OSFlagPend()     OS_FLAG.C
                    6621   ; *              OSTaskDel()      OS_TASK.C
                    6622   ; *
                    6623   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6624   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6625   ; *********************************************************************************************************
                    6626   ; */
                    6627   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6628   ; {
                    6629   _OS_FlagUnlink:
000024E8  4E56 FFF8 6630          link      A6,#-8
000024EC  48E7 3800 6631          movem.l   D2/D3/D4,-(A7)
000024F0  262E 0008 6632          move.l    8(A6),D3
                    6633   ; #if OS_TASK_DEL_EN > 0u
                    6634   ; OS_TCB       *ptcb;
                    6635   ; #endif
                    6636   ; OS_FLAG_GRP  *pgrp;
                    6637   ; OS_FLAG_NODE *pnode_prev;
                    6638   ; OS_FLAG_NODE *pnode_next;
                    6639   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000024F4  2043      6640          move.l    D3,A0
000024F6  2828 0004 6641          move.l    4(A0),D4
                    6642   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000024FA  2043      6643          move.l    D3,A0
000024FC  2410      6644          move.l    (A0),D2
                    6645   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000024FE  4A84      6646          tst.l     D4
00002500  661C      6647          bne.s     OS_FlagUnlink_1
                    6648   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00002502  2043      6649          move.l    D3,A0
00002504  2D68 000C 6650          move.l    12(A0),-4(A6)
00002508  FFFC      
                    6651   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
0000250A  206E FFFC 6652          move.l    -4(A6),A0
0000250E  2142 0002 6653          move.l    D2,2(A0)
                    6654   ; if (pnode_next != (OS_FLAG_NODE *)0) {
00002512  4A82      6655          tst.l     D2
00002514  6706      6656          beq.s     OS_FlagUnlink_3
                    6657   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00002516  2042      6658          move.l    D2,A0
00002518  42A8 0004 6659          clr.l     4(A0)
                    6660   OS_FlagUnlink_3:
0000251C  600E      6661          bra.s     OS_FlagUnlink_5
                    6662   OS_FlagUnlink_1:
                    6663   ; }
                    6664   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6665   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
0000251E  2044      6666          move.l    D4,A0
00002520  2082      6667          move.l    D2,(A0)
                    6668   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
00002522  4A82      6669          tst.l     D2
00002524  6706      6670          beq.s     OS_FlagUnlink_5
                    6671   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00002526  2042      6672          move.l    D2,A0
00002528  2144 0004 6673          move.l    D4,4(A0)
                    6674   OS_FlagUnlink_5:
                    6675   ; }
                    6676   ; }
                    6677   ; #if OS_TASK_DEL_EN > 0u
                    6678   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0000252C  2043      6679          move.l    D3,A0
0000252E  2D68 0008 6680          move.l    8(A0),-8(A6)
00002532  FFF8      
                    6681   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00002534  206E FFF8 6682          move.l    -8(A6),A0
00002538  42A8 0028 6683          clr.l     40(A0)
0000253C  4CDF 001C 6684          movem.l   (A7)+,D2/D3/D4
00002540  4E5E      6685          unlk      A6
00002542  4E75      6686          rts
                    6687   ; /*
                    6688   ; *********************************************************************************************************
                    6689   ; *                                                uC/OS-II
                    6690   ; *                                          The Real-Time Kernel
                    6691   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6692   ; *
                    6693   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6694   ; *                                           All Rights Reserved
                    6695   ; *
                    6696   ; * File    : OS_MBOX.C
                    6697   ; * By      : Jean J. Labrosse
                    6698   ; * Version : V2.92.07
                    6699   ; *
                    6700   ; * LICENSING TERMS:
                    6701   ; * ---------------
                    6702   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6703   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6704   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6705   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6706   ; * licensing fee.
                    6707   ; *********************************************************************************************************
                    6708   ; */
                    6709   ; #define  MICRIUM_SOURCE
                    6710   ; #ifndef  OS_MASTER_FILE
                    6711   ; #include <ucos_ii.h>
                    6712   ; #endif
                    6713   ; #if OS_MBOX_EN > 0u
                    6714   ; /*
                    6715   ; *********************************************************************************************************
                    6716   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6717   ; *
                    6718   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6719   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6720   ; *
                    6721   ; * Arguments  : pevent        is a pointer to the event control block
                    6722   ; *
                    6723   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6724   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6725   ; *              == (void *)0  if the mailbox is empty or,
                    6726   ; *                            if 'pevent' is a NULL pointer or,
                    6727   ; *                            if you didn't pass the proper event pointer.
                    6728   ; *********************************************************************************************************
                    6729   ; */
                    6730   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6731   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6732   ; {
                    6733   _OSMboxAccept:
00002544  4E56 FFFC 6734          link      A6,#-4
00002548  2F02      6735          move.l    D2,-(A7)
0000254A  242E 0008 6736          move.l    8(A6),D2
                    6737   ; void      *pmsg;
                    6738   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6739   ; OS_CPU_SR  cpu_sr = 0u;
                    6740   ; #endif
                    6741   ; #if OS_ARG_CHK_EN > 0u
                    6742   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6743   ; return ((void *)0);
                    6744   ; }
                    6745   ; #endif
                    6746   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
0000254E  2042      6747          move.l    D2,A0
00002550  1010      6748          move.b    (A0),D0
00002552  0C00 0001 6749          cmp.b     #1,D0
00002556  6704      6750          beq.s     OSMboxAccept_1
                    6751   ; return ((void *)0);
00002558  4280      6752          clr.l     D0
0000255A  601A      6753          bra.s     OSMboxAccept_3
                    6754   OSMboxAccept_1:
                    6755   ; }
                    6756   ; OS_ENTER_CRITICAL();
0000255C  40E7      6757          dc.w      16615
0000255E  007C      6758          dc.w      124
00002560  0700      6759          dc.w      1792
                    6760   ; pmsg               = pevent->OSEventPtr;
00002562  2042      6761          move.l    D2,A0
00002564  2D68 0002 6762          move.l    2(A0),-4(A6)
00002568  FFFC      
                    6763   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
0000256A  2042      6764          move.l    D2,A0
0000256C  42A8 0002 6765          clr.l     2(A0)
                    6766   ; OS_EXIT_CRITICAL();
00002570  46DF      6767          dc.w      18143
                    6768   ; return (pmsg);                                        /* Return the message received (or NULL)     */
00002572  202E FFFC 6769          move.l    -4(A6),D0
                    6770   OSMboxAccept_3:
00002576  241F      6771          move.l    (A7)+,D2
00002578  4E5E      6772          unlk      A6
0000257A  4E75      6773          rts
                    6774   ; }
                    6775   ; #endif
                    6776   ; /*$PAGE*/
                    6777   ; /*
                    6778   ; *********************************************************************************************************
                    6779   ; *                                          CREATE A MESSAGE MAILBOX
                    6780   ; *
                    6781   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    6782   ; *
                    6783   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    6784   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    6785   ; *                            will be considered empty.
                    6786   ; *
                    6787   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    6788   ; *                                created mailbox
                    6789   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    6790   ; *********************************************************************************************************
                    6791   ; */
                    6792   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    6793   ; {
                    6794   _OSMboxCreate:
0000257C  4E56 0000 6795          link      A6,#0
00002580  48E7 2020 6796          movem.l   D2/A2,-(A7)
00002584  45F9 0800 6797          lea       _OSEventFreeList.L,A2
00002588  01FA      
                    6798   ; OS_EVENT  *pevent;
                    6799   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    6800   ; OS_CPU_SR  cpu_sr = 0u;
                    6801   ; #endif
                    6802   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    6803   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    6804   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6805   ; return ((OS_EVENT *)0);
                    6806   ; }
                    6807   ; #endif
                    6808   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
0000258A  1039 0800 6809          move.b    _OSIntNesting.L,D0
0000258E  0426      
00002590  0C00 0000 6810          cmp.b     #0,D0
00002594  6306      6811          bls.s     OSMboxCreate_1
                    6812   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00002596  4280      6813          clr.l     D0
00002598  6000 0044 6814          bra       OSMboxCreate_3
                    6815   OSMboxCreate_1:
                    6816   ; }
                    6817   ; OS_ENTER_CRITICAL();
0000259C  40E7      6818          dc.w      16615
0000259E  007C      6819          dc.w      124
000025A0  0700      6820          dc.w      1792
                    6821   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000025A2  2412      6822          move.l    (A2),D2
                    6823   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000025A4  2012      6824          move.l    (A2),D0
000025A6  6706      6825          beq.s     OSMboxCreate_4
                    6826   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000025A8  2052      6827          move.l    (A2),A0
000025AA  24A8 0002 6828          move.l    2(A0),(A2)
                    6829   OSMboxCreate_4:
                    6830   ; }
                    6831   ; OS_EXIT_CRITICAL();
000025AE  46DF      6832          dc.w      18143
                    6833   ; if (pevent != (OS_EVENT *)0) {
000025B0  4A82      6834          tst.l     D2
000025B2  6728      6835          beq.s     OSMboxCreate_6
                    6836   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
000025B4  2042      6837          move.l    D2,A0
000025B6  10BC 0001 6838          move.b    #1,(A0)
                    6839   ; pevent->OSEventCnt     = 0u;
000025BA  2042      6840          move.l    D2,A0
000025BC  4268 0006 6841          clr.w     6(A0)
                    6842   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
000025C0  2042      6843          move.l    D2,A0
000025C2  216E 0008 6844          move.l    8(A6),2(A0)
000025C6  0002      
                    6845   ; #if OS_EVENT_NAME_EN > 0u
                    6846   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000025C8  41F9 0000 6847          lea       @ucos_ii_1.L,A0
000025CC  763A      
000025CE  2242      6848          move.l    D2,A1
000025D0  2348 0012 6849          move.l    A0,18(A1)
                    6850   ; #endif
                    6851   ; OS_EventWaitListInit(pevent);
000025D4  2F02      6852          move.l    D2,-(A7)
000025D6  4EB8 13A0 6853          jsr       _OS_EventWaitListInit
000025DA  584F      6854          addq.w    #4,A7
                    6855   OSMboxCreate_6:
                    6856   ; }
                    6857   ; return (pevent);                             /* Return pointer to event control block              */
000025DC  2002      6858          move.l    D2,D0
                    6859   OSMboxCreate_3:
000025DE  4CDF 0404 6860          movem.l   (A7)+,D2/A2
000025E2  4E5E      6861          unlk      A6
000025E4  4E75      6862          rts
                    6863   ; }
                    6864   ; /*$PAGE*/
                    6865   ; /*
                    6866   ; *********************************************************************************************************
                    6867   ; *                                           DELETE A MAIBOX
                    6868   ; *
                    6869   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    6870   ; *
                    6871   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    6872   ; *                            mailbox.
                    6873   ; *
                    6874   ; *              opt           determines delete options as follows:
                    6875   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    6876   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    6877   ; *                                                    In this case, all the tasks pending will be readied.
                    6878   ; *
                    6879   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    6880   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    6881   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    6882   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    6883   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    6884   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    6885   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    6886   ; *
                    6887   ; * Returns    : pevent        upon error
                    6888   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    6889   ; *
                    6890   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    6891   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    6892   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    6893   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    6894   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    6895   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    6896   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    6897   ; *                 will no longer be guarded by the mailbox.
                    6898   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    6899   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    6900   ; *********************************************************************************************************
                    6901   ; */
                    6902   ; #if OS_MBOX_DEL_EN > 0u
                    6903   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    6904   ; INT8U      opt,
                    6905   ; INT8U     *perr)
                    6906   ; {
                    6907   _OSMboxDel:
000025E6  4E56 0000 6908          link      A6,#0
000025EA  48E7 3C20 6909          movem.l   D2/D3/D4/D5/A2,-(A7)
000025EE  242E 0008 6910          move.l    8(A6),D2
000025F2  262E 0010 6911          move.l    16(A6),D3
000025F6  45F9 0800 6912          lea       _OSEventFreeList.L,A2
000025FA  01FA      
                    6913   ; BOOLEAN    tasks_waiting;
                    6914   ; OS_EVENT  *pevent_return;
                    6915   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6916   ; OS_CPU_SR  cpu_sr = 0u;
                    6917   ; #endif
                    6918   ; #ifdef OS_SAFETY_CRITICAL
                    6919   ; if (perr == (INT8U *)0) {
                    6920   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6921   ; return ((OS_EVENT *)0);
                    6922   ; }
                    6923   ; #endif
                    6924   ; #if OS_ARG_CHK_EN > 0u
                    6925   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    6926   ; *perr = OS_ERR_PEVENT_NULL;
                    6927   ; return (pevent);
                    6928   ; }
                    6929   ; #endif
                    6930   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
000025FC  2042      6931          move.l    D2,A0
000025FE  1010      6932          move.b    (A0),D0
00002600  0C00 0001 6933          cmp.b     #1,D0
00002604  670C      6934          beq.s     OSMboxDel_1
                    6935   ; *perr = OS_ERR_EVENT_TYPE;
00002606  2043      6936          move.l    D3,A0
00002608  10BC 0001 6937          move.b    #1,(A0)
                    6938   ; return (pevent);
0000260C  2002      6939          move.l    D2,D0
0000260E  6000 00EA 6940          bra       OSMboxDel_3
                    6941   OSMboxDel_1:
                    6942   ; }
                    6943   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002612  1039 0800 6944          move.b    _OSIntNesting.L,D0
00002616  0426      
00002618  0C00 0000 6945          cmp.b     #0,D0
0000261C  630C      6946          bls.s     OSMboxDel_4
                    6947   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0000261E  2043      6948          move.l    D3,A0
00002620  10BC 000F 6949          move.b    #15,(A0)
                    6950   ; return (pevent);
00002624  2002      6951          move.l    D2,D0
00002626  6000 00D2 6952          bra       OSMboxDel_3
                    6953   OSMboxDel_4:
                    6954   ; }
                    6955   ; OS_ENTER_CRITICAL();
0000262A  40E7      6956          dc.w      16615
0000262C  007C      6957          dc.w      124
0000262E  0700      6958          dc.w      1792
                    6959   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
00002630  2042      6960          move.l    D2,A0
00002632  1028 0008 6961          move.b    8(A0),D0
00002636  6704      6962          beq.s     OSMboxDel_6
                    6963   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002638  7A01      6964          moveq     #1,D5
0000263A  6002      6965          bra.s     OSMboxDel_7
                    6966   OSMboxDel_6:
                    6967   ; } else {
                    6968   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000263C  4205      6969          clr.b     D5
                    6970   OSMboxDel_7:
                    6971   ; }
                    6972   ; switch (opt) {
0000263E  102E 000F 6973          move.b    15(A6),D0
00002642  C0BC 0000 6974          and.l     #255,D0
00002646  00FF      
00002648  0C80 0000 6975          cmp.l     #1,D0
0000264C  0001      
0000264E  6700 0048 6976          beq       OSMboxDel_11
00002652  6200 009A 6977          bhi       OSMboxDel_8
00002656  4A80      6978          tst.l     D0
00002658  6704      6979          beq.s     OSMboxDel_10
0000265A  6000 0092 6980          bra       OSMboxDel_8
                    6981   OSMboxDel_10:
                    6982   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    6983   ; if (tasks_waiting == OS_FALSE) {
0000265E  4A05      6984          tst.b     D5
00002660  6628      6985          bne.s     OSMboxDel_13
                    6986   ; #if OS_EVENT_NAME_EN > 0u
                    6987   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002662  41F9 0000 6988          lea       @ucos_ii_1.L,A0
00002666  763A      
00002668  2242      6989          move.l    D2,A1
0000266A  2348 0012 6990          move.l    A0,18(A1)
                    6991   ; #endif
                    6992   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
0000266E  2042      6993          move.l    D2,A0
00002670  4210      6994          clr.b     (A0)
                    6995   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
00002672  2042      6996          move.l    D2,A0
00002674  2152 0002 6997          move.l    (A2),2(A0)
                    6998   ; pevent->OSEventCnt  = 0u;
00002678  2042      6999          move.l    D2,A0
0000267A  4268 0006 7000          clr.w     6(A0)
                    7001   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
0000267E  2482      7002          move.l    D2,(A2)
                    7003   ; OS_EXIT_CRITICAL();
00002680  46DF      7004          dc.w      18143
                    7005   ; *perr               = OS_ERR_NONE;
00002682  2043      7006          move.l    D3,A0
00002684  4210      7007          clr.b     (A0)
                    7008   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
00002686  4284      7009          clr.l     D4
00002688  600A      7010          bra.s     OSMboxDel_14
                    7011   OSMboxDel_13:
                    7012   ; } else {
                    7013   ; OS_EXIT_CRITICAL();
0000268A  46DF      7014          dc.w      18143
                    7015   ; *perr               = OS_ERR_TASK_WAITING;
0000268C  2043      7016          move.l    D3,A0
0000268E  10BC 0049 7017          move.b    #73,(A0)
                    7018   ; pevent_return       = pevent;
00002692  2802      7019          move.l    D2,D4
                    7020   OSMboxDel_14:
                    7021   ; }
                    7022   ; break;
00002694  6000 0062 7023          bra       OSMboxDel_9
                    7024   OSMboxDel_11:
                    7025   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    7026   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    7027   OSMboxDel_15:
00002698  2042      7028          move.l    D2,A0
0000269A  1028 0008 7029          move.b    8(A0),D0
0000269E  671C      7030          beq.s     OSMboxDel_17
                    7031   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000026A0  4878 0002 7032          pea       2
000026A4  4878 0002 7033          pea       2
000026A8  42A7      7034          clr.l     -(A7)
000026AA  2F02      7035          move.l    D2,-(A7)
000026AC  4EB8 10D8 7036          jsr       _OS_EventTaskRdy
000026B0  DEFC 0010 7037          add.w     #16,A7
000026B4  C0BC 0000 7038          and.l     #255,D0
000026B8  00FF      
000026BA  60DC      7039          bra       OSMboxDel_15
                    7040   OSMboxDel_17:
                    7041   ; }
                    7042   ; #if OS_EVENT_NAME_EN > 0u
                    7043   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000026BC  41F9 0000 7044          lea       @ucos_ii_1.L,A0
000026C0  763A      
000026C2  2242      7045          move.l    D2,A1
000026C4  2348 0012 7046          move.l    A0,18(A1)
                    7047   ; #endif
                    7048   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000026C8  2042      7049          move.l    D2,A0
000026CA  4210      7050          clr.b     (A0)
                    7051   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
000026CC  2042      7052          move.l    D2,A0
000026CE  2152 0002 7053          move.l    (A2),2(A0)
                    7054   ; pevent->OSEventCnt     = 0u;
000026D2  2042      7055          move.l    D2,A0
000026D4  4268 0006 7056          clr.w     6(A0)
                    7057   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
000026D8  2482      7058          move.l    D2,(A2)
                    7059   ; OS_EXIT_CRITICAL();
000026DA  46DF      7060          dc.w      18143
                    7061   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
000026DC  0C05 0001 7062          cmp.b     #1,D5
000026E0  6604      7063          bne.s     OSMboxDel_18
                    7064   ; OS_Sched();                               /* Find highest priority task ready to run  */
000026E2  4EB8 16B8 7065          jsr       _OS_Sched
                    7066   OSMboxDel_18:
                    7067   ; }
                    7068   ; *perr         = OS_ERR_NONE;
000026E6  2043      7069          move.l    D3,A0
000026E8  4210      7070          clr.b     (A0)
                    7071   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
000026EA  4284      7072          clr.l     D4
                    7073   ; break;
000026EC  600A      7074          bra.s     OSMboxDel_9
                    7075   OSMboxDel_8:
                    7076   ; default:
                    7077   ; OS_EXIT_CRITICAL();
000026EE  46DF      7078          dc.w      18143
                    7079   ; *perr         = OS_ERR_INVALID_OPT;
000026F0  2043      7080          move.l    D3,A0
000026F2  10BC 0007 7081          move.b    #7,(A0)
                    7082   ; pevent_return = pevent;
000026F6  2802      7083          move.l    D2,D4
                    7084   ; break;
                    7085   OSMboxDel_9:
                    7086   ; }
                    7087   ; return (pevent_return);
000026F8  2004      7088          move.l    D4,D0
                    7089   OSMboxDel_3:
000026FA  4CDF 043C 7090          movem.l   (A7)+,D2/D3/D4/D5/A2
000026FE  4E5E      7091          unlk      A6
00002700  4E75      7092          rts
                    7093   ; }
                    7094   ; #endif
                    7095   ; /*$PAGE*/
                    7096   ; /*
                    7097   ; *********************************************************************************************************
                    7098   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    7099   ; *
                    7100   ; * Description: This function waits for a message to be sent to a mailbox
                    7101   ; *
                    7102   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7103   ; *
                    7104   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    7105   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    7106   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    7107   ; *                            forever at the specified mailbox or, until a message arrives.
                    7108   ; *
                    7109   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7110   ; *                            messages are:
                    7111   ; *
                    7112   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    7113   ; *                                                message.
                    7114   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    7115   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    7116   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    7117   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    7118   ; *                                                would lead to a suspension.
                    7119   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    7120   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    7121   ; *
                    7122   ; * Returns    : != (void *)0  is a pointer to the message received
                    7123   ; *              == (void *)0  if no message was received or,
                    7124   ; *                            if 'pevent' is a NULL pointer or,
                    7125   ; *                            if you didn't pass the proper pointer to the event control block.
                    7126   ; *********************************************************************************************************
                    7127   ; */
                    7128   ; /*$PAGE*/
                    7129   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    7130   ; INT32U     timeout,
                    7131   ; INT8U     *perr)
                    7132   ; {
                    7133   _OSMboxPend:
00002702  4E56 0000 7134          link      A6,#0
00002706  48E7 3820 7135          movem.l   D2/D3/D4/A2,-(A7)
0000270A  45F9 0800 7136          lea       _OSTCBCur.L,A2
0000270E  0540      
00002710  262E 0010 7137          move.l    16(A6),D3
00002714  282E 0008 7138          move.l    8(A6),D4
                    7139   ; void      *pmsg;
                    7140   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7141   ; OS_CPU_SR  cpu_sr = 0u;
                    7142   ; #endif
                    7143   ; #ifdef OS_SAFETY_CRITICAL
                    7144   ; if (perr == (INT8U *)0) {
                    7145   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7146   ; return ((void *)0);
                    7147   ; }
                    7148   ; #endif
                    7149   ; #if OS_ARG_CHK_EN > 0u
                    7150   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7151   ; *perr = OS_ERR_PEVENT_NULL;
                    7152   ; return ((void *)0);
                    7153   ; }
                    7154   ; #endif
                    7155   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002718  2044      7156          move.l    D4,A0
0000271A  1010      7157          move.b    (A0),D0
0000271C  0C00 0001 7158          cmp.b     #1,D0
00002720  670C      7159          beq.s     OSMboxPend_1
                    7160   ; *perr = OS_ERR_EVENT_TYPE;
00002722  2043      7161          move.l    D3,A0
00002724  10BC 0001 7162          move.b    #1,(A0)
                    7163   ; return ((void *)0);
00002728  4280      7164          clr.l     D0
0000272A  6000 00F0 7165          bra       OSMboxPend_3
                    7166   OSMboxPend_1:
                    7167   ; }
                    7168   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000272E  1039 0800 7169          move.b    _OSIntNesting.L,D0
00002732  0426      
00002734  0C00 0000 7170          cmp.b     #0,D0
00002738  630C      7171          bls.s     OSMboxPend_4
                    7172   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
0000273A  2043      7173          move.l    D3,A0
0000273C  10BC 0002 7174          move.b    #2,(A0)
                    7175   ; return ((void *)0);
00002740  4280      7176          clr.l     D0
00002742  6000 00D8 7177          bra       OSMboxPend_3
                    7178   OSMboxPend_4:
                    7179   ; }
                    7180   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00002746  1039 0800 7181          move.b    _OSLockNesting.L,D0
0000274A  0428      
0000274C  0C00 0000 7182          cmp.b     #0,D0
00002750  630C      7183          bls.s     OSMboxPend_6
                    7184   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002752  2043      7185          move.l    D3,A0
00002754  10BC 000D 7186          move.b    #13,(A0)
                    7187   ; return ((void *)0);
00002758  4280      7188          clr.l     D0
0000275A  6000 00C0 7189          bra       OSMboxPend_3
                    7190   OSMboxPend_6:
                    7191   ; }
                    7192   ; OS_ENTER_CRITICAL();
0000275E  40E7      7193          dc.w      16615
00002760  007C      7194          dc.w      124
00002762  0700      7195          dc.w      1792
                    7196   ; pmsg = pevent->OSEventPtr;
00002764  2044      7197          move.l    D4,A0
00002766  2428 0002 7198          move.l    2(A0),D2
                    7199   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
0000276A  4A82      7200          tst.l     D2
0000276C  6712      7201          beq.s     OSMboxPend_8
                    7202   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
0000276E  2044      7203          move.l    D4,A0
00002770  42A8 0002 7204          clr.l     2(A0)
                    7205   ; OS_EXIT_CRITICAL();
00002774  46DF      7206          dc.w      18143
                    7207   ; *perr = OS_ERR_NONE;
00002776  2043      7208          move.l    D3,A0
00002778  4210      7209          clr.b     (A0)
                    7210   ; return (pmsg);                                /* Return the message received (or NULL)         */
0000277A  2002      7211          move.l    D2,D0
0000277C  6000 009E 7212          bra       OSMboxPend_3
                    7213   OSMboxPend_8:
                    7214   ; }
                    7215   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
00002780  2052      7216          move.l    (A2),A0
00002782  0028 0002 7217          or.b      #2,50(A0)
00002786  0032      
                    7218   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00002788  2052      7219          move.l    (A2),A0
0000278A  4228 0033 7220          clr.b     51(A0)
                    7221   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
0000278E  2052      7222          move.l    (A2),A0
00002790  216E 000C 7223          move.l    12(A6),46(A0)
00002794  002E      
                    7224   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00002796  2F04      7225          move.l    D4,-(A7)
00002798  4EB8 11BC 7226          jsr       _OS_EventTaskWait
0000279C  584F      7227          addq.w    #4,A7
                    7228   ; OS_EXIT_CRITICAL();
0000279E  46DF      7229          dc.w      18143
                    7230   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
000027A0  4EB8 16B8 7231          jsr       _OS_Sched
                    7232   ; OS_ENTER_CRITICAL();
000027A4  40E7      7233          dc.w      16615
000027A6  007C      7234          dc.w      124
000027A8  0700      7235          dc.w      1792
                    7236   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000027AA  2052      7237          move.l    (A2),A0
000027AC  1028 0033 7238          move.b    51(A0),D0
000027B0  C0BC 0000 7239          and.l     #255,D0
000027B4  00FF      
000027B6  0C80 0000 7240          cmp.l     #1,D0
000027BA  0001      
000027BC  6700 002A 7241          beq       OSMboxPend_14
000027C0  6206      7242          bhi.s     OSMboxPend_16
000027C2  4A80      7243          tst.l     D0
000027C4  670C      7244          beq.s     OSMboxPend_12
000027C6  6020      7245          bra.s     OSMboxPend_14
                    7246   OSMboxPend_16:
000027C8  0C80 0000 7247          cmp.l     #2,D0
000027CC  0002      
000027CE  670E      7248          beq.s     OSMboxPend_13
000027D0  6016      7249          bra.s     OSMboxPend_14
                    7250   OSMboxPend_12:
                    7251   ; case OS_STAT_PEND_OK:
                    7252   ; pmsg =  OSTCBCur->OSTCBMsg;
000027D2  2052      7253          move.l    (A2),A0
000027D4  2428 0024 7254          move.l    36(A0),D2
                    7255   ; *perr =  OS_ERR_NONE;
000027D8  2043      7256          move.l    D3,A0
000027DA  4210      7257          clr.b     (A0)
                    7258   ; break;
000027DC  601C      7259          bra.s     OSMboxPend_11
                    7260   OSMboxPend_13:
                    7261   ; case OS_STAT_PEND_ABORT:
                    7262   ; pmsg = (void *)0;
000027DE  4282      7263          clr.l     D2
                    7264   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
000027E0  2043      7265          move.l    D3,A0
000027E2  10BC 000E 7266          move.b    #14,(A0)
                    7267   ; break;
000027E6  6012      7268          bra.s     OSMboxPend_11
                    7269   OSMboxPend_14:
                    7270   ; case OS_STAT_PEND_TO:
                    7271   ; default:
                    7272   ; OS_EventTaskRemove(OSTCBCur, pevent);
000027E8  2F04      7273          move.l    D4,-(A7)
000027EA  2F12      7274          move.l    (A2),-(A7)
000027EC  4EB8 12DE 7275          jsr       _OS_EventTaskRemove
000027F0  504F      7276          addq.w    #8,A7
                    7277   ; pmsg = (void *)0;
000027F2  4282      7278          clr.l     D2
                    7279   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
000027F4  2043      7280          move.l    D3,A0
000027F6  10BC 000A 7281          move.b    #10,(A0)
                    7282   ; break;
                    7283   OSMboxPend_11:
                    7284   ; }
                    7285   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
000027FA  2052      7286          move.l    (A2),A0
000027FC  4228 0032 7287          clr.b     50(A0)
                    7288   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00002800  2052      7289          move.l    (A2),A0
00002802  4228 0033 7290          clr.b     51(A0)
                    7291   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002806  2052      7292          move.l    (A2),A0
00002808  42A8 001C 7293          clr.l     28(A0)
                    7294   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7295   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000280C  2052      7296          move.l    (A2),A0
0000280E  42A8 0020 7297          clr.l     32(A0)
                    7298   ; #endif
                    7299   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002812  2052      7300          move.l    (A2),A0
00002814  42A8 0024 7301          clr.l     36(A0)
                    7302   ; OS_EXIT_CRITICAL();
00002818  46DF      7303          dc.w      18143
                    7304   ; return (pmsg);                                    /* Return received message                       */
0000281A  2002      7305          move.l    D2,D0
                    7306   OSMboxPend_3:
0000281C  4CDF 041C 7307          movem.l   (A7)+,D2/D3/D4/A2
00002820  4E5E      7308          unlk      A6
00002822  4E75      7309          rts
                    7310   ; }
                    7311   ; /*$PAGE*/
                    7312   ; /*
                    7313   ; *********************************************************************************************************
                    7314   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7315   ; *
                    7316   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7317   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7318   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7319   ; *
                    7320   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7321   ; *
                    7322   ; *              opt           determines the type of ABORT performed:
                    7323   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7324   ; *                                                     mailbox
                    7325   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7326   ; *                                                     mailbox
                    7327   ; *
                    7328   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7329   ; *                            messages are:
                    7330   ; *
                    7331   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7332   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7333   ; *                                                and informed of the aborted wait; check return value
                    7334   ; *                                                for the number of tasks whose wait on the mailbox
                    7335   ; *                                                was aborted.
                    7336   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7337   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7338   ; *
                    7339   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7340   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7341   ; *********************************************************************************************************
                    7342   ; */
                    7343   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7344   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7345   ; INT8U      opt,
                    7346   ; INT8U     *perr)
                    7347   ; {
                    7348   _OSMboxPendAbort:
00002824  4E56 0000 7349          link      A6,#0
00002828  48E7 3800 7350          movem.l   D2/D3/D4,-(A7)
0000282C  242E 0008 7351          move.l    8(A6),D2
00002830  282E 0010 7352          move.l    16(A6),D4
                    7353   ; INT8U      nbr_tasks;
                    7354   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7355   ; OS_CPU_SR  cpu_sr = 0u;
                    7356   ; #endif
                    7357   ; #ifdef OS_SAFETY_CRITICAL
                    7358   ; if (perr == (INT8U *)0) {
                    7359   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7360   ; return (0u);
                    7361   ; }
                    7362   ; #endif
                    7363   ; #if OS_ARG_CHK_EN > 0u
                    7364   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7365   ; *perr = OS_ERR_PEVENT_NULL;
                    7366   ; return (0u);
                    7367   ; }
                    7368   ; #endif
                    7369   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002834  2042      7370          move.l    D2,A0
00002836  1010      7371          move.b    (A0),D0
00002838  0C00 0001 7372          cmp.b     #1,D0
0000283C  670C      7373          beq.s     OSMboxPendAbort_1
                    7374   ; *perr = OS_ERR_EVENT_TYPE;
0000283E  2044      7375          move.l    D4,A0
00002840  10BC 0001 7376          move.b    #1,(A0)
                    7377   ; return (0u);
00002844  4200      7378          clr.b     D0
00002846  6000 008C 7379          bra       OSMboxPendAbort_3
                    7380   OSMboxPendAbort_1:
                    7381   ; }
                    7382   ; OS_ENTER_CRITICAL();
0000284A  40E7      7383          dc.w      16615
0000284C  007C      7384          dc.w      124
0000284E  0700      7385          dc.w      1792
                    7386   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
00002850  2042      7387          move.l    D2,A0
00002852  1028 0008 7388          move.b    8(A0),D0
00002856  6700 0074 7389          beq       OSMboxPendAbort_4
                    7390   ; nbr_tasks = 0u;
0000285A  4203      7391          clr.b     D3
                    7392   ; switch (opt) {
0000285C  102E 000F 7393          move.b    15(A6),D0
00002860  C0BC 0000 7394          and.l     #255,D0
00002864  00FF      
00002866  0C80 0000 7395          cmp.l     #1,D0
0000286A  0001      
0000286C  670A      7396          beq.s     OSMboxPendAbort_8
0000286E  6200 0030 7397          bhi       OSMboxPendAbort_9
00002872  4A80      7398          tst.l     D0
00002874  672A      7399          beq.s     OSMboxPendAbort_9
00002876  6028      7400          bra.s     OSMboxPendAbort_9
                    7401   OSMboxPendAbort_8:
                    7402   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7403   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7404   OSMboxPendAbort_11:
00002878  2042      7405          move.l    D2,A0
0000287A  1028 0008 7406          move.b    8(A0),D0
0000287E  671E      7407          beq.s     OSMboxPendAbort_13
                    7408   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002880  4878 0002 7409          pea       2
00002884  4878 0002 7410          pea       2
00002888  42A7      7411          clr.l     -(A7)
0000288A  2F02      7412          move.l    D2,-(A7)
0000288C  4EB8 10D8 7413          jsr       _OS_EventTaskRdy
00002890  DEFC 0010 7414          add.w     #16,A7
00002894  C0BC 0000 7415          and.l     #255,D0
00002898  00FF      
                    7416   ; nbr_tasks++;
0000289A  5203      7417          addq.b    #1,D3
0000289C  60DA      7418          bra       OSMboxPendAbort_11
                    7419   OSMboxPendAbort_13:
                    7420   ; }
                    7421   ; break;
0000289E  601C      7422          bra.s     OSMboxPendAbort_7
                    7423   OSMboxPendAbort_9:
                    7424   ; case OS_PEND_OPT_NONE:
                    7425   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7426   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000028A0  4878 0002 7427          pea       2
000028A4  4878 0002 7428          pea       2
000028A8  42A7      7429          clr.l     -(A7)
000028AA  2F02      7430          move.l    D2,-(A7)
000028AC  4EB8 10D8 7431          jsr       _OS_EventTaskRdy
000028B0  DEFC 0010 7432          add.w     #16,A7
000028B4  C0BC 0000 7433          and.l     #255,D0
000028B8  00FF      
                    7434   ; nbr_tasks++;
000028BA  5203      7435          addq.b    #1,D3
                    7436   ; break;
                    7437   OSMboxPendAbort_7:
                    7438   ; }
                    7439   ; OS_EXIT_CRITICAL();
000028BC  46DF      7440          dc.w      18143
                    7441   ; OS_Sched();                                        /* Find HPT ready to run                    */
000028BE  4EB8 16B8 7442          jsr       _OS_Sched
                    7443   ; *perr = OS_ERR_PEND_ABORT;
000028C2  2044      7444          move.l    D4,A0
000028C4  10BC 000E 7445          move.b    #14,(A0)
                    7446   ; return (nbr_tasks);
000028C8  1003      7447          move.b    D3,D0
000028CA  6008      7448          bra.s     OSMboxPendAbort_3
                    7449   OSMboxPendAbort_4:
                    7450   ; }
                    7451   ; OS_EXIT_CRITICAL();
000028CC  46DF      7452          dc.w      18143
                    7453   ; *perr = OS_ERR_NONE;
000028CE  2044      7454          move.l    D4,A0
000028D0  4210      7455          clr.b     (A0)
                    7456   ; return (0u);                                           /* No tasks waiting on mailbox              */
000028D2  4200      7457          clr.b     D0
                    7458   OSMboxPendAbort_3:
000028D4  4CDF 001C 7459          movem.l   (A7)+,D2/D3/D4
000028D8  4E5E      7460          unlk      A6
000028DA  4E75      7461          rts
                    7462   ; }
                    7463   ; #endif
                    7464   ; /*$PAGE*/
                    7465   ; /*
                    7466   ; *********************************************************************************************************
                    7467   ; *                                      POST MESSAGE TO A MAILBOX
                    7468   ; *
                    7469   ; * Description: This function sends a message to a mailbox
                    7470   ; *
                    7471   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7472   ; *
                    7473   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7474   ; *
                    7475   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7476   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7477   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7478   ; *                                   are allowed to send another one.
                    7479   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7480   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7481   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7482   ; *
                    7483   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7484   ; *********************************************************************************************************
                    7485   ; */
                    7486   ; #if OS_MBOX_POST_EN > 0u
                    7487   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7488   ; void      *pmsg)
                    7489   ; {
                    7490   _OSMboxPost:
000028DC  4E56 0000 7491          link      A6,#0
000028E0  2F02      7492          move.l    D2,-(A7)
000028E2  242E 0008 7493          move.l    8(A6),D2
                    7494   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7495   ; OS_CPU_SR  cpu_sr = 0u;
                    7496   ; #endif
                    7497   ; #if OS_ARG_CHK_EN > 0u
                    7498   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7499   ; return (OS_ERR_PEVENT_NULL);
                    7500   ; }
                    7501   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7502   ; return (OS_ERR_POST_NULL_PTR);
                    7503   ; }
                    7504   ; #endif
                    7505   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000028E6  2042      7506          move.l    D2,A0
000028E8  1010      7507          move.b    (A0),D0
000028EA  0C00 0001 7508          cmp.b     #1,D0
000028EE  6706      7509          beq.s     OSMboxPost_1
                    7510   ; return (OS_ERR_EVENT_TYPE);
000028F0  7001      7511          moveq     #1,D0
000028F2  6000 004E 7512          bra       OSMboxPost_3
                    7513   OSMboxPost_1:
                    7514   ; }
                    7515   ; OS_ENTER_CRITICAL();
000028F6  40E7      7516          dc.w      16615
000028F8  007C      7517          dc.w      124
000028FA  0700      7518          dc.w      1792
                    7519   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
000028FC  2042      7520          move.l    D2,A0
000028FE  1028 0008 7521          move.b    8(A0),D0
00002902  6724      7522          beq.s     OSMboxPost_4
                    7523   ; /* Ready HPT waiting on event                    */
                    7524   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002904  42A7      7525          clr.l     -(A7)
00002906  4878 0002 7526          pea       2
0000290A  2F2E 000C 7527          move.l    12(A6),-(A7)
0000290E  2F02      7528          move.l    D2,-(A7)
00002910  4EB8 10D8 7529          jsr       _OS_EventTaskRdy
00002914  DEFC 0010 7530          add.w     #16,A7
00002918  C0BC 0000 7531          and.l     #255,D0
0000291C  00FF      
                    7532   ; OS_EXIT_CRITICAL();
0000291E  46DF      7533          dc.w      18143
                    7534   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002920  4EB8 16B8 7535          jsr       _OS_Sched
                    7536   ; return (OS_ERR_NONE);
00002924  4200      7537          clr.b     D0
00002926  601A      7538          bra.s     OSMboxPost_3
                    7539   OSMboxPost_4:
                    7540   ; }
                    7541   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002928  2042      7542          move.l    D2,A0
0000292A  2028 0002 7543          move.l    2(A0),D0
0000292E  6706      7544          beq.s     OSMboxPost_6
                    7545   ; OS_EXIT_CRITICAL();
00002930  46DF      7546          dc.w      18143
                    7547   ; return (OS_ERR_MBOX_FULL);
00002932  7014      7548          moveq     #20,D0
00002934  600C      7549          bra.s     OSMboxPost_3
                    7550   OSMboxPost_6:
                    7551   ; }
                    7552   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002936  2042      7553          move.l    D2,A0
00002938  216E 000C 7554          move.l    12(A6),2(A0)
0000293C  0002      
                    7555   ; OS_EXIT_CRITICAL();
0000293E  46DF      7556          dc.w      18143
                    7557   ; return (OS_ERR_NONE);
00002940  4200      7558          clr.b     D0
                    7559   OSMboxPost_3:
00002942  241F      7560          move.l    (A7)+,D2
00002944  4E5E      7561          unlk      A6
00002946  4E75      7562          rts
                    7563   ; }
                    7564   ; #endif
                    7565   ; /*$PAGE*/
                    7566   ; /*
                    7567   ; *********************************************************************************************************
                    7568   ; *                                      POST MESSAGE TO A MAILBOX
                    7569   ; *
                    7570   ; * Description: This function sends a message to a mailbox
                    7571   ; *
                    7572   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7573   ; *
                    7574   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7575   ; *
                    7576   ; *              opt           determines the type of POST performed:
                    7577   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7578   ; *                                                     (Identical to OSMboxPost())
                    7579   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7580   ; *
                    7581   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7582   ; *
                    7583   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7584   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7585   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7586   ; *                                   are allowed to send another one.
                    7587   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7588   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7589   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7590   ; *
                    7591   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7592   ; *
                    7593   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7594   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7595   ; *********************************************************************************************************
                    7596   ; */
                    7597   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7598   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7599   ; void      *pmsg,
                    7600   ; INT8U      opt)
                    7601   ; {
                    7602   _OSMboxPostOpt:
00002948  4E56 0000 7603          link      A6,#0
0000294C  48E7 3000 7604          movem.l   D2/D3,-(A7)
00002950  242E 0008 7605          move.l    8(A6),D2
00002954  262E 000C 7606          move.l    12(A6),D3
                    7607   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7608   ; OS_CPU_SR  cpu_sr = 0u;
                    7609   ; #endif
                    7610   ; #if OS_ARG_CHK_EN > 0u
                    7611   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7612   ; return (OS_ERR_PEVENT_NULL);
                    7613   ; }
                    7614   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7615   ; return (OS_ERR_POST_NULL_PTR);
                    7616   ; }
                    7617   ; #endif
                    7618   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002958  2042      7619          move.l    D2,A0
0000295A  1010      7620          move.b    (A0),D0
0000295C  0C00 0001 7621          cmp.b     #1,D0
00002960  6706      7622          beq.s     OSMboxPostOpt_1
                    7623   ; return (OS_ERR_EVENT_TYPE);
00002962  7001      7624          moveq     #1,D0
00002964  6000 0084 7625          bra       OSMboxPostOpt_3
                    7626   OSMboxPostOpt_1:
                    7627   ; }
                    7628   ; OS_ENTER_CRITICAL();
00002968  40E7      7629          dc.w      16615
0000296A  007C      7630          dc.w      124
0000296C  0700      7631          dc.w      1792
                    7632   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
0000296E  2042      7633          move.l    D2,A0
00002970  1028 0008 7634          move.b    8(A0),D0
00002974  6700 005C 7635          beq       OSMboxPostOpt_4
                    7636   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00002978  102E 0013 7637          move.b    19(A6),D0
0000297C  C03C 0001 7638          and.b     #1,D0
00002980  6724      7639          beq.s     OSMboxPostOpt_6
                    7640   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7641   OSMboxPostOpt_8:
00002982  2042      7642          move.l    D2,A0
00002984  1028 0008 7643          move.b    8(A0),D0
00002988  671A      7644          beq.s     OSMboxPostOpt_10
                    7645   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
0000298A  42A7      7646          clr.l     -(A7)
0000298C  4878 0002 7647          pea       2
00002990  2F03      7648          move.l    D3,-(A7)
00002992  2F02      7649          move.l    D2,-(A7)
00002994  4EB8 10D8 7650          jsr       _OS_EventTaskRdy
00002998  DEFC 0010 7651          add.w     #16,A7
0000299C  C0BC 0000 7652          and.l     #255,D0
000029A0  00FF      
000029A2  60DE      7653          bra       OSMboxPostOpt_8
                    7654   OSMboxPostOpt_10:
000029A4  6018      7655          bra.s     OSMboxPostOpt_7
                    7656   OSMboxPostOpt_6:
                    7657   ; }
                    7658   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7659   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
000029A6  42A7      7660          clr.l     -(A7)
000029A8  4878 0002 7661          pea       2
000029AC  2F03      7662          move.l    D3,-(A7)
000029AE  2F02      7663          move.l    D2,-(A7)
000029B0  4EB8 10D8 7664          jsr       _OS_EventTaskRdy
000029B4  DEFC 0010 7665          add.w     #16,A7
000029B8  C0BC 0000 7666          and.l     #255,D0
000029BC  00FF      
                    7667   OSMboxPostOpt_7:
                    7668   ; }
                    7669   ; OS_EXIT_CRITICAL();
000029BE  46DF      7670          dc.w      18143
                    7671   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
000029C0  102E 0013 7672          move.b    19(A6),D0
000029C4  C03C 0004 7673          and.b     #4,D0
000029C8  6604      7674          bne.s     OSMboxPostOpt_11
                    7675   ; OS_Sched();                               /* Find HPT ready to run                         */
000029CA  4EB8 16B8 7676          jsr       _OS_Sched
                    7677   OSMboxPostOpt_11:
                    7678   ; }
                    7679   ; return (OS_ERR_NONE);
000029CE  4200      7680          clr.b     D0
000029D0  6018      7681          bra.s     OSMboxPostOpt_3
                    7682   OSMboxPostOpt_4:
                    7683   ; }
                    7684   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
000029D2  2042      7685          move.l    D2,A0
000029D4  2028 0002 7686          move.l    2(A0),D0
000029D8  6706      7687          beq.s     OSMboxPostOpt_13
                    7688   ; OS_EXIT_CRITICAL();
000029DA  46DF      7689          dc.w      18143
                    7690   ; return (OS_ERR_MBOX_FULL);
000029DC  7014      7691          moveq     #20,D0
000029DE  600A      7692          bra.s     OSMboxPostOpt_3
                    7693   OSMboxPostOpt_13:
                    7694   ; }
                    7695   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
000029E0  2042      7696          move.l    D2,A0
000029E2  2143 0002 7697          move.l    D3,2(A0)
                    7698   ; OS_EXIT_CRITICAL();
000029E6  46DF      7699          dc.w      18143
                    7700   ; return (OS_ERR_NONE);
000029E8  4200      7701          clr.b     D0
                    7702   OSMboxPostOpt_3:
000029EA  4CDF 000C 7703          movem.l   (A7)+,D2/D3
000029EE  4E5E      7704          unlk      A6
000029F0  4E75      7705          rts
                    7706   ; }
                    7707   ; #endif
                    7708   ; /*$PAGE*/
                    7709   ; /*
                    7710   ; *********************************************************************************************************
                    7711   ; *                                       QUERY A MESSAGE MAILBOX
                    7712   ; *
                    7713   ; * Description: This function obtains information about a message mailbox.
                    7714   ; *
                    7715   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7716   ; *
                    7717   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7718   ; *                            mailbox.
                    7719   ; *
                    7720   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7721   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7722   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7723   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7724   ; *********************************************************************************************************
                    7725   ; */
                    7726   ; #if OS_MBOX_QUERY_EN > 0u
                    7727   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7728   ; OS_MBOX_DATA  *p_mbox_data)
                    7729   ; {
                    7730   _OSMboxQuery:
000029F2  4E56 FFF8 7731          link      A6,#-8
000029F6  48E7 3800 7732          movem.l   D2/D3/D4,-(A7)
000029FA  242E 0008 7733          move.l    8(A6),D2
000029FE  282E 000C 7734          move.l    12(A6),D4
                    7735   ; INT8U       i;
                    7736   ; OS_PRIO    *psrc;
                    7737   ; OS_PRIO    *pdest;
                    7738   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7739   ; OS_CPU_SR   cpu_sr = 0u;
                    7740   ; #endif
                    7741   ; #if OS_ARG_CHK_EN > 0u
                    7742   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7743   ; return (OS_ERR_PEVENT_NULL);
                    7744   ; }
                    7745   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7746   ; return (OS_ERR_PDATA_NULL);
                    7747   ; }
                    7748   ; #endif
                    7749   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002A02  2042      7750          move.l    D2,A0
00002A04  1010      7751          move.b    (A0),D0
00002A06  0C00 0001 7752          cmp.b     #1,D0
00002A0A  6706      7753          beq.s     OSMboxQuery_1
                    7754   ; return (OS_ERR_EVENT_TYPE);
00002A0C  7001      7755          moveq     #1,D0
00002A0E  6000 004C 7756          bra       OSMboxQuery_3
                    7757   OSMboxQuery_1:
                    7758   ; }
                    7759   ; OS_ENTER_CRITICAL();
00002A12  40E7      7760          dc.w      16615
00002A14  007C      7761          dc.w      124
00002A16  0700      7762          dc.w      1792
                    7763   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
00002A18  2042      7764          move.l    D2,A0
00002A1A  2244      7765          move.l    D4,A1
00002A1C  1368 0008 7766          move.b    8(A0),12(A1)
00002A20  000C      
                    7767   ; psrc                    = &pevent->OSEventTbl[0];
00002A22  700A      7768          moveq     #10,D0
00002A24  D082      7769          add.l     D2,D0
00002A26  2D40 FFF8 7770          move.l    D0,-8(A6)
                    7771   ; pdest                   = &p_mbox_data->OSEventTbl[0];
00002A2A  7004      7772          moveq     #4,D0
00002A2C  D084      7773          add.l     D4,D0
00002A2E  2D40 FFFC 7774          move.l    D0,-4(A6)
                    7775   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002A32  4203      7776          clr.b     D3
                    7777   OSMboxQuery_4:
00002A34  0C03 0008 7778          cmp.b     #8,D3
00002A38  6416      7779          bhs.s     OSMboxQuery_6
                    7780   ; *pdest++ = *psrc++;
00002A3A  206E FFF8 7781          move.l    -8(A6),A0
00002A3E  52AE FFF8 7782          addq.l    #1,-8(A6)
00002A42  226E FFFC 7783          move.l    -4(A6),A1
00002A46  52AE FFFC 7784          addq.l    #1,-4(A6)
00002A4A  1290      7785          move.b    (A0),(A1)
00002A4C  5203      7786          addq.b    #1,D3
00002A4E  60E4      7787          bra       OSMboxQuery_4
                    7788   OSMboxQuery_6:
                    7789   ; }
                    7790   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002A50  2042      7791          move.l    D2,A0
00002A52  2244      7792          move.l    D4,A1
00002A54  22A8 0002 7793          move.l    2(A0),(A1)
                    7794   ; OS_EXIT_CRITICAL();
00002A58  46DF      7795          dc.w      18143
                    7796   ; return (OS_ERR_NONE);
00002A5A  4200      7797          clr.b     D0
                    7798   OSMboxQuery_3:
00002A5C  4CDF 001C 7799          movem.l   (A7)+,D2/D3/D4
00002A60  4E5E      7800          unlk      A6
00002A62  4E75      7801          rts
                    7802   ; /*
                    7803   ; *********************************************************************************************************
                    7804   ; *                                                uC/OS-II
                    7805   ; *                                          The Real-Time Kernel
                    7806   ; *                                            MEMORY MANAGEMENT
                    7807   ; *
                    7808   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7809   ; *                                           All Rights Reserved
                    7810   ; *
                    7811   ; * File    : OS_MEM.C
                    7812   ; * By      : Jean J. Labrosse
                    7813   ; * Version : V2.92.07
                    7814   ; *
                    7815   ; * LICENSING TERMS:
                    7816   ; * ---------------
                    7817   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7818   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7819   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7820   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7821   ; * licensing fee.
                    7822   ; *********************************************************************************************************
                    7823   ; */
                    7824   ; #define  MICRIUM_SOURCE
                    7825   ; #ifndef  OS_MASTER_FILE
                    7826   ; #include <ucos_ii.h>
                    7827   ; #endif
                    7828   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    7829   ; /*
                    7830   ; *********************************************************************************************************
                    7831   ; *                                      CREATE A MEMORY PARTITION
                    7832   ; *
                    7833   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    7834   ; *
                    7835   ; * Arguments   : addr     is the starting address of the memory partition
                    7836   ; *
                    7837   ; *               nblks    is the number of memory blocks to create from the partition.
                    7838   ; *
                    7839   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    7840   ; *
                    7841   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    7842   ; *                        this function to either:
                    7843   ; *
                    7844   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    7845   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    7846   ; *                                                 storage of the partition or, the block does not align
                    7847   ; *                                                 on a pointer boundary
                    7848   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    7849   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    7850   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    7851   ; *                                                   - must be greater than the size of a pointer
                    7852   ; *                                                   - must be able to hold an integral number of pointers
                    7853   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    7854   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    7855   ; *                              free partition is available.
                    7856   ; *********************************************************************************************************
                    7857   ; */
                    7858   ; OS_MEM  *OSMemCreate (void   *addr,
                    7859   ; INT32U  nblks,
                    7860   ; INT32U  blksize,
                    7861   ; INT8U  *perr)
                    7862   ; {
                    7863   _OSMemCreate:
00002A64  4E56 FFFC 7864          link      A6,#-4
00002A68  48E7 3F20 7865          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002A6C  282E 0008 7866          move.l    8(A6),D4
00002A70  45F9 0800 7867          lea       _OSMemFreeList.L,A2
00002A74  0DB4      
00002A76  2E2E 000C 7868          move.l    12(A6),D7
                    7869   ; OS_MEM    *pmem;
                    7870   ; INT8U     *pblk;
                    7871   ; void     **plink;
                    7872   ; INT32U     loops;
                    7873   ; INT32U     i;
                    7874   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7875   ; OS_CPU_SR  cpu_sr = 0u;
                    7876   ; #endif
                    7877   ; #ifdef OS_SAFETY_CRITICAL
                    7878   ; if (perr == (INT8U *)0) {
                    7879   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7880   ; return ((OS_MEM *)0);
                    7881   ; }
                    7882   ; #endif
                    7883   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7884   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7885   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7886   ; return ((OS_MEM *)0);
                    7887   ; }
                    7888   ; #endif
                    7889   ; #if OS_ARG_CHK_EN > 0u
                    7890   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    7891   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7892   ; return ((OS_MEM *)0);
                    7893   ; }
                    7894   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    7895   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7896   ; return ((OS_MEM *)0);
                    7897   ; }
                    7898   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    7899   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    7900   ; return ((OS_MEM *)0);
                    7901   ; }
                    7902   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    7903   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    7904   ; return ((OS_MEM *)0);
                    7905   ; }
                    7906   ; #endif
                    7907   ; OS_ENTER_CRITICAL();
00002A7A  40E7      7908          dc.w      16615
00002A7C  007C      7909          dc.w      124
00002A7E  0700      7910          dc.w      1792
                    7911   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
00002A80  2412      7912          move.l    (A2),D2
                    7913   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
00002A82  2012      7914          move.l    (A2),D0
00002A84  6706      7915          beq.s     OSMemCreate_1
                    7916   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
00002A86  2052      7917          move.l    (A2),A0
00002A88  24A8 0004 7918          move.l    4(A0),(A2)
                    7919   OSMemCreate_1:
                    7920   ; }
                    7921   ; OS_EXIT_CRITICAL();
00002A8C  46DF      7922          dc.w      18143
                    7923   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
00002A8E  4A82      7924          tst.l     D2
00002A90  660E      7925          bne.s     OSMemCreate_3
                    7926   ; *perr = OS_ERR_MEM_INVALID_PART;
00002A92  206E 0014 7927          move.l    20(A6),A0
00002A96  10BC 005A 7928          move.b    #90,(A0)
                    7929   ; return ((OS_MEM *)0);
00002A9A  4280      7930          clr.l     D0
00002A9C  6000 0050 7931          bra       OSMemCreate_5
                    7932   OSMemCreate_3:
                    7933   ; }
                    7934   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
00002AA0  2A04      7935          move.l    D4,D5
                    7936   ; pblk  = (INT8U *)addr;
00002AA2  2604      7937          move.l    D4,D3
                    7938   ; loops  = nblks - 1u;
00002AA4  2007      7939          move.l    D7,D0
00002AA6  5380      7940          subq.l    #1,D0
00002AA8  2D40 FFFC 7941          move.l    D0,-4(A6)
                    7942   ; for (i = 0u; i < loops; i++) {
00002AAC  4286      7943          clr.l     D6
                    7944   OSMemCreate_6:
00002AAE  BCAE FFFC 7945          cmp.l     -4(A6),D6
00002AB2  6410      7946          bhs.s     OSMemCreate_8
                    7947   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
00002AB4  202E 0010 7948          move.l    16(A6),D0
00002AB8  D680      7949          add.l     D0,D3
                    7950   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
00002ABA  2045      7951          move.l    D5,A0
00002ABC  2083      7952          move.l    D3,(A0)
                    7953   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
00002ABE  2A03      7954          move.l    D3,D5
00002AC0  5286      7955          addq.l    #1,D6
00002AC2  60EA      7956          bra       OSMemCreate_6
                    7957   OSMemCreate_8:
                    7958   ; }
                    7959   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
00002AC4  2045      7960          move.l    D5,A0
00002AC6  4290      7961          clr.l     (A0)
                    7962   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
00002AC8  2042      7963          move.l    D2,A0
00002ACA  2084      7964          move.l    D4,(A0)
                    7965   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
00002ACC  2042      7966          move.l    D2,A0
00002ACE  2144 0004 7967          move.l    D4,4(A0)
                    7968   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
00002AD2  2042      7969          move.l    D2,A0
00002AD4  2147 0010 7970          move.l    D7,16(A0)
                    7971   ; pmem->OSMemNBlks    = nblks;
00002AD8  2042      7972          move.l    D2,A0
00002ADA  2147 000C 7973          move.l    D7,12(A0)
                    7974   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
00002ADE  2042      7975          move.l    D2,A0
00002AE0  216E 0010 7976          move.l    16(A6),8(A0)
00002AE4  0008      
                    7977   ; *perr               = OS_ERR_NONE;
00002AE6  206E 0014 7978          move.l    20(A6),A0
00002AEA  4210      7979          clr.b     (A0)
                    7980   ; return (pmem);
00002AEC  2002      7981          move.l    D2,D0
                    7982   OSMemCreate_5:
00002AEE  4CDF 04FC 7983          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002AF2  4E5E      7984          unlk      A6
00002AF4  4E75      7985          rts
                    7986   ; }
                    7987   ; /*$PAGE*/
                    7988   ; /*
                    7989   ; *********************************************************************************************************
                    7990   ; *                                         GET A MEMORY BLOCK
                    7991   ; *
                    7992   ; * Description : Get a memory block from a partition
                    7993   ; *
                    7994   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    7995   ; *
                    7996   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    7997   ; *                       function to either:
                    7998   ; *
                    7999   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    8000   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    8001   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    8002   ; *
                    8003   ; * Returns     : A pointer to a memory block if no error is detected
                    8004   ; *               A pointer to NULL if an error is detected
                    8005   ; *********************************************************************************************************
                    8006   ; */
                    8007   ; void  *OSMemGet (OS_MEM  *pmem,
                    8008   ; INT8U   *perr)
                    8009   ; {
                    8010   _OSMemGet:
00002AF6  4E56 0000 8011          link      A6,#0
00002AFA  48E7 3000 8012          movem.l   D2/D3,-(A7)
00002AFE  242E 0008 8013          move.l    8(A6),D2
                    8014   ; void      *pblk;
                    8015   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8016   ; OS_CPU_SR  cpu_sr = 0u;
                    8017   ; #endif
                    8018   ; #ifdef OS_SAFETY_CRITICAL
                    8019   ; if (perr == (INT8U *)0) {
                    8020   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8021   ; return ((void *)0);
                    8022   ; }
                    8023   ; #endif
                    8024   ; #if OS_ARG_CHK_EN > 0u
                    8025   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    8026   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8027   ; return ((void *)0);
                    8028   ; }
                    8029   ; #endif
                    8030   ; OS_ENTER_CRITICAL();
00002B02  40E7      8031          dc.w      16615
00002B04  007C      8032          dc.w      124
00002B06  0700      8033          dc.w      1792
                    8034   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002B08  2042      8035          move.l    D2,A0
00002B0A  2028 0010 8036          move.l    16(A0),D0
00002B0E  0C80 0000 8037          cmp.l     #0,D0
00002B12  0000      
00002B14  6326      8038          bls.s     OSMemGet_1
                    8039   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002B16  2042      8040          move.l    D2,A0
00002B18  2628 0004 8041          move.l    4(A0),D3
                    8042   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
00002B1C  2043      8043          move.l    D3,A0
00002B1E  2242      8044          move.l    D2,A1
00002B20  2350 0004 8045          move.l    (A0),4(A1)
                    8046   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002B24  2002      8047          move.l    D2,D0
00002B26  0680 0000 8048          add.l     #16,D0
00002B2A  0010      
00002B2C  2040      8049          move.l    D0,A0
00002B2E  5390      8050          subq.l    #1,(A0)
                    8051   ; OS_EXIT_CRITICAL();
00002B30  46DF      8052          dc.w      18143
                    8053   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002B32  206E 000C 8054          move.l    12(A6),A0
00002B36  4210      8055          clr.b     (A0)
                    8056   ; return (pblk);                                /*      Return memory block to caller            */
00002B38  2003      8057          move.l    D3,D0
00002B3A  600C      8058          bra.s     OSMemGet_3
                    8059   OSMemGet_1:
                    8060   ; }
                    8061   ; OS_EXIT_CRITICAL();
00002B3C  46DF      8062          dc.w      18143
                    8063   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
00002B3E  206E 000C 8064          move.l    12(A6),A0
00002B42  10BC 005D 8065          move.b    #93,(A0)
                    8066   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002B46  4280      8067          clr.l     D0
                    8068   OSMemGet_3:
00002B48  4CDF 000C 8069          movem.l   (A7)+,D2/D3
00002B4C  4E5E      8070          unlk      A6
00002B4E  4E75      8071          rts
                    8072   ; }
                    8073   ; /*$PAGE*/
                    8074   ; /*
                    8075   ; *********************************************************************************************************
                    8076   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    8077   ; *
                    8078   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    8079   ; *
                    8080   ; * Arguments  : pmem      is a pointer to the memory partition
                    8081   ; *
                    8082   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    8083   ; *
                    8084   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8085   ; *
                    8086   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8087   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8088   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8089   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    8090   ; *
                    8091   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    8092   ; *********************************************************************************************************
                    8093   ; */
                    8094   ; #if OS_MEM_NAME_EN > 0u
                    8095   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    8096   ; INT8U   **pname,
                    8097   ; INT8U    *perr)
                    8098   ; {
                    8099   _OSMemNameGet:
00002B50  4E56 FFFC 8100          link      A6,#-4
                    8101   ; INT8U      len;
                    8102   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8103   ; OS_CPU_SR  cpu_sr = 0u;
                    8104   ; #endif
                    8105   ; #ifdef OS_SAFETY_CRITICAL
                    8106   ; if (perr == (INT8U *)0) {
                    8107   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8108   ; return (0u);
                    8109   ; }
                    8110   ; #endif
                    8111   ; #if OS_ARG_CHK_EN > 0u
                    8112   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8113   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8114   ; return (0u);
                    8115   ; }
                    8116   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    8117   ; *perr = OS_ERR_PNAME_NULL;
                    8118   ; return (0u);
                    8119   ; }
                    8120   ; #endif
                    8121   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002B54  1039 0800 8122          move.b    _OSIntNesting.L,D0
00002B58  0426      
00002B5A  0C00 0000 8123          cmp.b     #0,D0
00002B5E  630C      8124          bls.s     OSMemNameGet_1
                    8125   ; *perr = OS_ERR_NAME_GET_ISR;
00002B60  206E 0010 8126          move.l    16(A6),A0
00002B64  10BC 0011 8127          move.b    #17,(A0)
                    8128   ; return (0u);
00002B68  4200      8129          clr.b     D0
00002B6A  602E      8130          bra.s     OSMemNameGet_3
                    8131   OSMemNameGet_1:
                    8132   ; }
                    8133   ; OS_ENTER_CRITICAL();
00002B6C  40E7      8134          dc.w      16615
00002B6E  007C      8135          dc.w      124
00002B70  0700      8136          dc.w      1792
                    8137   ; *pname = pmem->OSMemName;
00002B72  206E 0008 8138          move.l    8(A6),A0
00002B76  226E 000C 8139          move.l    12(A6),A1
00002B7A  22A8 0014 8140          move.l    20(A0),(A1)
                    8141   ; len    = OS_StrLen(*pname);
00002B7E  206E 000C 8142          move.l    12(A6),A0
00002B82  2F10      8143          move.l    (A0),-(A7)
00002B84  4EB8 1762 8144          jsr       _OS_StrLen
00002B88  584F      8145          addq.w    #4,A7
00002B8A  1D40 FFFF 8146          move.b    D0,-1(A6)
                    8147   ; OS_EXIT_CRITICAL();
00002B8E  46DF      8148          dc.w      18143
                    8149   ; *perr  = OS_ERR_NONE;
00002B90  206E 0010 8150          move.l    16(A6),A0
00002B94  4210      8151          clr.b     (A0)
                    8152   ; return (len);
00002B96  102E FFFF 8153          move.b    -1(A6),D0
                    8154   OSMemNameGet_3:
00002B9A  4E5E      8155          unlk      A6
00002B9C  4E75      8156          rts
                    8157   ; }
                    8158   ; #endif
                    8159   ; /*$PAGE*/
                    8160   ; /*
                    8161   ; *********************************************************************************************************
                    8162   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8163   ; *
                    8164   ; * Description: This function assigns a name to a memory partition.
                    8165   ; *
                    8166   ; * Arguments  : pmem      is a pointer to the memory partition
                    8167   ; *
                    8168   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8169   ; *
                    8170   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8171   ; *
                    8172   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8173   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8174   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8175   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8176   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8177   ; *
                    8178   ; * Returns    : None
                    8179   ; *********************************************************************************************************
                    8180   ; */
                    8181   ; #if OS_MEM_NAME_EN > 0u
                    8182   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8183   ; INT8U   *pname,
                    8184   ; INT8U   *perr)
                    8185   ; {
                    8186   _OSMemNameSet:
00002B9E  4E56 0000 8187          link      A6,#0
                    8188   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8189   ; OS_CPU_SR  cpu_sr = 0u;
                    8190   ; #endif
                    8191   ; #ifdef OS_SAFETY_CRITICAL
                    8192   ; if (perr == (INT8U *)0) {
                    8193   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8194   ; return;
                    8195   ; }
                    8196   ; #endif
                    8197   ; #if OS_ARG_CHK_EN > 0u
                    8198   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8199   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8200   ; return;
                    8201   ; }
                    8202   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8203   ; *perr = OS_ERR_PNAME_NULL;
                    8204   ; return;
                    8205   ; }
                    8206   ; #endif
                    8207   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002BA2  1039 0800 8208          move.b    _OSIntNesting.L,D0
00002BA6  0426      
00002BA8  0C00 0000 8209          cmp.b     #0,D0
00002BAC  630A      8210          bls.s     OSMemNameSet_1
                    8211   ; *perr = OS_ERR_NAME_SET_ISR;
00002BAE  206E 0010 8212          move.l    16(A6),A0
00002BB2  10BC 0012 8213          move.b    #18,(A0)
                    8214   ; return;
00002BB6  6018      8215          bra.s     OSMemNameSet_3
                    8216   OSMemNameSet_1:
                    8217   ; }
                    8218   ; OS_ENTER_CRITICAL();
00002BB8  40E7      8219          dc.w      16615
00002BBA  007C      8220          dc.w      124
00002BBC  0700      8221          dc.w      1792
                    8222   ; pmem->OSMemName = pname;
00002BBE  206E 0008 8223          move.l    8(A6),A0
00002BC2  216E 000C 8224          move.l    12(A6),20(A0)
00002BC6  0014      
                    8225   ; OS_EXIT_CRITICAL();
00002BC8  46DF      8226          dc.w      18143
                    8227   ; *perr           = OS_ERR_NONE;
00002BCA  206E 0010 8228          move.l    16(A6),A0
00002BCE  4210      8229          clr.b     (A0)
                    8230   OSMemNameSet_3:
00002BD0  4E5E      8231          unlk      A6
00002BD2  4E75      8232          rts
                    8233   ; }
                    8234   ; #endif
                    8235   ; /*$PAGE*/
                    8236   ; /*
                    8237   ; *********************************************************************************************************
                    8238   ; *                                       RELEASE A MEMORY BLOCK
                    8239   ; *
                    8240   ; * Description : Returns a memory block to a partition
                    8241   ; *
                    8242   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8243   ; *
                    8244   ; *               pblk    is a pointer to the memory block being released.
                    8245   ; *
                    8246   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8247   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8248   ; *                                        partition (You freed more blocks than you allocated!)
                    8249   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8250   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8251   ; *********************************************************************************************************
                    8252   ; */
                    8253   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8254   ; void    *pblk)
                    8255   ; {
                    8256   _OSMemPut:
00002BD4  4E56 0000 8257          link      A6,#0
00002BD8  2F02      8258          move.l    D2,-(A7)
00002BDA  242E 0008 8259          move.l    8(A6),D2
                    8260   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8261   ; OS_CPU_SR  cpu_sr = 0u;
                    8262   ; #endif
                    8263   ; #if OS_ARG_CHK_EN > 0u
                    8264   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8265   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8266   ; }
                    8267   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8268   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8269   ; }
                    8270   ; #endif
                    8271   ; OS_ENTER_CRITICAL();
00002BDE  40E7      8272          dc.w      16615
00002BE0  007C      8273          dc.w      124
00002BE2  0700      8274          dc.w      1792
                    8275   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002BE4  2042      8276          move.l    D2,A0
00002BE6  2242      8277          move.l    D2,A1
00002BE8  2028 0010 8278          move.l    16(A0),D0
00002BEC  B0A9 000C 8279          cmp.l     12(A1),D0
00002BF0  6506      8280          blo.s     OSMemPut_1
                    8281   ; OS_EXIT_CRITICAL();
00002BF2  46DF      8282          dc.w      18143
                    8283   ; return (OS_ERR_MEM_FULL);
00002BF4  705E      8284          moveq     #94,D0
00002BF6  6024      8285          bra.s     OSMemPut_3
                    8286   OSMemPut_1:
                    8287   ; }
                    8288   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002BF8  2042      8289          move.l    D2,A0
00002BFA  202E 000C 8290          move.l    12(A6),D0
00002BFE  2240      8291          move.l    D0,A1
00002C00  22A8 0004 8292          move.l    4(A0),(A1)
                    8293   ; pmem->OSMemFreeList = pblk;
00002C04  2042      8294          move.l    D2,A0
00002C06  216E 000C 8295          move.l    12(A6),4(A0)
00002C0A  0004      
                    8296   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
00002C0C  2002      8297          move.l    D2,D0
00002C0E  0680 0000 8298          add.l     #16,D0
00002C12  0010      
00002C14  2040      8299          move.l    D0,A0
00002C16  5290      8300          addq.l    #1,(A0)
                    8301   ; OS_EXIT_CRITICAL();
00002C18  46DF      8302          dc.w      18143
                    8303   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
00002C1A  4200      8304          clr.b     D0
                    8305   OSMemPut_3:
00002C1C  241F      8306          move.l    (A7)+,D2
00002C1E  4E5E      8307          unlk      A6
00002C20  4E75      8308          rts
                    8309   ; }
                    8310   ; /*$PAGE*/
                    8311   ; /*
                    8312   ; *********************************************************************************************************
                    8313   ; *                                       QUERY MEMORY PARTITION
                    8314   ; *
                    8315   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8316   ; *               used memory blocks from a memory partition.
                    8317   ; *
                    8318   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8319   ; *
                    8320   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8321   ; *                           partition.
                    8322   ; *
                    8323   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8324   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8325   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8326   ; *********************************************************************************************************
                    8327   ; */
                    8328   ; #if OS_MEM_QUERY_EN > 0u
                    8329   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8330   ; OS_MEM_DATA  *p_mem_data)
                    8331   ; {
                    8332   _OSMemQuery:
00002C22  4E56 0000 8333          link      A6,#0
00002C26  48E7 3000 8334          movem.l   D2/D3,-(A7)
00002C2A  242E 000C 8335          move.l    12(A6),D2
00002C2E  262E 0008 8336          move.l    8(A6),D3
                    8337   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8338   ; OS_CPU_SR  cpu_sr = 0u;
                    8339   ; #endif
                    8340   ; #if OS_ARG_CHK_EN > 0u
                    8341   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8342   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8343   ; }
                    8344   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8345   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8346   ; }
                    8347   ; #endif
                    8348   ; OS_ENTER_CRITICAL();
00002C32  40E7      8349          dc.w      16615
00002C34  007C      8350          dc.w      124
00002C36  0700      8351          dc.w      1792
                    8352   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002C38  2043      8353          move.l    D3,A0
00002C3A  2242      8354          move.l    D2,A1
00002C3C  2290      8355          move.l    (A0),(A1)
                    8356   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
00002C3E  2043      8357          move.l    D3,A0
00002C40  2242      8358          move.l    D2,A1
00002C42  2368 0004 8359          move.l    4(A0),4(A1)
00002C46  0004      
                    8360   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002C48  2043      8361          move.l    D3,A0
00002C4A  2242      8362          move.l    D2,A1
00002C4C  2368 0008 8363          move.l    8(A0),8(A1)
00002C50  0008      
                    8364   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002C52  2043      8365          move.l    D3,A0
00002C54  2242      8366          move.l    D2,A1
00002C56  2368 000C 8367          move.l    12(A0),12(A1)
00002C5A  000C      
                    8368   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
00002C5C  2043      8369          move.l    D3,A0
00002C5E  2242      8370          move.l    D2,A1
00002C60  2368 0010 8371          move.l    16(A0),16(A1)
00002C64  0010      
                    8372   ; OS_EXIT_CRITICAL();
00002C66  46DF      8373          dc.w      18143
                    8374   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
00002C68  2042      8375          move.l    D2,A0
00002C6A  2028 000C 8376          move.l    12(A0),D0
00002C6E  2042      8377          move.l    D2,A0
00002C70  90A8 0010 8378          sub.l     16(A0),D0
00002C74  2042      8379          move.l    D2,A0
00002C76  2140 0014 8380          move.l    D0,20(A0)
                    8381   ; return (OS_ERR_NONE);
00002C7A  4200      8382          clr.b     D0
00002C7C  4CDF 000C 8383          movem.l   (A7)+,D2/D3
00002C80  4E5E      8384          unlk      A6
00002C82  4E75      8385          rts
                    8386   ; }
                    8387   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8388   ; /*$PAGE*/
                    8389   ; /*
                    8390   ; *********************************************************************************************************
                    8391   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8392   ; *
                    8393   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8394   ; *               application MUST NOT call this function.
                    8395   ; *
                    8396   ; * Arguments   : none
                    8397   ; *
                    8398   ; * Returns     : none
                    8399   ; *
                    8400   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8401   ; *********************************************************************************************************
                    8402   ; */
                    8403   ; void  OS_MemInit (void)
                    8404   ; {
                    8405   _OS_MemInit:
00002C84  48E7 3020 8406          movem.l   D2/D3/A2,-(A7)
00002C88  45F9 0800 8407          lea       _OSMemTbl.L,A2
00002C8C  0DB8      
                    8408   ; #if OS_MAX_MEM_PART == 1u
                    8409   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8410   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8411   ; #if OS_MEM_NAME_EN > 0u
                    8412   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8413   ; #endif
                    8414   ; #endif
                    8415   ; #if OS_MAX_MEM_PART >= 2u
                    8416   ; OS_MEM  *pmem;
                    8417   ; INT16U   i;
                    8418   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
00002C8E  4878 0078 8419          pea       120
00002C92  2F0A      8420          move.l    A2,-(A7)
00002C94  4EB8 166C 8421          jsr       _OS_MemClr
00002C98  504F      8422          addq.w    #8,A7
                    8423   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00002C9A  4243      8424          clr.w     D3
                    8425   OS_MemInit_1:
00002C9C  0C43 0004 8426          cmp.w     #4,D3
00002CA0  6400 003C 8427          bhs       OS_MemInit_3
                    8428   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
00002CA4  200A      8429          move.l    A2,D0
00002CA6  C6BC 0000 8430          and.l     #65535,D3
00002CAA  FFFF      
00002CAC  2203      8431          move.l    D3,D1
00002CAE  C3FC 0018 8432          muls      #24,D1
00002CB2  D081      8433          add.l     D1,D0
00002CB4  2400      8434          move.l    D0,D2
                    8435   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
00002CB6  200A      8436          move.l    A2,D0
00002CB8  C6BC 0000 8437          and.l     #65535,D3
00002CBC  FFFF      
00002CBE  2203      8438          move.l    D3,D1
00002CC0  5281      8439          addq.l    #1,D1
00002CC2  C3FC 0018 8440          muls      #24,D1
00002CC6  D081      8441          add.l     D1,D0
00002CC8  2042      8442          move.l    D2,A0
00002CCA  2140 0004 8443          move.l    D0,4(A0)
                    8444   ; #if OS_MEM_NAME_EN > 0u
                    8445   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00002CCE  41F9 0000 8446          lea       @ucos_ii_1.L,A0
00002CD2  763A      
00002CD4  2242      8447          move.l    D2,A1
00002CD6  2348 0014 8448          move.l    A0,20(A1)
00002CDA  5243      8449          addq.w    #1,D3
00002CDC  60BE      8450          bra       OS_MemInit_1
                    8451   OS_MemInit_3:
                    8452   ; #endif
                    8453   ; }
                    8454   ; pmem                = &OSMemTbl[i];
00002CDE  200A      8455          move.l    A2,D0
00002CE0  C6BC 0000 8456          and.l     #65535,D3
00002CE4  FFFF      
00002CE6  2203      8457          move.l    D3,D1
00002CE8  C3FC 0018 8458          muls      #24,D1
00002CEC  D081      8459          add.l     D1,D0
00002CEE  2400      8460          move.l    D0,D2
                    8461   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00002CF0  2042      8462          move.l    D2,A0
00002CF2  42A8 0004 8463          clr.l     4(A0)
                    8464   ; #if OS_MEM_NAME_EN > 0u
                    8465   ; pmem->OSMemName = (INT8U *)(void *)"?";
00002CF6  41F9 0000 8466          lea       @ucos_ii_1.L,A0
00002CFA  763A      
00002CFC  2242      8467          move.l    D2,A1
00002CFE  2348 0014 8468          move.l    A0,20(A1)
                    8469   ; #endif
                    8470   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
00002D02  23CA 0800 8471          move.l    A2,_OSMemFreeList.L
00002D06  0DB4      
00002D08  4CDF 040C 8472          movem.l   (A7)+,D2/D3/A2
00002D0C  4E75      8473          rts
                    8474   ; /*
                    8475   ; *********************************************************************************************************
                    8476   ; *                                                uC/OS-II
                    8477   ; *                                          The Real-Time Kernel
                    8478   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8479   ; *
                    8480   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8481   ; *                                           All Rights Reserved
                    8482   ; *
                    8483   ; * File    : OS_MUTEX.C
                    8484   ; * By      : Jean J. Labrosse
                    8485   ; * Version : V2.92.07
                    8486   ; *
                    8487   ; * LICENSING TERMS:
                    8488   ; * ---------------
                    8489   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8490   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8491   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8492   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8493   ; * licensing fee.
                    8494   ; *********************************************************************************************************
                    8495   ; */
                    8496   ; #define  MICRIUM_SOURCE
                    8497   ; #ifndef  OS_MASTER_FILE
                    8498   ; #include <ucos_ii.h>
                    8499   ; #endif
                    8500   ; #if OS_MUTEX_EN > 0u
                    8501   ; /*
                    8502   ; *********************************************************************************************************
                    8503   ; *                                           LOCAL CONSTANTS
                    8504   ; *********************************************************************************************************
                    8505   ; */
                    8506   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8507   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8508   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8509   ; /*
                    8510   ; *********************************************************************************************************
                    8511   ; *                                           LOCAL CONSTANTS
                    8512   ; *********************************************************************************************************
                    8513   ; */
                    8514   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8515   ; /*$PAGE*/
                    8516   ; /*
                    8517   ; *********************************************************************************************************
                    8518   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8519   ; *
                    8520   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8521   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8522   ; *              not available or the event did not occur.
                    8523   ; *
                    8524   ; * Arguments  : pevent     is a pointer to the event control block
                    8525   ; *
                    8526   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8527   ; *                            OS_ERR_NONE         if the call was successful.
                    8528   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8529   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8530   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8531   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8532   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8533   ; *                                                indicates that you did not set the PCP higher (lower
                    8534   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8535   ; *                                                Unfortunately, this is something that could not be
                    8536   ; *                                                detected when the Mutex is created because we don't know
                    8537   ; *                                                what tasks will be using the Mutex.
                    8538   ; *
                    8539   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8540   ; *              == OS_FALSE   a) if the resource is not available
                    8541   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8542   ; *                            c) you called this function from an ISR
                    8543   ; *
                    8544   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8545   ; *              intended to be used by tasks only.
                    8546   ; *********************************************************************************************************
                    8547   ; */
                    8548   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8549   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8550   ; INT8U     *perr)
                    8551   ; {
                    8552   _OSMutexAccept:
00002D0E  4E56 0000 8553          link      A6,#0
00002D12  48E7 3820 8554          movem.l   D2/D3/D4/A2,-(A7)
00002D16  242E 0008 8555          move.l    8(A6),D2
00002D1A  262E 000C 8556          move.l    12(A6),D3
00002D1E  45F9 0800 8557          lea       _OSTCBCur.L,A2
00002D22  0540      
                    8558   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8559   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8560   ; OS_CPU_SR  cpu_sr = 0u;
                    8561   ; #endif
                    8562   ; #ifdef OS_SAFETY_CRITICAL
                    8563   ; if (perr == (INT8U *)0) {
                    8564   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8565   ; return (OS_FALSE);
                    8566   ; }
                    8567   ; #endif
                    8568   ; #if OS_ARG_CHK_EN > 0u
                    8569   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8570   ; *perr = OS_ERR_PEVENT_NULL;
                    8571   ; return (OS_FALSE);
                    8572   ; }
                    8573   ; #endif
                    8574   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00002D24  2042      8575          move.l    D2,A0
00002D26  1010      8576          move.b    (A0),D0
00002D28  0C00 0004 8577          cmp.b     #4,D0
00002D2C  670C      8578          beq.s     OSMutexAccept_1
                    8579   ; *perr = OS_ERR_EVENT_TYPE;
00002D2E  2043      8580          move.l    D3,A0
00002D30  10BC 0001 8581          move.b    #1,(A0)
                    8582   ; return (OS_FALSE);
00002D34  4200      8583          clr.b     D0
00002D36  6000 0084 8584          bra       OSMutexAccept_3
                    8585   OSMutexAccept_1:
                    8586   ; }
                    8587   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
00002D3A  1039 0800 8588          move.b    _OSIntNesting.L,D0
00002D3E  0426      
00002D40  0C00 0000 8589          cmp.b     #0,D0
00002D44  630C      8590          bls.s     OSMutexAccept_4
                    8591   ; *perr = OS_ERR_PEND_ISR;
00002D46  2043      8592          move.l    D3,A0
00002D48  10BC 0002 8593          move.b    #2,(A0)
                    8594   ; return (OS_FALSE);
00002D4C  4200      8595          clr.b     D0
00002D4E  6000 006C 8596          bra       OSMutexAccept_3
                    8597   OSMutexAccept_4:
                    8598   ; }
                    8599   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
00002D52  40E7      8600          dc.w      16615
00002D54  007C      8601          dc.w      124
00002D56  0700      8602          dc.w      1792
                    8603   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00002D58  2042      8604          move.l    D2,A0
00002D5A  3028 0006 8605          move.w    6(A0),D0
00002D5E  E048      8606          lsr.w     #8,D0
00002D60  1800      8607          move.b    D0,D4
                    8608   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002D62  2042      8609          move.l    D2,A0
00002D64  3028 0006 8610          move.w    6(A0),D0
00002D68  C07C 00FF 8611          and.w     #255,D0
00002D6C  0C40 00FF 8612          cmp.w     #255,D0
00002D70  6600 0042 8613          bne       OSMutexAccept_6
                    8614   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
00002D74  2042      8615          move.l    D2,A0
00002D76  0268 FF00 8616          and.w     #65280,6(A0)
00002D7A  0006      
                    8617   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
00002D7C  2042      8618          move.l    D2,A0
00002D7E  2252      8619          move.l    (A2),A1
00002D80  1029 0034 8620          move.b    52(A1),D0
00002D84  C07C 00FF 8621          and.w     #255,D0
00002D88  8168 0006 8622          or.w      D0,6(A0)
                    8623   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
00002D8C  2042      8624          move.l    D2,A0
00002D8E  2152 0002 8625          move.l    (A2),2(A0)
                    8626   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002D92  0C04 00FF 8627          cmp.b     #255,D4
00002D96  6712      8628          beq.s     OSMutexAccept_8
00002D98  2052      8629          move.l    (A2),A0
00002D9A  B828 0034 8630          cmp.b     52(A0),D4
00002D9E  650A      8631          blo.s     OSMutexAccept_8
                    8632   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8633   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
00002DA0  46DF      8634          dc.w      18143
                    8635   ; *perr = OS_ERR_PCP_LOWER;
00002DA2  2043      8636          move.l    D3,A0
00002DA4  10BC 0078 8637          move.b    #120,(A0)
00002DA8  6006      8638          bra.s     OSMutexAccept_9
                    8639   OSMutexAccept_8:
                    8640   ; } else {
                    8641   ; OS_EXIT_CRITICAL();
00002DAA  46DF      8642          dc.w      18143
                    8643   ; *perr = OS_ERR_NONE;
00002DAC  2043      8644          move.l    D3,A0
00002DAE  4210      8645          clr.b     (A0)
                    8646   OSMutexAccept_9:
                    8647   ; }
                    8648   ; return (OS_TRUE);
00002DB0  7001      8649          moveq     #1,D0
00002DB2  6008      8650          bra.s     OSMutexAccept_3
                    8651   OSMutexAccept_6:
                    8652   ; }
                    8653   ; OS_EXIT_CRITICAL();
00002DB4  46DF      8654          dc.w      18143
                    8655   ; *perr = OS_ERR_NONE;
00002DB6  2043      8656          move.l    D3,A0
00002DB8  4210      8657          clr.b     (A0)
                    8658   ; return (OS_FALSE);
00002DBA  4200      8659          clr.b     D0
                    8660   OSMutexAccept_3:
00002DBC  4CDF 041C 8661          movem.l   (A7)+,D2/D3/D4/A2
00002DC0  4E5E      8662          unlk      A6
00002DC2  4E75      8663          rts
                    8664   ; }
                    8665   ; #endif
                    8666   ; /*$PAGE*/
                    8667   ; /*
                    8668   ; *********************************************************************************************************
                    8669   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8670   ; *
                    8671   ; * Description: This function creates a mutual exclusion semaphore.
                    8672   ; *
                    8673   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8674   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8675   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8676   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8677   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8678   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8679   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8680   ; *                            semaphore do not have their priority promoted.
                    8681   ; *
                    8682   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8683   ; *                               OS_ERR_NONE         if the call was successful.
                    8684   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8685   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8686   ; *                                                   already exist.
                    8687   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8688   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8689   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8690   ; *
                    8691   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8692   ; *                            created mutex.
                    8693   ; *              == (void *)0  if an error is detected.
                    8694   ; *
                    8695   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8696   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8697   ; *
                    8698   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8699   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8700   ; *                 promotion is disabled.
                    8701   ; *********************************************************************************************************
                    8702   ; */
                    8703   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8704   ; INT8U  *perr)
                    8705   ; {
                    8706   _OSMutexCreate:
00002DC4  4E56 0000 8707          link      A6,#0
00002DC8  48E7 3830 8708          movem.l   D2/D3/D4/A2/A3,-(A7)
00002DCC  162E 000B 8709          move.b    11(A6),D3
00002DD0  C6BC 0000 8710          and.l     #255,D3
00002DD4  00FF      
00002DD6  282E 000C 8711          move.l    12(A6),D4
00002DDA  45F9 0800 8712          lea       _OSEventFreeList.L,A2
00002DDE  01FA      
00002DE0  47F9 0800 8713          lea       _OSTCBPrioTbl.L,A3
00002DE4  0550      
                    8714   ; OS_EVENT  *pevent;
                    8715   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8716   ; OS_CPU_SR  cpu_sr = 0u;
                    8717   ; #endif
                    8718   ; #ifdef OS_SAFETY_CRITICAL
                    8719   ; if (perr == (INT8U *)0) {
                    8720   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8721   ; return ((OS_EVENT *)0);
                    8722   ; }
                    8723   ; #endif
                    8724   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8725   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8726   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8727   ; return ((OS_EVENT *)0);
                    8728   ; }
                    8729   ; #endif
                    8730   ; #if OS_ARG_CHK_EN > 0u
                    8731   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8732   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8733   ; *perr = OS_ERR_PRIO_INVALID;
                    8734   ; return ((OS_EVENT *)0);
                    8735   ; }
                    8736   ; }
                    8737   ; #endif
                    8738   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002DE6  1039 0800 8739          move.b    _OSIntNesting.L,D0
00002DEA  0426      
00002DEC  0C00 0000 8740          cmp.b     #0,D0
00002DF0  630C      8741          bls.s     OSMutexCreate_1
                    8742   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
00002DF2  2044      8743          move.l    D4,A0
00002DF4  10BC 0010 8744          move.b    #16,(A0)
                    8745   ; return ((OS_EVENT *)0);
00002DF8  4280      8746          clr.l     D0
00002DFA  6000 00A6 8747          bra       OSMutexCreate_3
                    8748   OSMutexCreate_1:
                    8749   ; }
                    8750   ; OS_ENTER_CRITICAL();
00002DFE  40E7      8751          dc.w      16615
00002E00  007C      8752          dc.w      124
00002E02  0700      8753          dc.w      1792
                    8754   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002E04  0C03 00FF 8755          cmp.b     #255,D3
00002E08  6730      8756          beq.s     OSMutexCreate_4
                    8757   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00002E0A  C6BC 0000 8758          and.l     #255,D3
00002E0E  00FF      
00002E10  2003      8759          move.l    D3,D0
00002E12  E588      8760          lsl.l     #2,D0
00002E14  2033 0800 8761          move.l    0(A3,D0.L),D0
00002E18  670E      8762          beq.s     OSMutexCreate_6
                    8763   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00002E1A  46DF      8764          dc.w      18143
                    8765   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00002E1C  2044      8766          move.l    D4,A0
00002E1E  10BC 0028 8767          move.b    #40,(A0)
                    8768   ; return ((OS_EVENT *)0);
00002E22  4280      8769          clr.l     D0
00002E24  6000 007C 8770          bra       OSMutexCreate_3
                    8771   OSMutexCreate_6:
                    8772   ; }
                    8773   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
00002E28  C6BC 0000 8774          and.l     #255,D3
00002E2C  00FF      
00002E2E  2003      8775          move.l    D3,D0
00002E30  E588      8776          lsl.l     #2,D0
00002E32  27BC 0000 8777          move.l    #1,0(A3,D0.L)
00002E36  0001 0800 
                    8778   OSMutexCreate_4:
                    8779   ; }
                    8780   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00002E3A  2412      8781          move.l    (A2),D2
                    8782   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
00002E3C  4A82      8783          tst.l     D2
00002E3E  6622      8784          bne.s     OSMutexCreate_8
                    8785   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002E40  0C03 00FF 8786          cmp.b     #255,D3
00002E44  670E      8787          beq.s     OSMutexCreate_10
                    8788   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
00002E46  C6BC 0000 8789          and.l     #255,D3
00002E4A  00FF      
00002E4C  2003      8790          move.l    D3,D0
00002E4E  E588      8791          lsl.l     #2,D0
00002E50  42B3 0800 8792          clr.l     0(A3,D0.L)
                    8793   OSMutexCreate_10:
                    8794   ; }
                    8795   ; OS_EXIT_CRITICAL();
00002E54  46DF      8796          dc.w      18143
                    8797   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
00002E56  2044      8798          move.l    D4,A0
00002E58  10BC 0004 8799          move.b    #4,(A0)
                    8800   ; return (pevent);
00002E5C  2002      8801          move.l    D2,D0
00002E5E  6000 0042 8802          bra       OSMutexCreate_3
                    8803   OSMutexCreate_8:
                    8804   ; }
                    8805   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
00002E62  2052      8806          move.l    (A2),A0
00002E64  24A8 0002 8807          move.l    2(A0),(A2)
                    8808   ; OS_EXIT_CRITICAL();
00002E68  46DF      8809          dc.w      18143
                    8810   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
00002E6A  2042      8811          move.l    D2,A0
00002E6C  10BC 0004 8812          move.b    #4,(A0)
                    8813   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
00002E70  1003      8814          move.b    D3,D0
00002E72  C07C 00FF 8815          and.w     #255,D0
00002E76  E148      8816          lsl.w     #8,D0
00002E78  807C 00FF 8817          or.w      #255,D0
00002E7C  2042      8818          move.l    D2,A0
00002E7E  3140 0006 8819          move.w    D0,6(A0)
                    8820   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
00002E82  2042      8821          move.l    D2,A0
00002E84  42A8 0002 8822          clr.l     2(A0)
                    8823   ; #if OS_EVENT_NAME_EN > 0u
                    8824   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002E88  41F9 0000 8825          lea       @ucos_ii_1.L,A0
00002E8C  763A      
00002E8E  2242      8826          move.l    D2,A1
00002E90  2348 0012 8827          move.l    A0,18(A1)
                    8828   ; #endif
                    8829   ; OS_EventWaitListInit(pevent);
00002E94  2F02      8830          move.l    D2,-(A7)
00002E96  4EB8 13A0 8831          jsr       _OS_EventWaitListInit
00002E9A  584F      8832          addq.w    #4,A7
                    8833   ; *perr = OS_ERR_NONE;
00002E9C  2044      8834          move.l    D4,A0
00002E9E  4210      8835          clr.b     (A0)
                    8836   ; return (pevent);
00002EA0  2002      8837          move.l    D2,D0
                    8838   OSMutexCreate_3:
00002EA2  4CDF 0C1C 8839          movem.l   (A7)+,D2/D3/D4/A2/A3
00002EA6  4E5E      8840          unlk      A6
00002EA8  4E75      8841          rts
                    8842   ; }
                    8843   ; /*$PAGE*/
                    8844   ; /*
                    8845   ; *********************************************************************************************************
                    8846   ; *                                           DELETE A MUTEX
                    8847   ; *
                    8848   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    8849   ; *
                    8850   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    8851   ; *
                    8852   ; *              opt           determines delete options as follows:
                    8853   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    8854   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    8855   ; *                                                    In this case, all the tasks pending will be readied.
                    8856   ; *
                    8857   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    8858   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    8859   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    8860   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    8861   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    8862   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    8863   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    8864   ; *
                    8865   ; * Returns    : pevent        upon error
                    8866   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    8867   ; *
                    8868   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    8869   ; *                 the mutex MUST check the return code of OSMutexPend().
                    8870   ; *
                    8871   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    8872   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    8873   ; *
                    8874   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    8875   ; *                 resource(s) will no longer be guarded by the mutex.
                    8876   ; *
                    8877   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    8878   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    8879   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    8880   ; *                            that task will be made ready-to-run at its original priority.
                    8881   ; *********************************************************************************************************
                    8882   ; */
                    8883   ; #if OS_MUTEX_DEL_EN > 0u
                    8884   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    8885   ; INT8U      opt,
                    8886   ; INT8U     *perr)
                    8887   ; {
                    8888   _OSMutexDel:
00002EAA  4E56 FFFC 8889          link      A6,#-4
00002EAE  48E7 3F20 8890          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002EB2  242E 0008 8891          move.l    8(A6),D2
00002EB6  282E 0010 8892          move.l    16(A6),D4
00002EBA  45F9 0800 8893          lea       _OSEventFreeList.L,A2
00002EBE  01FA      
                    8894   ; BOOLEAN    tasks_waiting;
                    8895   ; OS_EVENT  *pevent_return;
                    8896   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    8897   ; INT8U      prio;
                    8898   ; OS_TCB    *ptcb;
                    8899   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8900   ; OS_CPU_SR  cpu_sr = 0u;
                    8901   ; #endif
                    8902   ; #ifdef OS_SAFETY_CRITICAL
                    8903   ; if (perr == (INT8U *)0) {
                    8904   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8905   ; return ((OS_EVENT *)0);
                    8906   ; }
                    8907   ; #endif
                    8908   ; #if OS_ARG_CHK_EN > 0u
                    8909   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    8910   ; *perr = OS_ERR_PEVENT_NULL;
                    8911   ; return (pevent);
                    8912   ; }
                    8913   ; #endif
                    8914   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00002EC0  2042      8915          move.l    D2,A0
00002EC2  1010      8916          move.b    (A0),D0
00002EC4  0C00 0004 8917          cmp.b     #4,D0
00002EC8  670C      8918          beq.s     OSMutexDel_1
                    8919   ; *perr = OS_ERR_EVENT_TYPE;
00002ECA  2044      8920          move.l    D4,A0
00002ECC  10BC 0001 8921          move.b    #1,(A0)
                    8922   ; return (pevent);
00002ED0  2002      8923          move.l    D2,D0
00002ED2  6000 017C 8924          bra       OSMutexDel_3
                    8925   OSMutexDel_1:
                    8926   ; }
                    8927   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002ED6  1039 0800 8928          move.b    _OSIntNesting.L,D0
00002EDA  0426      
00002EDC  0C00 0000 8929          cmp.b     #0,D0
00002EE0  630C      8930          bls.s     OSMutexDel_4
                    8931   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
00002EE2  2044      8932          move.l    D4,A0
00002EE4  10BC 000F 8933          move.b    #15,(A0)
                    8934   ; return (pevent);
00002EE8  2002      8935          move.l    D2,D0
00002EEA  6000 0164 8936          bra       OSMutexDel_3
                    8937   OSMutexDel_4:
                    8938   ; }
                    8939   ; OS_ENTER_CRITICAL();
00002EEE  40E7      8940          dc.w      16615
00002EF0  007C      8941          dc.w      124
00002EF2  0700      8942          dc.w      1792
                    8943   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
00002EF4  2042      8944          move.l    D2,A0
00002EF6  1028 0008 8945          move.b    8(A0),D0
00002EFA  6704      8946          beq.s     OSMutexDel_6
                    8947   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002EFC  7E01      8948          moveq     #1,D7
00002EFE  6002      8949          bra.s     OSMutexDel_7
                    8950   OSMutexDel_6:
                    8951   ; } else {
                    8952   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00002F00  7E00      8953          moveq     #0,D7
                    8954   OSMutexDel_7:
                    8955   ; }
                    8956   ; switch (opt) {
00002F02  102E 000F 8957          move.b    15(A6),D0
00002F06  C0BC 0000 8958          and.l     #255,D0
00002F0A  00FF      
00002F0C  0C80 0000 8959          cmp.l     #1,D0
00002F10  0001      
00002F12  6700 006E 8960          beq       OSMutexDel_11
00002F16  6200 012C 8961          bhi       OSMutexDel_8
00002F1A  4A80      8962          tst.l     D0
00002F1C  6704      8963          beq.s     OSMutexDel_10
00002F1E  6000 0124 8964          bra       OSMutexDel_8
                    8965   OSMutexDel_10:
                    8966   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    8967   ; if (tasks_waiting == OS_FALSE) {
00002F22  4A07      8968          tst.b     D7
00002F24  6600 004E 8969          bne       OSMutexDel_13
                    8970   ; #if OS_EVENT_NAME_EN > 0u
                    8971   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002F28  41F9 0000 8972          lea       @ucos_ii_1.L,A0
00002F2C  763A      
00002F2E  2242      8973          move.l    D2,A1
00002F30  2348 0012 8974          move.l    A0,18(A1)
                    8975   ; #endif
                    8976   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002F34  2042      8977          move.l    D2,A0
00002F36  3028 0006 8978          move.w    6(A0),D0
00002F3A  E048      8979          lsr.w     #8,D0
00002F3C  1600      8980          move.b    D0,D3
                    8981   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002F3E  0C03 00FF 8982          cmp.b     #255,D3
00002F42  6714      8983          beq.s     OSMutexDel_15
                    8984   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
00002F44  C6BC 0000 8985          and.l     #255,D3
00002F48  00FF      
00002F4A  2003      8986          move.l    D3,D0
00002F4C  E588      8987          lsl.l     #2,D0
00002F4E  41F9 0800 8988          lea       _OSTCBPrioTbl.L,A0
00002F52  0550      
00002F54  42B0 0800 8989          clr.l     0(A0,D0.L)
                    8990   OSMutexDel_15:
                    8991   ; }
                    8992   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00002F58  2042      8993          move.l    D2,A0
00002F5A  4210      8994          clr.b     (A0)
                    8995   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
00002F5C  2042      8996          move.l    D2,A0
00002F5E  2152 0002 8997          move.l    (A2),2(A0)
                    8998   ; pevent->OSEventCnt    = 0u;
00002F62  2042      8999          move.l    D2,A0
00002F64  4268 0006 9000          clr.w     6(A0)
                    9001   ; OSEventFreeList       = pevent;
00002F68  2482      9002          move.l    D2,(A2)
                    9003   ; OS_EXIT_CRITICAL();
00002F6A  46DF      9004          dc.w      18143
                    9005   ; *perr                 = OS_ERR_NONE;
00002F6C  2044      9006          move.l    D4,A0
00002F6E  4210      9007          clr.b     (A0)
                    9008   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
00002F70  4285      9009          clr.l     D5
00002F72  600A      9010          bra.s     OSMutexDel_14
                    9011   OSMutexDel_13:
                    9012   ; } else {
                    9013   ; OS_EXIT_CRITICAL();
00002F74  46DF      9014          dc.w      18143
                    9015   ; *perr                 = OS_ERR_TASK_WAITING;
00002F76  2044      9016          move.l    D4,A0
00002F78  10BC 0049 9017          move.b    #73,(A0)
                    9018   ; pevent_return         = pevent;
00002F7C  2A02      9019          move.l    D2,D5
                    9020   OSMutexDel_14:
                    9021   ; }
                    9022   ; break;
00002F7E  6000 00CE 9023          bra       OSMutexDel_9
                    9024   OSMutexDel_11:
                    9025   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    9026   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
00002F82  2042      9027          move.l    D2,A0
00002F84  3028 0006 9028          move.w    6(A0),D0
00002F88  E048      9029          lsr.w     #8,D0
00002F8A  1600      9030          move.b    D0,D3
                    9031   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002F8C  0C03 00FF 9032          cmp.b     #255,D3
00002F90  6700 0038 9033          beq       OSMutexDel_21
                    9034   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
00002F94  2042      9035          move.l    D2,A0
00002F96  3028 0006 9036          move.w    6(A0),D0
00002F9A  C07C 00FF 9037          and.w     #255,D0
00002F9E  1D40 FFFF 9038          move.b    D0,-1(A6)
                    9039   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
00002FA2  2042      9040          move.l    D2,A0
00002FA4  2C28 0002 9041          move.l    2(A0),D6
                    9042   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
00002FA8  4A86      9043          tst.l     D6
00002FAA  671E      9044          beq.s     OSMutexDel_21
                    9045   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00002FAC  2046      9046          move.l    D6,A0
00002FAE  B628 0034 9047          cmp.b     52(A0),D3
00002FB2  6616      9048          bne.s     OSMutexDel_21
                    9049   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
00002FB4  122E FFFF 9050          move.b    -1(A6),D1
00002FB8  C2BC 0000 9051          and.l     #255,D1
00002FBC  00FF      
00002FBE  2F01      9052          move.l    D1,-(A7)
00002FC0  2F06      9053          move.l    D6,-(A7)
00002FC2  4EB9 0000 9054          jsr       @ucos_ii_OSMutex_RdyAtPrio
00002FC6  3506      
00002FC8  504F      9055          addq.w    #8,A7
                    9056   OSMutexDel_21:
                    9057   ; }
                    9058   ; }
                    9059   ; }
                    9060   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    9061   OSMutexDel_23:
00002FCA  2042      9062          move.l    D2,A0
00002FCC  1028 0008 9063          move.b    8(A0),D0
00002FD0  671C      9064          beq.s     OSMutexDel_25
                    9065   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00002FD2  4878 0002 9066          pea       2
00002FD6  4878 0010 9067          pea       16
00002FDA  42A7      9068          clr.l     -(A7)
00002FDC  2F02      9069          move.l    D2,-(A7)
00002FDE  4EB8 10D8 9070          jsr       _OS_EventTaskRdy
00002FE2  DEFC 0010 9071          add.w     #16,A7
00002FE6  C0BC 0000 9072          and.l     #255,D0
00002FEA  00FF      
00002FEC  60DC      9073          bra       OSMutexDel_23
                    9074   OSMutexDel_25:
                    9075   ; }
                    9076   ; #if OS_EVENT_NAME_EN > 0u
                    9077   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002FEE  41F9 0000 9078          lea       @ucos_ii_1.L,A0
00002FF2  763A      
00002FF4  2242      9079          move.l    D2,A1
00002FF6  2348 0012 9080          move.l    A0,18(A1)
                    9081   ; #endif
                    9082   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002FFA  2042      9083          move.l    D2,A0
00002FFC  3028 0006 9084          move.w    6(A0),D0
00003000  E048      9085          lsr.w     #8,D0
00003002  1600      9086          move.b    D0,D3
                    9087   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003004  0C03 00FF 9088          cmp.b     #255,D3
00003008  6714      9089          beq.s     OSMutexDel_26
                    9090   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
0000300A  C6BC 0000 9091          and.l     #255,D3
0000300E  00FF      
00003010  2003      9092          move.l    D3,D0
00003012  E588      9093          lsl.l     #2,D0
00003014  41F9 0800 9094          lea       _OSTCBPrioTbl.L,A0
00003018  0550      
0000301A  42B0 0800 9095          clr.l     0(A0,D0.L)
                    9096   OSMutexDel_26:
                    9097   ; }
                    9098   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
0000301E  2042      9099          move.l    D2,A0
00003020  4210      9100          clr.b     (A0)
                    9101   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
00003022  2042      9102          move.l    D2,A0
00003024  2152 0002 9103          move.l    (A2),2(A0)
                    9104   ; pevent->OSEventCnt    = 0u;
00003028  2042      9105          move.l    D2,A0
0000302A  4268 0006 9106          clr.w     6(A0)
                    9107   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
0000302E  2482      9108          move.l    D2,(A2)
                    9109   ; OS_EXIT_CRITICAL();
00003030  46DF      9110          dc.w      18143
                    9111   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003032  0C07 0001 9112          cmp.b     #1,D7
00003036  6604      9113          bne.s     OSMutexDel_28
                    9114   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003038  4EB8 16B8 9115          jsr       _OS_Sched
                    9116   OSMutexDel_28:
                    9117   ; }
                    9118   ; *perr         = OS_ERR_NONE;
0000303C  2044      9119          move.l    D4,A0
0000303E  4210      9120          clr.b     (A0)
                    9121   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
00003040  4285      9122          clr.l     D5
                    9123   ; break;
00003042  600A      9124          bra.s     OSMutexDel_9
                    9125   OSMutexDel_8:
                    9126   ; default:
                    9127   ; OS_EXIT_CRITICAL();
00003044  46DF      9128          dc.w      18143
                    9129   ; *perr         = OS_ERR_INVALID_OPT;
00003046  2044      9130          move.l    D4,A0
00003048  10BC 0007 9131          move.b    #7,(A0)
                    9132   ; pevent_return = pevent;
0000304C  2A02      9133          move.l    D2,D5
                    9134   ; break;
                    9135   OSMutexDel_9:
                    9136   ; }
                    9137   ; return (pevent_return);
0000304E  2005      9138          move.l    D5,D0
                    9139   OSMutexDel_3:
00003050  4CDF 04FC 9140          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00003054  4E5E      9141          unlk      A6
00003056  4E75      9142          rts
                    9143   ; }
                    9144   ; #endif
                    9145   ; /*$PAGE*/
                    9146   ; /*
                    9147   ; *********************************************************************************************************
                    9148   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9149   ; *
                    9150   ; * Description: This function waits for a mutual exclusion semaphore.
                    9151   ; *
                    9152   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9153   ; *                            mutex.
                    9154   ; *
                    9155   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9156   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9157   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9158   ; *                            mutex or, until the resource becomes available.
                    9159   ; *
                    9160   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9161   ; *                            messages are:
                    9162   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9163   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9164   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9165   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9166   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9167   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9168   ; *                                                  would lead to a suspension.
                    9169   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9170   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9171   ; *                                                  indicates that you did not set the PCP higher (lower
                    9172   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9173   ; *                                                  Unfortunately, this is something that could not be
                    9174   ; *                                                  detected when the Mutex is created because we don't know
                    9175   ; *                                                  what tasks will be using the Mutex.
                    9176   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9177   ; *
                    9178   ; * Returns    : none
                    9179   ; *
                    9180   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9181   ; *
                    9182   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9183   ; *********************************************************************************************************
                    9184   ; */
                    9185   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9186   ; INT32U     timeout,
                    9187   ; INT8U     *perr)
                    9188   ; {
                    9189   _OSMutexPend:
00003058  4E56 FFFC 9190          link      A6,#-4
0000305C  48E7 3F30 9191          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
00003060  45F9 0800 9192          lea       _OSTCBCur.L,A2
00003064  0540      
00003066  262E 0008 9193          move.l    8(A6),D3
0000306A  2A2E 0010 9194          move.l    16(A6),D5
0000306E  47F9 0800 9195          lea       _OSRdyTbl.L,A3
00003072  0430      
                    9196   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9197   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9198   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9199   ; OS_TCB    *ptcb;
                    9200   ; OS_EVENT  *pevent2;
                    9201   ; INT8U      y;
                    9202   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9203   ; OS_CPU_SR  cpu_sr = 0u;
                    9204   ; #endif
                    9205   ; #ifdef OS_SAFETY_CRITICAL
                    9206   ; if (perr == (INT8U *)0) {
                    9207   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9208   ; return;
                    9209   ; }
                    9210   ; #endif
                    9211   ; #if OS_ARG_CHK_EN > 0u
                    9212   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9213   ; *perr = OS_ERR_PEVENT_NULL;
                    9214   ; return;
                    9215   ; }
                    9216   ; #endif
                    9217   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00003074  2043      9218          move.l    D3,A0
00003076  1010      9219          move.b    (A0),D0
00003078  0C00 0004 9220          cmp.b     #4,D0
0000307C  670A      9221          beq.s     OSMutexPend_1
                    9222   ; *perr = OS_ERR_EVENT_TYPE;
0000307E  2045      9223          move.l    D5,A0
00003080  10BC 0001 9224          move.b    #1,(A0)
                    9225   ; return;
00003084  6000 02AC 9226          bra       OSMutexPend_3
                    9227   OSMutexPend_1:
                    9228   ; }
                    9229   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003088  1039 0800 9230          move.b    _OSIntNesting.L,D0
0000308C  0426      
0000308E  0C00 0000 9231          cmp.b     #0,D0
00003092  630A      9232          bls.s     OSMutexPend_4
                    9233   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00003094  2045      9234          move.l    D5,A0
00003096  10BC 0002 9235          move.b    #2,(A0)
                    9236   ; return;
0000309A  6000 0296 9237          bra       OSMutexPend_3
                    9238   OSMutexPend_4:
                    9239   ; }
                    9240   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
0000309E  1039 0800 9241          move.b    _OSLockNesting.L,D0
000030A2  0428      
000030A4  0C00 0000 9242          cmp.b     #0,D0
000030A8  630A      9243          bls.s     OSMutexPend_6
                    9244   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
000030AA  2045      9245          move.l    D5,A0
000030AC  10BC 000D 9246          move.b    #13,(A0)
                    9247   ; return;
000030B0  6000 0280 9248          bra       OSMutexPend_3
                    9249   OSMutexPend_6:
                    9250   ; }
                    9251   ; /*$PAGE*/
                    9252   ; OS_ENTER_CRITICAL();
000030B4  40E7      9253          dc.w      16615
000030B6  007C      9254          dc.w      124
000030B8  0700      9255          dc.w      1792
                    9256   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
000030BA  2043      9257          move.l    D3,A0
000030BC  3028 0006 9258          move.w    6(A0),D0
000030C0  E048      9259          lsr.w     #8,D0
000030C2  1E00      9260          move.b    D0,D7
                    9261   ; /* Is Mutex available?                      */
                    9262   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
000030C4  2043      9263          move.l    D3,A0
000030C6  3028 0006 9264          move.w    6(A0),D0
000030CA  C07C 00FF 9265          and.w     #255,D0
000030CE  C07C 00FF 9266          and.w     #255,D0
000030D2  0C40 00FF 9267          cmp.w     #255,D0
000030D6  6600 0042 9268          bne       OSMutexPend_8
                    9269   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
000030DA  2043      9270          move.l    D3,A0
000030DC  0268 FF00 9271          and.w     #65280,6(A0)
000030E0  0006      
                    9272   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
000030E2  2043      9273          move.l    D3,A0
000030E4  2252      9274          move.l    (A2),A1
000030E6  1029 0034 9275          move.b    52(A1),D0
000030EA  C07C 00FF 9276          and.w     #255,D0
000030EE  8168 0006 9277          or.w      D0,6(A0)
                    9278   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
000030F2  2043      9279          move.l    D3,A0
000030F4  2152 0002 9280          move.l    (A2),2(A0)
                    9281   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
000030F8  0C07 00FF 9282          cmp.b     #255,D7
000030FC  6712      9283          beq.s     OSMutexPend_10
000030FE  2052      9284          move.l    (A2),A0
00003100  BE28 0034 9285          cmp.b     52(A0),D7
00003104  650A      9286          blo.s     OSMutexPend_10
                    9287   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9288   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00003106  46DF      9289          dc.w      18143
                    9290   ; *perr = OS_ERR_PCP_LOWER;
00003108  2045      9291          move.l    D5,A0
0000310A  10BC 0078 9292          move.b    #120,(A0)
0000310E  6006      9293          bra.s     OSMutexPend_11
                    9294   OSMutexPend_10:
                    9295   ; } else {
                    9296   ; OS_EXIT_CRITICAL();
00003110  46DF      9297          dc.w      18143
                    9298   ; *perr = OS_ERR_NONE;
00003112  2045      9299          move.l    D5,A0
00003114  4210      9300          clr.b     (A0)
                    9301   OSMutexPend_11:
                    9302   ; }
                    9303   ; return;
00003116  6000 021A 9304          bra       OSMutexPend_3
                    9305   OSMutexPend_8:
                    9306   ; }
                    9307   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000311A  0C07 00FF 9308          cmp.b     #255,D7
0000311E  6700 018A 9309          beq       OSMutexPend_16
                    9310   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
00003122  2043      9311          move.l    D3,A0
00003124  3028 0006 9312          move.w    6(A0),D0
00003128  C07C 00FF 9313          and.w     #255,D0
0000312C  1D40 FFFE 9314          move.b    D0,-2(A6)
                    9315   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
00003130  2043      9316          move.l    D3,A0
00003132  2428 0002 9317          move.l    2(A0),D2
                    9318   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
00003136  2042      9319          move.l    D2,A0
00003138  BE28 0034 9320          cmp.b     52(A0),D7
0000313C  6400 016C 9321          bhs       OSMutexPend_16
                    9322   ; if (mprio > OSTCBCur->OSTCBPrio) {
00003140  2052      9323          move.l    (A2),A0
00003142  102E FFFE 9324          move.b    -2(A6),D0
00003146  B028 0034 9325          cmp.b     52(A0),D0
0000314A  6300 015E 9326          bls       OSMutexPend_16
                    9327   ; y = ptcb->OSTCBY;
0000314E  2042      9328          move.l    D2,A0
00003150  1C28 0036 9329          move.b    54(A0),D6
                    9330   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
00003154  CCBC 0000 9331          and.l     #255,D6
00003158  00FF      
0000315A  1033 6800 9332          move.b    0(A3,D6.L),D0
0000315E  2042      9333          move.l    D2,A0
00003160  C028 0037 9334          and.b     55(A0),D0
00003164  6736      9335          beq.s     OSMutexPend_18
                    9336   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
00003166  CCBC 0000 9337          and.l     #255,D6
0000316A  00FF      
0000316C  2042      9338          move.l    D2,A0
0000316E  1028 0037 9339          move.b    55(A0),D0
00003172  4600      9340          not.b     D0
00003174  C133 6800 9341          and.b     D0,0(A3,D6.L)
                    9342   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
00003178  CCBC 0000 9343          and.l     #255,D6
0000317C  00FF      
0000317E  1033 6800 9344          move.b    0(A3,D6.L),D0
00003182  660E      9345          bne.s     OSMutexPend_20
                    9346   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00003184  2042      9347          move.l    D2,A0
00003186  1028 0038 9348          move.b    56(A0),D0
0000318A  4600      9349          not.b     D0
0000318C  C139 0800 9350          and.b     D0,_OSRdyGrp.L
00003190  042E      
                    9351   OSMutexPend_20:
                    9352   ; }
                    9353   ; rdy = OS_TRUE;
00003192  1D7C 0001 9354          move.b    #1,-1(A6)
00003196  FFFF      
00003198  6000 004C 9355          bra       OSMutexPend_19
                    9356   OSMutexPend_18:
                    9357   ; } else {
                    9358   ; pevent2 = ptcb->OSTCBEventPtr;
0000319C  2042      9359          move.l    D2,A0
0000319E  2828 001C 9360          move.l    28(A0),D4
                    9361   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
000031A2  4A84      9362          tst.l     D4
000031A4  6700 003C 9363          beq       OSMutexPend_24
                    9364   ; y = ptcb->OSTCBY;
000031A8  2042      9365          move.l    D2,A0
000031AA  1C28 0036 9366          move.b    54(A0),D6
                    9367   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
000031AE  2044      9368          move.l    D4,A0
000031B0  CCBC 0000 9369          and.l     #255,D6
000031B4  00FF      
000031B6  D1C6      9370          add.l     D6,A0
000031B8  2242      9371          move.l    D2,A1
000031BA  1029 0037 9372          move.b    55(A1),D0
000031BE  4600      9373          not.b     D0
000031C0  C128 000A 9374          and.b     D0,10(A0)
                    9375   ; if (pevent2->OSEventTbl[y] == 0u) {
000031C4  2044      9376          move.l    D4,A0
000031C6  CCBC 0000 9377          and.l     #255,D6
000031CA  00FF      
000031CC  D1C6      9378          add.l     D6,A0
000031CE  1028 000A 9379          move.b    10(A0),D0
000031D2  660E      9380          bne.s     OSMutexPend_24
                    9381   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000031D4  2044      9382          move.l    D4,A0
000031D6  2242      9383          move.l    D2,A1
000031D8  1029 0038 9384          move.b    56(A1),D0
000031DC  4600      9385          not.b     D0
000031DE  C128 0008 9386          and.b     D0,8(A0)
                    9387   OSMutexPend_24:
                    9388   ; }
                    9389   ; }
                    9390   ; rdy = OS_FALSE;                        /* No                                       */
000031E2  422E FFFF 9391          clr.b     -1(A6)
                    9392   OSMutexPend_19:
                    9393   ; }
                    9394   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
000031E6  2042      9395          move.l    D2,A0
000031E8  1147 0034 9396          move.b    D7,52(A0)
                    9397   ; #if OS_LOWEST_PRIO <= 63u
                    9398   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
000031EC  2042      9399          move.l    D2,A0
000031EE  1028 0034 9400          move.b    52(A0),D0
000031F2  E608      9401          lsr.b     #3,D0
000031F4  2042      9402          move.l    D2,A0
000031F6  1140 0036 9403          move.b    D0,54(A0)
                    9404   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
000031FA  2042      9405          move.l    D2,A0
000031FC  1028 0034 9406          move.b    52(A0),D0
00003200  C03C 0007 9407          and.b     #7,D0
00003204  2042      9408          move.l    D2,A0
00003206  1140 0035 9409          move.b    D0,53(A0)
                    9410   ; #else
                    9411   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9412   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9413   ; #endif
                    9414   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000320A  7001      9415          moveq     #1,D0
0000320C  2042      9416          move.l    D2,A0
0000320E  1228 0036 9417          move.b    54(A0),D1
00003212  C2BC 0000 9418          and.l     #255,D1
00003216  00FF      
00003218  E3A8      9419          lsl.l     D1,D0
0000321A  2042      9420          move.l    D2,A0
0000321C  1140 0038 9421          move.b    D0,56(A0)
                    9422   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
00003220  7001      9423          moveq     #1,D0
00003222  2042      9424          move.l    D2,A0
00003224  1228 0035 9425          move.b    53(A0),D1
00003228  C2BC 0000 9426          and.l     #255,D1
0000322C  00FF      
0000322E  E3A8      9427          lsl.l     D1,D0
00003230  2042      9428          move.l    D2,A0
00003232  1140 0037 9429          move.b    D0,55(A0)
                    9430   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
00003236  102E FFFF 9431          move.b    -1(A6),D0
0000323A  0C00 0001 9432          cmp.b     #1,D0
0000323E  6626      9433          bne.s     OSMutexPend_26
                    9434   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
00003240  2042      9435          move.l    D2,A0
00003242  1028 0038 9436          move.b    56(A0),D0
00003246  8139 0800 9437          or.b      D0,_OSRdyGrp.L
0000324A  042E      
                    9438   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000324C  2042      9439          move.l    D2,A0
0000324E  1028 0036 9440          move.b    54(A0),D0
00003252  C0BC 0000 9441          and.l     #255,D0
00003256  00FF      
00003258  2042      9442          move.l    D2,A0
0000325A  1228 0037 9443          move.b    55(A0),D1
0000325E  8333 0800 9444          or.b      D1,0(A3,D0.L)
00003262  6000 0032 9445          bra       OSMutexPend_28
                    9446   OSMutexPend_26:
                    9447   ; } else {
                    9448   ; pevent2 = ptcb->OSTCBEventPtr;
00003266  2042      9449          move.l    D2,A0
00003268  2828 001C 9450          move.l    28(A0),D4
                    9451   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
0000326C  4A84      9452          tst.l     D4
0000326E  6726      9453          beq.s     OSMutexPend_28
                    9454   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
00003270  2044      9455          move.l    D4,A0
00003272  2242      9456          move.l    D2,A1
00003274  1029 0038 9457          move.b    56(A1),D0
00003278  8128 0008 9458          or.b      D0,8(A0)
                    9459   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000327C  2044      9460          move.l    D4,A0
0000327E  2242      9461          move.l    D2,A1
00003280  1029 0036 9462          move.b    54(A1),D0
00003284  C0BC 0000 9463          and.l     #255,D0
00003288  00FF      
0000328A  D1C0      9464          add.l     D0,A0
0000328C  2242      9465          move.l    D2,A1
0000328E  1029 0037 9466          move.b    55(A1),D0
00003292  8128 000A 9467          or.b      D0,10(A0)
                    9468   OSMutexPend_28:
                    9469   ; }
                    9470   ; }
                    9471   ; OSTCBPrioTbl[pcp] = ptcb;
00003296  CEBC 0000 9472          and.l     #255,D7
0000329A  00FF      
0000329C  2007      9473          move.l    D7,D0
0000329E  E588      9474          lsl.l     #2,D0
000032A0  41F9 0800 9475          lea       _OSTCBPrioTbl.L,A0
000032A4  0550      
000032A6  2182 0800 9476          move.l    D2,0(A0,D0.L)
                    9477   OSMutexPend_16:
                    9478   ; }
                    9479   ; }
                    9480   ; }
                    9481   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
000032AA  2052      9482          move.l    (A2),A0
000032AC  0028 0010 9483          or.b      #16,50(A0)
000032B0  0032      
                    9484   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000032B2  2052      9485          move.l    (A2),A0
000032B4  4228 0033 9486          clr.b     51(A0)
                    9487   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
000032B8  2052      9488          move.l    (A2),A0
000032BA  216E 000C 9489          move.l    12(A6),46(A0)
000032BE  002E      
                    9490   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000032C0  2F03      9491          move.l    D3,-(A7)
000032C2  4EB8 11BC 9492          jsr       _OS_EventTaskWait
000032C6  584F      9493          addq.w    #4,A7
                    9494   ; OS_EXIT_CRITICAL();
000032C8  46DF      9495          dc.w      18143
                    9496   ; OS_Sched();                                       /* Find next highest priority task ready         */
000032CA  4EB8 16B8 9497          jsr       _OS_Sched
                    9498   ; OS_ENTER_CRITICAL();
000032CE  40E7      9499          dc.w      16615
000032D0  007C      9500          dc.w      124
000032D2  0700      9501          dc.w      1792
                    9502   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000032D4  2052      9503          move.l    (A2),A0
000032D6  1028 0033 9504          move.b    51(A0),D0
000032DA  C0BC 0000 9505          and.l     #255,D0
000032DE  00FF      
000032E0  0C80 0000 9506          cmp.l     #1,D0
000032E4  0001      
000032E6  6720      9507          beq.s     OSMutexPend_34
000032E8  6206      9508          bhi.s     OSMutexPend_36
000032EA  4A80      9509          tst.l     D0
000032EC  670C      9510          beq.s     OSMutexPend_32
000032EE  6018      9511          bra.s     OSMutexPend_34
                    9512   OSMutexPend_36:
000032F0  0C80 0000 9513          cmp.l     #2,D0
000032F4  0002      
000032F6  6708      9514          beq.s     OSMutexPend_33
000032F8  600E      9515          bra.s     OSMutexPend_34
                    9516   OSMutexPend_32:
                    9517   ; case OS_STAT_PEND_OK:
                    9518   ; *perr = OS_ERR_NONE;
000032FA  2045      9519          move.l    D5,A0
000032FC  4210      9520          clr.b     (A0)
                    9521   ; break;
000032FE  6018      9522          bra.s     OSMutexPend_31
                    9523   OSMutexPend_33:
                    9524   ; case OS_STAT_PEND_ABORT:
                    9525   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
00003300  2045      9526          move.l    D5,A0
00003302  10BC 000E 9527          move.b    #14,(A0)
                    9528   ; break;
00003306  6010      9529          bra.s     OSMutexPend_31
                    9530   OSMutexPend_34:
                    9531   ; case OS_STAT_PEND_TO:
                    9532   ; default:
                    9533   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003308  2F03      9534          move.l    D3,-(A7)
0000330A  2F12      9535          move.l    (A2),-(A7)
0000330C  4EB8 12DE 9536          jsr       _OS_EventTaskRemove
00003310  504F      9537          addq.w    #8,A7
                    9538   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
00003312  2045      9539          move.l    D5,A0
00003314  10BC 000A 9540          move.b    #10,(A0)
                    9541   ; break;
                    9542   OSMutexPend_31:
                    9543   ; }
                    9544   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003318  2052      9545          move.l    (A2),A0
0000331A  4228 0032 9546          clr.b     50(A0)
                    9547   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000331E  2052      9548          move.l    (A2),A0
00003320  4228 0033 9549          clr.b     51(A0)
                    9550   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003324  2052      9551          move.l    (A2),A0
00003326  42A8 001C 9552          clr.l     28(A0)
                    9553   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9554   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000332A  2052      9555          move.l    (A2),A0
0000332C  42A8 0020 9556          clr.l     32(A0)
                    9557   ; #endif
                    9558   ; OS_EXIT_CRITICAL();
00003330  46DF      9559          dc.w      18143
                    9560   OSMutexPend_3:
00003332  4CDF 0CFC 9561          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
00003336  4E5E      9562          unlk      A6
00003338  4E75      9563          rts
                    9564   ; }
                    9565   ; /*$PAGE*/
                    9566   ; /*
                    9567   ; *********************************************************************************************************
                    9568   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9569   ; *
                    9570   ; * Description: This function signals a mutual exclusion semaphore
                    9571   ; *
                    9572   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9573   ; *                                  mutex.
                    9574   ; *
                    9575   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9576   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9577   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9578   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9579   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9580   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9581   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9582   ; *                                      indicates that you did not set the PCP higher (lower
                    9583   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9584   ; *                                      Unfortunately, this is something that could not be
                    9585   ; *                                      detected when the Mutex is created because we don't know
                    9586   ; *                                      what tasks will be using the Mutex.
                    9587   ; *********************************************************************************************************
                    9588   ; */
                    9589   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9590   ; {
                    9591   _OSMutexPost:
0000333A  4E56 0000 9592          link      A6,#0
0000333E  48E7 3820 9593          movem.l   D2/D3/D4/A2,-(A7)
00003342  242E 0008 9594          move.l    8(A6),D2
00003346  45F9 0800 9595          lea       _OSTCBCur.L,A2
0000334A  0540      
                    9596   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9597   ; INT8U      prio;
                    9598   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9599   ; OS_CPU_SR  cpu_sr = 0u;
                    9600   ; #endif
                    9601   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000334C  1039 0800 9602          move.b    _OSIntNesting.L,D0
00003350  0426      
00003352  0C00 0000 9603          cmp.b     #0,D0
00003356  6306      9604          bls.s     OSMutexPost_1
                    9605   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
00003358  7005      9606          moveq     #5,D0
0000335A  6000 00F0 9607          bra       OSMutexPost_3
                    9608   OSMutexPost_1:
                    9609   ; }
                    9610   ; #if OS_ARG_CHK_EN > 0u
                    9611   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9612   ; return (OS_ERR_PEVENT_NULL);
                    9613   ; }
                    9614   ; #endif
                    9615   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
0000335E  2042      9616          move.l    D2,A0
00003360  1010      9617          move.b    (A0),D0
00003362  0C00 0004 9618          cmp.b     #4,D0
00003366  6706      9619          beq.s     OSMutexPost_4
                    9620   ; return (OS_ERR_EVENT_TYPE);
00003368  7001      9621          moveq     #1,D0
0000336A  6000 00E0 9622          bra       OSMutexPost_3
                    9623   OSMutexPost_4:
                    9624   ; }
                    9625   ; OS_ENTER_CRITICAL();
0000336E  40E7      9626          dc.w      16615
00003370  007C      9627          dc.w      124
00003372  0700      9628          dc.w      1792
                    9629   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
00003374  2042      9630          move.l    D2,A0
00003376  3028 0006 9631          move.w    6(A0),D0
0000337A  E048      9632          lsr.w     #8,D0
0000337C  1800      9633          move.b    D0,D4
                    9634   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
0000337E  2042      9635          move.l    D2,A0
00003380  3028 0006 9636          move.w    6(A0),D0
00003384  C07C 00FF 9637          and.w     #255,D0
00003388  1600      9638          move.b    D0,D3
                    9639   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
0000338A  2042      9640          move.l    D2,A0
0000338C  2012      9641          move.l    (A2),D0
0000338E  B0A8 0002 9642          cmp.l     2(A0),D0
00003392  6708      9643          beq.s     OSMutexPost_6
                    9644   ; OS_EXIT_CRITICAL();
00003394  46DF      9645          dc.w      18143
                    9646   ; return (OS_ERR_NOT_MUTEX_OWNER);
00003396  7064      9647          moveq     #100,D0
00003398  6000 00B2 9648          bra       OSMutexPost_3
                    9649   OSMutexPost_6:
                    9650   ; }
                    9651   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000339C  0C04 00FF 9652          cmp.b     #255,D4
000033A0  6732      9653          beq.s     OSMutexPost_8
                    9654   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
000033A2  2052      9655          move.l    (A2),A0
000033A4  B828 0034 9656          cmp.b     52(A0),D4
000033A8  6612      9657          bne.s     OSMutexPost_10
                    9658   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
000033AA  C6BC 0000 9659          and.l     #255,D3
000033AE  00FF      
000033B0  2F03      9660          move.l    D3,-(A7)
000033B2  2F12      9661          move.l    (A2),-(A7)
000033B4  4EB9 0000 9662          jsr       @ucos_ii_OSMutex_RdyAtPrio
000033B8  3506      
000033BA  504F      9663          addq.w    #8,A7
                    9664   OSMutexPost_10:
                    9665   ; }
                    9666   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
000033BC  C8BC 0000 9667          and.l     #255,D4
000033C0  00FF      
000033C2  2004      9668          move.l    D4,D0
000033C4  E588      9669          lsl.l     #2,D0
000033C6  41F9 0800 9670          lea       _OSTCBPrioTbl.L,A0
000033CA  0550      
000033CC  21BC 0000 9671          move.l    #1,0(A0,D0.L)
000033D0  0001 0800 
                    9672   OSMutexPost_8:
                    9673   ; }
                    9674   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
000033D4  2042      9675          move.l    D2,A0
000033D6  1028 0008 9676          move.b    8(A0),D0
000033DA  6700 005E 9677          beq       OSMutexPost_12
                    9678   ; /* Yes, Make HPT waiting for mutex ready         */
                    9679   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
000033DE  42A7      9680          clr.l     -(A7)
000033E0  4878 0010 9681          pea       16
000033E4  42A7      9682          clr.l     -(A7)
000033E6  2F02      9683          move.l    D2,-(A7)
000033E8  4EB8 10D8 9684          jsr       _OS_EventTaskRdy
000033EC  DEFC 0010 9685          add.w     #16,A7
000033F0  1600      9686          move.b    D0,D3
                    9687   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
000033F2  2042      9688          move.l    D2,A0
000033F4  0268 FF00 9689          and.w     #65280,6(A0)
000033F8  0006      
                    9690   ; pevent->OSEventCnt |= prio;
000033FA  2042      9691          move.l    D2,A0
000033FC  C67C 00FF 9692          and.w     #255,D3
00003400  8768 0006 9693          or.w      D3,6(A0)
                    9694   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
00003404  C6BC 0000 9695          and.l     #255,D3
00003408  00FF      
0000340A  2003      9696          move.l    D3,D0
0000340C  E588      9697          lsl.l     #2,D0
0000340E  41F9 0800 9698          lea       _OSTCBPrioTbl.L,A0
00003412  0550      
00003414  2242      9699          move.l    D2,A1
00003416  2370 0800 9700          move.l    0(A0,D0.L),2(A1)
0000341A  0002      
                    9701   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
0000341C  0C04 00FF 9702          cmp.b     #255,D4
00003420  670E      9703          beq.s     OSMutexPost_14
00003422  B604      9704          cmp.b     D4,D3
00003424  620A      9705          bhi.s     OSMutexPost_14
                    9706   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9707   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
00003426  46DF      9708          dc.w      18143
                    9709   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003428  4EB8 16B8 9710          jsr       _OS_Sched
                    9711   ; return (OS_ERR_PCP_LOWER);
0000342C  7078      9712          moveq     #120,D0
0000342E  601C      9713          bra.s     OSMutexPost_3
                    9714   OSMutexPost_14:
                    9715   ; } else {
                    9716   ; OS_EXIT_CRITICAL();
00003430  46DF      9717          dc.w      18143
                    9718   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003432  4EB8 16B8 9719          jsr       _OS_Sched
                    9720   ; return (OS_ERR_NONE);
00003436  4200      9721          clr.b     D0
00003438  6012      9722          bra.s     OSMutexPost_3
                    9723   OSMutexPost_12:
                    9724   ; }
                    9725   ; }
                    9726   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
0000343A  2042      9727          move.l    D2,A0
0000343C  0068 00FF 9728          or.w      #255,6(A0)
00003440  0006      
                    9729   ; pevent->OSEventPtr  = (void *)0;
00003442  2042      9730          move.l    D2,A0
00003444  42A8 0002 9731          clr.l     2(A0)
                    9732   ; OS_EXIT_CRITICAL();
00003448  46DF      9733          dc.w      18143
                    9734   ; return (OS_ERR_NONE);
0000344A  4200      9735          clr.b     D0
                    9736   OSMutexPost_3:
0000344C  4CDF 041C 9737          movem.l   (A7)+,D2/D3/D4/A2
00003450  4E5E      9738          unlk      A6
00003452  4E75      9739          rts
                    9740   ; }
                    9741   ; /*$PAGE*/
                    9742   ; /*
                    9743   ; *********************************************************************************************************
                    9744   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9745   ; *
                    9746   ; * Description: This function obtains information about a mutex
                    9747   ; *
                    9748   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9749   ; *
                    9750   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9751   ; *
                    9752   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9753   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9754   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9755   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9756   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9757   ; *********************************************************************************************************
                    9758   ; */
                    9759   ; #if OS_MUTEX_QUERY_EN > 0u
                    9760   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9761   ; OS_MUTEX_DATA  *p_mutex_data)
                    9762   ; {
                    9763   _OSMutexQuery:
00003454  4E56 FFF8 9764          link      A6,#-8
00003458  48E7 3800 9765          movem.l   D2/D3/D4,-(A7)
0000345C  242E 000C 9766          move.l    12(A6),D2
00003460  262E 0008 9767          move.l    8(A6),D3
                    9768   ; INT8U       i;
                    9769   ; OS_PRIO    *psrc;
                    9770   ; OS_PRIO    *pdest;
                    9771   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9772   ; OS_CPU_SR   cpu_sr = 0u;
                    9773   ; #endif
                    9774   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003464  1039 0800 9775          move.b    _OSIntNesting.L,D0
00003468  0426      
0000346A  0C00 0000 9776          cmp.b     #0,D0
0000346E  6306      9777          bls.s     OSMutexQuery_1
                    9778   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
00003470  7006      9779          moveq     #6,D0
00003472  6000 008A 9780          bra       OSMutexQuery_3
                    9781   OSMutexQuery_1:
                    9782   ; }
                    9783   ; #if OS_ARG_CHK_EN > 0u
                    9784   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9785   ; return (OS_ERR_PEVENT_NULL);
                    9786   ; }
                    9787   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    9788   ; return (OS_ERR_PDATA_NULL);
                    9789   ; }
                    9790   ; #endif
                    9791   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00003476  2043      9792          move.l    D3,A0
00003478  1010      9793          move.b    (A0),D0
0000347A  0C00 0004 9794          cmp.b     #4,D0
0000347E  6706      9795          beq.s     OSMutexQuery_4
                    9796   ; return (OS_ERR_EVENT_TYPE);
00003480  7001      9797          moveq     #1,D0
00003482  6000 007A 9798          bra       OSMutexQuery_3
                    9799   OSMutexQuery_4:
                    9800   ; }
                    9801   ; OS_ENTER_CRITICAL();
00003486  40E7      9802          dc.w      16615
00003488  007C      9803          dc.w      124
0000348A  0700      9804          dc.w      1792
                    9805   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
0000348C  2043      9806          move.l    D3,A0
0000348E  3028 0006 9807          move.w    6(A0),D0
00003492  E048      9808          lsr.w     #8,D0
00003494  2042      9809          move.l    D2,A0
00003496  1140 000B 9810          move.b    D0,11(A0)
                    9811   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
0000349A  2043      9812          move.l    D3,A0
0000349C  3028 0006 9813          move.w    6(A0),D0
000034A0  C07C 00FF 9814          and.w     #255,D0
000034A4  2042      9815          move.l    D2,A0
000034A6  1140 000A 9816          move.b    D0,10(A0)
                    9817   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
000034AA  2042      9818          move.l    D2,A0
000034AC  1028 000A 9819          move.b    10(A0),D0
000034B0  0C00 00FF 9820          cmp.b     #255,D0
000034B4  660A      9821          bne.s     OSMutexQuery_6
                    9822   ; p_mutex_data->OSValue = OS_TRUE;
000034B6  2042      9823          move.l    D2,A0
000034B8  117C 0001 9824          move.b    #1,9(A0)
000034BC  0009      
000034BE  6006      9825          bra.s     OSMutexQuery_7
                    9826   OSMutexQuery_6:
                    9827   ; } else {
                    9828   ; p_mutex_data->OSValue = OS_FALSE;
000034C0  2042      9829          move.l    D2,A0
000034C2  4228 0009 9830          clr.b     9(A0)
                    9831   OSMutexQuery_7:
                    9832   ; }
                    9833   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
000034C6  2043      9834          move.l    D3,A0
000034C8  2242      9835          move.l    D2,A1
000034CA  1368 0008 9836          move.b    8(A0),8(A1)
000034CE  0008      
                    9837   ; psrc                      = &pevent->OSEventTbl[0];
000034D0  700A      9838          moveq     #10,D0
000034D2  D083      9839          add.l     D3,D0
000034D4  2D40 FFF8 9840          move.l    D0,-8(A6)
                    9841   ; pdest                     = &p_mutex_data->OSEventTbl[0];
000034D8  2D42 FFFC 9842          move.l    D2,-4(A6)
                    9843   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000034DC  4204      9844          clr.b     D4
                    9845   OSMutexQuery_8:
000034DE  0C04 0008 9846          cmp.b     #8,D4
000034E2  6416      9847          bhs.s     OSMutexQuery_10
                    9848   ; *pdest++ = *psrc++;
000034E4  206E FFF8 9849          move.l    -8(A6),A0
000034E8  52AE FFF8 9850          addq.l    #1,-8(A6)
000034EC  226E FFFC 9851          move.l    -4(A6),A1
000034F0  52AE FFFC 9852          addq.l    #1,-4(A6)
000034F4  1290      9853          move.b    (A0),(A1)
000034F6  5204      9854          addq.b    #1,D4
000034F8  60E4      9855          bra       OSMutexQuery_8
                    9856   OSMutexQuery_10:
                    9857   ; }
                    9858   ; OS_EXIT_CRITICAL();
000034FA  46DF      9859          dc.w      18143
                    9860   ; return (OS_ERR_NONE);
000034FC  4200      9861          clr.b     D0
                    9862   OSMutexQuery_3:
000034FE  4CDF 001C 9863          movem.l   (A7)+,D2/D3/D4
00003502  4E5E      9864          unlk      A6
00003504  4E75      9865          rts
                    9866   ; }
                    9867   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    9868   ; /*$PAGE*/
                    9869   ; /*
                    9870   ; *********************************************************************************************************
                    9871   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    9872   ; *
                    9873   ; * Description: This function makes a task ready at the specified priority
                    9874   ; *
                    9875   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    9876   ; *
                    9877   ; *              prio            is the desired priority
                    9878   ; *
                    9879   ; * Returns    : none
                    9880   ; *********************************************************************************************************
                    9881   ; */
                    9882   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    9883   ; INT8U    prio)
                    9884   ; {
                    9885   @ucos_ii_OSMutex_RdyAtPrio:
00003506  4E56 0000 9886          link      A6,#0
0000350A  48E7 3820 9887          movem.l   D2/D3/D4/A2,-(A7)
0000350E  242E 0008 9888          move.l    8(A6),D2
00003512  162E 000F 9889          move.b    15(A6),D3
00003516  C6BC 0000 9890          and.l     #255,D3
0000351A  00FF      
0000351C  45F9 0800 9891          lea       _OSRdyTbl.L,A2
00003520  0430      
                    9892   ; INT8U  y;
                    9893   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
00003522  2042      9894          move.l    D2,A0
00003524  1828 0036 9895          move.b    54(A0),D4
                    9896   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003528  C8BC 0000 9897          and.l     #255,D4
0000352C  00FF      
0000352E  2042      9898          move.l    D2,A0
00003530  1028 0037 9899          move.b    55(A0),D0
00003534  4600      9900          not.b     D0
00003536  C132 4800 9901          and.b     D0,0(A2,D4.L)
                    9902   ; if (OSRdyTbl[y] == 0u) {
0000353A  C8BC 0000 9903          and.l     #255,D4
0000353E  00FF      
00003540  1032 4800 9904          move.b    0(A2,D4.L),D0
00003544  660E      9905          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    9906   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00003546  2042      9907          move.l    D2,A0
00003548  1028 0038 9908          move.b    56(A0),D0
0000354C  4600      9909          not.b     D0
0000354E  C139 0800 9910          and.b     D0,_OSRdyGrp.L
00003552  042E      
                    9911   @ucos_ii_OSMutex_RdyAtPrio_1:
                    9912   ; }
                    9913   ; ptcb->OSTCBPrio         = prio;
00003554  2042      9914          move.l    D2,A0
00003556  1143 0034 9915          move.b    D3,52(A0)
                    9916   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
0000355A  13C3 0800 9917          move.b    D3,_OSPrioCur.L
0000355E  042A      
                    9918   ; #if OS_LOWEST_PRIO <= 63u
                    9919   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
00003560  1003      9920          move.b    D3,D0
00003562  E608      9921          lsr.b     #3,D0
00003564  C03C 0007 9922          and.b     #7,D0
00003568  2042      9923          move.l    D2,A0
0000356A  1140 0036 9924          move.b    D0,54(A0)
                    9925   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
0000356E  1003      9926          move.b    D3,D0
00003570  C03C 0007 9927          and.b     #7,D0
00003574  2042      9928          move.l    D2,A0
00003576  1140 0035 9929          move.b    D0,53(A0)
                    9930   ; #else
                    9931   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    9932   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    9933   ; #endif
                    9934   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
0000357A  7001      9935          moveq     #1,D0
0000357C  2042      9936          move.l    D2,A0
0000357E  1228 0036 9937          move.b    54(A0),D1
00003582  C2BC 0000 9938          and.l     #255,D1
00003586  00FF      
00003588  E3A8      9939          lsl.l     D1,D0
0000358A  2042      9940          move.l    D2,A0
0000358C  1140 0038 9941          move.b    D0,56(A0)
                    9942   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
00003590  7001      9943          moveq     #1,D0
00003592  2042      9944          move.l    D2,A0
00003594  1228 0035 9945          move.b    53(A0),D1
00003598  C2BC 0000 9946          and.l     #255,D1
0000359C  00FF      
0000359E  E3A8      9947          lsl.l     D1,D0
000035A0  2042      9948          move.l    D2,A0
000035A2  1140 0037 9949          move.b    D0,55(A0)
                    9950   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
000035A6  2042      9951          move.l    D2,A0
000035A8  1028 0038 9952          move.b    56(A0),D0
000035AC  8139 0800 9953          or.b      D0,_OSRdyGrp.L
000035B0  042E      
                    9954   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000035B2  2042      9955          move.l    D2,A0
000035B4  1028 0036 9956          move.b    54(A0),D0
000035B8  C0BC 0000 9957          and.l     #255,D0
000035BC  00FF      
000035BE  2042      9958          move.l    D2,A0
000035C0  1228 0037 9959          move.b    55(A0),D1
000035C4  8332 0800 9960          or.b      D1,0(A2,D0.L)
                    9961   ; OSTCBPrioTbl[prio]      = ptcb;
000035C8  C6BC 0000 9962          and.l     #255,D3
000035CC  00FF      
000035CE  2003      9963          move.l    D3,D0
000035D0  E588      9964          lsl.l     #2,D0
000035D2  41F9 0800 9965          lea       _OSTCBPrioTbl.L,A0
000035D6  0550      
000035D8  2182 0800 9966          move.l    D2,0(A0,D0.L)
000035DC  4CDF 041C 9967          movem.l   (A7)+,D2/D3/D4/A2
000035E0  4E5E      9968          unlk      A6
000035E2  4E75      9969          rts
                    9970   ; /*
                    9971   ; *********************************************************************************************************
                    9972   ; *                                                uC/OS-II
                    9973   ; *                                          The Real-Time Kernel
                    9974   ; *                                        MESSAGE QUEUE MANAGEMENT
                    9975   ; *
                    9976   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    9977   ; *                                           All Rights Reserved
                    9978   ; *
                    9979   ; * File    : OS_Q.C
                    9980   ; * By      : Jean J. Labrosse
                    9981   ; * Version : V2.92.07
                    9982   ; *
                    9983   ; * LICENSING TERMS:
                    9984   ; * ---------------
                    9985   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    9986   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    9987   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    9988   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    9989   ; * licensing fee.
                    9990   ; *********************************************************************************************************
                    9991   ; */
                    9992   ; #define  MICRIUM_SOURCE
                    9993   ; #ifndef  OS_MASTER_FILE
                    9994   ; #include <ucos_ii.h>
                    9995   ; #endif
                    9996   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    9997   ; /*
                    9998   ; *********************************************************************************************************
                    9999   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    10000   ; *
                    10001   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    10002   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    10003   ; *
                    10004   ; * Arguments  : pevent        is a pointer to the event control block
                    10005   ; *
                    10006   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10007   ; *                            messages are:
                    10008   ; *
                    10009   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10010   ; *                                                message.
                    10011   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10012   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10013   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    10014   ; *
                    10015   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    10016   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    10017   ; *                            one less entry.
                    10018   ; *              == (void *)0  if you received a NULL pointer message
                    10019   ; *                            if the queue is empty or,
                    10020   ; *                            if 'pevent' is a NULL pointer or,
                    10021   ; *                            if you passed an invalid event type
                    10022   ; *
                    10023   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    10024   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    10025   ; *********************************************************************************************************
                    10026   ; */
                    10027   ; #if OS_Q_ACCEPT_EN > 0u
                    10028   ; void  *OSQAccept (OS_EVENT  *pevent,
                    10029   ; INT8U     *perr)
                    10030   ; {
                    10031   _OSQAccept:
000035E4  4E56 0000 10032          link      A6,#0
000035E8  48E7 3800 10033          movem.l   D2/D3/D4,-(A7)
000035EC  282E 000C 10034          move.l    12(A6),D4
                    10035   ; void      *pmsg;
                    10036   ; OS_Q      *pq;
                    10037   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10038   ; OS_CPU_SR  cpu_sr = 0u;
                    10039   ; #endif
                    10040   ; #ifdef OS_SAFETY_CRITICAL
                    10041   ; if (perr == (INT8U *)0) {
                    10042   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10043   ; return ((void *)0);
                    10044   ; }
                    10045   ; #endif
                    10046   ; #if OS_ARG_CHK_EN > 0u
                    10047   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10048   ; *perr = OS_ERR_PEVENT_NULL;
                    10049   ; return ((void *)0);
                    10050   ; }
                    10051   ; #endif
                    10052   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
000035F0  206E 0008 10053          move.l    8(A6),A0
000035F4  1010      10054          move.b    (A0),D0
000035F6  0C00 0002 10055          cmp.b     #2,D0
000035FA  670C      10056          beq.s     OSQAccept_1
                    10057   ; *perr = OS_ERR_EVENT_TYPE;
000035FC  2044      10058          move.l    D4,A0
000035FE  10BC 0001 10059          move.b    #1,(A0)
                    10060   ; return ((void *)0);
00003602  4280      10061          clr.l     D0
00003604  6000 0064 10062          bra       OSQAccept_3
                    10063   OSQAccept_1:
                    10064   ; }
                    10065   ; OS_ENTER_CRITICAL();
00003608  40E7      10066          dc.w      16615
0000360A  007C      10067          dc.w      124
0000360C  0700      10068          dc.w      1792
                    10069   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
0000360E  206E 0008 10070          move.l    8(A6),A0
00003612  2428 0002 10071          move.l    2(A0),D2
                    10072   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003616  2042      10073          move.l    D2,A0
00003618  3028 0016 10074          move.w    22(A0),D0
0000361C  0C40 0000 10075          cmp.w     #0,D0
00003620  6300 003C 10076          bls       OSQAccept_4
                    10077   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003624  2002      10078          move.l    D2,D0
00003626  0680 0000 10079          add.l     #16,D0
0000362A  0010      
0000362C  2040      10080          move.l    D0,A0
0000362E  2250      10081          move.l    (A0),A1
00003630  5890      10082          addq.l    #4,(A0)
00003632  2611      10083          move.l    (A1),D3
                    10084   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003634  2002      10085          move.l    D2,D0
00003636  0680 0000 10086          add.l     #22,D0
0000363A  0016      
0000363C  2040      10087          move.l    D0,A0
0000363E  5350      10088          subq.w    #1,(A0)
                    10089   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003640  2042      10090          move.l    D2,A0
00003642  2242      10091          move.l    D2,A1
00003644  2028 0010 10092          move.l    16(A0),D0
00003648  B0A9 0008 10093          cmp.l     8(A1),D0
0000364C  660A      10094          bne.s     OSQAccept_6
                    10095   ; pq->OSQOut = pq->OSQStart;
0000364E  2042      10096          move.l    D2,A0
00003650  2242      10097          move.l    D2,A1
00003652  2368 0004 10098          move.l    4(A0),16(A1)
00003656  0010      
                    10099   OSQAccept_6:
                    10100   ; }
                    10101   ; *perr = OS_ERR_NONE;
00003658  2044      10102          move.l    D4,A0
0000365A  4210      10103          clr.b     (A0)
0000365C  6008      10104          bra.s     OSQAccept_5
                    10105   OSQAccept_4:
                    10106   ; } else {
                    10107   ; *perr = OS_ERR_Q_EMPTY;
0000365E  2044      10108          move.l    D4,A0
00003660  10BC 001F 10109          move.b    #31,(A0)
                    10110   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
00003664  4283      10111          clr.l     D3
                    10112   OSQAccept_5:
                    10113   ; }
                    10114   ; OS_EXIT_CRITICAL();
00003666  46DF      10115          dc.w      18143
                    10116   ; return (pmsg);                               /* Return message received (or NULL)                  */
00003668  2003      10117          move.l    D3,D0
                    10118   OSQAccept_3:
0000366A  4CDF 001C 10119          movem.l   (A7)+,D2/D3/D4
0000366E  4E5E      10120          unlk      A6
00003670  4E75      10121          rts
                    10122   ; }
                    10123   ; #endif
                    10124   ; /*$PAGE*/
                    10125   ; /*
                    10126   ; *********************************************************************************************************
                    10127   ; *                                       CREATE A MESSAGE QUEUE
                    10128   ; *
                    10129   ; * Description: This function creates a message queue if free event control blocks are available.
                    10130   ; *
                    10131   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    10132   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    10133   ; *
                    10134   ; *                            void *MessageStorage[size]
                    10135   ; *
                    10136   ; *              size          is the number of elements in the storage area
                    10137   ; *
                    10138   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    10139   ; *                                created queue
                    10140   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    10141   ; *********************************************************************************************************
                    10142   ; */
                    10143   ; OS_EVENT  *OSQCreate (void    **start,
                    10144   ; INT16U    size)
                    10145   ; {
                    10146   _OSQCreate:
00003672  4E56 0000 10147          link      A6,#0
00003676  48E7 3830 10148          movem.l   D2/D3/D4/A2/A3,-(A7)
0000367A  45F9 0800 10149          lea       _OSEventFreeList.L,A2
0000367E  01FA      
00003680  282E 0008 10150          move.l    8(A6),D4
00003684  47F9 0800 10151          lea       _OSQFreeList.L,A3
00003688  0E30      
                    10152   ; OS_EVENT  *pevent;
                    10153   ; OS_Q      *pq;
                    10154   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10155   ; OS_CPU_SR  cpu_sr = 0u;
                    10156   ; #endif
                    10157   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10158   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10159   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10160   ; return ((OS_EVENT *)0);
                    10161   ; }
                    10162   ; #endif
                    10163   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
0000368A  1039 0800 10164          move.b    _OSIntNesting.L,D0
0000368E  0426      
00003690  0C00 0000 10165          cmp.b     #0,D0
00003694  6306      10166          bls.s     OSQCreate_1
                    10167   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00003696  4280      10168          clr.l     D0
00003698  6000 009C 10169          bra       OSQCreate_3
                    10170   OSQCreate_1:
                    10171   ; }
                    10172   ; OS_ENTER_CRITICAL();
0000369C  40E7      10173          dc.w      16615
0000369E  007C      10174          dc.w      124
000036A0  0700      10175          dc.w      1792
                    10176   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000036A2  2412      10177          move.l    (A2),D2
                    10178   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000036A4  2012      10179          move.l    (A2),D0
000036A6  6706      10180          beq.s     OSQCreate_4
                    10181   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000036A8  2052      10182          move.l    (A2),A0
000036AA  24A8 0002 10183          move.l    2(A0),(A2)
                    10184   OSQCreate_4:
                    10185   ; }
                    10186   ; OS_EXIT_CRITICAL();
000036AE  46DF      10187          dc.w      18143
                    10188   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
000036B0  4A82      10189          tst.l     D2
000036B2  6700 0080 10190          beq       OSQCreate_9
                    10191   ; OS_ENTER_CRITICAL();
000036B6  40E7      10192          dc.w      16615
000036B8  007C      10193          dc.w      124
000036BA  0700      10194          dc.w      1792
                    10195   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
000036BC  2613      10196          move.l    (A3),D3
                    10197   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
000036BE  4A83      10198          tst.l     D3
000036C0  6700 0066 10199          beq       OSQCreate_8
                    10200   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
000036C4  2053      10201          move.l    (A3),A0
000036C6  2690      10202          move.l    (A0),(A3)
                    10203   ; OS_EXIT_CRITICAL();
000036C8  46DF      10204          dc.w      18143
                    10205   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
000036CA  2043      10206          move.l    D3,A0
000036CC  2144 0004 10207          move.l    D4,4(A0)
                    10208   ; pq->OSQEnd             = &start[size];
000036D0  2004      10209          move.l    D4,D0
000036D2  322E 000E 10210          move.w    14(A6),D1
000036D6  C2BC 0000 10211          and.l     #65535,D1
000036DA  FFFF      
000036DC  E589      10212          lsl.l     #2,D1
000036DE  D081      10213          add.l     D1,D0
000036E0  2043      10214          move.l    D3,A0
000036E2  2140 0008 10215          move.l    D0,8(A0)
                    10216   ; pq->OSQIn              = start;
000036E6  2043      10217          move.l    D3,A0
000036E8  2144 000C 10218          move.l    D4,12(A0)
                    10219   ; pq->OSQOut             = start;
000036EC  2043      10220          move.l    D3,A0
000036EE  2144 0010 10221          move.l    D4,16(A0)
                    10222   ; pq->OSQSize            = size;
000036F2  2043      10223          move.l    D3,A0
000036F4  316E 000E 10224          move.w    14(A6),20(A0)
000036F8  0014      
                    10225   ; pq->OSQEntries         = 0u;
000036FA  2043      10226          move.l    D3,A0
000036FC  4268 0016 10227          clr.w     22(A0)
                    10228   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
00003700  2042      10229          move.l    D2,A0
00003702  10BC 0002 10230          move.b    #2,(A0)
                    10231   ; pevent->OSEventCnt     = 0u;
00003706  2042      10232          move.l    D2,A0
00003708  4268 0006 10233          clr.w     6(A0)
                    10234   ; pevent->OSEventPtr     = pq;
0000370C  2042      10235          move.l    D2,A0
0000370E  2143 0002 10236          move.l    D3,2(A0)
                    10237   ; #if OS_EVENT_NAME_EN > 0u
                    10238   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003712  41F9 0000 10239          lea       @ucos_ii_1.L,A0
00003716  763A      
00003718  2242      10240          move.l    D2,A1
0000371A  2348 0012 10241          move.l    A0,18(A1)
                    10242   ; #endif
                    10243   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
0000371E  2F02      10244          move.l    D2,-(A7)
00003720  4EB8 13A0 10245          jsr       _OS_EventWaitListInit
00003724  584F      10246          addq.w    #4,A7
00003726  600C      10247          bra.s     OSQCreate_9
                    10248   OSQCreate_8:
                    10249   ; } else {
                    10250   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
00003728  2042      10251          move.l    D2,A0
0000372A  2152 0002 10252          move.l    (A2),2(A0)
                    10253   ; OSEventFreeList    = pevent;
0000372E  2482      10254          move.l    D2,(A2)
                    10255   ; OS_EXIT_CRITICAL();
00003730  46DF      10256          dc.w      18143
                    10257   ; pevent = (OS_EVENT *)0;
00003732  4282      10258          clr.l     D2
                    10259   OSQCreate_9:
                    10260   ; }
                    10261   ; }
                    10262   ; return (pevent);
00003734  2002      10263          move.l    D2,D0
                    10264   OSQCreate_3:
00003736  4CDF 0C1C 10265          movem.l   (A7)+,D2/D3/D4/A2/A3
0000373A  4E5E      10266          unlk      A6
0000373C  4E75      10267          rts
                    10268   ; }
                    10269   ; /*$PAGE*/
                    10270   ; /*
                    10271   ; *********************************************************************************************************
                    10272   ; *                                       DELETE A MESSAGE QUEUE
                    10273   ; *
                    10274   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10275   ; *
                    10276   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10277   ; *                            queue.
                    10278   ; *
                    10279   ; *              opt           determines delete options as follows:
                    10280   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10281   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10282   ; *                                                    In this case, all the tasks pending will be readied.
                    10283   ; *
                    10284   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10285   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10286   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10287   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10288   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10289   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10290   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10291   ; *
                    10292   ; * Returns    : pevent        upon error
                    10293   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10294   ; *
                    10295   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10296   ; *                 the queue MUST check the return code of OSQPend().
                    10297   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10298   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10299   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10300   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10301   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10302   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10303   ; *                 will no longer be guarded by the queue.
                    10304   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10305   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10306   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10307   ; *                 then, the storage can be reused.
                    10308   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10309   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10310   ; *********************************************************************************************************
                    10311   ; */
                    10312   ; #if OS_Q_DEL_EN > 0u
                    10313   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10314   ; INT8U      opt,
                    10315   ; INT8U     *perr)
                    10316   ; {
                    10317   _OSQDel:
0000373E  4E56 0000 10318          link      A6,#0
00003742  48E7 3E30 10319          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
00003746  242E 0008 10320          move.l    8(A6),D2
0000374A  282E 0010 10321          move.l    16(A6),D4
0000374E  45F9 0800 10322          lea       _OSEventFreeList.L,A2
00003752  01FA      
00003754  47F9 0800 10323          lea       _OSQFreeList.L,A3
00003758  0E30      
                    10324   ; BOOLEAN    tasks_waiting;
                    10325   ; OS_EVENT  *pevent_return;
                    10326   ; OS_Q      *pq;
                    10327   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10328   ; OS_CPU_SR  cpu_sr = 0u;
                    10329   ; #endif
                    10330   ; #ifdef OS_SAFETY_CRITICAL
                    10331   ; if (perr == (INT8U *)0) {
                    10332   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10333   ; return ((OS_EVENT *)0);
                    10334   ; }
                    10335   ; #endif
                    10336   ; #if OS_ARG_CHK_EN > 0u
                    10337   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10338   ; *perr = OS_ERR_PEVENT_NULL;
                    10339   ; return (pevent);
                    10340   ; }
                    10341   ; #endif
                    10342   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000375A  2042      10343          move.l    D2,A0
0000375C  1010      10344          move.b    (A0),D0
0000375E  0C00 0002 10345          cmp.b     #2,D0
00003762  670C      10346          beq.s     OSQDel_1
                    10347   ; *perr = OS_ERR_EVENT_TYPE;
00003764  2044      10348          move.l    D4,A0
00003766  10BC 0001 10349          move.b    #1,(A0)
                    10350   ; return (pevent);
0000376A  2002      10351          move.l    D2,D0
0000376C  6000 0104 10352          bra       OSQDel_3
                    10353   OSQDel_1:
                    10354   ; }
                    10355   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003770  1039 0800 10356          move.b    _OSIntNesting.L,D0
00003774  0426      
00003776  0C00 0000 10357          cmp.b     #0,D0
0000377A  630C      10358          bls.s     OSQDel_4
                    10359   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0000377C  2044      10360          move.l    D4,A0
0000377E  10BC 000F 10361          move.b    #15,(A0)
                    10362   ; return (pevent);
00003782  2002      10363          move.l    D2,D0
00003784  6000 00EC 10364          bra       OSQDel_3
                    10365   OSQDel_4:
                    10366   ; }
                    10367   ; OS_ENTER_CRITICAL();
00003788  40E7      10368          dc.w      16615
0000378A  007C      10369          dc.w      124
0000378C  0700      10370          dc.w      1792
                    10371   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
0000378E  2042      10372          move.l    D2,A0
00003790  1028 0008 10373          move.b    8(A0),D0
00003794  6704      10374          beq.s     OSQDel_6
                    10375   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003796  7C01      10376          moveq     #1,D6
00003798  6002      10377          bra.s     OSQDel_7
                    10378   OSQDel_6:
                    10379   ; } else {
                    10380   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000379A  4206      10381          clr.b     D6
                    10382   OSQDel_7:
                    10383   ; }
                    10384   ; switch (opt) {
0000379C  102E 000F 10385          move.b    15(A6),D0
000037A0  C0BC 0000 10386          and.l     #255,D0
000037A4  00FF      
000037A6  0C80 0000 10387          cmp.l     #1,D0
000037AA  0001      
000037AC  6700 0056 10388          beq       OSQDel_11
000037B0  6200 00B4 10389          bhi       OSQDel_8
000037B4  4A80      10390          tst.l     D0
000037B6  6704      10391          beq.s     OSQDel_10
000037B8  6000 00AC 10392          bra       OSQDel_8
                    10393   OSQDel_10:
                    10394   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10395   ; if (tasks_waiting == OS_FALSE) {
000037BC  4A06      10396          tst.b     D6
000037BE  6600 0036 10397          bne       OSQDel_13
                    10398   ; #if OS_EVENT_NAME_EN > 0u
                    10399   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000037C2  41F9 0000 10400          lea       @ucos_ii_1.L,A0
000037C6  763A      
000037C8  2242      10401          move.l    D2,A1
000037CA  2348 0012 10402          move.l    A0,18(A1)
                    10403   ; #endif
                    10404   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
000037CE  2042      10405          move.l    D2,A0
000037D0  2628 0002 10406          move.l    2(A0),D3
                    10407   ; pq->OSQPtr             = OSQFreeList;
000037D4  2043      10408          move.l    D3,A0
000037D6  2093      10409          move.l    (A3),(A0)
                    10410   ; OSQFreeList            = pq;
000037D8  2683      10411          move.l    D3,(A3)
                    10412   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000037DA  2042      10413          move.l    D2,A0
000037DC  4210      10414          clr.b     (A0)
                    10415   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
000037DE  2042      10416          move.l    D2,A0
000037E0  2152 0002 10417          move.l    (A2),2(A0)
                    10418   ; pevent->OSEventCnt     = 0u;
000037E4  2042      10419          move.l    D2,A0
000037E6  4268 0006 10420          clr.w     6(A0)
                    10421   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
000037EA  2482      10422          move.l    D2,(A2)
                    10423   ; OS_EXIT_CRITICAL();
000037EC  46DF      10424          dc.w      18143
                    10425   ; *perr                  = OS_ERR_NONE;
000037EE  2044      10426          move.l    D4,A0
000037F0  4210      10427          clr.b     (A0)
                    10428   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
000037F2  4285      10429          clr.l     D5
000037F4  600A      10430          bra.s     OSQDel_14
                    10431   OSQDel_13:
                    10432   ; } else {
                    10433   ; OS_EXIT_CRITICAL();
000037F6  46DF      10434          dc.w      18143
                    10435   ; *perr                  = OS_ERR_TASK_WAITING;
000037F8  2044      10436          move.l    D4,A0
000037FA  10BC 0049 10437          move.b    #73,(A0)
                    10438   ; pevent_return          = pevent;
000037FE  2A02      10439          move.l    D2,D5
                    10440   OSQDel_14:
                    10441   ; }
                    10442   ; break;
00003800  6000 006E 10443          bra       OSQDel_9
                    10444   OSQDel_11:
                    10445   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10446   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10447   OSQDel_15:
00003804  2042      10448          move.l    D2,A0
00003806  1028 0008 10449          move.b    8(A0),D0
0000380A  671C      10450          beq.s     OSQDel_17
                    10451   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0000380C  4878 0002 10452          pea       2
00003810  4878 0004 10453          pea       4
00003814  42A7      10454          clr.l     -(A7)
00003816  2F02      10455          move.l    D2,-(A7)
00003818  4EB8 10D8 10456          jsr       _OS_EventTaskRdy
0000381C  DEFC 0010 10457          add.w     #16,A7
00003820  C0BC 0000 10458          and.l     #255,D0
00003824  00FF      
00003826  60DC      10459          bra       OSQDel_15
                    10460   OSQDel_17:
                    10461   ; }
                    10462   ; #if OS_EVENT_NAME_EN > 0u
                    10463   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003828  41F9 0000 10464          lea       @ucos_ii_1.L,A0
0000382C  763A      
0000382E  2242      10465          move.l    D2,A1
00003830  2348 0012 10466          move.l    A0,18(A1)
                    10467   ; #endif
                    10468   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003834  2042      10469          move.l    D2,A0
00003836  2628 0002 10470          move.l    2(A0),D3
                    10471   ; pq->OSQPtr             = OSQFreeList;
0000383A  2043      10472          move.l    D3,A0
0000383C  2093      10473          move.l    (A3),(A0)
                    10474   ; OSQFreeList            = pq;
0000383E  2683      10475          move.l    D3,(A3)
                    10476   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003840  2042      10477          move.l    D2,A0
00003842  4210      10478          clr.b     (A0)
                    10479   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003844  2042      10480          move.l    D2,A0
00003846  2152 0002 10481          move.l    (A2),2(A0)
                    10482   ; pevent->OSEventCnt     = 0u;
0000384A  2042      10483          move.l    D2,A0
0000384C  4268 0006 10484          clr.w     6(A0)
                    10485   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003850  2482      10486          move.l    D2,(A2)
                    10487   ; OS_EXIT_CRITICAL();
00003852  46DF      10488          dc.w      18143
                    10489   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003854  0C06 0001 10490          cmp.b     #1,D6
00003858  6604      10491          bne.s     OSQDel_18
                    10492   ; OS_Sched();                               /* Find highest priority task ready to run  */
0000385A  4EB8 16B8 10493          jsr       _OS_Sched
                    10494   OSQDel_18:
                    10495   ; }
                    10496   ; *perr                  = OS_ERR_NONE;
0000385E  2044      10497          move.l    D4,A0
00003860  4210      10498          clr.b     (A0)
                    10499   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
00003862  4285      10500          clr.l     D5
                    10501   ; break;
00003864  600A      10502          bra.s     OSQDel_9
                    10503   OSQDel_8:
                    10504   ; default:
                    10505   ; OS_EXIT_CRITICAL();
00003866  46DF      10506          dc.w      18143
                    10507   ; *perr                  = OS_ERR_INVALID_OPT;
00003868  2044      10508          move.l    D4,A0
0000386A  10BC 0007 10509          move.b    #7,(A0)
                    10510   ; pevent_return          = pevent;
0000386E  2A02      10511          move.l    D2,D5
                    10512   ; break;
                    10513   OSQDel_9:
                    10514   ; }
                    10515   ; return (pevent_return);
00003870  2005      10516          move.l    D5,D0
                    10517   OSQDel_3:
00003872  4CDF 0C7C 10518          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
00003876  4E5E      10519          unlk      A6
00003878  4E75      10520          rts
                    10521   ; }
                    10522   ; #endif
                    10523   ; /*$PAGE*/
                    10524   ; /*
                    10525   ; *********************************************************************************************************
                    10526   ; *                                             FLUSH QUEUE
                    10527   ; *
                    10528   ; * Description : This function is used to flush the contents of the message queue.
                    10529   ; *
                    10530   ; * Arguments   : none
                    10531   ; *
                    10532   ; * Returns     : OS_ERR_NONE         upon success
                    10533   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10534   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10535   ; *
                    10536   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10537   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10538   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10539   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10540   ; *********************************************************************************************************
                    10541   ; */
                    10542   ; #if OS_Q_FLUSH_EN > 0u
                    10543   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10544   ; {
                    10545   _OSQFlush:
0000387A  4E56 0000 10546          link      A6,#0
0000387E  2F02      10547          move.l    D2,-(A7)
                    10548   ; OS_Q      *pq;
                    10549   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10550   ; OS_CPU_SR  cpu_sr = 0u;
                    10551   ; #endif
                    10552   ; #if OS_ARG_CHK_EN > 0u
                    10553   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10554   ; return (OS_ERR_PEVENT_NULL);
                    10555   ; }
                    10556   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10557   ; return (OS_ERR_EVENT_TYPE);
                    10558   ; }
                    10559   ; #endif
                    10560   ; OS_ENTER_CRITICAL();
00003880  40E7      10561          dc.w      16615
00003882  007C      10562          dc.w      124
00003884  0700      10563          dc.w      1792
                    10564   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
00003886  206E 0008 10565          move.l    8(A6),A0
0000388A  2428 0002 10566          move.l    2(A0),D2
                    10567   ; pq->OSQIn      = pq->OSQStart;
0000388E  2042      10568          move.l    D2,A0
00003890  2242      10569          move.l    D2,A1
00003892  2368 0004 10570          move.l    4(A0),12(A1)
00003896  000C      
                    10571   ; pq->OSQOut     = pq->OSQStart;
00003898  2042      10572          move.l    D2,A0
0000389A  2242      10573          move.l    D2,A1
0000389C  2368 0004 10574          move.l    4(A0),16(A1)
000038A0  0010      
                    10575   ; pq->OSQEntries = 0u;
000038A2  2042      10576          move.l    D2,A0
000038A4  4268 0016 10577          clr.w     22(A0)
                    10578   ; OS_EXIT_CRITICAL();
000038A8  46DF      10579          dc.w      18143
                    10580   ; return (OS_ERR_NONE);
000038AA  4200      10581          clr.b     D0
000038AC  241F      10582          move.l    (A7)+,D2
000038AE  4E5E      10583          unlk      A6
000038B0  4E75      10584          rts
                    10585   ; }
                    10586   ; #endif
                    10587   ; /*$PAGE*/
                    10588   ; /*
                    10589   ; *********************************************************************************************************
                    10590   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10591   ; *
                    10592   ; * Description: This function waits for a message to be sent to a queue
                    10593   ; *
                    10594   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10595   ; *
                    10596   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10597   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10598   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10599   ; *                            forever at the specified queue or, until a message arrives.
                    10600   ; *
                    10601   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10602   ; *                            messages are:
                    10603   ; *
                    10604   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10605   ; *                                                message.
                    10606   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10607   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10608   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10609   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10610   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10611   ; *                                                would lead to a suspension.
                    10612   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10613   ; *
                    10614   ; * Returns    : != (void *)0  is a pointer to the message received
                    10615   ; *              == (void *)0  if you received a NULL pointer message or,
                    10616   ; *                            if no message was received or,
                    10617   ; *                            if 'pevent' is a NULL pointer or,
                    10618   ; *                            if you didn't pass a pointer to a queue.
                    10619   ; *
                    10620   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10621   ; *********************************************************************************************************
                    10622   ; */
                    10623   ; void  *OSQPend (OS_EVENT  *pevent,
                    10624   ; INT32U     timeout,
                    10625   ; INT8U     *perr)
                    10626   ; {
                    10627   _OSQPend:
000038B2  4E56 0000 10628          link      A6,#0
000038B6  48E7 3C20 10629          movem.l   D2/D3/D4/D5/A2,-(A7)
000038BA  45F9 0800 10630          lea       _OSTCBCur.L,A2
000038BE  0540      
000038C0  262E 0010 10631          move.l    16(A6),D3
000038C4  2A2E 0008 10632          move.l    8(A6),D5
                    10633   ; void      *pmsg;
                    10634   ; OS_Q      *pq;
                    10635   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10636   ; OS_CPU_SR  cpu_sr = 0u;
                    10637   ; #endif
                    10638   ; #ifdef OS_SAFETY_CRITICAL
                    10639   ; if (perr == (INT8U *)0) {
                    10640   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10641   ; return ((void *)0);
                    10642   ; }
                    10643   ; #endif
                    10644   ; #if OS_ARG_CHK_EN > 0u
                    10645   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10646   ; *perr = OS_ERR_PEVENT_NULL;
                    10647   ; return ((void *)0);
                    10648   ; }
                    10649   ; #endif
                    10650   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
000038C8  2045      10651          move.l    D5,A0
000038CA  1010      10652          move.b    (A0),D0
000038CC  0C00 0002 10653          cmp.b     #2,D0
000038D0  670C      10654          beq.s     OSQPend_1
                    10655   ; *perr = OS_ERR_EVENT_TYPE;
000038D2  2043      10656          move.l    D3,A0
000038D4  10BC 0001 10657          move.b    #1,(A0)
                    10658   ; return ((void *)0);
000038D8  4280      10659          clr.l     D0
000038DA  6000 0128 10660          bra       OSQPend_3
                    10661   OSQPend_1:
                    10662   ; }
                    10663   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000038DE  1039 0800 10664          move.b    _OSIntNesting.L,D0
000038E2  0426      
000038E4  0C00 0000 10665          cmp.b     #0,D0
000038E8  630C      10666          bls.s     OSQPend_4
                    10667   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
000038EA  2043      10668          move.l    D3,A0
000038EC  10BC 0002 10669          move.b    #2,(A0)
                    10670   ; return ((void *)0);
000038F0  4280      10671          clr.l     D0
000038F2  6000 0110 10672          bra       OSQPend_3
                    10673   OSQPend_4:
                    10674   ; }
                    10675   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
000038F6  1039 0800 10676          move.b    _OSLockNesting.L,D0
000038FA  0428      
000038FC  0C00 0000 10677          cmp.b     #0,D0
00003900  630C      10678          bls.s     OSQPend_6
                    10679   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003902  2043      10680          move.l    D3,A0
00003904  10BC 000D 10681          move.b    #13,(A0)
                    10682   ; return ((void *)0);
00003908  4280      10683          clr.l     D0
0000390A  6000 00F8 10684          bra       OSQPend_3
                    10685   OSQPend_6:
                    10686   ; }
                    10687   ; OS_ENTER_CRITICAL();
0000390E  40E7      10688          dc.w      16615
00003910  007C      10689          dc.w      124
00003912  0700      10690          dc.w      1792
                    10691   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003914  2045      10692          move.l    D5,A0
00003916  2428 0002 10693          move.l    2(A0),D2
                    10694   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
0000391A  2042      10695          move.l    D2,A0
0000391C  3028 0016 10696          move.w    22(A0),D0
00003920  0C40 0000 10697          cmp.w     #0,D0
00003924  6300 0042 10698          bls       OSQPend_8
                    10699   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003928  2002      10700          move.l    D2,D0
0000392A  0680 0000 10701          add.l     #16,D0
0000392E  0010      
00003930  2040      10702          move.l    D0,A0
00003932  2250      10703          move.l    (A0),A1
00003934  5890      10704          addq.l    #4,(A0)
00003936  2811      10705          move.l    (A1),D4
                    10706   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003938  2002      10707          move.l    D2,D0
0000393A  0680 0000 10708          add.l     #22,D0
0000393E  0016      
00003940  2040      10709          move.l    D0,A0
00003942  5350      10710          subq.w    #1,(A0)
                    10711   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003944  2042      10712          move.l    D2,A0
00003946  2242      10713          move.l    D2,A1
00003948  2028 0010 10714          move.l    16(A0),D0
0000394C  B0A9 0008 10715          cmp.l     8(A1),D0
00003950  660A      10716          bne.s     OSQPend_10
                    10717   ; pq->OSQOut = pq->OSQStart;
00003952  2042      10718          move.l    D2,A0
00003954  2242      10719          move.l    D2,A1
00003956  2368 0004 10720          move.l    4(A0),16(A1)
0000395A  0010      
                    10721   OSQPend_10:
                    10722   ; }
                    10723   ; OS_EXIT_CRITICAL();
0000395C  46DF      10724          dc.w      18143
                    10725   ; *perr = OS_ERR_NONE;
0000395E  2043      10726          move.l    D3,A0
00003960  4210      10727          clr.b     (A0)
                    10728   ; return (pmsg);                           /* Return message received                            */
00003962  2004      10729          move.l    D4,D0
00003964  6000 009E 10730          bra       OSQPend_3
                    10731   OSQPend_8:
                    10732   ; }
                    10733   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
00003968  2052      10734          move.l    (A2),A0
0000396A  0028 0004 10735          or.b      #4,50(A0)
0000396E  0032      
                    10736   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003970  2052      10737          move.l    (A2),A0
00003972  4228 0033 10738          clr.b     51(A0)
                    10739   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00003976  2052      10740          move.l    (A2),A0
00003978  216E 000C 10741          move.l    12(A6),46(A0)
0000397C  002E      
                    10742   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
0000397E  2F05      10743          move.l    D5,-(A7)
00003980  4EB8 11BC 10744          jsr       _OS_EventTaskWait
00003984  584F      10745          addq.w    #4,A7
                    10746   ; OS_EXIT_CRITICAL();
00003986  46DF      10747          dc.w      18143
                    10748   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
00003988  4EB8 16B8 10749          jsr       _OS_Sched
                    10750   ; OS_ENTER_CRITICAL();
0000398C  40E7      10751          dc.w      16615
0000398E  007C      10752          dc.w      124
00003990  0700      10753          dc.w      1792
                    10754   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003992  2052      10755          move.l    (A2),A0
00003994  1028 0033 10756          move.b    51(A0),D0
00003998  C0BC 0000 10757          and.l     #255,D0
0000399C  00FF      
0000399E  0C80 0000 10758          cmp.l     #1,D0
000039A2  0001      
000039A4  6700 002A 10759          beq       OSQPend_16
000039A8  6206      10760          bhi.s     OSQPend_18
000039AA  4A80      10761          tst.l     D0
000039AC  670C      10762          beq.s     OSQPend_14
000039AE  6020      10763          bra.s     OSQPend_16
                    10764   OSQPend_18:
000039B0  0C80 0000 10765          cmp.l     #2,D0
000039B4  0002      
000039B6  670E      10766          beq.s     OSQPend_15
000039B8  6016      10767          bra.s     OSQPend_16
                    10768   OSQPend_14:
                    10769   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    10770   ; pmsg =  OSTCBCur->OSTCBMsg;
000039BA  2052      10771          move.l    (A2),A0
000039BC  2828 0024 10772          move.l    36(A0),D4
                    10773   ; *perr =  OS_ERR_NONE;
000039C0  2043      10774          move.l    D3,A0
000039C2  4210      10775          clr.b     (A0)
                    10776   ; break;
000039C4  601C      10777          bra.s     OSQPend_13
                    10778   OSQPend_15:
                    10779   ; case OS_STAT_PEND_ABORT:
                    10780   ; pmsg = (void *)0;
000039C6  4284      10781          clr.l     D4
                    10782   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
000039C8  2043      10783          move.l    D3,A0
000039CA  10BC 000E 10784          move.b    #14,(A0)
                    10785   ; break;
000039CE  6012      10786          bra.s     OSQPend_13
                    10787   OSQPend_16:
                    10788   ; case OS_STAT_PEND_TO:
                    10789   ; default:
                    10790   ; OS_EventTaskRemove(OSTCBCur, pevent);
000039D0  2F05      10791          move.l    D5,-(A7)
000039D2  2F12      10792          move.l    (A2),-(A7)
000039D4  4EB8 12DE 10793          jsr       _OS_EventTaskRemove
000039D8  504F      10794          addq.w    #8,A7
                    10795   ; pmsg = (void *)0;
000039DA  4284      10796          clr.l     D4
                    10797   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
000039DC  2043      10798          move.l    D3,A0
000039DE  10BC 000A 10799          move.b    #10,(A0)
                    10800   ; break;
                    10801   OSQPend_13:
                    10802   ; }
                    10803   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
000039E2  2052      10804          move.l    (A2),A0
000039E4  4228 0032 10805          clr.b     50(A0)
                    10806   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
000039E8  2052      10807          move.l    (A2),A0
000039EA  4228 0033 10808          clr.b     51(A0)
                    10809   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
000039EE  2052      10810          move.l    (A2),A0
000039F0  42A8 001C 10811          clr.l     28(A0)
                    10812   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10813   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
000039F4  2052      10814          move.l    (A2),A0
000039F6  42A8 0020 10815          clr.l     32(A0)
                    10816   ; #endif
                    10817   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
000039FA  2052      10818          move.l    (A2),A0
000039FC  42A8 0024 10819          clr.l     36(A0)
                    10820   ; OS_EXIT_CRITICAL();
00003A00  46DF      10821          dc.w      18143
                    10822   ; return (pmsg);                                    /* Return received message                       */
00003A02  2004      10823          move.l    D4,D0
                    10824   OSQPend_3:
00003A04  4CDF 043C 10825          movem.l   (A7)+,D2/D3/D4/D5/A2
00003A08  4E5E      10826          unlk      A6
00003A0A  4E75      10827          rts
                    10828   ; }
                    10829   ; /*$PAGE*/
                    10830   ; /*
                    10831   ; *********************************************************************************************************
                    10832   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    10833   ; *
                    10834   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    10835   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    10836   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    10837   ; *
                    10838   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    10839   ; *
                    10840   ; *              opt           determines the type of ABORT performed:
                    10841   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    10842   ; *                                                     queue
                    10843   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    10844   ; *                                                     queue
                    10845   ; *
                    10846   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10847   ; *                            messages are:
                    10848   ; *
                    10849   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    10850   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    10851   ; *                                                and informed of the aborted wait; check return value
                    10852   ; *                                                for the number of tasks whose wait on the queue
                    10853   ; *                                                was aborted.
                    10854   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    10855   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    10856   ; *
                    10857   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    10858   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    10859   ; *********************************************************************************************************
                    10860   ; */
                    10861   ; #if OS_Q_PEND_ABORT_EN > 0u
                    10862   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    10863   ; INT8U      opt,
                    10864   ; INT8U     *perr)
                    10865   ; {
                    10866   _OSQPendAbort:
00003A0C  4E56 0000 10867          link      A6,#0
00003A10  48E7 3800 10868          movem.l   D2/D3/D4,-(A7)
00003A14  242E 0008 10869          move.l    8(A6),D2
00003A18  282E 0010 10870          move.l    16(A6),D4
                    10871   ; INT8U      nbr_tasks;
                    10872   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10873   ; OS_CPU_SR  cpu_sr = 0u;
                    10874   ; #endif
                    10875   ; #ifdef OS_SAFETY_CRITICAL
                    10876   ; if (perr == (INT8U *)0) {
                    10877   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10878   ; return (0u);
                    10879   ; }
                    10880   ; #endif
                    10881   ; #if OS_ARG_CHK_EN > 0u
                    10882   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10883   ; *perr = OS_ERR_PEVENT_NULL;
                    10884   ; return (0u);
                    10885   ; }
                    10886   ; #endif
                    10887   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00003A1C  2042      10888          move.l    D2,A0
00003A1E  1010      10889          move.b    (A0),D0
00003A20  0C00 0002 10890          cmp.b     #2,D0
00003A24  670C      10891          beq.s     OSQPendAbort_1
                    10892   ; *perr = OS_ERR_EVENT_TYPE;
00003A26  2044      10893          move.l    D4,A0
00003A28  10BC 0001 10894          move.b    #1,(A0)
                    10895   ; return (0u);
00003A2C  4200      10896          clr.b     D0
00003A2E  6000 008C 10897          bra       OSQPendAbort_3
                    10898   OSQPendAbort_1:
                    10899   ; }
                    10900   ; OS_ENTER_CRITICAL();
00003A32  40E7      10901          dc.w      16615
00003A34  007C      10902          dc.w      124
00003A36  0700      10903          dc.w      1792
                    10904   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00003A38  2042      10905          move.l    D2,A0
00003A3A  1028 0008 10906          move.b    8(A0),D0
00003A3E  6700 0074 10907          beq       OSQPendAbort_4
                    10908   ; nbr_tasks = 0u;
00003A42  4203      10909          clr.b     D3
                    10910   ; switch (opt) {
00003A44  102E 000F 10911          move.b    15(A6),D0
00003A48  C0BC 0000 10912          and.l     #255,D0
00003A4C  00FF      
00003A4E  0C80 0000 10913          cmp.l     #1,D0
00003A52  0001      
00003A54  670A      10914          beq.s     OSQPendAbort_8
00003A56  6200 0030 10915          bhi       OSQPendAbort_9
00003A5A  4A80      10916          tst.l     D0
00003A5C  672A      10917          beq.s     OSQPendAbort_9
00003A5E  6028      10918          bra.s     OSQPendAbort_9
                    10919   OSQPendAbort_8:
                    10920   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    10921   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    10922   OSQPendAbort_11:
00003A60  2042      10923          move.l    D2,A0
00003A62  1028 0008 10924          move.b    8(A0),D0
00003A66  671E      10925          beq.s     OSQPendAbort_13
                    10926   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003A68  4878 0002 10927          pea       2
00003A6C  4878 0004 10928          pea       4
00003A70  42A7      10929          clr.l     -(A7)
00003A72  2F02      10930          move.l    D2,-(A7)
00003A74  4EB8 10D8 10931          jsr       _OS_EventTaskRdy
00003A78  DEFC 0010 10932          add.w     #16,A7
00003A7C  C0BC 0000 10933          and.l     #255,D0
00003A80  00FF      
                    10934   ; nbr_tasks++;
00003A82  5203      10935          addq.b    #1,D3
00003A84  60DA      10936          bra       OSQPendAbort_11
                    10937   OSQPendAbort_13:
                    10938   ; }
                    10939   ; break;
00003A86  601C      10940          bra.s     OSQPendAbort_7
                    10941   OSQPendAbort_9:
                    10942   ; case OS_PEND_OPT_NONE:
                    10943   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    10944   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003A88  4878 0002 10945          pea       2
00003A8C  4878 0004 10946          pea       4
00003A90  42A7      10947          clr.l     -(A7)
00003A92  2F02      10948          move.l    D2,-(A7)
00003A94  4EB8 10D8 10949          jsr       _OS_EventTaskRdy
00003A98  DEFC 0010 10950          add.w     #16,A7
00003A9C  C0BC 0000 10951          and.l     #255,D0
00003AA0  00FF      
                    10952   ; nbr_tasks++;
00003AA2  5203      10953          addq.b    #1,D3
                    10954   ; break;
                    10955   OSQPendAbort_7:
                    10956   ; }
                    10957   ; OS_EXIT_CRITICAL();
00003AA4  46DF      10958          dc.w      18143
                    10959   ; OS_Sched();                                        /* Find HPT ready to run                    */
00003AA6  4EB8 16B8 10960          jsr       _OS_Sched
                    10961   ; *perr = OS_ERR_PEND_ABORT;
00003AAA  2044      10962          move.l    D4,A0
00003AAC  10BC 000E 10963          move.b    #14,(A0)
                    10964   ; return (nbr_tasks);
00003AB0  1003      10965          move.b    D3,D0
00003AB2  6008      10966          bra.s     OSQPendAbort_3
                    10967   OSQPendAbort_4:
                    10968   ; }
                    10969   ; OS_EXIT_CRITICAL();
00003AB4  46DF      10970          dc.w      18143
                    10971   ; *perr = OS_ERR_NONE;
00003AB6  2044      10972          move.l    D4,A0
00003AB8  4210      10973          clr.b     (A0)
                    10974   ; return (0u);                                           /* No tasks waiting on queue                */
00003ABA  4200      10975          clr.b     D0
                    10976   OSQPendAbort_3:
00003ABC  4CDF 001C 10977          movem.l   (A7)+,D2/D3/D4
00003AC0  4E5E      10978          unlk      A6
00003AC2  4E75      10979          rts
                    10980   ; }
                    10981   ; #endif
                    10982   ; /*$PAGE*/
                    10983   ; /*
                    10984   ; *********************************************************************************************************
                    10985   ; *                                       POST MESSAGE TO A QUEUE
                    10986   ; *
                    10987   ; * Description: This function sends a message to a queue
                    10988   ; *
                    10989   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10990   ; *
                    10991   ; *              pmsg          is a pointer to the message to send.
                    10992   ; *
                    10993   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10994   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10995   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10996   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10997   ; *
                    10998   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10999   ; *********************************************************************************************************
                    11000   ; */
                    11001   ; #if OS_Q_POST_EN > 0u
                    11002   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    11003   ; void      *pmsg)
                    11004   ; {
                    11005   _OSQPost:
00003AC4  4E56 0000 11006          link      A6,#0
00003AC8  48E7 3000 11007          movem.l   D2/D3,-(A7)
00003ACC  262E 0008 11008          move.l    8(A6),D3
                    11009   ; OS_Q      *pq;
                    11010   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11011   ; OS_CPU_SR  cpu_sr = 0u;
                    11012   ; #endif
                    11013   ; #if OS_ARG_CHK_EN > 0u
                    11014   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11015   ; return (OS_ERR_PEVENT_NULL);
                    11016   ; }
                    11017   ; #endif
                    11018   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003AD0  2043      11019          move.l    D3,A0
00003AD2  1010      11020          move.b    (A0),D0
00003AD4  0C00 0002 11021          cmp.b     #2,D0
00003AD8  6706      11022          beq.s     OSQPost_1
                    11023   ; return (OS_ERR_EVENT_TYPE);
00003ADA  7001      11024          moveq     #1,D0
00003ADC  6000 008C 11025          bra       OSQPost_3
                    11026   OSQPost_1:
                    11027   ; }
                    11028   ; OS_ENTER_CRITICAL();
00003AE0  40E7      11029          dc.w      16615
00003AE2  007C      11030          dc.w      124
00003AE4  0700      11031          dc.w      1792
                    11032   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003AE6  2043      11033          move.l    D3,A0
00003AE8  1028 0008 11034          move.b    8(A0),D0
00003AEC  6726      11035          beq.s     OSQPost_4
                    11036   ; /* Ready highest priority task waiting on event */
                    11037   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003AEE  42A7      11038          clr.l     -(A7)
00003AF0  4878 0004 11039          pea       4
00003AF4  2F2E 000C 11040          move.l    12(A6),-(A7)
00003AF8  2F03      11041          move.l    D3,-(A7)
00003AFA  4EB8 10D8 11042          jsr       _OS_EventTaskRdy
00003AFE  DEFC 0010 11043          add.w     #16,A7
00003B02  C0BC 0000 11044          and.l     #255,D0
00003B06  00FF      
                    11045   ; OS_EXIT_CRITICAL();
00003B08  46DF      11046          dc.w      18143
                    11047   ; OS_Sched();                                    /* Find highest priority task ready to run      */
00003B0A  4EB8 16B8 11048          jsr       _OS_Sched
                    11049   ; return (OS_ERR_NONE);
00003B0E  4200      11050          clr.b     D0
00003B10  6000 0058 11051          bra       OSQPost_3
                    11052   OSQPost_4:
                    11053   ; }
                    11054   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003B14  2043      11055          move.l    D3,A0
00003B16  2428 0002 11056          move.l    2(A0),D2
                    11057   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
00003B1A  2042      11058          move.l    D2,A0
00003B1C  2242      11059          move.l    D2,A1
00003B1E  3028 0016 11060          move.w    22(A0),D0
00003B22  B069 0014 11061          cmp.w     20(A1),D0
00003B26  6508      11062          blo.s     OSQPost_6
                    11063   ; OS_EXIT_CRITICAL();
00003B28  46DF      11064          dc.w      18143
                    11065   ; return (OS_ERR_Q_FULL);
00003B2A  701E      11066          moveq     #30,D0
00003B2C  6000 003C 11067          bra       OSQPost_3
                    11068   OSQPost_6:
                    11069   ; }
                    11070   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003B30  2002      11071          move.l    D2,D0
00003B32  0680 0000 11072          add.l     #12,D0
00003B36  000C      
00003B38  2040      11073          move.l    D0,A0
00003B3A  2250      11074          move.l    (A0),A1
00003B3C  5890      11075          addq.l    #4,(A0)
00003B3E  22AE 000C 11076          move.l    12(A6),(A1)
                    11077   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003B42  2002      11078          move.l    D2,D0
00003B44  0680 0000 11079          add.l     #22,D0
00003B48  0016      
00003B4A  2040      11080          move.l    D0,A0
00003B4C  5250      11081          addq.w    #1,(A0)
                    11082   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
00003B4E  2042      11083          move.l    D2,A0
00003B50  2242      11084          move.l    D2,A1
00003B52  2028 000C 11085          move.l    12(A0),D0
00003B56  B0A9 0008 11086          cmp.l     8(A1),D0
00003B5A  660A      11087          bne.s     OSQPost_8
                    11088   ; pq->OSQIn = pq->OSQStart;
00003B5C  2042      11089          move.l    D2,A0
00003B5E  2242      11090          move.l    D2,A1
00003B60  2368 0004 11091          move.l    4(A0),12(A1)
00003B64  000C      
                    11092   OSQPost_8:
                    11093   ; }
                    11094   ; OS_EXIT_CRITICAL();
00003B66  46DF      11095          dc.w      18143
                    11096   ; return (OS_ERR_NONE);
00003B68  4200      11097          clr.b     D0
                    11098   OSQPost_3:
00003B6A  4CDF 000C 11099          movem.l   (A7)+,D2/D3
00003B6E  4E5E      11100          unlk      A6
00003B70  4E75      11101          rts
                    11102   ; }
                    11103   ; #endif
                    11104   ; /*$PAGE*/
                    11105   ; /*
                    11106   ; *********************************************************************************************************
                    11107   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    11108   ; *
                    11109   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    11110   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    11111   ; *              'priority' messages.
                    11112   ; *
                    11113   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11114   ; *
                    11115   ; *              pmsg          is a pointer to the message to send.
                    11116   ; *
                    11117   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11118   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11119   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11120   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11121   ; *
                    11122   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11123   ; *********************************************************************************************************
                    11124   ; */
                    11125   ; #if OS_Q_POST_FRONT_EN > 0u
                    11126   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    11127   ; void      *pmsg)
                    11128   ; {
                    11129   _OSQPostFront:
00003B72  4E56 0000 11130          link      A6,#0
00003B76  48E7 3000 11131          movem.l   D2/D3,-(A7)
00003B7A  262E 0008 11132          move.l    8(A6),D3
                    11133   ; OS_Q      *pq;
                    11134   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11135   ; OS_CPU_SR  cpu_sr = 0u;
                    11136   ; #endif
                    11137   ; #if OS_ARG_CHK_EN > 0u
                    11138   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11139   ; return (OS_ERR_PEVENT_NULL);
                    11140   ; }
                    11141   ; #endif
                    11142   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003B7E  2043      11143          move.l    D3,A0
00003B80  1010      11144          move.b    (A0),D0
00003B82  0C00 0002 11145          cmp.b     #2,D0
00003B86  6706      11146          beq.s     OSQPostFront_1
                    11147   ; return (OS_ERR_EVENT_TYPE);
00003B88  7001      11148          moveq     #1,D0
00003B8A  6000 0090 11149          bra       OSQPostFront_3
                    11150   OSQPostFront_1:
                    11151   ; }
                    11152   ; OS_ENTER_CRITICAL();
00003B8E  40E7      11153          dc.w      16615
00003B90  007C      11154          dc.w      124
00003B92  0700      11155          dc.w      1792
                    11156   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00003B94  2043      11157          move.l    D3,A0
00003B96  1028 0008 11158          move.b    8(A0),D0
00003B9A  6726      11159          beq.s     OSQPostFront_4
                    11160   ; /* Ready highest priority task waiting on event  */
                    11161   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003B9C  42A7      11162          clr.l     -(A7)
00003B9E  4878 0004 11163          pea       4
00003BA2  2F2E 000C 11164          move.l    12(A6),-(A7)
00003BA6  2F03      11165          move.l    D3,-(A7)
00003BA8  4EB8 10D8 11166          jsr       _OS_EventTaskRdy
00003BAC  DEFC 0010 11167          add.w     #16,A7
00003BB0  C0BC 0000 11168          and.l     #255,D0
00003BB4  00FF      
                    11169   ; OS_EXIT_CRITICAL();
00003BB6  46DF      11170          dc.w      18143
                    11171   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00003BB8  4EB8 16B8 11172          jsr       _OS_Sched
                    11173   ; return (OS_ERR_NONE);
00003BBC  4200      11174          clr.b     D0
00003BBE  6000 005C 11175          bra       OSQPostFront_3
                    11176   OSQPostFront_4:
                    11177   ; }
                    11178   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003BC2  2043      11179          move.l    D3,A0
00003BC4  2428 0002 11180          move.l    2(A0),D2
                    11181   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003BC8  2042      11182          move.l    D2,A0
00003BCA  2242      11183          move.l    D2,A1
00003BCC  3028 0016 11184          move.w    22(A0),D0
00003BD0  B069 0014 11185          cmp.w     20(A1),D0
00003BD4  6508      11186          blo.s     OSQPostFront_6
                    11187   ; OS_EXIT_CRITICAL();
00003BD6  46DF      11188          dc.w      18143
                    11189   ; return (OS_ERR_Q_FULL);
00003BD8  701E      11190          moveq     #30,D0
00003BDA  6000 0040 11191          bra       OSQPostFront_3
                    11192   OSQPostFront_6:
                    11193   ; }
                    11194   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
00003BDE  2042      11195          move.l    D2,A0
00003BE0  2242      11196          move.l    D2,A1
00003BE2  2028 0010 11197          move.l    16(A0),D0
00003BE6  B0A9 0004 11198          cmp.l     4(A1),D0
00003BEA  660A      11199          bne.s     OSQPostFront_8
                    11200   ; pq->OSQOut = pq->OSQEnd;
00003BEC  2042      11201          move.l    D2,A0
00003BEE  2242      11202          move.l    D2,A1
00003BF0  2368 0008 11203          move.l    8(A0),16(A1)
00003BF4  0010      
                    11204   OSQPostFront_8:
                    11205   ; }
                    11206   ; pq->OSQOut--;
00003BF6  2002      11207          move.l    D2,D0
00003BF8  0680 0000 11208          add.l     #16,D0
00003BFC  0010      
00003BFE  2040      11209          move.l    D0,A0
00003C00  5990      11210          subq.l    #4,(A0)
                    11211   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003C02  2042      11212          move.l    D2,A0
00003C04  2068 0010 11213          move.l    16(A0),A0
00003C08  20AE 000C 11214          move.l    12(A6),(A0)
                    11215   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003C0C  2002      11216          move.l    D2,D0
00003C0E  0680 0000 11217          add.l     #22,D0
00003C12  0016      
00003C14  2040      11218          move.l    D0,A0
00003C16  5250      11219          addq.w    #1,(A0)
                    11220   ; OS_EXIT_CRITICAL();
00003C18  46DF      11221          dc.w      18143
                    11222   ; return (OS_ERR_NONE);
00003C1A  4200      11223          clr.b     D0
                    11224   OSQPostFront_3:
00003C1C  4CDF 000C 11225          movem.l   (A7)+,D2/D3
00003C20  4E5E      11226          unlk      A6
00003C22  4E75      11227          rts
                    11228   ; }
                    11229   ; #endif
                    11230   ; /*$PAGE*/
                    11231   ; /*
                    11232   ; *********************************************************************************************************
                    11233   ; *                                       POST MESSAGE TO A QUEUE
                    11234   ; *
                    11235   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11236   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11237   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11238   ; *
                    11239   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11240   ; *
                    11241   ; *              pmsg          is a pointer to the message to send.
                    11242   ; *
                    11243   ; *              opt           determines the type of POST performed:
                    11244   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11245   ; *                                                     (Identical to OSQPost())
                    11246   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11247   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11248   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11249   ; *
                    11250   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11251   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11252   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11253   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11254   ; *
                    11255   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11256   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11257   ; *********************************************************************************************************
                    11258   ; */
                    11259   ; #if OS_Q_POST_OPT_EN > 0u
                    11260   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11261   ; void      *pmsg,
                    11262   ; INT8U      opt)
                    11263   ; {
                    11264   _OSQPostOpt:
00003C24  4E56 0000 11265          link      A6,#0
00003C28  48E7 3C00 11266          movem.l   D2/D3/D4/D5,-(A7)
00003C2C  262E 0008 11267          move.l    8(A6),D3
00003C30  282E 000C 11268          move.l    12(A6),D4
00003C34  1A2E 0013 11269          move.b    19(A6),D5
00003C38  CABC 0000 11270          and.l     #255,D5
00003C3C  00FF      
                    11271   ; OS_Q      *pq;
                    11272   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11273   ; OS_CPU_SR  cpu_sr = 0u;
                    11274   ; #endif
                    11275   ; #if OS_ARG_CHK_EN > 0u
                    11276   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11277   ; return (OS_ERR_PEVENT_NULL);
                    11278   ; }
                    11279   ; #endif
                    11280   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003C3E  2043      11281          move.l    D3,A0
00003C40  1010      11282          move.b    (A0),D0
00003C42  0C00 0002 11283          cmp.b     #2,D0
00003C46  6706      11284          beq.s     OSQPostOpt_1
                    11285   ; return (OS_ERR_EVENT_TYPE);
00003C48  7001      11286          moveq     #1,D0
00003C4A  6000 00F6 11287          bra       OSQPostOpt_3
                    11288   OSQPostOpt_1:
                    11289   ; }
                    11290   ; OS_ENTER_CRITICAL();
00003C4E  40E7      11291          dc.w      16615
00003C50  007C      11292          dc.w      124
00003C52  0700      11293          dc.w      1792
                    11294   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003C54  2043      11295          move.l    D3,A0
00003C56  1028 0008 11296          move.b    8(A0),D0
00003C5A  6700 005A 11297          beq       OSQPostOpt_4
                    11298   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00003C5E  1005      11299          move.b    D5,D0
00003C60  C03C 0001 11300          and.b     #1,D0
00003C64  6724      11301          beq.s     OSQPostOpt_6
                    11302   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11303   OSQPostOpt_8:
00003C66  2043      11304          move.l    D3,A0
00003C68  1028 0008 11305          move.b    8(A0),D0
00003C6C  671A      11306          beq.s     OSQPostOpt_10
                    11307   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003C6E  42A7      11308          clr.l     -(A7)
00003C70  4878 0004 11309          pea       4
00003C74  2F04      11310          move.l    D4,-(A7)
00003C76  2F03      11311          move.l    D3,-(A7)
00003C78  4EB8 10D8 11312          jsr       _OS_EventTaskRdy
00003C7C  DEFC 0010 11313          add.w     #16,A7
00003C80  C0BC 0000 11314          and.l     #255,D0
00003C84  00FF      
00003C86  60DE      11315          bra       OSQPostOpt_8
                    11316   OSQPostOpt_10:
00003C88  6018      11317          bra.s     OSQPostOpt_7
                    11318   OSQPostOpt_6:
                    11319   ; }
                    11320   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11321   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003C8A  42A7      11322          clr.l     -(A7)
00003C8C  4878 0004 11323          pea       4
00003C90  2F04      11324          move.l    D4,-(A7)
00003C92  2F03      11325          move.l    D3,-(A7)
00003C94  4EB8 10D8 11326          jsr       _OS_EventTaskRdy
00003C98  DEFC 0010 11327          add.w     #16,A7
00003C9C  C0BC 0000 11328          and.l     #255,D0
00003CA0  00FF      
                    11329   OSQPostOpt_7:
                    11330   ; }
                    11331   ; OS_EXIT_CRITICAL();
00003CA2  46DF      11332          dc.w      18143
                    11333   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00003CA4  1005      11334          move.b    D5,D0
00003CA6  C03C 0004 11335          and.b     #4,D0
00003CAA  6604      11336          bne.s     OSQPostOpt_11
                    11337   ; OS_Sched();                               /* Find highest priority task ready to run       */
00003CAC  4EB8 16B8 11338          jsr       _OS_Sched
                    11339   OSQPostOpt_11:
                    11340   ; }
                    11341   ; return (OS_ERR_NONE);
00003CB0  4200      11342          clr.b     D0
00003CB2  6000 008E 11343          bra       OSQPostOpt_3
                    11344   OSQPostOpt_4:
                    11345   ; }
                    11346   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003CB6  2043      11347          move.l    D3,A0
00003CB8  2428 0002 11348          move.l    2(A0),D2
                    11349   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003CBC  2042      11350          move.l    D2,A0
00003CBE  2242      11351          move.l    D2,A1
00003CC0  3028 0016 11352          move.w    22(A0),D0
00003CC4  B069 0014 11353          cmp.w     20(A1),D0
00003CC8  6508      11354          blo.s     OSQPostOpt_13
                    11355   ; OS_EXIT_CRITICAL();
00003CCA  46DF      11356          dc.w      18143
                    11357   ; return (OS_ERR_Q_FULL);
00003CCC  701E      11358          moveq     #30,D0
00003CCE  6000 0072 11359          bra       OSQPostOpt_3
                    11360   OSQPostOpt_13:
                    11361   ; }
                    11362   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00003CD2  1005      11363          move.b    D5,D0
00003CD4  C03C 0002 11364          and.b     #2,D0
00003CD8  6700 0030 11365          beq       OSQPostOpt_15
                    11366   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00003CDC  2042      11367          move.l    D2,A0
00003CDE  2242      11368          move.l    D2,A1
00003CE0  2028 0010 11369          move.l    16(A0),D0
00003CE4  B0A9 0004 11370          cmp.l     4(A1),D0
00003CE8  660A      11371          bne.s     OSQPostOpt_17
                    11372   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00003CEA  2042      11373          move.l    D2,A0
00003CEC  2242      11374          move.l    D2,A1
00003CEE  2368 0008 11375          move.l    8(A0),16(A1)
00003CF2  0010      
                    11376   OSQPostOpt_17:
                    11377   ; }
                    11378   ; pq->OSQOut--;
00003CF4  2002      11379          move.l    D2,D0
00003CF6  0680 0000 11380          add.l     #16,D0
00003CFA  0010      
00003CFC  2040      11381          move.l    D0,A0
00003CFE  5990      11382          subq.l    #4,(A0)
                    11383   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
00003D00  2042      11384          move.l    D2,A0
00003D02  2068 0010 11385          move.l    16(A0),A0
00003D06  2084      11386          move.l    D4,(A0)
00003D08  6028      11387          bra.s     OSQPostOpt_19
                    11388   OSQPostOpt_15:
                    11389   ; } else {                                          /* No,  Post as FIFO                             */
                    11390   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00003D0A  2002      11391          move.l    D2,D0
00003D0C  0680 0000 11392          add.l     #12,D0
00003D10  000C      
00003D12  2040      11393          move.l    D0,A0
00003D14  2250      11394          move.l    (A0),A1
00003D16  5890      11395          addq.l    #4,(A0)
00003D18  2284      11396          move.l    D4,(A1)
                    11397   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00003D1A  2042      11398          move.l    D2,A0
00003D1C  2242      11399          move.l    D2,A1
00003D1E  2028 000C 11400          move.l    12(A0),D0
00003D22  B0A9 0008 11401          cmp.l     8(A1),D0
00003D26  660A      11402          bne.s     OSQPostOpt_19
                    11403   ; pq->OSQIn = pq->OSQStart;
00003D28  2042      11404          move.l    D2,A0
00003D2A  2242      11405          move.l    D2,A1
00003D2C  2368 0004 11406          move.l    4(A0),12(A1)
00003D30  000C      
                    11407   OSQPostOpt_19:
                    11408   ; }
                    11409   ; }
                    11410   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003D32  2002      11411          move.l    D2,D0
00003D34  0680 0000 11412          add.l     #22,D0
00003D38  0016      
00003D3A  2040      11413          move.l    D0,A0
00003D3C  5250      11414          addq.w    #1,(A0)
                    11415   ; OS_EXIT_CRITICAL();
00003D3E  46DF      11416          dc.w      18143
                    11417   ; return (OS_ERR_NONE);
00003D40  4200      11418          clr.b     D0
                    11419   OSQPostOpt_3:
00003D42  4CDF 003C 11420          movem.l   (A7)+,D2/D3/D4/D5
00003D46  4E5E      11421          unlk      A6
00003D48  4E75      11422          rts
                    11423   ; }
                    11424   ; #endif
                    11425   ; /*$PAGE*/
                    11426   ; /*
                    11427   ; *********************************************************************************************************
                    11428   ; *                                        QUERY A MESSAGE QUEUE
                    11429   ; *
                    11430   ; * Description: This function obtains information about a message queue.
                    11431   ; *
                    11432   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11433   ; *
                    11434   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11435   ; *                            queue.
                    11436   ; *
                    11437   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11438   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11439   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11440   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11441   ; *********************************************************************************************************
                    11442   ; */
                    11443   ; #if OS_Q_QUERY_EN > 0u
                    11444   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11445   ; OS_Q_DATA *p_q_data)
                    11446   ; {
                    11447   _OSQQuery:
00003D4A  4E56 FFF8 11448          link      A6,#-8
00003D4E  48E7 3C00 11449          movem.l   D2/D3/D4/D5,-(A7)
00003D52  242E 000C 11450          move.l    12(A6),D2
00003D56  282E 0008 11451          move.l    8(A6),D4
                    11452   ; OS_Q       *pq;
                    11453   ; INT8U       i;
                    11454   ; OS_PRIO    *psrc;
                    11455   ; OS_PRIO    *pdest;
                    11456   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11457   ; OS_CPU_SR   cpu_sr = 0u;
                    11458   ; #endif
                    11459   ; #if OS_ARG_CHK_EN > 0u
                    11460   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11461   ; return (OS_ERR_PEVENT_NULL);
                    11462   ; }
                    11463   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11464   ; return (OS_ERR_PDATA_NULL);
                    11465   ; }
                    11466   ; #endif
                    11467   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003D5A  2044      11468          move.l    D4,A0
00003D5C  1010      11469          move.b    (A0),D0
00003D5E  0C00 0002 11470          cmp.b     #2,D0
00003D62  6706      11471          beq.s     OSQQuery_1
                    11472   ; return (OS_ERR_EVENT_TYPE);
00003D64  7001      11473          moveq     #1,D0
00003D66  6000 007A 11474          bra       OSQQuery_3
                    11475   OSQQuery_1:
                    11476   ; }
                    11477   ; OS_ENTER_CRITICAL();
00003D6A  40E7      11478          dc.w      16615
00003D6C  007C      11479          dc.w      124
00003D6E  0700      11480          dc.w      1792
                    11481   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00003D70  2044      11482          move.l    D4,A0
00003D72  2242      11483          move.l    D2,A1
00003D74  1368 0008 11484          move.b    8(A0),16(A1)
00003D78  0010      
                    11485   ; psrc                 = &pevent->OSEventTbl[0];
00003D7A  700A      11486          moveq     #10,D0
00003D7C  D084      11487          add.l     D4,D0
00003D7E  2D40 FFF8 11488          move.l    D0,-8(A6)
                    11489   ; pdest                = &p_q_data->OSEventTbl[0];
00003D82  7008      11490          moveq     #8,D0
00003D84  D082      11491          add.l     D2,D0
00003D86  2D40 FFFC 11492          move.l    D0,-4(A6)
                    11493   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003D8A  4205      11494          clr.b     D5
                    11495   OSQQuery_4:
00003D8C  0C05 0008 11496          cmp.b     #8,D5
00003D90  6416      11497          bhs.s     OSQQuery_6
                    11498   ; *pdest++ = *psrc++;
00003D92  206E FFF8 11499          move.l    -8(A6),A0
00003D96  52AE FFF8 11500          addq.l    #1,-8(A6)
00003D9A  226E FFFC 11501          move.l    -4(A6),A1
00003D9E  52AE FFFC 11502          addq.l    #1,-4(A6)
00003DA2  1290      11503          move.b    (A0),(A1)
00003DA4  5205      11504          addq.b    #1,D5
00003DA6  60E4      11505          bra       OSQQuery_4
                    11506   OSQQuery_6:
                    11507   ; }
                    11508   ; pq = (OS_Q *)pevent->OSEventPtr;
00003DA8  2044      11509          move.l    D4,A0
00003DAA  2628 0002 11510          move.l    2(A0),D3
                    11511   ; if (pq->OSQEntries > 0u) {
00003DAE  2043      11512          move.l    D3,A0
00003DB0  3028 0016 11513          move.w    22(A0),D0
00003DB4  0C40 0000 11514          cmp.w     #0,D0
00003DB8  630C      11515          bls.s     OSQQuery_7
                    11516   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00003DBA  2043      11517          move.l    D3,A0
00003DBC  2068 0010 11518          move.l    16(A0),A0
00003DC0  2242      11519          move.l    D2,A1
00003DC2  2290      11520          move.l    (A0),(A1)
00003DC4  6004      11521          bra.s     OSQQuery_8
                    11522   OSQQuery_7:
                    11523   ; } else {
                    11524   ; p_q_data->OSMsg = (void *)0;
00003DC6  2042      11525          move.l    D2,A0
00003DC8  4290      11526          clr.l     (A0)
                    11527   OSQQuery_8:
                    11528   ; }
                    11529   ; p_q_data->OSNMsgs = pq->OSQEntries;
00003DCA  2043      11530          move.l    D3,A0
00003DCC  2242      11531          move.l    D2,A1
00003DCE  3368 0016 11532          move.w    22(A0),4(A1)
00003DD2  0004      
                    11533   ; p_q_data->OSQSize = pq->OSQSize;
00003DD4  2043      11534          move.l    D3,A0
00003DD6  2242      11535          move.l    D2,A1
00003DD8  3368 0014 11536          move.w    20(A0),6(A1)
00003DDC  0006      
                    11537   ; OS_EXIT_CRITICAL();
00003DDE  46DF      11538          dc.w      18143
                    11539   ; return (OS_ERR_NONE);
00003DE0  4200      11540          clr.b     D0
                    11541   OSQQuery_3:
00003DE2  4CDF 003C 11542          movem.l   (A7)+,D2/D3/D4/D5
00003DE6  4E5E      11543          unlk      A6
00003DE8  4E75      11544          rts
                    11545   ; }
                    11546   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11547   ; /*$PAGE*/
                    11548   ; /*
                    11549   ; *********************************************************************************************************
                    11550   ; *                                     QUEUE MODULE INITIALIZATION
                    11551   ; *
                    11552   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11553   ; *               application MUST NOT call this function.
                    11554   ; *
                    11555   ; * Arguments   :  none
                    11556   ; *
                    11557   ; * Returns     : none
                    11558   ; *
                    11559   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11560   ; *********************************************************************************************************
                    11561   ; */
                    11562   ; void  OS_QInit (void)
                    11563   ; {
                    11564   _OS_QInit:
00003DEA  4E56 FFF8 11565          link      A6,#-8
00003DEE  48E7 3020 11566          movem.l   D2/D3/A2,-(A7)
00003DF2  45F9 0800 11567          lea       _OSQTbl.L,A2
00003DF6  0E34      
                    11568   ; #if OS_MAX_QS == 1u
                    11569   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11570   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11571   ; #endif
                    11572   ; #if OS_MAX_QS >= 2u
                    11573   ; INT16U   ix;
                    11574   ; INT16U   ix_next;
                    11575   ; OS_Q    *pq1;
                    11576   ; OS_Q    *pq2;
                    11577   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00003DF8  4878 0060 11578          pea       96
00003DFC  2F0A      11579          move.l    A2,-(A7)
00003DFE  4EB8 166C 11580          jsr       _OS_MemClr
00003E02  504F      11581          addq.w    #8,A7
                    11582   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00003E04  4242      11583          clr.w     D2
                    11584   OS_QInit_1:
00003E06  0C42 0003 11585          cmp.w     #3,D2
00003E0A  6400 003C 11586          bhs       OS_QInit_3
                    11587   ; ix_next = ix + 1u;
00003E0E  3002      11588          move.w    D2,D0
00003E10  5240      11589          addq.w    #1,D0
00003E12  3D40 FFFA 11590          move.w    D0,-6(A6)
                    11591   ; pq1 = &OSQTbl[ix];
00003E16  200A      11592          move.l    A2,D0
00003E18  C4BC 0000 11593          and.l     #65535,D2
00003E1C  FFFF      
00003E1E  2202      11594          move.l    D2,D1
00003E20  C3FC 0018 11595          muls      #24,D1
00003E24  D081      11596          add.l     D1,D0
00003E26  2600      11597          move.l    D0,D3
                    11598   ; pq2 = &OSQTbl[ix_next];
00003E28  200A      11599          move.l    A2,D0
00003E2A  322E FFFA 11600          move.w    -6(A6),D1
00003E2E  C2BC 0000 11601          and.l     #65535,D1
00003E32  FFFF      
00003E34  C3FC 0018 11602          muls      #24,D1
00003E38  D081      11603          add.l     D1,D0
00003E3A  2D40 FFFC 11604          move.l    D0,-4(A6)
                    11605   ; pq1->OSQPtr = pq2;
00003E3E  2043      11606          move.l    D3,A0
00003E40  20AE FFFC 11607          move.l    -4(A6),(A0)
00003E44  5242      11608          addq.w    #1,D2
00003E46  60BE      11609          bra       OS_QInit_1
                    11610   OS_QInit_3:
                    11611   ; }
                    11612   ; pq1         = &OSQTbl[ix];
00003E48  200A      11613          move.l    A2,D0
00003E4A  C4BC 0000 11614          and.l     #65535,D2
00003E4E  FFFF      
00003E50  2202      11615          move.l    D2,D1
00003E52  C3FC 0018 11616          muls      #24,D1
00003E56  D081      11617          add.l     D1,D0
00003E58  2600      11618          move.l    D0,D3
                    11619   ; pq1->OSQPtr = (OS_Q *)0;
00003E5A  2043      11620          move.l    D3,A0
00003E5C  4290      11621          clr.l     (A0)
                    11622   ; OSQFreeList = &OSQTbl[0];
00003E5E  23CA 0800 11623          move.l    A2,_OSQFreeList.L
00003E62  0E30      
00003E64  4CDF 040C 11624          movem.l   (A7)+,D2/D3/A2
00003E68  4E5E      11625          unlk      A6
00003E6A  4E75      11626          rts
                    11627   ; /*
                    11628   ; *********************************************************************************************************
                    11629   ; *                                                uC/OS-II
                    11630   ; *                                          The Real-Time Kernel
                    11631   ; *                                          SEMAPHORE MANAGEMENT
                    11632   ; *
                    11633   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11634   ; *                                           All Rights Reserved
                    11635   ; *
                    11636   ; * File    : OS_SEM.C
                    11637   ; * By      : Jean J. Labrosse
                    11638   ; * Version : V2.92.07
                    11639   ; *
                    11640   ; * LICENSING TERMS:
                    11641   ; * ---------------
                    11642   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11643   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11644   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11645   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11646   ; * licensing fee.
                    11647   ; *********************************************************************************************************
                    11648   ; */
                    11649   ; #define  MICRIUM_SOURCE
                    11650   ; #ifndef  OS_MASTER_FILE
                    11651   ; #include <ucos_ii.h>
                    11652   ; #endif
                    11653   ; #if OS_SEM_EN > 0u
                    11654   ; /*$PAGE*/
                    11655   ; /*
                    11656   ; *********************************************************************************************************
                    11657   ; *                                          ACCEPT SEMAPHORE
                    11658   ; *
                    11659   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11660   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11661   ; *              resource is not available or the event did not occur.
                    11662   ; *
                    11663   ; * Arguments  : pevent     is a pointer to the event control block
                    11664   ; *
                    11665   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11666   ; *                         decremented to obtain the resource.
                    11667   ; *              == 0       if the resource is not available or the event did not occur or,
                    11668   ; *                         if 'pevent' is a NULL pointer or,
                    11669   ; *                         if you didn't pass a pointer to a semaphore
                    11670   ; *********************************************************************************************************
                    11671   ; */
                    11672   ; #if OS_SEM_ACCEPT_EN > 0u
                    11673   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11674   ; {
                    11675   _OSSemAccept:
00003E6C  4E56 0000 11676          link      A6,#0
00003E70  48E7 3000 11677          movem.l   D2/D3,-(A7)
00003E74  262E 0008 11678          move.l    8(A6),D3
                    11679   ; INT16U     cnt;
                    11680   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11681   ; OS_CPU_SR  cpu_sr = 0u;
                    11682   ; #endif
                    11683   ; #if OS_ARG_CHK_EN > 0u
                    11684   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11685   ; return (0u);
                    11686   ; }
                    11687   ; #endif
                    11688   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003E78  2043      11689          move.l    D3,A0
00003E7A  1010      11690          move.b    (A0),D0
00003E7C  0C00 0003 11691          cmp.b     #3,D0
00003E80  6704      11692          beq.s     OSSemAccept_1
                    11693   ; return (0u);
00003E82  4240      11694          clr.w     D0
00003E84  601E      11695          bra.s     OSSemAccept_3
                    11696   OSSemAccept_1:
                    11697   ; }
                    11698   ; OS_ENTER_CRITICAL();
00003E86  40E7      11699          dc.w      16615
00003E88  007C      11700          dc.w      124
00003E8A  0700      11701          dc.w      1792
                    11702   ; cnt = pevent->OSEventCnt;
00003E8C  2043      11703          move.l    D3,A0
00003E8E  3428 0006 11704          move.w    6(A0),D2
                    11705   ; if (cnt > 0u) {                                   /* See if resource is available                  */
00003E92  0C42 0000 11706          cmp.w     #0,D2
00003E96  6308      11707          bls.s     OSSemAccept_4
                    11708   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
00003E98  2003      11709          move.l    D3,D0
00003E9A  5C80      11710          addq.l    #6,D0
00003E9C  2040      11711          move.l    D0,A0
00003E9E  5350      11712          subq.w    #1,(A0)
                    11713   OSSemAccept_4:
                    11714   ; }
                    11715   ; OS_EXIT_CRITICAL();
00003EA0  46DF      11716          dc.w      18143
                    11717   ; return (cnt);                                     /* Return semaphore count                        */
00003EA2  3002      11718          move.w    D2,D0
                    11719   OSSemAccept_3:
00003EA4  4CDF 000C 11720          movem.l   (A7)+,D2/D3
00003EA8  4E5E      11721          unlk      A6
00003EAA  4E75      11722          rts
                    11723   ; }
                    11724   ; #endif
                    11725   ; /*$PAGE*/
                    11726   ; /*
                    11727   ; *********************************************************************************************************
                    11728   ; *                                         CREATE A SEMAPHORE
                    11729   ; *
                    11730   ; * Description: This function creates a semaphore.
                    11731   ; *
                    11732   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11733   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11734   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11735   ; *                            10 resources, you would initialize the semaphore to 10).
                    11736   ; *
                    11737   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11738   ; *                            created semaphore
                    11739   ; *              == (void *)0  if no event control blocks were available
                    11740   ; *********************************************************************************************************
                    11741   ; */
                    11742   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11743   ; {
                    11744   _OSSemCreate:
00003EAC  4E56 0000 11745          link      A6,#0
00003EB0  48E7 2020 11746          movem.l   D2/A2,-(A7)
00003EB4  45F9 0800 11747          lea       _OSEventFreeList.L,A2
00003EB8  01FA      
                    11748   ; OS_EVENT  *pevent;
                    11749   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11750   ; OS_CPU_SR  cpu_sr = 0u;
                    11751   ; #endif
                    11752   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11753   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11754   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11755   ; return ((OS_EVENT *)0);
                    11756   ; }
                    11757   ; #endif
                    11758   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003EBA  1039 0800 11759          move.b    _OSIntNesting.L,D0
00003EBE  0426      
00003EC0  0C00 0000 11760          cmp.b     #0,D0
00003EC4  6306      11761          bls.s     OSSemCreate_1
                    11762   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00003EC6  4280      11763          clr.l     D0
00003EC8  6000 0044 11764          bra       OSSemCreate_3
                    11765   OSSemCreate_1:
                    11766   ; }
                    11767   ; OS_ENTER_CRITICAL();
00003ECC  40E7      11768          dc.w      16615
00003ECE  007C      11769          dc.w      124
00003ED0  0700      11770          dc.w      1792
                    11771   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00003ED2  2412      11772          move.l    (A2),D2
                    11773   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
00003ED4  2012      11774          move.l    (A2),D0
00003ED6  6706      11775          beq.s     OSSemCreate_4
                    11776   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00003ED8  2052      11777          move.l    (A2),A0
00003EDA  24A8 0002 11778          move.l    2(A0),(A2)
                    11779   OSSemCreate_4:
                    11780   ; }
                    11781   ; OS_EXIT_CRITICAL();
00003EDE  46DF      11782          dc.w      18143
                    11783   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
00003EE0  4A82      11784          tst.l     D2
00003EE2  6728      11785          beq.s     OSSemCreate_6
                    11786   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00003EE4  2042      11787          move.l    D2,A0
00003EE6  10BC 0003 11788          move.b    #3,(A0)
                    11789   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00003EEA  2042      11790          move.l    D2,A0
00003EEC  316E 000A 11791          move.w    10(A6),6(A0)
00003EF0  0006      
                    11792   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
00003EF2  2042      11793          move.l    D2,A0
00003EF4  42A8 0002 11794          clr.l     2(A0)
                    11795   ; #if OS_EVENT_NAME_EN > 0u
                    11796   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003EF8  41F9 0000 11797          lea       @ucos_ii_1.L,A0
00003EFC  763A      
00003EFE  2242      11798          move.l    D2,A1
00003F00  2348 0012 11799          move.l    A0,18(A1)
                    11800   ; #endif
                    11801   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
00003F04  2F02      11802          move.l    D2,-(A7)
00003F06  4EB8 13A0 11803          jsr       _OS_EventWaitListInit
00003F0A  584F      11804          addq.w    #4,A7
                    11805   OSSemCreate_6:
                    11806   ; }
                    11807   ; return (pevent);
00003F0C  2002      11808          move.l    D2,D0
                    11809   OSSemCreate_3:
00003F0E  4CDF 0404 11810          movem.l   (A7)+,D2/A2
00003F12  4E5E      11811          unlk      A6
00003F14  4E75      11812          rts
                    11813   ; }
                    11814   ; /*$PAGE*/
                    11815   ; /*
                    11816   ; *********************************************************************************************************
                    11817   ; *                                         DELETE A SEMAPHORE
                    11818   ; *
                    11819   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    11820   ; *
                    11821   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11822   ; *                            semaphore.
                    11823   ; *
                    11824   ; *              opt           determines delete options as follows:
                    11825   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    11826   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    11827   ; *                                                    In this case, all the tasks pending will be readied.
                    11828   ; *
                    11829   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    11830   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    11831   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    11832   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    11833   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    11834   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    11835   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    11836   ; *
                    11837   ; * Returns    : pevent        upon error
                    11838   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    11839   ; *
                    11840   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    11841   ; *                 the semaphore MUST check the return code of OSSemPend().
                    11842   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    11843   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    11844   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    11845   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    11846   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    11847   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    11848   ; *                 will no longer be guarded by the semaphore.
                    11849   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    11850   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    11851   ; *********************************************************************************************************
                    11852   ; */
                    11853   ; #if OS_SEM_DEL_EN > 0u
                    11854   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    11855   ; INT8U      opt,
                    11856   ; INT8U     *perr)
                    11857   ; {
                    11858   _OSSemDel:
00003F16  4E56 0000 11859          link      A6,#0
00003F1A  48E7 3C20 11860          movem.l   D2/D3/D4/D5/A2,-(A7)
00003F1E  242E 0008 11861          move.l    8(A6),D2
00003F22  262E 0010 11862          move.l    16(A6),D3
00003F26  45F9 0800 11863          lea       _OSEventFreeList.L,A2
00003F2A  01FA      
                    11864   ; BOOLEAN    tasks_waiting;
                    11865   ; OS_EVENT  *pevent_return;
                    11866   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11867   ; OS_CPU_SR  cpu_sr = 0u;
                    11868   ; #endif
                    11869   ; #ifdef OS_SAFETY_CRITICAL
                    11870   ; if (perr == (INT8U *)0) {
                    11871   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11872   ; return ((OS_EVENT *)0);
                    11873   ; }
                    11874   ; #endif
                    11875   ; #if OS_ARG_CHK_EN > 0u
                    11876   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11877   ; *perr = OS_ERR_PEVENT_NULL;
                    11878   ; return (pevent);
                    11879   ; }
                    11880   ; #endif
                    11881   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00003F2C  2042      11882          move.l    D2,A0
00003F2E  1010      11883          move.b    (A0),D0
00003F30  0C00 0003 11884          cmp.b     #3,D0
00003F34  670C      11885          beq.s     OSSemDel_1
                    11886   ; *perr = OS_ERR_EVENT_TYPE;
00003F36  2043      11887          move.l    D3,A0
00003F38  10BC 0001 11888          move.b    #1,(A0)
                    11889   ; return (pevent);
00003F3C  2002      11890          move.l    D2,D0
00003F3E  6000 00EA 11891          bra       OSSemDel_3
                    11892   OSSemDel_1:
                    11893   ; }
                    11894   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003F42  1039 0800 11895          move.b    _OSIntNesting.L,D0
00003F46  0426      
00003F48  0C00 0000 11896          cmp.b     #0,D0
00003F4C  630C      11897          bls.s     OSSemDel_4
                    11898   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00003F4E  2043      11899          move.l    D3,A0
00003F50  10BC 000F 11900          move.b    #15,(A0)
                    11901   ; return (pevent);
00003F54  2002      11902          move.l    D2,D0
00003F56  6000 00D2 11903          bra       OSSemDel_3
                    11904   OSSemDel_4:
                    11905   ; }
                    11906   ; OS_ENTER_CRITICAL();
00003F5A  40E7      11907          dc.w      16615
00003F5C  007C      11908          dc.w      124
00003F5E  0700      11909          dc.w      1792
                    11910   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
00003F60  2042      11911          move.l    D2,A0
00003F62  1028 0008 11912          move.b    8(A0),D0
00003F66  6704      11913          beq.s     OSSemDel_6
                    11914   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003F68  7A01      11915          moveq     #1,D5
00003F6A  6002      11916          bra.s     OSSemDel_7
                    11917   OSSemDel_6:
                    11918   ; } else {
                    11919   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00003F6C  4205      11920          clr.b     D5
                    11921   OSSemDel_7:
                    11922   ; }
                    11923   ; switch (opt) {
00003F6E  102E 000F 11924          move.b    15(A6),D0
00003F72  C0BC 0000 11925          and.l     #255,D0
00003F76  00FF      
00003F78  0C80 0000 11926          cmp.l     #1,D0
00003F7C  0001      
00003F7E  6700 0048 11927          beq       OSSemDel_11
00003F82  6200 009A 11928          bhi       OSSemDel_8
00003F86  4A80      11929          tst.l     D0
00003F88  6704      11930          beq.s     OSSemDel_10
00003F8A  6000 0092 11931          bra       OSSemDel_8
                    11932   OSSemDel_10:
                    11933   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    11934   ; if (tasks_waiting == OS_FALSE) {
00003F8E  4A05      11935          tst.b     D5
00003F90  6628      11936          bne.s     OSSemDel_13
                    11937   ; #if OS_EVENT_NAME_EN > 0u
                    11938   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003F92  41F9 0000 11939          lea       @ucos_ii_1.L,A0
00003F96  763A      
00003F98  2242      11940          move.l    D2,A1
00003F9A  2348 0012 11941          move.l    A0,18(A1)
                    11942   ; #endif
                    11943   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003F9E  2042      11944          move.l    D2,A0
00003FA0  4210      11945          clr.b     (A0)
                    11946   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003FA2  2042      11947          move.l    D2,A0
00003FA4  2152 0002 11948          move.l    (A2),2(A0)
                    11949   ; pevent->OSEventCnt     = 0u;
00003FA8  2042      11950          move.l    D2,A0
00003FAA  4268 0006 11951          clr.w     6(A0)
                    11952   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003FAE  2482      11953          move.l    D2,(A2)
                    11954   ; OS_EXIT_CRITICAL();
00003FB0  46DF      11955          dc.w      18143
                    11956   ; *perr                  = OS_ERR_NONE;
00003FB2  2043      11957          move.l    D3,A0
00003FB4  4210      11958          clr.b     (A0)
                    11959   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
00003FB6  4284      11960          clr.l     D4
00003FB8  600A      11961          bra.s     OSSemDel_14
                    11962   OSSemDel_13:
                    11963   ; } else {
                    11964   ; OS_EXIT_CRITICAL();
00003FBA  46DF      11965          dc.w      18143
                    11966   ; *perr                  = OS_ERR_TASK_WAITING;
00003FBC  2043      11967          move.l    D3,A0
00003FBE  10BC 0049 11968          move.b    #73,(A0)
                    11969   ; pevent_return          = pevent;
00003FC2  2802      11970          move.l    D2,D4
                    11971   OSSemDel_14:
                    11972   ; }
                    11973   ; break;
00003FC4  6000 0062 11974          bra       OSSemDel_9
                    11975   OSSemDel_11:
                    11976   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    11977   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    11978   OSSemDel_15:
00003FC8  2042      11979          move.l    D2,A0
00003FCA  1028 0008 11980          move.b    8(A0),D0
00003FCE  671C      11981          beq.s     OSSemDel_17
                    11982   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00003FD0  4878 0002 11983          pea       2
00003FD4  4878 0001 11984          pea       1
00003FD8  42A7      11985          clr.l     -(A7)
00003FDA  2F02      11986          move.l    D2,-(A7)
00003FDC  4EB8 10D8 11987          jsr       _OS_EventTaskRdy
00003FE0  DEFC 0010 11988          add.w     #16,A7
00003FE4  C0BC 0000 11989          and.l     #255,D0
00003FE8  00FF      
00003FEA  60DC      11990          bra       OSSemDel_15
                    11991   OSSemDel_17:
                    11992   ; }
                    11993   ; #if OS_EVENT_NAME_EN > 0u
                    11994   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003FEC  41F9 0000 11995          lea       @ucos_ii_1.L,A0
00003FF0  763A      
00003FF2  2242      11996          move.l    D2,A1
00003FF4  2348 0012 11997          move.l    A0,18(A1)
                    11998   ; #endif
                    11999   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003FF8  2042      12000          move.l    D2,A0
00003FFA  4210      12001          clr.b     (A0)
                    12002   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003FFC  2042      12003          move.l    D2,A0
00003FFE  2152 0002 12004          move.l    (A2),2(A0)
                    12005   ; pevent->OSEventCnt     = 0u;
00004002  2042      12006          move.l    D2,A0
00004004  4268 0006 12007          clr.w     6(A0)
                    12008   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00004008  2482      12009          move.l    D2,(A2)
                    12010   ; OS_EXIT_CRITICAL();
0000400A  46DF      12011          dc.w      18143
                    12012   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000400C  0C05 0001 12013          cmp.b     #1,D5
00004010  6604      12014          bne.s     OSSemDel_18
                    12015   ; OS_Sched();                               /* Find highest priority task ready to run  */
00004012  4EB8 16B8 12016          jsr       _OS_Sched
                    12017   OSSemDel_18:
                    12018   ; }
                    12019   ; *perr                  = OS_ERR_NONE;
00004016  2043      12020          move.l    D3,A0
00004018  4210      12021          clr.b     (A0)
                    12022   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
0000401A  4284      12023          clr.l     D4
                    12024   ; break;
0000401C  600A      12025          bra.s     OSSemDel_9
                    12026   OSSemDel_8:
                    12027   ; default:
                    12028   ; OS_EXIT_CRITICAL();
0000401E  46DF      12029          dc.w      18143
                    12030   ; *perr                  = OS_ERR_INVALID_OPT;
00004020  2043      12031          move.l    D3,A0
00004022  10BC 0007 12032          move.b    #7,(A0)
                    12033   ; pevent_return          = pevent;
00004026  2802      12034          move.l    D2,D4
                    12035   ; break;
                    12036   OSSemDel_9:
                    12037   ; }
                    12038   ; return (pevent_return);
00004028  2004      12039          move.l    D4,D0
                    12040   OSSemDel_3:
0000402A  4CDF 043C 12041          movem.l   (A7)+,D2/D3/D4/D5/A2
0000402E  4E5E      12042          unlk      A6
00004030  4E75      12043          rts
                    12044   ; }
                    12045   ; #endif
                    12046   ; /*$PAGE*/
                    12047   ; /*
                    12048   ; *********************************************************************************************************
                    12049   ; *                                          PEND ON SEMAPHORE
                    12050   ; *
                    12051   ; * Description: This function waits for a semaphore.
                    12052   ; *
                    12053   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12054   ; *                            semaphore.
                    12055   ; *
                    12056   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    12057   ; *                            wait for the resource up to the amount of time specified by this argument.
                    12058   ; *                            If you specify 0, however, your task will wait forever at the specified
                    12059   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    12060   ; *
                    12061   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12062   ; *                            messages are:
                    12063   ; *
                    12064   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    12065   ; *                                                or, the event you are waiting for occurred.
                    12066   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    12067   ; *                                                'timeout'.
                    12068   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    12069   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12070   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    12071   ; *                                                would lead to a suspension.
                    12072   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12073   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    12074   ; *
                    12075   ; * Returns    : none
                    12076   ; *********************************************************************************************************
                    12077   ; */
                    12078   ; /*$PAGE*/
                    12079   ; void  OSSemPend (OS_EVENT  *pevent,
                    12080   ; INT32U     timeout,
                    12081   ; INT8U     *perr)
                    12082   ; {
                    12083   _OSSemPend:
00004032  4E56 0000 12084          link      A6,#0
00004036  48E7 3020 12085          movem.l   D2/D3/A2,-(A7)
0000403A  45F9 0800 12086          lea       _OSTCBCur.L,A2
0000403E  0540      
00004040  242E 0010 12087          move.l    16(A6),D2
00004044  262E 0008 12088          move.l    8(A6),D3
                    12089   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12090   ; OS_CPU_SR  cpu_sr = 0u;
                    12091   ; #endif
                    12092   ; #ifdef OS_SAFETY_CRITICAL
                    12093   ; if (perr == (INT8U *)0) {
                    12094   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12095   ; return;
                    12096   ; }
                    12097   ; #endif
                    12098   ; #if OS_ARG_CHK_EN > 0u
                    12099   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12100   ; *perr = OS_ERR_PEVENT_NULL;
                    12101   ; return;
                    12102   ; }
                    12103   ; #endif
                    12104   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004048  2043      12105          move.l    D3,A0
0000404A  1010      12106          move.b    (A0),D0
0000404C  0C00 0003 12107          cmp.b     #3,D0
00004050  670A      12108          beq.s     OSSemPend_1
                    12109   ; *perr = OS_ERR_EVENT_TYPE;
00004052  2042      12110          move.l    D2,A0
00004054  10BC 0001 12111          move.b    #1,(A0)
                    12112   ; return;
00004058  6000 00DA 12113          bra       OSSemPend_3
                    12114   OSSemPend_1:
                    12115   ; }
                    12116   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000405C  1039 0800 12117          move.b    _OSIntNesting.L,D0
00004060  0426      
00004062  0C00 0000 12118          cmp.b     #0,D0
00004066  630A      12119          bls.s     OSSemPend_4
                    12120   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00004068  2042      12121          move.l    D2,A0
0000406A  10BC 0002 12122          move.b    #2,(A0)
                    12123   ; return;
0000406E  6000 00C4 12124          bra       OSSemPend_3
                    12125   OSSemPend_4:
                    12126   ; }
                    12127   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00004072  1039 0800 12128          move.b    _OSLockNesting.L,D0
00004076  0428      
00004078  0C00 0000 12129          cmp.b     #0,D0
0000407C  630A      12130          bls.s     OSSemPend_6
                    12131   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
0000407E  2042      12132          move.l    D2,A0
00004080  10BC 000D 12133          move.b    #13,(A0)
                    12134   ; return;
00004084  6000 00AE 12135          bra       OSSemPend_3
                    12136   OSSemPend_6:
                    12137   ; }
                    12138   ; OS_ENTER_CRITICAL();
00004088  40E7      12139          dc.w      16615
0000408A  007C      12140          dc.w      124
0000408C  0700      12141          dc.w      1792
                    12142   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
0000408E  2043      12143          move.l    D3,A0
00004090  3028 0006 12144          move.w    6(A0),D0
00004094  0C40 0000 12145          cmp.w     #0,D0
00004098  6312      12146          bls.s     OSSemPend_8
                    12147   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
0000409A  2003      12148          move.l    D3,D0
0000409C  5C80      12149          addq.l    #6,D0
0000409E  2040      12150          move.l    D0,A0
000040A0  5350      12151          subq.w    #1,(A0)
                    12152   ; OS_EXIT_CRITICAL();
000040A2  46DF      12153          dc.w      18143
                    12154   ; *perr = OS_ERR_NONE;
000040A4  2042      12155          move.l    D2,A0
000040A6  4210      12156          clr.b     (A0)
                    12157   ; return;
000040A8  6000 008A 12158          bra       OSSemPend_3
                    12159   OSSemPend_8:
                    12160   ; }
                    12161   ; /* Otherwise, must wait until event occurs       */
                    12162   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
000040AC  2052      12163          move.l    (A2),A0
000040AE  0028 0001 12164          or.b      #1,50(A0)
000040B2  0032      
                    12165   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000040B4  2052      12166          move.l    (A2),A0
000040B6  4228 0033 12167          clr.b     51(A0)
                    12168   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
000040BA  2052      12169          move.l    (A2),A0
000040BC  216E 000C 12170          move.l    12(A6),46(A0)
000040C0  002E      
                    12171   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000040C2  2F03      12172          move.l    D3,-(A7)
000040C4  4EB8 11BC 12173          jsr       _OS_EventTaskWait
000040C8  584F      12174          addq.w    #4,A7
                    12175   ; OS_EXIT_CRITICAL();
000040CA  46DF      12176          dc.w      18143
                    12177   ; OS_Sched();                                       /* Find next highest priority task ready         */
000040CC  4EB8 16B8 12178          jsr       _OS_Sched
                    12179   ; OS_ENTER_CRITICAL();
000040D0  40E7      12180          dc.w      16615
000040D2  007C      12181          dc.w      124
000040D4  0700      12182          dc.w      1792
                    12183   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000040D6  2052      12184          move.l    (A2),A0
000040D8  1028 0033 12185          move.b    51(A0),D0
000040DC  C0BC 0000 12186          and.l     #255,D0
000040E0  00FF      
000040E2  0C80 0000 12187          cmp.l     #1,D0
000040E6  0001      
000040E8  6720      12188          beq.s     OSSemPend_14
000040EA  6206      12189          bhi.s     OSSemPend_16
000040EC  4A80      12190          tst.l     D0
000040EE  670C      12191          beq.s     OSSemPend_12
000040F0  6018      12192          bra.s     OSSemPend_14
                    12193   OSSemPend_16:
000040F2  0C80 0000 12194          cmp.l     #2,D0
000040F6  0002      
000040F8  6708      12195          beq.s     OSSemPend_13
000040FA  600E      12196          bra.s     OSSemPend_14
                    12197   OSSemPend_12:
                    12198   ; case OS_STAT_PEND_OK:
                    12199   ; *perr = OS_ERR_NONE;
000040FC  2042      12200          move.l    D2,A0
000040FE  4210      12201          clr.b     (A0)
                    12202   ; break;
00004100  6018      12203          bra.s     OSSemPend_11
                    12204   OSSemPend_13:
                    12205   ; case OS_STAT_PEND_ABORT:
                    12206   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00004102  2042      12207          move.l    D2,A0
00004104  10BC 000E 12208          move.b    #14,(A0)
                    12209   ; break;
00004108  6010      12210          bra.s     OSSemPend_11
                    12211   OSSemPend_14:
                    12212   ; case OS_STAT_PEND_TO:
                    12213   ; default:
                    12214   ; OS_EventTaskRemove(OSTCBCur, pevent);
0000410A  2F03      12215          move.l    D3,-(A7)
0000410C  2F12      12216          move.l    (A2),-(A7)
0000410E  4EB8 12DE 12217          jsr       _OS_EventTaskRemove
00004112  504F      12218          addq.w    #8,A7
                    12219   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00004114  2042      12220          move.l    D2,A0
00004116  10BC 000A 12221          move.b    #10,(A0)
                    12222   ; break;
                    12223   OSSemPend_11:
                    12224   ; }
                    12225   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000411A  2052      12226          move.l    (A2),A0
0000411C  4228 0032 12227          clr.b     50(A0)
                    12228   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00004120  2052      12229          move.l    (A2),A0
00004122  4228 0033 12230          clr.b     51(A0)
                    12231   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00004126  2052      12232          move.l    (A2),A0
00004128  42A8 001C 12233          clr.l     28(A0)
                    12234   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12235   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000412C  2052      12236          move.l    (A2),A0
0000412E  42A8 0020 12237          clr.l     32(A0)
                    12238   ; #endif
                    12239   ; OS_EXIT_CRITICAL();
00004132  46DF      12240          dc.w      18143
                    12241   OSSemPend_3:
00004134  4CDF 040C 12242          movem.l   (A7)+,D2/D3/A2
00004138  4E5E      12243          unlk      A6
0000413A  4E75      12244          rts
                    12245   ; }
                    12246   ; /*$PAGE*/
                    12247   ; /*
                    12248   ; *********************************************************************************************************
                    12249   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12250   ; *
                    12251   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12252   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12253   ; *              the semaphore via OSSemPost().
                    12254   ; *
                    12255   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12256   ; *                            semaphore.
                    12257   ; *
                    12258   ; *              opt           determines the type of ABORT performed:
                    12259   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12260   ; *                                                     semaphore
                    12261   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12262   ; *                                                     semaphore
                    12263   ; *
                    12264   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12265   ; *                            messages are:
                    12266   ; *
                    12267   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12268   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12269   ; *                                                and informed of the aborted wait; check return value
                    12270   ; *                                                for the number of tasks whose wait on the semaphore
                    12271   ; *                                                was aborted.
                    12272   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12273   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12274   ; *
                    12275   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12276   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12277   ; *********************************************************************************************************
                    12278   ; */
                    12279   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12280   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12281   ; INT8U      opt,
                    12282   ; INT8U     *perr)
                    12283   ; {
                    12284   _OSSemPendAbort:
0000413C  4E56 0000 12285          link      A6,#0
00004140  48E7 3800 12286          movem.l   D2/D3/D4,-(A7)
00004144  242E 0008 12287          move.l    8(A6),D2
00004148  282E 0010 12288          move.l    16(A6),D4
                    12289   ; INT8U      nbr_tasks;
                    12290   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12291   ; OS_CPU_SR  cpu_sr = 0u;
                    12292   ; #endif
                    12293   ; #ifdef OS_SAFETY_CRITICAL
                    12294   ; if (perr == (INT8U *)0) {
                    12295   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12296   ; return (0u);
                    12297   ; }
                    12298   ; #endif
                    12299   ; #if OS_ARG_CHK_EN > 0u
                    12300   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12301   ; *perr = OS_ERR_PEVENT_NULL;
                    12302   ; return (0u);
                    12303   ; }
                    12304   ; #endif
                    12305   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000414C  2042      12306          move.l    D2,A0
0000414E  1010      12307          move.b    (A0),D0
00004150  0C00 0003 12308          cmp.b     #3,D0
00004154  670C      12309          beq.s     OSSemPendAbort_1
                    12310   ; *perr = OS_ERR_EVENT_TYPE;
00004156  2044      12311          move.l    D4,A0
00004158  10BC 0001 12312          move.b    #1,(A0)
                    12313   ; return (0u);
0000415C  4200      12314          clr.b     D0
0000415E  6000 008C 12315          bra       OSSemPendAbort_3
                    12316   OSSemPendAbort_1:
                    12317   ; }
                    12318   ; OS_ENTER_CRITICAL();
00004162  40E7      12319          dc.w      16615
00004164  007C      12320          dc.w      124
00004166  0700      12321          dc.w      1792
                    12322   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
00004168  2042      12323          move.l    D2,A0
0000416A  1028 0008 12324          move.b    8(A0),D0
0000416E  6700 0074 12325          beq       OSSemPendAbort_4
                    12326   ; nbr_tasks = 0u;
00004172  4203      12327          clr.b     D3
                    12328   ; switch (opt) {
00004174  102E 000F 12329          move.b    15(A6),D0
00004178  C0BC 0000 12330          and.l     #255,D0
0000417C  00FF      
0000417E  0C80 0000 12331          cmp.l     #1,D0
00004182  0001      
00004184  670A      12332          beq.s     OSSemPendAbort_8
00004186  6200 0030 12333          bhi       OSSemPendAbort_9
0000418A  4A80      12334          tst.l     D0
0000418C  672A      12335          beq.s     OSSemPendAbort_9
0000418E  6028      12336          bra.s     OSSemPendAbort_9
                    12337   OSSemPendAbort_8:
                    12338   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12339   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12340   OSSemPendAbort_11:
00004190  2042      12341          move.l    D2,A0
00004192  1028 0008 12342          move.b    8(A0),D0
00004196  671E      12343          beq.s     OSSemPendAbort_13
                    12344   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00004198  4878 0002 12345          pea       2
0000419C  4878 0001 12346          pea       1
000041A0  42A7      12347          clr.l     -(A7)
000041A2  2F02      12348          move.l    D2,-(A7)
000041A4  4EB8 10D8 12349          jsr       _OS_EventTaskRdy
000041A8  DEFC 0010 12350          add.w     #16,A7
000041AC  C0BC 0000 12351          and.l     #255,D0
000041B0  00FF      
                    12352   ; nbr_tasks++;
000041B2  5203      12353          addq.b    #1,D3
000041B4  60DA      12354          bra       OSSemPendAbort_11
                    12355   OSSemPendAbort_13:
                    12356   ; }
                    12357   ; break;
000041B6  601C      12358          bra.s     OSSemPendAbort_7
                    12359   OSSemPendAbort_9:
                    12360   ; case OS_PEND_OPT_NONE:
                    12361   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12362   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
000041B8  4878 0002 12363          pea       2
000041BC  4878 0001 12364          pea       1
000041C0  42A7      12365          clr.l     -(A7)
000041C2  2F02      12366          move.l    D2,-(A7)
000041C4  4EB8 10D8 12367          jsr       _OS_EventTaskRdy
000041C8  DEFC 0010 12368          add.w     #16,A7
000041CC  C0BC 0000 12369          and.l     #255,D0
000041D0  00FF      
                    12370   ; nbr_tasks++;
000041D2  5203      12371          addq.b    #1,D3
                    12372   ; break;
                    12373   OSSemPendAbort_7:
                    12374   ; }
                    12375   ; OS_EXIT_CRITICAL();
000041D4  46DF      12376          dc.w      18143
                    12377   ; OS_Sched();                                   /* Find HPT ready to run                         */
000041D6  4EB8 16B8 12378          jsr       _OS_Sched
                    12379   ; *perr = OS_ERR_PEND_ABORT;
000041DA  2044      12380          move.l    D4,A0
000041DC  10BC 000E 12381          move.b    #14,(A0)
                    12382   ; return (nbr_tasks);
000041E0  1003      12383          move.b    D3,D0
000041E2  6008      12384          bra.s     OSSemPendAbort_3
                    12385   OSSemPendAbort_4:
                    12386   ; }
                    12387   ; OS_EXIT_CRITICAL();
000041E4  46DF      12388          dc.w      18143
                    12389   ; *perr = OS_ERR_NONE;
000041E6  2044      12390          move.l    D4,A0
000041E8  4210      12391          clr.b     (A0)
                    12392   ; return (0u);                                      /* No tasks waiting on semaphore                 */
000041EA  4200      12393          clr.b     D0
                    12394   OSSemPendAbort_3:
000041EC  4CDF 001C 12395          movem.l   (A7)+,D2/D3/D4
000041F0  4E5E      12396          unlk      A6
000041F2  4E75      12397          rts
                    12398   ; }
                    12399   ; #endif
                    12400   ; /*$PAGE*/
                    12401   ; /*
                    12402   ; *********************************************************************************************************
                    12403   ; *                                         POST TO A SEMAPHORE
                    12404   ; *
                    12405   ; * Description: This function signals a semaphore
                    12406   ; *
                    12407   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12408   ; *                            semaphore.
                    12409   ; *
                    12410   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12411   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12412   ; *                                  signaled the semaphore more often than you waited on it with either
                    12413   ; *                                  OSSemAccept() or OSSemPend().
                    12414   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12415   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12416   ; *********************************************************************************************************
                    12417   ; */
                    12418   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12419   ; {
                    12420   _OSSemPost:
000041F4  4E56 0000 12421          link      A6,#0
000041F8  2F02      12422          move.l    D2,-(A7)
000041FA  242E 0008 12423          move.l    8(A6),D2
                    12424   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12425   ; OS_CPU_SR  cpu_sr = 0u;
                    12426   ; #endif
                    12427   ; #if OS_ARG_CHK_EN > 0u
                    12428   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12429   ; return (OS_ERR_PEVENT_NULL);
                    12430   ; }
                    12431   ; #endif
                    12432   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000041FE  2042      12433          move.l    D2,A0
00004200  1010      12434          move.b    (A0),D0
00004202  0C00 0003 12435          cmp.b     #3,D0
00004206  6706      12436          beq.s     OSSemPost_1
                    12437   ; return (OS_ERR_EVENT_TYPE);
00004208  7001      12438          moveq     #1,D0
0000420A  6000 0050 12439          bra       OSSemPost_3
                    12440   OSSemPost_1:
                    12441   ; }
                    12442   ; OS_ENTER_CRITICAL();
0000420E  40E7      12443          dc.w      16615
00004210  007C      12444          dc.w      124
00004212  0700      12445          dc.w      1792
                    12446   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
00004214  2042      12447          move.l    D2,A0
00004216  1028 0008 12448          move.b    8(A0),D0
0000421A  6722      12449          beq.s     OSSemPost_4
                    12450   ; /* Ready HPT waiting on event                    */
                    12451   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
0000421C  42A7      12452          clr.l     -(A7)
0000421E  4878 0001 12453          pea       1
00004222  42A7      12454          clr.l     -(A7)
00004224  2F02      12455          move.l    D2,-(A7)
00004226  4EB8 10D8 12456          jsr       _OS_EventTaskRdy
0000422A  DEFC 0010 12457          add.w     #16,A7
0000422E  C0BC 0000 12458          and.l     #255,D0
00004232  00FF      
                    12459   ; OS_EXIT_CRITICAL();
00004234  46DF      12460          dc.w      18143
                    12461   ; OS_Sched();                                   /* Find HPT ready to run                         */
00004236  4EB8 16B8 12462          jsr       _OS_Sched
                    12463   ; return (OS_ERR_NONE);
0000423A  4200      12464          clr.b     D0
0000423C  601E      12465          bra.s     OSSemPost_3
                    12466   OSSemPost_4:
                    12467   ; }
                    12468   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
0000423E  2042      12469          move.l    D2,A0
00004240  3028 0006 12470          move.w    6(A0),D0
00004244  0C40 FFFF 12471          cmp.w     #65535,D0
00004248  640E      12472          bhs.s     OSSemPost_6
                    12473   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
0000424A  2002      12474          move.l    D2,D0
0000424C  5C80      12475          addq.l    #6,D0
0000424E  2040      12476          move.l    D0,A0
00004250  5250      12477          addq.w    #1,(A0)
                    12478   ; OS_EXIT_CRITICAL();
00004252  46DF      12479          dc.w      18143
                    12480   ; return (OS_ERR_NONE);
00004254  4200      12481          clr.b     D0
00004256  6004      12482          bra.s     OSSemPost_3
                    12483   OSSemPost_6:
                    12484   ; }
                    12485   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
00004258  46DF      12486          dc.w      18143
                    12487   ; return (OS_ERR_SEM_OVF);
0000425A  7033      12488          moveq     #51,D0
                    12489   OSSemPost_3:
0000425C  241F      12490          move.l    (A7)+,D2
0000425E  4E5E      12491          unlk      A6
00004260  4E75      12492          rts
                    12493   ; }
                    12494   ; /*$PAGE*/
                    12495   ; /*
                    12496   ; *********************************************************************************************************
                    12497   ; *                                          QUERY A SEMAPHORE
                    12498   ; *
                    12499   ; * Description: This function obtains information about a semaphore
                    12500   ; *
                    12501   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12502   ; *                            semaphore
                    12503   ; *
                    12504   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12505   ; *                            semaphore.
                    12506   ; *
                    12507   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12508   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12509   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12510   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12511   ; *********************************************************************************************************
                    12512   ; */
                    12513   ; #if OS_SEM_QUERY_EN > 0u
                    12514   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12515   ; OS_SEM_DATA  *p_sem_data)
                    12516   ; {
                    12517   _OSSemQuery:
00004262  4E56 FFF8 12518          link      A6,#-8
00004266  48E7 3800 12519          movem.l   D2/D3/D4,-(A7)
0000426A  242E 0008 12520          move.l    8(A6),D2
0000426E  282E 000C 12521          move.l    12(A6),D4
                    12522   ; INT8U       i;
                    12523   ; OS_PRIO    *psrc;
                    12524   ; OS_PRIO    *pdest;
                    12525   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12526   ; OS_CPU_SR   cpu_sr = 0u;
                    12527   ; #endif
                    12528   ; #if OS_ARG_CHK_EN > 0u
                    12529   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12530   ; return (OS_ERR_PEVENT_NULL);
                    12531   ; }
                    12532   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12533   ; return (OS_ERR_PDATA_NULL);
                    12534   ; }
                    12535   ; #endif
                    12536   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00004272  2042      12537          move.l    D2,A0
00004274  1010      12538          move.b    (A0),D0
00004276  0C00 0003 12539          cmp.b     #3,D0
0000427A  6706      12540          beq.s     OSSemQuery_1
                    12541   ; return (OS_ERR_EVENT_TYPE);
0000427C  7001      12542          moveq     #1,D0
0000427E  6000 004C 12543          bra       OSSemQuery_3
                    12544   OSSemQuery_1:
                    12545   ; }
                    12546   ; OS_ENTER_CRITICAL();
00004282  40E7      12547          dc.w      16615
00004284  007C      12548          dc.w      124
00004286  0700      12549          dc.w      1792
                    12550   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
00004288  2042      12551          move.l    D2,A0
0000428A  2244      12552          move.l    D4,A1
0000428C  1368 0008 12553          move.b    8(A0),10(A1)
00004290  000A      
                    12554   ; psrc                   = &pevent->OSEventTbl[0];
00004292  700A      12555          moveq     #10,D0
00004294  D082      12556          add.l     D2,D0
00004296  2D40 FFF8 12557          move.l    D0,-8(A6)
                    12558   ; pdest                  = &p_sem_data->OSEventTbl[0];
0000429A  7002      12559          moveq     #2,D0
0000429C  D084      12560          add.l     D4,D0
0000429E  2D40 FFFC 12561          move.l    D0,-4(A6)
                    12562   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000042A2  4203      12563          clr.b     D3
                    12564   OSSemQuery_4:
000042A4  0C03 0008 12565          cmp.b     #8,D3
000042A8  6416      12566          bhs.s     OSSemQuery_6
                    12567   ; *pdest++ = *psrc++;
000042AA  206E FFF8 12568          move.l    -8(A6),A0
000042AE  52AE FFF8 12569          addq.l    #1,-8(A6)
000042B2  226E FFFC 12570          move.l    -4(A6),A1
000042B6  52AE FFFC 12571          addq.l    #1,-4(A6)
000042BA  1290      12572          move.b    (A0),(A1)
000042BC  5203      12573          addq.b    #1,D3
000042BE  60E4      12574          bra       OSSemQuery_4
                    12575   OSSemQuery_6:
                    12576   ; }
                    12577   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
000042C0  2042      12578          move.l    D2,A0
000042C2  2244      12579          move.l    D4,A1
000042C4  32A8 0006 12580          move.w    6(A0),(A1)
                    12581   ; OS_EXIT_CRITICAL();
000042C8  46DF      12582          dc.w      18143
                    12583   ; return (OS_ERR_NONE);
000042CA  4200      12584          clr.b     D0
                    12585   OSSemQuery_3:
000042CC  4CDF 001C 12586          movem.l   (A7)+,D2/D3/D4
000042D0  4E5E      12587          unlk      A6
000042D2  4E75      12588          rts
                    12589   ; }
                    12590   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12591   ; /*$PAGE*/
                    12592   ; /*
                    12593   ; *********************************************************************************************************
                    12594   ; *                                            SET SEMAPHORE
                    12595   ; *
                    12596   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12597   ; *              this value would be 0.
                    12598   ; *
                    12599   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12600   ; *              and, you want to reset the count value.
                    12601   ; *
                    12602   ; * Arguments  : pevent     is a pointer to the event control block
                    12603   ; *
                    12604   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12605   ; *                         semaphore count.
                    12606   ; *
                    12607   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12608   ; *
                    12609   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12610   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12611   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12612   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12613   ; *********************************************************************************************************
                    12614   ; */
                    12615   ; #if OS_SEM_SET_EN > 0u
                    12616   ; void  OSSemSet (OS_EVENT  *pevent,
                    12617   ; INT16U     cnt,
                    12618   ; INT8U     *perr)
                    12619   ; {
                    12620   _OSSemSet:
000042D4  4E56 0000 12621          link      A6,#0
000042D8  48E7 3000 12622          movem.l   D2/D3,-(A7)
000042DC  242E 0008 12623          move.l    8(A6),D2
000042E0  262E 0010 12624          move.l    16(A6),D3
                    12625   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12626   ; OS_CPU_SR  cpu_sr = 0u;
                    12627   ; #endif
                    12628   ; #ifdef OS_SAFETY_CRITICAL
                    12629   ; if (perr == (INT8U *)0) {
                    12630   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12631   ; return;
                    12632   ; }
                    12633   ; #endif
                    12634   ; #if OS_ARG_CHK_EN > 0u
                    12635   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12636   ; *perr = OS_ERR_PEVENT_NULL;
                    12637   ; return;
                    12638   ; }
                    12639   ; #endif
                    12640   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000042E4  2042      12641          move.l    D2,A0
000042E6  1010      12642          move.b    (A0),D0
000042E8  0C00 0003 12643          cmp.b     #3,D0
000042EC  670A      12644          beq.s     OSSemSet_1
                    12645   ; *perr = OS_ERR_EVENT_TYPE;
000042EE  2043      12646          move.l    D3,A0
000042F0  10BC 0001 12647          move.b    #1,(A0)
                    12648   ; return;
000042F4  6000 003C 12649          bra       OSSemSet_3
                    12650   OSSemSet_1:
                    12651   ; }
                    12652   ; OS_ENTER_CRITICAL();
000042F8  40E7      12653          dc.w      16615
000042FA  007C      12654          dc.w      124
000042FC  0700      12655          dc.w      1792
                    12656   ; *perr = OS_ERR_NONE;
000042FE  2043      12657          move.l    D3,A0
00004300  4210      12658          clr.b     (A0)
                    12659   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
00004302  2042      12660          move.l    D2,A0
00004304  3028 0006 12661          move.w    6(A0),D0
00004308  0C40 0000 12662          cmp.w     #0,D0
0000430C  630A      12663          bls.s     OSSemSet_4
                    12664   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
0000430E  2042      12665          move.l    D2,A0
00004310  316E 000E 12666          move.w    14(A6),6(A0)
00004314  0006      
00004316  6018      12667          bra.s     OSSemSet_7
                    12668   OSSemSet_4:
                    12669   ; } else {                                          /* No                                            */
                    12670   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
00004318  2042      12671          move.l    D2,A0
0000431A  1028 0008 12672          move.b    8(A0),D0
0000431E  660A      12673          bne.s     OSSemSet_6
                    12674   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
00004320  2042      12675          move.l    D2,A0
00004322  316E 000E 12676          move.w    14(A6),6(A0)
00004326  0006      
00004328  6006      12677          bra.s     OSSemSet_7
                    12678   OSSemSet_6:
                    12679   ; } else {
                    12680   ; *perr              = OS_ERR_TASK_WAITING;
0000432A  2043      12681          move.l    D3,A0
0000432C  10BC 0049 12682          move.b    #73,(A0)
                    12683   OSSemSet_7:
                    12684   ; }
                    12685   ; }
                    12686   ; OS_EXIT_CRITICAL();
00004330  46DF      12687          dc.w      18143
                    12688   OSSemSet_3:
00004332  4CDF 000C 12689          movem.l   (A7)+,D2/D3
00004336  4E5E      12690          unlk      A6
00004338  4E75      12691          rts
                    12692   ; /*
                    12693   ; *********************************************************************************************************
                    12694   ; *                                                uC/OS-II
                    12695   ; *                                          The Real-Time Kernel
                    12696   ; *                                            TASK MANAGEMENT
                    12697   ; *
                    12698   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12699   ; *                                           All Rights Reserved
                    12700   ; *
                    12701   ; * File    : OS_TASK.C
                    12702   ; * By      : Jean J. Labrosse
                    12703   ; * Version : V2.92.07
                    12704   ; *
                    12705   ; * LICENSING TERMS:
                    12706   ; * ---------------
                    12707   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12708   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12709   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12710   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12711   ; * licensing fee.
                    12712   ; *********************************************************************************************************
                    12713   ; */
                    12714   ; #define  MICRIUM_SOURCE
                    12715   ; #ifndef  OS_MASTER_FILE
                    12716   ; #include <ucos_ii.h>
                    12717   ; #endif
                    12718   ; /*$PAGE*/
                    12719   ; /*
                    12720   ; *********************************************************************************************************
                    12721   ; *                                      CHANGE PRIORITY OF A TASK
                    12722   ; *
                    12723   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12724   ; *              priority MUST be available.
                    12725   ; *
                    12726   ; * Arguments  : oldp     is the old priority
                    12727   ; *
                    12728   ; *              newp     is the new priority
                    12729   ; *
                    12730   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12731   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12732   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12733   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12734   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12735   ; *                                     not exist.
                    12736   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12737   ; *********************************************************************************************************
                    12738   ; */
                    12739   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12740   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12741   ; INT8U  newprio)
                    12742   ; {
                    12743   _OSTaskChangePrio:
0000433A  4E56 FFFC 12744          link      A6,#-4
0000433E  48E7 3F38 12745          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00004342  47F9 0800 12746          lea       _OSRdyTbl.L,A3
00004346  0430      
00004348  49F9 0800 12747          lea       _OSTCBPrioTbl.L,A4
0000434C  0550      
                    12748   ; #if (OS_EVENT_EN)
                    12749   ; OS_EVENT  *pevent;
                    12750   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12751   ; OS_EVENT **pevents;
                    12752   ; #endif
                    12753   ; #endif
                    12754   ; OS_TCB    *ptcb;
                    12755   ; INT8U      y_new;
                    12756   ; INT8U      x_new;
                    12757   ; INT8U      y_old;
                    12758   ; OS_PRIO    bity_new;
                    12759   ; OS_PRIO    bitx_new;
                    12760   ; OS_PRIO    bity_old;
                    12761   ; OS_PRIO    bitx_old;
                    12762   ; #if OS_CRITICAL_METHOD == 3u
                    12763   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12764   ; #endif
                    12765   ; /*$PAGE*/
                    12766   ; #if OS_ARG_CHK_EN > 0u
                    12767   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12768   ; if (oldprio != OS_PRIO_SELF) {
                    12769   ; return (OS_ERR_PRIO_INVALID);
                    12770   ; }
                    12771   ; }
                    12772   ; if (newprio >= OS_LOWEST_PRIO) {
                    12773   ; return (OS_ERR_PRIO_INVALID);
                    12774   ; }
                    12775   ; #endif
                    12776   ; OS_ENTER_CRITICAL();
0000434E  40E7      12777          dc.w      16615
00004350  007C      12778          dc.w      124
00004352  0700      12779          dc.w      1792
                    12780   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
00004354  102E 000F 12781          move.b    15(A6),D0
00004358  C0BC 0000 12782          and.l     #255,D0
0000435C  00FF      
0000435E  E588      12783          lsl.l     #2,D0
00004360  2034 0800 12784          move.l    0(A4,D0.L),D0
00004364  6708      12785          beq.s     OSTaskChangePrio_1
                    12786   ; OS_EXIT_CRITICAL();
00004366  46DF      12787          dc.w      18143
                    12788   ; return (OS_ERR_PRIO_EXIST);
00004368  7028      12789          moveq     #40,D0
0000436A  6000 01E0 12790          bra       OSTaskChangePrio_3
                    12791   OSTaskChangePrio_1:
                    12792   ; }
                    12793   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
0000436E  102E 000B 12794          move.b    11(A6),D0
00004372  0C00 00FF 12795          cmp.b     #255,D0
00004376  660C      12796          bne.s     OSTaskChangePrio_4
                    12797   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
00004378  2079 0800 12798          move.l    _OSTCBCur.L,A0
0000437C  0540      
0000437E  1D68 0034 12799          move.b    52(A0),11(A6)
00004382  000B      
                    12800   OSTaskChangePrio_4:
                    12801   ; }
                    12802   ; ptcb = OSTCBPrioTbl[oldprio];
00004384  102E 000B 12803          move.b    11(A6),D0
00004388  C0BC 0000 12804          and.l     #255,D0
0000438C  00FF      
0000438E  E588      12805          lsl.l     #2,D0
00004390  2634 0800 12806          move.l    0(A4,D0.L),D3
                    12807   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
00004394  4A83      12808          tst.l     D3
00004396  6608      12809          bne.s     OSTaskChangePrio_6
                    12810   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
00004398  46DF      12811          dc.w      18143
                    12812   ; return (OS_ERR_PRIO);
0000439A  7029      12813          moveq     #41,D0
0000439C  6000 01AE 12814          bra       OSTaskChangePrio_3
                    12815   OSTaskChangePrio_6:
                    12816   ; }
                    12817   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
000043A0  0C83 0000 12818          cmp.l     #1,D3
000043A4  0001      
000043A6  6608      12819          bne.s     OSTaskChangePrio_8
                    12820   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000043A8  46DF      12821          dc.w      18143
                    12822   ; return (OS_ERR_TASK_NOT_EXIST);
000043AA  7043      12823          moveq     #67,D0
000043AC  6000 019E 12824          bra       OSTaskChangePrio_3
                    12825   OSTaskChangePrio_8:
                    12826   ; }
                    12827   ; #if OS_LOWEST_PRIO <= 63u
                    12828   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
000043B0  102E 000F 12829          move.b    15(A6),D0
000043B4  E608      12830          lsr.b     #3,D0
000043B6  1A00      12831          move.b    D0,D5
                    12832   ; x_new                 = (INT8U)(newprio & 0x07u);
000043B8  102E 000F 12833          move.b    15(A6),D0
000043BC  C03C 0007 12834          and.b     #7,D0
000043C0  1D40 FFFD 12835          move.b    D0,-3(A6)
                    12836   ; #else
                    12837   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    12838   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    12839   ; #endif
                    12840   ; bity_new              = (OS_PRIO)(1uL << y_new);
000043C4  7001      12841          moveq     #1,D0
000043C6  CABC 0000 12842          and.l     #255,D5
000043CA  00FF      
000043CC  EBA8      12843          lsl.l     D5,D0
000043CE  1D40 FFFE 12844          move.b    D0,-2(A6)
                    12845   ; bitx_new              = (OS_PRIO)(1uL << x_new);
000043D2  7001      12846          moveq     #1,D0
000043D4  122E FFFD 12847          move.b    -3(A6),D1
000043D8  C2BC 0000 12848          and.l     #255,D1
000043DC  00FF      
000043DE  E3A8      12849          lsl.l     D1,D0
000043E0  1E00      12850          move.b    D0,D7
                    12851   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
000043E2  102E 000B 12852          move.b    11(A6),D0
000043E6  C0BC 0000 12853          and.l     #255,D0
000043EA  00FF      
000043EC  E588      12854          lsl.l     #2,D0
000043EE  42B4 0800 12855          clr.l     0(A4,D0.L)
                    12856   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
000043F2  102E 000F 12857          move.b    15(A6),D0
000043F6  C0BC 0000 12858          and.l     #255,D0
000043FA  00FF      
000043FC  E588      12859          lsl.l     #2,D0
000043FE  2983 0800 12860          move.l    D3,0(A4,D0.L)
                    12861   ; y_old                 =  ptcb->OSTCBY;
00004402  2043      12862          move.l    D3,A0
00004404  1828 0036 12863          move.b    54(A0),D4
                    12864   ; bity_old              =  ptcb->OSTCBBitY;
00004408  2043      12865          move.l    D3,A0
0000440A  1D68 0038 12866          move.b    56(A0),-1(A6)
0000440E  FFFF      
                    12867   ; bitx_old              =  ptcb->OSTCBBitX;
00004410  2043      12868          move.l    D3,A0
00004412  1C28 0037 12869          move.b    55(A0),D6
                    12870   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00004416  C8BC 0000 12871          and.l     #255,D4
0000441A  00FF      
0000441C  1033 4800 12872          move.b    0(A3,D4.L),D0
00004420  C006      12873          and.b     D6,D0
00004422  673A      12874          beq.s     OSTaskChangePrio_10
                    12875   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
00004424  C8BC 0000 12876          and.l     #255,D4
00004428  00FF      
0000442A  1006      12877          move.b    D6,D0
0000442C  4600      12878          not.b     D0
0000442E  C133 4800 12879          and.b     D0,0(A3,D4.L)
                    12880   ; if (OSRdyTbl[y_old] == 0u) {
00004432  C8BC 0000 12881          and.l     #255,D4
00004436  00FF      
00004438  1033 4800 12882          move.b    0(A3,D4.L),D0
0000443C  660C      12883          bne.s     OSTaskChangePrio_12
                    12884   ; OSRdyGrp &= (OS_PRIO)~bity_old;
0000443E  102E FFFF 12885          move.b    -1(A6),D0
00004442  4600      12886          not.b     D0
00004444  C139 0800 12887          and.b     D0,_OSRdyGrp.L
00004448  042E      
                    12888   OSTaskChangePrio_12:
                    12889   ; }
                    12890   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
0000444A  102E FFFE 12891          move.b    -2(A6),D0
0000444E  8139 0800 12892          or.b      D0,_OSRdyGrp.L
00004452  042E      
                    12893   ; OSRdyTbl[y_new] |= bitx_new;
00004454  CABC 0000 12894          and.l     #255,D5
00004458  00FF      
0000445A  8F33 5800 12895          or.b      D7,0(A3,D5.L)
                    12896   OSTaskChangePrio_10:
                    12897   ; }
                    12898   ; #if (OS_EVENT_EN)
                    12899   ; pevent = ptcb->OSTCBEventPtr;
0000445E  2043      12900          move.l    D3,A0
00004460  2428 001C 12901          move.l    28(A0),D2
                    12902   ; if (pevent != (OS_EVENT *)0) {
00004464  4A82      12903          tst.l     D2
00004466  6700 0048 12904          beq       OSTaskChangePrio_14
                    12905   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
0000446A  2042      12906          move.l    D2,A0
0000446C  C8BC 0000 12907          and.l     #255,D4
00004470  00FF      
00004472  D1C4      12908          add.l     D4,A0
00004474  1006      12909          move.b    D6,D0
00004476  4600      12910          not.b     D0
00004478  C128 000A 12911          and.b     D0,10(A0)
                    12912   ; if (pevent->OSEventTbl[y_old] == 0u) {
0000447C  2042      12913          move.l    D2,A0
0000447E  C8BC 0000 12914          and.l     #255,D4
00004482  00FF      
00004484  D1C4      12915          add.l     D4,A0
00004486  1028 000A 12916          move.b    10(A0),D0
0000448A  660C      12917          bne.s     OSTaskChangePrio_16
                    12918   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0000448C  2042      12919          move.l    D2,A0
0000448E  102E FFFF 12920          move.b    -1(A6),D0
00004492  4600      12921          not.b     D0
00004494  C128 0008 12922          and.b     D0,8(A0)
                    12923   OSTaskChangePrio_16:
                    12924   ; }
                    12925   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
00004498  2042      12926          move.l    D2,A0
0000449A  102E FFFE 12927          move.b    -2(A6),D0
0000449E  8128 0008 12928          or.b      D0,8(A0)
                    12929   ; pevent->OSEventTbl[y_new] |= bitx_new;
000044A2  2042      12930          move.l    D2,A0
000044A4  CABC 0000 12931          and.l     #255,D5
000044A8  00FF      
000044AA  D1C5      12932          add.l     D5,A0
000044AC  8F28 000A 12933          or.b      D7,10(A0)
                    12934   OSTaskChangePrio_14:
                    12935   ; }
                    12936   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12937   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
000044B0  2043      12938          move.l    D3,A0
000044B2  2028 0020 12939          move.l    32(A0),D0
000044B6  6700 005C 12940          beq       OSTaskChangePrio_22
                    12941   ; pevents =  ptcb->OSTCBEventMultiPtr;
000044BA  2043      12942          move.l    D3,A0
000044BC  2468 0020 12943          move.l    32(A0),A2
                    12944   ; pevent  = *pevents;
000044C0  2412      12945          move.l    (A2),D2
                    12946   ; while (pevent != (OS_EVENT *)0) {
                    12947   OSTaskChangePrio_20:
000044C2  4A82      12948          tst.l     D2
000044C4  6700 004E 12949          beq       OSTaskChangePrio_22
                    12950   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
000044C8  2042      12951          move.l    D2,A0
000044CA  C8BC 0000 12952          and.l     #255,D4
000044CE  00FF      
000044D0  D1C4      12953          add.l     D4,A0
000044D2  1006      12954          move.b    D6,D0
000044D4  4600      12955          not.b     D0
000044D6  C128 000A 12956          and.b     D0,10(A0)
                    12957   ; if (pevent->OSEventTbl[y_old] == 0u) {
000044DA  2042      12958          move.l    D2,A0
000044DC  C8BC 0000 12959          and.l     #255,D4
000044E0  00FF      
000044E2  D1C4      12960          add.l     D4,A0
000044E4  1028 000A 12961          move.b    10(A0),D0
000044E8  660C      12962          bne.s     OSTaskChangePrio_23
                    12963   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000044EA  2042      12964          move.l    D2,A0
000044EC  102E FFFF 12965          move.b    -1(A6),D0
000044F0  4600      12966          not.b     D0
000044F2  C128 0008 12967          and.b     D0,8(A0)
                    12968   OSTaskChangePrio_23:
                    12969   ; }
                    12970   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
000044F6  2042      12971          move.l    D2,A0
000044F8  102E FFFE 12972          move.b    -2(A6),D0
000044FC  8128 0008 12973          or.b      D0,8(A0)
                    12974   ; pevent->OSEventTbl[y_new] |= bitx_new;
00004500  2042      12975          move.l    D2,A0
00004502  CABC 0000 12976          and.l     #255,D5
00004506  00FF      
00004508  D1C5      12977          add.l     D5,A0
0000450A  8F28 000A 12978          or.b      D7,10(A0)
                    12979   ; pevents++;
0000450E  584A      12980          addq.w    #4,A2
                    12981   ; pevent                     = *pevents;
00004510  2412      12982          move.l    (A2),D2
00004512  60AE      12983          bra       OSTaskChangePrio_20
                    12984   OSTaskChangePrio_22:
                    12985   ; }
                    12986   ; }
                    12987   ; #endif
                    12988   ; #endif
                    12989   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
00004514  2043      12990          move.l    D3,A0
00004516  116E 000F 12991          move.b    15(A6),52(A0)
0000451A  0034      
                    12992   ; ptcb->OSTCBY    = y_new;
0000451C  2043      12993          move.l    D3,A0
0000451E  1145 0036 12994          move.b    D5,54(A0)
                    12995   ; ptcb->OSTCBX    = x_new;
00004522  2043      12996          move.l    D3,A0
00004524  116E FFFD 12997          move.b    -3(A6),53(A0)
00004528  0035      
                    12998   ; ptcb->OSTCBBitY = bity_new;
0000452A  2043      12999          move.l    D3,A0
0000452C  116E FFFE 13000          move.b    -2(A6),56(A0)
00004530  0038      
                    13001   ; ptcb->OSTCBBitX = bitx_new;
00004532  2043      13002          move.l    D3,A0
00004534  1147 0037 13003          move.b    D7,55(A0)
                    13004   ; OS_EXIT_CRITICAL();
00004538  46DF      13005          dc.w      18143
                    13006   ; if (OSRunning == OS_TRUE) {
0000453A  1039 0800 13007          move.b    _OSRunning.L,D0
0000453E  0438      
00004540  0C00 0001 13008          cmp.b     #1,D0
00004544  6604      13009          bne.s     OSTaskChangePrio_25
                    13010   ; OS_Sched();                                         /* Find new highest priority task          */
00004546  4EB8 16B8 13011          jsr       _OS_Sched
                    13012   OSTaskChangePrio_25:
                    13013   ; }
                    13014   ; return (OS_ERR_NONE);
0000454A  4200      13015          clr.b     D0
                    13016   OSTaskChangePrio_3:
0000454C  4CDF 1CFC 13017          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00004550  4E5E      13018          unlk      A6
00004552  4E75      13019          rts
                    13020   ; }
                    13021   ; #endif
                    13022   ; /*$PAGE*/
                    13023   ; /*
                    13024   ; *********************************************************************************************************
                    13025   ; *                                            CREATE A TASK
                    13026   ; *
                    13027   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13028   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13029   ; *              created by an ISR.
                    13030   ; *
                    13031   ; * Arguments  : task     is a pointer to the task's code
                    13032   ; *
                    13033   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    13034   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    13035   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    13036   ; *
                    13037   ; *                           void Task (void *p_arg)
                    13038   ; *                           {
                    13039   ; *                               for (;;) {
                    13040   ; *                                   Task code;
                    13041   ; *                               }
                    13042   ; *                           }
                    13043   ; *
                    13044   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    13045   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13046   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    13047   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    13048   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    13049   ; *                       memory locations.
                    13050   ; *
                    13051   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    13052   ; *                       lower the number, the higher the priority.
                    13053   ; *
                    13054   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13055   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13056   ; *                                               (each task MUST have a unique priority).
                    13057   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13058   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    13059   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13060   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13061   ; *                                               operation started.
                    13062   ; *********************************************************************************************************
                    13063   ; */
                    13064   ; #if OS_TASK_CREATE_EN > 0u
                    13065   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    13066   ; void    *p_arg,
                    13067   ; OS_STK  *ptos,
                    13068   ; INT8U    prio)
                    13069   ; {
                    13070   _OSTaskCreate:
00004554  4E56 FFFC 13071          link      A6,#-4
00004558  48E7 3020 13072          movem.l   D2/D3/A2,-(A7)
0000455C  142E 0017 13073          move.b    23(A6),D2
00004560  C4BC 0000 13074          and.l     #255,D2
00004564  00FF      
00004566  45F9 0800 13075          lea       _OSTCBPrioTbl.L,A2
0000456A  0550      
                    13076   ; OS_STK     *psp;
                    13077   ; INT8U       err;
                    13078   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13079   ; OS_CPU_SR   cpu_sr = 0u;
                    13080   ; #endif
                    13081   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13082   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13083   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13084   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13085   ; }
                    13086   ; #endif
                    13087   ; #if OS_ARG_CHK_EN > 0u
                    13088   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13089   ; return (OS_ERR_PRIO_INVALID);
                    13090   ; }
                    13091   ; #endif
                    13092   ; OS_ENTER_CRITICAL();
0000456C  40E7      13093          dc.w      16615
0000456E  007C      13094          dc.w      124
00004570  0700      13095          dc.w      1792
                    13096   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
00004572  1039 0800 13097          move.b    _OSIntNesting.L,D0
00004576  0426      
00004578  0C00 0000 13098          cmp.b     #0,D0
0000457C  6308      13099          bls.s     OSTaskCreate_1
                    13100   ; OS_EXIT_CRITICAL();
0000457E  46DF      13101          dc.w      18143
                    13102   ; return (OS_ERR_TASK_CREATE_ISR);
00004580  703C      13103          moveq     #60,D0
00004582  6000 0096 13104          bra       OSTaskCreate_3
                    13105   OSTaskCreate_1:
                    13106   ; }
                    13107   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
00004586  C4BC 0000 13108          and.l     #255,D2
0000458A  00FF      
0000458C  2002      13109          move.l    D2,D0
0000458E  E588      13110          lsl.l     #2,D0
00004590  2032 0800 13111          move.l    0(A2,D0.L),D0
00004594  6600 0080 13112          bne       OSTaskCreate_4
                    13113   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00004598  C4BC 0000 13114          and.l     #255,D2
0000459C  00FF      
0000459E  2002      13115          move.l    D2,D0
000045A0  E588      13116          lsl.l     #2,D0
000045A2  25BC 0000 13117          move.l    #1,0(A2,D0.L)
000045A6  0001 0800 
                    13118   ; /* ... the same thing until task is created.              */
                    13119   ; OS_EXIT_CRITICAL();
000045AA  46DF      13120          dc.w      18143
                    13121   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
000045AC  42A7      13122          clr.l     -(A7)
000045AE  2F2E 0010 13123          move.l    16(A6),-(A7)
000045B2  2F2E 000C 13124          move.l    12(A6),-(A7)
000045B6  2F2E 0008 13125          move.l    8(A6),-(A7)
000045BA  4EB8 08BA 13126          jsr       _OSTaskStkInit
000045BE  DEFC 0010 13127          add.w     #16,A7
000045C2  2D40 FFFC 13128          move.l    D0,-4(A6)
                    13129   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
000045C6  42A7      13130          clr.l     -(A7)
000045C8  42A7      13131          clr.l     -(A7)
000045CA  42A7      13132          clr.l     -(A7)
000045CC  42A7      13133          clr.l     -(A7)
000045CE  42A7      13134          clr.l     -(A7)
000045D0  2F2E FFFC 13135          move.l    -4(A6),-(A7)
000045D4  C4BC 0000 13136          and.l     #255,D2
000045D8  00FF      
000045DA  2F02      13137          move.l    D2,-(A7)
000045DC  4EB8 18D2 13138          jsr       _OS_TCBInit
000045E0  DEFC 001C 13139          add.w     #28,A7
000045E4  1600      13140          move.b    D0,D3
                    13141   ; if (err == OS_ERR_NONE) {
000045E6  4A03      13142          tst.b     D3
000045E8  6612      13143          bne.s     OSTaskCreate_6
                    13144   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
000045EA  1039 0800 13145          move.b    _OSRunning.L,D0
000045EE  0438      
000045F0  0C00 0001 13146          cmp.b     #1,D0
000045F4  6604      13147          bne.s     OSTaskCreate_8
                    13148   ; OS_Sched();
000045F6  4EB8 16B8 13149          jsr       _OS_Sched
                    13150   OSTaskCreate_8:
000045FA  6016      13151          bra.s     OSTaskCreate_7
                    13152   OSTaskCreate_6:
                    13153   ; }
                    13154   ; } else {
                    13155   ; OS_ENTER_CRITICAL();
000045FC  40E7      13156          dc.w      16615
000045FE  007C      13157          dc.w      124
00004600  0700      13158          dc.w      1792
                    13159   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00004602  C4BC 0000 13160          and.l     #255,D2
00004606  00FF      
00004608  2002      13161          move.l    D2,D0
0000460A  E588      13162          lsl.l     #2,D0
0000460C  42B2 0800 13163          clr.l     0(A2,D0.L)
                    13164   ; OS_EXIT_CRITICAL();
00004610  46DF      13165          dc.w      18143
                    13166   OSTaskCreate_7:
                    13167   ; }
                    13168   ; return (err);
00004612  1003      13169          move.b    D3,D0
00004614  6004      13170          bra.s     OSTaskCreate_3
                    13171   OSTaskCreate_4:
                    13172   ; }
                    13173   ; OS_EXIT_CRITICAL();
00004616  46DF      13174          dc.w      18143
                    13175   ; return (OS_ERR_PRIO_EXIST);
00004618  7028      13176          moveq     #40,D0
                    13177   OSTaskCreate_3:
0000461A  4CDF 040C 13178          movem.l   (A7)+,D2/D3/A2
0000461E  4E5E      13179          unlk      A6
00004620  4E75      13180          rts
                    13181   ; }
                    13182   ; #endif
                    13183   ; /*$PAGE*/
                    13184   ; /*
                    13185   ; *********************************************************************************************************
                    13186   ; *                                  CREATE A TASK (Extended Version)
                    13187   ; *
                    13188   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13189   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13190   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13191   ; *              additional information about a task to be specified.
                    13192   ; *
                    13193   ; * Arguments  : task      is a pointer to the task's code
                    13194   ; *
                    13195   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13196   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13197   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13198   ; *
                    13199   ; *                            void Task (void *p_arg)
                    13200   ; *                            {
                    13201   ; *                                for (;;) {
                    13202   ; *                                    Task code;
                    13203   ; *                                }
                    13204   ; *                            }
                    13205   ; *
                    13206   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13207   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13208   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13209   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13210   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13211   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13212   ; *
                    13213   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13214   ; *                        lower the number, the higher the priority.
                    13215   ; *
                    13216   ; *              id        is the task's ID (0..65535)
                    13217   ; *
                    13218   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13219   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13220   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13221   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13222   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13223   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13224   ; *
                    13225   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13226   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13227   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13228   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13229   ; *                        available on the stack.
                    13230   ; *
                    13231   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13232   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13233   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13234   ; *                        the task has been switched-in, etc.
                    13235   ; *
                    13236   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13237   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13238   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13239   ; *
                    13240   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13241   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13242   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13243   ; *                                                 during a context switch.
                    13244   ; *
                    13245   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13246   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13247   ; *                                               (each task MUST have a unique priority).
                    13248   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13249   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13250   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13251   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13252   ; *                                               operation started.
                    13253   ; *********************************************************************************************************
                    13254   ; */
                    13255   ; /*$PAGE*/
                    13256   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13257   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13258   ; void    *p_arg,
                    13259   ; OS_STK  *ptos,
                    13260   ; INT8U    prio,
                    13261   ; INT16U   id,
                    13262   ; OS_STK  *pbos,
                    13263   ; INT32U   stk_size,
                    13264   ; void    *pext,
                    13265   ; INT16U   opt)
                    13266   ; {
                    13267   _OSTaskCreateExt:
00004622  4E56 FFFC 13268          link      A6,#-4
00004626  48E7 3820 13269          movem.l   D2/D3/D4/A2,-(A7)
0000462A  142E 0017 13270          move.b    23(A6),D2
0000462E  C4BC 0000 13271          and.l     #255,D2
00004632  00FF      
00004634  382E 002A 13272          move.w    42(A6),D4
00004638  C8BC 0000 13273          and.l     #65535,D4
0000463C  FFFF      
0000463E  45F9 0800 13274          lea       _OSTCBPrioTbl.L,A2
00004642  0550      
                    13275   ; OS_STK     *psp;
                    13276   ; INT8U       err;
                    13277   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13278   ; OS_CPU_SR   cpu_sr = 0u;
                    13279   ; #endif
                    13280   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13281   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13282   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13283   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13284   ; }
                    13285   ; #endif
                    13286   ; #if OS_ARG_CHK_EN > 0u
                    13287   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13288   ; return (OS_ERR_PRIO_INVALID);
                    13289   ; }
                    13290   ; #endif
                    13291   ; OS_ENTER_CRITICAL();
00004644  40E7      13292          dc.w      16615
00004646  007C      13293          dc.w      124
00004648  0700      13294          dc.w      1792
                    13295   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0000464A  1039 0800 13296          move.b    _OSIntNesting.L,D0
0000464E  0426      
00004650  0C00 0000 13297          cmp.b     #0,D0
00004654  6308      13298          bls.s     OSTaskCreateExt_1
                    13299   ; OS_EXIT_CRITICAL();
00004656  46DF      13300          dc.w      18143
                    13301   ; return (OS_ERR_TASK_CREATE_ISR);
00004658  703C      13302          moveq     #60,D0
0000465A  6000 00CC 13303          bra       OSTaskCreateExt_3
                    13304   OSTaskCreateExt_1:
                    13305   ; }
                    13306   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
0000465E  C4BC 0000 13307          and.l     #255,D2
00004662  00FF      
00004664  2002      13308          move.l    D2,D0
00004666  E588      13309          lsl.l     #2,D0
00004668  2032 0800 13310          move.l    0(A2,D0.L),D0
0000466C  6600 00B6 13311          bne       OSTaskCreateExt_4
                    13312   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00004670  C4BC 0000 13313          and.l     #255,D2
00004674  00FF      
00004676  2002      13314          move.l    D2,D0
00004678  E588      13315          lsl.l     #2,D0
0000467A  25BC 0000 13316          move.l    #1,0(A2,D0.L)
0000467E  0001 0800 
                    13317   ; /* ... the same thing until task is created.              */
                    13318   ; OS_EXIT_CRITICAL();
00004682  46DF      13319          dc.w      18143
                    13320   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13321   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
00004684  C8BC 0000 13322          and.l     #65535,D4
00004688  FFFF      
0000468A  2F04      13323          move.l    D4,-(A7)
0000468C  2F2E 0020 13324          move.l    32(A6),-(A7)
00004690  2F2E 001C 13325          move.l    28(A6),-(A7)
00004694  4EB9 0000 13326          jsr       _OS_TaskStkClr
00004698  4E7C      
0000469A  DEFC 000C 13327          add.w     #12,A7
                    13328   ; #endif
                    13329   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
0000469E  C8BC 0000 13330          and.l     #65535,D4
000046A2  FFFF      
000046A4  2F04      13331          move.l    D4,-(A7)
000046A6  2F2E 0010 13332          move.l    16(A6),-(A7)
000046AA  2F2E 000C 13333          move.l    12(A6),-(A7)
000046AE  2F2E 0008 13334          move.l    8(A6),-(A7)
000046B2  4EB8 08BA 13335          jsr       _OSTaskStkInit
000046B6  DEFC 0010 13336          add.w     #16,A7
000046BA  2D40 FFFC 13337          move.l    D0,-4(A6)
                    13338   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
000046BE  C8BC 0000 13339          and.l     #65535,D4
000046C2  FFFF      
000046C4  2F04      13340          move.l    D4,-(A7)
000046C6  2F2E 0024 13341          move.l    36(A6),-(A7)
000046CA  2F2E 0020 13342          move.l    32(A6),-(A7)
000046CE  322E 001A 13343          move.w    26(A6),D1
000046D2  C2BC 0000 13344          and.l     #65535,D1
000046D6  FFFF      
000046D8  2F01      13345          move.l    D1,-(A7)
000046DA  2F2E 001C 13346          move.l    28(A6),-(A7)
000046DE  2F2E FFFC 13347          move.l    -4(A6),-(A7)
000046E2  C4BC 0000 13348          and.l     #255,D2
000046E6  00FF      
000046E8  2F02      13349          move.l    D2,-(A7)
000046EA  4EB8 18D2 13350          jsr       _OS_TCBInit
000046EE  DEFC 001C 13351          add.w     #28,A7
000046F2  1600      13352          move.b    D0,D3
                    13353   ; if (err == OS_ERR_NONE) {
000046F4  4A03      13354          tst.b     D3
000046F6  6612      13355          bne.s     OSTaskCreateExt_6
                    13356   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
000046F8  1039 0800 13357          move.b    _OSRunning.L,D0
000046FC  0438      
000046FE  0C00 0001 13358          cmp.b     #1,D0
00004702  6604      13359          bne.s     OSTaskCreateExt_8
                    13360   ; OS_Sched();
00004704  4EB8 16B8 13361          jsr       _OS_Sched
                    13362   OSTaskCreateExt_8:
00004708  6016      13363          bra.s     OSTaskCreateExt_7
                    13364   OSTaskCreateExt_6:
                    13365   ; }
                    13366   ; } else {
                    13367   ; OS_ENTER_CRITICAL();
0000470A  40E7      13368          dc.w      16615
0000470C  007C      13369          dc.w      124
0000470E  0700      13370          dc.w      1792
                    13371   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
00004710  C4BC 0000 13372          and.l     #255,D2
00004714  00FF      
00004716  2002      13373          move.l    D2,D0
00004718  E588      13374          lsl.l     #2,D0
0000471A  42B2 0800 13375          clr.l     0(A2,D0.L)
                    13376   ; OS_EXIT_CRITICAL();
0000471E  46DF      13377          dc.w      18143
                    13378   OSTaskCreateExt_7:
                    13379   ; }
                    13380   ; return (err);
00004720  1003      13381          move.b    D3,D0
00004722  6004      13382          bra.s     OSTaskCreateExt_3
                    13383   OSTaskCreateExt_4:
                    13384   ; }
                    13385   ; OS_EXIT_CRITICAL();
00004724  46DF      13386          dc.w      18143
                    13387   ; return (OS_ERR_PRIO_EXIST);
00004726  7028      13388          moveq     #40,D0
                    13389   OSTaskCreateExt_3:
00004728  4CDF 041C 13390          movem.l   (A7)+,D2/D3/D4/A2
0000472C  4E5E      13391          unlk      A6
0000472E  4E75      13392          rts
                    13393   ; }
                    13394   ; #endif
                    13395   ; /*$PAGE*/
                    13396   ; /*
                    13397   ; *********************************************************************************************************
                    13398   ; *                                            DELETE A TASK
                    13399   ; *
                    13400   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13401   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13402   ; *              re-activated by creating the deleted task again.
                    13403   ; *
                    13404   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13405   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13406   ; *                      OS_PRIO_SELF.
                    13407   ; *
                    13408   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13409   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13410   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13411   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13412   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13413   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13414   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13415   ; *
                    13416   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13417   ; *                    a) by making it not ready
                    13418   ; *                    b) by removing it from any wait lists
                    13419   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13420   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13421   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13422   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13423   ; *              3) An ISR cannot delete a task.
                    13424   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13425   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13426   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13427   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13428   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13429   ; *********************************************************************************************************
                    13430   ; */
                    13431   ; #if OS_TASK_DEL_EN > 0u
                    13432   ; INT8U  OSTaskDel (INT8U prio)
                    13433   ; {
                    13434   _OSTaskDel:
00004730  4E56 0000 13435          link      A6,#0
00004734  48E7 3800 13436          movem.l   D2/D3/D4,-(A7)
00004738  162E 000B 13437          move.b    11(A6),D3
0000473C  C6BC 0000 13438          and.l     #255,D3
00004740  00FF      
                    13439   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13440   ; OS_FLAG_NODE *pnode;
                    13441   ; #endif
                    13442   ; OS_TCB       *ptcb;
                    13443   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13444   ; OS_CPU_SR     cpu_sr = 0u;
                    13445   ; #endif
                    13446   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
00004742  1039 0800 13447          move.b    _OSIntNesting.L,D0
00004746  0426      
00004748  0C00 0000 13448          cmp.b     #0,D0
0000474C  6306      13449          bls.s     OSTaskDel_1
                    13450   ; return (OS_ERR_TASK_DEL_ISR);
0000474E  7040      13451          moveq     #64,D0
00004750  6000 01A4 13452          bra       OSTaskDel_3
                    13453   OSTaskDel_1:
                    13454   ; }
                    13455   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00004754  0C03 003F 13456          cmp.b     #63,D3
00004758  6606      13457          bne.s     OSTaskDel_4
                    13458   ; return (OS_ERR_TASK_DEL_IDLE);
0000475A  703E      13459          moveq     #62,D0
0000475C  6000 0198 13460          bra       OSTaskDel_3
                    13461   OSTaskDel_4:
                    13462   ; }
                    13463   ; #if OS_ARG_CHK_EN > 0u
                    13464   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13465   ; if (prio != OS_PRIO_SELF) {
                    13466   ; return (OS_ERR_PRIO_INVALID);
                    13467   ; }
                    13468   ; }
                    13469   ; #endif
                    13470   ; /*$PAGE*/
                    13471   ; OS_ENTER_CRITICAL();
00004760  40E7      13472          dc.w      16615
00004762  007C      13473          dc.w      124
00004764  0700      13474          dc.w      1792
                    13475   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
00004766  0C03 00FF 13476          cmp.b     #255,D3
0000476A  660A      13477          bne.s     OSTaskDel_6
                    13478   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
0000476C  2079 0800 13479          move.l    _OSTCBCur.L,A0
00004770  0540      
00004772  1628 0034 13480          move.b    52(A0),D3
                    13481   OSTaskDel_6:
                    13482   ; }
                    13483   ; ptcb = OSTCBPrioTbl[prio];
00004776  C6BC 0000 13484          and.l     #255,D3
0000477A  00FF      
0000477C  2003      13485          move.l    D3,D0
0000477E  E588      13486          lsl.l     #2,D0
00004780  41F9 0800 13487          lea       _OSTCBPrioTbl.L,A0
00004784  0550      
00004786  2430 0800 13488          move.l    0(A0,D0.L),D2
                    13489   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
0000478A  4A82      13490          tst.l     D2
0000478C  6608      13491          bne.s     OSTaskDel_8
                    13492   ; OS_EXIT_CRITICAL();
0000478E  46DF      13493          dc.w      18143
                    13494   ; return (OS_ERR_TASK_NOT_EXIST);
00004790  7043      13495          moveq     #67,D0
00004792  6000 0162 13496          bra       OSTaskDel_3
                    13497   OSTaskDel_8:
                    13498   ; }
                    13499   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
00004796  0C82 0000 13500          cmp.l     #1,D2
0000479A  0001      
0000479C  6608      13501          bne.s     OSTaskDel_10
                    13502   ; OS_EXIT_CRITICAL();
0000479E  46DF      13503          dc.w      18143
                    13504   ; return (OS_ERR_TASK_DEL);
000047A0  703D      13505          moveq     #61,D0
000047A2  6000 0152 13506          bra       OSTaskDel_3
                    13507   OSTaskDel_10:
                    13508   ; }
                    13509   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
000047A6  2042      13510          move.l    D2,A0
000047A8  1028 0036 13511          move.b    54(A0),D0
000047AC  C0BC 0000 13512          and.l     #255,D0
000047B0  00FF      
000047B2  41F9 0800 13513          lea       _OSRdyTbl.L,A0
000047B6  0430      
000047B8  2242      13514          move.l    D2,A1
000047BA  1229 0037 13515          move.b    55(A1),D1
000047BE  4601      13516          not.b     D1
000047C0  C330 0800 13517          and.b     D1,0(A0,D0.L)
                    13518   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
000047C4  2042      13519          move.l    D2,A0
000047C6  1028 0036 13520          move.b    54(A0),D0
000047CA  C0BC 0000 13521          and.l     #255,D0
000047CE  00FF      
000047D0  41F9 0800 13522          lea       _OSRdyTbl.L,A0
000047D4  0430      
000047D6  1030 0800 13523          move.b    0(A0,D0.L),D0
000047DA  660E      13524          bne.s     OSTaskDel_12
                    13525   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
000047DC  2042      13526          move.l    D2,A0
000047DE  1028 0038 13527          move.b    56(A0),D0
000047E2  4600      13528          not.b     D0
000047E4  C139 0800 13529          and.b     D0,_OSRdyGrp.L
000047E8  042E      
                    13530   OSTaskDel_12:
                    13531   ; }
                    13532   ; #if (OS_EVENT_EN)
                    13533   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
000047EA  2042      13534          move.l    D2,A0
000047EC  2028 001C 13535          move.l    28(A0),D0
000047F0  670E      13536          beq.s     OSTaskDel_14
                    13537   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
000047F2  2042      13538          move.l    D2,A0
000047F4  2F28 001C 13539          move.l    28(A0),-(A7)
000047F8  2F02      13540          move.l    D2,-(A7)
000047FA  4EB8 12DE 13541          jsr       _OS_EventTaskRemove
000047FE  504F      13542          addq.w    #8,A7
                    13543   OSTaskDel_14:
                    13544   ; }
                    13545   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13546   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
00004800  2042      13547          move.l    D2,A0
00004802  2028 0020 13548          move.l    32(A0),D0
00004806  670E      13549          beq.s     OSTaskDel_16
                    13550   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00004808  2042      13551          move.l    D2,A0
0000480A  2F28 0020 13552          move.l    32(A0),-(A7)
0000480E  2F02      13553          move.l    D2,-(A7)
00004810  4EB8 1330 13554          jsr       _OS_EventTaskRemoveMulti
00004814  504F      13555          addq.w    #8,A7
                    13556   OSTaskDel_16:
                    13557   ; }
                    13558   ; #endif
                    13559   ; #endif
                    13560   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13561   ; pnode = ptcb->OSTCBFlagNode;
00004816  2042      13562          move.l    D2,A0
00004818  2828 0028 13563          move.l    40(A0),D4
                    13564   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
0000481C  4A84      13565          tst.l     D4
0000481E  6708      13566          beq.s     OSTaskDel_18
                    13567   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00004820  2F04      13568          move.l    D4,-(A7)
00004822  4EB8 24E8 13569          jsr       _OS_FlagUnlink
00004826  584F      13570          addq.w    #4,A7
                    13571   OSTaskDel_18:
                    13572   ; }
                    13573   ; #endif
                    13574   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
00004828  2042      13575          move.l    D2,A0
0000482A  42A8 002E 13576          clr.l     46(A0)
                    13577   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
0000482E  2042      13578          move.l    D2,A0
00004830  4228 0032 13579          clr.b     50(A0)
                    13580   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004834  2042      13581          move.l    D2,A0
00004836  4228 0033 13582          clr.b     51(A0)
                    13583   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
0000483A  1039 0800 13584          move.b    _OSLockNesting.L,D0
0000483E  0428      
00004840  0C00 00FF 13585          cmp.b     #255,D0
00004844  6406      13586          bhs.s     OSTaskDel_20
                    13587   ; OSLockNesting++;
00004846  5239 0800 13588          addq.b    #1,_OSLockNesting.L
0000484A  0428      
                    13589   OSTaskDel_20:
                    13590   ; }
                    13591   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
0000484C  46DF      13592          dc.w      18143
                    13593   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
0000484E  4EB8 10D6 13594          jsr       _OS_Dummy
                    13595   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00004852  40E7      13596          dc.w      16615
00004854  007C      13597          dc.w      124
00004856  0700      13598          dc.w      1792
                    13599   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
00004858  1039 0800 13600          move.b    _OSLockNesting.L,D0
0000485C  0428      
0000485E  0C00 0000 13601          cmp.b     #0,D0
00004862  6306      13602          bls.s     OSTaskDel_22
                    13603   ; OSLockNesting--;
00004864  5339 0800 13604          subq.b    #1,_OSLockNesting.L
00004868  0428      
                    13605   OSTaskDel_22:
                    13606   ; }
                    13607   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
0000486A  2F02      13608          move.l    D2,-(A7)
0000486C  4EB8 09A4 13609          jsr       _OSTaskDelHook
00004870  584F      13610          addq.w    #4,A7
                    13611   ; OSTaskCtr--;                                        /* One less task being managed                 */
00004872  5339 0800 13612          subq.b    #1,_OSTaskCtr.L
00004876  043A      
                    13613   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
00004878  C6BC 0000 13614          and.l     #255,D3
0000487C  00FF      
0000487E  2003      13615          move.l    D3,D0
00004880  E588      13616          lsl.l     #2,D0
00004882  41F9 0800 13617          lea       _OSTCBPrioTbl.L,A0
00004886  0550      
00004888  42B0 0800 13618          clr.l     0(A0,D0.L)
                    13619   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
0000488C  2042      13620          move.l    D2,A0
0000488E  2028 0018 13621          move.l    24(A0),D0
00004892  6616      13622          bne.s     OSTaskDel_24
                    13623   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
00004894  2042      13624          move.l    D2,A0
00004896  2068 0014 13625          move.l    20(A0),A0
0000489A  42A8 0018 13626          clr.l     24(A0)
                    13627   ; OSTCBList                  = ptcb->OSTCBNext;
0000489E  2042      13628          move.l    D2,A0
000048A0  23E8 0014 13629          move.l    20(A0),_OSTCBList.L
000048A4  0800 054C 
000048A8  601C      13630          bra.s     OSTaskDel_25
                    13631   OSTaskDel_24:
                    13632   ; } else {
                    13633   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
000048AA  2042      13634          move.l    D2,A0
000048AC  2242      13635          move.l    D2,A1
000048AE  2269 0018 13636          move.l    24(A1),A1
000048B2  2368 0014 13637          move.l    20(A0),20(A1)
000048B6  0014      
                    13638   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
000048B8  2042      13639          move.l    D2,A0
000048BA  2242      13640          move.l    D2,A1
000048BC  2269 0014 13641          move.l    20(A1),A1
000048C0  2368 0018 13642          move.l    24(A0),24(A1)
000048C4  0018      
                    13643   OSTaskDel_25:
                    13644   ; }
                    13645   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
000048C6  2042      13646          move.l    D2,A0
000048C8  2179 0800 13647          move.l    _OSTCBFreeList.L,20(A0)
000048CC  0544 0014 
                    13648   ; OSTCBFreeList       = ptcb;
000048D0  23C2 0800 13649          move.l    D2,_OSTCBFreeList.L
000048D4  0544      
                    13650   ; #if OS_TASK_NAME_EN > 0u
                    13651   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
000048D6  41F9 0000 13652          lea       @ucos_ii_1.L,A0
000048DA  763A      
000048DC  2242      13653          move.l    D2,A1
000048DE  2348 004E 13654          move.l    A0,78(A1)
                    13655   ; #endif
                    13656   ; OS_EXIT_CRITICAL();
000048E2  46DF      13657          dc.w      18143
                    13658   ; if (OSRunning == OS_TRUE) {
000048E4  1039 0800 13659          move.b    _OSRunning.L,D0
000048E8  0438      
000048EA  0C00 0001 13660          cmp.b     #1,D0
000048EE  6604      13661          bne.s     OSTaskDel_26
                    13662   ; OS_Sched();                                     /* Find new highest priority task              */
000048F0  4EB8 16B8 13663          jsr       _OS_Sched
                    13664   OSTaskDel_26:
                    13665   ; }
                    13666   ; return (OS_ERR_NONE);
000048F4  4200      13667          clr.b     D0
                    13668   OSTaskDel_3:
000048F6  4CDF 001C 13669          movem.l   (A7)+,D2/D3/D4
000048FA  4E5E      13670          unlk      A6
000048FC  4E75      13671          rts
                    13672   ; }
                    13673   ; #endif
                    13674   ; /*$PAGE*/
                    13675   ; /*
                    13676   ; *********************************************************************************************************
                    13677   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13678   ; *
                    13679   ; * Description: This function is used to:
                    13680   ; *                   a) notify a task to delete itself.
                    13681   ; *                   b) to see if a task requested that the current task delete itself.
                    13682   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13683   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13684   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13685   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13686   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13687   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13688   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13689   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13690   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13691   ; *              this:
                    13692   ; *
                    13693   ; *                   void Task(void *p_arg)
                    13694   ; *                   {
                    13695   ; *                       .
                    13696   ; *                       .
                    13697   ; *                       while (1) {
                    13698   ; *                           OSTimeDly(1);
                    13699   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13700   ; *                               Release any owned resources;
                    13701   ; *                               De-allocate any dynamic memory;
                    13702   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13703   ; *                           }
                    13704   ; *                       }
                    13705   ; *                   }
                    13706   ; *
                    13707   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13708   ; *
                    13709   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13710   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13711   ; *                                     the request has been executed.
                    13712   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13713   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13714   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13715   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13716   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13717   ; *                                     deleted.
                    13718   ; *********************************************************************************************************
                    13719   ; */
                    13720   ; /*$PAGE*/
                    13721   ; #if OS_TASK_DEL_EN > 0u
                    13722   ; INT8U  OSTaskDelReq (INT8U prio)
                    13723   ; {
                    13724   _OSTaskDelReq:
000048FE  4E56 FFFC 13725          link      A6,#-4
00004902  48E7 3000 13726          movem.l   D2/D3,-(A7)
00004906  162E 000B 13727          move.b    11(A6),D3
0000490A  C6BC 0000 13728          and.l     #255,D3
0000490E  00FF      
                    13729   ; INT8U      stat;
                    13730   ; OS_TCB    *ptcb;
                    13731   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13732   ; OS_CPU_SR  cpu_sr = 0u;
                    13733   ; #endif
                    13734   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004910  0C03 003F 13735          cmp.b     #63,D3
00004914  6606      13736          bne.s     OSTaskDelReq_1
                    13737   ; return (OS_ERR_TASK_DEL_IDLE);
00004916  703E      13738          moveq     #62,D0
00004918  6000 0062 13739          bra       OSTaskDelReq_3
                    13740   OSTaskDelReq_1:
                    13741   ; }
                    13742   ; #if OS_ARG_CHK_EN > 0u
                    13743   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13744   ; if (prio != OS_PRIO_SELF) {
                    13745   ; return (OS_ERR_PRIO_INVALID);
                    13746   ; }
                    13747   ; }
                    13748   ; #endif
                    13749   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
0000491C  0C03 00FF 13750          cmp.b     #255,D3
00004920  661C      13751          bne.s     OSTaskDelReq_4
                    13752   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004922  40E7      13753          dc.w      16615
00004924  007C      13754          dc.w      124
00004926  0700      13755          dc.w      1792
                    13756   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
00004928  2079 0800 13757          move.l    _OSTCBCur.L,A0
0000492C  0540      
0000492E  1D68 0039 13758          move.b    57(A0),-1(A6)
00004932  FFFF      
                    13759   ; OS_EXIT_CRITICAL();
00004934  46DF      13760          dc.w      18143
                    13761   ; return (stat);
00004936  102E FFFF 13762          move.b    -1(A6),D0
0000493A  6000 0040 13763          bra       OSTaskDelReq_3
                    13764   OSTaskDelReq_4:
                    13765   ; }
                    13766   ; OS_ENTER_CRITICAL();
0000493E  40E7      13767          dc.w      16615
00004940  007C      13768          dc.w      124
00004942  0700      13769          dc.w      1792
                    13770   ; ptcb = OSTCBPrioTbl[prio];
00004944  C6BC 0000 13771          and.l     #255,D3
00004948  00FF      
0000494A  2003      13772          move.l    D3,D0
0000494C  E588      13773          lsl.l     #2,D0
0000494E  41F9 0800 13774          lea       _OSTCBPrioTbl.L,A0
00004952  0550      
00004954  2430 0800 13775          move.l    0(A0,D0.L),D2
                    13776   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00004958  4A82      13777          tst.l     D2
0000495A  6606      13778          bne.s     OSTaskDelReq_6
                    13779   ; OS_EXIT_CRITICAL();
0000495C  46DF      13780          dc.w      18143
                    13781   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
0000495E  7043      13782          moveq     #67,D0
00004960  601A      13783          bra.s     OSTaskDelReq_3
                    13784   OSTaskDelReq_6:
                    13785   ; }
                    13786   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00004962  0C82 0000 13787          cmp.l     #1,D2
00004966  0001      
00004968  6606      13788          bne.s     OSTaskDelReq_8
                    13789   ; OS_EXIT_CRITICAL();
0000496A  46DF      13790          dc.w      18143
                    13791   ; return (OS_ERR_TASK_DEL);
0000496C  703D      13792          moveq     #61,D0
0000496E  600C      13793          bra.s     OSTaskDelReq_3
                    13794   OSTaskDelReq_8:
                    13795   ; }
                    13796   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00004970  2042      13797          move.l    D2,A0
00004972  117C 003F 13798          move.b    #63,57(A0)
00004976  0039      
                    13799   ; OS_EXIT_CRITICAL();
00004978  46DF      13800          dc.w      18143
                    13801   ; return (OS_ERR_NONE);
0000497A  4200      13802          clr.b     D0
                    13803   OSTaskDelReq_3:
0000497C  4CDF 000C 13804          movem.l   (A7)+,D2/D3
00004980  4E5E      13805          unlk      A6
00004982  4E75      13806          rts
                    13807   ; }
                    13808   ; #endif
                    13809   ; /*$PAGE*/
                    13810   ; /*
                    13811   ; *********************************************************************************************************
                    13812   ; *                                       GET THE NAME OF A TASK
                    13813   ; *
                    13814   ; * Description: This function is called to obtain the name of a task.
                    13815   ; *
                    13816   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    13817   ; *
                    13818   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    13819   ; *
                    13820   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    13821   ; *
                    13822   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13823   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13824   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13825   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13826   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13827   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    13828   ; *
                    13829   ; *
                    13830   ; * Returns    : The length of the string or 0 if the task does not exist.
                    13831   ; *********************************************************************************************************
                    13832   ; */
                    13833   ; #if OS_TASK_NAME_EN > 0u
                    13834   ; INT8U  OSTaskNameGet (INT8U    prio,
                    13835   ; INT8U  **pname,
                    13836   ; INT8U   *perr)
                    13837   ; {
                    13838   _OSTaskNameGet:
00004984  4E56 FFFC 13839          link      A6,#-4
00004988  48E7 3800 13840          movem.l   D2/D3/D4,-(A7)
0000498C  262E 0010 13841          move.l    16(A6),D3
00004990  182E 000B 13842          move.b    11(A6),D4
00004994  C8BC 0000 13843          and.l     #255,D4
00004998  00FF      
                    13844   ; OS_TCB    *ptcb;
                    13845   ; INT8U      len;
                    13846   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    13847   ; OS_CPU_SR  cpu_sr = 0u;
                    13848   ; #endif
                    13849   ; #ifdef OS_SAFETY_CRITICAL
                    13850   ; if (perr == (INT8U *)0) {
                    13851   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13852   ; return (0u);
                    13853   ; }
                    13854   ; #endif
                    13855   ; #if OS_ARG_CHK_EN > 0u
                    13856   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    13857   ; if (prio != OS_PRIO_SELF) {
                    13858   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    13859   ; return (0u);
                    13860   ; }
                    13861   ; }
                    13862   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    13863   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    13864   ; return (0u);
                    13865   ; }
                    13866   ; #endif
                    13867   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
0000499A  1039 0800 13868          move.b    _OSIntNesting.L,D0
0000499E  0426      
000049A0  0C00 0000 13869          cmp.b     #0,D0
000049A4  630C      13870          bls.s     OSTaskNameGet_1
                    13871   ; *perr = OS_ERR_NAME_GET_ISR;
000049A6  2043      13872          move.l    D3,A0
000049A8  10BC 0011 13873          move.b    #17,(A0)
                    13874   ; return (0u);
000049AC  4200      13875          clr.b     D0
000049AE  6000 0076 13876          bra       OSTaskNameGet_3
                    13877   OSTaskNameGet_1:
                    13878   ; }
                    13879   ; OS_ENTER_CRITICAL();
000049B2  40E7      13880          dc.w      16615
000049B4  007C      13881          dc.w      124
000049B6  0700      13882          dc.w      1792
                    13883   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
000049B8  0C04 00FF 13884          cmp.b     #255,D4
000049BC  660A      13885          bne.s     OSTaskNameGet_4
                    13886   ; prio = OSTCBCur->OSTCBPrio;
000049BE  2079 0800 13887          move.l    _OSTCBCur.L,A0
000049C2  0540      
000049C4  1828 0034 13888          move.b    52(A0),D4
                    13889   OSTaskNameGet_4:
                    13890   ; }
                    13891   ; ptcb = OSTCBPrioTbl[prio];
000049C8  C8BC 0000 13892          and.l     #255,D4
000049CC  00FF      
000049CE  2004      13893          move.l    D4,D0
000049D0  E588      13894          lsl.l     #2,D0
000049D2  41F9 0800 13895          lea       _OSTCBPrioTbl.L,A0
000049D6  0550      
000049D8  2430 0800 13896          move.l    0(A0,D0.L),D2
                    13897   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
000049DC  4A82      13898          tst.l     D2
000049DE  660E      13899          bne.s     OSTaskNameGet_6
                    13900   ; OS_EXIT_CRITICAL();                              /* No                                         */
000049E0  46DF      13901          dc.w      18143
                    13902   ; *perr = OS_ERR_TASK_NOT_EXIST;
000049E2  2043      13903          move.l    D3,A0
000049E4  10BC 0043 13904          move.b    #67,(A0)
                    13905   ; return (0u);
000049E8  4200      13906          clr.b     D0
000049EA  6000 003A 13907          bra       OSTaskNameGet_3
                    13908   OSTaskNameGet_6:
                    13909   ; }
                    13910   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
000049EE  0C82 0000 13911          cmp.l     #1,D2
000049F2  0001      
000049F4  660C      13912          bne.s     OSTaskNameGet_8
                    13913   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
000049F6  46DF      13914          dc.w      18143
                    13915   ; *perr = OS_ERR_TASK_NOT_EXIST;
000049F8  2043      13916          move.l    D3,A0
000049FA  10BC 0043 13917          move.b    #67,(A0)
                    13918   ; return (0u);
000049FE  4200      13919          clr.b     D0
00004A00  6024      13920          bra.s     OSTaskNameGet_3
                    13921   OSTaskNameGet_8:
                    13922   ; }
                    13923   ; *pname = ptcb->OSTCBTaskName;
00004A02  2042      13924          move.l    D2,A0
00004A04  226E 000C 13925          move.l    12(A6),A1
00004A08  22A8 004E 13926          move.l    78(A0),(A1)
                    13927   ; len    = OS_StrLen(*pname);
00004A0C  206E 000C 13928          move.l    12(A6),A0
00004A10  2F10      13929          move.l    (A0),-(A7)
00004A12  4EB8 1762 13930          jsr       _OS_StrLen
00004A16  584F      13931          addq.w    #4,A7
00004A18  1D40 FFFF 13932          move.b    D0,-1(A6)
                    13933   ; OS_EXIT_CRITICAL();
00004A1C  46DF      13934          dc.w      18143
                    13935   ; *perr  = OS_ERR_NONE;
00004A1E  2043      13936          move.l    D3,A0
00004A20  4210      13937          clr.b     (A0)
                    13938   ; return (len);
00004A22  102E FFFF 13939          move.b    -1(A6),D0
                    13940   OSTaskNameGet_3:
00004A26  4CDF 001C 13941          movem.l   (A7)+,D2/D3/D4
00004A2A  4E5E      13942          unlk      A6
00004A2C  4E75      13943          rts
                    13944   ; }
                    13945   ; #endif
                    13946   ; /*$PAGE*/
                    13947   ; /*
                    13948   ; *********************************************************************************************************
                    13949   ; *                                       ASSIGN A NAME TO A TASK
                    13950   ; *
                    13951   ; * Description: This function is used to set the name of a task.
                    13952   ; *
                    13953   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    13954   ; *
                    13955   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    13956   ; *
                    13957   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    13958   ; *
                    13959   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13960   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13961   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13962   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13963   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13964   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    13965   ; *
                    13966   ; * Returns    : None
                    13967   ; *********************************************************************************************************
                    13968   ; */
                    13969   ; #if OS_TASK_NAME_EN > 0u
                    13970   ; void  OSTaskNameSet (INT8U   prio,
                    13971   ; INT8U  *pname,
                    13972   ; INT8U  *perr)
                    13973   ; {
                    13974   _OSTaskNameSet:
00004A2E  4E56 0000 13975          link      A6,#0
00004A32  48E7 3800 13976          movem.l   D2/D3/D4,-(A7)
00004A36  262E 0010 13977          move.l    16(A6),D3
00004A3A  182E 000B 13978          move.b    11(A6),D4
00004A3E  C8BC 0000 13979          and.l     #255,D4
00004A42  00FF      
                    13980   ; OS_TCB    *ptcb;
                    13981   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    13982   ; OS_CPU_SR  cpu_sr = 0u;
                    13983   ; #endif
                    13984   ; #ifdef OS_SAFETY_CRITICAL
                    13985   ; if (perr == (INT8U *)0) {
                    13986   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13987   ; return;
                    13988   ; }
                    13989   ; #endif
                    13990   ; #if OS_ARG_CHK_EN > 0u
                    13991   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    13992   ; if (prio != OS_PRIO_SELF) {
                    13993   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    13994   ; return;
                    13995   ; }
                    13996   ; }
                    13997   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    13998   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    13999   ; return;
                    14000   ; }
                    14001   ; #endif
                    14002   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004A44  1039 0800 14003          move.b    _OSIntNesting.L,D0
00004A48  0426      
00004A4A  0C00 0000 14004          cmp.b     #0,D0
00004A4E  630A      14005          bls.s     OSTaskNameSet_1
                    14006   ; *perr = OS_ERR_NAME_SET_ISR;
00004A50  2043      14007          move.l    D3,A0
00004A52  10BC 0012 14008          move.b    #18,(A0)
                    14009   ; return;
00004A56  6000 005A 14010          bra       OSTaskNameSet_3
                    14011   OSTaskNameSet_1:
                    14012   ; }
                    14013   ; OS_ENTER_CRITICAL();
00004A5A  40E7      14014          dc.w      16615
00004A5C  007C      14015          dc.w      124
00004A5E  0700      14016          dc.w      1792
                    14017   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
00004A60  0C04 00FF 14018          cmp.b     #255,D4
00004A64  660A      14019          bne.s     OSTaskNameSet_4
                    14020   ; prio = OSTCBCur->OSTCBPrio;
00004A66  2079 0800 14021          move.l    _OSTCBCur.L,A0
00004A6A  0540      
00004A6C  1828 0034 14022          move.b    52(A0),D4
                    14023   OSTaskNameSet_4:
                    14024   ; }
                    14025   ; ptcb = OSTCBPrioTbl[prio];
00004A70  C8BC 0000 14026          and.l     #255,D4
00004A74  00FF      
00004A76  2004      14027          move.l    D4,D0
00004A78  E588      14028          lsl.l     #2,D0
00004A7A  41F9 0800 14029          lea       _OSTCBPrioTbl.L,A0
00004A7E  0550      
00004A80  2430 0800 14030          move.l    0(A0,D0.L),D2
                    14031   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
00004A84  4A82      14032          tst.l     D2
00004A86  660A      14033          bne.s     OSTaskNameSet_6
                    14034   ; OS_EXIT_CRITICAL();                          /* No                                             */
00004A88  46DF      14035          dc.w      18143
                    14036   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004A8A  2043      14037          move.l    D3,A0
00004A8C  10BC 0043 14038          move.b    #67,(A0)
                    14039   ; return;
00004A90  6020      14040          bra.s     OSTaskNameSet_3
                    14041   OSTaskNameSet_6:
                    14042   ; }
                    14043   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
00004A92  0C82 0000 14044          cmp.l     #1,D2
00004A96  0001      
00004A98  660A      14045          bne.s     OSTaskNameSet_8
                    14046   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
00004A9A  46DF      14047          dc.w      18143
                    14048   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004A9C  2043      14049          move.l    D3,A0
00004A9E  10BC 0043 14050          move.b    #67,(A0)
                    14051   ; return;
00004AA2  600E      14052          bra.s     OSTaskNameSet_3
                    14053   OSTaskNameSet_8:
                    14054   ; }
                    14055   ; ptcb->OSTCBTaskName = pname;
00004AA4  2042      14056          move.l    D2,A0
00004AA6  216E 000C 14057          move.l    12(A6),78(A0)
00004AAA  004E      
                    14058   ; OS_EXIT_CRITICAL();
00004AAC  46DF      14059          dc.w      18143
                    14060   ; *perr               = OS_ERR_NONE;
00004AAE  2043      14061          move.l    D3,A0
00004AB0  4210      14062          clr.b     (A0)
                    14063   OSTaskNameSet_3:
00004AB2  4CDF 001C 14064          movem.l   (A7)+,D2/D3/D4
00004AB6  4E5E      14065          unlk      A6
00004AB8  4E75      14066          rts
                    14067   ; }
                    14068   ; #endif
                    14069   ; /*$PAGE*/
                    14070   ; /*
                    14071   ; *********************************************************************************************************
                    14072   ; *                                       RESUME A SUSPENDED TASK
                    14073   ; *
                    14074   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    14075   ; *              will remove an explicit task suspension.
                    14076   ; *
                    14077   ; * Arguments  : prio     is the priority of the task to resume.
                    14078   ; *
                    14079   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    14080   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    14081   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    14082   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    14083   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    14084   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    14085   ; *********************************************************************************************************
                    14086   ; */
                    14087   ; #if OS_TASK_SUSPEND_EN > 0u
                    14088   ; INT8U  OSTaskResume (INT8U prio)
                    14089   ; {
                    14090   _OSTaskResume:
00004ABA  4E56 0000 14091          link      A6,#0
00004ABE  2F02      14092          move.l    D2,-(A7)
                    14093   ; OS_TCB    *ptcb;
                    14094   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    14095   ; OS_CPU_SR  cpu_sr = 0u;
                    14096   ; #endif
                    14097   ; #if OS_ARG_CHK_EN > 0u
                    14098   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    14099   ; return (OS_ERR_PRIO_INVALID);
                    14100   ; }
                    14101   ; #endif
                    14102   ; OS_ENTER_CRITICAL();
00004AC0  40E7      14103          dc.w      16615
00004AC2  007C      14104          dc.w      124
00004AC4  0700      14105          dc.w      1792
                    14106   ; ptcb = OSTCBPrioTbl[prio];
00004AC6  102E 000B 14107          move.b    11(A6),D0
00004ACA  C0BC 0000 14108          and.l     #255,D0
00004ACE  00FF      
00004AD0  E588      14109          lsl.l     #2,D0
00004AD2  41F9 0800 14110          lea       _OSTCBPrioTbl.L,A0
00004AD6  0550      
00004AD8  2430 0800 14111          move.l    0(A0,D0.L),D2
                    14112   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
00004ADC  4A82      14113          tst.l     D2
00004ADE  6608      14114          bne.s     OSTaskResume_1
                    14115   ; OS_EXIT_CRITICAL();
00004AE0  46DF      14116          dc.w      18143
                    14117   ; return (OS_ERR_TASK_RESUME_PRIO);
00004AE2  7046      14118          moveq     #70,D0
00004AE4  6000 0088 14119          bra       OSTaskResume_3
                    14120   OSTaskResume_1:
                    14121   ; }
                    14122   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004AE8  0C82 0000 14123          cmp.l     #1,D2
00004AEC  0001      
00004AEE  6608      14124          bne.s     OSTaskResume_4
                    14125   ; OS_EXIT_CRITICAL();
00004AF0  46DF      14126          dc.w      18143
                    14127   ; return (OS_ERR_TASK_NOT_EXIST);
00004AF2  7043      14128          moveq     #67,D0
00004AF4  6000 0078 14129          bra       OSTaskResume_3
                    14130   OSTaskResume_4:
                    14131   ; }
                    14132   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004AF8  2042      14133          move.l    D2,A0
00004AFA  1028 0032 14134          move.b    50(A0),D0
00004AFE  C03C 0008 14135          and.b     #8,D0
00004B02  6700 0066 14136          beq       OSTaskResume_6
                    14137   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004B06  2042      14138          move.l    D2,A0
00004B08  7008      14139          moveq     #8,D0
00004B0A  4600      14140          not.b     D0
00004B0C  C128 0032 14141          and.b     D0,50(A0)
                    14142   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004B10  2042      14143          move.l    D2,A0
00004B12  1028 0032 14144          move.b    50(A0),D0
00004B16  6600 004C 14145          bne       OSTaskResume_8
                    14146   ; if (ptcb->OSTCBDly == 0u) {
00004B1A  2042      14147          move.l    D2,A0
00004B1C  2028 002E 14148          move.l    46(A0),D0
00004B20  6600 003E 14149          bne       OSTaskResume_10
                    14150   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004B24  2042      14151          move.l    D2,A0
00004B26  1028 0038 14152          move.b    56(A0),D0
00004B2A  8139 0800 14153          or.b      D0,_OSRdyGrp.L
00004B2E  042E      
                    14154   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004B30  2042      14155          move.l    D2,A0
00004B32  1028 0036 14156          move.b    54(A0),D0
00004B36  C0BC 0000 14157          and.l     #255,D0
00004B3A  00FF      
00004B3C  41F9 0800 14158          lea       _OSRdyTbl.L,A0
00004B40  0430      
00004B42  2242      14159          move.l    D2,A1
00004B44  1229 0037 14160          move.b    55(A1),D1
00004B48  8330 0800 14161          or.b      D1,0(A0,D0.L)
                    14162   ; OS_EXIT_CRITICAL();
00004B4C  46DF      14163          dc.w      18143
                    14164   ; if (OSRunning == OS_TRUE) {
00004B4E  1039 0800 14165          move.b    _OSRunning.L,D0
00004B52  0438      
00004B54  0C00 0001 14166          cmp.b     #1,D0
00004B58  6604      14167          bne.s     OSTaskResume_12
                    14168   ; OS_Sched();                               /* Find new highest priority task        */
00004B5A  4EB8 16B8 14169          jsr       _OS_Sched
                    14170   OSTaskResume_12:
00004B5E  6002      14171          bra.s     OSTaskResume_11
                    14172   OSTaskResume_10:
                    14173   ; }
                    14174   ; } else {
                    14175   ; OS_EXIT_CRITICAL();
00004B60  46DF      14176          dc.w      18143
                    14177   OSTaskResume_11:
00004B62  6002      14178          bra.s     OSTaskResume_9
                    14179   OSTaskResume_8:
                    14180   ; }
                    14181   ; } else {                                              /* Must be pending on event              */
                    14182   ; OS_EXIT_CRITICAL();
00004B64  46DF      14183          dc.w      18143
                    14184   OSTaskResume_9:
                    14185   ; }
                    14186   ; return (OS_ERR_NONE);
00004B66  4200      14187          clr.b     D0
00004B68  6004      14188          bra.s     OSTaskResume_3
                    14189   OSTaskResume_6:
                    14190   ; }
                    14191   ; OS_EXIT_CRITICAL();
00004B6A  46DF      14192          dc.w      18143
                    14193   ; return (OS_ERR_TASK_NOT_SUSPENDED);
00004B6C  7044      14194          moveq     #68,D0
                    14195   OSTaskResume_3:
00004B6E  241F      14196          move.l    (A7)+,D2
00004B70  4E5E      14197          unlk      A6
00004B72  4E75      14198          rts
                    14199   ; }
                    14200   ; #endif
                    14201   ; /*$PAGE*/
                    14202   ; /*
                    14203   ; *********************************************************************************************************
                    14204   ; *                                           STACK CHECKING
                    14205   ; *
                    14206   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14207   ; *              stack.
                    14208   ; *
                    14209   ; * Arguments  : prio          is the task priority
                    14210   ; *
                    14211   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14212   ; *
                    14213   ; * Returns    : OS_ERR_NONE            upon success
                    14214   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14215   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14216   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14217   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14218   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14219   ; *********************************************************************************************************
                    14220   ; */
                    14221   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14222   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14223   ; OS_STK_DATA  *p_stk_data)
                    14224   ; {
                    14225   _OSTaskStkChk:
00004B74  4E56 FFF8 14226          link      A6,#-8
00004B78  48E7 3C00 14227          movem.l   D2/D3/D4/D5,-(A7)
00004B7C  282E 000C 14228          move.l    12(A6),D4
00004B80  1A2E 000B 14229          move.b    11(A6),D5
00004B84  CABC 0000 14230          and.l     #255,D5
00004B88  00FF      
                    14231   ; OS_TCB    *ptcb;
                    14232   ; OS_STK    *pchk;
                    14233   ; INT32U     nfree;
                    14234   ; INT32U     size;
                    14235   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14236   ; OS_CPU_SR  cpu_sr = 0u;
                    14237   ; #endif
                    14238   ; #if OS_ARG_CHK_EN > 0u
                    14239   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14240   ; if (prio != OS_PRIO_SELF) {
                    14241   ; return (OS_ERR_PRIO_INVALID);
                    14242   ; }
                    14243   ; }
                    14244   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14245   ; return (OS_ERR_PDATA_NULL);
                    14246   ; }
                    14247   ; #endif
                    14248   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00004B8A  2044      14249          move.l    D4,A0
00004B8C  4290      14250          clr.l     (A0)
                    14251   ; p_stk_data->OSUsed = 0u;
00004B8E  2044      14252          move.l    D4,A0
00004B90  42A8 0004 14253          clr.l     4(A0)
                    14254   ; OS_ENTER_CRITICAL();
00004B94  40E7      14255          dc.w      16615
00004B96  007C      14256          dc.w      124
00004B98  0700      14257          dc.w      1792
                    14258   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
00004B9A  0C05 00FF 14259          cmp.b     #255,D5
00004B9E  660A      14260          bne.s     OSTaskStkChk_1
                    14261   ; prio = OSTCBCur->OSTCBPrio;
00004BA0  2079 0800 14262          move.l    _OSTCBCur.L,A0
00004BA4  0540      
00004BA6  1A28 0034 14263          move.b    52(A0),D5
                    14264   OSTaskStkChk_1:
                    14265   ; }
                    14266   ; ptcb = OSTCBPrioTbl[prio];
00004BAA  CABC 0000 14267          and.l     #255,D5
00004BAE  00FF      
00004BB0  2005      14268          move.l    D5,D0
00004BB2  E588      14269          lsl.l     #2,D0
00004BB4  41F9 0800 14270          lea       _OSTCBPrioTbl.L,A0
00004BB8  0550      
00004BBA  2430 0800 14271          move.l    0(A0,D0.L),D2
                    14272   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00004BBE  4A82      14273          tst.l     D2
00004BC0  6608      14274          bne.s     OSTaskStkChk_3
                    14275   ; OS_EXIT_CRITICAL();
00004BC2  46DF      14276          dc.w      18143
                    14277   ; return (OS_ERR_TASK_NOT_EXIST);
00004BC4  7043      14278          moveq     #67,D0
00004BC6  6000 005C 14279          bra       OSTaskStkChk_5
                    14280   OSTaskStkChk_3:
                    14281   ; }
                    14282   ; if (ptcb == OS_TCB_RESERVED) {
00004BCA  0C82 0000 14283          cmp.l     #1,D2
00004BCE  0001      
00004BD0  6608      14284          bne.s     OSTaskStkChk_6
                    14285   ; OS_EXIT_CRITICAL();
00004BD2  46DF      14286          dc.w      18143
                    14287   ; return (OS_ERR_TASK_NOT_EXIST);
00004BD4  7043      14288          moveq     #67,D0
00004BD6  6000 004C 14289          bra       OSTaskStkChk_5
                    14290   OSTaskStkChk_6:
                    14291   ; }
                    14292   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
00004BDA  2042      14293          move.l    D2,A0
00004BDC  3028 0010 14294          move.w    16(A0),D0
00004BE0  C07C 0001 14295          and.w     #1,D0
00004BE4  6608      14296          bne.s     OSTaskStkChk_8
                    14297   ; OS_EXIT_CRITICAL();
00004BE6  46DF      14298          dc.w      18143
                    14299   ; return (OS_ERR_TASK_OPT);
00004BE8  7045      14300          moveq     #69,D0
00004BEA  6000 0038 14301          bra       OSTaskStkChk_5
                    14302   OSTaskStkChk_8:
                    14303   ; }
                    14304   ; nfree = 0u;
00004BEE  4283      14305          clr.l     D3
                    14306   ; size  = ptcb->OSTCBStkSize;
00004BF0  2042      14307          move.l    D2,A0
00004BF2  2D68 000C 14308          move.l    12(A0),-4(A6)
00004BF6  FFFC      
                    14309   ; pchk  = ptcb->OSTCBStkBottom;
00004BF8  2042      14310          move.l    D2,A0
00004BFA  2D68 0008 14311          move.l    8(A0),-8(A6)
00004BFE  FFF8      
                    14312   ; OS_EXIT_CRITICAL();
00004C00  46DF      14313          dc.w      18143
                    14314   ; #if OS_STK_GROWTH == 1u
                    14315   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14316   OSTaskStkChk_10:
00004C02  206E FFF8 14317          move.l    -8(A6),A0
00004C06  54AE FFF8 14318          addq.l    #2,-8(A6)
00004C0A  3010      14319          move.w    (A0),D0
00004C0C  6604      14320          bne.s     OSTaskStkChk_12
                    14321   ; nfree++;
00004C0E  5283      14322          addq.l    #1,D3
00004C10  60F0      14323          bra       OSTaskStkChk_10
                    14324   OSTaskStkChk_12:
                    14325   ; }
                    14326   ; #else
                    14327   ; while (*pchk-- == (OS_STK)0) {
                    14328   ; nfree++;
                    14329   ; }
                    14330   ; #endif
                    14331   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004C12  2044      14332          move.l    D4,A0
00004C14  2083      14333          move.l    D3,(A0)
                    14334   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004C16  202E FFFC 14335          move.l    -4(A6),D0
00004C1A  9083      14336          sub.l     D3,D0
00004C1C  2044      14337          move.l    D4,A0
00004C1E  2140 0004 14338          move.l    D0,4(A0)
                    14339   ; return (OS_ERR_NONE);
00004C22  4200      14340          clr.b     D0
                    14341   OSTaskStkChk_5:
00004C24  4CDF 003C 14342          movem.l   (A7)+,D2/D3/D4/D5
00004C28  4E5E      14343          unlk      A6
00004C2A  4E75      14344          rts
                    14345   ; }
                    14346   ; #endif
                    14347   ; /*$PAGE*/
                    14348   ; /*
                    14349   ; *********************************************************************************************************
                    14350   ; *                                           SUSPEND A TASK
                    14351   ; *
                    14352   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14353   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14354   ; *
                    14355   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14356   ; *                       calling task will suspend itself and rescheduling will occur.
                    14357   ; *
                    14358   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14359   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14360   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14361   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14362   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14363   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14364   ; *
                    14365   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14366   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14367   ; *              running when the event arrives.
                    14368   ; *********************************************************************************************************
                    14369   ; */
                    14370   ; #if OS_TASK_SUSPEND_EN > 0u
                    14371   ; INT8U  OSTaskSuspend (INT8U prio)
                    14372   ; {
                    14373   _OSTaskSuspend:
00004C2C  4E56 0000 14374          link      A6,#0
00004C30  48E7 3C00 14375          movem.l   D2/D3/D4/D5,-(A7)
00004C34  182E 000B 14376          move.b    11(A6),D4
00004C38  C8BC 0000 14377          and.l     #255,D4
00004C3C  00FF      
                    14378   ; BOOLEAN    self;
                    14379   ; OS_TCB    *ptcb;
                    14380   ; INT8U      y;
                    14381   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14382   ; OS_CPU_SR  cpu_sr = 0u;
                    14383   ; #endif
                    14384   ; #if OS_ARG_CHK_EN > 0u
                    14385   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14386   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14387   ; }
                    14388   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14389   ; if (prio != OS_PRIO_SELF) {
                    14390   ; return (OS_ERR_PRIO_INVALID);
                    14391   ; }
                    14392   ; }
                    14393   ; #endif
                    14394   ; OS_ENTER_CRITICAL();
00004C3E  40E7      14395          dc.w      16615
00004C40  007C      14396          dc.w      124
00004C42  0700      14397          dc.w      1792
                    14398   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004C44  0C04 00FF 14399          cmp.b     #255,D4
00004C48  660E      14400          bne.s     OSTaskSuspend_1
                    14401   ; prio = OSTCBCur->OSTCBPrio;
00004C4A  2079 0800 14402          move.l    _OSTCBCur.L,A0
00004C4E  0540      
00004C50  1828 0034 14403          move.b    52(A0),D4
                    14404   ; self = OS_TRUE;
00004C54  7601      14405          moveq     #1,D3
00004C56  6012      14406          bra.s     OSTaskSuspend_4
                    14407   OSTaskSuspend_1:
                    14408   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004C58  2079 0800 14409          move.l    _OSTCBCur.L,A0
00004C5C  0540      
00004C5E  B828 0034 14410          cmp.b     52(A0),D4
00004C62  6604      14411          bne.s     OSTaskSuspend_3
                    14412   ; self = OS_TRUE;
00004C64  7601      14413          moveq     #1,D3
00004C66  6002      14414          bra.s     OSTaskSuspend_4
                    14415   OSTaskSuspend_3:
                    14416   ; } else {
                    14417   ; self = OS_FALSE;                                        /* No suspending another task          */
00004C68  4203      14418          clr.b     D3
                    14419   OSTaskSuspend_4:
                    14420   ; }
                    14421   ; ptcb = OSTCBPrioTbl[prio];
00004C6A  C8BC 0000 14422          and.l     #255,D4
00004C6E  00FF      
00004C70  2004      14423          move.l    D4,D0
00004C72  E588      14424          lsl.l     #2,D0
00004C74  41F9 0800 14425          lea       _OSTCBPrioTbl.L,A0
00004C78  0550      
00004C7A  2430 0800 14426          move.l    0(A0,D0.L),D2
                    14427   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00004C7E  4A82      14428          tst.l     D2
00004C80  6608      14429          bne.s     OSTaskSuspend_5
                    14430   ; OS_EXIT_CRITICAL();
00004C82  46DF      14431          dc.w      18143
                    14432   ; return (OS_ERR_TASK_SUSPEND_PRIO);
00004C84  7048      14433          moveq     #72,D0
00004C86  6000 0066 14434          bra       OSTaskSuspend_7
                    14435   OSTaskSuspend_5:
                    14436   ; }
                    14437   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
00004C8A  0C82 0000 14438          cmp.l     #1,D2
00004C8E  0001      
00004C90  6608      14439          bne.s     OSTaskSuspend_8
                    14440   ; OS_EXIT_CRITICAL();
00004C92  46DF      14441          dc.w      18143
                    14442   ; return (OS_ERR_TASK_NOT_EXIST);
00004C94  7043      14443          moveq     #67,D0
00004C96  6000 0056 14444          bra       OSTaskSuspend_7
                    14445   OSTaskSuspend_8:
                    14446   ; }
                    14447   ; y            = ptcb->OSTCBY;
00004C9A  2042      14448          move.l    D2,A0
00004C9C  1A28 0036 14449          move.b    54(A0),D5
                    14450   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
00004CA0  CABC 0000 14451          and.l     #255,D5
00004CA4  00FF      
00004CA6  41F9 0800 14452          lea       _OSRdyTbl.L,A0
00004CAA  0430      
00004CAC  2242      14453          move.l    D2,A1
00004CAE  1029 0037 14454          move.b    55(A1),D0
00004CB2  4600      14455          not.b     D0
00004CB4  C130 5800 14456          and.b     D0,0(A0,D5.L)
                    14457   ; if (OSRdyTbl[y] == 0u) {
00004CB8  CABC 0000 14458          and.l     #255,D5
00004CBC  00FF      
00004CBE  41F9 0800 14459          lea       _OSRdyTbl.L,A0
00004CC2  0430      
00004CC4  1030 5800 14460          move.b    0(A0,D5.L),D0
00004CC8  660E      14461          bne.s     OSTaskSuspend_10
                    14462   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00004CCA  2042      14463          move.l    D2,A0
00004CCC  1028 0038 14464          move.b    56(A0),D0
00004CD0  4600      14465          not.b     D0
00004CD2  C139 0800 14466          and.b     D0,_OSRdyGrp.L
00004CD6  042E      
                    14467   OSTaskSuspend_10:
                    14468   ; }
                    14469   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00004CD8  2042      14470          move.l    D2,A0
00004CDA  0028 0008 14471          or.b      #8,50(A0)
00004CDE  0032      
                    14472   ; OS_EXIT_CRITICAL();
00004CE0  46DF      14473          dc.w      18143
                    14474   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
00004CE2  0C03 0001 14475          cmp.b     #1,D3
00004CE6  6604      14476          bne.s     OSTaskSuspend_12
                    14477   ; OS_Sched();                                             /* Find new highest priority task      */
00004CE8  4EB8 16B8 14478          jsr       _OS_Sched
                    14479   OSTaskSuspend_12:
                    14480   ; }
                    14481   ; return (OS_ERR_NONE);
00004CEC  4200      14482          clr.b     D0
                    14483   OSTaskSuspend_7:
00004CEE  4CDF 003C 14484          movem.l   (A7)+,D2/D3/D4/D5
00004CF2  4E5E      14485          unlk      A6
00004CF4  4E75      14486          rts
                    14487   ; }
                    14488   ; #endif
                    14489   ; /*$PAGE*/
                    14490   ; /*
                    14491   ; *********************************************************************************************************
                    14492   ; *                                            QUERY A TASK
                    14493   ; *
                    14494   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14495   ; *
                    14496   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14497   ; *
                    14498   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14499   ; *
                    14500   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14501   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14502   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14503   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14504   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14505   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14506   ; *********************************************************************************************************
                    14507   ; */
                    14508   ; #if OS_TASK_QUERY_EN > 0u
                    14509   ; INT8U  OSTaskQuery (INT8U    prio,
                    14510   ; OS_TCB  *p_task_data)
                    14511   ; {
                    14512   _OSTaskQuery:
00004CF6  4E56 0000 14513          link      A6,#0
00004CFA  48E7 3000 14514          movem.l   D2/D3,-(A7)
00004CFE  162E 000B 14515          move.b    11(A6),D3
00004D02  C6BC 0000 14516          and.l     #255,D3
00004D06  00FF      
                    14517   ; OS_TCB    *ptcb;
                    14518   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14519   ; OS_CPU_SR  cpu_sr = 0u;
                    14520   ; #endif
                    14521   ; #if OS_ARG_CHK_EN > 0u
                    14522   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14523   ; if (prio != OS_PRIO_SELF) {
                    14524   ; return (OS_ERR_PRIO_INVALID);
                    14525   ; }
                    14526   ; }
                    14527   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14528   ; return (OS_ERR_PDATA_NULL);
                    14529   ; }
                    14530   ; #endif
                    14531   ; OS_ENTER_CRITICAL();
00004D08  40E7      14532          dc.w      16615
00004D0A  007C      14533          dc.w      124
00004D0C  0700      14534          dc.w      1792
                    14535   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00004D0E  0C03 00FF 14536          cmp.b     #255,D3
00004D12  660A      14537          bne.s     OSTaskQuery_1
                    14538   ; prio = OSTCBCur->OSTCBPrio;
00004D14  2079 0800 14539          move.l    _OSTCBCur.L,A0
00004D18  0540      
00004D1A  1628 0034 14540          move.b    52(A0),D3
                    14541   OSTaskQuery_1:
                    14542   ; }
                    14543   ; ptcb = OSTCBPrioTbl[prio];
00004D1E  C6BC 0000 14544          and.l     #255,D3
00004D22  00FF      
00004D24  2003      14545          move.l    D3,D0
00004D26  E588      14546          lsl.l     #2,D0
00004D28  41F9 0800 14547          lea       _OSTCBPrioTbl.L,A0
00004D2C  0550      
00004D2E  2430 0800 14548          move.l    0(A0,D0.L),D2
                    14549   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00004D32  4A82      14550          tst.l     D2
00004D34  6606      14551          bne.s     OSTaskQuery_3
                    14552   ; OS_EXIT_CRITICAL();
00004D36  46DF      14553          dc.w      18143
                    14554   ; return (OS_ERR_PRIO);
00004D38  7029      14555          moveq     #41,D0
00004D3A  6024      14556          bra.s     OSTaskQuery_5
                    14557   OSTaskQuery_3:
                    14558   ; }
                    14559   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
00004D3C  0C82 0000 14560          cmp.l     #1,D2
00004D40  0001      
00004D42  6606      14561          bne.s     OSTaskQuery_6
                    14562   ; OS_EXIT_CRITICAL();
00004D44  46DF      14563          dc.w      18143
                    14564   ; return (OS_ERR_TASK_NOT_EXIST);
00004D46  7043      14565          moveq     #67,D0
00004D48  6016      14566          bra.s     OSTaskQuery_5
                    14567   OSTaskQuery_6:
                    14568   ; }
                    14569   ; /* Copy TCB into user storage area                    */
                    14570   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
00004D4A  4878 0056 14571          pea       86
00004D4E  2F02      14572          move.l    D2,-(A7)
00004D50  2F2E 000C 14573          move.l    12(A6),-(A7)
00004D54  4EB8 168E 14574          jsr       _OS_MemCopy
00004D58  DEFC 000C 14575          add.w     #12,A7
                    14576   ; OS_EXIT_CRITICAL();
00004D5C  46DF      14577          dc.w      18143
                    14578   ; return (OS_ERR_NONE);
00004D5E  4200      14579          clr.b     D0
                    14580   OSTaskQuery_5:
00004D60  4CDF 000C 14581          movem.l   (A7)+,D2/D3
00004D64  4E5E      14582          unlk      A6
00004D66  4E75      14583          rts
                    14584   ; }
                    14585   ; #endif
                    14586   ; /*$PAGE*/
                    14587   ; /*
                    14588   ; *********************************************************************************************************
                    14589   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14590   ; *
                    14591   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14592   ; *              are application specific and can be used to store task specific values such as 'error
                    14593   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14594   ; *
                    14595   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14596   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14597   ; *
                    14598   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14599   ; *                        than OS_TASK_REG_TBL_SIZE
                    14600   ; *
                    14601   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14602   ; *
                    14603   ; *                        OS_ERR_NONE            if the call was successful
                    14604   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14605   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14606   ; *
                    14607   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14608   ; *
                    14609   ; * Note(s)    : The maximum number of task variables is 254
                    14610   ; *********************************************************************************************************
                    14611   ; */
                    14612   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14613   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14614   ; INT8U   id,
                    14615   ; INT8U  *perr)
                    14616   ; {
                    14617   _OSTaskRegGet:
00004D68  4E56 FFFC 14618          link      A6,#-4
00004D6C  2F02      14619          move.l    D2,-(A7)
                    14620   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14621   ; OS_CPU_SR  cpu_sr = 0u;
                    14622   ; #endif
                    14623   ; INT32U     value;
                    14624   ; OS_TCB    *ptcb;
                    14625   ; #ifdef OS_SAFETY_CRITICAL
                    14626   ; if (perr == (INT8U *)0) {
                    14627   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14628   ; return (0u);
                    14629   ; }
                    14630   ; #endif
                    14631   ; #if OS_ARG_CHK_EN > 0u
                    14632   ; if (prio >= OS_LOWEST_PRIO) {
                    14633   ; if (prio != OS_PRIO_SELF) {
                    14634   ; *perr = OS_ERR_PRIO_INVALID;
                    14635   ; return (0u);
                    14636   ; }
                    14637   ; }
                    14638   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14639   ; *perr = OS_ERR_ID_INVALID;
                    14640   ; return (0u);
                    14641   ; }
                    14642   ; #endif
                    14643   ; OS_ENTER_CRITICAL();
00004D6E  40E7      14644          dc.w      16615
00004D70  007C      14645          dc.w      124
00004D72  0700      14646          dc.w      1792
                    14647   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004D74  102E 000B 14648          move.b    11(A6),D0
00004D78  0C00 00FF 14649          cmp.b     #255,D0
00004D7C  6608      14650          bne.s     OSTaskRegGet_1
                    14651   ; ptcb = OSTCBCur;
00004D7E  2439 0800 14652          move.l    _OSTCBCur.L,D2
00004D82  0540      
00004D84  6016      14653          bra.s     OSTaskRegGet_2
                    14654   OSTaskRegGet_1:
                    14655   ; } else {
                    14656   ; ptcb = OSTCBPrioTbl[prio];
00004D86  102E 000B 14657          move.b    11(A6),D0
00004D8A  C0BC 0000 14658          and.l     #255,D0
00004D8E  00FF      
00004D90  E588      14659          lsl.l     #2,D0
00004D92  41F9 0800 14660          lea       _OSTCBPrioTbl.L,A0
00004D96  0550      
00004D98  2430 0800 14661          move.l    0(A0,D0.L),D2
                    14662   OSTaskRegGet_2:
                    14663   ; }
                    14664   ; value = ptcb->OSTCBRegTbl[id];
00004D9C  2042      14665          move.l    D2,A0
00004D9E  102E 000F 14666          move.b    15(A6),D0
00004DA2  C0BC 0000 14667          and.l     #255,D0
00004DA6  00FF      
00004DA8  E588      14668          lsl.l     #2,D0
00004DAA  D1C0      14669          add.l     D0,A0
00004DAC  2D68 0052 14670          move.l    82(A0),-4(A6)
00004DB0  FFFC      
                    14671   ; OS_EXIT_CRITICAL();
00004DB2  46DF      14672          dc.w      18143
                    14673   ; *perr = OS_ERR_NONE;
00004DB4  206E 0010 14674          move.l    16(A6),A0
00004DB8  4210      14675          clr.b     (A0)
                    14676   ; return (value);
00004DBA  202E FFFC 14677          move.l    -4(A6),D0
00004DBE  241F      14678          move.l    (A7)+,D2
00004DC0  4E5E      14679          unlk      A6
00004DC2  4E75      14680          rts
                    14681   ; }
                    14682   ; #endif
                    14683   ; /*$PAGE*/
                    14684   ; /*
                    14685   ; ************************************************************************************************************************
                    14686   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14687   ; *
                    14688   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14689   ; *              allocated dynamically instead of statically.
                    14690   ; *
                    14691   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14692   ; *
                    14693   ; *                            OS_ERR_NONE               if the call was successful
                    14694   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14695   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14696   ; *
                    14697   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14698   ; ************************************************************************************************************************
                    14699   ; */
                    14700   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14701   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14702   ; {
                    14703   _OSTaskRegGetID:
00004DC4  4E56 FFFC 14704          link      A6,#-4
                    14705   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14706   ; OS_CPU_SR  cpu_sr = 0u;
                    14707   ; #endif
                    14708   ; INT8U      id;
                    14709   ; #ifdef OS_SAFETY_CRITICAL
                    14710   ; if (perr == (INT8U *)0) {
                    14711   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14712   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14713   ; }
                    14714   ; #endif
                    14715   ; OS_ENTER_CRITICAL();
00004DC8  40E7      14716          dc.w      16615
00004DCA  007C      14717          dc.w      124
00004DCC  0700      14718          dc.w      1792
                    14719   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00004DCE  1039 0800 14720          move.b    _OSTaskRegNextAvailID.L,D0
00004DD2  0E94      
00004DD4  0C00 0001 14721          cmp.b     #1,D0
00004DD8  650E      14722          blo.s     OSTaskRegGetID_1
                    14723   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00004DDA  206E 0008 14724          move.l    8(A6),A0
00004DDE  10BC 0096 14725          move.b    #150,(A0)
                    14726   ; OS_EXIT_CRITICAL();
00004DE2  46DF      14727          dc.w      18143
                    14728   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
00004DE4  7001      14729          moveq     #1,D0
00004DE6  601A      14730          bra.s     OSTaskRegGetID_3
                    14731   OSTaskRegGetID_1:
                    14732   ; }
                    14733   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
00004DE8  1D79 0800 14734          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00004DEC  0E94 FFFF 
                    14735   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
00004DF0  5239 0800 14736          addq.b    #1,_OSTaskRegNextAvailID.L
00004DF4  0E94      
                    14737   ; OS_EXIT_CRITICAL();
00004DF6  46DF      14738          dc.w      18143
                    14739   ; *perr = OS_ERR_NONE;
00004DF8  206E 0008 14740          move.l    8(A6),A0
00004DFC  4210      14741          clr.b     (A0)
                    14742   ; return (id);
00004DFE  102E FFFF 14743          move.b    -1(A6),D0
                    14744   OSTaskRegGetID_3:
00004E02  4E5E      14745          unlk      A6
00004E04  4E75      14746          rts
                    14747   ; }
                    14748   ; #endif
                    14749   ; /*$PAGE*/
                    14750   ; /*
                    14751   ; *********************************************************************************************************
                    14752   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14753   ; *
                    14754   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14755   ; *              are application specific and can be used to store task specific values such as 'error
                    14756   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14757   ; *
                    14758   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14759   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14760   ; *
                    14761   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14762   ; *                        than OS_TASK_REG_TBL_SIZE
                    14763   ; *
                    14764   ; *              value     is the desired value for the task register.
                    14765   ; *
                    14766   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14767   ; *
                    14768   ; *                        OS_ERR_NONE            if the call was successful
                    14769   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14770   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14771   ; *
                    14772   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    14773   ; *
                    14774   ; * Note(s)    : The maximum number of task variables is 254
                    14775   ; *********************************************************************************************************
                    14776   ; */
                    14777   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14778   ; void  OSTaskRegSet (INT8U    prio,
                    14779   ; INT8U    id,
                    14780   ; INT32U   value,
                    14781   ; INT8U   *perr)
                    14782   ; {
                    14783   _OSTaskRegSet:
00004E06  4E56 0000 14784          link      A6,#0
00004E0A  2F02      14785          move.l    D2,-(A7)
                    14786   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14787   ; OS_CPU_SR  cpu_sr = 0u;
                    14788   ; #endif
                    14789   ; OS_TCB    *ptcb;
                    14790   ; #ifdef OS_SAFETY_CRITICAL
                    14791   ; if (perr == (INT8U *)0) {
                    14792   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14793   ; return;
                    14794   ; }
                    14795   ; #endif
                    14796   ; #if OS_ARG_CHK_EN > 0u
                    14797   ; if (prio >= OS_LOWEST_PRIO) {
                    14798   ; if (prio != OS_PRIO_SELF) {
                    14799   ; *perr = OS_ERR_PRIO_INVALID;
                    14800   ; return;
                    14801   ; }
                    14802   ; }
                    14803   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14804   ; *perr = OS_ERR_ID_INVALID;
                    14805   ; return;
                    14806   ; }
                    14807   ; #endif
                    14808   ; OS_ENTER_CRITICAL();
00004E0C  40E7      14809          dc.w      16615
00004E0E  007C      14810          dc.w      124
00004E10  0700      14811          dc.w      1792
                    14812   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004E12  102E 000B 14813          move.b    11(A6),D0
00004E16  0C00 00FF 14814          cmp.b     #255,D0
00004E1A  6608      14815          bne.s     OSTaskRegSet_1
                    14816   ; ptcb = OSTCBCur;
00004E1C  2439 0800 14817          move.l    _OSTCBCur.L,D2
00004E20  0540      
00004E22  6016      14818          bra.s     OSTaskRegSet_2
                    14819   OSTaskRegSet_1:
                    14820   ; } else {
                    14821   ; ptcb = OSTCBPrioTbl[prio];
00004E24  102E 000B 14822          move.b    11(A6),D0
00004E28  C0BC 0000 14823          and.l     #255,D0
00004E2C  00FF      
00004E2E  E588      14824          lsl.l     #2,D0
00004E30  41F9 0800 14825          lea       _OSTCBPrioTbl.L,A0
00004E34  0550      
00004E36  2430 0800 14826          move.l    0(A0,D0.L),D2
                    14827   OSTaskRegSet_2:
                    14828   ; }
                    14829   ; ptcb->OSTCBRegTbl[id] = value;
00004E3A  2042      14830          move.l    D2,A0
00004E3C  102E 000F 14831          move.b    15(A6),D0
00004E40  C0BC 0000 14832          and.l     #255,D0
00004E44  00FF      
00004E46  E588      14833          lsl.l     #2,D0
00004E48  D1C0      14834          add.l     D0,A0
00004E4A  216E 0010 14835          move.l    16(A6),82(A0)
00004E4E  0052      
                    14836   ; OS_EXIT_CRITICAL();
00004E50  46DF      14837          dc.w      18143
                    14838   ; *perr                 = OS_ERR_NONE;
00004E52  206E 0014 14839          move.l    20(A6),A0
00004E56  4210      14840          clr.b     (A0)
00004E58  241F      14841          move.l    (A7)+,D2
00004E5A  4E5E      14842          unlk      A6
00004E5C  4E75      14843          rts
                    14844   ; }
                    14845   ; #endif
                    14846   ; /*$PAGE*/
                    14847   ; /*
                    14848   ; *********************************************************************************************************
                    14849   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    14850   ; *
                    14851   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    14852   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    14853   ; *
                    14854   ; * Arguments  : none
                    14855   ; *
                    14856   ; * Returns    : none
                    14857   ; *
                    14858   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    14859   ; *********************************************************************************************************
                    14860   ; */
                    14861   ; void  OS_TaskReturn (void)
                    14862   ; {
                    14863   _OS_TaskReturn:
                    14864   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
00004E5E  2F39 0800 14865          move.l    _OSTCBCur.L,-(A7)
00004E62  0540      
00004E64  4EB8 09B0 14866          jsr       _OSTaskReturnHook
00004E68  584F      14867          addq.w    #4,A7
                    14868   ; #if OS_TASK_DEL_EN > 0u
                    14869   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00004E6A  4878 00FF 14870          pea       255
00004E6E  4EB8 4730 14871          jsr       _OSTaskDel
00004E72  584F      14872          addq.w    #4,A7
00004E74  C0BC 0000 14873          and.l     #255,D0
00004E78  00FF      
00004E7A  4E75      14874          rts
                    14875   ; #else
                    14876   ; for (;;) {
                    14877   ; OSTimeDly(OS_TICKS_PER_SEC);
                    14878   ; }
                    14879   ; #endif
                    14880   ; }
                    14881   ; /*$PAGE*/
                    14882   ; /*
                    14883   ; *********************************************************************************************************
                    14884   ; *                                          CLEAR TASK STACK
                    14885   ; *
                    14886   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    14887   ; *
                    14888   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    14889   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    14890   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    14891   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    14892   ; *                       highest memory location of the stack and the stack will grow with increasing
                    14893   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    14894   ; *
                    14895   ; *              size     is the number of 'stack elements' to clear.
                    14896   ; *
                    14897   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    14898   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    14899   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    14900   ; *
                    14901   ; * Returns    : none
                    14902   ; *********************************************************************************************************
                    14903   ; */
                    14904   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14905   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    14906   ; INT32U   size,
                    14907   ; INT16U   opt)
                    14908   ; {
                    14909   _OS_TaskStkClr:
00004E7C  4E56 0000 14910          link      A6,#0
                    14911   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
00004E80  302E 0012 14912          move.w    18(A6),D0
00004E84  C07C 0001 14913          and.w     #1,D0
00004E88  6726      14914          beq.s     OS_TaskStkClr_7
                    14915   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
00004E8A  302E 0012 14916          move.w    18(A6),D0
00004E8E  C07C 0002 14917          and.w     #2,D0
00004E92  671C      14918          beq.s     OS_TaskStkClr_7
                    14919   ; #if OS_STK_GROWTH == 1u
                    14920   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    14921   OS_TaskStkClr_5:
00004E94  202E 000C 14922          move.l    12(A6),D0
00004E98  0C80 0000 14923          cmp.l     #0,D0
00004E9C  0000      
00004E9E  6310      14924          bls.s     OS_TaskStkClr_7
                    14925   ; size--;
00004EA0  53AE 000C 14926          subq.l    #1,12(A6)
                    14927   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
00004EA4  206E 0008 14928          move.l    8(A6),A0
00004EA8  54AE 0008 14929          addq.l    #2,8(A6)
00004EAC  4250      14930          clr.w     (A0)
00004EAE  60E4      14931          bra       OS_TaskStkClr_5
                    14932   OS_TaskStkClr_7:
00004EB0  4E5E      14933          unlk      A6
00004EB2  4E75      14934          rts
                    14935   ; /*
                    14936   ; *********************************************************************************************************
                    14937   ; *                                                uC/OS-II
                    14938   ; *                                          The Real-Time Kernel
                    14939   ; *                                             TIME MANAGEMENT
                    14940   ; *
                    14941   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    14942   ; *                                           All Rights Reserved
                    14943   ; *
                    14944   ; * File    : OS_TIME.C
                    14945   ; * By      : Jean J. Labrosse
                    14946   ; * Version : V2.92.07
                    14947   ; *
                    14948   ; * LICENSING TERMS:
                    14949   ; * ---------------
                    14950   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    14951   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    14952   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    14953   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    14954   ; * licensing fee.
                    14955   ; *********************************************************************************************************
                    14956   ; */
                    14957   ; #define  MICRIUM_SOURCE
                    14958   ; #ifndef  OS_MASTER_FILE
                    14959   ; #include <ucos_ii.h>
                    14960   ; #endif
                    14961   ; /*
                    14962   ; *********************************************************************************************************
                    14963   ; *                                        DELAY TASK 'n' TICKS
                    14964   ; *
                    14965   ; * Description: This function is called to delay execution of the currently running task until the
                    14966   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    14967   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    14968   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    14969   ; *
                    14970   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    14971   ; *                        Note that by specifying 0, the task will not be delayed.
                    14972   ; *
                    14973   ; * Returns    : none
                    14974   ; *********************************************************************************************************
                    14975   ; */
                    14976   ; void  OSTimeDly (INT32U ticks)
                    14977   ; {
                    14978   _OSTimeDly:
00004EB4  4E56 0000 14979          link      A6,#0
00004EB8  48E7 2020 14980          movem.l   D2/A2,-(A7)
00004EBC  45F9 0800 14981          lea       _OSTCBCur.L,A2
00004EC0  0540      
                    14982   ; INT8U      y;
                    14983   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14984   ; OS_CPU_SR  cpu_sr = 0u;
                    14985   ; #endif
                    14986   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004EC2  1039 0800 14987          move.b    _OSIntNesting.L,D0
00004EC6  0426      
00004EC8  0C00 0000 14988          cmp.b     #0,D0
00004ECC  6304      14989          bls.s     OSTimeDly_1
                    14990   ; return;
00004ECE  6000 0072 14991          bra       OSTimeDly_6
                    14992   OSTimeDly_1:
                    14993   ; }
                    14994   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004ED2  1039 0800 14995          move.b    _OSLockNesting.L,D0
00004ED6  0428      
00004ED8  0C00 0000 14996          cmp.b     #0,D0
00004EDC  6304      14997          bls.s     OSTimeDly_4
                    14998   ; return;
00004EDE  6000 0062 14999          bra       OSTimeDly_6
                    15000   OSTimeDly_4:
                    15001   ; }
                    15002   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
00004EE2  202E 0008 15003          move.l    8(A6),D0
00004EE6  0C80 0000 15004          cmp.l     #0,D0
00004EEA  0000      
00004EEC  6300 0054 15005          bls       OSTimeDly_6
                    15006   ; OS_ENTER_CRITICAL();
00004EF0  40E7      15007          dc.w      16615
00004EF2  007C      15008          dc.w      124
00004EF4  0700      15009          dc.w      1792
                    15010   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
00004EF6  2052      15011          move.l    (A2),A0
00004EF8  1428 0036 15012          move.b    54(A0),D2
                    15013   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00004EFC  C4BC 0000 15014          and.l     #255,D2
00004F00  00FF      
00004F02  41F9 0800 15015          lea       _OSRdyTbl.L,A0
00004F06  0430      
00004F08  2252      15016          move.l    (A2),A1
00004F0A  1029 0037 15017          move.b    55(A1),D0
00004F0E  4600      15018          not.b     D0
00004F10  C130 2800 15019          and.b     D0,0(A0,D2.L)
                    15020   ; if (OSRdyTbl[y] == 0u) {
00004F14  C4BC 0000 15021          and.l     #255,D2
00004F18  00FF      
00004F1A  41F9 0800 15022          lea       _OSRdyTbl.L,A0
00004F1E  0430      
00004F20  1030 2800 15023          move.b    0(A0,D2.L),D0
00004F24  660E      15024          bne.s     OSTimeDly_8
                    15025   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00004F26  2052      15026          move.l    (A2),A0
00004F28  1028 0038 15027          move.b    56(A0),D0
00004F2C  4600      15028          not.b     D0
00004F2E  C139 0800 15029          and.b     D0,_OSRdyGrp.L
00004F32  042E      
                    15030   OSTimeDly_8:
                    15031   ; }
                    15032   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
00004F34  2052      15033          move.l    (A2),A0
00004F36  216E 0008 15034          move.l    8(A6),46(A0)
00004F3A  002E      
                    15035   ; OS_EXIT_CRITICAL();
00004F3C  46DF      15036          dc.w      18143
                    15037   ; OS_Sched();                              /* Find next task to run!                             */
00004F3E  4EB8 16B8 15038          jsr       _OS_Sched
                    15039   OSTimeDly_6:
00004F42  4CDF 0404 15040          movem.l   (A7)+,D2/A2
00004F46  4E5E      15041          unlk      A6
00004F48  4E75      15042          rts
                    15043   ; }
                    15044   ; }
                    15045   ; /*$PAGE*/
                    15046   ; /*
                    15047   ; *********************************************************************************************************
                    15048   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    15049   ; *
                    15050   ; * Description: This function is called to delay execution of the currently running task until some time
                    15051   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    15052   ; *              MILLISECONDS instead of ticks.
                    15053   ; *
                    15054   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    15055   ; *              minutes   specifies the number of minutes (max. 59)
                    15056   ; *              seconds   specifies the number of seconds (max. 59)
                    15057   ; *              ms        specifies the number of milliseconds (max. 999)
                    15058   ; *
                    15059   ; * Returns    : OS_ERR_NONE
                    15060   ; *              OS_ERR_TIME_INVALID_MINUTES
                    15061   ; *              OS_ERR_TIME_INVALID_SECONDS
                    15062   ; *              OS_ERR_TIME_INVALID_MS
                    15063   ; *              OS_ERR_TIME_ZERO_DLY
                    15064   ; *              OS_ERR_TIME_DLY_ISR
                    15065   ; *
                    15066   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    15067   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    15068   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    15069   ; *********************************************************************************************************
                    15070   ; */
                    15071   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    15072   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    15073   ; INT8U   minutes,
                    15074   ; INT8U   seconds,
                    15075   ; INT16U  ms)
                    15076   ; {
                    15077   _OSTimeDlyHMSM:
00004F4A  4E56 FFFC 15078          link      A6,#-4
                    15079   ; INT32U ticks;
                    15080   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004F4E  1039 0800 15081          move.b    _OSIntNesting.L,D0
00004F52  0426      
00004F54  0C00 0000 15082          cmp.b     #0,D0
00004F58  6306      15083          bls.s     OSTimeDlyHMSM_1
                    15084   ; return (OS_ERR_TIME_DLY_ISR);
00004F5A  7055      15085          moveq     #85,D0
00004F5C  6000 00A4 15086          bra       OSTimeDlyHMSM_3
                    15087   OSTimeDlyHMSM_1:
                    15088   ; }
                    15089   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004F60  1039 0800 15090          move.b    _OSLockNesting.L,D0
00004F64  0428      
00004F66  0C00 0000 15091          cmp.b     #0,D0
00004F6A  6306      15092          bls.s     OSTimeDlyHMSM_4
                    15093   ; return (OS_ERR_SCHED_LOCKED);
00004F6C  7032      15094          moveq     #50,D0
00004F6E  6000 0092 15095          bra       OSTimeDlyHMSM_3
                    15096   OSTimeDlyHMSM_4:
                    15097   ; }
                    15098   ; #if OS_ARG_CHK_EN > 0u
                    15099   ; if (hours == 0u) {
                    15100   ; if (minutes == 0u) {
                    15101   ; if (seconds == 0u) {
                    15102   ; if (ms == 0u) {
                    15103   ; return (OS_ERR_TIME_ZERO_DLY);
                    15104   ; }
                    15105   ; }
                    15106   ; }
                    15107   ; }
                    15108   ; if (minutes > 59u) {
                    15109   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    15110   ; }
                    15111   ; if (seconds > 59u) {
                    15112   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    15113   ; }
                    15114   ; if (ms > 999u) {
                    15115   ; return (OS_ERR_TIME_INVALID_MS);
                    15116   ; }
                    15117   ; #endif
                    15118   ; /* Compute the total number of clock ticks required.. */
                    15119   ; /* .. (rounded to the nearest tick)                   */
                    15120   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
00004F72  102E 000B 15121          move.b    11(A6),D0
00004F76  C0BC 0000 15122          and.l     #255,D0
00004F7A  00FF      
00004F7C  2F00      15123          move.l    D0,-(A7)
00004F7E  4878 0E10 15124          pea       3600
00004F82  4EB9 0000 15125          jsr       ULMUL
00004F86  6A9C      
00004F88  2017      15126          move.l    (A7),D0
00004F8A  504F      15127          addq.w    #8,A7
00004F8C  122E 000F 15128          move.b    15(A6),D1
00004F90  C2BC 0000 15129          and.l     #255,D1
00004F94  00FF      
00004F96  2F01      15130          move.l    D1,-(A7)
00004F98  4878 003C 15131          pea       60
00004F9C  4EB9 0000 15132          jsr       ULMUL
00004FA0  6A9C      
00004FA2  2217      15133          move.l    (A7),D1
00004FA4  504F      15134          addq.w    #8,A7
00004FA6  D081      15135          add.l     D1,D0
00004FA8  122E 0013 15136          move.b    19(A6),D1
00004FAC  C2BC 0000 15137          and.l     #255,D1
00004FB0  00FF      
00004FB2  D081      15138          add.l     D1,D0
00004FB4  2F00      15139          move.l    D0,-(A7)
00004FB6  4878 0064 15140          pea       100
00004FBA  4EB9 0000 15141          jsr       ULMUL
00004FBE  6A9C      
00004FC0  2017      15142          move.l    (A7),D0
00004FC2  504F      15143          addq.w    #8,A7
00004FC4  322E 0016 15144          move.w    22(A6),D1
00004FC8  C2BC 0000 15145          and.l     #65535,D1
00004FCC  FFFF      
00004FCE  5A81      15146          addq.l    #5,D1
00004FD0  2F01      15147          move.l    D1,-(A7)
00004FD2  4878 0064 15148          pea       100
00004FD6  4EB9 0000 15149          jsr       ULMUL
00004FDA  6A9C      
00004FDC  2217      15150          move.l    (A7),D1
00004FDE  504F      15151          addq.w    #8,A7
00004FE0  2F01      15152          move.l    D1,-(A7)
00004FE2  4878 03E8 15153          pea       1000
00004FE6  4EB9 0000 15154          jsr       ULDIV
00004FEA  6B3C      
00004FEC  2217      15155          move.l    (A7),D1
00004FEE  504F      15156          addq.w    #8,A7
00004FF0  D081      15157          add.l     D1,D0
00004FF2  2D40 FFFC 15158          move.l    D0,-4(A6)
                    15159   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15160   ; OSTimeDly(ticks);
00004FF6  2F2E FFFC 15161          move.l    -4(A6),-(A7)
00004FFA  4EB8 4EB4 15162          jsr       _OSTimeDly
00004FFE  584F      15163          addq.w    #4,A7
                    15164   ; return (OS_ERR_NONE);
00005000  4200      15165          clr.b     D0
                    15166   OSTimeDlyHMSM_3:
00005002  4E5E      15167          unlk      A6
00005004  4E75      15168          rts
                    15169   ; }
                    15170   ; #endif
                    15171   ; /*$PAGE*/
                    15172   ; /*
                    15173   ; *********************************************************************************************************
                    15174   ; *                                        RESUME A DELAYED TASK
                    15175   ; *
                    15176   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15177   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15178   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15179   ; *              like a timeout occurred.
                    15180   ; *
                    15181   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15182   ; *
                    15183   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15184   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15185   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15186   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15187   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15188   ; *********************************************************************************************************
                    15189   ; */
                    15190   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15191   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15192   ; {
                    15193   _OSTimeDlyResume:
00005006  4E56 0000 15194          link      A6,#0
0000500A  2F02      15195          move.l    D2,-(A7)
                    15196   ; OS_TCB    *ptcb;
                    15197   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15198   ; OS_CPU_SR  cpu_sr = 0u;
                    15199   ; #endif
                    15200   ; if (prio >= OS_LOWEST_PRIO) {
0000500C  102E 000B 15201          move.b    11(A6),D0
00005010  0C00 003F 15202          cmp.b     #63,D0
00005014  6506      15203          blo.s     OSTimeDlyResume_1
                    15204   ; return (OS_ERR_PRIO_INVALID);
00005016  702A      15205          moveq     #42,D0
00005018  6000 00B4 15206          bra       OSTimeDlyResume_3
                    15207   OSTimeDlyResume_1:
                    15208   ; }
                    15209   ; OS_ENTER_CRITICAL();
0000501C  40E7      15210          dc.w      16615
0000501E  007C      15211          dc.w      124
00005020  0700      15212          dc.w      1792
                    15213   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
00005022  102E 000B 15214          move.b    11(A6),D0
00005026  C0BC 0000 15215          and.l     #255,D0
0000502A  00FF      
0000502C  E588      15216          lsl.l     #2,D0
0000502E  41F9 0800 15217          lea       _OSTCBPrioTbl.L,A0
00005032  0550      
00005034  2430 0800 15218          move.l    0(A0,D0.L),D2
                    15219   ; if (ptcb == (OS_TCB *)0) {
00005038  4A82      15220          tst.l     D2
0000503A  6608      15221          bne.s     OSTimeDlyResume_4
                    15222   ; OS_EXIT_CRITICAL();
0000503C  46DF      15223          dc.w      18143
                    15224   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
0000503E  7043      15225          moveq     #67,D0
00005040  6000 008C 15226          bra       OSTimeDlyResume_3
                    15227   OSTimeDlyResume_4:
                    15228   ; }
                    15229   ; if (ptcb == OS_TCB_RESERVED) {
00005044  0C82 0000 15230          cmp.l     #1,D2
00005048  0001      
0000504A  6608      15231          bne.s     OSTimeDlyResume_6
                    15232   ; OS_EXIT_CRITICAL();
0000504C  46DF      15233          dc.w      18143
                    15234   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
0000504E  7043      15235          moveq     #67,D0
00005050  6000 007C 15236          bra       OSTimeDlyResume_3
                    15237   OSTimeDlyResume_6:
                    15238   ; }
                    15239   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
00005054  2042      15240          move.l    D2,A0
00005056  2028 002E 15241          move.l    46(A0),D0
0000505A  6608      15242          bne.s     OSTimeDlyResume_8
                    15243   ; OS_EXIT_CRITICAL();
0000505C  46DF      15244          dc.w      18143
                    15245   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
0000505E  7050      15246          moveq     #80,D0
00005060  6000 006C 15247          bra       OSTimeDlyResume_3
                    15248   OSTimeDlyResume_8:
                    15249   ; }
                    15250   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
00005064  2042      15251          move.l    D2,A0
00005066  42A8 002E 15252          clr.l     46(A0)
                    15253   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
0000506A  2042      15254          move.l    D2,A0
0000506C  1028 0032 15255          move.b    50(A0),D0
00005070  C03C 0037 15256          and.b     #55,D0
00005074  6712      15257          beq.s     OSTimeDlyResume_10
                    15258   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
00005076  2042      15259          move.l    D2,A0
00005078  0228 00C8 15260          and.b     #-56,50(A0)
0000507C  0032      
                    15261   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
0000507E  2042      15262          move.l    D2,A0
00005080  117C 0001 15263          move.b    #1,51(A0)
00005084  0033      
00005086  6006      15264          bra.s     OSTimeDlyResume_11
                    15265   OSTimeDlyResume_10:
                    15266   ; } else {
                    15267   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
00005088  2042      15268          move.l    D2,A0
0000508A  4228 0033 15269          clr.b     51(A0)
                    15270   OSTimeDlyResume_11:
                    15271   ; }
                    15272   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
0000508E  2042      15273          move.l    D2,A0
00005090  1028 0032 15274          move.b    50(A0),D0
00005094  C03C 0008 15275          and.b     #8,D0
00005098  6630      15276          bne.s     OSTimeDlyResume_12
                    15277   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
0000509A  2042      15278          move.l    D2,A0
0000509C  1028 0038 15279          move.b    56(A0),D0
000050A0  8139 0800 15280          or.b      D0,_OSRdyGrp.L
000050A4  042E      
                    15281   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000050A6  2042      15282          move.l    D2,A0
000050A8  1028 0036 15283          move.b    54(A0),D0
000050AC  C0BC 0000 15284          and.l     #255,D0
000050B0  00FF      
000050B2  41F9 0800 15285          lea       _OSRdyTbl.L,A0
000050B6  0430      
000050B8  2242      15286          move.l    D2,A1
000050BA  1229 0037 15287          move.b    55(A1),D1
000050BE  8330 0800 15288          or.b      D1,0(A0,D0.L)
                    15289   ; OS_EXIT_CRITICAL();
000050C2  46DF      15290          dc.w      18143
                    15291   ; OS_Sched();                                            /* See if this is new highest priority  */
000050C4  4EB8 16B8 15292          jsr       _OS_Sched
000050C8  6002      15293          bra.s     OSTimeDlyResume_13
                    15294   OSTimeDlyResume_12:
                    15295   ; } else {
                    15296   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
000050CA  46DF      15297          dc.w      18143
                    15298   OSTimeDlyResume_13:
                    15299   ; }
                    15300   ; return (OS_ERR_NONE);
000050CC  4200      15301          clr.b     D0
                    15302   OSTimeDlyResume_3:
000050CE  241F      15303          move.l    (A7)+,D2
000050D0  4E5E      15304          unlk      A6
000050D2  4E75      15305          rts
                    15306   ; }
                    15307   ; #endif
                    15308   ; /*$PAGE*/
                    15309   ; /*
                    15310   ; *********************************************************************************************************
                    15311   ; *                                       GET CURRENT SYSTEM TIME
                    15312   ; *
                    15313   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15314   ; *              counter which keeps track of the number of clock ticks.
                    15315   ; *
                    15316   ; * Arguments  : none
                    15317   ; *
                    15318   ; * Returns    : The current value of OSTime
                    15319   ; *********************************************************************************************************
                    15320   ; */
                    15321   ; #if OS_TIME_GET_SET_EN > 0u
                    15322   ; INT32U  OSTimeGet (void)
                    15323   ; {
                    15324   _OSTimeGet:
000050D4  4E56 FFFC 15325          link      A6,#-4
                    15326   ; INT32U     ticks;
                    15327   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15328   ; OS_CPU_SR  cpu_sr = 0u;
                    15329   ; #endif
                    15330   ; OS_ENTER_CRITICAL();
000050D8  40E7      15331          dc.w      16615
000050DA  007C      15332          dc.w      124
000050DC  0700      15333          dc.w      1792
                    15334   ; ticks = OSTime;
000050DE  2D79 0800 15335          move.l    _OSTime.L,-4(A6)
000050E2  0E96 FFFC 
                    15336   ; OS_EXIT_CRITICAL();
000050E6  46DF      15337          dc.w      18143
                    15338   ; return (ticks);
000050E8  202E FFFC 15339          move.l    -4(A6),D0
000050EC  4E5E      15340          unlk      A6
000050EE  4E75      15341          rts
                    15342   ; }
                    15343   ; #endif
                    15344   ; /*
                    15345   ; *********************************************************************************************************
                    15346   ; *                                          SET SYSTEM CLOCK
                    15347   ; *
                    15348   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15349   ; *
                    15350   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15351   ; *
                    15352   ; * Returns    : none
                    15353   ; *********************************************************************************************************
                    15354   ; */
                    15355   ; #if OS_TIME_GET_SET_EN > 0u
                    15356   ; void  OSTimeSet (INT32U ticks)
                    15357   ; {
                    15358   _OSTimeSet:
000050F0  4E56 0000 15359          link      A6,#0
                    15360   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15361   ; OS_CPU_SR  cpu_sr = 0u;
                    15362   ; #endif
                    15363   ; OS_ENTER_CRITICAL();
000050F4  40E7      15364          dc.w      16615
000050F6  007C      15365          dc.w      124
000050F8  0700      15366          dc.w      1792
                    15367   ; OSTime = ticks;
000050FA  23EE 0008 15368          move.l    8(A6),_OSTime.L
000050FE  0800 0E96 
                    15369   ; OS_EXIT_CRITICAL();
00005102  46DF      15370          dc.w      18143
00005104  4E5E      15371          unlk      A6
00005106  4E75      15372          rts
                    15373   ; /*
                    15374   ; *********************************************************************************************************
                    15375   ; *                                                uC/OS-II
                    15376   ; *                                          The Real-Time Kernel
                    15377   ; *                                            TIMER MANAGEMENT
                    15378   ; *
                    15379   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15380   ; *                                           All Rights Reserved
                    15381   ; *
                    15382   ; *
                    15383   ; * File    : OS_TMR.C
                    15384   ; * By      : Jean J. Labrosse
                    15385   ; * Version : V2.92.07
                    15386   ; *
                    15387   ; * LICENSING TERMS:
                    15388   ; * ---------------
                    15389   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15390   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15391   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15392   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15393   ; * licensing fee.
                    15394   ; *********************************************************************************************************
                    15395   ; */
                    15396   ; #define  MICRIUM_SOURCE
                    15397   ; #ifndef  OS_MASTER_FILE
                    15398   ; #include <ucos_ii.h>
                    15399   ; #endif
                    15400   ; /*
                    15401   ; *********************************************************************************************************
                    15402   ; *                                                        NOTES
                    15403   ; *
                    15404   ; * 1) Your application MUST define the following #define constants:
                    15405   ; *
                    15406   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15407   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15408   ; *
                    15409   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15410   ; *********************************************************************************************************
                    15411   ; */
                    15412   ; /*
                    15413   ; *********************************************************************************************************
                    15414   ; *                                              CONSTANTS
                    15415   ; *********************************************************************************************************
                    15416   ; */
                    15417   ; #define  OS_TMR_LINK_DLY       0u
                    15418   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15419   ; /*
                    15420   ; *********************************************************************************************************
                    15421   ; *                                          LOCAL PROTOTYPES
                    15422   ; *********************************************************************************************************
                    15423   ; */
                    15424   ; #if OS_TMR_EN > 0u
                    15425   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15426   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15427   ; static  void     OSTmr_InitTask      (void);
                    15428   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15429   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15430   ; static  void     OSTmr_Task          (void   *p_arg);
                    15431   ; #endif
                    15432   ; /*$PAGE*/
                    15433   ; /*
                    15434   ; *********************************************************************************************************
                    15435   ; *                                           CREATE A TIMER
                    15436   ; *
                    15437   ; * Description: This function is called by your application code to create a timer.
                    15438   ; *
                    15439   ; * Arguments  : dly           Initial delay.
                    15440   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15441   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15442   ; *                               wait for before the timer starts entering periodic mode.
                    15443   ; *
                    15444   ; *              period        The 'period' being repeated for the timer.
                    15445   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15446   ; *                               expires, it will automatically restart with the same period.
                    15447   ; *
                    15448   ; *              opt           Specifies either:
                    15449   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15450   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15451   ; *
                    15452   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15453   ; *                               The callback function must be declared as follows:
                    15454   ; *
                    15455   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15456   ; *
                    15457   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15458   ; *
                    15459   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15460   ; *                               useful for debugging.
                    15461   ; *
                    15462   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15463   ; *                               OS_ERR_NONE
                    15464   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15465   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15466   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15467   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15468   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15469   ; *
                    15470   ; * Returns    : A pointer to an OS_TMR data structure.
                    15471   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15472   ; *********************************************************************************************************
                    15473   ; */
                    15474   ; #if OS_TMR_EN > 0u
                    15475   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15476   ; INT32U           period,
                    15477   ; INT8U            opt,
                    15478   ; OS_TMR_CALLBACK  callback,
                    15479   ; void            *callback_arg,
                    15480   ; INT8U           *pname,
                    15481   ; INT8U           *perr)
                    15482   ; {
                    15483   _OSTmrCreate:
00005108  4E56 0000 15484          link      A6,#0
0000510C  48E7 3000 15485          movem.l   D2/D3,-(A7)
00005110  262E 0020 15486          move.l    32(A6),D3
                    15487   ; OS_TMR   *ptmr;
                    15488   ; #ifdef OS_SAFETY_CRITICAL
                    15489   ; if (perr == (INT8U *)0) {
                    15490   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15491   ; return ((OS_TMR *)0);
                    15492   ; }
                    15493   ; #endif
                    15494   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15495   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15496   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15497   ; return ((OS_TMR *)0);
                    15498   ; }
                    15499   ; #endif
                    15500   ; #if OS_ARG_CHK_EN > 0u
                    15501   ; switch (opt) {                                          /* Validate arguments                                     */
                    15502   ; case OS_TMR_OPT_PERIODIC:
                    15503   ; if (period == 0u) {
                    15504   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15505   ; return ((OS_TMR *)0);
                    15506   ; }
                    15507   ; break;
                    15508   ; case OS_TMR_OPT_ONE_SHOT:
                    15509   ; if (dly == 0u) {
                    15510   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15511   ; return ((OS_TMR *)0);
                    15512   ; }
                    15513   ; break;
                    15514   ; default:
                    15515   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15516   ; return ((OS_TMR *)0);
                    15517   ; }
                    15518   ; #endif
                    15519   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005114  1039 0800 15520          move.b    _OSIntNesting.L,D0
00005118  0426      
0000511A  0C00 0000 15521          cmp.b     #0,D0
0000511E  630C      15522          bls.s     OSTmrCreate_1
                    15523   ; *perr  = OS_ERR_TMR_ISR;
00005120  2043      15524          move.l    D3,A0
00005122  10BC 008B 15525          move.b    #139,(A0)
                    15526   ; return ((OS_TMR *)0);
00005126  4280      15527          clr.l     D0
00005128  6000 0078 15528          bra       OSTmrCreate_3
                    15529   OSTmrCreate_1:
                    15530   ; }
                    15531   ; OSSchedLock();
0000512C  4EB8 0F08 15532          jsr       _OSSchedLock
                    15533   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
00005130  4EB9 0000 15534          jsr       @ucos_ii_OSTmr_Alloc
00005134  56A0      
00005136  2400      15535          move.l    D0,D2
                    15536   ; if (ptmr == (OS_TMR *)0) {
00005138  4A82      15537          tst.l     D2
0000513A  6610      15538          bne.s     OSTmrCreate_4
                    15539   ; OSSchedUnlock();
0000513C  4EB8 0F38 15540          jsr       _OSSchedUnlock
                    15541   ; *perr = OS_ERR_TMR_NON_AVAIL;
00005140  2043      15542          move.l    D3,A0
00005142  10BC 0086 15543          move.b    #134,(A0)
                    15544   ; return ((OS_TMR *)0);
00005146  4280      15545          clr.l     D0
00005148  6000 0058 15546          bra       OSTmrCreate_3
                    15547   OSTmrCreate_4:
                    15548   ; }
                    15549   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
0000514C  2042      15550          move.l    D2,A0
0000514E  117C 0001 15551          move.b    #1,35(A0)
00005152  0023      
                    15552   ; ptmr->OSTmrDly         = dly;
00005154  2042      15553          move.l    D2,A0
00005156  216E 0008 15554          move.l    8(A6),22(A0)
0000515A  0016      
                    15555   ; ptmr->OSTmrPeriod      = period;
0000515C  2042      15556          move.l    D2,A0
0000515E  216E 000C 15557          move.l    12(A6),26(A0)
00005162  001A      
                    15558   ; ptmr->OSTmrOpt         = opt;
00005164  2042      15559          move.l    D2,A0
00005166  116E 0013 15560          move.b    19(A6),34(A0)
0000516A  0022      
                    15561   ; ptmr->OSTmrCallback    = callback;
0000516C  2042      15562          move.l    D2,A0
0000516E  216E 0014 15563          move.l    20(A6),2(A0)
00005172  0002      
                    15564   ; ptmr->OSTmrCallbackArg = callback_arg;
00005174  2042      15565          move.l    D2,A0
00005176  216E 0018 15566          move.l    24(A6),6(A0)
0000517A  0006      
                    15567   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15568   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
0000517C  202E 001C 15569          move.l    28(A6),D0
00005180  660E      15570          bne.s     OSTmrCreate_6
                    15571   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
00005182  41F9 0000 15572          lea       @ucos_ii_1.L,A0
00005186  763A      
00005188  2242      15573          move.l    D2,A1
0000518A  2348 001E 15574          move.l    A0,30(A1)
0000518E  6008      15575          bra.s     OSTmrCreate_7
                    15576   OSTmrCreate_6:
                    15577   ; } else {
                    15578   ; ptmr->OSTmrName    = pname;
00005190  2042      15579          move.l    D2,A0
00005192  216E 001C 15580          move.l    28(A6),30(A0)
00005196  001E      
                    15581   OSTmrCreate_7:
                    15582   ; }
                    15583   ; #endif
                    15584   ; OSSchedUnlock();
00005198  4EB8 0F38 15585          jsr       _OSSchedUnlock
                    15586   ; *perr = OS_ERR_NONE;
0000519C  2043      15587          move.l    D3,A0
0000519E  4210      15588          clr.b     (A0)
                    15589   ; return (ptmr);
000051A0  2002      15590          move.l    D2,D0
                    15591   OSTmrCreate_3:
000051A2  4CDF 000C 15592          movem.l   (A7)+,D2/D3
000051A6  4E5E      15593          unlk      A6
000051A8  4E75      15594          rts
                    15595   ; }
                    15596   ; #endif
                    15597   ; /*$PAGE*/
                    15598   ; /*
                    15599   ; *********************************************************************************************************
                    15600   ; *                                           DELETE A TIMER
                    15601   ; *
                    15602   ; * Description: This function is called by your application code to delete a timer.
                    15603   ; *
                    15604   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15605   ; *
                    15606   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15607   ; *                               OS_ERR_NONE
                    15608   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15609   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15610   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15611   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15612   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15613   ; *
                    15614   ; * Returns    : OS_TRUE       If the call was successful
                    15615   ; *              OS_FALSE      If not
                    15616   ; *********************************************************************************************************
                    15617   ; */
                    15618   ; #if OS_TMR_EN > 0u
                    15619   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15620   ; INT8U   *perr)
                    15621   ; {
                    15622   _OSTmrDel:
000051AA  4E56 0000 15623          link      A6,#0
000051AE  48E7 3020 15624          movem.l   D2/D3/A2,-(A7)
000051B2  242E 000C 15625          move.l    12(A6),D2
000051B6  262E 0008 15626          move.l    8(A6),D3
000051BA  45F8 0F38 15627          lea       _OSSchedUnlock.L,A2
                    15628   ; #ifdef OS_SAFETY_CRITICAL
                    15629   ; if (perr == (INT8U *)0) {
                    15630   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15631   ; return (OS_FALSE);
                    15632   ; }
                    15633   ; #endif
                    15634   ; #if OS_ARG_CHK_EN > 0u
                    15635   ; if (ptmr == (OS_TMR *)0) {
                    15636   ; *perr = OS_ERR_TMR_INVALID;
                    15637   ; return (OS_FALSE);
                    15638   ; }
                    15639   ; #endif
                    15640   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000051BE  2043      15641          move.l    D3,A0
000051C0  1010      15642          move.b    (A0),D0
000051C2  0C00 0064 15643          cmp.b     #100,D0
000051C6  670C      15644          beq.s     OSTmrDel_1
                    15645   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000051C8  2042      15646          move.l    D2,A0
000051CA  10BC 0089 15647          move.b    #137,(A0)
                    15648   ; return (OS_FALSE);
000051CE  4200      15649          clr.b     D0
000051D0  6000 0090 15650          bra       OSTmrDel_3
                    15651   OSTmrDel_1:
                    15652   ; }
                    15653   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
000051D4  1039 0800 15654          move.b    _OSIntNesting.L,D0
000051D8  0426      
000051DA  0C00 0000 15655          cmp.b     #0,D0
000051DE  630C      15656          bls.s     OSTmrDel_4
                    15657   ; *perr  = OS_ERR_TMR_ISR;
000051E0  2042      15658          move.l    D2,A0
000051E2  10BC 008B 15659          move.b    #139,(A0)
                    15660   ; return (OS_FALSE);
000051E6  4200      15661          clr.b     D0
000051E8  6000 0078 15662          bra       OSTmrDel_3
                    15663   OSTmrDel_4:
                    15664   ; }
                    15665   ; OSSchedLock();
000051EC  4EB8 0F08 15666          jsr       _OSSchedLock
                    15667   ; switch (ptmr->OSTmrState) {
000051F0  2043      15668          move.l    D3,A0
000051F2  1028 0023 15669          move.b    35(A0),D0
000051F6  C0BC 0000 15670          and.l     #255,D0
000051FA  00FF      
000051FC  0C80 0000 15671          cmp.l     #4,D0
00005200  0004      
00005202  6400 0054 15672          bhs       OSTmrDel_6
00005206  E380      15673          asl.l     #1,D0
00005208  303B 0806 15674          move.w    OSTmrDel_8(PC,D0.L),D0
0000520C  4EFB 0002 15675          jmp       OSTmrDel_8(PC,D0.W)
                    15676   OSTmrDel_8:
00005210  003C      15677          dc.w      OSTmrDel_12-OSTmrDel_8
00005212  0028      15678          dc.w      OSTmrDel_10-OSTmrDel_8
00005214  0028      15679          dc.w      OSTmrDel_10-OSTmrDel_8
00005216  0008      15680          dc.w      OSTmrDel_9-OSTmrDel_8
                    15681   OSTmrDel_9:
                    15682   ; case OS_TMR_STATE_RUNNING:
                    15683   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
00005218  2F03      15684          move.l    D3,-(A7)
0000521A  4EB9 0000 15685          jsr       @ucos_ii_OSTmr_Unlink
0000521E  5996      
00005220  584F      15686          addq.w    #4,A7
                    15687   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005222  2F03      15688          move.l    D3,-(A7)
00005224  4EB9 0000 15689          jsr       @ucos_ii_OSTmr_Free
00005228  56DA      
0000522A  584F      15690          addq.w    #4,A7
                    15691   ; OSSchedUnlock();
0000522C  4E92      15692          jsr       (A2)
                    15693   ; *perr = OS_ERR_NONE;
0000522E  2042      15694          move.l    D2,A0
00005230  4210      15695          clr.b     (A0)
                    15696   ; return (OS_TRUE);
00005232  7001      15697          moveq     #1,D0
00005234  6000 002C 15698          bra       OSTmrDel_3
                    15699   OSTmrDel_10:
                    15700   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15701   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15702   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005238  2F03      15703          move.l    D3,-(A7)
0000523A  4EB9 0000 15704          jsr       @ucos_ii_OSTmr_Free
0000523E  56DA      
00005240  584F      15705          addq.w    #4,A7
                    15706   ; OSSchedUnlock();
00005242  4E92      15707          jsr       (A2)
                    15708   ; *perr = OS_ERR_NONE;
00005244  2042      15709          move.l    D2,A0
00005246  4210      15710          clr.b     (A0)
                    15711   ; return (OS_TRUE);
00005248  7001      15712          moveq     #1,D0
0000524A  6016      15713          bra.s     OSTmrDel_3
                    15714   OSTmrDel_12:
                    15715   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15716   ; OSSchedUnlock();
0000524C  4E92      15717          jsr       (A2)
                    15718   ; *perr = OS_ERR_TMR_INACTIVE;
0000524E  2042      15719          move.l    D2,A0
00005250  10BC 0087 15720          move.b    #135,(A0)
                    15721   ; return (OS_FALSE);
00005254  4200      15722          clr.b     D0
00005256  600A      15723          bra.s     OSTmrDel_3
                    15724   OSTmrDel_6:
                    15725   ; default:
                    15726   ; OSSchedUnlock();
00005258  4E92      15727          jsr       (A2)
                    15728   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000525A  2042      15729          move.l    D2,A0
0000525C  10BC 008D 15730          move.b    #141,(A0)
                    15731   ; return (OS_FALSE);
00005260  4200      15732          clr.b     D0
                    15733   OSTmrDel_3:
00005262  4CDF 040C 15734          movem.l   (A7)+,D2/D3/A2
00005266  4E5E      15735          unlk      A6
00005268  4E75      15736          rts
                    15737   ; }
                    15738   ; }
                    15739   ; #endif
                    15740   ; /*$PAGE*/
                    15741   ; /*
                    15742   ; *********************************************************************************************************
                    15743   ; *                                       GET THE NAME OF A TIMER
                    15744   ; *
                    15745   ; * Description: This function is called to obtain the name of a timer.
                    15746   ; *
                    15747   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15748   ; *
                    15749   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15750   ; *
                    15751   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15752   ; *                               OS_ERR_NONE               The call was successful
                    15753   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15754   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15755   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15756   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15757   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15758   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15759   ; *
                    15760   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15761   ; *********************************************************************************************************
                    15762   ; */
                    15763   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15764   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15765   ; INT8U   **pdest,
                    15766   ; INT8U    *perr)
                    15767   ; {
                    15768   _OSTmrNameGet:
0000526A  4E56 FFFC 15769          link      A6,#-4
0000526E  48E7 3020 15770          movem.l   D2/D3/A2,-(A7)
00005272  242E 0010 15771          move.l    16(A6),D2
00005276  45F8 0F38 15772          lea       _OSSchedUnlock.L,A2
0000527A  262E 0008 15773          move.l    8(A6),D3
                    15774   ; INT8U  len;
                    15775   ; #ifdef OS_SAFETY_CRITICAL
                    15776   ; if (perr == (INT8U *)0) {
                    15777   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15778   ; return (0u);
                    15779   ; }
                    15780   ; #endif
                    15781   ; #if OS_ARG_CHK_EN > 0u
                    15782   ; if (pdest == (INT8U **)0) {
                    15783   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    15784   ; return (0u);
                    15785   ; }
                    15786   ; if (ptmr == (OS_TMR *)0) {
                    15787   ; *perr = OS_ERR_TMR_INVALID;
                    15788   ; return (0u);
                    15789   ; }
                    15790   ; #endif
                    15791   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
0000527E  2043      15792          move.l    D3,A0
00005280  1010      15793          move.b    (A0),D0
00005282  0C00 0064 15794          cmp.b     #100,D0
00005286  670C      15795          beq.s     OSTmrNameGet_1
                    15796   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005288  2042      15797          move.l    D2,A0
0000528A  10BC 0089 15798          move.b    #137,(A0)
                    15799   ; return (0u);
0000528E  4200      15800          clr.b     D0
00005290  6000 0082 15801          bra       OSTmrNameGet_3
                    15802   OSTmrNameGet_1:
                    15803   ; }
                    15804   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005294  1039 0800 15805          move.b    _OSIntNesting.L,D0
00005298  0426      
0000529A  0C00 0000 15806          cmp.b     #0,D0
0000529E  630C      15807          bls.s     OSTmrNameGet_4
                    15808   ; *perr = OS_ERR_NAME_GET_ISR;
000052A0  2042      15809          move.l    D2,A0
000052A2  10BC 0011 15810          move.b    #17,(A0)
                    15811   ; return (0u);
000052A6  4200      15812          clr.b     D0
000052A8  6000 006A 15813          bra       OSTmrNameGet_3
                    15814   OSTmrNameGet_4:
                    15815   ; }
                    15816   ; OSSchedLock();
000052AC  4EB8 0F08 15817          jsr       _OSSchedLock
                    15818   ; switch (ptmr->OSTmrState) {
000052B0  2043      15819          move.l    D3,A0
000052B2  1028 0023 15820          move.b    35(A0),D0
000052B6  C0BC 0000 15821          and.l     #255,D0
000052BA  00FF      
000052BC  0C80 0000 15822          cmp.l     #4,D0
000052C0  0004      
000052C2  6400 0046 15823          bhs       OSTmrNameGet_6
000052C6  E380      15824          asl.l     #1,D0
000052C8  303B 0806 15825          move.w    OSTmrNameGet_8(PC,D0.L),D0
000052CC  4EFB 0002 15826          jmp       OSTmrNameGet_8(PC,D0.W)
                    15827   OSTmrNameGet_8:
000052D0  002E      15828          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
000052D2  0008      15829          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
000052D4  0008      15830          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
000052D6  0008      15831          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    15832   OSTmrNameGet_9:
                    15833   ; case OS_TMR_STATE_RUNNING:
                    15834   ; case OS_TMR_STATE_STOPPED:
                    15835   ; case OS_TMR_STATE_COMPLETED:
                    15836   ; *pdest = ptmr->OSTmrName;
000052D8  2043      15837          move.l    D3,A0
000052DA  226E 000C 15838          move.l    12(A6),A1
000052DE  22A8 001E 15839          move.l    30(A0),(A1)
                    15840   ; len    = OS_StrLen(*pdest);
000052E2  206E 000C 15841          move.l    12(A6),A0
000052E6  2F10      15842          move.l    (A0),-(A7)
000052E8  4EB8 1762 15843          jsr       _OS_StrLen
000052EC  584F      15844          addq.w    #4,A7
000052EE  1D40 FFFF 15845          move.b    D0,-1(A6)
                    15846   ; OSSchedUnlock();
000052F2  4E92      15847          jsr       (A2)
                    15848   ; *perr = OS_ERR_NONE;
000052F4  2042      15849          move.l    D2,A0
000052F6  4210      15850          clr.b     (A0)
                    15851   ; return (len);
000052F8  102E FFFF 15852          move.b    -1(A6),D0
000052FC  6016      15853          bra.s     OSTmrNameGet_3
                    15854   OSTmrNameGet_12:
                    15855   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    15856   ; OSSchedUnlock();
000052FE  4E92      15857          jsr       (A2)
                    15858   ; *perr = OS_ERR_TMR_INACTIVE;
00005300  2042      15859          move.l    D2,A0
00005302  10BC 0087 15860          move.b    #135,(A0)
                    15861   ; return (0u);
00005306  4200      15862          clr.b     D0
00005308  600A      15863          bra.s     OSTmrNameGet_3
                    15864   OSTmrNameGet_6:
                    15865   ; default:
                    15866   ; OSSchedUnlock();
0000530A  4E92      15867          jsr       (A2)
                    15868   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000530C  2042      15869          move.l    D2,A0
0000530E  10BC 008D 15870          move.b    #141,(A0)
                    15871   ; return (0u);
00005312  4200      15872          clr.b     D0
                    15873   OSTmrNameGet_3:
00005314  4CDF 040C 15874          movem.l   (A7)+,D2/D3/A2
00005318  4E5E      15875          unlk      A6
0000531A  4E75      15876          rts
                    15877   ; }
                    15878   ; }
                    15879   ; #endif
                    15880   ; /*$PAGE*/
                    15881   ; /*
                    15882   ; *********************************************************************************************************
                    15883   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    15884   ; *
                    15885   ; * Description: This function is called to get the number of ticks before a timer times out.
                    15886   ; *
                    15887   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    15888   ; *
                    15889   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15890   ; *                               OS_ERR_NONE
                    15891   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15892   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15893   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15894   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15895   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15896   ; *
                    15897   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    15898   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    15899   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    15900   ; *********************************************************************************************************
                    15901   ; */
                    15902   ; #if OS_TMR_EN > 0u
                    15903   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    15904   ; INT8U   *perr)
                    15905   ; {
                    15906   _OSTmrRemainGet:
0000531C  4E56 0000 15907          link      A6,#0
00005320  48E7 3820 15908          movem.l   D2/D3/D4/A2,-(A7)
00005324  242E 000C 15909          move.l    12(A6),D2
00005328  262E 0008 15910          move.l    8(A6),D3
0000532C  45F8 0F38 15911          lea       _OSSchedUnlock.L,A2
                    15912   ; INT32U  remain;
                    15913   ; #ifdef OS_SAFETY_CRITICAL
                    15914   ; if (perr == (INT8U *)0) {
                    15915   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15916   ; return (0u);
                    15917   ; }
                    15918   ; #endif
                    15919   ; #if OS_ARG_CHK_EN > 0u
                    15920   ; if (ptmr == (OS_TMR *)0) {
                    15921   ; *perr = OS_ERR_TMR_INVALID;
                    15922   ; return (0u);
                    15923   ; }
                    15924   ; #endif
                    15925   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005330  2043      15926          move.l    D3,A0
00005332  1010      15927          move.b    (A0),D0
00005334  0C00 0064 15928          cmp.b     #100,D0
00005338  670C      15929          beq.s     OSTmrRemainGet_1
                    15930   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000533A  2042      15931          move.l    D2,A0
0000533C  10BC 0089 15932          move.b    #137,(A0)
                    15933   ; return (0u);
00005340  4280      15934          clr.l     D0
00005342  6000 00CE 15935          bra       OSTmrRemainGet_3
                    15936   OSTmrRemainGet_1:
                    15937   ; }
                    15938   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005346  1039 0800 15939          move.b    _OSIntNesting.L,D0
0000534A  0426      
0000534C  0C00 0000 15940          cmp.b     #0,D0
00005350  630C      15941          bls.s     OSTmrRemainGet_4
                    15942   ; *perr = OS_ERR_TMR_ISR;
00005352  2042      15943          move.l    D2,A0
00005354  10BC 008B 15944          move.b    #139,(A0)
                    15945   ; return (0u);
00005358  4280      15946          clr.l     D0
0000535A  6000 00B6 15947          bra       OSTmrRemainGet_3
                    15948   OSTmrRemainGet_4:
                    15949   ; }
                    15950   ; OSSchedLock();
0000535E  4EB8 0F08 15951          jsr       _OSSchedLock
                    15952   ; switch (ptmr->OSTmrState) {
00005362  2043      15953          move.l    D3,A0
00005364  1028 0023 15954          move.b    35(A0),D0
00005368  C0BC 0000 15955          and.l     #255,D0
0000536C  00FF      
0000536E  0C80 0000 15956          cmp.l     #4,D0
00005372  0004      
00005374  6400 0092 15957          bhs       OSTmrRemainGet_6
00005378  E380      15958          asl.l     #1,D0
0000537A  303B 0806 15959          move.w    OSTmrRemainGet_8(PC,D0.L),D0
0000537E  4EFB 0002 15960          jmp       OSTmrRemainGet_8(PC,D0.W)
                    15961   OSTmrRemainGet_8:
00005382  007A      15962          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
00005384  0022      15963          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
00005386  0070      15964          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
00005388  0008      15965          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    15966   OSTmrRemainGet_9:
                    15967   ; case OS_TMR_STATE_RUNNING:
                    15968   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
0000538A  2043      15969          move.l    D3,A0
0000538C  2028 0012 15970          move.l    18(A0),D0
00005390  90B9 0800 15971          sub.l     _OSTmrTime.L,D0
00005394  0E9E      
00005396  2800      15972          move.l    D0,D4
                    15973   ; OSSchedUnlock();
00005398  4E92      15974          jsr       (A2)
                    15975   ; *perr  = OS_ERR_NONE;
0000539A  2042      15976          move.l    D2,A0
0000539C  4210      15977          clr.b     (A0)
                    15978   ; return (remain);
0000539E  2004      15979          move.l    D4,D0
000053A0  6000 0070 15980          bra       OSTmrRemainGet_3
                    15981   OSTmrRemainGet_10:
                    15982   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    15983   ; switch (ptmr->OSTmrOpt) {
000053A4  2043      15984          move.l    D3,A0
000053A6  1028 0022 15985          move.b    34(A0),D0
000053AA  C0BC 0000 15986          and.l     #255,D0
000053AE  00FF      
000053B0  0C80 0000 15987          cmp.l     #2,D0
000053B4  0002      
000053B6  670C      15988          beq.s     OSTmrRemainGet_16
000053B8  6228      15989          bhi.s     OSTmrRemainGet_17
000053BA  0C80 0000 15990          cmp.l     #1,D0
000053BE  0001      
000053C0  6720      15991          beq.s     OSTmrRemainGet_17
000053C2  601E      15992          bra.s     OSTmrRemainGet_17
                    15993   OSTmrRemainGet_16:
                    15994   ; case OS_TMR_OPT_PERIODIC:
                    15995   ; if (ptmr->OSTmrDly == 0u) {
000053C4  2043      15996          move.l    D3,A0
000053C6  2028 0016 15997          move.l    22(A0),D0
000053CA  6608      15998          bne.s     OSTmrRemainGet_19
                    15999   ; remain = ptmr->OSTmrPeriod;
000053CC  2043      16000          move.l    D3,A0
000053CE  2828 001A 16001          move.l    26(A0),D4
000053D2  6006      16002          bra.s     OSTmrRemainGet_20
                    16003   OSTmrRemainGet_19:
                    16004   ; } else {
                    16005   ; remain = ptmr->OSTmrDly;
000053D4  2043      16006          move.l    D3,A0
000053D6  2828 0016 16007          move.l    22(A0),D4
                    16008   OSTmrRemainGet_20:
                    16009   ; }
                    16010   ; OSSchedUnlock();
000053DA  4E92      16011          jsr       (A2)
                    16012   ; *perr  = OS_ERR_NONE;
000053DC  2042      16013          move.l    D2,A0
000053DE  4210      16014          clr.b     (A0)
                    16015   ; break;
000053E0  600C      16016          bra.s     OSTmrRemainGet_15
                    16017   OSTmrRemainGet_17:
                    16018   ; case OS_TMR_OPT_ONE_SHOT:
                    16019   ; default:
                    16020   ; remain = ptmr->OSTmrDly;
000053E2  2043      16021          move.l    D3,A0
000053E4  2828 0016 16022          move.l    22(A0),D4
                    16023   ; OSSchedUnlock();
000053E8  4E92      16024          jsr       (A2)
                    16025   ; *perr  = OS_ERR_NONE;
000053EA  2042      16026          move.l    D2,A0
000053EC  4210      16027          clr.b     (A0)
                    16028   ; break;
                    16029   OSTmrRemainGet_15:
                    16030   ; }
                    16031   ; return (remain);
000053EE  2004      16032          move.l    D4,D0
000053F0  6020      16033          bra.s     OSTmrRemainGet_3
                    16034   OSTmrRemainGet_11:
                    16035   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    16036   ; OSSchedUnlock();
000053F2  4E92      16037          jsr       (A2)
                    16038   ; *perr = OS_ERR_NONE;
000053F4  2042      16039          move.l    D2,A0
000053F6  4210      16040          clr.b     (A0)
                    16041   ; return (0u);
000053F8  4280      16042          clr.l     D0
000053FA  6016      16043          bra.s     OSTmrRemainGet_3
                    16044   OSTmrRemainGet_12:
                    16045   ; case OS_TMR_STATE_UNUSED:
                    16046   ; OSSchedUnlock();
000053FC  4E92      16047          jsr       (A2)
                    16048   ; *perr = OS_ERR_TMR_INACTIVE;
000053FE  2042      16049          move.l    D2,A0
00005400  10BC 0087 16050          move.b    #135,(A0)
                    16051   ; return (0u);
00005404  4280      16052          clr.l     D0
00005406  600A      16053          bra.s     OSTmrRemainGet_3
                    16054   OSTmrRemainGet_6:
                    16055   ; default:
                    16056   ; OSSchedUnlock();
00005408  4E92      16057          jsr       (A2)
                    16058   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000540A  2042      16059          move.l    D2,A0
0000540C  10BC 008D 16060          move.b    #141,(A0)
                    16061   ; return (0u);
00005410  4280      16062          clr.l     D0
                    16063   OSTmrRemainGet_3:
00005412  4CDF 041C 16064          movem.l   (A7)+,D2/D3/D4/A2
00005416  4E5E      16065          unlk      A6
00005418  4E75      16066          rts
                    16067   ; }
                    16068   ; }
                    16069   ; #endif
                    16070   ; /*$PAGE*/
                    16071   ; /*
                    16072   ; *********************************************************************************************************
                    16073   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    16074   ; *
                    16075   ; * Description: This function is called to determine what state the timer is in:
                    16076   ; *
                    16077   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    16078   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    16079   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    16080   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    16081   ; *
                    16082   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    16083   ; *
                    16084   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16085   ; *                               OS_ERR_NONE
                    16086   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16087   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16088   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16089   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16090   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    16091   ; *
                    16092   ; * Returns    : The current state of the timer (see description).
                    16093   ; *********************************************************************************************************
                    16094   ; */
                    16095   ; #if OS_TMR_EN > 0u
                    16096   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    16097   ; INT8U   *perr)
                    16098   ; {
                    16099   _OSTmrStateGet:
0000541A  4E56 0000 16100          link      A6,#0
0000541E  48E7 3000 16101          movem.l   D2/D3,-(A7)
00005422  242E 000C 16102          move.l    12(A6),D2
                    16103   ; INT8U  state;
                    16104   ; #ifdef OS_SAFETY_CRITICAL
                    16105   ; if (perr == (INT8U *)0) {
                    16106   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16107   ; return (0u);
                    16108   ; }
                    16109   ; #endif
                    16110   ; #if OS_ARG_CHK_EN > 0u
                    16111   ; if (ptmr == (OS_TMR *)0) {
                    16112   ; *perr = OS_ERR_TMR_INVALID;
                    16113   ; return (0u);
                    16114   ; }
                    16115   ; #endif
                    16116   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005426  206E 0008 16117          move.l    8(A6),A0
0000542A  1010      16118          move.b    (A0),D0
0000542C  0C00 0064 16119          cmp.b     #100,D0
00005430  670C      16120          beq.s     OSTmrStateGet_1
                    16121   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005432  2042      16122          move.l    D2,A0
00005434  10BC 0089 16123          move.b    #137,(A0)
                    16124   ; return (0u);
00005438  4200      16125          clr.b     D0
0000543A  6000 005A 16126          bra       OSTmrStateGet_3
                    16127   OSTmrStateGet_1:
                    16128   ; }
                    16129   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
0000543E  1039 0800 16130          move.b    _OSIntNesting.L,D0
00005442  0426      
00005444  0C00 0000 16131          cmp.b     #0,D0
00005448  630C      16132          bls.s     OSTmrStateGet_4
                    16133   ; *perr = OS_ERR_TMR_ISR;
0000544A  2042      16134          move.l    D2,A0
0000544C  10BC 008B 16135          move.b    #139,(A0)
                    16136   ; return (0u);
00005450  4200      16137          clr.b     D0
00005452  6000 0042 16138          bra       OSTmrStateGet_3
                    16139   OSTmrStateGet_4:
                    16140   ; }
                    16141   ; OSSchedLock();
00005456  4EB8 0F08 16142          jsr       _OSSchedLock
                    16143   ; state = ptmr->OSTmrState;
0000545A  206E 0008 16144          move.l    8(A6),A0
0000545E  1628 0023 16145          move.b    35(A0),D3
                    16146   ; switch (state) {
00005462  C6BC 0000 16147          and.l     #255,D3
00005466  00FF      
00005468  2003      16148          move.l    D3,D0
0000546A  0C80 0000 16149          cmp.l     #4,D0
0000546E  0004      
00005470  6418      16150          bhs.s     OSTmrStateGet_6
00005472  E380      16151          asl.l     #1,D0
00005474  303B 0806 16152          move.w    OSTmrStateGet_8(PC,D0.L),D0
00005478  4EFB 0002 16153          jmp       OSTmrStateGet_8(PC,D0.W)
                    16154   OSTmrStateGet_8:
0000547C  0008      16155          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
0000547E  0008      16156          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
00005480  0008      16157          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
00005482  0008      16158          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16159   OSTmrStateGet_9:
                    16160   ; case OS_TMR_STATE_UNUSED:
                    16161   ; case OS_TMR_STATE_STOPPED:
                    16162   ; case OS_TMR_STATE_COMPLETED:
                    16163   ; case OS_TMR_STATE_RUNNING:
                    16164   ; *perr = OS_ERR_NONE;
00005484  2042      16165          move.l    D2,A0
00005486  4210      16166          clr.b     (A0)
                    16167   ; break;
00005488  6006      16168          bra.s     OSTmrStateGet_7
                    16169   OSTmrStateGet_6:
                    16170   ; default:
                    16171   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000548A  2042      16172          move.l    D2,A0
0000548C  10BC 008D 16173          move.b    #141,(A0)
                    16174   ; break;
                    16175   OSTmrStateGet_7:
                    16176   ; }
                    16177   ; OSSchedUnlock();
00005490  4EB8 0F38 16178          jsr       _OSSchedUnlock
                    16179   ; return (state);
00005494  1003      16180          move.b    D3,D0
                    16181   OSTmrStateGet_3:
00005496  4CDF 000C 16182          movem.l   (A7)+,D2/D3
0000549A  4E5E      16183          unlk      A6
0000549C  4E75      16184          rts
                    16185   ; }
                    16186   ; #endif
                    16187   ; /*$PAGE*/
                    16188   ; /*
                    16189   ; *********************************************************************************************************
                    16190   ; *                                            START A TIMER
                    16191   ; *
                    16192   ; * Description: This function is called by your application code to start a timer.
                    16193   ; *
                    16194   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16195   ; *
                    16196   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16197   ; *                               OS_ERR_NONE
                    16198   ; *                               OS_ERR_TMR_INVALID
                    16199   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16200   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16201   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16202   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16203   ; *
                    16204   ; * Returns    : OS_TRUE    if the timer was started
                    16205   ; *              OS_FALSE   if an error was detected
                    16206   ; *********************************************************************************************************
                    16207   ; */
                    16208   ; #if OS_TMR_EN > 0u
                    16209   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16210   ; INT8U    *perr)
                    16211   ; {
                    16212   _OSTmrStart:
0000549E  4E56 0000 16213          link      A6,#0
000054A2  48E7 3020 16214          movem.l   D2/D3/A2,-(A7)
000054A6  242E 000C 16215          move.l    12(A6),D2
000054AA  262E 0008 16216          move.l    8(A6),D3
000054AE  45F8 0F38 16217          lea       _OSSchedUnlock.L,A2
                    16218   ; #ifdef OS_SAFETY_CRITICAL
                    16219   ; if (perr == (INT8U *)0) {
                    16220   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16221   ; return (OS_FALSE);
                    16222   ; }
                    16223   ; #endif
                    16224   ; #if OS_ARG_CHK_EN > 0u
                    16225   ; if (ptmr == (OS_TMR *)0) {
                    16226   ; *perr = OS_ERR_TMR_INVALID;
                    16227   ; return (OS_FALSE);
                    16228   ; }
                    16229   ; #endif
                    16230   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000054B2  2043      16231          move.l    D3,A0
000054B4  1010      16232          move.b    (A0),D0
000054B6  0C00 0064 16233          cmp.b     #100,D0
000054BA  670C      16234          beq.s     OSTmrStart_1
                    16235   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000054BC  2042      16236          move.l    D2,A0
000054BE  10BC 0089 16237          move.b    #137,(A0)
                    16238   ; return (OS_FALSE);
000054C2  4200      16239          clr.b     D0
000054C4  6000 0094 16240          bra       OSTmrStart_3
                    16241   OSTmrStart_1:
                    16242   ; }
                    16243   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
000054C8  1039 0800 16244          move.b    _OSIntNesting.L,D0
000054CC  0426      
000054CE  0C00 0000 16245          cmp.b     #0,D0
000054D2  630C      16246          bls.s     OSTmrStart_4
                    16247   ; *perr  = OS_ERR_TMR_ISR;
000054D4  2042      16248          move.l    D2,A0
000054D6  10BC 008B 16249          move.b    #139,(A0)
                    16250   ; return (OS_FALSE);
000054DA  4200      16251          clr.b     D0
000054DC  6000 007C 16252          bra       OSTmrStart_3
                    16253   OSTmrStart_4:
                    16254   ; }
                    16255   ; OSSchedLock();
000054E0  4EB8 0F08 16256          jsr       _OSSchedLock
                    16257   ; switch (ptmr->OSTmrState) {
000054E4  2043      16258          move.l    D3,A0
000054E6  1028 0023 16259          move.b    35(A0),D0
000054EA  C0BC 0000 16260          and.l     #255,D0
000054EE  00FF      
000054F0  0C80 0000 16261          cmp.l     #4,D0
000054F4  0004      
000054F6  6400 0058 16262          bhs       OSTmrStart_6
000054FA  E380      16263          asl.l     #1,D0
000054FC  303B 0806 16264          move.w    OSTmrStart_8(PC,D0.L),D0
00005500  4EFB 0002 16265          jmp       OSTmrStart_8(PC,D0.W)
                    16266   OSTmrStart_8:
00005504  0040      16267          dc.w      OSTmrStart_12-OSTmrStart_8
00005506  002A      16268          dc.w      OSTmrStart_10-OSTmrStart_8
00005508  002A      16269          dc.w      OSTmrStart_10-OSTmrStart_8
0000550A  0008      16270          dc.w      OSTmrStart_9-OSTmrStart_8
                    16271   OSTmrStart_9:
                    16272   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16273   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
0000550C  2F03      16274          move.l    D3,-(A7)
0000550E  4EB9 0000 16275          jsr       @ucos_ii_OSTmr_Unlink
00005512  5996      
00005514  584F      16276          addq.w    #4,A7
                    16277   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005516  42A7      16278          clr.l     -(A7)
00005518  2F03      16279          move.l    D3,-(A7)
0000551A  4EB9 0000 16280          jsr       @ucos_ii_OSTmr_Link
0000551E  58C2      
00005520  504F      16281          addq.w    #8,A7
                    16282   ; OSSchedUnlock();
00005522  4E92      16283          jsr       (A2)
                    16284   ; *perr = OS_ERR_NONE;
00005524  2042      16285          move.l    D2,A0
00005526  4210      16286          clr.b     (A0)
                    16287   ; return (OS_TRUE);
00005528  7001      16288          moveq     #1,D0
0000552A  6000 002E 16289          bra       OSTmrStart_3
                    16290   OSTmrStart_10:
                    16291   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16292   ; case OS_TMR_STATE_COMPLETED:
                    16293   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
0000552E  42A7      16294          clr.l     -(A7)
00005530  2F03      16295          move.l    D3,-(A7)
00005532  4EB9 0000 16296          jsr       @ucos_ii_OSTmr_Link
00005536  58C2      
00005538  504F      16297          addq.w    #8,A7
                    16298   ; OSSchedUnlock();
0000553A  4E92      16299          jsr       (A2)
                    16300   ; *perr = OS_ERR_NONE;
0000553C  2042      16301          move.l    D2,A0
0000553E  4210      16302          clr.b     (A0)
                    16303   ; return (OS_TRUE);
00005540  7001      16304          moveq     #1,D0
00005542  6016      16305          bra.s     OSTmrStart_3
                    16306   OSTmrStart_12:
                    16307   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16308   ; OSSchedUnlock();
00005544  4E92      16309          jsr       (A2)
                    16310   ; *perr = OS_ERR_TMR_INACTIVE;
00005546  2042      16311          move.l    D2,A0
00005548  10BC 0087 16312          move.b    #135,(A0)
                    16313   ; return (OS_FALSE);
0000554C  4200      16314          clr.b     D0
0000554E  600A      16315          bra.s     OSTmrStart_3
                    16316   OSTmrStart_6:
                    16317   ; default:
                    16318   ; OSSchedUnlock();
00005550  4E92      16319          jsr       (A2)
                    16320   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005552  2042      16321          move.l    D2,A0
00005554  10BC 008D 16322          move.b    #141,(A0)
                    16323   ; return (OS_FALSE);
00005558  4200      16324          clr.b     D0
                    16325   OSTmrStart_3:
0000555A  4CDF 040C 16326          movem.l   (A7)+,D2/D3/A2
0000555E  4E5E      16327          unlk      A6
00005560  4E75      16328          rts
                    16329   ; }
                    16330   ; }
                    16331   ; #endif
                    16332   ; /*$PAGE*/
                    16333   ; /*
                    16334   ; *********************************************************************************************************
                    16335   ; *                                            STOP A TIMER
                    16336   ; *
                    16337   ; * Description: This function is called by your application code to stop a timer.
                    16338   ; *
                    16339   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16340   ; *
                    16341   ; *              opt           Allows you to specify an option to this functions which can be:
                    16342   ; *
                    16343   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16344   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16345   ; *                                                        callback argument specified when the timer 
                    16346   ; *                                                        was created.
                    16347   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16348   ; *                                                        callback argument specified in THIS function call.
                    16349   ; *
                    16350   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16351   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16352   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16353   ; *
                    16354   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16355   ; *                               OS_ERR_NONE
                    16356   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16357   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16358   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16359   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16360   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16361   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16362   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16363   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16364   ; *
                    16365   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16366   ; *              OS_FALSE      If not
                    16367   ; *********************************************************************************************************
                    16368   ; */
                    16369   ; #if OS_TMR_EN > 0u
                    16370   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16371   ; INT8U    opt,
                    16372   ; void    *callback_arg,
                    16373   ; INT8U   *perr)
                    16374   ; {
                    16375   _OSTmrStop:
00005562  4E56 0000 16376          link      A6,#0
00005566  48E7 3820 16377          movem.l   D2/D3/D4/A2,-(A7)
0000556A  242E 0014 16378          move.l    20(A6),D2
0000556E  262E 0008 16379          move.l    8(A6),D3
00005572  45F8 0F38 16380          lea       _OSSchedUnlock.L,A2
                    16381   ; OS_TMR_CALLBACK  pfnct;
                    16382   ; #ifdef OS_SAFETY_CRITICAL
                    16383   ; if (perr == (INT8U *)0) {
                    16384   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16385   ; return (OS_FALSE);
                    16386   ; }
                    16387   ; #endif
                    16388   ; #if OS_ARG_CHK_EN > 0u
                    16389   ; if (ptmr == (OS_TMR *)0) {
                    16390   ; *perr = OS_ERR_TMR_INVALID;
                    16391   ; return (OS_FALSE);
                    16392   ; }
                    16393   ; #endif
                    16394   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
00005576  2043      16395          move.l    D3,A0
00005578  1010      16396          move.b    (A0),D0
0000557A  0C00 0064 16397          cmp.b     #100,D0
0000557E  670C      16398          beq.s     OSTmrStop_1
                    16399   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005580  2042      16400          move.l    D2,A0
00005582  10BC 0089 16401          move.b    #137,(A0)
                    16402   ; return (OS_FALSE);
00005586  4200      16403          clr.b     D0
00005588  6000 00F2 16404          bra       OSTmrStop_3
                    16405   OSTmrStop_1:
                    16406   ; }
                    16407   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
0000558C  1039 0800 16408          move.b    _OSIntNesting.L,D0
00005590  0426      
00005592  0C00 0000 16409          cmp.b     #0,D0
00005596  630C      16410          bls.s     OSTmrStop_4
                    16411   ; *perr  = OS_ERR_TMR_ISR;
00005598  2042      16412          move.l    D2,A0
0000559A  10BC 008B 16413          move.b    #139,(A0)
                    16414   ; return (OS_FALSE);
0000559E  4200      16415          clr.b     D0
000055A0  6000 00DA 16416          bra       OSTmrStop_3
                    16417   OSTmrStop_4:
                    16418   ; }
                    16419   ; OSSchedLock();
000055A4  4EB8 0F08 16420          jsr       _OSSchedLock
                    16421   ; switch (ptmr->OSTmrState) {
000055A8  2043      16422          move.l    D3,A0
000055AA  1028 0023 16423          move.b    35(A0),D0
000055AE  C0BC 0000 16424          and.l     #255,D0
000055B2  00FF      
000055B4  0C80 0000 16425          cmp.l     #4,D0
000055B8  0004      
000055BA  6400 00B6 16426          bhs       OSTmrStop_6
000055BE  E380      16427          asl.l     #1,D0
000055C0  303B 0806 16428          move.w    OSTmrStop_8(PC,D0.L),D0
000055C4  4EFB 0002 16429          jmp       OSTmrStop_8(PC,D0.W)
                    16430   OSTmrStop_8:
000055C8  009E      16431          dc.w      OSTmrStop_12-OSTmrStop_8
000055CA  0092      16432          dc.w      OSTmrStop_10-OSTmrStop_8
000055CC  0092      16433          dc.w      OSTmrStop_10-OSTmrStop_8
000055CE  0008      16434          dc.w      OSTmrStop_9-OSTmrStop_8
                    16435   OSTmrStop_9:
                    16436   ; case OS_TMR_STATE_RUNNING:
                    16437   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
000055D0  2F03      16438          move.l    D3,-(A7)
000055D2  4EB9 0000 16439          jsr       @ucos_ii_OSTmr_Unlink
000055D6  5996      
000055D8  584F      16440          addq.w    #4,A7
                    16441   ; *perr = OS_ERR_NONE;
000055DA  2042      16442          move.l    D2,A0
000055DC  4210      16443          clr.b     (A0)
                    16444   ; switch (opt) {
000055DE  102E 000F 16445          move.b    15(A6),D0
000055E2  C0BC 0000 16446          and.l     #255,D0
000055E6  00FF      
000055E8  0C80 0000 16447          cmp.l     #3,D0
000055EC  0003      
000055EE  6718      16448          beq.s     OSTmrStop_16
000055F0  620A      16449          bhi.s     OSTmrStop_20
000055F2  4A80      16450          tst.l     D0
000055F4  6700 0056 16451          beq       OSTmrStop_18
000055F8  6000 0054 16452          bra       OSTmrStop_14
                    16453   OSTmrStop_20:
000055FC  0C80 0000 16454          cmp.l     #4,D0
00005600  0004      
00005602  6728      16455          beq.s     OSTmrStop_17
00005604  6000 0048 16456          bra       OSTmrStop_14
                    16457   OSTmrStop_16:
                    16458   ; case OS_TMR_OPT_CALLBACK:
                    16459   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005608  2043      16460          move.l    D3,A0
0000560A  2828 0002 16461          move.l    2(A0),D4
                    16462   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0000560E  4A84      16463          tst.l     D4
00005610  6710      16464          beq.s     OSTmrStop_21
                    16465   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
00005612  2043      16466          move.l    D3,A0
00005614  2F28 0006 16467          move.l    6(A0),-(A7)
00005618  2F03      16468          move.l    D3,-(A7)
0000561A  2044      16469          move.l    D4,A0
0000561C  4E90      16470          jsr       (A0)
0000561E  504F      16471          addq.w    #8,A7
00005620  6006      16472          bra.s     OSTmrStop_22
                    16473   OSTmrStop_21:
                    16474   ; } else {
                    16475   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005622  2042      16476          move.l    D2,A0
00005624  10BC 008F 16477          move.b    #143,(A0)
                    16478   OSTmrStop_22:
                    16479   ; }
                    16480   ; break;
00005628  6000 002A 16481          bra       OSTmrStop_15
                    16482   OSTmrStop_17:
                    16483   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16484   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000562C  2043      16485          move.l    D3,A0
0000562E  2828 0002 16486          move.l    2(A0),D4
                    16487   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005632  4A84      16488          tst.l     D4
00005634  670E      16489          beq.s     OSTmrStop_23
                    16490   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
00005636  2F2E 0010 16491          move.l    16(A6),-(A7)
0000563A  2F03      16492          move.l    D3,-(A7)
0000563C  2044      16493          move.l    D4,A0
0000563E  4E90      16494          jsr       (A0)
00005640  504F      16495          addq.w    #8,A7
00005642  6006      16496          bra.s     OSTmrStop_24
                    16497   OSTmrStop_23:
                    16498   ; } else {
                    16499   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005644  2042      16500          move.l    D2,A0
00005646  10BC 008F 16501          move.b    #143,(A0)
                    16502   OSTmrStop_24:
                    16503   ; }
                    16504   ; break;
0000564A  6008      16505          bra.s     OSTmrStop_15
                    16506   OSTmrStop_18:
                    16507   ; case OS_TMR_OPT_NONE:
                    16508   ; break;
0000564C  6006      16509          bra.s     OSTmrStop_15
                    16510   OSTmrStop_14:
                    16511   ; default:
                    16512   ; *perr = OS_ERR_TMR_INVALID_OPT;
0000564E  2042      16513          move.l    D2,A0
00005650  10BC 0084 16514          move.b    #132,(A0)
                    16515   ; break;
                    16516   OSTmrStop_15:
                    16517   ; }
                    16518   ; OSSchedUnlock();
00005654  4E92      16519          jsr       (A2)
                    16520   ; return (OS_TRUE);
00005656  7001      16521          moveq     #1,D0
00005658  6022      16522          bra.s     OSTmrStop_3
                    16523   OSTmrStop_10:
                    16524   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16525   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16526   ; OSSchedUnlock();
0000565A  4E92      16527          jsr       (A2)
                    16528   ; *perr = OS_ERR_TMR_STOPPED;
0000565C  2042      16529          move.l    D2,A0
0000565E  10BC 008E 16530          move.b    #142,(A0)
                    16531   ; return (OS_TRUE);
00005662  7001      16532          moveq     #1,D0
00005664  6016      16533          bra.s     OSTmrStop_3
                    16534   OSTmrStop_12:
                    16535   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16536   ; OSSchedUnlock();
00005666  4E92      16537          jsr       (A2)
                    16538   ; *perr = OS_ERR_TMR_INACTIVE;
00005668  2042      16539          move.l    D2,A0
0000566A  10BC 0087 16540          move.b    #135,(A0)
                    16541   ; return (OS_FALSE);
0000566E  4200      16542          clr.b     D0
00005670  600A      16543          bra.s     OSTmrStop_3
                    16544   OSTmrStop_6:
                    16545   ; default:
                    16546   ; OSSchedUnlock();
00005672  4E92      16547          jsr       (A2)
                    16548   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005674  2042      16549          move.l    D2,A0
00005676  10BC 008D 16550          move.b    #141,(A0)
                    16551   ; return (OS_FALSE);
0000567A  4200      16552          clr.b     D0
                    16553   OSTmrStop_3:
0000567C  4CDF 041C 16554          movem.l   (A7)+,D2/D3/D4/A2
00005680  4E5E      16555          unlk      A6
00005682  4E75      16556          rts
                    16557   ; }
                    16558   ; }
                    16559   ; #endif
                    16560   ; /*$PAGE*/
                    16561   ; /*
                    16562   ; *********************************************************************************************************
                    16563   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16564   ; *
                    16565   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16566   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16567   ; *
                    16568   ; * Arguments  : none
                    16569   ; *
                    16570   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16571   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16572   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16573   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16574   ; *                                  signaling is created by uC/OS-II.
                    16575   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16576   ; *                                  used for signaling is created by uC/OS-II.
                    16577   ; *********************************************************************************************************
                    16578   ; */
                    16579   ; #if OS_TMR_EN > 0u
                    16580   ; INT8U  OSTmrSignal (void)
                    16581   ; {
                    16582   _OSTmrSignal:
00005684  4E56 FFFC 16583          link      A6,#-4
                    16584   ; INT8U  err;
                    16585   ; err = OSSemPost(OSTmrSemSignal);
00005688  2F39 0800 16586          move.l    _OSTmrSemSignal.L,-(A7)
0000568C  0EA6      
0000568E  4EB8 41F4 16587          jsr       _OSSemPost
00005692  584F      16588          addq.w    #4,A7
00005694  1D40 FFFF 16589          move.b    D0,-1(A6)
                    16590   ; return (err);
00005698  102E FFFF 16591          move.b    -1(A6),D0
0000569C  4E5E      16592          unlk      A6
0000569E  4E75      16593          rts
                    16594   ; }
                    16595   ; #endif
                    16596   ; /*$PAGE*/
                    16597   ; /*
                    16598   ; *********************************************************************************************************
                    16599   ; *                                      ALLOCATE AND FREE A TIMER
                    16600   ; *
                    16601   ; * Description: This function is called to allocate a timer.
                    16602   ; *
                    16603   ; * Arguments  : none
                    16604   ; *
                    16605   ; * Returns    : a pointer to a timer if one is available
                    16606   ; *********************************************************************************************************
                    16607   ; */
                    16608   ; #if OS_TMR_EN > 0u
                    16609   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16610   ; {
                    16611   @ucos_ii_OSTmr_Alloc:
000056A0  48E7 2020 16612          movem.l   D2/A2,-(A7)
000056A4  45F9 0800 16613          lea       _OSTmrFreeList.L,A2
000056A8  10EA      
                    16614   ; OS_TMR *ptmr;
                    16615   ; if (OSTmrFreeList == (OS_TMR *)0) {
000056AA  2012      16616          move.l    (A2),D0
000056AC  6604      16617          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16618   ; return ((OS_TMR *)0);
000056AE  4280      16619          clr.l     D0
000056B0  6022      16620          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16621   @ucos_ii_OSTmr_Alloc_1:
                    16622   ; }
                    16623   ; ptmr            = (OS_TMR *)OSTmrFreeList;
000056B2  2412      16624          move.l    (A2),D2
                    16625   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
000056B4  2042      16626          move.l    D2,A0
000056B6  24A8 000A 16627          move.l    10(A0),(A2)
                    16628   ; ptmr->OSTmrNext = (OS_TCB *)0;
000056BA  2042      16629          move.l    D2,A0
000056BC  42A8 000A 16630          clr.l     10(A0)
                    16631   ; ptmr->OSTmrPrev = (OS_TCB *)0;
000056C0  2042      16632          move.l    D2,A0
000056C2  42A8 000E 16633          clr.l     14(A0)
                    16634   ; OSTmrUsed++;
000056C6  5279 0800 16635          addq.w    #1,_OSTmrUsed.L
000056CA  0E9C      
                    16636   ; OSTmrFree--;
000056CC  5379 0800 16637          subq.w    #1,_OSTmrFree.L
000056D0  0E9A      
                    16638   ; return (ptmr);
000056D2  2002      16639          move.l    D2,D0
                    16640   @ucos_ii_OSTmr_Alloc_3:
000056D4  4CDF 0404 16641          movem.l   (A7)+,D2/A2
000056D8  4E75      16642          rts
                    16643   ; }
                    16644   ; #endif
                    16645   ; /*
                    16646   ; *********************************************************************************************************
                    16647   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16648   ; *
                    16649   ; * Description: This function is called to return a timer object to the free list of timers.
                    16650   ; *
                    16651   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16652   ; *
                    16653   ; * Returns    : none
                    16654   ; *********************************************************************************************************
                    16655   ; */
                    16656   ; #if OS_TMR_EN > 0u
                    16657   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16658   ; {
                    16659   @ucos_ii_OSTmr_Free:
000056DA  4E56 0000 16660          link      A6,#0
000056DE  2F02      16661          move.l    D2,-(A7)
000056E0  242E 0008 16662          move.l    8(A6),D2
                    16663   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
000056E4  2042      16664          move.l    D2,A0
000056E6  4228 0023 16665          clr.b     35(A0)
                    16666   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
000056EA  2042      16667          move.l    D2,A0
000056EC  4228 0022 16668          clr.b     34(A0)
                    16669   ; ptmr->OSTmrPeriod      = 0u;
000056F0  2042      16670          move.l    D2,A0
000056F2  42A8 001A 16671          clr.l     26(A0)
                    16672   ; ptmr->OSTmrMatch       = 0u;
000056F6  2042      16673          move.l    D2,A0
000056F8  42A8 0012 16674          clr.l     18(A0)
                    16675   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
000056FC  2042      16676          move.l    D2,A0
000056FE  42A8 0002 16677          clr.l     2(A0)
                    16678   ; ptmr->OSTmrCallbackArg = (void *)0;
00005702  2042      16679          move.l    D2,A0
00005704  42A8 0006 16680          clr.l     6(A0)
                    16681   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16682   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
00005708  41F9 0000 16683          lea       @ucos_ii_1.L,A0
0000570C  763A      
0000570E  2242      16684          move.l    D2,A1
00005710  2348 001E 16685          move.l    A0,30(A1)
                    16686   ; #endif
                    16687   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00005714  2042      16688          move.l    D2,A0
00005716  42A8 000E 16689          clr.l     14(A0)
                    16690   ; ptmr->OSTmrNext        = OSTmrFreeList;
0000571A  2042      16691          move.l    D2,A0
0000571C  2179 0800 16692          move.l    _OSTmrFreeList.L,10(A0)
00005720  10EA 000A 
                    16693   ; OSTmrFreeList          = ptmr;
00005724  23C2 0800 16694          move.l    D2,_OSTmrFreeList.L
00005728  10EA      
                    16695   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
0000572A  5379 0800 16696          subq.w    #1,_OSTmrUsed.L
0000572E  0E9C      
                    16697   ; OSTmrFree++;
00005730  5279 0800 16698          addq.w    #1,_OSTmrFree.L
00005734  0E9A      
00005736  241F      16699          move.l    (A7)+,D2
00005738  4E5E      16700          unlk      A6
0000573A  4E75      16701          rts
                    16702   ; }
                    16703   ; #endif
                    16704   ; /*$PAGE*/
                    16705   ; /*
                    16706   ; *********************************************************************************************************
                    16707   ; *                                                    INITIALIZATION
                    16708   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16709   ; *
                    16710   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16711   ; *
                    16712   ; * Arguments  : none
                    16713   ; *
                    16714   ; * Returns    : none
                    16715   ; *********************************************************************************************************
                    16716   ; */
                    16717   ; #if OS_TMR_EN > 0u
                    16718   ; void  OSTmr_Init (void)
                    16719   ; {
                    16720   _OSTmr_Init:
0000573C  4E56 FFF8 16721          link      A6,#-8
00005740  48E7 3020 16722          movem.l   D2/D3/A2,-(A7)
00005744  45F9 0800 16723          lea       _OSTmrTbl.L,A2
00005748  0EAA      
                    16724   ; #if OS_EVENT_NAME_EN > 0u
                    16725   ; INT8U    err;
                    16726   ; #endif
                    16727   ; INT16U   ix;
                    16728   ; INT16U   ix_next;
                    16729   ; OS_TMR  *ptmr1;
                    16730   ; OS_TMR  *ptmr2;
                    16731   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
0000574A  4878 0240 16732          pea       576
0000574E  2F0A      16733          move.l    A2,-(A7)
00005750  4EB8 166C 16734          jsr       _OS_MemClr
00005754  504F      16735          addq.w    #8,A7
                    16736   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00005756  4878 0020 16737          pea       32
0000575A  4879 0800 16738          pea       _OSTmrWheelTbl.L
0000575E  11EE      
00005760  4EB8 166C 16739          jsr       _OS_MemClr
00005764  504F      16740          addq.w    #8,A7
                    16741   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
00005766  4243      16742          clr.w     D3
                    16743   OSTmr_Init_1:
00005768  0C43 000F 16744          cmp.w     #15,D3
0000576C  6400 0056 16745          bhs       OSTmr_Init_3
                    16746   ; ix_next = ix + 1u;
00005770  3003      16747          move.w    D3,D0
00005772  5240      16748          addq.w    #1,D0
00005774  3D40 FFFA 16749          move.w    D0,-6(A6)
                    16750   ; ptmr1 = &OSTmrTbl[ix];
00005778  200A      16751          move.l    A2,D0
0000577A  C6BC 0000 16752          and.l     #65535,D3
0000577E  FFFF      
00005780  2203      16753          move.l    D3,D1
00005782  C3FC 0024 16754          muls      #36,D1
00005786  D081      16755          add.l     D1,D0
00005788  2400      16756          move.l    D0,D2
                    16757   ; ptmr2 = &OSTmrTbl[ix_next];
0000578A  200A      16758          move.l    A2,D0
0000578C  322E FFFA 16759          move.w    -6(A6),D1
00005790  C2BC 0000 16760          and.l     #65535,D1
00005794  FFFF      
00005796  C3FC 0024 16761          muls      #36,D1
0000579A  D081      16762          add.l     D1,D0
0000579C  2D40 FFFC 16763          move.l    D0,-4(A6)
                    16764   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000057A0  2042      16765          move.l    D2,A0
000057A2  10BC 0064 16766          move.b    #100,(A0)
                    16767   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000057A6  2042      16768          move.l    D2,A0
000057A8  4228 0023 16769          clr.b     35(A0)
                    16770   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
000057AC  2042      16771          move.l    D2,A0
000057AE  216E FFFC 16772          move.l    -4(A6),10(A0)
000057B2  000A      
                    16773   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16774   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
000057B4  41F9 0000 16775          lea       @ucos_ii_1.L,A0
000057B8  763A      
000057BA  2242      16776          move.l    D2,A1
000057BC  2348 001E 16777          move.l    A0,30(A1)
000057C0  5243      16778          addq.w    #1,D3
000057C2  60A4      16779          bra       OSTmr_Init_1
                    16780   OSTmr_Init_3:
                    16781   ; #endif
                    16782   ; }
                    16783   ; ptmr1               = &OSTmrTbl[ix];
000057C4  200A      16784          move.l    A2,D0
000057C6  C6BC 0000 16785          and.l     #65535,D3
000057CA  FFFF      
000057CC  2203      16786          move.l    D3,D1
000057CE  C3FC 0024 16787          muls      #36,D1
000057D2  D081      16788          add.l     D1,D0
000057D4  2400      16789          move.l    D0,D2
                    16790   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000057D6  2042      16791          move.l    D2,A0
000057D8  10BC 0064 16792          move.b    #100,(A0)
                    16793   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
000057DC  2042      16794          move.l    D2,A0
000057DE  4228 0023 16795          clr.b     35(A0)
                    16796   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
000057E2  2042      16797          move.l    D2,A0
000057E4  42A8 000A 16798          clr.l     10(A0)
                    16799   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16800   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
000057E8  41F9 0000 16801          lea       @ucos_ii_1.L,A0
000057EC  763A      
000057EE  2242      16802          move.l    D2,A1
000057F0  2348 001E 16803          move.l    A0,30(A1)
                    16804   ; #endif
                    16805   ; OSTmrTime           = 0u;
000057F4  42B9 0800 16806          clr.l     _OSTmrTime.L
000057F8  0E9E      
                    16807   ; OSTmrUsed           = 0u;
000057FA  4279 0800 16808          clr.w     _OSTmrUsed.L
000057FE  0E9C      
                    16809   ; OSTmrFree           = OS_TMR_CFG_MAX;
00005800  33FC 0010 16810          move.w    #16,_OSTmrFree.L
00005804  0800 0E9A 
                    16811   ; OSTmrFreeList       = &OSTmrTbl[0];
00005808  23CA 0800 16812          move.l    A2,_OSTmrFreeList.L
0000580C  10EA      
                    16813   ; OSTmrSem            = OSSemCreate(1u);
0000580E  4878 0001 16814          pea       1
00005812  4EB8 3EAC 16815          jsr       _OSSemCreate
00005816  584F      16816          addq.w    #4,A7
00005818  23C0 0800 16817          move.l    D0,_OSTmrSem.L
0000581C  0EA2      
                    16818   ; OSTmrSemSignal      = OSSemCreate(0u);
0000581E  42A7      16819          clr.l     -(A7)
00005820  4EB8 3EAC 16820          jsr       _OSSemCreate
00005824  584F      16821          addq.w    #4,A7
00005826  23C0 0800 16822          move.l    D0,_OSTmrSemSignal.L
0000582A  0EA6      
                    16823   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    16824   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
0000582C  486E FFF9 16825          pea       -7(A6)
00005830  4879 0000 16826          pea       @ucos_ii_4.L
00005834  7658      
00005836  2F39 0800 16827          move.l    _OSTmrSem.L,-(A7)
0000583A  0EA2      
0000583C  4EB8 0A7A 16828          jsr       _OSEventNameSet
00005840  DEFC 000C 16829          add.w     #12,A7
                    16830   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
00005844  486E FFF9 16831          pea       -7(A6)
00005848  4879 0000 16832          pea       @ucos_ii_5.L
0000584C  766A      
0000584E  2F39 0800 16833          move.l    _OSTmrSemSignal.L,-(A7)
00005852  0EA6      
00005854  4EB8 0A7A 16834          jsr       _OSEventNameSet
00005858  DEFC 000C 16835          add.w     #12,A7
                    16836   ; #endif
                    16837   ; OSTmr_InitTask();
0000585C  4EB9 0000 16838          jsr       @ucos_ii_OSTmr_InitTask
00005860  586A      
00005862  4CDF 040C 16839          movem.l   (A7)+,D2/D3/A2
00005866  4E5E      16840          unlk      A6
00005868  4E75      16841          rts
                    16842   ; }
                    16843   ; #endif
                    16844   ; /*$PAGE*/
                    16845   ; /*
                    16846   ; *********************************************************************************************************
                    16847   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    16848   ; *
                    16849   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    16850   ; *                               * Arguments  : none
                    16851   ; *
                    16852   ; * Returns    : none
                    16853   ; *********************************************************************************************************
                    16854   ; */
                    16855   ; #if OS_TMR_EN > 0u
                    16856   ; static  void  OSTmr_InitTask (void)
                    16857   ; {
                    16858   @ucos_ii_OSTmr_InitTask:
0000586A  4E56 FFFC 16859          link      A6,#-4
                    16860   ; #if OS_TASK_NAME_EN > 0u
                    16861   ; INT8U  err;
                    16862   ; #endif
                    16863   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    16864   ; #if OS_STK_GROWTH == 1u
                    16865   ; (void)OSTaskCreateExt(OSTmr_Task,
0000586E  4878 0003 16866          pea       3
00005872  42A7      16867          clr.l     -(A7)
00005874  4878 0080 16868          pea       128
00005878  4879 0800 16869          pea       _OSTmrTaskStk.L
0000587C  10EE      
0000587E  4878 FFFD 16870          pea       65533
00005882  4878 0005 16871          pea       5
00005886  41F9 0800 16872          lea       _OSTmrTaskStk.L,A0
0000588A  10EE      
0000588C  D0FC 00FE 16873          add.w     #254,A0
00005890  2F08      16874          move.l    A0,-(A7)
00005892  42A7      16875          clr.l     -(A7)
00005894  4879 0000 16876          pea       @ucos_ii_OSTmr_Task.L
00005898  5A34      
0000589A  4EB8 4622 16877          jsr       _OSTaskCreateExt
0000589E  DEFC 0024 16878          add.w     #36,A7
000058A2  C0BC 0000 16879          and.l     #255,D0
000058A6  00FF      
                    16880   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16881   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    16882   ; OS_TASK_TMR_PRIO,
                    16883   ; OS_TASK_TMR_ID,
                    16884   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    16885   ; OS_TASK_TMR_STK_SIZE,
                    16886   ; (void *)0,                                       /* No TCB extension                        */
                    16887   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16888   ; #else
                    16889   ; (void)OSTaskCreateExt(OSTmr_Task,
                    16890   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16891   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    16892   ; OS_TASK_TMR_PRIO,
                    16893   ; OS_TASK_TMR_ID,
                    16894   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    16895   ; OS_TASK_TMR_STK_SIZE,
                    16896   ; (void *)0,                                       /* No TCB extension                        */
                    16897   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16898   ; #endif
                    16899   ; #else
                    16900   ; #if OS_STK_GROWTH == 1u
                    16901   ; (void)OSTaskCreate(OSTmr_Task,
                    16902   ; (void *)0,
                    16903   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    16904   ; OS_TASK_TMR_PRIO);
                    16905   ; #else
                    16906   ; (void)OSTaskCreate(OSTmr_Task,
                    16907   ; (void *)0,
                    16908   ; &OSTmrTaskStk[0],
                    16909   ; OS_TASK_TMR_PRIO);
                    16910   ; #endif
                    16911   ; #endif
                    16912   ; #if OS_TASK_NAME_EN > 0u
                    16913   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
000058A8  486E FFFF 16914          pea       -1(A6)
000058AC  4879 0000 16915          pea       @ucos_ii_6.L
000058B0  767E      
000058B2  4878 0005 16916          pea       5
000058B6  4EB8 4A2E 16917          jsr       _OSTaskNameSet
000058BA  DEFC 000C 16918          add.w     #12,A7
000058BE  4E5E      16919          unlk      A6
000058C0  4E75      16920          rts
                    16921   ; #endif
                    16922   ; }
                    16923   ; #endif
                    16924   ; /*$PAGE*/
                    16925   ; /*
                    16926   ; *********************************************************************************************************
                    16927   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    16928   ; *
                    16929   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    16930   ; *              inserted at the beginning of the list.
                    16931   ; *
                    16932   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    16933   ; *
                    16934   ; *              type          Is either:
                    16935   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    16936   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    16937   ; *
                    16938   ; * Returns    : none
                    16939   ; *********************************************************************************************************
                    16940   ; */
                    16941   ; #if OS_TMR_EN > 0u
                    16942   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    16943   ; INT8U    type)
                    16944   ; {
                    16945   @ucos_ii_OSTmr_Link:
000058C2  4E56 FFFC 16946          link      A6,#-4
000058C6  48E7 3820 16947          movem.l   D2/D3/D4/A2,-(A7)
000058CA  242E 0008 16948          move.l    8(A6),D2
000058CE  45F9 0800 16949          lea       _OSTmrTime.L,A2
000058D2  0E9E      
                    16950   ; OS_TMR       *ptmr1;
                    16951   ; OS_TMR_WHEEL *pspoke;
                    16952   ; INT16U        spoke;
                    16953   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
000058D4  2042      16954          move.l    D2,A0
000058D6  117C 0003 16955          move.b    #3,35(A0)
000058DA  0023      
                    16956   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
000058DC  102E 000F 16957          move.b    15(A6),D0
000058E0  0C00 0001 16958          cmp.b     #1,D0
000058E4  6610      16959          bne.s     @ucos_ii_OSTmr_Link_1
                    16960   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
000058E6  2042      16961          move.l    D2,A0
000058E8  2028 001A 16962          move.l    26(A0),D0
000058EC  D092      16963          add.l     (A2),D0
000058EE  2042      16964          move.l    D2,A0
000058F0  2140 0012 16965          move.l    D0,18(A0)
000058F4  6026      16966          bra.s     @ucos_ii_OSTmr_Link_4
                    16967   @ucos_ii_OSTmr_Link_1:
                    16968   ; } else {
                    16969   ; if (ptmr->OSTmrDly == 0u) {
000058F6  2042      16970          move.l    D2,A0
000058F8  2028 0016 16971          move.l    22(A0),D0
000058FC  6610      16972          bne.s     @ucos_ii_OSTmr_Link_3
                    16973   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
000058FE  2042      16974          move.l    D2,A0
00005900  2028 001A 16975          move.l    26(A0),D0
00005904  D092      16976          add.l     (A2),D0
00005906  2042      16977          move.l    D2,A0
00005908  2140 0012 16978          move.l    D0,18(A0)
0000590C  600E      16979          bra.s     @ucos_ii_OSTmr_Link_4
                    16980   @ucos_ii_OSTmr_Link_3:
                    16981   ; } else {
                    16982   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
0000590E  2042      16983          move.l    D2,A0
00005910  2028 0016 16984          move.l    22(A0),D0
00005914  D092      16985          add.l     (A2),D0
00005916  2042      16986          move.l    D2,A0
00005918  2140 0012 16987          move.l    D0,18(A0)
                    16988   @ucos_ii_OSTmr_Link_4:
                    16989   ; }
                    16990   ; }
                    16991   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0000591C  2002      16992          move.l    D2,D0
0000591E  0680 0000 16993          add.l     #18,D0
00005922  0012      
00005924  2040      16994          move.l    D0,A0
00005926  2F10      16995          move.l    (A0),-(A7)
00005928  4878 0008 16996          pea       8
0000592C  4EB9 0000 16997          jsr       ULDIV
00005930  6B3C      
00005932  202F 0004 16998          move.l    4(A7),D0
00005936  504F      16999          addq.w    #8,A7
00005938  3D40 FFFE 17000          move.w    D0,-2(A6)
                    17001   ; pspoke = &OSTmrWheelTbl[spoke];
0000593C  41F9 0800 17002          lea       _OSTmrWheelTbl.L,A0
00005940  11EE      
00005942  302E FFFE 17003          move.w    -2(A6),D0
00005946  C0BC 0000 17004          and.l     #65535,D0
0000594A  FFFF      
0000594C  E588      17005          lsl.l     #2,D0
0000594E  D1C0      17006          add.l     D0,A0
00005950  2608      17007          move.l    A0,D3
                    17008   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005952  2043      17009          move.l    D3,A0
00005954  2010      17010          move.l    (A0),D0
00005956  6614      17011          bne.s     @ucos_ii_OSTmr_Link_5
                    17012   ; pspoke->OSTmrFirst   = ptmr;
00005958  2043      17013          move.l    D3,A0
0000595A  2082      17014          move.l    D2,(A0)
                    17015   ; ptmr->OSTmrNext      = (OS_TMR *)0;
0000595C  2042      17016          move.l    D2,A0
0000595E  42A8 000A 17017          clr.l     10(A0)
                    17018   ; pspoke->OSTmrEntries = 1u;
00005962  2043      17019          move.l    D3,A0
00005964  317C 0001 17020          move.w    #1,4(A0)
00005968  0004      
0000596A  601C      17021          bra.s     @ucos_ii_OSTmr_Link_6
                    17022   @ucos_ii_OSTmr_Link_5:
                    17023   ; } else {
                    17024   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
0000596C  2043      17025          move.l    D3,A0
0000596E  2810      17026          move.l    (A0),D4
                    17027   ; pspoke->OSTmrFirst   = ptmr;
00005970  2043      17028          move.l    D3,A0
00005972  2082      17029          move.l    D2,(A0)
                    17030   ; ptmr->OSTmrNext      = (void *)ptmr1;
00005974  2042      17031          move.l    D2,A0
00005976  2144 000A 17032          move.l    D4,10(A0)
                    17033   ; ptmr1->OSTmrPrev     = (void *)ptmr;
0000597A  2044      17034          move.l    D4,A0
0000597C  2142 000E 17035          move.l    D2,14(A0)
                    17036   ; pspoke->OSTmrEntries++;
00005980  2003      17037          move.l    D3,D0
00005982  5880      17038          addq.l    #4,D0
00005984  2040      17039          move.l    D0,A0
00005986  5250      17040          addq.w    #1,(A0)
                    17041   @ucos_ii_OSTmr_Link_6:
                    17042   ; }
                    17043   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005988  2042      17044          move.l    D2,A0
0000598A  42A8 000E 17045          clr.l     14(A0)
0000598E  4CDF 041C 17046          movem.l   (A7)+,D2/D3/D4/A2
00005992  4E5E      17047          unlk      A6
00005994  4E75      17048          rts
                    17049   ; }
                    17050   ; #endif
                    17051   ; /*$PAGE*/
                    17052   ; /*
                    17053   ; *********************************************************************************************************
                    17054   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    17055   ; *
                    17056   ; * Description: This function is called to remove the timer from the timer wheel.
                    17057   ; *
                    17058   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    17059   ; *
                    17060   ; * Returns    : none
                    17061   ; *********************************************************************************************************
                    17062   ; */
                    17063   ; #if OS_TMR_EN > 0u
                    17064   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    17065   ; {
                    17066   @ucos_ii_OSTmr_Unlink:
00005996  4E56 FFFC 17067          link      A6,#-4
0000599A  48E7 3C00 17068          movem.l   D2/D3/D4/D5,-(A7)
0000599E  242E 0008 17069          move.l    8(A6),D2
                    17070   ; OS_TMR        *ptmr1;
                    17071   ; OS_TMR        *ptmr2;
                    17072   ; OS_TMR_WHEEL  *pspoke;
                    17073   ; INT16U         spoke;
                    17074   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000059A2  2002      17075          move.l    D2,D0
000059A4  0680 0000 17076          add.l     #18,D0
000059A8  0012      
000059AA  2040      17077          move.l    D0,A0
000059AC  2F10      17078          move.l    (A0),-(A7)
000059AE  4878 0008 17079          pea       8
000059B2  4EB9 0000 17080          jsr       ULDIV
000059B6  6B3C      
000059B8  202F 0004 17081          move.l    4(A7),D0
000059BC  504F      17082          addq.w    #8,A7
000059BE  3D40 FFFE 17083          move.w    D0,-2(A6)
                    17084   ; pspoke = &OSTmrWheelTbl[spoke];
000059C2  41F9 0800 17085          lea       _OSTmrWheelTbl.L,A0
000059C6  11EE      
000059C8  302E FFFE 17086          move.w    -2(A6),D0
000059CC  C0BC 0000 17087          and.l     #65535,D0
000059D0  FFFF      
000059D2  E588      17088          lsl.l     #2,D0
000059D4  D1C0      17089          add.l     D0,A0
000059D6  2A08      17090          move.l    A0,D5
                    17091   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
000059D8  2045      17092          move.l    D5,A0
000059DA  B490      17093          cmp.l     (A0),D2
000059DC  6616      17094          bne.s     @ucos_ii_OSTmr_Unlink_1
                    17095   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
000059DE  2042      17096          move.l    D2,A0
000059E0  2628 000A 17097          move.l    10(A0),D3
                    17098   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
000059E4  2045      17099          move.l    D5,A0
000059E6  2083      17100          move.l    D3,(A0)
                    17101   ; if (ptmr1 != (OS_TMR *)0) {
000059E8  4A83      17102          tst.l     D3
000059EA  6706      17103          beq.s     @ucos_ii_OSTmr_Unlink_3
                    17104   ; ptmr1->OSTmrPrev = (void *)0;
000059EC  2043      17105          move.l    D3,A0
000059EE  42A8 000E 17106          clr.l     14(A0)
                    17107   @ucos_ii_OSTmr_Unlink_3:
000059F2  601C      17108          bra.s     @ucos_ii_OSTmr_Unlink_5
                    17109   @ucos_ii_OSTmr_Unlink_1:
                    17110   ; }
                    17111   ; } else {
                    17112   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
000059F4  2042      17113          move.l    D2,A0
000059F6  2628 000E 17114          move.l    14(A0),D3
                    17115   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
000059FA  2042      17116          move.l    D2,A0
000059FC  2828 000A 17117          move.l    10(A0),D4
                    17118   ; ptmr1->OSTmrNext = ptmr2;
00005A00  2043      17119          move.l    D3,A0
00005A02  2144 000A 17120          move.l    D4,10(A0)
                    17121   ; if (ptmr2 != (OS_TMR *)0) {
00005A06  4A84      17122          tst.l     D4
00005A08  6706      17123          beq.s     @ucos_ii_OSTmr_Unlink_5
                    17124   ; ptmr2->OSTmrPrev = (void *)ptmr1;
00005A0A  2044      17125          move.l    D4,A0
00005A0C  2143 000E 17126          move.l    D3,14(A0)
                    17127   @ucos_ii_OSTmr_Unlink_5:
                    17128   ; }
                    17129   ; }
                    17130   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005A10  2042      17131          move.l    D2,A0
00005A12  117C 0001 17132          move.b    #1,35(A0)
00005A16  0023      
                    17133   ; ptmr->OSTmrNext  = (void *)0;
00005A18  2042      17134          move.l    D2,A0
00005A1A  42A8 000A 17135          clr.l     10(A0)
                    17136   ; ptmr->OSTmrPrev  = (void *)0;
00005A1E  2042      17137          move.l    D2,A0
00005A20  42A8 000E 17138          clr.l     14(A0)
                    17139   ; pspoke->OSTmrEntries--;
00005A24  2005      17140          move.l    D5,D0
00005A26  5880      17141          addq.l    #4,D0
00005A28  2040      17142          move.l    D0,A0
00005A2A  5350      17143          subq.w    #1,(A0)
00005A2C  4CDF 003C 17144          movem.l   (A7)+,D2/D3/D4/D5
00005A30  4E5E      17145          unlk      A6
00005A32  4E75      17146          rts
                    17147   ; }
                    17148   ; #endif
                    17149   ; /*$PAGE*/
                    17150   ; /*
                    17151   ; *********************************************************************************************************
                    17152   ; *                                        TIMER MANAGEMENT TASK
                    17153   ; *
                    17154   ; * Description: This task is created by OSTmrInit().
                    17155   ; *
                    17156   ; * Arguments  : none
                    17157   ; *
                    17158   ; * Returns    : none
                    17159   ; *********************************************************************************************************
                    17160   ; */
                    17161   ; #if OS_TMR_EN > 0u
                    17162   ; static  void  OSTmr_Task (void *p_arg)
                    17163   ; {
                    17164   @ucos_ii_OSTmr_Task:
00005A34  4E56 FFF4 17165          link      A6,#-12
00005A38  48E7 3020 17166          movem.l   D2/D3/A2,-(A7)
00005A3C  45F9 0800 17167          lea       _OSTmrTime.L,A2
00005A40  0E9E      
                    17168   ; INT8U            err;
                    17169   ; OS_TMR          *ptmr;
                    17170   ; OS_TMR          *ptmr_next;
                    17171   ; OS_TMR_CALLBACK  pfnct;
                    17172   ; OS_TMR_WHEEL    *pspoke;
                    17173   ; INT16U           spoke;
                    17174   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17175   ; for (;;) {
                    17176   @ucos_ii_OSTmr_Task_1:
                    17177   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005A42  486E FFF5 17178          pea       -11(A6)
00005A46  42A7      17179          clr.l     -(A7)
00005A48  2F39 0800 17180          move.l    _OSTmrSemSignal.L,-(A7)
00005A4C  0EA6      
00005A4E  4EB8 4032 17181          jsr       _OSSemPend
00005A52  DEFC 000C 17182          add.w     #12,A7
                    17183   ; OSSchedLock();
00005A56  4EB8 0F08 17184          jsr       _OSSchedLock
                    17185   ; OSTmrTime++;                                             /* Increment the current time                        */
00005A5A  5292      17186          addq.l    #1,(A2)
                    17187   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
00005A5C  2F12      17188          move.l    (A2),-(A7)
00005A5E  4878 0008 17189          pea       8
00005A62  4EB9 0000 17190          jsr       ULDIV
00005A66  6B3C      
00005A68  202F 0004 17191          move.l    4(A7),D0
00005A6C  504F      17192          addq.w    #8,A7
00005A6E  3D40 FFFE 17193          move.w    D0,-2(A6)
                    17194   ; pspoke = &OSTmrWheelTbl[spoke];
00005A72  41F9 0800 17195          lea       _OSTmrWheelTbl.L,A0
00005A76  11EE      
00005A78  302E FFFE 17196          move.w    -2(A6),D0
00005A7C  C0BC 0000 17197          and.l     #65535,D0
00005A80  FFFF      
00005A82  E588      17198          lsl.l     #2,D0
00005A84  D1C0      17199          add.l     D0,A0
00005A86  2D48 FFFA 17200          move.l    A0,-6(A6)
                    17201   ; ptmr   = pspoke->OSTmrFirst;
00005A8A  206E FFFA 17202          move.l    -6(A6),A0
00005A8E  2410      17203          move.l    (A0),D2
                    17204   ; while (ptmr != (OS_TMR *)0) {
                    17205   @ucos_ii_OSTmr_Task_4:
00005A90  4A82      17206          tst.l     D2
00005A92  6700 005E 17207          beq       @ucos_ii_OSTmr_Task_6
                    17208   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
00005A96  2042      17209          move.l    D2,A0
00005A98  2D68 000A 17210          move.l    10(A0),-10(A6)
00005A9C  FFF6      
                    17211   ; /* ... timer could get unlinked from the wheel.      */
                    17212   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
00005A9E  2042      17213          move.l    D2,A0
00005AA0  2012      17214          move.l    (A2),D0
00005AA2  B0A8 0012 17215          cmp.l     18(A0),D0
00005AA6  6600 0044 17216          bne       @ucos_ii_OSTmr_Task_11
                    17217   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
00005AAA  2F02      17218          move.l    D2,-(A7)
00005AAC  4EB8 5996 17219          jsr       @ucos_ii_OSTmr_Unlink
00005AB0  584F      17220          addq.w    #4,A7
                    17221   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
00005AB2  2042      17222          move.l    D2,A0
00005AB4  1028 0022 17223          move.b    34(A0),D0
00005AB8  0C00 0002 17224          cmp.b     #2,D0
00005ABC  660E      17225          bne.s     @ucos_ii_OSTmr_Task_9
                    17226   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
00005ABE  4878 0001 17227          pea       1
00005AC2  2F02      17228          move.l    D2,-(A7)
00005AC4  4EB8 58C2 17229          jsr       @ucos_ii_OSTmr_Link
00005AC8  504F      17230          addq.w    #8,A7
00005ACA  6008      17231          bra.s     @ucos_ii_OSTmr_Task_10
                    17232   @ucos_ii_OSTmr_Task_9:
                    17233   ; } else {
                    17234   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00005ACC  2042      17235          move.l    D2,A0
00005ACE  117C 0002 17236          move.b    #2,35(A0)
00005AD2  0023      
                    17237   @ucos_ii_OSTmr_Task_10:
                    17238   ; }
                    17239   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005AD4  2042      17240          move.l    D2,A0
00005AD6  2628 0002 17241          move.l    2(A0),D3
                    17242   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005ADA  4A83      17243          tst.l     D3
00005ADC  670E      17244          beq.s     @ucos_ii_OSTmr_Task_11
                    17245   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
00005ADE  2042      17246          move.l    D2,A0
00005AE0  2F28 0006 17247          move.l    6(A0),-(A7)
00005AE4  2F02      17248          move.l    D2,-(A7)
00005AE6  2043      17249          move.l    D3,A0
00005AE8  4E90      17250          jsr       (A0)
00005AEA  504F      17251          addq.w    #8,A7
                    17252   @ucos_ii_OSTmr_Task_11:
                    17253   ; }
                    17254   ; }
                    17255   ; ptmr = ptmr_next;
00005AEC  242E FFF6 17256          move.l    -10(A6),D2
00005AF0  609E      17257          bra       @ucos_ii_OSTmr_Task_4
                    17258   @ucos_ii_OSTmr_Task_6:
                    17259   ; }
                    17260   ; OSSchedUnlock();
00005AF2  4EB8 0F38 17261          jsr       _OSSchedUnlock
00005AF6  6000 FF4A 17262          bra       @ucos_ii_OSTmr_Task_1
                    17263   ; /*
                    17264   ; *********************************************************************************************************
                    17265   ; *                                                uC/OS-II
                    17266   ; *                                          The Real-Time Kernel
                    17267   ; *
                    17268   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17269   ; *                                           All Rights Reserved
                    17270   ; *
                    17271   ; * File    : uCOS_II.C
                    17272   ; * By      : Jean J. Labrosse
                    17273   ; * Version : V2.91
                    17274   ; *
                    17275   ; * LICENSING TERMS:
                    17276   ; * ---------------
                    17277   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17278   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriï¿½m to properly license 
                    17279   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17280   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17281   ; * licensing fee.
                    17282   ; *********************************************************************************************************
                    17283   ; */
                    17284   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17285   ; #include "ucos_ii.h"
                    17286   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17287   ; #include "os_core.c"
                    17288   ; #include "os_flag.c"
                    17289   ; #include "os_mbox.c"
                    17290   ; #include "os_mem.c"
                    17291   ; #include "os_mutex.c"
                    17292   ; #include "os_q.c"
                    17293   ; #include "os_sem.c"
                    17294   ; #include "os_task.c"
                    17295   ; #include "os_time.c"
                    17296   ; #include "os_tmr.c"
                    17297   ; C:\CPEN412\ASN6\ASN6B_INTERRUPTS\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17298   ; #include "Bios.h"
                    17299   ; /*
                    17300   ; **  These basic IO routines are designed to handle input and output of characters
                    17301   ; **  via the serial port to the console of hyperternal
                    17302   ; **
                    17303   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17304   ; */
                    17305   ; // things that need to be done at initialisation/boot include
                    17306   ; // 1) initialise serial port and LCD display
                    17307   ; // 2) initialise the LCD display
                    17308   ; // 3) install the trap handler for a context switch (trap0)
                    17309   ; // 4) install the TickISR for level 3 IRQ
                    17310   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17311   ; /*********************************************************************************************
                    17312   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17313   ; *********************************************************************************************/
                    17314   ; void Init_RS232(void)
                    17315   ; {
                    17316   _Init_RS232:
                    17317   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00005AFA  13FC 0015 17318          move.b    #21,4194368
00005AFE  0040 0040 
                    17319   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00005B02  13FC 0001 17320          move.b    #1,4194372
00005B06  0040 0044 
00005B0A  4E75      17321          rts
                    17322   ; }
                    17323   ; int kbhit(void)
                    17324   ; {
                    17325   _kbhit:
                    17326   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
00005B0C  1039 0040 17327          move.b    4194368,D0
00005B10  0040      
00005B12  C03C 0002 17328          and.b     #2,D0
00005B16  0C00 0002 17329          cmp.b     #2,D0
00005B1A  6604      17330          bne.s     kbhit_1
                    17331   ; return 1 ;
00005B1C  7001      17332          moveq     #1,D0
00005B1E  6002      17333          bra.s     kbhit_3
                    17334   kbhit_1:
                    17335   ; else
                    17336   ; return 0 ;
00005B20  4280      17337          clr.l     D0
                    17338   kbhit_3:
00005B22  4E75      17339          rts
                    17340   ; }
                    17341   ; /*********************************************************************************************************
                    17342   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17343   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17344   ; **  to allow the board to communicate with HyperTerminal Program
                    17345   ; **
                    17346   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17347   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17348   ; **  call _putch() also
                    17349   ; *********************************************************************************************************/
                    17350   ; int _putch( int c)
                    17351   ; {
                    17352   __putch:
00005B24  4E56 0000 17353          link      A6,#0
                    17354   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17355   _putch_1:
00005B28  1039 0040 17356          move.b    4194368,D0
00005B2C  0040      
00005B2E  C03C 0002 17357          and.b     #2,D0
00005B32  0C00 0002 17358          cmp.b     #2,D0
00005B36  6702      17359          beq.s     _putch_3
00005B38  60EE      17360          bra       _putch_1
                    17361   _putch_3:
                    17362   ; ;
                    17363   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00005B3A  202E 0008 17364          move.l    8(A6),D0
00005B3E  C03C 007F 17365          and.b     #127,D0
00005B42  13C0 0040 17366          move.b    D0,4194370
00005B46  0042      
                    17367   ; return c ;                                              // putchar() expects the character to be returned
00005B48  202E 0008 17368          move.l    8(A6),D0
00005B4C  4E5E      17369          unlk      A6
00005B4E  4E75      17370          rts
                    17371   ; }
                    17372   ; /*********************************************************************************************************
                    17373   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17374   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17375   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17376   ; **
                    17377   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17378   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17379   ; **  call _getch() also
                    17380   ; *********************************************************************************************************/
                    17381   ; int _getch( void )
                    17382   ; {
                    17383   __getch:
00005B50  2F02      17384          move.l    D2,-(A7)
                    17385   ; int c ;
                    17386   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17387   _getch_1:
00005B52  1039 0040 17388          move.b    4194368,D0
00005B56  0040      
00005B58  C03C 0001 17389          and.b     #1,D0
00005B5C  0C00 0001 17390          cmp.b     #1,D0
00005B60  6702      17391          beq.s     _getch_3
00005B62  60EE      17392          bra       _getch_1
                    17393   _getch_3:
                    17394   ; ;
                    17395   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00005B64  1039 0040 17396          move.b    4194370,D0
00005B68  0042      
00005B6A  C0BC 0000 17397          and.l     #255,D0
00005B6E  00FF      
00005B70  C0BC 0000 17398          and.l     #127,D0
00005B74  007F      
00005B76  2400      17399          move.l    D0,D2
                    17400   ; _putch(c);
00005B78  2F02      17401          move.l    D2,-(A7)
00005B7A  4EB8 5B24 17402          jsr       __putch
00005B7E  584F      17403          addq.w    #4,A7
                    17404   ; return c ;
00005B80  2002      17405          move.l    D2,D0
00005B82  241F      17406          move.l    (A7)+,D2
00005B84  4E75      17407          rts
                    17408   ; }
                    17409   ; /************************************************************************************
                    17410   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17411   ; ************************************************************************************/
                    17412   ; void Wait1ms(void)
                    17413   ; {
                    17414   _Wait1ms:
00005B86  2F02      17415          move.l    D2,-(A7)
                    17416   ; long int  i ;
                    17417   ; for(i = 0; i < 1000; i ++)
00005B88  4282      17418          clr.l     D2
                    17419   Wait1ms_1:
00005B8A  0C82 0000 17420          cmp.l     #1000,D2
00005B8E  03E8      
00005B90  6C04      17421          bge.s     Wait1ms_3
00005B92  5282      17422          addq.l    #1,D2
00005B94  60F4      17423          bra       Wait1ms_1
                    17424   Wait1ms_3:
00005B96  241F      17425          move.l    (A7)+,D2
00005B98  4E75      17426          rts
                    17427   ; ;
                    17428   ; }
                    17429   ; /************************************************************************************
                    17430   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17431   ; **************************************************************************************/
                    17432   ; void Wait3ms(void)
                    17433   ; {
                    17434   _Wait3ms:
00005B9A  2F02      17435          move.l    D2,-(A7)
                    17436   ; int i ;
                    17437   ; for(i = 0; i < 3; i++)
00005B9C  4282      17438          clr.l     D2
                    17439   Wait3ms_1:
00005B9E  0C82 0000 17440          cmp.l     #3,D2
00005BA2  0003      
00005BA4  6C08      17441          bge.s     Wait3ms_3
                    17442   ; Wait1ms() ;
00005BA6  4EB8 5B86 17443          jsr       _Wait1ms
00005BAA  5282      17444          addq.l    #1,D2
00005BAC  60F0      17445          bra       Wait3ms_1
                    17446   Wait3ms_3:
00005BAE  241F      17447          move.l    (A7)+,D2
00005BB0  4E75      17448          rts
                    17449   ; }
                    17450   ; /*********************************************************************************************
                    17451   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17452   ; *********************************************************************************************/
                    17453   ; void Init_LCD(void)
                    17454   ; {
                    17455   _Init_LCD:
                    17456   ; LCDcommand = (char)(0x0c) ;
00005BB2  13FC 000C 17457          move.b    #12,4194336
00005BB6  0040 0020 
                    17458   ; Wait3ms() ;
00005BBA  4EB8 5B9A 17459          jsr       _Wait3ms
                    17460   ; LCDcommand = (char)(0x38) ;
00005BBE  13FC 0038 17461          move.b    #56,4194336
00005BC2  0040 0020 
                    17462   ; Wait3ms() ;
00005BC6  4EB8 5B9A 17463          jsr       _Wait3ms
00005BCA  4E75      17464          rts
                    17465   ; }
                    17466   ; /******************************************************************************
                    17467   ; *subroutine to output a single character held in d1 to the LCD display
                    17468   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17469   ; *current cursor position
                    17470   ; *******************************************************************************/
                    17471   ; void Outchar(int c)
                    17472   ; {
                    17473   _Outchar:
00005BCC  4E56 0000 17474          link      A6,#0
                    17475   ; LCDdata = (char)(c);
00005BD0  202E 0008 17476          move.l    8(A6),D0
00005BD4  13C0 0040 17477          move.b    D0,4194338
00005BD8  0022      
                    17478   ; Wait1ms() ;
00005BDA  4EB8 5B86 17479          jsr       _Wait1ms
00005BDE  4E5E      17480          unlk      A6
00005BE0  4E75      17481          rts
                    17482   ; }
                    17483   ; /**********************************************************************************
                    17484   ; *subroutine to output a message at the current cursor position of the LCD display
                    17485   ; ************************************************************************************/
                    17486   ; void OutMess(char *theMessage)
                    17487   ; {
                    17488   _OutMess:
00005BE2  4E56 FFFC 17489          link      A6,#-4
                    17490   ; char c ;
                    17491   ; while((c = *theMessage++) != (char)(0))
                    17492   OutMess_1:
00005BE6  206E 0008 17493          move.l    8(A6),A0
00005BEA  52AE 0008 17494          addq.l    #1,8(A6)
00005BEE  1D50 FFFF 17495          move.b    (A0),-1(A6)
00005BF2  1010      17496          move.b    (A0),D0
00005BF4  6712      17497          beq.s     OutMess_3
                    17498   ; Outchar(c) ;
00005BF6  122E FFFF 17499          move.b    -1(A6),D1
00005BFA  4881      17500          ext.w     D1
00005BFC  48C1      17501          ext.l     D1
00005BFE  2F01      17502          move.l    D1,-(A7)
00005C00  4EB8 5BCC 17503          jsr       _Outchar
00005C04  584F      17504          addq.w    #4,A7
00005C06  60DE      17505          bra       OutMess_1
                    17506   OutMess_3:
00005C08  4E5E      17507          unlk      A6
00005C0A  4E75      17508          rts
                    17509   ; }
                    17510   ; /******************************************************************************
                    17511   ; *subroutine to clear the line by issuing 24 space characters
                    17512   ; *******************************************************************************/
                    17513   ; void Clearln(void)
                    17514   ; {
                    17515   _Clearln:
00005C0C  2F02      17516          move.l    D2,-(A7)
                    17517   ; unsigned char i ;
                    17518   ; for(i = 0; i < 24; i ++)
00005C0E  4202      17519          clr.b     D2
                    17520   Clearln_1:
00005C10  0C02 0018 17521          cmp.b     #24,D2
00005C14  640E      17522          bhs.s     Clearln_3
                    17523   ; Outchar(' ') ;  /* write a space char to the LCD display */
00005C16  4878 0020 17524          pea       32
00005C1A  4EB8 5BCC 17525          jsr       _Outchar
00005C1E  584F      17526          addq.w    #4,A7
00005C20  5202      17527          addq.b    #1,D2
00005C22  60EC      17528          bra       Clearln_1
                    17529   Clearln_3:
00005C24  241F      17530          move.l    (A7)+,D2
00005C26  4E75      17531          rts
                    17532   ; }
                    17533   ; /******************************************************************************
                    17534   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    17535   ; *******************************************************************************/
                    17536   ; void Oline0(char *theMessage)
                    17537   ; {
                    17538   _Oline0:
00005C28  4E56 0000 17539          link      A6,#0
                    17540   ; LCDcommand = (char)(0x80) ;
00005C2C  13FC 0080 17541          move.b    #128,4194336
00005C30  0040 0020 
                    17542   ; Wait3ms();
00005C34  4EB8 5B9A 17543          jsr       _Wait3ms
                    17544   ; Clearln() ;
00005C38  4EB8 5C0C 17545          jsr       _Clearln
                    17546   ; LCDcommand = (char)(0x80) ;
00005C3C  13FC 0080 17547          move.b    #128,4194336
00005C40  0040 0020 
                    17548   ; Wait3ms() ;
00005C44  4EB8 5B9A 17549          jsr       _Wait3ms
                    17550   ; OutMess(theMessage) ;
00005C48  2F2E 0008 17551          move.l    8(A6),-(A7)
00005C4C  4EB8 5BE2 17552          jsr       _OutMess
00005C50  584F      17553          addq.w    #4,A7
00005C52  4E5E      17554          unlk      A6
00005C54  4E75      17555          rts
                    17556   ; }
                    17557   ; /******************************************************************************
                    17558   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    17559   ; *******************************************************************************/
                    17560   ; void Oline1(char *theMessage)
                    17561   ; {
                    17562   _Oline1:
00005C56  4E56 0000 17563          link      A6,#0
                    17564   ; LCDcommand = (char)(0xC0) ;
00005C5A  13FC 00C0 17565          move.b    #192,4194336
00005C5E  0040 0020 
                    17566   ; Wait3ms();
00005C62  4EB8 5B9A 17567          jsr       _Wait3ms
                    17568   ; Clearln() ;
00005C66  4EB8 5C0C 17569          jsr       _Clearln
                    17570   ; LCDcommand = (char)(0xC0) ;
00005C6A  13FC 00C0 17571          move.b    #192,4194336
00005C6E  0040 0020 
                    17572   ; Wait3ms() ;
00005C72  4EB8 5B9A 17573          jsr       _Wait3ms
                    17574   ; OutMess(theMessage) ;
00005C76  2F2E 0008 17575          move.l    8(A6),-(A7)
00005C7A  4EB8 5BE2 17576          jsr       _OutMess
00005C7E  584F      17577          addq.w    #4,A7
00005C80  4E5E      17578          unlk      A6
00005C82  4E75      17579          rts
                    17580   ; }
                    17581   ; /*********************************************************************************
                    17582   ; ** Timer ISR
                    17583   ; **********************************************************************************/
                    17584   ; void Timer_ISR(void)
                    17585   ; {
                    17586   _Timer_ISR:
                    17587   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
00005C84  1039 0040 17588          move.b    4194354,D0
00005C88  0032      
00005C8A  0C00 0001 17589          cmp.b     #1,D0
00005C8E  6608      17590          bne.s     Timer_ISR_1
                    17591   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
00005C90  13FC 0003 17592          move.b    #3,4194354
00005C94  0040 0032 
                    17593   Timer_ISR_1:
00005C98  4E75      17594          rts
                    17595   ; }
                    17596   ; }
                    17597   ; /**********************************************************************************
                    17598   ; ** Timer Initialisation Routine
                    17599   ; **********************************************************************************/
                    17600   ; void Timer1_Init(void)
                    17601   ; {
                    17602   _Timer1_Init:
                    17603   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
00005C9A  13FC 0003 17604          move.b    #3,4194352
00005C9E  0040 0030 
                    17605   ; /*
                    17606   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    17607   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    17608   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    17609   ; **
                    17610   ; **
                    17611   ; ** Now write binary 00000011 to timer control register:
                    17612   ; **	Bit0 = 1 (enable interrupt from that timer)
                    17613   ; **	Bit 1 = 1 enable counting
                    17614   ; */
                    17615   ; Timer1Control = 3;
00005CA2  13FC 0003 17616          move.b    #3,4194354
00005CA6  0040 0032 
00005CAA  4E75      17617          rts
                    17618   ; }
                    17619   ; /*********************************************************************************************************************************
                    17620   ; **  IMPORTANT FUNCTION
                    17621   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    17622   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    17623   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    17624   ; **  Calling this function allows you to deal with Interrupts for example
                    17625   ; **
                    17626   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    17627   ; **
                    17628   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    17629   ; **
                    17630   ; **	see main below for other examples
                    17631   ; ***********************************************************************************************************************************/
                    17632   ; /*
                    17633   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    17634   ; {
                    17635   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    17636   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    17637   ; }
                    17638   ; */
                    17639   ; C:\CPEN412\ASN6\ASN6B_INTERRUPTS\CANBUS-CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17640   ; #include <stdio.h>
                    17641   ; #include "Canbus-Controller.h"
                    17642   ; #include "DebugMonitor.h"
                    17643   ; #define TEMP 0
                    17644   ; #define POTENTIAL 1
                    17645   ; #define LIGHT 2
                    17646   ; #define SWITCHES 3
                    17647   ; /*********************************************************************************************
                    17648   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                    17649   ; ** application note and adapted for the 68k assignment
                    17650   ; *********************************************************************************************/
                    17651   ; /*
                    17652   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                    17653   ; ** assume the addresses for the 2 can controllers given in the assignment
                    17654   ; **
                    17655   ; ** Registers are defined in terms of the following Macro for each Can controller,
                    17656   ; ** where (i) represents an registers number
                    17657   ; */
                    17658   ; /*  bus timing values for
                    17659   ; **  bit-rate : 100 kBit/s
                    17660   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                    17661   ; **  maximum tolerated propagation delay : 4450 ns
                    17662   ; **  minimum requested propagation delay : 500 ns
                    17663   ; **
                    17664   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                    17665   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                    17666   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                    17667   ; */
                    17668   ; // initialisation for Can controller 0
                    17669   ; void Init_CanBus_Controller0(void)
                    17670   ; {
                    17671   _Init_CanBus_Controller0:
                    17672   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    17673   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    17674   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    17675   ; leave loop after a time out and signal an error */
                    17676   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    17677   Init_CanBus_Controller0_1:
00005CAC  1039 0050 17678          move.b    5242880,D0
00005CB0  0000      
00005CB2  C03C 0001 17679          and.b     #1,D0
00005CB6  6612      17680          bne.s     Init_CanBus_Controller0_3
                    17681   ; {
                    17682   ; /* other bits than the reset mode/request bit are unchanged */
                    17683   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit ;
00005CB8  1039 0050 17684          move.b    5242880,D0
00005CBC  0000      
00005CBE  803C 0001 17685          or.b      #1,D0
00005CC2  13C0 0050 17686          move.b    D0,5242880
00005CC6  0000      
00005CC8  60E2      17687          bra       Init_CanBus_Controller0_1
                    17688   Init_CanBus_Controller0_3:
                    17689   ; }
                    17690   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    17691   ; select PeliCAN mode
                    17692   ; bypass CAN input comparator as external transceiver is used
                    17693   ; select the clock for the controller S87C654 */
                    17694   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00005CCA  13FC 00C0 17695          move.b    #192,5242942
00005CCE  0050 003E 
                    17696   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    17697   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    17698   ; Can0_InterruptEnReg = ClrIntEnSJA;
00005CD2  4239 0050 17699          clr.b     5242888
00005CD6  0008      
                    17700   ; /* define acceptance code and mask */
                    17701   ; Can0_AcceptCode0Reg = ClrByte;
00005CD8  4239 0050 17702          clr.b     5242912
00005CDC  0020      
                    17703   ; Can0_AcceptCode1Reg = ClrByte;
00005CDE  4239 0050 17704          clr.b     5242914
00005CE2  0022      
                    17705   ; Can0_AcceptCode2Reg = ClrByte;
00005CE4  4239 0050 17706          clr.b     5242916
00005CE8  0024      
                    17707   ; Can0_AcceptCode3Reg = ClrByte;
00005CEA  4239 0050 17708          clr.b     5242918
00005CEE  0026      
                    17709   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00005CF0  13FC 00FF 17710          move.b    #255,5242920
00005CF4  0050 0028 
                    17711   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00005CF8  13FC 00FF 17712          move.b    #255,5242922
00005CFC  0050 002A 
                    17713   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00005D00  13FC 00FF 17714          move.b    #255,5242924
00005D04  0050 002C 
                    17715   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00005D08  13FC 00FF 17716          move.b    #255,5242926
00005D0C  0050 002E 
                    17717   ; /* configure bus timing */
                    17718   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    17719   ; Can0_BusTiming0Reg = 0x04;
00005D10  13FC 0004 17720          move.b    #4,5242892
00005D14  0050 000C 
                    17721   ; Can0_BusTiming1Reg = 0x7F;
00005D18  13FC 007F 17722          move.b    #127,5242894
00005D1C  0050 000E 
                    17723   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    17724   ; normal output mode */
                    17725   ; Can0_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00005D20  13FC 001A 17726          move.b    #26,5242896
00005D24  0050 0010 
                    17727   ; /* leave the reset mode/request i.e. switch to operating mode,
                    17728   ; the interrupts of the S87C654 are enabled
                    17729   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    17730   ; for the different tasks in a system */
                    17731   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    17732   ; switch off Self Test Mode and Listen Only Mode,
                    17733   ; clear Sleep Mode (wake up) */
                    17734   ; /* wait until RM_RR_Bit is cleared */
                    17735   ; /* break loop after a time out and signal an error */
                    17736   ; do{
                    17737   Init_CanBus_Controller0_4:
                    17738   ; Can0_ModeControlReg = ClrByte;
00005D28  4239 0050 17739          clr.b     5242880
00005D2C  0000      
00005D2E  1039 0050 17740          move.b    5242880,D0
00005D32  0000      
00005D34  C03C 0001 17741          and.b     #1,D0
00005D38  66EE      17742          bne       Init_CanBus_Controller0_4
00005D3A  4E75      17743          rts
                    17744   ; } while((Can0_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    17745   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    17746   ; }
                    17747   ; // initialisation for Can controller 1
                    17748   ; void Init_CanBus_Controller1(void)
                    17749   ; {
                    17750   _Init_CanBus_Controller1:
                    17751   ; // TODO - put your Canbus initialisation code for CanController 1 here
                    17752   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    17753   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    17754   ; leave loop after a time out and signal an error */
                    17755   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    17756   Init_CanBus_Controller1_1:
00005D3C  1039 0050 17757          move.b    5243392,D0
00005D40  0200      
00005D42  C03C 0001 17758          and.b     #1,D0
00005D46  6612      17759          bne.s     Init_CanBus_Controller1_3
                    17760   ; {
                    17761   ; /* other bits than the reset mode/request bit are unchanged */
                    17762   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit ;
00005D48  1039 0050 17763          move.b    5243392,D0
00005D4C  0200      
00005D4E  803C 0001 17764          or.b      #1,D0
00005D52  13C0 0050 17765          move.b    D0,5243392
00005D56  0200      
00005D58  60E2      17766          bra       Init_CanBus_Controller1_1
                    17767   Init_CanBus_Controller1_3:
                    17768   ; }
                    17769   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    17770   ; select PeliCAN mode
                    17771   ; bypass CAN input comparator as external transceiver is used
                    17772   ; select the clock for the controller S87C654 */
                    17773   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00005D5A  13FC 00C0 17774          move.b    #192,5243454
00005D5E  0050 023E 
                    17775   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    17776   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    17777   ; Can1_InterruptEnReg = ClrIntEnSJA;
00005D62  4239 0050 17778          clr.b     5243400
00005D66  0208      
                    17779   ; /* define acceptance code and mask */
                    17780   ; Can1_AcceptCode0Reg = ClrByte;
00005D68  4239 0050 17781          clr.b     5243424
00005D6C  0220      
                    17782   ; Can1_AcceptCode1Reg = ClrByte;
00005D6E  4239 0050 17783          clr.b     5243426
00005D72  0222      
                    17784   ; Can1_AcceptCode2Reg = ClrByte;
00005D74  4239 0050 17785          clr.b     5243428
00005D78  0224      
                    17786   ; Can1_AcceptCode3Reg = ClrByte;
00005D7A  4239 0050 17787          clr.b     5243430
00005D7E  0226      
                    17788   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00005D80  13FC 00FF 17789          move.b    #255,5243432
00005D84  0050 0228 
                    17790   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00005D88  13FC 00FF 17791          move.b    #255,5243434
00005D8C  0050 022A 
                    17792   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00005D90  13FC 00FF 17793          move.b    #255,5243436
00005D94  0050 022C 
                    17794   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00005D98  13FC 00FF 17795          move.b    #255,5243438
00005D9C  0050 022E 
                    17796   ; /* configure bus timing */
                    17797   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    17798   ; Can1_BusTiming0Reg = 0x04;
00005DA0  13FC 0004 17799          move.b    #4,5243404
00005DA4  0050 020C 
                    17800   ; Can1_BusTiming1Reg = 0x7F;
00005DA8  13FC 007F 17801          move.b    #127,5243406
00005DAC  0050 020E 
                    17802   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    17803   ; normal output mode */
                    17804   ; Can1_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00005DB0  13FC 001A 17805          move.b    #26,5243408
00005DB4  0050 0210 
                    17806   ; /* leave the reset mode/request i.e. switch to operating mode,
                    17807   ; the interrupts of the S87C654 are enabled
                    17808   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    17809   ; for the different tasks in a system */
                    17810   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    17811   ; switch off Self Test Mode and Listen Only Mode,
                    17812   ; clear Sleep Mode (wake up) */
                    17813   ; /* wait until RM_RR_Bit is cleared */
                    17814   ; /* break loop after a time out and signal an error */
                    17815   ; do{
                    17816   Init_CanBus_Controller1_4:
                    17817   ; Can1_ModeControlReg = ClrByte;
00005DB8  4239 0050 17818          clr.b     5243392
00005DBC  0200      
00005DBE  1039 0050 17819          move.b    5243392,D0
00005DC2  0200      
00005DC4  C03C 0001 17820          and.b     #1,D0
00005DC8  66EE      17821          bne       Init_CanBus_Controller1_4
00005DCA  4E75      17822          rts
                    17823   ; } while((Can1_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    17824   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    17825   ; }
                    17826   ; // Transmit for sending a message via Can controller 0
                    17827   ; void CanBus0_Transmit(unsigned char data)
                    17828   ; {
                    17829   _CanBus0_Transmit:
00005DCC  4E56 0000 17830          link      A6,#0
                    17831   ; // TODO - put your Canbus transmit code for CanController 0 here
                    17832   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    17833   ; /* wait until the Transmit Buffer is released */
                    17834   ; do{
                    17835   CanBus0_Transmit_1:
                    17836   ; /* start a polling timer and run some tasks while waiting
                    17837   ; break the loop and signal an error if time too long */
                    17838   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
00005DD0  1039 0050 17839          move.b    5242884,D0
00005DD4  0004      
00005DD6  C03C 0004 17840          and.b     #4,D0
00005DDA  0C00 0004 17841          cmp.b     #4,D0
00005DDE  66F0      17842          bne       CanBus0_Transmit_1
                    17843   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    17844   ; /* in this example a Standard Frame message shall be transmitted */
                    17845   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00005DE0  13FC 0008 17846          move.b    #8,5242912
00005DE4  0050 0020 
                    17847   ; Can0_TxBuffer1 = data; /*Data that will be sent*/
00005DE8  13EE 000B 17848          move.b    11(A6),5242914
00005DEC  0050 0022 
                    17849   ; /* Start the transmission */
                    17850   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00005DF0  13FC 0001 17851          move.b    #1,5242882
00005DF4  0050 0002 
00005DF8  4E5E      17852          unlk      A6
00005DFA  4E75      17853          rts
                    17854   ; }
                    17855   ; // Transmit for sending a message via Can controller 1
                    17856   ; void CanBus1_Transmit(unsigned char data)
                    17857   ; {
                    17858   _CanBus1_Transmit:
00005DFC  4E56 0000 17859          link      A6,#0
                    17860   ; // TODO - put your Canbus transmit code for CanController 1 here
                    17861   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    17862   ; /* wait until the Transmit Buffer is released */
                    17863   ; do{
                    17864   CanBus1_Transmit_1:
                    17865   ; /* start a polling timer and run some tasks while waiting
                    17866   ; break the loop and signal an error if time too long */
                    17867   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
00005E00  1039 0050 17868          move.b    5243396,D0
00005E04  0204      
00005E06  C03C 0004 17869          and.b     #4,D0
00005E0A  0C00 0004 17870          cmp.b     #4,D0
00005E0E  66F0      17871          bne       CanBus1_Transmit_1
                    17872   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    17873   ; /* in this example a Standard Frame message shall be transmitted */
                    17874   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00005E10  13FC 0008 17875          move.b    #8,5243424
00005E14  0050 0220 
                    17876   ; Can1_TxBuffer1 = data; /*Data that will be sent*/
00005E18  13EE 000B 17877          move.b    11(A6),5243426
00005E1C  0050 0222 
                    17878   ; /* Start the transmission */
                    17879   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00005E20  13FC 0001 17880          move.b    #1,5243394
00005E24  0050 0202 
00005E28  4E5E      17881          unlk      A6
00005E2A  4E75      17882          rts
                    17883   ; }
                    17884   ; // Receive for reading a received message via Can controller 0
                    17885   ; void CanBus0_Receive(int type)
                    17886   ; {
                    17887   _CanBus0_Receive:
00005E2C  4E56 FFFC 17888          link      A6,#-4
00005E30  48E7 3820 17889          movem.l   D2/D3/D4/A2,-(A7)
00005E34  45F9 0000 17890          lea       _printf.L,A2
00005E38  6A6A      
00005E3A  282E 0008 17891          move.l    8(A6),D4
                    17892   ; unsigned char data;
                    17893   ; unsigned char c = 0xFF;
00005E3E  1D7C 00FF 17894          move.b    #255,-1(A6)
00005E42  FFFF      
                    17895   ; unsigned int i = 0;
00005E44  4283      17896          clr.l     D3
                    17897   ; // TODO - put your Canbus receive code for CanController 0 here
                    17898   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    17899   ; //Bottom of page 35
                    17900   ; /* enable the receive interrupt */
                    17901   ; //Can0_InterruptEnReg = RIE_Bit; ////
                    17902   ; /* wait until the Receiver Buffer is released */
                    17903   ; do{
                    17904   CanBus0_Receive_1:
                    17905   ; /* start a polling timer and run some tasks while waiting
                    17906   ; break the loop and signal an error if time too long */
                    17907   ; } while((Can0_StatusReg & RBS_Bit) != RBS_Bit );
00005E46  1039 0050 17908          move.b    5242884,D0
00005E4A  0004      
00005E4C  C03C 0001 17909          and.b     #1,D0
00005E50  0C00 0001 17910          cmp.b     #1,D0
00005E54  66F0      17911          bne       CanBus0_Receive_1
                    17912   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                    17913   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                    17914   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                    17915   ; */
                    17916   ; /* get the content of the Receive Buffer from SJA1000 and store the
                    17917   ; message into internal memory of the controller,
                    17918   ; it is possible at once to decode the FrameInfo and Data Length Code
                    17919   ; and adapt the fetch appropriately */
                    17920   ; data = Can0_RxBuffer1;
00005E56  1439 0050 17921          move.b    5242914,D2
00005E5A  0022      
                    17922   ; if(type == TEMP){
00005E5C  4A84      17923          tst.l     D4
00005E5E  6616      17924          bne.s     CanBus0_Receive_3
                    17925   ; printf("Value of Thermistor (CAN0): %d\n", data);
00005E60  C4BC 0000 17926          and.l     #255,D2
00005E64  00FF      
00005E66  2F02      17927          move.l    D2,-(A7)
00005E68  4879 0000 17928          pea       @canbus~1_1.L
00005E6C  778C      
00005E6E  4E92      17929          jsr       (A2)
00005E70  504F      17930          addq.w    #8,A7
00005E72  6000 009C 17931          bra       CanBus0_Receive_10
                    17932   CanBus0_Receive_3:
                    17933   ; }else if(type == POTENTIAL){
00005E76  0C84 0000 17934          cmp.l     #1,D4
00005E7A  0001      
00005E7C  6616      17935          bne.s     CanBus0_Receive_5
                    17936   ; printf("Value of Potentiometer (CAN0): %d\n", data);
00005E7E  C4BC 0000 17937          and.l     #255,D2
00005E82  00FF      
00005E84  2F02      17938          move.l    D2,-(A7)
00005E86  4879 0000 17939          pea       @canbus~1_2.L
00005E8A  77AC      
00005E8C  4E92      17940          jsr       (A2)
00005E8E  504F      17941          addq.w    #8,A7
00005E90  6000 007E 17942          bra       CanBus0_Receive_10
                    17943   CanBus0_Receive_5:
                    17944   ; }else if(type == LIGHT){
00005E94  0C84 0000 17945          cmp.l     #2,D4
00005E98  0002      
00005E9A  6616      17946          bne.s     CanBus0_Receive_7
                    17947   ; printf("Value of Photo-resister (CAN0): %d\n", data);
00005E9C  C4BC 0000 17948          and.l     #255,D2
00005EA0  00FF      
00005EA2  2F02      17949          move.l    D2,-(A7)
00005EA4  4879 0000 17950          pea       @canbus~1_3.L
00005EA8  77D0      
00005EAA  4E92      17951          jsr       (A2)
00005EAC  504F      17952          addq.w    #8,A7
00005EAE  6000 0060 17953          bra       CanBus0_Receive_10
                    17954   CanBus0_Receive_7:
                    17955   ; }else if(type == SWITCHES){
00005EB2  0C84 0000 17956          cmp.l     #3,D4
00005EB6  0003      
00005EB8  6600 004C 17957          bne       CanBus0_Receive_9
                    17958   ; printf("Value of SW[7-0] (CAN0): ");
00005EBC  4879 0000 17959          pea       @canbus~1_4.L
00005EC0  77F4      
00005EC2  4E92      17960          jsr       (A2)
00005EC4  584F      17961          addq.w    #4,A7
                    17962   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00005EC6  263C 0000 17963          move.l    #128,D3
00005ECA  0080      
                    17964   CanBus0_Receive_11:
00005ECC  0C83 0000 17965          cmp.l     #0,D3
00005ED0  0000      
00005ED2  6326      17966          bls.s     CanBus0_Receive_13
                    17967   ; if ((data & i) == 0)
00005ED4  1002      17968          move.b    D2,D0
00005ED6  C0BC 0000 17969          and.l     #255,D0
00005EDA  00FF      
00005EDC  C083      17970          and.l     D3,D0
00005EDE  660C      17971          bne.s     CanBus0_Receive_14
                    17972   ; printf("0");
00005EE0  4879 0000 17973          pea       @canbus~1_5.L
00005EE4  780E      
00005EE6  4E92      17974          jsr       (A2)
00005EE8  584F      17975          addq.w    #4,A7
00005EEA  600A      17976          bra.s     CanBus0_Receive_15
                    17977   CanBus0_Receive_14:
                    17978   ; else
                    17979   ; printf("1");
00005EEC  4879 0000 17980          pea       @canbus~1_6.L
00005EF0  7810      
00005EF2  4E92      17981          jsr       (A2)
00005EF4  584F      17982          addq.w    #4,A7
                    17983   CanBus0_Receive_15:
00005EF6  E28B      17984          lsr.l     #1,D3
00005EF8  60D2      17985          bra       CanBus0_Receive_11
                    17986   CanBus0_Receive_13:
                    17987   ; }
                    17988   ; printf("\n");
00005EFA  4879 0000 17989          pea       @canbus~1_7.L
00005EFE  7812      
00005F00  4E92      17990          jsr       (A2)
00005F02  584F      17991          addq.w    #4,A7
00005F04  600A      17992          bra.s     CanBus0_Receive_10
                    17993   CanBus0_Receive_9:
                    17994   ; }else{
                    17995   ; printf("ERROR");
00005F06  4879 0000 17996          pea       @canbus~1_8.L
00005F0A  7814      
00005F0C  4E92      17997          jsr       (A2)
00005F0E  584F      17998          addq.w    #4,A7
                    17999   CanBus0_Receive_10:
                    18000   ; }
                    18001   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                    18002   ; further messages will generate a new interrupt */
                    18003   ; Can0_CommandReg = RRB_Bit; /* Release Receive Buffer */
00005F10  13FC 0004 18004          move.b    #4,5242882
00005F14  0050 0002 
00005F18  4CDF 041C 18005          movem.l   (A7)+,D2/D3/D4/A2
00005F1C  4E5E      18006          unlk      A6
00005F1E  4E75      18007          rts
                    18008   ; }
                    18009   ; // Receive for reading a received message via Can controller 1
                    18010   ; void CanBus1_Receive(int type)
                    18011   ; {
                    18012   _CanBus1_Receive:
00005F20  4E56 FFFC 18013          link      A6,#-4
00005F24  48E7 3820 18014          movem.l   D2/D3/D4/A2,-(A7)
00005F28  45F9 0000 18015          lea       _printf.L,A2
00005F2C  6A6A      
00005F2E  282E 0008 18016          move.l    8(A6),D4
                    18017   ; unsigned char data;
                    18018   ; unsigned char c = 0xFF;
00005F32  1D7C 00FF 18019          move.b    #255,-1(A6)
00005F36  FFFF      
                    18020   ; unsigned int i = 0;        
00005F38  4283      18021          clr.l     D3
                    18022   ; // TODO - put your Canbus receive code for CanController 1 here
                    18023   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18024   ; //Bottom of page 35
                    18025   ; // TODO - put your Canbus receive code for CanController 0 here
                    18026   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18027   ; /* enable the receive interrupt */
                    18028   ; //Can1_InterruptEnReg = RIE_Bit;
                    18029   ; /* wait until the Receiver Buffer is released */
                    18030   ; do{
                    18031   CanBus1_Receive_1:
                    18032   ; /* start a polling timer and run some tasks while waiting
                    18033   ; break the loop and signal an error if time too long */
                    18034   ; } while((Can1_StatusReg & RBS_Bit) != RBS_Bit );
00005F3A  1039 0050 18035          move.b    5243396,D0
00005F3E  0204      
00005F40  C03C 0001 18036          and.b     #1,D0
00005F44  0C00 0001 18037          cmp.b     #1,D0
00005F48  66F0      18038          bne       CanBus1_Receive_1
                    18039   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                    18040   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                    18041   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                    18042   ; */
                    18043   ; /* get the content of the Receive Buffer from SJA1000 and store the
                    18044   ; message into internal memory of the controller,
                    18045   ; it is possible at once to decode the FrameInfo and Data Length Code
                    18046   ; and adapt the fetch appropriately */
                    18047   ; data = Can1_RxBuffer1;
00005F4A  1439 0050 18048          move.b    5243426,D2
00005F4E  0222      
                    18049   ; if(type == TEMP){
00005F50  4A84      18050          tst.l     D4
00005F52  6616      18051          bne.s     CanBus1_Receive_3
                    18052   ; printf("Value of Thermistor (CAN1): %d\n", data);
00005F54  C4BC 0000 18053          and.l     #255,D2
00005F58  00FF      
00005F5A  2F02      18054          move.l    D2,-(A7)
00005F5C  4879 0000 18055          pea       @canbus~1_9.L
00005F60  781A      
00005F62  4E92      18056          jsr       (A2)
00005F64  504F      18057          addq.w    #8,A7
00005F66  6000 009C 18058          bra       CanBus1_Receive_10
                    18059   CanBus1_Receive_3:
                    18060   ; }else if(type == POTENTIAL){
00005F6A  0C84 0000 18061          cmp.l     #1,D4
00005F6E  0001      
00005F70  6616      18062          bne.s     CanBus1_Receive_5
                    18063   ; printf("Value of Potentiometer (CAN1): %d\n", data);
00005F72  C4BC 0000 18064          and.l     #255,D2
00005F76  00FF      
00005F78  2F02      18065          move.l    D2,-(A7)
00005F7A  4879 0000 18066          pea       @canbus~1_10.L
00005F7E  783A      
00005F80  4E92      18067          jsr       (A2)
00005F82  504F      18068          addq.w    #8,A7
00005F84  6000 007E 18069          bra       CanBus1_Receive_10
                    18070   CanBus1_Receive_5:
                    18071   ; }else if(type == LIGHT){
00005F88  0C84 0000 18072          cmp.l     #2,D4
00005F8C  0002      
00005F8E  6616      18073          bne.s     CanBus1_Receive_7
                    18074   ; printf("Value of Photo-resister (CAN1): %d\n", data);
00005F90  C4BC 0000 18075          and.l     #255,D2
00005F94  00FF      
00005F96  2F02      18076          move.l    D2,-(A7)
00005F98  4879 0000 18077          pea       @canbus~1_11.L
00005F9C  785E      
00005F9E  4E92      18078          jsr       (A2)
00005FA0  504F      18079          addq.w    #8,A7
00005FA2  6000 0060 18080          bra       CanBus1_Receive_10
                    18081   CanBus1_Receive_7:
                    18082   ; }else if(type == SWITCHES){
00005FA6  0C84 0000 18083          cmp.l     #3,D4
00005FAA  0003      
00005FAC  6600 004C 18084          bne       CanBus1_Receive_9
                    18085   ; printf("Value of SW[7-0] (CAN1): ");
00005FB0  4879 0000 18086          pea       @canbus~1_12.L
00005FB4  7882      
00005FB6  4E92      18087          jsr       (A2)
00005FB8  584F      18088          addq.w    #4,A7
                    18089   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00005FBA  263C 0000 18090          move.l    #128,D3
00005FBE  0080      
                    18091   CanBus1_Receive_11:
00005FC0  0C83 0000 18092          cmp.l     #0,D3
00005FC4  0000      
00005FC6  6326      18093          bls.s     CanBus1_Receive_13
                    18094   ; if ((data & i) == 0)
00005FC8  1002      18095          move.b    D2,D0
00005FCA  C0BC 0000 18096          and.l     #255,D0
00005FCE  00FF      
00005FD0  C083      18097          and.l     D3,D0
00005FD2  660C      18098          bne.s     CanBus1_Receive_14
                    18099   ; printf("0");
00005FD4  4879 0000 18100          pea       @canbus~1_5.L
00005FD8  780E      
00005FDA  4E92      18101          jsr       (A2)
00005FDC  584F      18102          addq.w    #4,A7
00005FDE  600A      18103          bra.s     CanBus1_Receive_15
                    18104   CanBus1_Receive_14:
                    18105   ; else
                    18106   ; printf("1");
00005FE0  4879 0000 18107          pea       @canbus~1_6.L
00005FE4  7810      
00005FE6  4E92      18108          jsr       (A2)
00005FE8  584F      18109          addq.w    #4,A7
                    18110   CanBus1_Receive_15:
00005FEA  E28B      18111          lsr.l     #1,D3
00005FEC  60D2      18112          bra       CanBus1_Receive_11
                    18113   CanBus1_Receive_13:
                    18114   ; }
                    18115   ; printf("\n");
00005FEE  4879 0000 18116          pea       @canbus~1_7.L
00005FF2  7812      
00005FF4  4E92      18117          jsr       (A2)
00005FF6  584F      18118          addq.w    #4,A7
00005FF8  600A      18119          bra.s     CanBus1_Receive_10
                    18120   CanBus1_Receive_9:
                    18121   ; }else{
                    18122   ; printf("ERROR");
00005FFA  4879 0000 18123          pea       @canbus~1_8.L
00005FFE  7814      
00006000  4E92      18124          jsr       (A2)
00006002  584F      18125          addq.w    #4,A7
                    18126   CanBus1_Receive_10:
                    18127   ; }
                    18128   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                    18129   ; further messages will generate a new interrupt */
                    18130   ; Can1_CommandReg = RRB_Bit; /* Release Receive Buffer */
00006004  13FC 0004 18131          move.b    #4,5243394
00006008  0050 0202 
0000600C  4CDF 041C 18132          movem.l   (A7)+,D2/D3/D4/A2
00006010  4E5E      18133          unlk      A6
00006012  4E75      18134          rts
                    18135   ; }
                    18136   ; void CanBusTest(void)
                    18137   ; {
                    18138   _CanBusTest:
00006014  48E7 2020 18139          movem.l   D2/A2,-(A7)
00006018  45F9 0000 18140          lea       _printf.L,A2
0000601C  6A6A      
                    18141   ; unsigned char data = 0xFF;
0000601E  143C 00FF 18142          move.b    #255,D2
                    18143   ; // initialise the two Can controllers
                    18144   ; Init_CanBus_Controller0();
00006022  4EB8 5CAC 18145          jsr       _Init_CanBus_Controller0
                    18146   ; Init_CanBus_Controller1();
00006026  4EB8 5D3C 18147          jsr       _Init_CanBus_Controller1
                    18148   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
0000602A  4879 0000 18149          pea       @canbus~1_13.L
0000602E  789C      
00006030  4E92      18150          jsr       (A2)
00006032  584F      18151          addq.w    #4,A7
                    18152   ; // simple application to alternately transmit and receive messages from each of two nodes
                    18153   ; while(1)    {
                    18154   CanBusTest_1:
                    18155   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00006034  4EB9 0000 18156          jsr       _WaitHalfSecond
00006038  6082      
                    18157   ; CanBus0_Transmit(data) ;       // transmit a message via Controller 0
0000603A  C4BC 0000 18158          and.l     #255,D2
0000603E  00FF      
00006040  2F02      18159          move.l    D2,-(A7)
00006042  4EB8 5DCC 18160          jsr       _CanBus0_Transmit
00006046  584F      18161          addq.w    #4,A7
                    18162   ; CanBus1_Receive(TEMP) ;        // receive a message via Controller 1 (and display it)
00006048  42A7      18163          clr.l     -(A7)
0000604A  4EB8 5F20 18164          jsr       _CanBus1_Receive
0000604E  584F      18165          addq.w    #4,A7
                    18166   ; printf("\r\n") ;
00006050  4879 0000 18167          pea       @canbus~1_14.L
00006054  78B8      
00006056  4E92      18168          jsr       (A2)
00006058  584F      18169          addq.w    #4,A7
                    18170   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
0000605A  4EB9 0000 18171          jsr       _WaitHalfSecond
0000605E  6082      
                    18172   ; CanBus1_Transmit(data) ;        // transmit a message via Controller 1
00006060  C4BC 0000 18173          and.l     #255,D2
00006064  00FF      
00006066  2F02      18174          move.l    D2,-(A7)
00006068  4EB8 5DFC 18175          jsr       _CanBus1_Transmit
0000606C  584F      18176          addq.w    #4,A7
                    18177   ; CanBus0_Receive(TEMP) ;         // receive a message via Controller 0 (and display it)
0000606E  42A7      18178          clr.l     -(A7)
00006070  4EB8 5E2C 18179          jsr       _CanBus0_Receive
00006074  584F      18180          addq.w    #4,A7
                    18181   ; printf("\r\n") ;
00006076  4879 0000 18182          pea       @canbus~1_14.L
0000607A  78B8      
0000607C  4E92      18183          jsr       (A2)
0000607E  584F      18184          addq.w    #4,A7
00006080  60B2      18185          bra       CanBusTest_1
                    18186   ; }
                    18187   ; }
                    18188   ; /************************************************************************************
                    18189   ; *Subroutine to give the 68000 something useless to do to waste 1 x 500 mSec = 500mSec = 0.5sec therefore 500000
                    18190   ; ************************************************************************************/
                    18191   ; void WaitHalfSecond(void)
                    18192   ; {
                    18193   _WaitHalfSecond:
00006082  2F02      18194          move.l    D2,-(A7)
                    18195   ; long int  i;
                    18196   ; for (i = 0; i < 500000; i++)
00006084  4282      18197          clr.l     D2
                    18198   WaitHalfSecond_1:
00006086  0C82 0007 18199          cmp.l     #500000,D2
0000608A  A120      
0000608C  6C04      18200          bge.s     WaitHalfSecond_3
0000608E  5282      18201          addq.l    #1,D2
00006090  60F4      18202          bra       WaitHalfSecond_1
                    18203   WaitHalfSecond_3:
00006092  241F      18204          move.l    (A7)+,D2
00006094  4E75      18205          rts
                    18206   ; ;
                    18207   ; }
                    18208   ; /************************************************************************************
                    18209   ; ** Subfunctions for I2C
                    18210   ; ************************************************************************************/
                    18211   ; void Enable_SCL_Clock(void){
                    18212   _Enable_SCL_Clock:
                    18213   ; I2C_Clock_PrerLo = 0x31;
00006096  13FC 0031 18214          move.b    #49,4227072
0000609A  0040 8000 
                    18215   ; I2C_Clock_PrerHi = 0x00;
0000609E  4239 0040 18216          clr.b     4227074
000060A2  8002      
                    18217   ; return;
000060A4  4E75      18218          rts
                    18219   ; }
                    18220   ; void WaitForI2C_TIP(void){
                    18221   _WaitForI2C_TIP:
000060A6  4E56 FFFC 18222          link      A6,#-4
                    18223   ; int TIP_bit;
                    18224   ; do{
                    18225   WaitForI2C_TIP_1:
                    18226   ; TIP_bit = (I2C_Status >> 1) & 0x01; 
000060AA  1039 0040 18227          move.b    4227080,D0
000060AE  8008      
000060B0  C0BC 0000 18228          and.l     #255,D0
000060B4  00FF      
000060B6  E288      18229          lsr.l     #1,D0
000060B8  C0BC 0000 18230          and.l     #1,D0
000060BC  0001      
000060BE  2D40 FFFC 18231          move.l    D0,-4(A6)
000060C2  202E FFFC 18232          move.l    -4(A6),D0
000060C6  66E2      18233          bne       WaitForI2C_TIP_1
                    18234   ; }while(TIP_bit != 0);
                    18235   ; return;
000060C8  4E5E      18236          unlk      A6
000060CA  4E75      18237          rts
                    18238   ; }
                    18239   ; void WaitForI2C_RxACK(void){
                    18240   _WaitForI2C_RxACK:
000060CC  4E56 FFFC 18241          link      A6,#-4
                    18242   ; int RxACK_bit;
                    18243   ; do{
                    18244   WaitForI2C_RxACK_1:
                    18245   ; RxACK_bit = (I2C_Status >> 7) & 0x01;
000060D0  1039 0040 18246          move.b    4227080,D0
000060D4  8008      
000060D6  C0BC 0000 18247          and.l     #255,D0
000060DA  00FF      
000060DC  EE88      18248          lsr.l     #7,D0
000060DE  C0BC 0000 18249          and.l     #1,D0
000060E2  0001      
000060E4  2D40 FFFC 18250          move.l    D0,-4(A6)
000060E8  202E FFFC 18251          move.l    -4(A6),D0
000060EC  66E2      18252          bne       WaitForI2C_RxACK_1
                    18253   ; }while(RxACK_bit != 0);
                    18254   ; return;
000060EE  4E5E      18255          unlk      A6
000060F0  4E75      18256          rts
                    18257   ; }
                    18258   ; /************************************************************************************
                    18259   ; ** initialises the I2C controller 
                    18260   ; ************************************************************************************/
                    18261   ; void I2C_Init(void){
                    18262   _I2C_Init:
                    18263   ; //Enabling 100Khz SCL Clock Line
                    18264   ; Enable_SCL_Clock();
000060F2  4EB8 6096 18265          jsr       _Enable_SCL_Clock
                    18266   ; //Enabling I2C for no interupts and enabling core
                    18267   ; Enable_I2C_CS();
000060F6  13FC 0080 18268          move.b    #128,4227076
000060FA  0040 8004 
                    18269   ; return;
000060FE  4E75      18270          rts
                    18271   ; }
                    18272   ; /************************************************************************************
                    18273   ; ** ADC Write Function to measure Thermistor, Potentimeter, Photo-resistor
                    18274   ; ************************************************************************************/
                    18275   ; unsigned char ADCWrite(int type){
                    18276   _ADCWrite:
00006100  4E56 FFE8 18277          link      A6,#-24
00006104  48E7 3030 18278          movem.l   D2/D3/A2/A3,-(A7)
00006108  45F8 60A6 18279          lea       _WaitForI2C_TIP.L,A2
0000610C  262E 0008 18280          move.l    8(A6),D3
00006110  47F8 60CC 18281          lea       _WaitForI2C_RxACK.L,A3
                    18282   ; int i;
                    18283   ; unsigned char c;
                    18284   ; unsigned char* data[3];
                    18285   ; unsigned char temp, light, potential;
                    18286   ; unsigned int delay = 0xFFFFF;
00006114  2D7C 000F 18287          move.l    #1048575,-4(A6)
00006118  FFFF FFFC 
                    18288   ; //Wait for TIP bit in Status Register 
                    18289   ; WaitForI2C_TIP();
0000611C  4E92      18290          jsr       (A2)
                    18291   ; //Send data to Transmit register
                    18292   ; I2C_Transmit = ADC_DAC_WRITE_ADDRESS;
0000611E  13FC 0092 18293          move.b    #146,4227078
00006122  0040 8006 
                    18294   ; //Set Command register
                    18295   ; I2C_Command = I2C_Slave_Write_Start_Command;
00006126  13FC 0091 18296          move.b    #145,4227080
0000612A  0040 8008 
                    18297   ; //Wait for TIP bit in Status Register 
                    18298   ; WaitForI2C_TIP();
0000612E  4E92      18299          jsr       (A2)
                    18300   ; //Wait RxACK bit in Status Register 
                    18301   ; WaitForI2C_RxACK();
00006130  4E93      18302          jsr       (A3)
                    18303   ; //Send data to Transmit register
                    18304   ; I2C_Transmit = ADC_ENABLE_COMMAND;
00006132  13FC 0044 18305          move.b    #68,4227078
00006136  0040 8006 
                    18306   ; //Set Command register
                    18307   ; I2C_Command = I2C_Slave_Write_Command;
0000613A  13FC 0011 18308          move.b    #17,4227080
0000613E  0040 8008 
                    18309   ; //Wait for TIP bit in Status Register 
                    18310   ; WaitForI2C_TIP();
00006142  4E92      18311          jsr       (A2)
                    18312   ; //Wait RxACK bit in Status Register 
                    18313   ; WaitForI2C_RxACK();
00006144  4E93      18314          jsr       (A3)
                    18315   ; //Send data to Transmit register
                    18316   ; I2C_Transmit = ADC_READ_ADDRESS;
00006146  13FC 0093 18317          move.b    #147,4227078
0000614A  0040 8006 
                    18318   ; //Set Command register
                    18319   ; I2C_Command = I2C_Slave_Write_Start_Command;
0000614E  13FC 0091 18320          move.b    #145,4227080
00006152  0040 8008 
                    18321   ; //Wait for TIP bit in Status Register 
                    18322   ; WaitForI2C_TIP();
00006156  4E92      18323          jsr       (A2)
                    18324   ; //Wait RxACK bit in Status Register 
                    18325   ; WaitForI2C_RxACK();
00006158  4E93      18326          jsr       (A3)
                    18327   ; //Set Command register to skip
                    18328   ; I2C_Command = I2C_Slave_Read_Command;
0000615A  13FC 0021 18329          move.b    #33,4227080
0000615E  0040 8008 
                    18330   ; //Wait for TIP bit in Status Register 
                    18331   ; WaitForI2C_TIP();
00006162  4E92      18332          jsr       (A2)
                    18333   ; //Set Command register to skip
                    18334   ; I2C_Command = I2C_Slave_Read_Command;
00006164  13FC 0021 18335          move.b    #33,4227080
00006168  0040 8008 
                    18336   ; //Wait for TIP bit in Status Register 
                    18337   ; WaitForI2C_TIP();
0000616C  4E92      18338          jsr       (A2)
                    18339   ; //Grabbing read data from Receive Register for Thermistor
                    18340   ; c = I2C_Receive;
0000616E  1439 0040 18341          move.b    4227078,D2
00006172  8006      
                    18342   ; temp = c;
00006174  1D42 FFF9 18343          move.b    D2,-7(A6)
                    18344   ; //Set Command register to skip
                    18345   ; I2C_Command = I2C_Slave_Read_Command;
00006178  13FC 0021 18346          move.b    #33,4227080
0000617C  0040 8008 
                    18347   ; //Wait for TIP bit in Status Register 
                    18348   ; WaitForI2C_TIP();
00006180  4E92      18349          jsr       (A2)
                    18350   ; //Grabbing read data from Receive Register for Potentiometer
                    18351   ; c = I2C_Receive;
00006182  1439 0040 18352          move.b    4227078,D2
00006186  8006      
                    18353   ; potential = c;
00006188  1D42 FFFB 18354          move.b    D2,-5(A6)
                    18355   ; //Set Command register to skip
                    18356   ; I2C_Command = I2C_Slave_Read_Command;
0000618C  13FC 0021 18357          move.b    #33,4227080
00006190  0040 8008 
                    18358   ; //Wait for TIP bit in Status Register 
                    18359   ; WaitForI2C_TIP();
00006194  4E92      18360          jsr       (A2)
                    18361   ; //Grabbing read data from Receive Register for Photo-resister
                    18362   ; c = I2C_Receive;
00006196  1439 0040 18363          move.b    4227078,D2
0000619A  8006      
                    18364   ; light = c;
0000619C  1D42 FFFA 18365          move.b    D2,-6(A6)
                    18366   ; c = 0xFF; //Give garabage value after in case
000061A0  143C 00FF 18367          move.b    #255,D2
                    18368   ; if(type == TEMP){
000061A4  4A83      18369          tst.l     D3
000061A6  6606      18370          bne.s     ADCWrite_1
                    18371   ; return temp;
000061A8  102E FFF9 18372          move.b    -7(A6),D0
000061AC  601E      18373          bra.s     ADCWrite_3
                    18374   ADCWrite_1:
                    18375   ; }else if(type == POTENTIAL){
000061AE  0C83 0000 18376          cmp.l     #1,D3
000061B2  0001      
000061B4  6606      18377          bne.s     ADCWrite_4
                    18378   ; return potential;
000061B6  102E FFFB 18379          move.b    -5(A6),D0
000061BA  6010      18380          bra.s     ADCWrite_3
                    18381   ADCWrite_4:
                    18382   ; }else if(type == LIGHT){
000061BC  0C83 0000 18383          cmp.l     #2,D3
000061C0  0002      
000061C2  6606      18384          bne.s     ADCWrite_6
                    18385   ; return light;
000061C4  102E FFFA 18386          move.b    -6(A6),D0
000061C8  6002      18387          bra.s     ADCWrite_3
                    18388   ADCWrite_6:
                    18389   ; }else{
                    18390   ; return c;
000061CA  1002      18391          move.b    D2,D0
                    18392   ADCWrite_3:
000061CC  4CDF 0C0C 18393          movem.l   (A7)+,D2/D3/A2/A3
000061D0  4E5E      18394          unlk      A6
000061D2  4E75      18395          rts
                    18396   ; }
                    18397   ; }
                    18398   @vsscanf_scanread:
000061D4  4E56 FFFC 18399          link      A6,#-4
000061D8  48E7 0020 18400          movem.l   A2,-(A7)
000061DC  45F9 0800 18401          lea       @vsscanf_bufx,A2
000061E0  0000      
000061E2  4AAE 0008 18402          tst.l     8(A6)
000061E6  6722      18403          beq.s     @vsscanf_scanread_1
000061E8  206E 0008 18404          move.l    8(A6),A0
000061EC  58AE 0008 18405          addq.l    #4,8(A6)
000061F0  2050      18406          move.l    (A0),A0
000061F2  1010      18407          move.b    (A0),D0
000061F4  4880      18408          ext.w     D0
000061F6  48C0      18409          ext.l     D0
000061F8  2D40 FFFC 18410          move.l    D0,-4(A6)
000061FC  6706      18411          beq.s     @vsscanf_scanread_3
000061FE  202E FFFC 18412          move.l    -4(A6),D0
00006202  6002      18413          bra.s     @vsscanf_scanread_4
                    18414   @vsscanf_scanread_3:
00006204  70FF      18415          moveq     #-1,D0
                    18416   @vsscanf_scanread_4:
00006206  6000 0032 18417          bra       @vsscanf_scanread_5
                    18418   @vsscanf_scanread_1:
0000620A  2052      18419          move.l    (A2),A0
0000620C  1010      18420          move.b    (A0),D0
0000620E  6620      18421          bne.s     @vsscanf_scanread_6
00006210  4879 0800 18422          pea       @vsscanf_buf
00006214  120E      
00006216  6100 0A02 18423          bsr       _gets
0000621A  584F      18424          addq.w    #4,A7
0000621C  2480      18425          move.l    D0,(A2)
0000621E  4879 0800 18426          pea       @vsscanf_1
00006222  0004      
00006224  4879 0800 18427          pea       @vsscanf_buf
00006228  120E      
0000622A  6100 0A8E 18428          bsr       _strcat
0000622E  504F      18429          addq.w    #8,A7
                    18430   @vsscanf_scanread_6:
00006230  2052      18431          move.l    (A2),A0
00006232  5292      18432          addq.l    #1,(A2)
00006234  1010      18433          move.b    (A0),D0
00006236  4880      18434          ext.w     D0
00006238  48C0      18435          ext.l     D0
                    18436   @vsscanf_scanread_5:
0000623A  4CDF 0400 18437          movem.l   (A7)+,A2
0000623E  4E5E      18438          unlk      A6
00006240  4E75      18439          rts
                    18440   @vsscanf_scanputback:
00006242  4E56 0000 18441          link      A6,#0
00006246  48E7 3000 18442          movem.l   D2/D3,-(A7)
0000624A  242E 000C 18443          move.l    12(A6),D2
0000624E  262E 0008 18444          move.l    8(A6),D3
00006252  6718      18445          beq.s     @vsscanf_scanputback_1
00006254  0C82 FFFF 18446          cmp.l     #-1,D2
00006258  FFFF      
0000625A  670A      18447          beq.s     @vsscanf_scanputback_3
0000625C  5983      18448          subq.l    #4,D3
0000625E  2043      18449          move.l    D3,A0
00006260  2050      18450          move.l    (A0),A0
00006262  1082      18451          move.b    D2,(A0)
00006264  6004      18452          bra.s     @vsscanf_scanputback_4
                    18453   @vsscanf_scanputback_3:
00006266  2043      18454          move.l    D3,A0
00006268  5390      18455          subq.l    #1,(A0)
                    18456   @vsscanf_scanputback_4:
0000626A  602E      18457          bra.s     @vsscanf_scanputback_6
                    18458   @vsscanf_scanputback_1:
0000626C  41F9 0800 18459          lea       @vsscanf_buf,A0
00006270  120E      
00006272  2008      18460          move.l    A0,D0
00006274  B0B9 0800 18461          cmp.l     @vsscanf_bufx,D0
00006278  0000      
0000627A  6610      18462          bne.s     @vsscanf_scanputback_5
0000627C  4239 0800 18463          clr.b     @vsscanf_buf
00006280  120E      
00006282  2F02      18464          move.l    D2,-(A7)
00006284  6100 0A76 18465          bsr       _ungetch
00006288  584F      18466          addq.w    #4,A7
0000628A  600E      18467          bra.s     @vsscanf_scanputback_6
                    18468   @vsscanf_scanputback_5:
0000628C  53B9 0800 18469          subq.l    #1,@vsscanf_bufx
00006290  0000      
00006292  2079 0800 18470          move.l    @vsscanf_bufx,A0
00006296  0000      
00006298  1082      18471          move.b    D2,(A0)
                    18472   @vsscanf_scanputback_6:
0000629A  2002      18473          move.l    D2,D0
0000629C  4CDF 000C 18474          movem.l   (A7)+,D2/D3
000062A0  4E5E      18475          unlk      A6
000062A2  4E75      18476          rts
                    18477   @vsscanf_scanspace:
000062A4  4E56 0000 18478          link      A6,#0
000062A8  48E7 2000 18479          movem.l   D2,-(A7)
                    18480   @vsscanf_scanspace_1:
000062AC  2F2E 0008 18481          move.l    8(A6),-(A7)
000062B0  6100 FF22 18482          bsr       @vsscanf_scanread
000062B4  584F      18483          addq.w    #4,A7
000062B6  2400      18484          move.l    D0,D2
000062B8  206E 000C 18485          move.l    12(A6),A0
000062BC  5290      18486          addq.l    #1,(A0)
000062BE  2042      18487          move.l    D2,A0
000062C0  43F9 0800 18488          lea       __ctype,A1
000062C4  0006      
000062C6  1030 9801 18489          move.b    1(A0,A1.L),D0
000062CA  C03C 0010 18490          and.b     #16,D0
000062CE  66DC      18491          bne       @vsscanf_scanspace_1
000062D0  2002      18492          move.l    D2,D0
000062D2  4CDF 0004 18493          movem.l   (A7)+,D2
000062D6  4E5E      18494          unlk      A6
000062D8  4E75      18495          rts
                    18496   @vsscanf_scanselect:
000062DA  4E56 0000 18497          link      A6,#0
000062DE  48E7 3F20 18498          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
000062E2  262E 000C 18499          move.l    12(A6),D3
000062E6  2C2E 0018 18500          move.l    24(A6),D6
000062EA  2E2E 0014 18501          move.l    20(A6),D7
000062EE  2043      18502          move.l    D3,A0
000062F0  1010      18503          move.b    (A0),D0
000062F2  4880      18504          ext.w     D0
000062F4  48C0      18505          ext.l     D0
000062F6  0C80 0000 18506          cmp.l     #94,D0
000062FA  005E      
000062FC  6608      18507          bne.s     @vsscanf_scanselect_1
000062FE  347C 0001 18508          move.w    #1,A2
00006302  5283      18509          addq.l    #1,D3
00006304  6004      18510          bra.s     @vsscanf_scanselect_2
                    18511   @vsscanf_scanselect_1:
00006306  347C 0000 18512          move.w    #0,A2
                    18513   @vsscanf_scanselect_2:
0000630A  202E 0010 18514          move.l    16(A6),D0
0000630E  53AE 0010 18515          subq.l    #1,16(A6)
00006312  4A80      18516          tst.l     D0
00006314  6700 0108 18517          beq       @vsscanf_scanselect_5
00006318  2F2E 0008 18518          move.l    8(A6),-(A7)
0000631C  6100 FEB6 18519          bsr       @vsscanf_scanread
00006320  584F      18520          addq.w    #4,A7
00006322  2800      18521          move.l    D0,D4
00006324  0C84 FFFF 18522          cmp.l     #-1,D4
00006328  FFFF      
0000632A  6604      18523          bne.s     @vsscanf_scanselect_6
0000632C  6000 00F0 18524          bra       @vsscanf_scanselect_5
                    18525   @vsscanf_scanselect_6:
00006330  206E 001C 18526          move.l    28(A6),A0
00006334  5290      18527          addq.l    #1,(A0)
00006336  4285      18528          clr.l     D5
00006338  4282      18529          clr.l     D2
                    18530   @vsscanf_scanselect_8:
0000633A  2043      18531          move.l    D3,A0
0000633C  1030 2800 18532          move.b    0(A0,D2.L),D0
00006340  4880      18533          ext.w     D0
00006342  48C0      18534          ext.l     D0
00006344  0C80 0000 18535          cmp.l     #93,D0
00006348  005D      
0000634A  6700 008E 18536          beq       @vsscanf_scanselect_10
0000634E  4A82      18537          tst.l     D2
00006350  6716      18538          beq.s     @vsscanf_scanselect_11
00006352  2043      18539          move.l    D3,A0
00006354  1030 2800 18540          move.b    0(A0,D2.L),D0
00006358  4880      18541          ext.w     D0
0000635A  48C0      18542          ext.l     D0
0000635C  0C80 0000 18543          cmp.l     #93,D0
00006360  005D      
00006362  6604      18544          bne.s     @vsscanf_scanselect_11
00006364  6000 0074 18545          bra       @vsscanf_scanselect_10
                    18546   @vsscanf_scanselect_11:
00006368  4A82      18547          tst.l     D2
0000636A  6700 0058 18548          beq       @vsscanf_scanselect_15
0000636E  2043      18549          move.l    D3,A0
00006370  1030 2800 18550          move.b    0(A0,D2.L),D0
00006374  4880      18551          ext.w     D0
00006376  48C0      18552          ext.l     D0
00006378  0C80 0000 18553          cmp.l     #45,D0
0000637C  002D      
0000637E  6600 0044 18554          bne       @vsscanf_scanselect_15
00006382  2043      18555          move.l    D3,A0
00006384  2002      18556          move.l    D2,D0
00006386  5380      18557          subq.l    #1,D0
00006388  2243      18558          move.l    D3,A1
0000638A  2F08      18559          move.l    A0,-(A7)
0000638C  2042      18560          move.l    D2,A0
0000638E  1230 0800 18561          move.b    0(A0,D0.L),D1
00006392  B230 9801 18562          cmp.b     1(A0,A1.L),D1
00006396  6C00 002C 18563          bge       @vsscanf_scanselect_15
0000639A  205F      18564          move.l    (A7)+,A0
0000639C  2043      18565          move.l    D3,A0
0000639E  2002      18566          move.l    D2,D0
000063A0  5380      18567          subq.l    #1,D0
000063A2  1030 0800 18568          move.b    0(A0,D0.L),D0
000063A6  4880      18569          ext.w     D0
000063A8  48C0      18570          ext.l     D0
000063AA  B880      18571          cmp.l     D0,D4
000063AC  6D12      18572          blt.s     @vsscanf_scanselect_17
000063AE  2043      18573          move.l    D3,A0
000063B0  2242      18574          move.l    D2,A1
000063B2  1031 8801 18575          move.b    1(A1,A0.L),D0
000063B6  4880      18576          ext.w     D0
000063B8  48C0      18577          ext.l     D0
000063BA  B880      18578          cmp.l     D0,D4
000063BC  6E02      18579          bgt.s     @vsscanf_scanselect_17
000063BE  601A      18580          bra.s     @vsscanf_scanselect_10
                    18581   @vsscanf_scanselect_17:
000063C0  5282      18582          addq.l    #1,D2
000063C2  6010      18583          bra.s     @vsscanf_scanselect_19
                    18584   @vsscanf_scanselect_15:
000063C4  2043      18585          move.l    D3,A0
000063C6  1030 2800 18586          move.b    0(A0,D2.L),D0
000063CA  4880      18587          ext.w     D0
000063CC  48C0      18588          ext.l     D0
000063CE  B880      18589          cmp.l     D0,D4
000063D0  6602      18590          bne.s     @vsscanf_scanselect_19
000063D2  6006      18591          bra.s     @vsscanf_scanselect_10
                    18592   @vsscanf_scanselect_19:
000063D4  5282      18593          addq.l    #1,D2
000063D6  6000 FF62 18594          bra       @vsscanf_scanselect_8
                    18595   @vsscanf_scanselect_10:
000063DA  4A82      18596          tst.l     D2
000063DC  6712      18597          beq.s     @vsscanf_scanselect_23
000063DE  2043      18598          move.l    D3,A0
000063E0  1030 2800 18599          move.b    0(A0,D2.L),D0
000063E4  4880      18600          ext.w     D0
000063E6  48C0      18601          ext.l     D0
000063E8  0C80 0000 18602          cmp.l     #93,D0
000063EC  005D      
000063EE  6702      18603          beq.s     @vsscanf_scanselect_21
                    18604   @vsscanf_scanselect_23:
000063F0  7A01      18605          moveq     #1,D5
                    18606   @vsscanf_scanselect_21:
000063F2  200A      18607          move.l    A2,D0
000063F4  6712      18608          beq.s     @vsscanf_scanselect_24
000063F6  4A85      18609          tst.l     D5
000063F8  660C      18610          bne.s     @vsscanf_scanselect_26
000063FA  4A87      18611          tst.l     D7
000063FC  6606      18612          bne.s     @vsscanf_scanselect_28
000063FE  2046      18613          move.l    D6,A0
00006400  5286      18614          addq.l    #1,D6
00006402  1084      18615          move.b    D4,(A0)
                    18616   @vsscanf_scanselect_28:
00006404  6014      18617          bra.s     @vsscanf_scanselect_4
                    18618   @vsscanf_scanselect_26:
00006406  6016      18619          bra.s     @vsscanf_scanselect_5
                    18620   @vsscanf_scanselect_24:
00006408  4A85      18621          tst.l     D5
0000640A  670C      18622          beq.s     @vsscanf_scanselect_30
0000640C  4A87      18623          tst.l     D7
0000640E  6606      18624          bne.s     @vsscanf_scanselect_32
00006410  2046      18625          move.l    D6,A0
00006412  5286      18626          addq.l    #1,D6
00006414  1084      18627          move.b    D4,(A0)
                    18628   @vsscanf_scanselect_32:
00006416  6002      18629          bra.s     @vsscanf_scanselect_4
                    18630   @vsscanf_scanselect_30:
00006418  6004      18631          bra.s     @vsscanf_scanselect_5
                    18632   @vsscanf_scanselect_4:
0000641A  6000 FEEE 18633          bra       @vsscanf_scanselect_2
                    18634   @vsscanf_scanselect_5:
0000641E  0C84 FFFF 18635          cmp.l     #-1,D4
00006422  FFFF      
00006424  6712      18636          beq.s     @vsscanf_scanselect_34
00006426  2F04      18637          move.l    D4,-(A7)
00006428  2F2E 0008 18638          move.l    8(A6),-(A7)
0000642C  6100 FE14 18639          bsr       @vsscanf_scanputback
00006430  504F      18640          addq.w    #8,A7
00006432  206E 001C 18641          move.l    28(A6),A0
00006436  5390      18642          subq.l    #1,(A0)
                    18643   @vsscanf_scanselect_34:
00006438  4A87      18644          tst.l     D7
0000643A  6604      18645          bne.s     @vsscanf_scanselect_36
0000643C  2046      18646          move.l    D6,A0
0000643E  4210      18647          clr.b     (A0)
                    18648   @vsscanf_scanselect_36:
00006440  5283      18649          addq.l    #1,D3
00006442  2043      18650          move.l    D3,A0
00006444  1010      18651          move.b    (A0),D0
00006446  4880      18652          ext.w     D0
00006448  48C0      18653          ext.l     D0
0000644A  0C80 0000 18654          cmp.l     #93,D0
0000644E  005D      
00006450  6702      18655          beq.s     @vsscanf_scanselect_40
00006452  60EC      18656          bra       @vsscanf_scanselect_36
                    18657   @vsscanf_scanselect_40:
00006454  5283      18658          addq.l    #1,D3
00006456  2003      18659          move.l    D3,D0
00006458  4CDF 04FC 18660          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
0000645C  4E5E      18661          unlk      A6
0000645E  4E75      18662          rts
                    18663   _scanflush:
00006460  41F9 0800 18664          lea       @vsscanf_buf,A0
00006464  120E      
00006466  23C8 0800 18665          move.l    A0,@vsscanf_bufx
0000646A  0000      
0000646C  4239 0800 18666          clr.b     @vsscanf_buf
00006470  120E      
00006472  4878 FFFF 18667          pea       -1
00006476  6100 0884 18668          bsr       _ungetch
0000647A  584F      18669          addq.w    #4,A7
0000647C  4E75      18670          rts
                    18671   _vsscanf:
0000647E  4E56 FF88 18672          link      A6,#-120
00006482  48E7 3F3C 18673          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00006486  47F8 61D4 18674          lea       @vsscanf_scanread,A3
0000648A  4AAE 0008 18675          tst.l     8(A6)
0000648E  6706      18676          beq.s     vsscanf_1
00006490  41EE 0008 18677          lea       8(A6),A0
00006494  6004      18678          bra.s     vsscanf_2
                    18679   vsscanf_1:
00006496  4280      18680          clr.l     D0
00006498  2040      18681          move.l    D0,A0
                    18682   vsscanf_2:
0000649A  2A08      18683          move.l    A0,D5
0000649C  42AE FFE4 18684          clr.l     -28(A6)
000064A0  4284      18685          clr.l     D4
                    18686   vsscanf_3:
000064A2  206E 000C 18687          move.l    12(A6),A0
000064A6  52AE 000C 18688          addq.l    #1,12(A6)
000064AA  1010      18689          move.b    (A0),D0
000064AC  4880      18690          ext.w     D0
000064AE  48C0      18691          ext.l     D0
000064B0  2600      18692          move.l    D0,D3
000064B2  6700 05AC 18693          beq       vsscanf_5
000064B6  4286      18694          clr.l     D6
000064B8  387C 0000 18695          move.w    #0,A4
000064BC  0C83 0000 18696          cmp.l     #32,D3
000064C0  0020      
000064C2  6712      18697          beq.s     vsscanf_8
000064C4  0C83 0000 18698          cmp.l     #9,D3
000064C8  0009      
000064CA  670A      18699          beq.s     vsscanf_8
000064CC  0C83 0000 18700          cmp.l     #10,D3
000064D0  000A      
000064D2  6600 0048 18701          bne       vsscanf_6
                    18702   vsscanf_8:
000064D6  2F05      18703          move.l    D5,-(A7)
000064D8  4E93      18704          jsr       (A3)
000064DA  584F      18705          addq.w    #4,A7
000064DC  2400      18706          move.l    D0,D2
000064DE  52AE FFE4 18707          addq.l    #1,-28(A6)
000064E2  0C82 FFFF 18708          cmp.l     #-1,D2
000064E6  FFFF      
000064E8  660E      18709          bne.s     vsscanf_11
000064EA  4A84      18710          tst.l     D4
000064EC  6704      18711          beq.s     vsscanf_13
000064EE  2004      18712          move.l    D4,D0
000064F0  6002      18713          bra.s     vsscanf_14
                    18714   vsscanf_13:
000064F2  70FF      18715          moveq     #-1,D0
                    18716   vsscanf_14:
000064F4  6000 056C 18717          bra       vsscanf_15
                    18718   vsscanf_11:
000064F8  2042      18719          move.l    D2,A0
000064FA  43F9 0800 18720          lea       __ctype,A1
000064FE  0006      
00006500  1030 9801 18721          move.b    1(A0,A1.L),D0
00006504  C03C 0010 18722          and.b     #16,D0
00006508  66CC      18723          bne       vsscanf_8
0000650A  53AE FFE4 18724          subq.l    #1,-28(A6)
0000650E  2F02      18725          move.l    D2,-(A7)
00006510  2F05      18726          move.l    D5,-(A7)
00006512  6100 FD2E 18727          bsr       @vsscanf_scanputback
00006516  504F      18728          addq.w    #8,A7
00006518  6000 0542 18729          bra       vsscanf_139
                    18730   vsscanf_6:
0000651C  0C83 0000 18731          cmp.l     #37,D3
00006520  0025      
00006522  6600 0502 18732          bne       vsscanf_127
00006526  206E 000C 18733          move.l    12(A6),A0
0000652A  52AE 000C 18734          addq.l    #1,12(A6)
0000652E  1010      18735          move.b    (A0),D0
00006530  4880      18736          ext.w     D0
00006532  48C0      18737          ext.l     D0
00006534  2600      18738          move.l    D0,D3
00006536  42AE FFEC 18739          clr.l     -20(A6)
0000653A  4286      18740          clr.l     D6
0000653C  42AE FFE8 18741          clr.l     -24(A6)
00006540  347C 7FFF 18742          move.w    #32767,A2
00006544  0C83 0000 18743          cmp.l     #42,D3
00006548  002A      
0000654A  6612      18744          bne.s     vsscanf_18
0000654C  7C01      18745          moveq     #1,D6
0000654E  206E 000C 18746          move.l    12(A6),A0
00006552  52AE 000C 18747          addq.l    #1,12(A6)
00006556  1010      18748          move.b    (A0),D0
00006558  4880      18749          ext.w     D0
0000655A  48C0      18750          ext.l     D0
0000655C  2600      18751          move.l    D0,D3
                    18752   vsscanf_18:
0000655E  2043      18753          move.l    D3,A0
00006560  43F9 0800 18754          lea       __ctype,A1
00006564  0006      
00006566  1030 9801 18755          move.b    1(A0,A1.L),D0
0000656A  C03C 0004 18756          and.b     #4,D0
0000656E  6700 004E 18757          beq       vsscanf_24
00006572  2003      18758          move.l    D3,D0
00006574  0480 0000 18759          sub.l     #48,D0
00006578  0030      
0000657A  2440      18760          move.l    D0,A2
                    18761   vsscanf_22:
0000657C  206E 000C 18762          move.l    12(A6),A0
00006580  52AE 000C 18763          addq.l    #1,12(A6)
00006584  1010      18764          move.b    (A0),D0
00006586  4880      18765          ext.w     D0
00006588  48C0      18766          ext.l     D0
0000658A  2600      18767          move.l    D0,D3
0000658C  2040      18768          move.l    D0,A0
0000658E  43F9 0800 18769          lea       __ctype,A1
00006592  0006      
00006594  1030 9801 18770          move.b    1(A0,A1.L),D0
00006598  C0BC 0000 18771          and.l     #255,D0
0000659C  00FF      
0000659E  C0BC 0000 18772          and.l     #4,D0
000065A2  0004      
000065A4  6718      18773          beq.s     vsscanf_24
000065A6  70D0      18774          moveq     #-48,D0
000065A8  2F0A      18775          move.l    A2,-(A7)
000065AA  4878 000A 18776          pea       10
000065AE  6100 04FE 18777          bsr       LMUL
000065B2  2217      18778          move.l    (A7),D1
000065B4  504F      18779          addq.w    #8,A7
000065B6  D283      18780          add.l     D3,D1
000065B8  D081      18781          add.l     D1,D0
000065BA  2440      18782          move.l    D0,A2
000065BC  60BE      18783          bra       vsscanf_22
                    18784   vsscanf_24:
000065BE  0C83 0000 18785          cmp.l     #108,D3
000065C2  006C      
000065C4  6708      18786          beq.s     vsscanf_27
000065C6  0C83 0000 18787          cmp.l     #76,D3
000065CA  004C      
000065CC  661A      18788          bne.s     vsscanf_25
                    18789   vsscanf_27:
000065CE  2D7C 0000 18790          move.l    #1,-24(A6)
000065D2  0001 FFE8 
000065D6  206E 000C 18791          move.l    12(A6),A0
000065DA  52AE 000C 18792          addq.l    #1,12(A6)
000065DE  1010      18793          move.b    (A0),D0
000065E0  4880      18794          ext.w     D0
000065E2  48C0      18795          ext.l     D0
000065E4  2600      18796          move.l    D0,D3
000065E6  6020      18797          bra.s     vsscanf_28
                    18798   vsscanf_25:
000065E8  0C83 0000 18799          cmp.l     #104,D3
000065EC  0068      
000065EE  6618      18800          bne.s     vsscanf_28
000065F0  2D7C 0000 18801          move.l    #1,-20(A6)
000065F4  0001 FFEC 
000065F8  206E 000C 18802          move.l    12(A6),A0
000065FC  52AE 000C 18803          addq.l    #1,12(A6)
00006600  1010      18804          move.b    (A0),D0
00006602  4880      18805          ext.w     D0
00006604  48C0      18806          ext.l     D0
00006606  2600      18807          move.l    D0,D3
                    18808   vsscanf_28:
00006608  0C83 0000 18809          cmp.l     #91,D3
0000660C  005B      
0000660E  6600 0036 18810          bne       vsscanf_30
00006612  4A86      18811          tst.l     D6
00006614  660A      18812          bne.s     vsscanf_32
00006616  206E 0010 18813          move.l    16(A6),A0
0000661A  58AE 0010 18814          addq.l    #4,16(A6)
0000661E  2E10      18815          move.l    (A0),D7
                    18816   vsscanf_32:
00006620  486E FFE4 18817          pea       -28(A6)
00006624  2F07      18818          move.l    D7,-(A7)
00006626  2F06      18819          move.l    D6,-(A7)
00006628  2F0A      18820          move.l    A2,-(A7)
0000662A  2F2E 000C 18821          move.l    12(A6),-(A7)
0000662E  2F05      18822          move.l    D5,-(A7)
00006630  6100 FCA8 18823          bsr       @vsscanf_scanselect
00006634  DEFC 0018 18824          add.w     #24,A7
00006638  2D40 000C 18825          move.l    D0,12(A6)
0000663C  4A86      18826          tst.l     D6
0000663E  6602      18827          bne.s     vsscanf_34
00006640  5284      18828          addq.l    #1,D4
                    18829   vsscanf_34:
00006642  6000 0418 18830          bra       vsscanf_139
                    18831   vsscanf_30:
00006646  0C83 0000 18832          cmp.l     #110,D3
0000664A  006E      
0000664C  661A      18833          bne.s     vsscanf_36
0000664E  4A86      18834          tst.l     D6
00006650  6612      18835          bne.s     vsscanf_38
00006652  206E 0010 18836          move.l    16(A6),A0
00006656  58AE 0010 18837          addq.l    #4,16(A6)
0000665A  2E10      18838          move.l    (A0),D7
0000665C  2047      18839          move.l    D7,A0
0000665E  20AE FFE4 18840          move.l    -28(A6),(A0)
00006662  5284      18841          addq.l    #1,D4
                    18842   vsscanf_38:
00006664  6000 03F6 18843          bra       vsscanf_139
                    18844   vsscanf_36:
00006668  0C83 0000 18845          cmp.l     #115,D3
0000666C  0073      
0000666E  6600 00AC 18846          bne       vsscanf_40
00006672  486E FFE4 18847          pea       -28(A6)
00006676  2F05      18848          move.l    D5,-(A7)
00006678  6100 FC2A 18849          bsr       @vsscanf_scanspace
0000667C  504F      18850          addq.w    #8,A7
0000667E  2400      18851          move.l    D0,D2
00006680  4A86      18852          tst.l     D6
00006682  660A      18853          bne.s     vsscanf_42
00006684  206E 0010 18854          move.l    16(A6),A0
00006688  58AE 0010 18855          addq.l    #4,16(A6)
0000668C  2E10      18856          move.l    (A0),D7
                    18857   vsscanf_42:
0000668E  52AE FFE4 18858          addq.l    #1,-28(A6)
                    18859   vsscanf_44:
00006692  200A      18860          move.l    A2,D0
00006694  534A      18861          subq.w    #1,A2
00006696  4A80      18862          tst.l     D0
00006698  6700 0038 18863          beq       vsscanf_46
0000669C  2042      18864          move.l    D2,A0
0000669E  43F9 0800 18865          lea       __ctype,A1
000066A2  0006      
000066A4  1030 9801 18866          move.b    1(A0,A1.L),D0
000066A8  C03C 0010 18867          and.b     #16,D0
000066AC  6624      18868          bne.s     vsscanf_46
000066AE  0C82 FFFF 18869          cmp.l     #-1,D2
000066B2  FFFF      
000066B4  671C      18870          beq.s     vsscanf_46
000066B6  387C 0001 18871          move.w    #1,A4
000066BA  4A86      18872          tst.l     D6
000066BC  6606      18873          bne.s     vsscanf_47
000066BE  2047      18874          move.l    D7,A0
000066C0  5287      18875          addq.l    #1,D7
000066C2  1082      18876          move.b    D2,(A0)
                    18877   vsscanf_47:
000066C4  2F05      18878          move.l    D5,-(A7)
000066C6  4E93      18879          jsr       (A3)
000066C8  584F      18880          addq.w    #4,A7
000066CA  2400      18881          move.l    D0,D2
000066CC  52AE FFE4 18882          addq.l    #1,-28(A6)
000066D0  60C0      18883          bra       vsscanf_44
                    18884   vsscanf_46:
000066D2  4A86      18885          tst.l     D6
000066D4  660A      18886          bne.s     vsscanf_51
000066D6  2047      18887          move.l    D7,A0
000066D8  4210      18888          clr.b     (A0)
000066DA  200C      18889          move.l    A4,D0
000066DC  6702      18890          beq.s     vsscanf_51
000066DE  5284      18891          addq.l    #1,D4
                    18892   vsscanf_51:
000066E0  0C82 FFFF 18893          cmp.l     #-1,D2
000066E4  FFFF      
000066E6  6708      18894          beq.s     vsscanf_55
000066E8  4A86      18895          tst.l     D6
000066EA  661E      18896          bne.s     vsscanf_53
000066EC  200C      18897          move.l    A4,D0
000066EE  661A      18898          bne.s     vsscanf_53
                    18899   vsscanf_55:
000066F0  4A84      18900          tst.l     D4
000066F2  6704      18901          beq.s     vsscanf_56
000066F4  2004      18902          move.l    D4,D0
000066F6  600E      18903          bra.s     vsscanf_59
                    18904   vsscanf_56:
000066F8  0C82 FFFF 18905          cmp.l     #-1,D2
000066FC  FFFF      
000066FE  6604      18906          bne.s     vsscanf_58
00006700  70FF      18907          moveq     #-1,D0
00006702  6002      18908          bra.s     vsscanf_59
                    18909   vsscanf_58:
00006704  2004      18910          move.l    D4,D0
                    18911   vsscanf_59:
00006706  6000 035A 18912          bra       vsscanf_15
                    18913   vsscanf_53:
0000670A  53AE FFE4 18914          subq.l    #1,-28(A6)
0000670E  2F02      18915          move.l    D2,-(A7)
00006710  2F05      18916          move.l    D5,-(A7)
00006712  6100 FB2E 18917          bsr       @vsscanf_scanputback
00006716  504F      18918          addq.w    #8,A7
00006718  6000 0342 18919          bra       vsscanf_139
                    18920   vsscanf_40:
0000671C  0C83 0000 18921          cmp.l     #99,D3
00006720  0063      
00006722  6600 008E 18922          bne       vsscanf_60
00006726  4A86      18923          tst.l     D6
00006728  660A      18924          bne.s     vsscanf_62
0000672A  206E 0010 18925          move.l    16(A6),A0
0000672E  58AE 0010 18926          addq.l    #4,16(A6)
00006732  2E10      18927          move.l    (A0),D7
                    18928   vsscanf_62:
00006734  2F05      18929          move.l    D5,-(A7)
00006736  4E93      18930          jsr       (A3)
00006738  584F      18931          addq.w    #4,A7
0000673A  2400      18932          move.l    D0,D2
0000673C  52AE FFE4 18933          addq.l    #1,-28(A6)
00006740  200A      18934          move.l    A2,D0
00006742  0C80 0000 18935          cmp.l     #32767,D0
00006746  7FFF      
00006748  6604      18936          bne.s     vsscanf_64
0000674A  347C 0001 18937          move.w    #1,A2
                    18938   vsscanf_64:
0000674E  0C82 FFFF 18939          cmp.l     #-1,D2
00006752  FFFF      
00006754  6606      18940          bne.s     vsscanf_66
00006756  4A86      18941          tst.l     D6
00006758  6602      18942          bne.s     vsscanf_66
0000675A  5384      18943          subq.l    #1,D4
                    18944   vsscanf_66:
0000675C  200A      18945          move.l    A2,D0
0000675E  534A      18946          subq.w    #1,A2
00006760  4A80      18947          tst.l     D0
00006762  6720      18948          beq.s     vsscanf_70
00006764  0C82 FFFF 18949          cmp.l     #-1,D2
00006768  FFFF      
0000676A  6718      18950          beq.s     vsscanf_70
0000676C  4A86      18951          tst.l     D6
0000676E  6606      18952          bne.s     vsscanf_71
00006770  2047      18953          move.l    D7,A0
00006772  5287      18954          addq.l    #1,D7
00006774  1082      18955          move.b    D2,(A0)
                    18956   vsscanf_71:
00006776  2F05      18957          move.l    D5,-(A7)
00006778  4E93      18958          jsr       (A3)
0000677A  584F      18959          addq.w    #4,A7
0000677C  2400      18960          move.l    D0,D2
0000677E  52AE FFE4 18961          addq.l    #1,-28(A6)
00006782  60D8      18962          bra       vsscanf_66
                    18963   vsscanf_70:
00006784  0C82 FFFF 18964          cmp.l     #-1,D2
00006788  FFFF      
0000678A  660E      18965          bne.s     vsscanf_73
0000678C  4A84      18966          tst.l     D4
0000678E  6704      18967          beq.s     vsscanf_75
00006790  2004      18968          move.l    D4,D0
00006792  6002      18969          bra.s     vsscanf_76
                    18970   vsscanf_75:
00006794  70FF      18971          moveq     #-1,D0
                    18972   vsscanf_76:
00006796  6000 02CA 18973          bra       vsscanf_15
                    18974   vsscanf_73:
0000679A  4A86      18975          tst.l     D6
0000679C  6602      18976          bne.s     vsscanf_77
0000679E  5284      18977          addq.l    #1,D4
                    18978   vsscanf_77:
000067A0  53AE FFE4 18979          subq.l    #1,-28(A6)
000067A4  2F02      18980          move.l    D2,-(A7)
000067A6  2F05      18981          move.l    D5,-(A7)
000067A8  6100 FA98 18982          bsr       @vsscanf_scanputback
000067AC  504F      18983          addq.w    #8,A7
000067AE  6000 02AC 18984          bra       vsscanf_139
                    18985   vsscanf_60:
000067B2  0C83 0000 18986          cmp.l     #105,D3
000067B6  0069      
000067B8  6600 0060 18987          bne       vsscanf_82
000067BC  486E FFE4 18988          pea       -28(A6)
000067C0  2F05      18989          move.l    D5,-(A7)
000067C2  6100 FAE0 18990          bsr       @vsscanf_scanspace
000067C6  504F      18991          addq.w    #8,A7
000067C8  2400      18992          move.l    D0,D2
000067CA  0C82 0000 18993          cmp.l     #48,D2
000067CE  0030      
000067D0  6600 0038 18994          bne       vsscanf_81
000067D4  387C 0001 18995          move.w    #1,A4
000067D8  2F05      18996          move.l    D5,-(A7)
000067DA  4E93      18997          jsr       (A3)
000067DC  584F      18998          addq.w    #4,A7
000067DE  2400      18999          move.l    D0,D2
000067E0  2F02      19000          move.l    D2,-(A7)
000067E2  6100 04AA 19001          bsr       _tolower
000067E6  584F      19002          addq.w    #4,A7
000067E8  0C80 0000 19003          cmp.l     #120,D0
000067EC  0078      
000067EE  6604      19004          bne.s     vsscanf_83
000067F0  7678      19005          moveq     #120,D3
000067F2  6010      19006          bra.s     vsscanf_84
                    19007   vsscanf_83:
000067F4  53AE FFE4 19008          subq.l    #1,-28(A6)
000067F8  2F02      19009          move.l    D2,-(A7)
000067FA  2F05      19010          move.l    D5,-(A7)
000067FC  6100 FA44 19011          bsr       @vsscanf_scanputback
00006800  504F      19012          addq.w    #8,A7
00006802  766F      19013          moveq     #111,D3
                    19014   vsscanf_84:
00006804  52AE FFE4 19015          addq.l    #1,-28(A6)
00006808  6010      19016          bra.s     vsscanf_82
                    19017   vsscanf_81:
0000680A  53AE FFE4 19018          subq.l    #1,-28(A6)
0000680E  2F02      19019          move.l    D2,-(A7)
00006810  2F05      19020          move.l    D5,-(A7)
00006812  6100 FA2E 19021          bsr       @vsscanf_scanputback
00006816  504F      19022          addq.w    #8,A7
00006818  7664      19023          moveq     #100,D3
                    19024   vsscanf_82:
0000681A  0C83 0000 19025          cmp.l     #100,D3
0000681E  0064      
00006820  671A      19026          beq.s     vsscanf_87
00006822  0C83 0000 19027          cmp.l     #117,D3
00006826  0075      
00006828  6712      19028          beq.s     vsscanf_87
0000682A  0C83 0000 19029          cmp.l     #120,D3
0000682E  0078      
00006830  670A      19030          beq.s     vsscanf_87
00006832  0C83 0000 19031          cmp.l     #111,D3
00006836  006F      
00006838  6600 01A4 19032          bne       vsscanf_85
                    19033   vsscanf_87:
0000683C  486E FFE4 19034          pea       -28(A6)
00006840  2F05      19035          move.l    D5,-(A7)
00006842  6100 FA60 19036          bsr       @vsscanf_scanspace
00006846  504F      19037          addq.w    #8,A7
00006848  2400      19038          move.l    D0,D2
0000684A  2D7C 0000 19039          move.l    #10,-4(A6)
0000684E  000A FFFC 
00006852  0C83 0000 19040          cmp.l     #120,D3
00006856  0078      
00006858  6608      19041          bne.s     vsscanf_88
0000685A  2D7C 0000 19042          move.l    #16,-4(A6)
0000685E  0010 FFFC 
                    19043   vsscanf_88:
00006862  0C83 0000 19044          cmp.l     #111,D3
00006866  006F      
00006868  6608      19045          bne.s     vsscanf_90
0000686A  2D7C 0000 19046          move.l    #8,-4(A6)
0000686E  0008 FFFC 
                    19047   vsscanf_90:
00006872  4A86      19048          tst.l     D6
00006874  660A      19049          bne.s     vsscanf_92
00006876  206E 0010 19050          move.l    16(A6),A0
0000687A  58AE 0010 19051          addq.l    #4,16(A6)
0000687E  2E10      19052          move.l    (A0),D7
                    19053   vsscanf_92:
00006880  42AE FFE0 19054          clr.l     -32(A6)
00006884  52AE FFE4 19055          addq.l    #1,-28(A6)
00006888  0C83 0000 19056          cmp.l     #117,D3
0000688C  0075      
0000688E  6720      19057          beq.s     vsscanf_94
00006890  0C82 0000 19058          cmp.l     #45,D2
00006894  002D      
00006896  6618      19059          bne.s     vsscanf_94
00006898  2F05      19060          move.l    D5,-(A7)
0000689A  4E93      19061          jsr       (A3)
0000689C  584F      19062          addq.w    #4,A7
0000689E  2400      19063          move.l    D0,D2
000068A0  52AE FFE4 19064          addq.l    #1,-28(A6)
000068A4  2D7C 0000 19065          move.l    #1,-32(A6)
000068A8  0001 FFE0 
000068AC  387C 0001 19066          move.w    #1,A4
                    19067   vsscanf_94:
000068B0  3A7C 0000 19068          move.w    #0,A5
000068B4  0C82 FFFF 19069          cmp.l     #-1,D2
000068B8  FFFF      
000068BA  660E      19070          bne.s     vsscanf_96
000068BC  4A84      19071          tst.l     D4
000068BE  6704      19072          beq.s     vsscanf_98
000068C0  2004      19073          move.l    D4,D0
000068C2  6002      19074          bra.s     vsscanf_99
                    19075   vsscanf_98:
000068C4  70FF      19076          moveq     #-1,D0
                    19077   vsscanf_99:
000068C6  6000 019A 19078          bra       vsscanf_15
                    19079   vsscanf_96:
000068CA  200A      19080          move.l    A2,D0
000068CC  534A      19081          subq.w    #1,A2
000068CE  4A80      19082          tst.l     D0
000068D0  6700 0090 19083          beq       vsscanf_102
000068D4  0C83 0000 19084          cmp.l     #120,D3
000068D8  0078      
000068DA  6620      19085          bne.s     vsscanf_104
000068DC  2F02      19086          move.l    D2,-(A7)
000068DE  6100 03F0 19087          bsr       _toupper
000068E2  584F      19088          addq.w    #4,A7
000068E4  0C80 0000 19089          cmp.l     #65,D0
000068E8  0041      
000068EA  6D10      19090          blt.s     vsscanf_104
000068EC  2F02      19091          move.l    D2,-(A7)
000068EE  6100 03E0 19092          bsr       _toupper
000068F2  584F      19093          addq.w    #4,A7
000068F4  0C80 0000 19094          cmp.l     #70,D0
000068F8  0046      
000068FA  6F14      19095          ble.s     vsscanf_103
                    19096   vsscanf_104:
000068FC  2042      19097          move.l    D2,A0
000068FE  43F9 0800 19098          lea       __ctype,A1
00006902  0006      
00006904  1030 9801 19099          move.b    1(A0,A1.L),D0
00006908  C03C 0004 19100          and.b     #4,D0
0000690C  6700 0054 19101          beq       vsscanf_102
                    19102   vsscanf_103:
00006910  2042      19103          move.l    D2,A0
00006912  43F9 0800 19104          lea       __ctype,A1
00006916  0006      
00006918  1030 9801 19105          move.b    1(A0,A1.L),D0
0000691C  C03C 0004 19106          and.b     #4,D0
00006920  6614      19107          bne.s     vsscanf_105
00006922  70F9      19108          moveq     #-7,D0
00006924  2F00      19109          move.l    D0,-(A7)
00006926  2F02      19110          move.l    D2,-(A7)
00006928  6100 03A6 19111          bsr       _toupper
0000692C  584F      19112          addq.w    #4,A7
0000692E  2200      19113          move.l    D0,D1
00006930  201F      19114          move.l    (A7)+,D0
00006932  D081      19115          add.l     D1,D0
00006934  2400      19116          move.l    D0,D2
                    19117   vsscanf_105:
00006936  2F0D      19118          move.l    A5,-(A7)
00006938  2F2E FFFC 19119          move.l    -4(A6),-(A7)
0000693C  6100 0170 19120          bsr       LMUL
00006940  2017      19121          move.l    (A7),D0
00006942  504F      19122          addq.w    #8,A7
00006944  D082      19123          add.l     D2,D0
00006946  0480 0000 19124          sub.l     #48,D0
0000694A  0030      
0000694C  2A40      19125          move.l    D0,A5
0000694E  2F05      19126          move.l    D5,-(A7)
00006950  4E93      19127          jsr       (A3)
00006952  584F      19128          addq.w    #4,A7
00006954  2400      19129          move.l    D0,D2
00006956  52AE FFE4 19130          addq.l    #1,-28(A6)
0000695A  387C 0001 19131          move.w    #1,A4
0000695E  6000 FF6A 19132          bra       vsscanf_96
                    19133   vsscanf_102:
00006962  0C82 FFFF 19134          cmp.l     #-1,D2
00006966  FFFF      
00006968  671A      19135          beq.s     vsscanf_107
0000696A  2F02      19136          move.l    D2,-(A7)
0000696C  2F05      19137          move.l    D5,-(A7)
0000696E  6100 F8D2 19138          bsr       @vsscanf_scanputback
00006972  504F      19139          addq.w    #8,A7
00006974  53AE FFE4 19140          subq.l    #1,-28(A6)
00006978  200C      19141          move.l    A4,D0
0000697A  6606      19142          bne.s     vsscanf_109
0000697C  2004      19143          move.l    D4,D0
0000697E  6000 00E2 19144          bra       vsscanf_15
                    19145   vsscanf_109:
00006982  6012      19146          bra.s     vsscanf_111
                    19147   vsscanf_107:
00006984  200C      19148          move.l    A4,D0
00006986  660E      19149          bne.s     vsscanf_111
00006988  4A84      19150          tst.l     D4
0000698A  6704      19151          beq.s     vsscanf_113
0000698C  2004      19152          move.l    D4,D0
0000698E  6002      19153          bra.s     vsscanf_114
                    19154   vsscanf_113:
00006990  70FF      19155          moveq     #-1,D0
                    19156   vsscanf_114:
00006992  6000 00CE 19157          bra       vsscanf_15
                    19158   vsscanf_111:
00006996  4AAE FFE0 19159          tst.l     -32(A6)
0000699A  6706      19160          beq.s     vsscanf_115
0000699C  200D      19161          move.l    A5,D0
0000699E  4480      19162          neg.l     D0
000069A0  2A40      19163          move.l    D0,A5
                    19164   vsscanf_115:
000069A2  4A86      19165          tst.l     D6
000069A4  661E      19166          bne.s     vsscanf_117
000069A6  4AAE FFE8 19167          tst.l     -24(A6)
000069AA  6706      19168          beq.s     vsscanf_119
000069AC  2047      19169          move.l    D7,A0
000069AE  208D      19170          move.l    A5,(A0)
000069B0  6010      19171          bra.s     vsscanf_122
                    19172   vsscanf_119:
000069B2  4AAE FFEC 19173          tst.l     -20(A6)
000069B6  6706      19174          beq.s     vsscanf_121
000069B8  2047      19175          move.l    D7,A0
000069BA  308D      19176          move.w    A5,(A0)
000069BC  6004      19177          bra.s     vsscanf_122
                    19178   vsscanf_121:
000069BE  2047      19179          move.l    D7,A0
000069C0  208D      19180          move.l    A5,(A0)
                    19181   vsscanf_122:
000069C2  5284      19182          addq.l    #1,D4
                    19183   vsscanf_117:
000069C4  0C82 FFFF 19184          cmp.l     #-1,D2
000069C8  FFFF      
000069CA  660E      19185          bne.s     vsscanf_123
000069CC  4A84      19186          tst.l     D4
000069CE  6704      19187          beq.s     vsscanf_125
000069D0  2004      19188          move.l    D4,D0
000069D2  6002      19189          bra.s     vsscanf_126
                    19190   vsscanf_125:
000069D4  70FF      19191          moveq     #-1,D0
                    19192   vsscanf_126:
000069D6  6000 008A 19193          bra       vsscanf_15
                    19194   vsscanf_123:
000069DA  6000 0080 19195          bra       vsscanf_139
                    19196   vsscanf_85:
000069DE  0C83 0000 19197          cmp.l     #37,D3
000069E2  0025      
000069E4  6600 0040 19198          bne       vsscanf_127
000069E8  2F05      19199          move.l    D5,-(A7)
000069EA  4E93      19200          jsr       (A3)
000069EC  584F      19201          addq.w    #4,A7
000069EE  2400      19202          move.l    D0,D2
000069F0  0C82 FFFF 19203          cmp.l     #-1,D2
000069F4  FFFF      
000069F6  660E      19204          bne.s     vsscanf_129
000069F8  4A84      19205          tst.l     D4
000069FA  6704      19206          beq.s     vsscanf_131
000069FC  2004      19207          move.l    D4,D0
000069FE  6002      19208          bra.s     vsscanf_132
                    19209   vsscanf_131:
00006A00  70FF      19210          moveq     #-1,D0
                    19211   vsscanf_132:
00006A02  6000 005E 19212          bra       vsscanf_15
                    19213   vsscanf_129:
00006A06  52AE FFE4 19214          addq.l    #1,-28(A6)
00006A0A  B483      19215          cmp.l     D3,D2
00006A0C  6714      19216          beq.s     vsscanf_133
00006A0E  2F02      19217          move.l    D2,-(A7)
00006A10  2F05      19218          move.l    D5,-(A7)
00006A12  6100 F82E 19219          bsr       @vsscanf_scanputback
00006A16  504F      19220          addq.w    #8,A7
00006A18  53AE FFE4 19221          subq.l    #1,-28(A6)
00006A1C  2004      19222          move.l    D4,D0
00006A1E  6000 0042 19223          bra       vsscanf_15
                    19224   vsscanf_133:
00006A22  6000 0038 19225          bra       vsscanf_139
                    19226   vsscanf_127:
00006A26  2F05      19227          move.l    D5,-(A7)
00006A28  4E93      19228          jsr       (A3)
00006A2A  584F      19229          addq.w    #4,A7
00006A2C  2400      19230          move.l    D0,D2
00006A2E  52AE FFE4 19231          addq.l    #1,-28(A6)
00006A32  0C82 FFFF 19232          cmp.l     #-1,D2
00006A36  FFFF      
00006A38  660C      19233          bne.s     vsscanf_135
00006A3A  4A84      19234          tst.l     D4
00006A3C  6704      19235          beq.s     vsscanf_137
00006A3E  2004      19236          move.l    D4,D0
00006A40  6002      19237          bra.s     vsscanf_138
                    19238   vsscanf_137:
00006A42  70FF      19239          moveq     #-1,D0
                    19240   vsscanf_138:
00006A44  601C      19241          bra.s     vsscanf_15
                    19242   vsscanf_135:
00006A46  B483      19243          cmp.l     D3,D2
00006A48  6712      19244          beq.s     vsscanf_139
00006A4A  2F02      19245          move.l    D2,-(A7)
00006A4C  2F05      19246          move.l    D5,-(A7)
00006A4E  6100 F7F2 19247          bsr       @vsscanf_scanputback
00006A52  504F      19248          addq.w    #8,A7
00006A54  53AE FFE4 19249          subq.l    #1,-28(A6)
00006A58  2004      19250          move.l    D4,D0
00006A5A  6006      19251          bra.s     vsscanf_15
                    19252   vsscanf_139:
00006A5C  6000 FA44 19253          bra       vsscanf_3
                    19254   vsscanf_5:
00006A60  2004      19255          move.l    D4,D0
                    19256   vsscanf_15:
00006A62  4CDF 3CFC 19257          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00006A66  4E5E      19258          unlk      A6
00006A68  4E75      19259          rts
                    19260   _printf:
00006A6A  4E56 FFFC 19261          link      A6,#-4
00006A6E  48E7 2000 19262          movem.l   D2,-(A7)
00006A72  41EE 0008 19263          lea       8(A6),A0
00006A76  5848      19264          addq.w    #4,A0
00006A78  2408      19265          move.l    A0,D2
00006A7A  2F02      19266          move.l    D2,-(A7)
00006A7C  2F2E 0008 19267          move.l    8(A6),-(A7)
00006A80  42A7      19268          clr.l     -(A7)
00006A82  6100 033E 19269          bsr       _vsprintf
00006A86  DEFC 000C 19270          add.w     #12,A7
00006A8A  2D40 FFFC 19271          move.l    D0,-4(A6)
00006A8E  4282      19272          clr.l     D2
00006A90  202E FFFC 19273          move.l    -4(A6),D0
00006A94  4CDF 0004 19274          movem.l   (A7)+,D2
00006A98  4E5E      19275          unlk      A6
00006A9A  4E75      19276          rts
                    19277   ULMUL:
00006A9C  4E56 0000 19278          link    A6,#0
00006AA0  48E7 C000 19279          movem.l D0/D1,-(A7)
00006AA4  222E 0008 19280          move.l  8(A6),D1
00006AA8  202E 000C 19281          move.l  12(A6),D0
00006AAC  602C      19282          bra.s   lmul_3
                    19283   LMUL:
00006AAE  4E56 0000 19284          link    A6,#0
00006AB2  48E7 C000 19285          movem.l D0/D1,-(A7)
00006AB6  222E 0008 19286          move.l  8(A6),D1
00006ABA  202E 000C 19287          move.l  12(A6),D0
00006ABE  4A80      19288          tst.l   D0
00006AC0  6A0A      19289          bpl.s   lmul_1
00006AC2  4480      19290          neg.l   D0
00006AC4  4A81      19291          tst.l   D1
00006AC6  6A0A      19292          bpl.s   lmul_2
00006AC8  4481      19293          neg.l   D1
00006ACA  600E      19294          bra.s   lmul_3
                    19295   lmul_1:
00006ACC  4A81      19296          tst.l   D1
00006ACE  6A0A      19297          bpl.s   lmul_3
00006AD0  4481      19298          neg.l   D1
                    19299   lmul_2:
00006AD2  6114      19300          bsr.s   domul
00006AD4  4481      19301          neg.l   D1
00006AD6  4080      19302          negx.l  D0
00006AD8  6002      19303          bra.s   lmul_4
                    19304   lmul_3:
00006ADA  610C      19305          bsr.s   domul
                    19306   lmul_4:
00006ADC  2D41 0008 19307          move.l  D1,8(A6)
00006AE0  4CDF 0003 19308          movem.l (A7)+,D0/D1
00006AE4  4E5E      19309          unlk    A6
00006AE6  4E75      19310          rts
                    19311   domul:
00006AE8  0C81 0000 19312          cmpi.l  #$FFFF,D1
00006AEC  FFFF      
00006AEE  620C      19313          bhi.s   domul_1
00006AF0  0C80 0000 19314          cmpi.l  #$FFFF,D0
00006AF4  FFFF      
00006AF6  620E      19315          bhi.s   domul_2
00006AF8  C2C0      19316          mulu    D0,D1
00006AFA  4E75      19317          rts
                    19318   domul_1:
00006AFC  0C80 0000 19319          cmpi.l  #$FFFF,D0
00006B00  FFFF      
00006B02  6218      19320          bhi.s   domul_4
00006B04  6002      19321          bra.s   domul_3
                    19322   domul_2
00006B06  C141      19323          exg     D0,D1
                    19324   domul_3:
00006B08  2F02      19325          move.l  D2,-(A7)
00006B0A  2401      19326          move.l  D1,D2
00006B0C  4842      19327          swap    D2
00006B0E  C2C0      19328          mulu    D0,D1
00006B10  C4C0      19329          mulu    D0,D2
00006B12  4842      19330          swap    D2
00006B14  4242      19331          clr.w   D2
00006B16  D282      19332          add.l   D2,D1
00006B18  241F      19333          move.l  (A7)+,D2
00006B1A  4E75      19334          rts
                    19335   domul_4:
00006B1C  48E7 3000 19336          movem.l D2/D3,-(A7)
00006B20  2401      19337          move.l  D1,D2
00006B22  2601      19338          move.l  D1,D3
00006B24  C2C0      19339          mulu    D0,D1
00006B26  4842      19340          swap    D2
00006B28  C4C0      19341          mulu    D0,D2
00006B2A  4840      19342          swap    D0
00006B2C  C6C0      19343          mulu    D0,D3
00006B2E  D483      19344          add.l   D3,D2
00006B30  4842      19345          swap    D2
00006B32  4242      19346          clr.w   D2
00006B34  D282      19347          add.l   D2,D1
00006B36  4CDF 000C 19348          movem.l (A7)+,D2/D3
00006B3A  4E75      19349          rts
                    19350   ULDIV:
00006B3C  4E56 0000 19351          link    A6,#0
00006B40  48E7 C000 19352          movem.l D0/D1,-(A7)
00006B44  222E 0008 19353          move.l  8(A6),D1
00006B48  202E 000C 19354          move.l  12(A6),D0
00006B4C  6036      19355          bra.s   ldiv_3
                    19356   LDIV:
00006B4E  4E56 0000 19357          link    A6,#0
00006B52  48E7 C000 19358          movem.l D0/D1,-(A7)
00006B56  222E 0008 19359          move.l  8(A6),D1
00006B5A  202E 000C 19360          move.l  12(A6),D0
00006B5E  4A80      19361          tst.l   D0
00006B60  6A0E      19362          bpl.s   ldiv_1
00006B62  4480      19363          neg.l   D0
00006B64  4A81      19364          tst.l   D1
00006B66  6A14      19365          bpl.s   ldiv_2
00006B68  4481      19366          neg.l   D1
00006B6A  612A      19367          bsr.s   dodiv
00006B6C  4481      19368          neg.l   D1
00006B6E  6016      19369          bra.s   ldiv_4
                    19370   ldiv_1:
00006B70  4A81      19371          tst.l   D1
00006B72  6A10      19372          bpl.s   ldiv_3
00006B74  4481      19373          neg.l   D1
00006B76  611E      19374          bsr.s   dodiv
00006B78  4480      19375          neg.l   D0
00006B7A  600A      19376          bra.s   ldiv_4
                    19377   ldiv_2:
00006B7C  6118      19378          bsr.s   dodiv
00006B7E  4480      19379          neg.l   D0
00006B80  4481      19380          neg.l   D1
00006B82  6002      19381          bra.s   ldiv_4
                    19382   ldiv_3:
00006B84  6110      19383          bsr.s   dodiv
                    19384   ldiv_4:
00006B86  2D40 0008 19385          move.l  D0,8(A6)
00006B8A  2D41 000C 19386          move.l  D1,12(A6)
00006B8E  4CDF 0003 19387          movem.l (A7)+,D0/D1
00006B92  4E5E      19388          unlk    A6
00006B94  4E75      19389          rts
                    19390   dodiv:
00006B96  0C81 0000 19391          cmpi.l  #$FFFF,D1
00006B9A  FFFF      
00006B9C  6236      19392          bhi.s   dodiv_2
00006B9E  0C80 0000 19393          cmpi.l  #$FFFF,D0
00006BA2  FFFF      
00006BA4  6210      19394          bhi.s   dodiv_1
00006BA6  80C1      19395          divu    D1,D0
00006BA8  2200      19396          move.l  D0,D1
00006BAA  4241      19397          clr.w   D1
00006BAC  4841      19398          swap    D1
00006BAE  0280 0000 19399          andi.l  #$FFFF,D0
00006BB2  FFFF      
00006BB4  4E75      19400          rts
                    19401   dodiv_1:
00006BB6  48A7 A000 19402          movem.w D0/D2,-(A7)
00006BBA  4240      19403          clr.w   D0
00006BBC  4840      19404          swap    D0
00006BBE  80C1      19405          divu    D1,D0
00006BC0  3400      19406          move.w  D0,D2
00006BC2  301F      19407          move.w  (A7)+,D0
00006BC4  80C1      19408          divu    D1,D0
00006BC6  4840      19409          swap    D0
00006BC8  4281      19410          clr.l   D1
00006BCA  3200      19411          move.w  D0,D1
00006BCC  3002      19412          move.w  D2,D0
00006BCE  4840      19413          swap    D0
00006BD0  341F      19414          move.w  (A7)+,D2
00006BD2  4E75      19415          rts
                    19416   dodiv_2:
00006BD4  48E7 3800 19417          movem.l D2/D3/D4,-(A7)
00006BD8  2401      19418          move.l  D1,D2
00006BDA  4242      19419          clr.w   D2
00006BDC  4842      19420          swap    D2
00006BDE  5282      19421          addq.l  #1,D2
00006BE0  2600      19422          move.l  D0,D3
00006BE2  2801      19423          move.l  D1,D4
00006BE4  2202      19424          move.l  D2,D1
00006BE6  61CE      19425          bsr.s   dodiv_1
00006BE8  2204      19426          move.l  D4,D1
00006BEA  82C2      19427          divu    D2,D1
00006BEC  80C1      19428          divu    D1,D0
00006BEE  0280 0000 19429          andi.l  #$FFFF,D0
00006BF2  FFFF      
                    19430   dodiv_3:
00006BF4  2204      19431          move.l  D4,D1
00006BF6  2404      19432          move.l  D4,D2
00006BF8  4842      19433          swap    D2
00006BFA  C2C0      19434          mulu    D0,D1
00006BFC  C4C0      19435          mulu    D0,D2
00006BFE  4842      19436          swap    D2
00006C00  D282      19437          add.l   D2,D1
00006C02  9283      19438          sub.l   D3,D1
00006C04  620A      19439          bhi.s   dodiv_4
00006C06  4481      19440          neg.l   D1
00006C08  B881      19441          cmp.l   D1,D4
00006C0A  6208      19442          bhi.s   dodiv_5
00006C0C  5280      19443          addq.l  #1,D0
00006C0E  60E4      19444          bra.s   dodiv_3
                    19445   dodiv_4:
00006C10  5380      19446          subq.l  #1,D0
00006C12  60E0      19447          bra.s   dodiv_3
                    19448   dodiv_5:
00006C14  4CDF 001C 19449          movem.l (A7)+,D2/D3/D4
00006C18  4E75      19450          rts
                    19451   _gets:
00006C1A  4E56 0000 19452          link      A6,#0
00006C1E  48E7 3820 19453          movem.l   D2/D3/D4/A2,-(A7)
00006C22  45F9 0000 19454          lea       _putch,A2
00006C26  7424      
00006C28  282E 0008 19455          move.l    8(A6),D4
00006C2C  2404      19456          move.l    D4,D2
                    19457   gets_1:
00006C2E  6100 0824 19458          bsr       _getch
00006C32  2600      19459          move.l    D0,D3
00006C34  0C80 0000 19460          cmp.l     #10,D0
00006C38  000A      
00006C3A  6700 003C 19461          beq       gets_3
00006C3E  0C83 0000 19462          cmp.l     #8,D3
00006C42  0008      
00006C44  6712      19463          beq.s     gets_4
00006C46  2042      19464          move.l    D2,A0
00006C48  5282      19465          addq.l    #1,D2
00006C4A  1083      19466          move.b    D3,(A0)
00006C4C  4883      19467          ext.w     D3
00006C4E  48C3      19468          ext.l     D3
00006C50  2F03      19469          move.l    D3,-(A7)
00006C52  4E92      19470          jsr       (A2)
00006C54  584F      19471          addq.w    #4,A7
00006C56  601E      19472          bra.s     gets_6
                    19473   gets_4:
00006C58  B484      19474          cmp.l     D4,D2
00006C5A  631A      19475          bls.s     gets_6
00006C5C  4878 0008 19476          pea       8
00006C60  4E92      19477          jsr       (A2)
00006C62  584F      19478          addq.w    #4,A7
00006C64  4878 0020 19479          pea       32
00006C68  4E92      19480          jsr       (A2)
00006C6A  584F      19481          addq.w    #4,A7
00006C6C  4878 0008 19482          pea       8
00006C70  4E92      19483          jsr       (A2)
00006C72  584F      19484          addq.w    #4,A7
00006C74  5382      19485          subq.l    #1,D2
                    19486   gets_6:
00006C76  60B6      19487          bra       gets_1
                    19488   gets_3:
00006C78  4878 000A 19489          pea       10
00006C7C  4E92      19490          jsr       (A2)
00006C7E  584F      19491          addq.w    #4,A7
00006C80  2042      19492          move.l    D2,A0
00006C82  4210      19493          clr.b     (A0)
00006C84  2004      19494          move.l    D4,D0
00006C86  4CDF 041C 19495          movem.l   (A7)+,D2/D3/D4/A2
00006C8A  4E5E      19496          unlk      A6
00006C8C  4E75      19497          rts
                    19498   _tolower:
00006C8E  4E56 0000 19499          link      A6,#0
00006C92  48E7 2000 19500          movem.l   D2,-(A7)
00006C96  242E 0008 19501          move.l    8(A6),D2
00006C9A  0C82 0000 19502          cmp.l     #65,D2
00006C9E  0041      
00006CA0  6D0E      19503          blt.s     tolower_1
00006CA2  0C82 0000 19504          cmp.l     #90,D2
00006CA6  005A      
00006CA8  6E06      19505          bgt.s     tolower_1
00006CAA  84BC 0000 19506          or.l      #32,D2
00006CAE  0020      
                    19507   tolower_1:
00006CB0  2002      19508          move.l    D2,D0
00006CB2  4CDF 0004 19509          movem.l   (A7)+,D2
00006CB6  4E5E      19510          unlk      A6
00006CB8  4E75      19511          rts
                    19512   _strcat:
00006CBA  206F 0004 19513          move.l    (4,A7),A0	
00006CBE  226F 0008 19514          move.l    (8,A7),A1	
00006CC2  2008      19515          move.l    A0,D0		
                    19516   strcat_0:
00006CC4  4A18      19517          tst.b     (A0)+
00006CC6  66FC      19518          bne       strcat_0
00006CC8  5348      19519          subq      #1,A0
                    19520   strcat_1:
00006CCA  10D9      19521          move.b    (A1)+,(A0)+
00006CCC  66FC      19522          bne       strcat_1
00006CCE  4E75      19523          rts
                    19524   _toupper:
00006CD0  4E56 0000 19525          link      A6,#0
00006CD4  48E7 2000 19526          movem.l   D2,-(A7)
00006CD8  242E 0008 19527          move.l    8(A6),D2
00006CDC  0C82 0000 19528          cmp.l     #97,D2
00006CE0  0061      
00006CE2  6D0E      19529          blt.s     toupper_1
00006CE4  0C82 0000 19530          cmp.l     #122,D2
00006CE8  007A      
00006CEA  6E06      19531          bgt.s     toupper_1
00006CEC  C4BC 0000 19532          and.l     #95,D2
00006CF0  005F      
                    19533   toupper_1:
00006CF2  2002      19534          move.l    D2,D0
00006CF4  4CDF 0004 19535          movem.l   (A7)+,D2
00006CF8  4E5E      19536          unlk      A6
00006CFA  4E75      19537          rts
                    19538   _ungetch:
00006CFC  4E56 0000 19539          link      A6,#0
00006D00  23EE 0008 19540          move.l    8(A6),__ungetbuf
00006D04  0800 01D4 
00006D08  202E 0008 19541          move.l    8(A6),D0
00006D0C  4E5E      19542          unlk      A6
00006D0E  4E75      19543          rts
                    19544   @vsprintf_copy:
00006D10  4E56 0000 19545          link      A6,#0
00006D14  206E 0008 19546          move.l    8(A6),A0
00006D18  4A90      19547          tst.l     (A0)
00006D1A  6710      19548          beq.s     @vsprintf_copy_1
00006D1C  202E 000C 19549          move.l    12(A6),D0
00006D20  206E 0008 19550          move.l    8(A6),A0
00006D24  2250      19551          move.l    (A0),A1
00006D26  5290      19552          addq.l    #1,(A0)
00006D28  1280      19553          move.b    D0,(A1)
00006D2A  600A      19554          bra.s     @vsprintf_copy_2
                    19555   @vsprintf_copy_1:
00006D2C  2F2E 000C 19556          move.l    12(A6),-(A7)
00006D30  6100 06F2 19557          bsr       _putch
00006D34  584F      19558          addq.w    #4,A7
                    19559   @vsprintf_copy_2:
00006D36  4E5E      19560          unlk      A6
00006D38  4E75      19561          rts
                    19562   @vsprintf_getval:
00006D3A  4E56 0000 19563          link      A6,#0
00006D3E  48E7 3000 19564          movem.l   D2/D3,-(A7)
00006D42  242E 0008 19565          move.l    8(A6),D2
00006D46  4283      19566          clr.l     D3
00006D48  2042      19567          move.l    D2,A0
00006D4A  2050      19568          move.l    (A0),A0
00006D4C  1010      19569          move.b    (A0),D0
00006D4E  4880      19570          ext.w     D0
00006D50  48C0      19571          ext.l     D0
00006D52  0C80 0000 19572          cmp.l     #42,D0
00006D56  002A      
00006D58  6612      19573          bne.s     @vsprintf_getval_1
00006D5A  206E 000C 19574          move.l    12(A6),A0
00006D5E  2250      19575          move.l    (A0),A1
00006D60  5890      19576          addq.l    #4,(A0)
00006D62  2611      19577          move.l    (A1),D3
00006D64  2042      19578          move.l    D2,A0
00006D66  5290      19579          addq.l    #1,(A0)
00006D68  6000 004E 19580          bra       @vsprintf_getval_5
                    19581   @vsprintf_getval_1:
00006D6C  2042      19582          move.l    D2,A0
00006D6E  2050      19583          move.l    (A0),A0
00006D70  1010      19584          move.b    (A0),D0
00006D72  4880      19585          ext.w     D0
00006D74  48C0      19586          ext.l     D0
00006D76  0C80 0000 19587          cmp.l     #48,D0
00006D7A  0030      
00006D7C  6D00 003A 19588          blt       @vsprintf_getval_5
00006D80  2042      19589          move.l    D2,A0
00006D82  2050      19590          move.l    (A0),A0
00006D84  1010      19591          move.b    (A0),D0
00006D86  4880      19592          ext.w     D0
00006D88  48C0      19593          ext.l     D0
00006D8A  0C80 0000 19594          cmp.l     #57,D0
00006D8E  0039      
00006D90  6E26      19595          bgt.s     @vsprintf_getval_5
00006D92  2F03      19596          move.l    D3,-(A7)
00006D94  4878 000A 19597          pea       10
00006D98  6100 FD14 19598          bsr       LMUL
00006D9C  2017      19599          move.l    (A7),D0
00006D9E  504F      19600          addq.w    #8,A7
00006DA0  2042      19601          move.l    D2,A0
00006DA2  2250      19602          move.l    (A0),A1
00006DA4  5290      19603          addq.l    #1,(A0)
00006DA6  1211      19604          move.b    (A1),D1
00006DA8  4881      19605          ext.w     D1
00006DAA  48C1      19606          ext.l     D1
00006DAC  D081      19607          add.l     D1,D0
00006DAE  0480 0000 19608          sub.l     #48,D0
00006DB2  0030      
00006DB4  2600      19609          move.l    D0,D3
00006DB6  60B4      19610          bra       @vsprintf_getval_1
                    19611   @vsprintf_getval_5:
00006DB8  2003      19612          move.l    D3,D0
00006DBA  4CDF 000C 19613          movem.l   (A7)+,D2/D3
00006DBE  4E5E      19614          unlk      A6
00006DC0  4E75      19615          rts
                    19616   _vsprintf:
00006DC2  4E56 FFCC 19617          link      A6,#-52
00006DC6  48E7 3F3C 19618          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00006DCA  45EE 0008 19619          lea       8(A6),A2
00006DCE  47F8 6D10 19620          lea       @vsprintf_copy,A3
00006DD2  49F9 0000 19621          lea       _ultoa,A4
00006DD6  7586      
00006DD8  4286      19622          clr.l     D6
                    19623   vsprintf_1:
00006DDA  206E 000C 19624          move.l    12(A6),A0
00006DDE  4A10      19625          tst.b     (A0)
00006DE0  6700 0624 19626          beq       vsprintf_3
00006DE4  206E 000C 19627          move.l    12(A6),A0
00006DE8  1010      19628          move.b    (A0),D0
00006DEA  4880      19629          ext.w     D0
00006DEC  48C0      19630          ext.l     D0
00006DEE  0C80 0000 19631          cmp.l     #37,D0
00006DF2  0025      
00006DF4  671C      19632          beq.s     vsprintf_4
00006DF6  206E 000C 19633          move.l    12(A6),A0
00006DFA  52AE 000C 19634          addq.l    #1,12(A6)
00006DFE  1210      19635          move.b    (A0),D1
00006E00  4881      19636          ext.w     D1
00006E02  48C1      19637          ext.l     D1
00006E04  2F01      19638          move.l    D1,-(A7)
00006E06  2F0A      19639          move.l    A2,-(A7)
00006E08  4E93      19640          jsr       (A3)
00006E0A  504F      19641          addq.w    #8,A7
00006E0C  5286      19642          addq.l    #1,D6
00006E0E  6000 05F2 19643          bra       vsprintf_2
                    19644   vsprintf_4:
00006E12  52AE 000C 19645          addq.l    #1,12(A6)
00006E16  422E FFD3 19646          clr.b     -45(A6)
00006E1A  422E FFD2 19647          clr.b     -46(A6)
00006E1E  422E FFD0 19648          clr.b     -48(A6)
00006E22  422E FFCF 19649          clr.b     -49(A6)
00006E26  422E FFCE 19650          clr.b     -50(A6)
00006E2A  422E FFCD 19651          clr.b     -51(A6)
00006E2E  42AE FFFC 19652          clr.l     -4(A6)
00006E32  7AFF      19653          moveq     #-1,D5
00006E34  41EE FFDC 19654          lea       -36(A6),A0
00006E38  2608      19655          move.l    A0,D3
00006E3A  2408      19656          move.l    A0,D2
                    19657   vsprintf_6:
00006E3C  206E 000C 19658          move.l    12(A6),A0
00006E40  1010      19659          move.b    (A0),D0
00006E42  4880      19660          ext.w     D0
00006E44  48C0      19661          ext.l     D0
00006E46  0C80 0000 19662          cmp.l     #43,D0
00006E4A  002B      
00006E4C  6730      19663          beq.s     vsprintf_12
00006E4E  6E18      19664          bgt.s     vsprintf_15
00006E50  0C80 0000 19665          cmp.l     #35,D0
00006E54  0023      
00006E56  6700 003E 19666          beq       vsprintf_14
00006E5A  6E00 0046 19667          bgt       vsprintf_9
00006E5E  0C80 0000 19668          cmp.l     #32,D0
00006E62  0020      
00006E64  6724      19669          beq.s     vsprintf_13
00006E66  603A      19670          bra.s     vsprintf_9
                    19671   vsprintf_15:
00006E68  0C80 0000 19672          cmp.l     #45,D0
00006E6C  002D      
00006E6E  6702      19673          beq.s     vsprintf_11
00006E70  6030      19674          bra.s     vsprintf_9
                    19675   vsprintf_11:
00006E72  1D7C 0001 19676          move.b    #1,-51(A6)
00006E76  FFCD      
00006E78  52AE 000C 19677          addq.l    #1,12(A6)
00006E7C  6026      19678          bra.s     vsprintf_7
                    19679   vsprintf_12:
00006E7E  1D7C 0001 19680          move.b    #1,-50(A6)
00006E82  FFCE      
00006E84  52AE 000C 19681          addq.l    #1,12(A6)
00006E88  601A      19682          bra.s     vsprintf_7
                    19683   vsprintf_13:
00006E8A  1D7C 0001 19684          move.b    #1,-49(A6)
00006E8E  FFCF      
00006E90  52AE 000C 19685          addq.l    #1,12(A6)
00006E94  600E      19686          bra.s     vsprintf_7
                    19687   vsprintf_14:
00006E96  1D7C 0001 19688          move.b    #1,-48(A6)
00006E9A  FFD0      
00006E9C  52AE 000C 19689          addq.l    #1,12(A6)
00006EA0  6002      19690          bra.s     vsprintf_7
                    19691   vsprintf_9:
00006EA2  6002      19692          bra.s     vsprintf_8
                    19693   vsprintf_7:
00006EA4  6096      19694          bra       vsprintf_6
                    19695   vsprintf_8:
00006EA6  206E 000C 19696          move.l    12(A6),A0
00006EAA  1010      19697          move.b    (A0),D0
00006EAC  4880      19698          ext.w     D0
00006EAE  48C0      19699          ext.l     D0
00006EB0  0C80 0000 19700          cmp.l     #48,D0
00006EB4  0030      
00006EB6  660A      19701          bne.s     vsprintf_16
00006EB8  52AE 000C 19702          addq.l    #1,12(A6)
00006EBC  1D7C 0001 19703          move.b    #1,-46(A6)
00006EC0  FFD2      
                    19704   vsprintf_16:
00006EC2  486E 0010 19705          pea       16(A6)
00006EC6  486E 000C 19706          pea       12(A6)
00006ECA  6100 FE6E 19707          bsr       @vsprintf_getval
00006ECE  504F      19708          addq.w    #8,A7
00006ED0  2A40      19709          move.l    D0,A5
00006ED2  206E 000C 19710          move.l    12(A6),A0
00006ED6  1010      19711          move.b    (A0),D0
00006ED8  4880      19712          ext.w     D0
00006EDA  48C0      19713          ext.l     D0
00006EDC  0C80 0000 19714          cmp.l     #46,D0
00006EE0  002E      
00006EE2  6614      19715          bne.s     vsprintf_18
00006EE4  52AE 000C 19716          addq.l    #1,12(A6)
00006EE8  486E 0010 19717          pea       16(A6)
00006EEC  486E 000C 19718          pea       12(A6)
00006EF0  6100 FE48 19719          bsr       @vsprintf_getval
00006EF4  504F      19720          addq.w    #8,A7
00006EF6  2A00      19721          move.l    D0,D5
                    19722   vsprintf_18:
00006EF8  206E 000C 19723          move.l    12(A6),A0
00006EFC  1010      19724          move.b    (A0),D0
00006EFE  4880      19725          ext.w     D0
00006F00  48C0      19726          ext.l     D0
00006F02  0C80 0000 19727          cmp.l     #108,D0
00006F06  006C      
00006F08  660A      19728          bne.s     vsprintf_20
00006F0A  52AE 000C 19729          addq.l    #1,12(A6)
00006F0E  1D7C 0001 19730          move.b    #1,-45(A6)
00006F12  FFD3      
                    19731   vsprintf_20:
00006F14  206E 000C 19732          move.l    12(A6),A0
00006F18  1010      19733          move.b    (A0),D0
00006F1A  4880      19734          ext.w     D0
00006F1C  48C0      19735          ext.l     D0
00006F1E  0C80 0000 19736          cmp.l     #111,D0
00006F22  006F      
00006F24  6700 00D4 19737          beq       vsprintf_27
00006F28  6E34      19738          bgt.s     vsprintf_33
00006F2A  0C80 0000 19739          cmp.l     #100,D0
00006F2E  0064      
00006F30  6700 0054 19740          beq       vsprintf_24
00006F34  6E1C      19741          bgt.s     vsprintf_34
00006F36  0C80 0000 19742          cmp.l     #99,D0
00006F3A  0063      
00006F3C  6700 012C 19743          beq       vsprintf_30
00006F40  6E00 016A 19744          bgt       vsprintf_22
00006F44  0C80 0000 19745          cmp.l     #88,D0
00006F48  0058      
00006F4A  6700 00E6 19746          beq       vsprintf_28
00006F4E  6000 015C 19747          bra       vsprintf_22
                    19748   vsprintf_34:
00006F52  0C80 0000 19749          cmp.l     #105,D0
00006F56  0069      
00006F58  672C      19750          beq.s     vsprintf_24
00006F5A  6000 0150 19751          bra       vsprintf_22
                    19752   vsprintf_33:
00006F5E  0C80 0000 19753          cmp.l     #117,D0
00006F62  0075      
00006F64  6700 005C 19754          beq       vsprintf_26
00006F68  6E0E      19755          bgt.s     vsprintf_35
00006F6A  0C80 0000 19756          cmp.l     #115,D0
00006F6E  0073      
00006F70  6700 011C 19757          beq       vsprintf_31
00006F74  6000 0136 19758          bra       vsprintf_22
                    19759   vsprintf_35:
00006F78  0C80 0000 19760          cmp.l     #120,D0
00006F7C  0078      
00006F7E  6700 00B2 19761          beq       vsprintf_28
00006F82  6000 0128 19762          bra       vsprintf_22
                    19763   vsprintf_24:
00006F86  4A2E FFD3 19764          tst.b     -45(A6)
00006F8A  671A      19765          beq.s     vsprintf_36
00006F8C  4878 000A 19766          pea       10
00006F90  2F03      19767          move.l    D3,-(A7)
00006F92  206E 0010 19768          move.l    16(A6),A0
00006F96  58AE 0010 19769          addq.l    #4,16(A6)
00006F9A  2F10      19770          move.l    (A0),-(A7)
00006F9C  6100 0564 19771          bsr       _ltoa
00006FA0  DEFC 000C 19772          add.w     #12,A7
00006FA4  6018      19773          bra.s     vsprintf_37
                    19774   vsprintf_36:
00006FA6  4878 000A 19775          pea       10
00006FAA  2F03      19776          move.l    D3,-(A7)
00006FAC  206E 0010 19777          move.l    16(A6),A0
00006FB0  58AE 0010 19778          addq.l    #4,16(A6)
00006FB4  2F10      19779          move.l    (A0),-(A7)
00006FB6  6100 054A 19780          bsr       _ltoa
00006FBA  DEFC 000C 19781          add.w     #12,A7
                    19782   vsprintf_37:
00006FBE  6000 00FA 19783          bra       vsprintf_23
                    19784   vsprintf_26:
00006FC2  4A2E FFD3 19785          tst.b     -45(A6)
00006FC6  6718      19786          beq.s     vsprintf_38
00006FC8  4878 000A 19787          pea       10
00006FCC  2F03      19788          move.l    D3,-(A7)
00006FCE  206E 0010 19789          move.l    16(A6),A0
00006FD2  58AE 0010 19790          addq.l    #4,16(A6)
00006FD6  2F10      19791          move.l    (A0),-(A7)
00006FD8  4E94      19792          jsr       (A4)
00006FDA  DEFC 000C 19793          add.w     #12,A7
00006FDE  6016      19794          bra.s     vsprintf_39
                    19795   vsprintf_38:
00006FE0  4878 000A 19796          pea       10
00006FE4  2F03      19797          move.l    D3,-(A7)
00006FE6  206E 0010 19798          move.l    16(A6),A0
00006FEA  58AE 0010 19799          addq.l    #4,16(A6)
00006FEE  2F10      19800          move.l    (A0),-(A7)
00006FF0  4E94      19801          jsr       (A4)
00006FF2  DEFC 000C 19802          add.w     #12,A7
                    19803   vsprintf_39:
00006FF6  6000 00C2 19804          bra       vsprintf_23
                    19805   vsprintf_27:
00006FFA  4A2E FFD3 19806          tst.b     -45(A6)
00006FFE  6718      19807          beq.s     vsprintf_40
00007000  4878 0008 19808          pea       8
00007004  2F03      19809          move.l    D3,-(A7)
00007006  206E 0010 19810          move.l    16(A6),A0
0000700A  58AE 0010 19811          addq.l    #4,16(A6)
0000700E  2F10      19812          move.l    (A0),-(A7)
00007010  4E94      19813          jsr       (A4)
00007012  DEFC 000C 19814          add.w     #12,A7
00007016  6016      19815          bra.s     vsprintf_41
                    19816   vsprintf_40:
00007018  4878 0008 19817          pea       8
0000701C  2F03      19818          move.l    D3,-(A7)
0000701E  206E 0010 19819          move.l    16(A6),A0
00007022  58AE 0010 19820          addq.l    #4,16(A6)
00007026  2F10      19821          move.l    (A0),-(A7)
00007028  4E94      19822          jsr       (A4)
0000702A  DEFC 000C 19823          add.w     #12,A7
                    19824   vsprintf_41:
0000702E  6000 008A 19825          bra       vsprintf_23
                    19826   vsprintf_28:
00007032  4A2E FFD3 19827          tst.b     -45(A6)
00007036  6718      19828          beq.s     vsprintf_42
00007038  4878 0010 19829          pea       16
0000703C  2F03      19830          move.l    D3,-(A7)
0000703E  206E 0010 19831          move.l    16(A6),A0
00007042  58AE 0010 19832          addq.l    #4,16(A6)
00007046  2F10      19833          move.l    (A0),-(A7)
00007048  4E94      19834          jsr       (A4)
0000704A  DEFC 000C 19835          add.w     #12,A7
0000704E  6016      19836          bra.s     vsprintf_43
                    19837   vsprintf_42:
00007050  4878 0010 19838          pea       16
00007054  2F03      19839          move.l    D3,-(A7)
00007056  206E 0010 19840          move.l    16(A6),A0
0000705A  58AE 0010 19841          addq.l    #4,16(A6)
0000705E  2F10      19842          move.l    (A0),-(A7)
00007060  4E94      19843          jsr       (A4)
00007062  DEFC 000C 19844          add.w     #12,A7
                    19845   vsprintf_43:
00007066  6000 0052 19846          bra       vsprintf_23
                    19847   vsprintf_30:
0000706A  206E 0010 19848          move.l    16(A6),A0
0000706E  58AE 0010 19849          addq.l    #4,16(A6)
00007072  2010      19850          move.l    (A0),D0
00007074  2042      19851          move.l    D2,A0
00007076  5282      19852          addq.l    #1,D2
00007078  1080      19853          move.b    D0,(A0)
0000707A  2042      19854          move.l    D2,A0
0000707C  4210      19855          clr.b     (A0)
0000707E  200D      19856          move.l    A5,D0
00007080  6704      19857          beq.s     vsprintf_44
00007082  200D      19858          move.l    A5,D0
00007084  6002      19859          bra.s     vsprintf_45
                    19860   vsprintf_44:
00007086  7001      19861          moveq     #1,D0
                    19862   vsprintf_45:
00007088  2A00      19863          move.l    D0,D5
0000708A  6000 002E 19864          bra       vsprintf_23
                    19865   vsprintf_31:
0000708E  206E 0010 19866          move.l    16(A6),A0
00007092  58AE 0010 19867          addq.l    #4,16(A6)
00007096  2610      19868          move.l    (A0),D3
00007098  0C85 FFFF 19869          cmp.l     #-1,D5
0000709C  FFFF      
0000709E  660A      19870          bne.s     vsprintf_46
000070A0  2F03      19871          move.l    D3,-(A7)
000070A2  6100 0544 19872          bsr       _strlen
000070A6  584F      19873          addq.w    #4,A7
000070A8  2A00      19874          move.l    D0,D5
                    19875   vsprintf_46:
000070AA  600E      19876          bra.s     vsprintf_23
                    19877   vsprintf_22:
000070AC  206E 000C 19878          move.l    12(A6),A0
000070B0  2242      19879          move.l    D2,A1
000070B2  5282      19880          addq.l    #1,D2
000070B4  1290      19881          move.b    (A0),(A1)
000070B6  2042      19882          move.l    D2,A0
000070B8  4210      19883          clr.b     (A0)
                    19884   vsprintf_23:
000070BA  2F03      19885          move.l    D3,-(A7)
000070BC  6100 052A 19886          bsr       _strlen
000070C0  584F      19887          addq.w    #4,A7
000070C2  1800      19888          move.b    D0,D4
000070C4  206E 000C 19889          move.l    12(A6),A0
000070C8  1010      19890          move.b    (A0),D0
000070CA  4880      19891          ext.w     D0
000070CC  48C0      19892          ext.l     D0
000070CE  0C80 0000 19893          cmp.l     #115,D0
000070D2  0073      
000070D4  6618      19894          bne.s     vsprintf_48
000070D6  0C85 0000 19895          cmp.l     #0,D5
000070DA  0000      
000070DC  6D10      19896          blt.s     vsprintf_48
000070DE  4884      19897          ext.w     D4
000070E0  48C4      19898          ext.l     D4
000070E2  B885      19899          cmp.l     D5,D4
000070E4  6F04      19900          ble.s     vsprintf_50
000070E6  1005      19901          move.b    D5,D0
000070E8  6002      19902          bra.s     vsprintf_51
                    19903   vsprintf_50:
000070EA  1004      19904          move.b    D4,D0
                    19905   vsprintf_51:
000070EC  1800      19906          move.b    D0,D4
                    19907   vsprintf_48:
000070EE  206E 000C 19908          move.l    12(A6),A0
000070F2  1010      19909          move.b    (A0),D0
000070F4  4880      19910          ext.w     D0
000070F6  48C0      19911          ext.l     D0
000070F8  0C80 0000 19912          cmp.l     #88,D0
000070FC  0058      
000070FE  6600 0026 19913          bne       vsprintf_56
00007102  41EE FFDC 19914          lea       -36(A6),A0
00007106  2408      19915          move.l    A0,D2
                    19916   vsprintf_54:
00007108  2042      19917          move.l    D2,A0
0000710A  4A10      19918          tst.b     (A0)
0000710C  6718      19919          beq.s     vsprintf_56
0000710E  2042      19920          move.l    D2,A0
00007110  1210      19921          move.b    (A0),D1
00007112  4881      19922          ext.w     D1
00007114  48C1      19923          ext.l     D1
00007116  2F01      19924          move.l    D1,-(A7)
00007118  6100 FBB6 19925          bsr       _toupper
0000711C  584F      19926          addq.w    #4,A7
0000711E  2042      19927          move.l    D2,A0
00007120  1080      19928          move.b    D0,(A0)
00007122  5282      19929          addq.l    #1,D2
00007124  60E2      19930          bra       vsprintf_54
                    19931   vsprintf_56:
00007126  7E00      19932          moveq     #0,D7
00007128  41EE FFD4 19933          lea       -44(A6),A0
0000712C  2408      19934          move.l    A0,D2
0000712E  206E 000C 19935          move.l    12(A6),A0
00007132  1010      19936          move.b    (A0),D0
00007134  4880      19937          ext.w     D0
00007136  48C0      19938          ext.l     D0
00007138  0C80 0000 19939          cmp.l     #100,D0
0000713C  0064      
0000713E  6714      19940          beq.s     vsprintf_59
00007140  206E 000C 19941          move.l    12(A6),A0
00007144  1010      19942          move.b    (A0),D0
00007146  4880      19943          ext.w     D0
00007148  48C0      19944          ext.l     D0
0000714A  0C80 0000 19945          cmp.l     #105,D0
0000714E  0069      
00007150  6600 0076 19946          bne       vsprintf_65
                    19947   vsprintf_59:
00007154  4A2E FFCE 19948          tst.b     -50(A6)
00007158  6612      19949          bne.s     vsprintf_62
0000715A  2043      19950          move.l    D3,A0
0000715C  1010      19951          move.b    (A0),D0
0000715E  4880      19952          ext.w     D0
00007160  48C0      19953          ext.l     D0
00007162  0C80 0000 19954          cmp.l     #45,D0
00007166  002D      
00007168  6600 002E 19955          bne       vsprintf_60
                    19956   vsprintf_62:
0000716C  2043      19957          move.l    D3,A0
0000716E  1010      19958          move.b    (A0),D0
00007170  4880      19959          ext.w     D0
00007172  48C0      19960          ext.l     D0
00007174  0C80 0000 19961          cmp.l     #45,D0
00007178  002D      
0000717A  660E      19962          bne.s     vsprintf_63
0000717C  2043      19963          move.l    D3,A0
0000717E  5283      19964          addq.l    #1,D3
00007180  2242      19965          move.l    D2,A1
00007182  5282      19966          addq.l    #1,D2
00007184  1290      19967          move.b    (A0),(A1)
00007186  5304      19968          subq.b    #1,D4
00007188  6008      19969          bra.s     vsprintf_64
                    19970   vsprintf_63:
0000718A  2042      19971          move.l    D2,A0
0000718C  5282      19972          addq.l    #1,D2
0000718E  10BC 002B 19973          move.b    #43,(A0)
                    19974   vsprintf_64:
00007192  5287      19975          addq.l    #1,D7
00007194  6000 0032 19976          bra       vsprintf_65
                    19977   vsprintf_60:
00007198  4A2E FFCF 19978          tst.b     -49(A6)
0000719C  6700 002A 19979          beq       vsprintf_65
000071A0  2043      19980          move.l    D3,A0
000071A2  1010      19981          move.b    (A0),D0
000071A4  4880      19982          ext.w     D0
000071A6  48C0      19983          ext.l     D0
000071A8  0C80 0000 19984          cmp.l     #45,D0
000071AC  002D      
000071AE  660E      19985          bne.s     vsprintf_67
000071B0  2043      19986          move.l    D3,A0
000071B2  5283      19987          addq.l    #1,D3
000071B4  2242      19988          move.l    D2,A1
000071B6  5282      19989          addq.l    #1,D2
000071B8  1290      19990          move.b    (A0),(A1)
000071BA  5304      19991          subq.b    #1,D4
000071BC  6008      19992          bra.s     vsprintf_68
                    19993   vsprintf_67:
000071BE  2042      19994          move.l    D2,A0
000071C0  5282      19995          addq.l    #1,D2
000071C2  10BC 0020 19996          move.b    #32,(A0)
                    19997   vsprintf_68:
000071C6  5287      19998          addq.l    #1,D7
                    19999   vsprintf_65:
000071C8  4A2E FFD0 20000          tst.b     -48(A6)
000071CC  6700 0066 20001          beq       vsprintf_77
000071D0  206E 000C 20002          move.l    12(A6),A0
000071D4  1010      20003          move.b    (A0),D0
000071D6  4880      20004          ext.w     D0
000071D8  48C0      20005          ext.l     D0
000071DA  0C80 0000 20006          cmp.l     #111,D0
000071DE  006F      
000071E0  671A      20007          beq.s     vsprintf_73
000071E2  6E0C      20008          bgt.s     vsprintf_76
000071E4  0C80 0000 20009          cmp.l     #88,D0
000071E8  0058      
000071EA  6710      20010          beq.s     vsprintf_73
000071EC  6000 0046 20011          bra       vsprintf_77
                    20012   vsprintf_76:
000071F0  0C80 0000 20013          cmp.l     #120,D0
000071F4  0078      
000071F6  6704      20014          beq.s     vsprintf_73
000071F8  6000 003A 20015          bra       vsprintf_77
                    20016   vsprintf_73:
000071FC  2042      20017          move.l    D2,A0
000071FE  5282      20018          addq.l    #1,D2
00007200  10BC 0030 20019          move.b    #48,(A0)
00007204  5287      20020          addq.l    #1,D7
00007206  206E 000C 20021          move.l    12(A6),A0
0000720A  1010      20022          move.b    (A0),D0
0000720C  4880      20023          ext.w     D0
0000720E  48C0      20024          ext.l     D0
00007210  0C80 0000 20025          cmp.l     #120,D0
00007214  0078      
00007216  6712      20026          beq.s     vsprintf_79
00007218  206E 000C 20027          move.l    12(A6),A0
0000721C  1010      20028          move.b    (A0),D0
0000721E  4880      20029          ext.w     D0
00007220  48C0      20030          ext.l     D0
00007222  0C80 0000 20031          cmp.l     #88,D0
00007226  0058      
00007228  660A      20032          bne.s     vsprintf_77
                    20033   vsprintf_79:
0000722A  2042      20034          move.l    D2,A0
0000722C  5282      20035          addq.l    #1,D2
0000722E  10BC 0078 20036          move.b    #120,(A0)
00007232  5287      20037          addq.l    #1,D7
                    20038   vsprintf_77:
00007234  2042      20039          move.l    D2,A0
00007236  4210      20040          clr.b     (A0)
00007238  206E 000C 20041          move.l    12(A6),A0
0000723C  1010      20042          move.b    (A0),D0
0000723E  4880      20043          ext.w     D0
00007240  48C0      20044          ext.l     D0
00007242  0C80 0000 20045          cmp.l     #105,D0
00007246  0069      
00007248  6700 0076 20046          beq       vsprintf_82
0000724C  6E42      20047          bgt.s     vsprintf_93
0000724E  0C80 0000 20048          cmp.l     #99,D0
00007252  0063      
00007254  6700 0084 20049          beq       vsprintf_96
00007258  6E1C      20050          bgt.s     vsprintf_94
0000725A  0C80 0000 20051          cmp.l     #88,D0
0000725E  0058      
00007260  6700 005E 20052          beq       vsprintf_82
00007264  6E00 0184 20053          bgt       vsprintf_80
00007268  0C80 0000 20054          cmp.l     #69,D0
0000726C  0045      
0000726E  6700 0050 20055          beq       vsprintf_82
00007272  6000 0176 20056          bra       vsprintf_80
                    20057   vsprintf_94:
00007276  0C80 0000 20058          cmp.l     #101,D0
0000727A  0065      
0000727C  6700 0042 20059          beq       vsprintf_82
00007280  6E00 0168 20060          bgt       vsprintf_80
00007284  0C80 0000 20061          cmp.l     #100,D0
00007288  0064      
0000728A  6734      20062          beq.s     vsprintf_82
0000728C  6000 015C 20063          bra       vsprintf_80
                    20064   vsprintf_93:
00007290  0C80 0000 20065          cmp.l     #117,D0
00007294  0075      
00007296  6728      20066          beq.s     vsprintf_82
00007298  6E1A      20067          bgt.s     vsprintf_95
0000729A  0C80 0000 20068          cmp.l     #115,D0
0000729E  0073      
000072A0  6700 0038 20069          beq       vsprintf_96
000072A4  6E00 0144 20070          bgt       vsprintf_80
000072A8  0C80 0000 20071          cmp.l     #111,D0
000072AC  006F      
000072AE  6710      20072          beq.s     vsprintf_82
000072B0  6000 0138 20073          bra       vsprintf_80
                    20074   vsprintf_95:
000072B4  0C80 0000 20075          cmp.l     #120,D0
000072B8  0078      
000072BA  6704      20076          beq.s     vsprintf_82
000072BC  6000 012C 20077          bra       vsprintf_80
                    20078   vsprintf_82:
000072C0  4A2E FFD2 20079          tst.b     -46(A6)
000072C4  6714      20080          beq.s     vsprintf_96
000072C6  4A2E FFCD 20081          tst.b     -51(A6)
000072CA  660E      20082          bne.s     vsprintf_96
000072CC  200D      20083          move.l    A5,D0
000072CE  9087      20084          sub.l     D7,D0
000072D0  4884      20085          ext.w     D4
000072D2  48C4      20086          ext.l     D4
000072D4  9084      20087          sub.l     D4,D0
000072D6  2D40 FFFC 20088          move.l    D0,-4(A6)
                    20089   vsprintf_96:
000072DA  202E FFFC 20090          move.l    -4(A6),D0
000072DE  0C80 0000 20091          cmp.l     #0,D0
000072E2  0000      
000072E4  6C04      20092          bge.s     vsprintf_98
000072E6  42AE FFFC 20093          clr.l     -4(A6)
                    20094   vsprintf_98:
000072EA  4A2E FFCD 20095          tst.b     -51(A6)
000072EE  6600 0030 20096          bne       vsprintf_104
000072F2  4884      20097          ext.w     D4
000072F4  48C4      20098          ext.l     D4
000072F6  2004      20099          move.l    D4,D0
000072F8  D0AE FFFC 20100          add.l     -4(A6),D0
000072FC  D087      20101          add.l     D7,D0
000072FE  1D40 FFD1 20102          move.b    D0,-47(A6)
                    20103   vsprintf_102:
00007302  102E FFD1 20104          move.b    -47(A6),D0
00007306  4880      20105          ext.w     D0
00007308  48C0      20106          ext.l     D0
0000730A  220D      20107          move.l    A5,D1
0000730C  534D      20108          subq.w    #1,A5
0000730E  B081      20109          cmp.l     D1,D0
00007310  6C0E      20110          bge.s     vsprintf_104
00007312  4878 0020 20111          pea       32
00007316  2F0A      20112          move.l    A2,-(A7)
00007318  4E93      20113          jsr       (A3)
0000731A  504F      20114          addq.w    #8,A7
0000731C  5286      20115          addq.l    #1,D6
0000731E  60E2      20116          bra       vsprintf_102
                    20117   vsprintf_104:
00007320  41EE FFD4 20118          lea       -44(A6),A0
00007324  2408      20119          move.l    A0,D2
                    20120   vsprintf_105:
00007326  2042      20121          move.l    D2,A0
00007328  4A10      20122          tst.b     (A0)
0000732A  6716      20123          beq.s     vsprintf_107
0000732C  2042      20124          move.l    D2,A0
0000732E  5282      20125          addq.l    #1,D2
00007330  1210      20126          move.b    (A0),D1
00007332  4881      20127          ext.w     D1
00007334  48C1      20128          ext.l     D1
00007336  2F01      20129          move.l    D1,-(A7)
00007338  2F0A      20130          move.l    A2,-(A7)
0000733A  4E93      20131          jsr       (A3)
0000733C  504F      20132          addq.w    #8,A7
0000733E  5286      20133          addq.l    #1,D6
00007340  60E4      20134          bra       vsprintf_105
                    20135   vsprintf_107:
00007342  202E FFFC 20136          move.l    -4(A6),D0
00007346  1D40 FFD1 20137          move.b    D0,-47(A6)
                    20138   vsprintf_108:
0000734A  102E FFD1 20139          move.b    -47(A6),D0
0000734E  532E FFD1 20140          subq.b    #1,-47(A6)
00007352  4A00      20141          tst.b     D0
00007354  670E      20142          beq.s     vsprintf_110
00007356  4878 0030 20143          pea       48
0000735A  2F0A      20144          move.l    A2,-(A7)
0000735C  4E93      20145          jsr       (A3)
0000735E  504F      20146          addq.w    #8,A7
00007360  5286      20147          addq.l    #1,D6
00007362  60E6      20148          bra       vsprintf_108
                    20149   vsprintf_110:
00007364  2043      20150          move.l    D3,A0
00007366  4A10      20151          tst.b     (A0)
00007368  6700 0048 20152          beq       vsprintf_113
0000736C  206E 000C 20153          move.l    12(A6),A0
00007370  1010      20154          move.b    (A0),D0
00007372  4880      20155          ext.w     D0
00007374  48C0      20156          ext.l     D0
00007376  0C80 0000 20157          cmp.l     #115,D0
0000737A  0073      
0000737C  670C      20158          beq.s     vsprintf_116
0000737E  6E18      20159          bgt.s     vsprintf_119
00007380  0C80 0000 20160          cmp.l     #99,D0
00007384  0063      
00007386  6702      20161          beq.s     vsprintf_116
00007388  600E      20162          bra.s     vsprintf_119
                    20163   vsprintf_116:
0000738A  2005      20164          move.l    D5,D0
0000738C  5385      20165          subq.l    #1,D5
0000738E  0C80 0000 20166          cmp.l     #0,D0
00007392  0000      
00007394  6E02      20167          bgt.s     vsprintf_119
00007396  6016      20168          bra.s     vsprintf_115
                    20169   vsprintf_119:
00007398  2043      20170          move.l    D3,A0
0000739A  5283      20171          addq.l    #1,D3
0000739C  1210      20172          move.b    (A0),D1
0000739E  4881      20173          ext.w     D1
000073A0  48C1      20174          ext.l     D1
000073A2  2F01      20175          move.l    D1,-(A7)
000073A4  2F0A      20176          move.l    A2,-(A7)
000073A6  4E93      20177          jsr       (A3)
000073A8  504F      20178          addq.w    #8,A7
000073AA  5286      20179          addq.l    #1,D6
000073AC  6002      20180          bra.s     vsprintf_112
                    20181   vsprintf_115:
000073AE  6002      20182          bra.s     vsprintf_113
                    20183   vsprintf_112:
000073B0  60B2      20184          bra       vsprintf_110
                    20185   vsprintf_113:
000073B2  4A2E FFCD 20186          tst.b     -51(A6)
000073B6  6700 0030 20187          beq       vsprintf_125
000073BA  4884      20188          ext.w     D4
000073BC  48C4      20189          ext.l     D4
000073BE  2004      20190          move.l    D4,D0
000073C0  D0AE FFFC 20191          add.l     -4(A6),D0
000073C4  D087      20192          add.l     D7,D0
000073C6  1D40 FFD1 20193          move.b    D0,-47(A6)
                    20194   vsprintf_123:
000073CA  102E FFD1 20195          move.b    -47(A6),D0
000073CE  4880      20196          ext.w     D0
000073D0  48C0      20197          ext.l     D0
000073D2  220D      20198          move.l    A5,D1
000073D4  534D      20199          subq.w    #1,A5
000073D6  B081      20200          cmp.l     D1,D0
000073D8  6C0E      20201          bge.s     vsprintf_125
000073DA  4878 0020 20202          pea       32
000073DE  2F0A      20203          move.l    A2,-(A7)
000073E0  4E93      20204          jsr       (A3)
000073E2  504F      20205          addq.w    #8,A7
000073E4  5386      20206          subq.l    #1,D6
000073E6  60E2      20207          bra       vsprintf_123
                    20208   vsprintf_125:
000073E8  6014      20209          bra.s     vsprintf_81
                    20210   vsprintf_80:
000073EA  206E 000C 20211          move.l    12(A6),A0
000073EE  1210      20212          move.b    (A0),D1
000073F0  4881      20213          ext.w     D1
000073F2  48C1      20214          ext.l     D1
000073F4  2F01      20215          move.l    D1,-(A7)
000073F6  2F0A      20216          move.l    A2,-(A7)
000073F8  4E93      20217          jsr       (A3)
000073FA  504F      20218          addq.w    #8,A7
000073FC  5286      20219          addq.l    #1,D6
                    20220   vsprintf_81:
000073FE  52AE 000C 20221          addq.l    #1,12(A6)
                    20222   vsprintf_2:
00007402  6000 F9D6 20223          bra       vsprintf_1
                    20224   vsprintf_3:
00007406  4A92      20225          tst.l     (A2)
00007408  6710      20226          beq.s     vsprintf_126
0000740A  4201      20227          clr.b     D1
0000740C  C2BC 0000 20228          and.l     #255,D1
00007410  00FF      
00007412  2F01      20229          move.l    D1,-(A7)
00007414  2F0A      20230          move.l    A2,-(A7)
00007416  4E93      20231          jsr       (A3)
00007418  504F      20232          addq.w    #8,A7
                    20233   vsprintf_126:
0000741A  2006      20234          move.l    D6,D0
0000741C  4CDF 3CFC 20235          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00007420  4E5E      20236          unlk      A6
00007422  4E75      20237          rts
                    20238   _putch:
00007424  4E56 0000 20239          link      A6,#0
00007428  48E7 2000 20240          movem.l   D2,-(A7)
0000742C  242E 0008 20241          move.l    8(A6),D2
00007430  0C82 0000 20242          cmp.l     #10,D2
00007434  000A      
00007436  660A      20243          bne.s     putch_1
00007438  4878 000D 20244          pea       13
0000743C  6100 E6E6 20245          bsr       __putch
00007440  584F      20246          addq.w    #4,A7
                    20247   putch_1:
00007442  2F02      20248          move.l    D2,-(A7)
00007444  6100 E6DE 20249          bsr       __putch
00007448  584F      20250          addq.w    #4,A7
0000744A  2002      20251          move.l    D2,D0
0000744C  4CDF 0004 20252          movem.l   (A7)+,D2
00007450  4E5E      20253          unlk      A6
00007452  4E75      20254          rts
                    20255   _getch:
00007454  48E7 2000 20256          movem.l   D2,-(A7)
00007458  2439 0800 20257          move.l    __ungetbuf,D2
0000745C  01D4      
0000745E  2039 0800 20258          move.l    __ungetbuf,D0
00007462  01D4      
00007464  0C80 FFFF 20259          cmp.l     #-1,D0
00007468  FFFF      
0000746A  670C      20260          beq.s     getch_1
0000746C  23FC FFFF 20261          move.l    #-1,__ungetbuf
00007470  FFFF 0800 
00007474  01D4      
00007476  6010      20262          bra.s     getch_3
                    20263   getch_1:
00007478  6100 E6D6 20264          bsr       __getch
0000747C  2400      20265          move.l    D0,D2
0000747E  0C80 0000 20266          cmp.l     #13,D0
00007482  000D      
00007484  6602      20267          bne.s     getch_3
00007486  740A      20268          moveq     #10,D2
                    20269   getch_3:
00007488  2002      20270          move.l    D2,D0
0000748A  4CDF 0004 20271          movem.l   (A7)+,D2
0000748E  4E75      20272          rts
                    20273   @itoa_convert:
00007490  4E56 0000 20274          link      A6,#0
00007494  48E7 3C00 20275          movem.l   D2/D3/D4/D5,-(A7)
00007498  242E 0008 20276          move.l    8(A6),D2
0000749C  262E 0010 20277          move.l    16(A6),D3
000074A0  2A2E 000C 20278          move.l    12(A6),D5
000074A4  2F05      20279          move.l    D5,-(A7)
000074A6  2F03      20280          move.l    D3,-(A7)
000074A8  6100 F692 20281          bsr       ULDIV
000074AC  202F 0004 20282          move.l    4(A7),D0
000074B0  504F      20283          addq.w    #8,A7
000074B2  2800      20284          move.l    D0,D4
000074B4  BA83      20285          cmp.l     D3,D5
000074B6  651A      20286          blo.s     @itoa_convert_1
000074B8  2F03      20287          move.l    D3,-(A7)
000074BA  2F05      20288          move.l    D5,-(A7)
000074BC  2F03      20289          move.l    D3,-(A7)
000074BE  6100 F67C 20290          bsr       ULDIV
000074C2  2217      20291          move.l    (A7),D1
000074C4  504F      20292          addq.w    #8,A7
000074C6  2F01      20293          move.l    D1,-(A7)
000074C8  2F02      20294          move.l    D2,-(A7)
000074CA  61C4      20295          bsr       @itoa_convert
000074CC  DEFC 000C 20296          add.w     #12,A7
000074D0  2400      20297          move.l    D0,D2
                    20298   @itoa_convert_1:
000074D2  0C84 0000 20299          cmp.l     #9,D4
000074D6  0009      
000074D8  6E0A      20300          bgt.s     @itoa_convert_3
000074DA  2004      20301          move.l    D4,D0
000074DC  0680 0000 20302          add.l     #48,D0
000074E0  0030      
000074E2  600E      20303          bra.s     @itoa_convert_4
                    20304   @itoa_convert_3:
000074E4  2004      20305          move.l    D4,D0
000074E6  0680 0000 20306          add.l     #97,D0
000074EA  0061      
000074EC  0480 0000 20307          sub.l     #10,D0
000074F0  000A      
                    20308   @itoa_convert_4:
000074F2  2042      20309          move.l    D2,A0
000074F4  1080      20310          move.b    D0,(A0)
000074F6  2002      20311          move.l    D2,D0
000074F8  5280      20312          addq.l    #1,D0
000074FA  4CDF 003C 20313          movem.l   (A7)+,D2/D3/D4/D5
000074FE  4E5E      20314          unlk      A6
00007500  4E75      20315          rts
                    20316   _ltoa:
00007502  4E56 0000 20317          link      A6,#0
00007506  48E7 3C00 20318          movem.l   D2/D3/D4/D5,-(A7)
0000750A  242E 0008 20319          move.l    8(A6),D2
0000750E  262E 000C 20320          move.l    12(A6),D3
00007512  2A2E 0010 20321          move.l    16(A6),D5
00007516  2803      20322          move.l    D3,D4
00007518  0C85 0000 20323          cmp.l     #2,D5
0000751C  0002      
0000751E  6D08      20324          blt.s     ltoa_3
00007520  0C85 0000 20325          cmp.l     #36,D5
00007524  0024      
00007526  6F06      20326          ble.s     ltoa_1
                    20327   ltoa_3:
00007528  2003      20328          move.l    D3,D0
0000752A  6000 0052 20329          bra       ltoa_4
                    20330   ltoa_1:
0000752E  0C85 0000 20331          cmp.l     #10,D5
00007532  000A      
00007534  6600 0032 20332          bne       ltoa_5
00007538  0C82 0000 20333          cmp.l     #0,D2
0000753C  0000      
0000753E  6C28      20334          bge.s     ltoa_5
00007540  2002      20335          move.l    D2,D0
00007542  4480      20336          neg.l     D0
00007544  2400      20337          move.l    D0,D2
00007546  0C82 0000 20338          cmp.l     #0,D2
0000754A  0000      
0000754C  6C12      20339          bge.s     ltoa_7
0000754E  4879 0800 20340          pea       @itoa_1
00007552  0108      
00007554  2F03      20341          move.l    D3,-(A7)
00007556  6100 00A2 20342          bsr       _strcpy
0000755A  504F      20343          addq.w    #8,A7
0000755C  2003      20344          move.l    D3,D0
0000755E  601E      20345          bra.s     ltoa_4
                    20346   ltoa_7:
00007560  2044      20347          move.l    D4,A0
00007562  5284      20348          addq.l    #1,D4
00007564  10BC 002D 20349          move.b    #45,(A0)
                    20350   ltoa_5:
00007568  2F05      20351          move.l    D5,-(A7)
0000756A  2F02      20352          move.l    D2,-(A7)
0000756C  2F04      20353          move.l    D4,-(A7)
0000756E  6100 FF20 20354          bsr       @itoa_convert
00007572  DEFC 000C 20355          add.w     #12,A7
00007576  2800      20356          move.l    D0,D4
00007578  2044      20357          move.l    D4,A0
0000757A  4210      20358          clr.b     (A0)
0000757C  2003      20359          move.l    D3,D0
                    20360   ltoa_4:
0000757E  4CDF 003C 20361          movem.l   (A7)+,D2/D3/D4/D5
00007582  4E5E      20362          unlk      A6
00007584  4E75      20363          rts
                    20364   _ultoa:
00007586  4E56 0000 20365          link      A6,#0
0000758A  48E7 3800 20366          movem.l   D2/D3/D4,-(A7)
0000758E  262E 0010 20367          move.l    16(A6),D3
00007592  282E 000C 20368          move.l    12(A6),D4
00007596  2404      20369          move.l    D4,D2
00007598  0C83 0000 20370          cmp.l     #2,D3
0000759C  0002      
0000759E  6D08      20371          blt.s     ultoa_3
000075A0  0C83 0000 20372          cmp.l     #36,D3
000075A4  0024      
000075A6  6F04      20373          ble.s     ultoa_1
                    20374   ultoa_3:
000075A8  2004      20375          move.l    D4,D0
000075AA  6018      20376          bra.s     ultoa_4
                    20377   ultoa_1:
000075AC  2F03      20378          move.l    D3,-(A7)
000075AE  2F2E 0008 20379          move.l    8(A6),-(A7)
000075B2  2F02      20380          move.l    D2,-(A7)
000075B4  6100 FEDA 20381          bsr       @itoa_convert
000075B8  DEFC 000C 20382          add.w     #12,A7
000075BC  2400      20383          move.l    D0,D2
000075BE  2042      20384          move.l    D2,A0
000075C0  4210      20385          clr.b     (A0)
000075C2  2004      20386          move.l    D4,D0
                    20387   ultoa_4:
000075C4  4CDF 001C 20388          movem.l   (A7)+,D2/D3/D4
000075C8  4E5E      20389          unlk      A6
000075CA  4E75      20390          rts
                    20391   _itoa:
000075CC  4E56 0000 20392          link      A6,#0
000075D0  2F2E 0010 20393          move.l    16(A6),-(A7)
000075D4  2F2E 000C 20394          move.l    12(A6),-(A7)
000075D8  2F2E 0008 20395          move.l    8(A6),-(A7)
000075DC  6100 FF24 20396          bsr       _ltoa
000075E0  DEFC 000C 20397          add.w     #12,A7
000075E4  4E5E      20398          unlk      A6
000075E6  4E75      20399          rts
                    20400   _strlen:
000075E8  206F 0004 20401          move.l    (4,A7),A0
000075EC  2248      20402          move.l    A0,A1
                    20403   strlen_1:
000075EE  4A19      20404          tst.b     (A1)+
000075F0  66FC      20405          bne       strlen_1
000075F2  2009      20406          move.l    A1,D0
000075F4  9088      20407          sub.l     A0,D0
000075F6  5380      20408          subq.l    #1,D0
000075F8  4E75      20409          rts
                    20410   _strcpy:
000075FA  206F 0004 20411          move.l    (4,A7),A0
000075FE  226F 0008 20412          move.l    (8,A7),A1
00007602  2008      20413          move.l    A0,D0
                    20414   strcpy_1:
00007604  10D9      20415          move.b    (A1)+,(A0)+
00007606  66FC      20416          bne       strcpy_1
00007608  4E75      20417          rts
                    20418          section   const
          0000 760A 20419   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    20420   
                    20421   @asn6b_~1_1:
0000760A  0D0A 4865 20422          dc.b      13,10,72,101,108,108,111,0
0000760E  6C6C 6F00 
                    20423   @asn6b_~1_2:
00007612  4D61 7474 20424          dc.b      77,97,116,116,104,101,119,32,84,111,110,103
00007616  6865 7720 
0000761A  546F 6E67 
0000761E  2061 6E64 20425          dc.b      32,97,110,100,32,65,121,111,109,105,98,111,32
00007622  2041 796F 
00007626  6D69 626F 
0000762A  20        
0000762B  4177 6F73 20426          dc.b      65,119,111,115,105,107,97,10,0
0000762F  696B 610A 
00007633  00        
                    20427   @asn6b_~1_3:
00007634  4845 4845 20428          dc.b      72,69,72,69,0
00007638  00        
                    20429   @ucos_ii_1:
0000763A  3F00      20430          dc.b      63,0
                    20431   @ucos_ii_2:
0000763C  7543 2F4F 20432          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
00007640  532D 4949 
00007644  2049 646C 
00007648  6500      
                    20433   @ucos_ii_3:
0000764A  7543 2F4F 20434          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
0000764E  532D 4949 
00007652  2053 7461 
00007656  7400      
                    20435   @ucos_ii_4:
00007658  7543 2F4F 20436          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
0000765C  532D 4949 
00007660  2054 6D72 
00007664  4C6F      
00007666  636B 00   20437          dc.b      99,107,0
                    20438   @ucos_ii_5:
0000766A  7543 2F4F 20439          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
0000766E  532D 4949 
00007672  2054 6D72 
00007676  5369      
00007678  676E 616C 20440          dc.b      103,110,97,108,0
0000767C  00        
                    20441   @ucos_ii_6:
0000767E  7543 2F4F 20442          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
00007682  532D 4949 
00007686  2054 6D72 
0000768A  00        
                    20443   _OSUnMapTbl:
0000768C  0000 0100 20444          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
00007690  0200 0100 
00007694  0300 0100 
00007698  0200 0100 
0000769C  0400 0100 
000076A0  0200      
000076A2  0100 0300 20445          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
000076A6  0100 0200 
000076AA  0100 0500 
000076AE  0100 0200 
000076B2  0100 0300 
000076B6  0100      
000076B8  0200 0100 20446          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
000076BC  0400 0100 
000076C0  0200 0100 
000076C4  0300 0100 
000076C8  0200 0100 
000076CC  0600      
000076CE  0100 0200 20447          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
000076D2  0100 0300 
000076D6  0100 0200 
000076DA  0100 0400 
000076DE  0100 0200 
000076E2  0100      
000076E4  0300 0100 20448          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
000076E8  0200 0100 
000076EC  0500 0100 
000076F0  0200 0100 
000076F4  0300 0100 
000076F8  0200      
000076FA  0100 0400 20449          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
000076FE  0100 0200 
00007702  0100 0300 
00007706  0100 0200 
0000770A  0100 0700 
0000770E  0100      
00007710  0200 0100 20450          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
00007714  0300 0100 
00007718  0200 0100 
0000771C  0400 0100 
00007720  0200 0100 
00007724  0300      
00007726  0100 0200 20451          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
0000772A  0100 0500 
0000772E  0100 0200 
00007732  0100 0300 
00007736  0100 0200 
0000773A  0100      
0000773C  0400 0100 20452          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
00007740  0200 0100 
00007744  0300 0100 
00007748  0200 0100 
0000774C  0600 0100 
00007750  0200      
00007752  0100 0300 20453          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
00007756  0100 0200 
0000775A  0100 0400 
0000775E  0100 0200 
00007762  0100 0300 
00007766  0100      
00007768  0200 0100 20454          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
0000776C  0500 0100 
00007770  0200 0100 
00007774  0300 0100 
00007778  0200 0100 
0000777C  0400      
0000777E  0100 0200 20455          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
00007782  0100 0300 
00007786  0100 0200 
0000778A  0100      
                    20456   @canbus~1_1:
0000778C  5661 6C75 20457          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
00007790  6520 6F66 
00007794  2054 6865 
00007798  72        
00007799  6D69 7374 20458          dc.b      109,105,115,116,111,114,32,40,67,65,78,48,41
0000779D  6F72 2028 
000077A1  4341 4E30 
000077A5  29        
000077A6  3A20 2564 20459          dc.b      58,32,37,100,10,0
000077AA  0A00      
                    20460   @canbus~1_2:
000077AC  5661 6C75 20461          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
000077B0  6520 6F66 
000077B4  2050 6F74 
000077B8  65        
000077B9  6E74 696F 20462          dc.b      110,116,105,111,109,101,116,101,114,32,40,67
000077BD  6D65 7465 
000077C1  7220 2843 
000077C5  414E 3029 20463          dc.b      65,78,48,41,58,32,37,100,10,0
000077C9  3A20 2564 
000077CD  0A00      
                    20464   @canbus~1_3:
000077D0  5661 6C75 20465          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
000077D4  6520 6F66 
000077D8  2050 686F 
000077DC  74        
000077DD  6F2D 7265 20466          dc.b      111,45,114,101,115,105,115,116,101,114,32,40
000077E1  7369 7374 
000077E5  6572 2028 
000077E9  4341 4E30 20467          dc.b      67,65,78,48,41,58,32,37,100,10,0
000077ED  293A 2025 
000077F1  640A 00   
                    20468   @canbus~1_4:
000077F4  5661 6C75 20469          dc.b      86,97,108,117,101,32,111,102,32,83,87,91,55
000077F8  6520 6F66 
000077FC  2053 575B 
00007800  37        
00007801  2D30 5D20 20470          dc.b      45,48,93,32,40,67,65,78,48,41,58,32,0
00007805  2843 414E 
00007809  3029 3A20 
0000780D  00        
                    20471   @canbus~1_5:
0000780E  3000      20472          dc.b      48,0
                    20473   @canbus~1_6:
00007810  3100      20474          dc.b      49,0
                    20475   @canbus~1_7:
00007812  0A00      20476          dc.b      10,0
                    20477   @canbus~1_8:
00007814  4552 524F 20478          dc.b      69,82,82,79,82,0
00007818  5200      
                    20479   @canbus~1_9:
0000781A  5661 6C75 20480          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
0000781E  6520 6F66 
00007822  2054 6865 
00007826  72        
00007827  6D69 7374 20481          dc.b      109,105,115,116,111,114,32,40,67,65,78,49,41
0000782B  6F72 2028 
0000782F  4341 4E31 
00007833  29        
00007834  3A20 2564 20482          dc.b      58,32,37,100,10,0
00007838  0A00      
                    20483   @canbus~1_10:
0000783A  5661 6C75 20484          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
0000783E  6520 6F66 
00007842  2050 6F74 
00007846  65        
00007847  6E74 696F 20485          dc.b      110,116,105,111,109,101,116,101,114,32,40,67
0000784B  6D65 7465 
0000784F  7220 2843 
00007853  414E 3129 20486          dc.b      65,78,49,41,58,32,37,100,10,0
00007857  3A20 2564 
0000785B  0A00      
                    20487   @canbus~1_11:
0000785E  5661 6C75 20488          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
00007862  6520 6F66 
00007866  2050 686F 
0000786A  74        
0000786B  6F2D 7265 20489          dc.b      111,45,114,101,115,105,115,116,101,114,32,40
0000786F  7369 7374 
00007873  6572 2028 
00007877  4341 4E31 20490          dc.b      67,65,78,49,41,58,32,37,100,10,0
0000787B  293A 2025 
0000787F  640A 00   
                    20491   @canbus~1_12:
00007882  5661 6C75 20492          dc.b      86,97,108,117,101,32,111,102,32,83,87,91,55
00007886  6520 6F66 
0000788A  2053 575B 
0000788E  37        
0000788F  2D30 5D20 20493          dc.b      45,48,93,32,40,67,65,78,49,41,58,32,0
00007893  2843 414E 
00007897  3129 3A20 
0000789B  00        
                    20494   @canbus~1_13:
0000789C  0D0A 0D0A 20495          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
000078A0  2D2D 2D2D 
000078A4  2043 414E 
000078A8  4255 53   
000078AB  2054 6573 20496          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
000078AF  7420 2D2D 
000078B3  2D2D 0D0A 
000078B7  00        
                    20497   @canbus~1_14:
000078B8  0D0A 00   20498          dc.b      13,10,0
                    20499          section   data
          0000 78BC 20500   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    20501   
08000000            20502              org         RAM				; starting at address $08000000
          0800 0000 20503   begin_RAM  equ         *				; begin ram starts here
          0800 0000 20504   data       equ         *				; data starts here also
                    20505   
                    20506   @vsscanf_bufx:
08000000  0800 120E 20507          dc.l      @vsscanf_buf
                    20508   @vsscanf_1:
08000004  0A00      20509          dc.b      10,0
                    20510   __ctype:
08000006  0040 4040 20511          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
0800000A  4040 4040 
0800000E  4040 5050 
08000012  5050 50   
08000015  4040 4040 20512          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
08000019  4040 4040 
0800001D  4040 4040 
08000021  4040 40   
08000024  4040 40D0 20513          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
08000028  A0A0 A0A0 
0800002C  A0A0 A0A0 
08000030  A0A0 A0A0 20514          dc.b      160,160,160,160,160,160,160,140,140,140,140
08000034  A0A0 A08C 
08000038  8C8C 8C   
0800003B  8C8C 8C8C 20515          dc.b      140,140,140,140,140,140,160,160,160,160,160
0800003F  8C8C A0A0 
08000043  A0A0 A0   
08000046  A0A0 8A8A 20516          dc.b      160,160,138,138,138,138,138,138,130,130,130
0800004A  8A8A 8A8A 
0800004E  8282 82   
08000051  8282 8282 20517          dc.b      130,130,130,130,130,130,130,130,130,130,130
08000055  8282 8282 
08000059  8282 82   
0800005C  8282 8282 20518          dc.b      130,130,130,130,130,130,160,160,160,160,160
08000060  8282 A0A0 
08000064  A0A0 A0   
08000067  A089 8989 20519          dc.b      160,137,137,137,137,137,137,129,129,129,129
0800006B  8989 8981 
0800006F  8181 81   
08000072  8181 8181 20520          dc.b      129,129,129,129,129,129,129,129,129,129,129
08000076  8181 8181 
0800007A  8181 81   
0800007D  8181 8181 20521          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
08000081  81A0 A0A0 
08000085  A040 0000 
08000089  00        
0800008A  0000 0000 20522          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0800008E  0000 0000 
08000092  0000 0000 
08000096  0000 0000 
0800009A  0000 0000 
0800009E  0000      
080000A0  0000 0000 20523          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080000A4  0000 0000 
080000A8  0000 0000 
080000AC  0000 0000 
080000B0  0000 0000 
080000B4  0000      
080000B6  0000 0000 20524          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080000BA  0000 0000 
080000BE  0000 0000 
080000C2  0000 0000 
080000C6  0000 0000 
080000CA  0000      
080000CC  0000 0000 20525          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080000D0  0000 0000 
080000D4  0000 0000 
080000D8  0000 0000 
080000DC  0000 0000 
080000E0  0000      
080000E2  0000 0000 20526          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080000E6  0000 0000 
080000EA  0000 0000 
080000EE  0000 0000 
080000F2  0000 0000 
080000F6  0000      
080000F8  0000 0000 20527          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
080000FC  0000 0000 
08000100  0000 0000 
08000104  0000 00   
                    20528   @itoa_1:
08000108  2D32 3134 20529          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
0800010C  3734 3833 
08000110  3634 3800 
                    20530          section   bss
          0800 0114 20531   bss        equ         *
                    20532   
                    20533   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    20534   
                    20535   *********************************************************************************************************
                    20536   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    20537   * install the exception handler using the C function InstallExceptionHandler()
                    20538   *********************************************************************************************************
                    20539   
08000114            20540   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08000118            20541   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0800011C            20542   VBusError        ds.l    1      storage for address of Bus Error Handler
08000120            20543   VAddressError    ds.l    1      storage for address of Address Error Handler
08000124            20544   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08000128            20545   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0800012C            20546   VCheck           ds.l    1      ditto
08000130            20547   VTrapV           ds.l    1      ditto
08000134            20548   VPrivilege       ds.l    1      ditto
08000138            20549   VTrace           ds.l    1
0800013C            20550   VLine1010emul    ds.l    1
08000140            20551   VLine1111emul    ds.l    1
08000144            20552   VUnassigned1     ds.l    1
08000148            20553   VUnassigned2     ds.l    1
0800014C            20554   VUnassigned3     ds.l    1
08000150            20555   VUninit_IRQ      ds.l    1
08000154            20556   VUnassigned4     ds.l    1
08000158            20557   VUnassigned5     ds.l    1
0800015C            20558   VUnassigned6     ds.l    1
08000160            20559   VUnassigned7     ds.l    1
08000164            20560   VUnassigned8     ds.l    1
08000168            20561   VUnassigned9     ds.l    1
0800016C            20562   VUnassigned10    ds.l    1
08000170            20563   VUnassigned11    ds.l    1
08000174            20564   VSpuriousIRQ     ds.l    1
                    20565   
                    20566   * Interrupt handlers Vector 25-31
08000178            20567   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800017C            20568   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000180            20569   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000184            20570   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000188            20571   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800018C            20572   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000190            20573   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    20574   
                    20575   * Trap Handler vectors 32-47
08000194            20576   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000198            20577   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800019C            20578   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001A0            20579   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001A4            20580   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001A8            20581   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001AC            20582   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001B0            20583   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001B4            20584   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001B8            20585   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001BC            20586   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001C0            20587   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001C4            20588   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001C8            20589   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001CC            20590   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080001D0            20591   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    20592   
                    20593   __ungetbuf:                            ; ungetbuffer for stdio functions
080001D4            20594              ds.l        1
                    20595   __timezone:                            ; difference, in seconds, between local time and UTC
080001D8            20596              ds.l        1
                    20597   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080001DC            20598              ds.l        1
                    20599   __romsize:                             ; size of ROM used by program
080001E0            20600              ds.l        1
                    20601   __ramsize:                             ; size of RAM used by program
080001E4            20602              ds.l        1
                    20603   
                    20604   _Timer5Count:
080001E8            20605          ds.b      1
                    20606   _temp:
080001EA            20607          ds.b      1
                    20608   _potential:
080001EC            20609          ds.b      1
                    20610   _light:
080001EE            20611          ds.b      1
                    20612   _switches:
080001F0            20613          ds.b      4
                    20614   _OSTmrTickCtr:
080001F4            20615          ds.b      1
                    20616   _OSCtxSwCtr:
080001F6            20617          ds.b      4
                    20618   _OSEventFreeList:
080001FA            20619          ds.b      4
                    20620   _OSEventTbl:
080001FE            20621          ds.b      220
                    20622   _OSFlagTbl:
080002DA            20623          ds.b      60
                    20624   _OSFlagFreeList:
08000316            20625          ds.b      4
                    20626   _OSCPUUsage:
0800031A            20627          ds.b      1
                    20628   _OSIdleCtrMax:
0800031C            20629          ds.b      4
                    20630   _OSIdleCtrRun:
08000320            20631          ds.b      4
                    20632   _OSStatRdy:
08000324            20633          ds.b      1
                    20634   _OSTaskStatStk:
08000326            20635          ds.b      256
                    20636   _OSIntNesting:
08000426            20637          ds.b      1
                    20638   _OSLockNesting:
08000428            20639          ds.b      1
                    20640   _OSPrioCur:
0800042A            20641          ds.b      1
                    20642   _OSPrioHighRdy:
0800042C            20643          ds.b      1
                    20644   _OSRdyGrp:
0800042E            20645          ds.b      1
                    20646   _OSRdyTbl:
08000430            20647          ds.b      8
                    20648   _OSRunning:
08000438            20649          ds.b      1
                    20650   _OSTaskCtr:
0800043A            20651          ds.b      1
                    20652   _OSIdleCtr:
0800043C            20653          ds.b      4
                    20654   _OSTaskIdleStk:
08000440            20655          ds.b      256
                    20656   _OSTCBCur:
08000540            20657          ds.b      4
                    20658   _OSTCBFreeList:
08000544            20659          ds.b      4
                    20660   _OSTCBHighRdy:
08000548            20661          ds.b      4
                    20662   _OSTCBList:
0800054C            20663          ds.b      4
                    20664   _OSTCBPrioTbl:
08000550            20665          ds.b      256
                    20666   _OSTCBTbl:
08000650            20667          ds.b      1892
                    20668   _OSMemFreeList:
08000DB4            20669          ds.b      4
                    20670   _OSMemTbl:
08000DB8            20671          ds.b      120
                    20672   _OSQFreeList:
08000E30            20673          ds.b      4
                    20674   _OSQTbl:
08000E34            20675          ds.b      96
                    20676   _OSTaskRegNextAvailID:
08000E94            20677          ds.b      1
                    20678   _OSTime:
08000E96            20679          ds.b      4
                    20680   _OSTmrFree:
08000E9A            20681          ds.b      2
                    20682   _OSTmrUsed:
08000E9C            20683          ds.b      2
                    20684   _OSTmrTime:
08000E9E            20685          ds.b      4
                    20686   _OSTmrSem:
08000EA2            20687          ds.b      4
                    20688   _OSTmrSemSignal:
08000EA6            20689          ds.b      4
                    20690   _OSTmrTbl:
08000EAA            20691          ds.b      576
                    20692   _OSTmrFreeList:
080010EA            20693          ds.b      4
                    20694   _OSTmrTaskStk:
080010EE            20695          ds.b      256
                    20696   _OSTmrWheelTbl:
080011EE            20697          ds.b      32
                    20698   @vsscanf_buf:
0800120E            20699          ds.b      80
                    20700          section   heap
          0800 125E 20701   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 125E 20702   heap       equ         *
                    20703   
          0801 0000 20704   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
