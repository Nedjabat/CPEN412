680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 10 Apr 2023      Time: 15:23:21          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\ASN6_APPLICATION.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0000 09FA   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0000 08EE   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  0000      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  1CEE      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  00C0      
                     116              ;
0000041A  23FC 0000  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  6B04 0800 
00000422  00CC      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  1CEE 0800 
0000042C  00D0      
0000042E  4EB9 0000  119              jsr         _main							; now call main() from our C program (yeah!!!!)
00000432  0698      
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  0064      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  0068      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  006C      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  0070      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  0074      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  0078      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  007C      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  0080      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  0084      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  0088      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  008C      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  0090      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  0094      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  0098      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  009C      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  00A0      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  00A4      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  00A8      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  00AC      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  00B0      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  00B4      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  00B8      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  00BC      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  0008      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  000C      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  0010      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  0014      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  0018      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  001C      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  0020      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  0024      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  0028      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  002C      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   ; C:\IDE68K\UCOSII\ASN6_APPLICATION.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     352   ; /*
                     353   ; * EXAMPLE_1.C
                     354   ; *
                     355   ; * This is a minimal program to verify multitasking.
                     356   ; *
                     357   ; */
                     358   ; #include <stdio.h>
                     359   ; #include "Bios.h"
                     360   ; #include "ucos_ii.h"
                     361   ; #define STACKSIZE 256
                     362   ; /*
                     363   ; ** Stacks for each task are allocated here in the application in this case = 256 bytes
                     364   ; ** but you can change size if required
                     365   ; */
                     366   ; OS_STK Task1Stk[STACKSIZE];
                     367   ; OS_STK Task2Stk[STACKSIZE];
                     368   ; OS_STK Task3Stk[STACKSIZE];
                     369   ; OS_STK Task4Stk[STACKSIZE];
                     370   ; OS_STK Task5Stk[STACKSIZE];
                     371   ; OS_STK Task6Stk[STACKSIZE];
                     372   ; /* Prototypes for our tasks/threads*/
                     373   ; void Task1(void *); /* (void *) means the child task expects no data from parent*/
                     374   ; void Task2(void *);
                     375   ; void Task3(void *);
                     376   ; void Task4(void *);
                     377   ; void Task5(void *);
                     378   ; void Task6(void *);
                     379   ; /*
                     380   ; ** Our main application which has to
                     381   ; ** 1) Initialise any peripherals on the board, e.g. RS232 for hyperterminal + LCD
                     382   ; ** 2) Call OSInit() to initialise the OS
                     383   ; ** 3) Create our application task/threads
                     384   ; ** 4) Call OSStart()
                     385   ; */
                     386   ; void main(void)
                     387   ; {
                     388   _main:
00000698  2F0A       389          move.l    A2,-(A7)
0000069A  45F9 0000  390          lea       _OSTaskCreate.L,A2
0000069E  46B2      
                     391   ; // initialise board hardware by calling our routines from the BIOS.C source file
                     392   ; Init_RS232();
000006A0  4EB9 0000  393          jsr       _Init_RS232
000006A4  5C58      
                     394   ; Init_LCD();
000006A6  4EB9 0000  395          jsr       _Init_LCD
000006AA  5D10      
                     396   ; /* display welcome message on LCD display */
                     397   ; Oline0("Altera DE1/68K");
000006AC  4879 0000  398          pea       @asn6_a~1_1.L
000006B0  6856      
000006B2  4EB9 0000  399          jsr       _Oline0
000006B6  5D86      
000006B8  584F       400          addq.w    #4,A7
                     401   ; Oline1("Micrium uC/OS-II RTOS");
000006BA  4879 0000  402          pea       @asn6_a~1_2.L
000006BE  6866      
000006C0  4EB9 0000  403          jsr       _Oline1
000006C4  5DB4      
000006C6  584F       404          addq.w    #4,A7
                     405   ; OSInit(); // call to initialise the OS
000006C8  4EB9 0000  406          jsr       _OSInit
000006CC  0F7A      
                     407   ; /*
                     408   ; ** Now create the 4 child tasks and pass them no data.
                     409   ; ** the smaller the numerical priority value, the higher the task priority
                     410   ; */
                     411   ; OSTaskCreate(Task1, OS_NULL, &Task1Stk[STACKSIZE], 12);
000006CE  4878 000C  412          pea       12
000006D2  41F9 0800  413          lea       _Task1Stk.L,A0
000006D6  00D4      
000006D8  D0FC 0200  414          add.w     #512,A0
000006DC  2F08       415          move.l    A0,-(A7)
000006DE  42A7       416          clr.l     -(A7)
000006E0  4879 0000  417          pea       _Task1.L
000006E4  078C      
000006E6  4E92       418          jsr       (A2)
000006E8  DEFC 0010  419          add.w     #16,A7
                     420   ; OSTaskCreate(Task2, OS_NULL, &Task2Stk[STACKSIZE], 11); // highest priority task
000006EC  4878 000B  421          pea       11
000006F0  41F9 0800  422          lea       _Task2Stk.L,A0
000006F4  02D4      
000006F6  D0FC 0200  423          add.w     #512,A0
000006FA  2F08       424          move.l    A0,-(A7)
000006FC  42A7       425          clr.l     -(A7)
000006FE  4879 0000  426          pea       _Task2.L
00000702  07CA      
00000704  4E92       427          jsr       (A2)
00000706  DEFC 0010  428          add.w     #16,A7
                     429   ; OSTaskCreate(Task3, OS_NULL, &Task3Stk[STACKSIZE], 13);
0000070A  4878 000D  430          pea       13
0000070E  41F9 0800  431          lea       _Task3Stk.L,A0
00000712  04D4      
00000714  D0FC 0200  432          add.w     #512,A0
00000718  2F08       433          move.l    A0,-(A7)
0000071A  42A7       434          clr.l     -(A7)
0000071C  4879 0000  435          pea       _Task3.L
00000720  0802      
00000722  4E92       436          jsr       (A2)
00000724  DEFC 0010  437          add.w     #16,A7
                     438   ; OSTaskCreate(Task4, OS_NULL, &Task4Stk[STACKSIZE], 14); 
00000728  4878 000E  439          pea       14
0000072C  41F9 0800  440          lea       _Task4Stk.L,A0
00000730  06D4      
00000732  D0FC 0200  441          add.w     #512,A0
00000736  2F08       442          move.l    A0,-(A7)
00000738  42A7       443          clr.l     -(A7)
0000073A  4879 0000  444          pea       _Task4.L
0000073E  0840      
00000740  4E92       445          jsr       (A2)
00000742  DEFC 0010  446          add.w     #16,A7
                     447   ; OSTaskCreate(Task5, OS_NULL, &Task5Stk[STACKSIZE], 15); 
00000746  4878 000F  448          pea       15
0000074A  41F9 0800  449          lea       _Task5Stk.L,A0
0000074E  08D4      
00000750  D0FC 0200  450          add.w     #512,A0
00000754  2F08       451          move.l    A0,-(A7)
00000756  42A7       452          clr.l     -(A7)
00000758  4879 0000  453          pea       _Task5.L
0000075C  0878      
0000075E  4E92       454          jsr       (A2)
00000760  DEFC 0010  455          add.w     #16,A7
                     456   ; OSTaskCreate(Task6, OS_NULL, &Task6Stk[STACKSIZE], 16); // lowest priority task
00000764  4878 0010  457          pea       16
00000768  41F9 0800  458          lea       _Task6Stk.L,A0
0000076C  0AD4      
0000076E  D0FC 0200  459          add.w     #512,A0
00000772  2F08       460          move.l    A0,-(A7)
00000774  42A7       461          clr.l     -(A7)
00000776  4879 0000  462          pea       _Task6.L
0000077A  08B0      
0000077C  4E92       463          jsr       (A2)
0000077E  DEFC 0010  464          add.w     #16,A7
                     465   ; OSStart(); // call to start the OS scheduler, (never returns from this function)
00000782  4EB9 0000  466          jsr       _OSStart
00000786  10E2      
00000788  245F       467          move.l    (A7)+,A2
0000078A  4E75       468          rts
                     469   ; }
                     470   ; /*
                     471   ; ** IMPORTANT : Timer 1 interrupts must be started by the highest priority task
                     472   ; ** that runs first which is Task2
                     473   ; */
                     474   ; void Task1(void *pdata)
                     475   ; {
                     476   _Task1:
0000078C  4E56 0000  477          link      A6,#0
00000790  2F02       478          move.l    D2,-(A7)
                     479   ; unsigned char count = 0;
00000792  4202       480          clr.b     D2
                     481   ; // must start timer ticker here
                     482   ; Timer1_Init() ; // this function is in BIOS.C and written by us to start timer
00000794  4EB9 0000  483          jsr       _Timer1_Init
00000798  5DF8      
                     484   ; for (;;) {
                     485   Task1_1:
                     486   ; printf("RANDOM HEX DISPLAY\n");
0000079A  4879 0000  487          pea       @asn6_a~1_3.L
0000079E  687C      
000007A0  4EB9 0000  488          jsr       _printf
000007A4  5E0A      
000007A6  584F       489          addq.w    #4,A7
                     490   ; HEX_A = ((count << 4) + (count & 0x0f));
000007A8  1002       491          move.b    D2,D0
000007AA  E908       492          lsl.b     #4,D0
000007AC  1202       493          move.b    D2,D1
000007AE  C23C 000F  494          and.b     #15,D1
000007B2  D001       495          add.b     D1,D0
000007B4  13C0 0040  496          move.b    D0,4194320
000007B8  0010      
                     497   ; count++;
000007BA  5202       498          addq.b    #1,D2
                     499   ; OSTimeDly(200);
000007BC  4878 00C8  500          pea       200
000007C0  4EB9 0000  501          jsr       _OSTimeDly
000007C4  5012      
000007C6  584F       502          addq.w    #4,A7
000007C8  60D0       503          bra       Task1_1
                     504   ; }
                     505   ; }
                     506   ; /*
                     507   ; ** Task 2 below was created with the highest priority so it must start timer1
                     508   ; ** so that it produces interrupts for the 100hz context switches
                     509   ; */
                     510   ; void Task2(void *pdata)
                     511   ; {
                     512   _Task2:
000007CA  4E56 0000  513          link      A6,#0
000007CE  2F02       514          move.l    D2,-(A7)
                     515   ; unsigned char count = 0;
000007D0  4202       516          clr.b     D2
                     517   ; for (;;) {
                     518   Task2_1:
                     519   ; printf("RANDOM LED DISPLAY\n");
000007D2  4879 0000  520          pea       @asn6_a~1_4.L
000007D6  6890      
000007D8  4EB9 0000  521          jsr       _printf
000007DC  5E0A      
000007DE  584F       522          addq.w    #4,A7
                     523   ; PortA = ((count << 4) + (count & 0x0f)); //LED0-7
000007E0  1002       524          move.b    D2,D0
000007E2  E908       525          lsl.b     #4,D0
000007E4  1202       526          move.b    D2,D1
000007E6  C23C 000F  527          and.b     #15,D1
000007EA  D001       528          add.b     D1,D0
000007EC  13C0 0040  529          move.b    D0,4194304
000007F0  0000      
                     530   ; count++;
000007F2  5202       531          addq.b    #1,D2
                     532   ; OSTimeDly(100);
000007F4  4878 0064  533          pea       100
000007F8  4EB9 0000  534          jsr       _OSTimeDly
000007FC  5012      
000007FE  584F       535          addq.w    #4,A7
00000800  60D0       536          bra       Task2_1
                     537   ; }
                     538   ; }
                     539   ; void Task3(void *pdata)
                     540   ; {
                     541   _Task3:
00000802  4E56 0000  542          link      A6,#0
00000806  2F02       543          move.l    D2,-(A7)
                     544   ; unsigned char count = 0;
00000808  4202       545          clr.b     D2
                     546   ; // must start timer ticker here
                     547   ; Timer1_Init() ; // this function is in BIOS.C and written by us to start timer
0000080A  4EB9 0000  548          jsr       _Timer1_Init
0000080E  5DF8      
                     549   ; for (;;) {
                     550   Task3_1:
                     551   ; printf("RANDOM HEX DISPLAY\n");
00000810  4879 0000  552          pea       @asn6_a~1_3.L
00000814  687C      
00000816  4EB9 0000  553          jsr       _printf
0000081A  5E0A      
0000081C  584F       554          addq.w    #4,A7
                     555   ; HEX_B = ((count << 4) + (count & 0x0f));
0000081E  1002       556          move.b    D2,D0
00000820  E908       557          lsl.b     #4,D0
00000822  1202       558          move.b    D2,D1
00000824  C23C 000F  559          and.b     #15,D1
00000828  D001       560          add.b     D1,D0
0000082A  13C0 0040  561          move.b    D0,4194322
0000082E  0012      
                     562   ; count++;
00000830  5202       563          addq.b    #1,D2
                     564   ; OSTimeDly(50);
00000832  4878 0032  565          pea       50
00000836  4EB9 0000  566          jsr       _OSTimeDly
0000083A  5012      
0000083C  584F       567          addq.w    #4,A7
0000083E  60D0       568          bra       Task3_1
                     569   ; }
                     570   ; }
                     571   ; void Task4(void *pdata)
                     572   ; {
                     573   _Task4:
00000840  4E56 0000  574          link      A6,#0
00000844  2F02       575          move.l    D2,-(A7)
                     576   ; unsigned char count = 0;
00000846  4202       577          clr.b     D2
                     578   ; for (;;) {
                     579   Task4_1:
                     580   ; printf("RANDOM LED DISPLAY\n");
00000848  4879 0000  581          pea       @asn6_a~1_4.L
0000084C  6890      
0000084E  4EB9 0000  582          jsr       _printf
00000852  5E0A      
00000854  584F       583          addq.w    #4,A7
                     584   ; PortB = ((count << 4) + (count & 0x0f)); //LED8-9
00000856  1002       585          move.b    D2,D0
00000858  E908       586          lsl.b     #4,D0
0000085A  1202       587          move.b    D2,D1
0000085C  C23C 000F  588          and.b     #15,D1
00000860  D001       589          add.b     D1,D0
00000862  13C0 0040  590          move.b    D0,4194306
00000866  0002      
                     591   ; count++;
00000868  5202       592          addq.b    #1,D2
                     593   ; OSTimeDly(25);
0000086A  4878 0019  594          pea       25
0000086E  4EB9 0000  595          jsr       _OSTimeDly
00000872  5012      
00000874  584F       596          addq.w    #4,A7
00000876  60D0       597          bra       Task4_1
                     598   ; }
                     599   ; }
                     600   ; void Task5(void *pdata)
                     601   ; {
                     602   _Task5:
00000878  4E56 0000  603          link      A6,#0
0000087C  2F02       604          move.l    D2,-(A7)
                     605   ; unsigned char count = 0;
0000087E  4202       606          clr.b     D2
                     607   ; for (;;) {
                     608   Task5_1:
                     609   ; printf("RANDOM HEX DISPLAY\n");
00000880  4879 0000  610          pea       @asn6_a~1_3.L
00000884  687C      
00000886  4EB9 0000  611          jsr       _printf
0000088A  5E0A      
0000088C  584F       612          addq.w    #4,A7
                     613   ; HEX_C = ((count << 4) + (count & 0x0f)); //LED8-9
0000088E  1002       614          move.b    D2,D0
00000890  E908       615          lsl.b     #4,D0
00000892  1202       616          move.b    D2,D1
00000894  C23C 000F  617          and.b     #15,D1
00000898  D001       618          add.b     D1,D0
0000089A  13C0 0040  619          move.b    D0,4194324
0000089E  0014      
                     620   ; count++;
000008A0  5202       621          addq.b    #1,D2
                     622   ; OSTimeDly(10);
000008A2  4878 000A  623          pea       10
000008A6  4EB9 0000  624          jsr       _OSTimeDly
000008AA  5012      
000008AC  584F       625          addq.w    #4,A7
000008AE  60D0       626          bra       Task5_1
                     627   ; }
                     628   ; }
                     629   ; void Task6(void *pdata)
                     630   ; {
                     631   _Task6:
000008B0  4E56 FFFC  632          link      A6,#-4
                     633   ; unsigned char count = 0;
000008B4  422E FFFF  634          clr.b     -1(A6)
                     635   ; for (;;) {
                     636   Task6_1:
                     637   ; printf("RANDOM HEX DISPLAY\n");
000008B8  4879 0000  638          pea       @asn6_a~1_3.L
000008BC  687C      
000008BE  4EB9 0000  639          jsr       _printf
000008C2  5E0A      
000008C4  584F       640          addq.w    #4,A7
                     641   ; OSTimeDly(10);
000008C6  4878 000A  642          pea       10
000008CA  4EB9 0000  643          jsr       _OSTimeDly
000008CE  5012      
000008D0  584F       644          addq.w    #4,A7
000008D2  60E4       645          bra       Task6_1
                     646   ; }
                     647   ; }
                     648   ;********************************************************************************************************
                     649   ;                                               uC/OS-II
                     650   ;                                         The Real-Time Kernel
                     651   ;
                     652   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     653   ;                                          All Rights Reserved
                     654   ;
                     655   ;
                     656   ;                                     68000 Specific assembly code
                     657   ;                                               IDE68K
                     658   ;
                     659   ; File         : OS_CPU_A.ASM
                     660   ; By           : Jean J. Labrosse, Peter J. Fondse
                     661   ;********************************************************************************************************
                     662   
                     663   
                     664   ;********************************************************************************************************
                     665   ;                                            REVISION HISTORY
                     666   ;
                     667   ; $Log$
                     668   ;
                     669   ;********************************************************************************************************
                     670   
                     671   
                     672   ;********************************************************************************************************
                     673   ;                                          PUBLIC DECLARATIONS
                     674   ;********************************************************************************************************
                     675   
                     676   
                     677   ;********************************************************************************************************
                     678   ;                                         EXTERNAL DECLARATIONS
                     679   ;********************************************************************************************************
                     680   
                     681   
                     682   ;********************************************************************************************************
                     683   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     684   ;
                     685   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     686   ;               by your application before calling OSStart().
                     687   ;
                     688   ; Arguments   : none
                     689   ;
                     690   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     691   ;
                     692   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     693   ;                                            +  2         D0    (L)
                     694   ;                                            +  4         D1    (H)
                     695   ;                                            +  6         D1    (L)
                     696   ;                                            +  8         D2    (H)
                     697   ;                                            + 10         D2    (L)
                     698   ;                                            + 12         D3    (H)
                     699   ;                                            + 14         D3    (L)
                     700   ;                                            + 16         D4    (H)
                     701   ;                                            + 18         D4    (L)
                     702   ;                                            + 20         D5    (H)
                     703   ;                                            + 22         D5    (L)
                     704   ;                                            + 24         D6    (H)
                     705   ;                                            + 26         D6    (L)
                     706   ;                                            + 28         D7    (H)
                     707   ;                                            + 30         D7    (L)
                     708   ;                                            + 32         A0    (H)
                     709   ;                                            + 34         A0    (L)
                     710   ;                                            + 36         A1    (H)
                     711   ;                                            + 38         A1    (L)
                     712   ;                                            + 40         A2    (H)
                     713   ;                                            + 42         A2    (L)
                     714   ;                                            + 44         A3    (H)
                     715   ;                                            + 46         A3    (L)
                     716   ;                                            + 48         A4    (H)
                     717   ;                                            + 50         A4    (L)
                     718   ;                                            + 52         A5    (H)
                     719   ;                                            + 54         A5    (L)
                     720   ;                                            + 56         A6    (H)
                     721   ;                                            + 58         A6    (L)
                     722   ;                                            + 60         OS_INITIAL_SR
                     723   ;                                            + 62         task  (H)
                     724   ;                                            + 64         task  (L)
                     725   ;                                            + 66         task  (H)
                     726   ;                                            + 68         task  (L)
                     727   ;                                            + 70         pdata (H)
                     728   ;                                            + 72         pdata (L)        High Memory
                     729   ;
                     730   ;               2) OSStartHighRdy() MUST:
                     731   ;                      a) Call OSTaskSwHook() then,
                     732   ;                      b) Set OSRunning to TRUE,
                     733   ;                      c) Switch to the highest priority task.
                     734   ;********************************************************************************************************
                     735   
                     736   ; Pseudocode for OSStartHighRdy:
                     737   ;          Call OSTaskSwHook();
                     738   ;          Set OSRunning to 1;
                     739   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     740   ;          POP all the processor registers from the stack;
                     741   ;          Execute a Return from Interrupt instruction;
                     742   
                     743   
                     744   _OSStartHighRdy:
000008D4  4EB9 0000  745           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
000008D8  0B0A      
000008DA  5239 0800  746           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
000008DE  0F18      
000008E0  2079 0800  747           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
000008E4  1028      
000008E6  2E50       748           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
000008E8  4CDF 7FFF  749           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
000008EC  4E73       750           rte                                ; Run task
                     751   
                     752   ;********************************************************************************************************
                     753   ;                                       TASK LEVEL CONTEXT SWITCH
                     754   ;
                     755   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     756   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     757   ;
                     758   ; Arguments   : none
                     759   ;
                     760   ; Note(s)     : 1) Upon entry,
                     761   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     762   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     763   ;
                     764   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     765   ;                  task to suspend need to be saved):
                     766   ;
                     767   ;                                         SP +  0  ---->  SR                   Low Memory
                     768   ;                                            +  2         PC of task  (H)
                     769   ;                                            +  4         PC of task  (L)      High Memory
                     770   ;
                     771   ;               3) The stack frame of the task to resume looks as follows:
                     772   ;
                     773   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     774   ;                                            +  2         D0    (L)
                     775   ;                                            +  4         D1    (H)
                     776   ;                                            +  6         D1    (L)
                     777   ;                                            +  8         D2    (H)
                     778   ;                                            + 10         D2    (L)
                     779   ;                                            + 12         D3    (H)
                     780   ;                                            + 14         D3    (L)
                     781   ;                                            + 16         D4    (H)
                     782   ;                                            + 18         D4    (L)
                     783   ;                                            + 20         D5    (H)
                     784   ;                                            + 22         D5    (L)
                     785   ;                                            + 24         D6    (H)
                     786   ;                                            + 26         D6    (L)
                     787   ;                                            + 28         D7    (H)
                     788   ;                                            + 30         D7    (L)
                     789   ;                                            + 32         A0    (H)
                     790   ;                                            + 34         A0    (L)
                     791   ;                                            + 36         A1    (H)
                     792   ;                                            + 38         A1    (L)
                     793   ;                                            + 40         A2    (H)
                     794   ;                                            + 42         A2    (L)
                     795   ;                                            + 44         A3    (H)
                     796   ;                                            + 46         A3    (L)
                     797   ;                                            + 48         A4    (H)
                     798   ;                                            + 50         A4    (L)
                     799   ;                                            + 52         A5    (H)
                     800   ;                                            + 54         A5    (L)
                     801   ;                                            + 56         A6    (H)
                     802   ;                                            + 58         A6    (L)
                     803   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     804   ;                                            + 62         PC of task  (H)
                     805   ;                                            + 64         PC of task  (L)     High Memory
                     806   ;********************************************************************************************************
                     807   
                     808   ; Pseudocode for OSCtxSw:
                     809   ; OSCtxSw:
                     810   ; PUSH processor registers onto the current tasks stack;
                     811   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     812   ; Call OSTaskSwHook(); (1)
                     813   ; OSTCBCur = OSTCBHighRdy;
                     814   ; OSPrioCur = OSPrioHighRdy; (2)
                     815   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     816   ; POP all the processor registers from the stack;
                     817   ; Execute a Return from Interrupt instruction;
                     818   
                     819   _OSCtxSw:
000008EE  48E7 FFFE  820           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
000008F2  2079 0800  821           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
000008F6  1020      
000008F8  208F       822           move.l    A7,(A0)
000008FA  4EB9 0000  823           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000008FE  0B0A      
00000900  13F9 0800  824           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000904  0F0C 0800 
00000908  0F0A      
0000090A  2079 0800  825           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
0000090E  1028      
00000910  23C8 0800  826           move.l    A0,_OSTCBCur
00000914  1020      
00000916  2E50       827           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
00000918  4CDF 7FFF  828           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
0000091C  4E73       829           rte                                      ; Run task
                     830   
                     831   ;********************************************************************************************************
                     832   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     833   ;
                     834   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     835   ;               Provided for backward compatibility.
                     836   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     837   ;********************************************************************************************************
                     838   
                     839   ; Pseudocode for OSIntCtxSw
                     840   ; OSIntCtxSw
                     841   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     842   ;          Call OSTaskSwHook(); (1)
                     843   ;          OSTCBCur = OSTCBHighRdy;
                     844   ;          OSPrioCur = OSPrioHighRdy; (2)
                     845   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     846   ;          POP all the processor registers from the stack;
                     847   ;          Execute a Return from Interrupt instruction;
                     848   
                     849   _OSIntCtxSw:
0000091E  DFFC 0000  850           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
00000922  000A      
00000924  2279 0800  851           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
00000928  1020      
0000092A  228F       852           move.l    A7,(A1)
                     853   ;
0000092C  4EB9 0000  854           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
00000930  0B0A      
                     855   ;
00000932  2279 0800  856           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
00000936  1028      
00000938  23C9 0800  857           move.l    A1,_OSTCBCur
0000093C  1020      
0000093E  2E51       858           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                     859   ;
00000940  13F9 0800  860           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000944  0F0C 0800 
00000948  0F0A      
0000094A  4CDF 7FFF  861           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
0000094E  4E73       862           rte                                      ; Run task
                     863   
                     864   ;********************************************************************************************************
                     865   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     866   ;
                     867   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     868   ;
                     869   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     870   ;
                     871   ; Stack frame upon entry:
                     872   ;
                     873   ;                  SP +  0  ---->  D0    (H)
                     874   ;                     +  2         D0    (L)
                     875   ;                     +  4         D1    (H)
                     876   ;                     +  6         D1    (L)
                     877   ;                     +  8         D2    (H)
                     878   ;                     + 10         D2    (L)
                     879   ;                     + 12         D3    (H)
                     880   ;                     + 14         D3    (L)
                     881   ;                     + 16         D4    (H)
                     882   ;                     + 18         D4    (L)
                     883   ;                     + 20         D5    (H)
                     884   ;                     + 22         D5    (L)
                     885   ;                     + 24         D6    (H)
                     886   ;                     + 26         D6    (L)
                     887   ;                     + 28         D7    (H)
                     888   ;                     + 30         D7    (L)
                     889   ;                     + 32         A0    (H)
                     890   ;                     + 34         A0    (L)
                     891   ;                     + 36         A1    (H)
                     892   ;                     + 38         A1    (L)
                     893   ;                     + 40         A2    (H)
                     894   ;                     + 42         A2    (L)
                     895   ;                     + 44         A3    (H)
                     896   ;                     + 46         A3    (L)
                     897   ;                     + 48         A4    (H)
                     898   ;                     + 50         A4    (L)
                     899   ;                     + 52         A5    (H)
                     900   ;                     + 54         A5    (L)
                     901   ;                     + 56         A6    (H)
                     902   ;                     + 58         A6    (L)
                     903   ;                     + 60         Task or ISR's SR
                     904   ;                     + 62         PC of task  (H)
                     905   ;                     + 64         PC of task  (L)                   High Memory
                     906   ;********************************************************************************************************
                     907   
                     908   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                     909   
                     910   ; void OSIntExit (void)
                     911   ; {
                     912   ;           OS_ENTER_CRITICAL();
                     913   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                     914   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                     915   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                     916   ;                       if (OSPrioHighRdy != OSPrioCur) {
                     917   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                     918   ;                                       OSCtxSwCtr++;
                     919   ;                                       OSIntCtxSw();
                     920   ;                       }
                     921   ;           }
                     922   ;           OS_EXIT_CRITICAL();
                     923   ; }
                     924   
                     925   OSIntExit68K:
00000950  5339 0800  926           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
00000954  0F06      
00000956  6600 009C  927           bne       OSIntExit68K_1
0000095A  4A39 0800  928           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
0000095E  0F08      
00000960  6600 0092  929           bne       OSIntExit68K_1
                     930   
                     931   ;       re-enabling interrupts
00000964  302F 003C  932           move.w    (60,A7),D0                    ; must be LAST nested ISR
00000968  C07C 0700  933           and.w     #$0700,D0                     ; do we want to change S bit in SR
                     934   ;
0000096C  6600 0086  935           bne       OSIntExit68K_1
00000970  41F9 0000  936           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000974  68F6      
00000976  4280       937           clr.l     D0
00000978  1039 0800  938           move.b    _OSRdyGrp,D0
0000097C  0F0E      
0000097E  1230 0800  939           move.b    0(A0,D0.L),D1                 ;  y in D1
                     940   ;
00000982  41F9 0800  941           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
00000986  0F10      
00000988  4280       942           clr.l     D0
0000098A  1001       943           move.b    D1,D0
0000098C  41F0 0800  944           lea       0(A0,D0.L),A0
00000990  4280       945           clr.l     D0
00000992  1010       946           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000994  41F9 0000  947           lea       _OSUnMapTbl,A0
00000998  68F6      
0000099A  41F0 0800  948           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
0000099E  1001       949           move.b    D1,D0
000009A0  E708       950           lsl.b     #3,D0                         ;  (y << 3) in D0
000009A2  D010       951           add.b     (A0),D0
000009A4  13C0 0800  952           move.b    D0,_OSPrioHighRdy
000009A8  0F0C      
                     953   ;
000009AA  B039 0800  954           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
000009AE  0F0A      
000009B0  6742       955           beq.s     OSIntExit68K_1
                     956   ;
000009B2  41F9 0800  957           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
000009B6  1030      
000009B8  4281       958           clr.l     D1
000009BA  1200       959           move.b    D0,D1
000009BC  E589       960           lsl.l     #2,D1
000009BE  41F0 1800  961           lea       0(A0,D1.L),A0
000009C2  23D0 0800  962           move.l    (A0),_OSTCBHighRdy
000009C6  1028      
                     963   ;
000009C8  52B9 0800  964           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
000009CC  0CD6      
                     965   ;
000009CE  2079 0800  966           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
000009D2  1020      
000009D4  208F       967           move.l    A7,(A0)
000009D6  4EB9 0000  968           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
000009DA  0B0A      
000009DC  2079 0800  969           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
000009E0  1028      
000009E2  23C8 0800  970           move.l    A0,_OSTCBCur
000009E6  1020      
000009E8  13F9 0800  971           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
000009EC  0F0C 0800 
000009F0  0F0A      
000009F2  2E50       972           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     973   OSIntExit68K_1:
000009F4  4CDF 7FFF  974           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
000009F8  4E73       975           rte                                     ;  Return to task or nested ISR
                     976   
                     977   ;********************************************************************************************************
                     978   ;                                           SYSTEM TICK ISR
                     979   ;
                     980   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     981   ;
                     982   ; Arguments   : none
                     983   ;
                     984   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     985   ;               2) You MUST save ALL the CPU registers as shown below
                     986   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     987   ;********************************************************************************************************
                     988   
                     989   ; C Code for OSInterrupt exit taken from text book on OS example program
                     990   
                     991   ; void OSTickISR(void)
                     992   ; {
                     993   ;          Save processor registers;
                     994   ;          Call OSIntEnter() or increment OSIntNesting;
                     995   ;          Call OSTimeTick();
                     996   ;          Call OSIntExit();
                     997   ;          Restore processor registers;
                     998   ;          Execute a return from interrupt instruction;
                     999   ; }
                    1000   
                    1001   
                    1002   _OSTickISR:
000009FA  007C 0700 1003           or.w      #$0700,SR                     ; Disable ALL interrupts
000009FE  5239 0800 1004           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
00000A02  0F06      
00000A04  48E7 FFFE 1005           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                    1006           ; call your ISR here to clear the tick interrupt
00000A08  4EB9 0000 1007           jsr       _Timer_ISR
00000A0C  5DE2      
                    1008           ;
00000A0E  4EB9 0000 1009           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
00000A12  1168      
00000A14  6000 FF3A 1010           bra       OSIntExit68K                  ; Exit ISR
                    1011   ; C:\IDE68K\UCOSII\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1012   ; /*
                    1013   ; *********************************************************************************************************
                    1014   ; *                                               uC/OS-II
                    1015   ; *                                         The Real-Time Kernel
                    1016   ; *
                    1017   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                    1018   ; *                                          All Rights Reserved
                    1019   ; *
                    1020   ; *
                    1021   ; *                                         68000 Specific C code
                    1022   ; *                                                IDE68K
                    1023   ; *
                    1024   ; * File         : OS_CPU_C.C
                    1025   ; * By           : Jean J. Labrosse
                    1026   ; *********************************************************************************************************
                    1027   ; */
                    1028   ; #ifndef  OS_MASTER_FILE
                    1029   ; #include "ucos_ii.h"
                    1030   ; #endif
                    1031   ; #include "Bios.h"
                    1032   ; /*
                    1033   ; *********************************************************************************************************
                    1034   ; *                                           REVISION HISTORY
                    1035   ; *
                    1036   ; * $Log$
                    1037   ; *
                    1038   ; *********************************************************************************************************
                    1039   ; */
                    1040   ; #if OS_TMR_EN > 0
                    1041   ; INT8U OSTmrTickCtr;
                    1042   ; #endif
                    1043   ; /*$PAGE*/
                    1044   ; /*
                    1045   ; *********************************************************************************************************
                    1046   ; *                                        INITIALIZE A TASK'S STACK
                    1047   ; *
                    1048   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                    1049   ; *              stack frame of the task being created.  This function is highly processor specific.
                    1050   ; *
                    1051   ; * Arguments  : task          is a pointer to the task code
                    1052   ; *
                    1053   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                    1054   ; *                            when the task first executes.
                    1055   ; *
                    1056   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                    1057   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                    1058   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                    1059   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                    1060   ; *                            of the stack.
                    1061   ; *
                    1062   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                    1063   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                    1064   ; *
                    1065   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                    1066   ; *              been placed on the stack in the proper order.
                    1067   ; *
                    1068   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                    1069   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                    1070   ; *                 mode.
                    1071   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                    1072   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                    1073   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                    1074   ; *                 OSTaskIdle() and OSTaskStat().
                    1075   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                    1076   ; *********************************************************************************************************
                    1077   ; */
                    1078   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                    1079   ; {
                    1080   _OSTaskStkInit:
00000A18  4E56 0000 1081          link      A6,#0
00000A1C  48E7 3000 1082          movem.l   D2/D3,-(A7)
                    1083   ; INT32U  *pstk32;
                    1084   ; INT16U  *pstk16;
                    1085   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                    1086   ; /* Load stack pointer and align on 32-bit bound  */
                    1087   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
00000A20  202E 0010 1088          move.l    16(A6),D0
00000A24  C0BC 7FFF 1089          and.l     #2147483647,D0
00000A28  FFFF      
00000A2A  2400      1090          move.l    D0,D2
                    1091   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                    1092   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
00000A2C  5982      1093          subq.l    #4,D2
00000A2E  2042      1094          move.l    D2,A0
00000A30  20AE 000C 1095          move.l    12(A6),(A0)
                    1096   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000A34  5982      1097          subq.l    #4,D2
00000A36  2042      1098          move.l    D2,A0
00000A38  20AE 0008 1099          move.l    8(A6),(A0)
                    1100   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                    1101   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000A3C  5982      1102          subq.l    #4,D2
00000A3E  2042      1103          move.l    D2,A0
00000A40  20AE 0008 1104          move.l    8(A6),(A0)
                    1105   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
00000A44  2602      1106          move.l    D2,D3
                    1107   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
00000A46  5583      1108          subq.l    #2,D3
00000A48  2043      1109          move.l    D3,A0
00000A4A  30BC 2000 1110          move.w    #8192,(A0)
                    1111   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
00000A4E  2403      1112          move.l    D3,D2
                    1113   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                    1114   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
00000A50  5982      1115          subq.l    #4,D2
00000A52  2042      1116          move.l    D2,A0
00000A54  20BC 00A6 1117          move.l    #10879142,(A0)
00000A58  00A6      
                    1118   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
00000A5A  5982      1119          subq.l    #4,D2
00000A5C  2042      1120          move.l    D2,A0
00000A5E  20BC 00A5 1121          move.l    #10813605,(A0)
00000A62  00A5      
                    1122   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
00000A64  5982      1123          subq.l    #4,D2
00000A66  2042      1124          move.l    D2,A0
00000A68  20BC 00A4 1125          move.l    #10748068,(A0)
00000A6C  00A4      
                    1126   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
00000A6E  5982      1127          subq.l    #4,D2
00000A70  2042      1128          move.l    D2,A0
00000A72  20BC 00A3 1129          move.l    #10682531,(A0)
00000A76  00A3      
                    1130   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
00000A78  5982      1131          subq.l    #4,D2
00000A7A  2042      1132          move.l    D2,A0
00000A7C  20BC 00A2 1133          move.l    #10616994,(A0)
00000A80  00A2      
                    1134   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
00000A82  5982      1135          subq.l    #4,D2
00000A84  2042      1136          move.l    D2,A0
00000A86  20BC 00A1 1137          move.l    #10551457,(A0)
00000A8A  00A1      
                    1138   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
00000A8C  5982      1139          subq.l    #4,D2
00000A8E  2042      1140          move.l    D2,A0
00000A90  20BC 00A0 1141          move.l    #10485920,(A0)
00000A94  00A0      
                    1142   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
00000A96  5982      1143          subq.l    #4,D2
00000A98  2042      1144          move.l    D2,A0
00000A9A  20BC 00D7 1145          move.l    #14090455,(A0)
00000A9E  00D7      
                    1146   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000AA0  5982      1147          subq.l    #4,D2
00000AA2  2042      1148          move.l    D2,A0
00000AA4  20BC 00D6 1149          move.l    #14024918,(A0)
00000AA8  00D6      
                    1150   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
00000AAA  5982      1151          subq.l    #4,D2
00000AAC  2042      1152          move.l    D2,A0
00000AAE  20BC 00D5 1153          move.l    #13959381,(A0)
00000AB2  00D5      
                    1154   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
00000AB4  5982      1155          subq.l    #4,D2
00000AB6  2042      1156          move.l    D2,A0
00000AB8  20BC 00D4 1157          move.l    #13893844,(A0)
00000ABC  00D4      
                    1158   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000ABE  5982      1159          subq.l    #4,D2
00000AC0  2042      1160          move.l    D2,A0
00000AC2  20BC 00D3 1161          move.l    #13828307,(A0)
00000AC6  00D3      
                    1162   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
00000AC8  5982      1163          subq.l    #4,D2
00000ACA  2042      1164          move.l    D2,A0
00000ACC  20BC 00D2 1165          move.l    #13762770,(A0)
00000AD0  00D2      
                    1166   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
00000AD2  5982      1167          subq.l    #4,D2
00000AD4  2042      1168          move.l    D2,A0
00000AD6  20BC 00D1 1169          move.l    #13697233,(A0)
00000ADA  00D1      
                    1170   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
00000ADC  5982      1171          subq.l    #4,D2
00000ADE  2042      1172          move.l    D2,A0
00000AE0  20BC 00D0 1173          move.l    #13631696,(A0)
00000AE4  00D0      
                    1174   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
00000AE6  2002      1175          move.l    D2,D0
00000AE8  4CDF 000C 1176          movem.l   (A7)+,D2/D3
00000AEC  4E5E      1177          unlk      A6
00000AEE  4E75      1178          rts
                    1179   ; }
                    1180   ; /*$PAGE*/
                    1181   ; /*
                    1182   ; *********************************************************************************************************
                    1183   ; *                                             GET ISR VECTOR
                    1184   ; *
                    1185   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                    1186   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                    1187   ; *
                    1188   ; * Arguments  : vect     is the vector number
                    1189   ; *
                    1190   ; * Note(s)    : 1) Interrupts are disabled during this call
                    1191   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                    1192   ; *********************************************************************************************************
                    1193   ; */
                    1194   ; /*$PAGE*/
                    1195   ; #if OS_CPU_HOOKS_EN
                    1196   ; /*
                    1197   ; *********************************************************************************************************
                    1198   ; *                                       OS INITIALIZATION HOOK
                    1199   ; *                                            (BEGINNING)
                    1200   ; *
                    1201   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                    1202   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                    1203   ; *
                    1204   ; * Arguments  : none
                    1205   ; *
                    1206   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1207   ; *********************************************************************************************************
                    1208   ; */
                    1209   ; void OSInitHookBegin(void)
                    1210   ; {
                    1211   _OSInitHookBegin:
00000AF0  4E75      1212          rts
                    1213   ; }
                    1214   ; /*
                    1215   ; *********************************************************************************************************
                    1216   ; *                                       OS INITIALIZATION HOOK
                    1217   ; *                                               (END)
                    1218   ; *
                    1219   ; * Description: This function is called by OSInit() at the end of OSInit().
                    1220   ; *
                    1221   ; * Arguments  : none
                    1222   ; *
                    1223   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1224   ; *********************************************************************************************************
                    1225   ; */
                    1226   ; void OSInitHookEnd(void)
                    1227   ; {
                    1228   _OSInitHookEnd:
                    1229   ; #if OS_TMR_EN > 0
                    1230   ; OSTmrTickCtr = 0;
00000AF2  4239 0800 1231          clr.b     _OSTmrTickCtr.L
00000AF6  0CD4      
00000AF8  4E75      1232          rts
                    1233   ; #endif
                    1234   ; }
                    1235   ; /*
                    1236   ; *********************************************************************************************************
                    1237   ; *                                          TASK CREATION HOOK
                    1238   ; *
                    1239   ; * Description: This function is called when a task is created.
                    1240   ; *
                    1241   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                    1242   ; *
                    1243   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1244   ; *********************************************************************************************************
                    1245   ; */
                    1246   ; void OSTaskCreateHook(OS_TCB *ptcb)
                    1247   ; {
                    1248   _OSTaskCreateHook:
00000AFA  4E56 0000 1249          link      A6,#0
00000AFE  4E5E      1250          unlk      A6
00000B00  4E75      1251          rts
                    1252   ; }
                    1253   ; /*
                    1254   ; *********************************************************************************************************
                    1255   ; *                                           TASK DELETION HOOK
                    1256   ; *
                    1257   ; * Description: This function is called when a task is deleted.
                    1258   ; *
                    1259   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                    1260   ; *
                    1261   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1262   ; *********************************************************************************************************
                    1263   ; */
                    1264   ; void OSTaskDelHook(OS_TCB *ptcb)
                    1265   ; {
                    1266   _OSTaskDelHook:
00000B02  4E56 0000 1267          link      A6,#0
00000B06  4E5E      1268          unlk      A6
00000B08  4E75      1269          rts
                    1270   ; }
                    1271   ; /*
                    1272   ; *********************************************************************************************************
                    1273   ; *                                           TASK SWITCH HOOK
                    1274   ; *
                    1275   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                    1276   ; *              operations during a context switch.
                    1277   ; *
                    1278   ; * Arguments  : none
                    1279   ; *
                    1280   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1281   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                    1282   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                    1283   ; *                 task being switched out (i.e. the preempted task).
                    1284   ; *********************************************************************************************************
                    1285   ; */
                    1286   ; void OSTaskSwHook(void)
                    1287   ; {
                    1288   _OSTaskSwHook:
00000B0A  4E75      1289          rts
                    1290   ; }
                    1291   ; /*
                    1292   ; *********************************************************************************************************
                    1293   ; *                                           TASK IDLE HOOK
                    1294   ; *
                    1295   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                    1296   ; *              operations during the idle task.
                    1297   ; *
                    1298   ; * Arguments  : none
                    1299   ; *
                    1300   ; * Note(s)    : none
                    1301   ; *********************************************************************************************************
                    1302   ; */
                    1303   ; void OSTaskIdleHook(void)
                    1304   ; {
                    1305   _OSTaskIdleHook:
00000B0C  4E75      1306          rts
                    1307   ; }
                    1308   ; /*
                    1309   ; *********************************************************************************************************
                    1310   ; *                                           TASK RETURN HOOK
                    1311   ; *
                    1312   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1313   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1314   ; *
                    1315   ; * Arguments  : Pointer to currently running TCB
                    1316   ; *
                    1317   ; * Note(s)    : none
                    1318   ; *********************************************************************************************************
                    1319   ; */
                    1320   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1321   ; {
                    1322   _OSTaskReturnHook:
00000B0E  4E56 0000 1323          link      A6,#0
00000B12  4E5E      1324          unlk      A6
00000B14  4E75      1325          rts
                    1326   ; }
                    1327   ; /*
                    1328   ; *********************************************************************************************************
                    1329   ; *                                           STATISTIC TASK HOOK
                    1330   ; *
                    1331   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1332   ; *              application to add functionality to the statistics task.
                    1333   ; *
                    1334   ; * Arguments  : none
                    1335   ; *********************************************************************************************************
                    1336   ; */
                    1337   ; void OSTaskStatHook(void)
                    1338   ; {
                    1339   _OSTaskStatHook:
00000B16  4E75      1340          rts
                    1341   ; }
                    1342   ; /*
                    1343   ; *********************************************************************************************************
                    1344   ; *                                               TICK HOOK
                    1345   ; *
                    1346   ; * Description: This function is called every tick.
                    1347   ; *
                    1348   ; * Arguments  : none
                    1349   ; *
                    1350   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1351   ; *********************************************************************************************************
                    1352   ; */
                    1353   ; void OSTimeTickHook(void)
                    1354   ; {
                    1355   _OSTimeTickHook:
                    1356   ; #if OS_TMR_EN > 0
                    1357   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
00000B18  3039 0800 1358          move.w    _OSTmrUsed.L,D0
00000B1C  197C      
00000B1E  0C40 0000 1359          cmp.w     #0,D0
00000B22  631E      1360          bls.s     OSTimeTickHook_1
00000B24  5239 0800 1361          addq.b    #1,_OSTmrTickCtr.L
00000B28  0CD4      
00000B2A  1039 0800 1362          move.b    _OSTmrTickCtr.L,D0
00000B2E  0CD4      
00000B30  0C00 000A 1363          cmp.b     #10,D0
00000B34  650C      1364          blo.s     OSTimeTickHook_1
                    1365   ; OSTmrTickCtr = 0;
00000B36  4239 0800 1366          clr.b     _OSTmrTickCtr.L
00000B3A  0CD4      
                    1367   ; OSTmrSignal();
00000B3C  4EB9 0000 1368          jsr       _OSTmrSignal
00000B40  57E2      
                    1369   OSTimeTickHook_1:
00000B42  4E75      1370          rts
                    1371   ; }
                    1372   ; #endif
                    1373   ; }
                    1374   ; /*
                    1375   ; *********************************************************************************************************
                    1376   ; *                                           OSTCBInit() HOOK
                    1377   ; *
                    1378   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1379   ; *
                    1380   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1381   ; *
                    1382   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1383   ; *********************************************************************************************************
                    1384   ; */
                    1385   ; #if OS_VERSION > 203
                    1386   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1387   ; {
                    1388   _OSTCBInitHook:
00000B44  4E56 0000 1389          link      A6,#0
00000B48  4E5E      1390          unlk      A6
00000B4A  4E75      1391          rts
                    1392   ; }
                    1393   ; #endif
                    1394   ; #endif // OS_CPU_HOOKS_EN
                    1395   ; C:\IDE68K\UCOSII\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1396   ; /*
                    1397   ; *********************************************************************************************************
                    1398   ; *                                                uC/OS-II
                    1399   ; *                                          The Real-Time Kernel
                    1400   ; *                                             CORE FUNCTIONS
                    1401   ; *
                    1402   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1403   ; *                                           All Rights Reserved
                    1404   ; *
                    1405   ; * File    : OS_CORE.C
                    1406   ; * By      : Jean J. Labrosse
                    1407   ; * Version : V2.92.07
                    1408   ; *
                    1409   ; * LICENSING TERMS:
                    1410   ; * ---------------
                    1411   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1412   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1413   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1414   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1415   ; * licensing fee.
                    1416   ; *********************************************************************************************************
                    1417   ; */
                    1418   ; #define  MICRIUM_SOURCE
                    1419   ; #ifndef  OS_MASTER_FILE
                    1420   ; #define  OS_GLOBALS
                    1421   ; #include <ucos_ii.h>
                    1422   ; #endif
                    1423   ; /*
                    1424   ; *********************************************************************************************************
                    1425   ; *                                      PRIORITY RESOLUTION TABLE
                    1426   ; *
                    1427   ; * Note: Index into table is bit pattern to resolve highest priority
                    1428   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1429   ; *********************************************************************************************************
                    1430   ; */
                    1431   ; INT8U  const  OSUnMapTbl[256] = {
                    1432   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1433   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1434   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1435   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1436   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1437   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1438   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1439   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1440   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1441   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1442   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1443   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1444   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1445   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1446   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1447   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1448   ; };
                    1449   ; /*$PAGE*/
                    1450   ; /*
                    1451   ; *********************************************************************************************************
                    1452   ; *                                         FUNCTION PROTOTYPES
                    1453   ; *********************************************************************************************************
                    1454   ; */
                    1455   ; static  void  OS_InitEventList(void);
                    1456   ; static  void  OS_InitMisc(void);
                    1457   ; static  void  OS_InitRdyList(void);
                    1458   ; static  void  OS_InitTaskIdle(void);
                    1459   ; #if OS_TASK_STAT_EN > 0u
                    1460   ; static  void  OS_InitTaskStat(void);
                    1461   ; #endif
                    1462   ; static  void  OS_InitTCBList(void);
                    1463   ; static  void  OS_SchedNew(void);
                    1464   ; /*$PAGE*/
                    1465   ; /*
                    1466   ; *********************************************************************************************************
                    1467   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1468   ; *
                    1469   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1470   ; *
                    1471   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1472   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1473   ; *                        type is irrelevant.
                    1474   ; *
                    1475   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1476   ; *                        mutex, mailbox or queue.
                    1477   ; *
                    1478   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1479   ; *
                    1480   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1481   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1482   ; *                                                   control block type.
                    1483   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1484   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1485   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1486   ; *
                    1487   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1488   ; *********************************************************************************************************
                    1489   ; */
                    1490   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1491   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1492   ; INT8U     **pname,
                    1493   ; INT8U      *perr)
                    1494   ; {
                    1495   _OSEventNameGet:
00000B4C  4E56 FFFC 1496          link      A6,#-4
00000B50  2F02      1497          move.l    D2,-(A7)
00000B52  242E 0010 1498          move.l    16(A6),D2
                    1499   ; INT8U      len;
                    1500   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1501   ; OS_CPU_SR  cpu_sr = 0u;
                    1502   ; #endif
                    1503   ; #ifdef OS_SAFETY_CRITICAL
                    1504   ; if (perr == (INT8U *)0) {
                    1505   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1506   ; return (0u);
                    1507   ; }
                    1508   ; #endif
                    1509   ; #if OS_ARG_CHK_EN > 0u
                    1510   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1511   ; *perr = OS_ERR_PEVENT_NULL;
                    1512   ; return (0u);
                    1513   ; }
                    1514   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1515   ; *perr = OS_ERR_PNAME_NULL;
                    1516   ; return (0u);
                    1517   ; }
                    1518   ; #endif
                    1519   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000B56  1039 0800 1520          move.b    _OSIntNesting.L,D0
00000B5A  0F06      
00000B5C  0C00 0000 1521          cmp.b     #0,D0
00000B60  630C      1522          bls.s     OSEventNameGet_1
                    1523   ; *perr  = OS_ERR_NAME_GET_ISR;
00000B62  2042      1524          move.l    D2,A0
00000B64  10BC 0011 1525          move.b    #17,(A0)
                    1526   ; return (0u);
00000B68  4200      1527          clr.b     D0
00000B6A  6000 0066 1528          bra       OSEventNameGet_3
                    1529   OSEventNameGet_1:
                    1530   ; }
                    1531   ; switch (pevent->OSEventType) {
00000B6E  206E 0008 1532          move.l    8(A6),A0
00000B72  1010      1533          move.b    (A0),D0
00000B74  C0BC 0000 1534          and.l     #255,D0
00000B78  00FF      
00000B7A  5380      1535          subq.l    #1,D0
00000B7C  651C      1536          blo.s     OSEventNameGet_4
00000B7E  0C80 0000 1537          cmp.l     #4,D0
00000B82  0004      
00000B84  6414      1538          bhs.s     OSEventNameGet_4
00000B86  E380      1539          asl.l     #1,D0
00000B88  303B 0806 1540          move.w    OSEventNameGet_6(PC,D0.L),D0
00000B8C  4EFB 0002 1541          jmp       OSEventNameGet_6(PC,D0.W)
                    1542   OSEventNameGet_6:
00000B90  0008      1543          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000B92  0008      1544          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000B94  0008      1545          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000B96  0008      1546          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1547   OSEventNameGet_7:
                    1548   ; case OS_EVENT_TYPE_SEM:
                    1549   ; case OS_EVENT_TYPE_MUTEX:
                    1550   ; case OS_EVENT_TYPE_MBOX:
                    1551   ; case OS_EVENT_TYPE_Q:
                    1552   ; break;
00000B98  600A      1553          bra.s     OSEventNameGet_5
                    1554   OSEventNameGet_4:
                    1555   ; default:
                    1556   ; *perr = OS_ERR_EVENT_TYPE;
00000B9A  2042      1557          move.l    D2,A0
00000B9C  10BC 0001 1558          move.b    #1,(A0)
                    1559   ; return (0u);
00000BA0  4200      1560          clr.b     D0
00000BA2  602E      1561          bra.s     OSEventNameGet_3
                    1562   OSEventNameGet_5:
                    1563   ; }
                    1564   ; OS_ENTER_CRITICAL();
00000BA4  40E7      1565          dc.w      16615
00000BA6  007C      1566          dc.w      124
00000BA8  0700      1567          dc.w      1792
                    1568   ; *pname = pevent->OSEventName;
00000BAA  206E 0008 1569          move.l    8(A6),A0
00000BAE  226E 000C 1570          move.l    12(A6),A1
00000BB2  22A8 0012 1571          move.l    18(A0),(A1)
                    1572   ; len    = OS_StrLen(*pname);
00000BB6  206E 000C 1573          move.l    12(A6),A0
00000BBA  2F10      1574          move.l    (A0),-(A7)
00000BBC  4EB9 0000 1575          jsr       _OS_StrLen
00000BC0  18C0      
00000BC2  584F      1576          addq.w    #4,A7
00000BC4  1D40 FFFF 1577          move.b    D0,-1(A6)
                    1578   ; OS_EXIT_CRITICAL();
00000BC8  46DF      1579          dc.w      18143
                    1580   ; *perr  = OS_ERR_NONE;
00000BCA  2042      1581          move.l    D2,A0
00000BCC  4210      1582          clr.b     (A0)
                    1583   ; return (len);
00000BCE  102E FFFF 1584          move.b    -1(A6),D0
                    1585   OSEventNameGet_3:
00000BD2  241F      1586          move.l    (A7)+,D2
00000BD4  4E5E      1587          unlk      A6
00000BD6  4E75      1588          rts
                    1589   ; }
                    1590   ; #endif
                    1591   ; /*$PAGE*/
                    1592   ; /*
                    1593   ; *********************************************************************************************************
                    1594   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1595   ; *
                    1596   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1597   ; *
                    1598   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1599   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1600   ; *                        matter the actual type.
                    1601   ; *
                    1602   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1603   ; *                        mutex, mailbox or queue.
                    1604   ; *
                    1605   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1606   ; *
                    1607   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1608   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1609   ; *                                                   control block type.
                    1610   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1611   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1612   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1613   ; *
                    1614   ; * Returns    : None
                    1615   ; *********************************************************************************************************
                    1616   ; */
                    1617   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1618   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1619   ; INT8U     *pname,
                    1620   ; INT8U     *perr)
                    1621   ; {
                    1622   _OSEventNameSet:
00000BD8  4E56 0000 1623          link      A6,#0
00000BDC  2F02      1624          move.l    D2,-(A7)
00000BDE  242E 0010 1625          move.l    16(A6),D2
                    1626   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1627   ; OS_CPU_SR  cpu_sr = 0u;
                    1628   ; #endif
                    1629   ; #ifdef OS_SAFETY_CRITICAL
                    1630   ; if (perr == (INT8U *)0) {
                    1631   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1632   ; return;
                    1633   ; }
                    1634   ; #endif
                    1635   ; #if OS_ARG_CHK_EN > 0u
                    1636   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1637   ; *perr = OS_ERR_PEVENT_NULL;
                    1638   ; return;
                    1639   ; }
                    1640   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1641   ; *perr = OS_ERR_PNAME_NULL;
                    1642   ; return;
                    1643   ; }
                    1644   ; #endif
                    1645   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000BE2  1039 0800 1646          move.b    _OSIntNesting.L,D0
00000BE6  0F06      
00000BE8  0C00 0000 1647          cmp.b     #0,D0
00000BEC  630A      1648          bls.s     OSEventNameSet_1
                    1649   ; *perr = OS_ERR_NAME_SET_ISR;
00000BEE  2042      1650          move.l    D2,A0
00000BF0  10BC 0012 1651          move.b    #18,(A0)
                    1652   ; return;
00000BF4  6000 004C 1653          bra       OSEventNameSet_3
                    1654   OSEventNameSet_1:
                    1655   ; }
                    1656   ; switch (pevent->OSEventType) {
00000BF8  206E 0008 1657          move.l    8(A6),A0
00000BFC  1010      1658          move.b    (A0),D0
00000BFE  C0BC 0000 1659          and.l     #255,D0
00000C02  00FF      
00000C04  5380      1660          subq.l    #1,D0
00000C06  651C      1661          blo.s     OSEventNameSet_4
00000C08  0C80 0000 1662          cmp.l     #4,D0
00000C0C  0004      
00000C0E  6414      1663          bhs.s     OSEventNameSet_4
00000C10  E380      1664          asl.l     #1,D0
00000C12  303B 0806 1665          move.w    OSEventNameSet_6(PC,D0.L),D0
00000C16  4EFB 0002 1666          jmp       OSEventNameSet_6(PC,D0.W)
                    1667   OSEventNameSet_6:
00000C1A  0008      1668          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000C1C  0008      1669          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000C1E  0008      1670          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000C20  0008      1671          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1672   OSEventNameSet_7:
                    1673   ; case OS_EVENT_TYPE_SEM:
                    1674   ; case OS_EVENT_TYPE_MUTEX:
                    1675   ; case OS_EVENT_TYPE_MBOX:
                    1676   ; case OS_EVENT_TYPE_Q:
                    1677   ; break;
00000C22  6008      1678          bra.s     OSEventNameSet_5
                    1679   OSEventNameSet_4:
                    1680   ; default:
                    1681   ; *perr = OS_ERR_EVENT_TYPE;
00000C24  2042      1682          move.l    D2,A0
00000C26  10BC 0001 1683          move.b    #1,(A0)
                    1684   ; return;
00000C2A  6016      1685          bra.s     OSEventNameSet_3
                    1686   OSEventNameSet_5:
                    1687   ; }
                    1688   ; OS_ENTER_CRITICAL();
00000C2C  40E7      1689          dc.w      16615
00000C2E  007C      1690          dc.w      124
00000C30  0700      1691          dc.w      1792
                    1692   ; pevent->OSEventName = pname;
00000C32  206E 0008 1693          move.l    8(A6),A0
00000C36  216E 000C 1694          move.l    12(A6),18(A0)
00000C3A  0012      
                    1695   ; OS_EXIT_CRITICAL();
00000C3C  46DF      1696          dc.w      18143
                    1697   ; *perr = OS_ERR_NONE;
00000C3E  2042      1698          move.l    D2,A0
00000C40  4210      1699          clr.b     (A0)
                    1700   OSEventNameSet_3:
00000C42  241F      1701          move.l    (A7)+,D2
00000C44  4E5E      1702          unlk      A6
00000C46  4E75      1703          rts
                    1704   ; }
                    1705   ; #endif
                    1706   ; /*$PAGE*/
                    1707   ; /*
                    1708   ; *********************************************************************************************************
                    1709   ; *                                       PEND ON MULTIPLE EVENTS
                    1710   ; *
                    1711   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1712   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1713   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1714   ; *
                    1715   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1716   ; *
                    1717   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1718   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1719   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1720   ; *
                    1721   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1722   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1723   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1724   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1725   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1726   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1727   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1728   ; *
                    1729   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1730   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1731   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1732   ; *                            events or, until the resources becomes available (or the events occur).
                    1733   ; *
                    1734   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1735   ; *                            messages are:
                    1736   ; *
                    1737   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1738   ; *                                                or, the events you are waiting for occurred; check the
                    1739   ; *                                                'pevents_rdy' array for which events are available.
                    1740   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1741   ; *                                                'pevents_rdy' array for which events were aborted.
                    1742   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1743   ; *                                                'timeout'.
                    1744   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1745   ; *                                                NULL pointer.
                    1746   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1747   ; *                                                mailboxes, and/or queues.
                    1748   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1749   ; *                                                would lead to a suspension.
                    1750   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1751   ; *
                    1752   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1753   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1754   ; *
                    1755   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1756   ; *
                    1757   ; *                        semaphores, mailboxes, queues
                    1758   ; *
                    1759   ; *                 b. Return ALL available events and messages, if any
                    1760   ; *
                    1761   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1762   ; *                      Performed in OS_EventTaskWaitMulti()
                    1763   ; *
                    1764   ; *                 d. Wait on any of multiple events
                    1765   ; *
                    1766   ; *                 e. Remove current task priority as pending from each events's wait list
                    1767   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1768   ; *
                    1769   ; *                 f. Return any event posted or aborted, if any
                    1770   ; *                      else
                    1771   ; *                    Return timeout
                    1772   ; *
                    1773   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1774   ; *                 case of any error(s).
                    1775   ; *********************************************************************************************************
                    1776   ; */
                    1777   ; /*$PAGE*/
                    1778   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1779   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1780   ; OS_EVENT  **pevents_rdy,
                    1781   ; void      **pmsgs_rdy,
                    1782   ; INT32U      timeout,
                    1783   ; INT8U      *perr)
                    1784   ; {
                    1785   _OSEventPendMulti:
00000C48  4E56 FFFC 1786          link      A6,#-4
00000C4C  48E7 3F38 1787          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000C50  45F9 0800 1788          lea       _OSTCBCur.L,A2
00000C54  1020      
00000C56  282E 0018 1789          move.l    24(A6),D4
00000C5A  2A2E 000C 1790          move.l    12(A6),D5
00000C5E  266E 0010 1791          move.l    16(A6),A3
00000C62  286E 0008 1792          move.l    8(A6),A4
                    1793   ; OS_EVENT  **pevents;
                    1794   ; OS_EVENT   *pevent;
                    1795   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1796   ; OS_Q       *pq;
                    1797   ; #endif
                    1798   ; BOOLEAN     events_rdy;
                    1799   ; INT16U      events_rdy_nbr;
                    1800   ; INT8U       events_stat;
                    1801   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1802   ; OS_CPU_SR   cpu_sr = 0u;
                    1803   ; #endif
                    1804   ; #ifdef OS_SAFETY_CRITICAL
                    1805   ; if (perr == (INT8U *)0) {
                    1806   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1807   ; return (0u);
                    1808   ; }
                    1809   ; #endif
                    1810   ; #if (OS_ARG_CHK_EN > 0u)
                    1811   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1812   ; *perr =  OS_ERR_PEVENT_NULL;
                    1813   ; return (0u);
                    1814   ; }
                    1815   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1816   ; *perr =  OS_ERR_PEVENT_NULL;
                    1817   ; return (0u);
                    1818   ; }
                    1819   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1820   ; *perr =  OS_ERR_PEVENT_NULL;
                    1821   ; return (0u);
                    1822   ; }
                    1823   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1824   ; *perr =  OS_ERR_PEVENT_NULL;
                    1825   ; return (0u);
                    1826   ; }
                    1827   ; #endif
                    1828   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000C66  2045      1829          move.l    D5,A0
00000C68  4290      1830          clr.l     (A0)
                    1831   ; pevents     =  pevents_pend;
00000C6A  2E0C      1832          move.l    A4,D7
                    1833   ; pevent      = *pevents;
00000C6C  2047      1834          move.l    D7,A0
00000C6E  2410      1835          move.l    (A0),D2
                    1836   ; while  (pevent != (OS_EVENT *)0) {
                    1837   OSEventPendMulti_1:
00000C70  4A82      1838          tst.l     D2
00000C72  6700 0046 1839          beq       OSEventPendMulti_3
                    1840   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000C76  2042      1841          move.l    D2,A0
00000C78  1010      1842          move.b    (A0),D0
00000C7A  C0BC 0000 1843          and.l     #255,D0
00000C7E  00FF      
00000C80  5380      1844          subq.l    #1,D0
00000C82  6522      1845          blo.s     OSEventPendMulti_10
00000C84  0C80 0000 1846          cmp.l     #5,D0
00000C88  0005      
00000C8A  641A      1847          bhs.s     OSEventPendMulti_10
00000C8C  E380      1848          asl.l     #1,D0
00000C8E  303B 0806 1849          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000C92  4EFB 0002 1850          jmp       OSEventPendMulti_6(PC,D0.W)
                    1851   OSEventPendMulti_6:
00000C96  000C      1852          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
00000C98  000E      1853          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
00000C9A  000A      1854          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
00000C9C  0010      1855          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000C9E  0010      1856          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1857   OSEventPendMulti_7:
                    1858   ; #if (OS_SEM_EN  > 0u)
                    1859   ; case OS_EVENT_TYPE_SEM:
                    1860   ; break;
00000CA0  6010      1861          bra.s     OSEventPendMulti_5
                    1862   OSEventPendMulti_8:
                    1863   ; #endif
                    1864   ; #if (OS_MBOX_EN > 0u)
                    1865   ; case OS_EVENT_TYPE_MBOX:
                    1866   ; break;
00000CA2  600E      1867          bra.s     OSEventPendMulti_5
                    1868   OSEventPendMulti_9:
                    1869   ; #endif
                    1870   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1871   ; case OS_EVENT_TYPE_Q:
                    1872   ; break;
00000CA4  600C      1873          bra.s     OSEventPendMulti_5
                    1874   OSEventPendMulti_10:
                    1875   ; #endif
                    1876   ; case OS_EVENT_TYPE_MUTEX:
                    1877   ; case OS_EVENT_TYPE_FLAG:
                    1878   ; default:
                    1879   ; *perr = OS_ERR_EVENT_TYPE;
00000CA6  2044      1880          move.l    D4,A0
00000CA8  10BC 0001 1881          move.b    #1,(A0)
                    1882   ; return (0u);
00000CAC  4240      1883          clr.w     D0
00000CAE  6000 02C2 1884          bra       OSEventPendMulti_13
                    1885   OSEventPendMulti_5:
                    1886   ; }
                    1887   ; pevents++;
00000CB2  5887      1888          addq.l    #4,D7
                    1889   ; pevent = *pevents;
00000CB4  2047      1890          move.l    D7,A0
00000CB6  2410      1891          move.l    (A0),D2
00000CB8  60B6      1892          bra       OSEventPendMulti_1
                    1893   OSEventPendMulti_3:
                    1894   ; }
                    1895   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00000CBA  1039 0800 1896          move.b    _OSIntNesting.L,D0
00000CBE  0F06      
00000CC0  0C00 0000 1897          cmp.b     #0,D0
00000CC4  630C      1898          bls.s     OSEventPendMulti_14
                    1899   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00000CC6  2044      1900          move.l    D4,A0
00000CC8  10BC 0002 1901          move.b    #2,(A0)
                    1902   ; return (0u);
00000CCC  4240      1903          clr.w     D0
00000CCE  6000 02A2 1904          bra       OSEventPendMulti_13
                    1905   OSEventPendMulti_14:
                    1906   ; }
                    1907   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00000CD2  1039 0800 1908          move.b    _OSLockNesting.L,D0
00000CD6  0F08      
00000CD8  0C00 0000 1909          cmp.b     #0,D0
00000CDC  630C      1910          bls.s     OSEventPendMulti_16
                    1911   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
00000CDE  2044      1912          move.l    D4,A0
00000CE0  10BC 000D 1913          move.b    #13,(A0)
                    1914   ; return (0u);
00000CE4  4240      1915          clr.w     D0
00000CE6  6000 028A 1916          bra       OSEventPendMulti_13
                    1917   OSEventPendMulti_16:
                    1918   ; }
                    1919   ; /*$PAGE*/
                    1920   ; events_rdy     =  OS_FALSE;
00000CEA  422E FFFE 1921          clr.b     -2(A6)
                    1922   ; events_rdy_nbr =  0u;
00000CEE  4243      1923          clr.w     D3
                    1924   ; events_stat    =  OS_STAT_RDY;
00000CF0  422E FFFF 1925          clr.b     -1(A6)
                    1926   ; pevents        =  pevents_pend;
00000CF4  2E0C      1927          move.l    A4,D7
                    1928   ; pevent         = *pevents;
00000CF6  2047      1929          move.l    D7,A0
00000CF8  2410      1930          move.l    (A0),D2
                    1931   ; OS_ENTER_CRITICAL();
00000CFA  40E7      1932          dc.w      16615
00000CFC  007C      1933          dc.w      124
00000CFE  0700      1934          dc.w      1792
                    1935   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    1936   OSEventPendMulti_18:
00000D00  4A82      1937          tst.l     D2
00000D02  6700 010A 1938          beq       OSEventPendMulti_20
                    1939   ; switch (pevent->OSEventType) {
00000D06  2042      1940          move.l    D2,A0
00000D08  1010      1941          move.b    (A0),D0
00000D0A  C0BC 0000 1942          and.l     #255,D0
00000D0E  00FF      
00000D10  5380      1943          subq.l    #1,D0
00000D12  6500 00DE 1944          blo       OSEventPendMulti_27
00000D16  0C80 0000 1945          cmp.l     #5,D0
00000D1A  0005      
00000D1C  6400 00D4 1946          bhs       OSEventPendMulti_27
00000D20  E380      1947          asl.l     #1,D0
00000D22  303B 0806 1948          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000D26  4EFB 0002 1949          jmp       OSEventPendMulti_23(PC,D0.W)
                    1950   OSEventPendMulti_23:
00000D2A  003A      1951          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
00000D2C  0068      1952          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000D2E  000A      1953          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000D30  00C8      1954          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000D32  00C8      1955          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    1956   OSEventPendMulti_24:
                    1957   ; #if (OS_SEM_EN > 0u)
                    1958   ; case OS_EVENT_TYPE_SEM:
                    1959   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000D34  2042      1960          move.l    D2,A0
00000D36  3028 0006 1961          move.w    6(A0),D0
00000D3A  0C40 0000 1962          cmp.w     #0,D0
00000D3E  631A      1963          bls.s     OSEventPendMulti_30
                    1964   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000D40  2002      1965          move.l    D2,D0
00000D42  5C80      1966          addq.l    #6,D0
00000D44  2040      1967          move.l    D0,A0
00000D46  5350      1968          subq.w    #1,(A0)
                    1969   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00000D48  2045      1970          move.l    D5,A0
00000D4A  5885      1971          addq.l    #4,D5
00000D4C  2082      1972          move.l    D2,(A0)
                    1973   ; events_rdy   =  OS_TRUE;
00000D4E  1D7C 0001 1974          move.b    #1,-2(A6)
00000D52  FFFE      
                    1975   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000D54  429B      1976          clr.l     (A3)+
                    1977   ; events_rdy_nbr++;
00000D56  5243      1978          addq.w    #1,D3
00000D58  6006      1979          bra.s     OSEventPendMulti_31
                    1980   OSEventPendMulti_30:
                    1981   ; } else {
                    1982   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
00000D5A  002E 0001 1983          or.b      #1,-1(A6)
00000D5E  FFFF      
                    1984   OSEventPendMulti_31:
                    1985   ; }
                    1986   ; break;
00000D60  6000 00A2 1987          bra       OSEventPendMulti_22
                    1988   OSEventPendMulti_25:
                    1989   ; #endif
                    1990   ; #if (OS_MBOX_EN > 0u)
                    1991   ; case OS_EVENT_TYPE_MBOX:
                    1992   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000D64  2042      1993          move.l    D2,A0
00000D66  2028 0002 1994          move.l    2(A0),D0
00000D6A  671C      1995          beq.s     OSEventPendMulti_32
                    1996   ; /* ... return available message,           ... */
                    1997   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
00000D6C  2042      1998          move.l    D2,A0
00000D6E  26E8 0002 1999          move.l    2(A0),(A3)+
                    2000   ; pevent->OSEventPtr  = (void *)0;
00000D72  2042      2001          move.l    D2,A0
00000D74  42A8 0002 2002          clr.l     2(A0)
                    2003   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
00000D78  2045      2004          move.l    D5,A0
00000D7A  5885      2005          addq.l    #4,D5
00000D7C  2082      2006          move.l    D2,(A0)
                    2007   ; events_rdy         =  OS_TRUE;
00000D7E  1D7C 0001 2008          move.b    #1,-2(A6)
00000D82  FFFE      
                    2009   ; events_rdy_nbr++;
00000D84  5243      2010          addq.w    #1,D3
00000D86  6006      2011          bra.s     OSEventPendMulti_33
                    2012   OSEventPendMulti_32:
                    2013   ; } else {
                    2014   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
00000D88  002E 0002 2015          or.b      #2,-1(A6)
00000D8C  FFFF      
                    2016   OSEventPendMulti_33:
                    2017   ; }
                    2018   ; break;
00000D8E  6000 0074 2019          bra       OSEventPendMulti_22
                    2020   OSEventPendMulti_26:
                    2021   ; #endif
                    2022   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    2023   ; case OS_EVENT_TYPE_Q:
                    2024   ; pq = (OS_Q *)pevent->OSEventPtr;
00000D92  2042      2025          move.l    D2,A0
00000D94  2C28 0002 2026          move.l    2(A0),D6
                    2027   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
00000D98  2046      2028          move.l    D6,A0
00000D9A  3028 0016 2029          move.w    22(A0),D0
00000D9E  0C40 0000 2030          cmp.w     #0,D0
00000DA2  6300 0046 2031          bls       OSEventPendMulti_34
                    2032   ; /* ... return available message,           ... */
                    2033   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000DA6  2006      2034          move.l    D6,D0
00000DA8  0680 0000 2035          add.l     #16,D0
00000DAC  0010      
00000DAE  2040      2036          move.l    D0,A0
00000DB0  2250      2037          move.l    (A0),A1
00000DB2  5890      2038          addq.l    #4,(A0)
00000DB4  26D1      2039          move.l    (A1),(A3)+
                    2040   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000DB6  2046      2041          move.l    D6,A0
00000DB8  2246      2042          move.l    D6,A1
00000DBA  2028 0010 2043          move.l    16(A0),D0
00000DBE  B0A9 0008 2044          cmp.l     8(A1),D0
00000DC2  660A      2045          bne.s     OSEventPendMulti_36
                    2046   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
00000DC4  2046      2047          move.l    D6,A0
00000DC6  2246      2048          move.l    D6,A1
00000DC8  2368 0004 2049          move.l    4(A0),16(A1)
00000DCC  0010      
                    2050   OSEventPendMulti_36:
                    2051   ; }
                    2052   ; pq->OSQEntries--;                  /* Update number of queue entries              */
00000DCE  2006      2053          move.l    D6,D0
00000DD0  0680 0000 2054          add.l     #22,D0
00000DD4  0016      
00000DD6  2040      2055          move.l    D0,A0
00000DD8  5350      2056          subq.w    #1,(A0)
                    2057   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
00000DDA  2045      2058          move.l    D5,A0
00000DDC  5885      2059          addq.l    #4,D5
00000DDE  2082      2060          move.l    D2,(A0)
                    2061   ; events_rdy   = OS_TRUE;
00000DE0  1D7C 0001 2062          move.b    #1,-2(A6)
00000DE4  FFFE      
                    2063   ; events_rdy_nbr++;
00000DE6  5243      2064          addq.w    #1,D3
00000DE8  6006      2065          bra.s     OSEventPendMulti_35
                    2066   OSEventPendMulti_34:
                    2067   ; } else {
                    2068   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
00000DEA  002E 0004 2069          or.b      #4,-1(A6)
00000DEE  FFFF      
                    2070   OSEventPendMulti_35:
                    2071   ; }
                    2072   ; break;
00000DF0  6012      2073          bra.s     OSEventPendMulti_22
                    2074   OSEventPendMulti_27:
                    2075   ; #endif
                    2076   ; case OS_EVENT_TYPE_MUTEX:
                    2077   ; case OS_EVENT_TYPE_FLAG:
                    2078   ; default:
                    2079   ; OS_EXIT_CRITICAL();
00000DF2  46DF      2080          dc.w      18143
                    2081   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
00000DF4  2045      2082          move.l    D5,A0
00000DF6  4290      2083          clr.l     (A0)
                    2084   ; *perr        =  OS_ERR_EVENT_TYPE;
00000DF8  2044      2085          move.l    D4,A0
00000DFA  10BC 0001 2086          move.b    #1,(A0)
                    2087   ; return (events_rdy_nbr);
00000DFE  3003      2088          move.w    D3,D0
00000E00  6000 0170 2089          bra       OSEventPendMulti_13
                    2090   OSEventPendMulti_22:
                    2091   ; }
                    2092   ; pevents++;
00000E04  5887      2093          addq.l    #4,D7
                    2094   ; pevent = *pevents;
00000E06  2047      2095          move.l    D7,A0
00000E08  2410      2096          move.l    (A0),D2
00000E0A  6000 FEF4 2097          bra       OSEventPendMulti_18
                    2098   OSEventPendMulti_20:
                    2099   ; }
                    2100   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
00000E0E  102E FFFE 2101          move.b    -2(A6),D0
00000E12  0C00 0001 2102          cmp.b     #1,D0
00000E16  6610      2103          bne.s     OSEventPendMulti_38
                    2104   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
00000E18  2045      2105          move.l    D5,A0
00000E1A  4290      2106          clr.l     (A0)
                    2107   ; OS_EXIT_CRITICAL();
00000E1C  46DF      2108          dc.w      18143
                    2109   ; *perr        =  OS_ERR_NONE;
00000E1E  2044      2110          move.l    D4,A0
00000E20  4210      2111          clr.b     (A0)
                    2112   ; return (events_rdy_nbr);
00000E22  3003      2113          move.w    D3,D0
00000E24  6000 014C 2114          bra       OSEventPendMulti_13
                    2115   OSEventPendMulti_38:
                    2116   ; }
                    2117   ; /*$PAGE*/
                    2118   ; /* Otherwise, must wait until any event occurs */
                    2119   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00000E28  2052      2120          move.l    (A2),A0
00000E2A  102E FFFF 2121          move.b    -1(A6),D0
00000E2E  803C 0080 2122          or.b      #128,D0
00000E32  8128 0032 2123          or.b      D0,50(A0)
                    2124   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    2125   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00000E36  2052      2126          move.l    (A2),A0
00000E38  4228 0033 2127          clr.b     51(A0)
                    2128   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00000E3C  2052      2129          move.l    (A2),A0
00000E3E  216E 0014 2130          move.l    20(A6),46(A0)
00000E42  002E      
                    2131   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00000E44  2F0C      2132          move.l    A4,-(A7)
00000E46  4EB9 0000 2133          jsr       _OS_EventTaskWaitMulti
00000E4A  139E      
00000E4C  584F      2134          addq.w    #4,A7
                    2135   ; OS_EXIT_CRITICAL();
00000E4E  46DF      2136          dc.w      18143
                    2137   ; OS_Sched();                                         /* Find next highest priority task ready       */
00000E50  4EB9 0000 2138          jsr       _OS_Sched
00000E54  1816      
                    2139   ; OS_ENTER_CRITICAL();
00000E56  40E7      2140          dc.w      16615
00000E58  007C      2141          dc.w      124
00000E5A  0700      2142          dc.w      1792
                    2143   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00000E5C  2052      2144          move.l    (A2),A0
00000E5E  1028 0033 2145          move.b    51(A0),D0
00000E62  C0BC 0000 2146          and.l     #255,D0
00000E66  00FF      
00000E68  0C80 0000 2147          cmp.l     #1,D0
00000E6C  0001      
00000E6E  6700 0046 2148          beq       OSEventPendMulti_44
00000E72  6208      2149          bhi.s     OSEventPendMulti_46
00000E74  4A80      2150          tst.l     D0
00000E76  6710      2151          beq.s     OSEventPendMulti_42
00000E78  6000 003C 2152          bra       OSEventPendMulti_44
                    2153   OSEventPendMulti_46:
00000E7C  0C80 0000 2154          cmp.l     #2,D0
00000E80  0002      
00000E82  6704      2155          beq.s     OSEventPendMulti_42
00000E84  6000 0030 2156          bra       OSEventPendMulti_44
                    2157   OSEventPendMulti_42:
                    2158   ; case OS_STAT_PEND_OK:
                    2159   ; case OS_STAT_PEND_ABORT:
                    2160   ; pevent = OSTCBCur->OSTCBEventPtr;
00000E88  2052      2161          move.l    (A2),A0
00000E8A  2428 001C 2162          move.l    28(A0),D2
                    2163   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
00000E8E  4A82      2164          tst.l     D2
00000E90  670E      2165          beq.s     OSEventPendMulti_47
                    2166   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
00000E92  2045      2167          move.l    D5,A0
00000E94  5885      2168          addq.l    #4,D5
00000E96  2082      2169          move.l    D2,(A0)
                    2170   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
00000E98  2045      2171          move.l    D5,A0
00000E9A  4290      2172          clr.l     (A0)
                    2173   ; events_rdy_nbr =  1;
00000E9C  7601      2174          moveq     #1,D3
00000E9E  6014      2175          bra.s     OSEventPendMulti_48
                    2176   OSEventPendMulti_47:
                    2177   ; } else {                                   /* Else NO event available, handle as timeout  */
                    2178   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00000EA0  2052      2179          move.l    (A2),A0
00000EA2  117C 0001 2180          move.b    #1,51(A0)
00000EA6  0033      
                    2181   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000EA8  2F0C      2182          move.l    A4,-(A7)
00000EAA  2F12      2183          move.l    (A2),-(A7)
00000EAC  4EB9 0000 2184          jsr       _OS_EventTaskRemoveMulti
00000EB0  148E      
00000EB2  504F      2185          addq.w    #8,A7
                    2186   OSEventPendMulti_48:
                    2187   ; }
                    2188   ; break;
00000EB4  600C      2189          bra.s     OSEventPendMulti_41
                    2190   OSEventPendMulti_44:
                    2191   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    2192   ; default:                                        /* ... remove task from events' wait lists     */
                    2193   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000EB6  2F0C      2194          move.l    A4,-(A7)
00000EB8  2F12      2195          move.l    (A2),-(A7)
00000EBA  4EB9 0000 2196          jsr       _OS_EventTaskRemoveMulti
00000EBE  148E      
00000EC0  504F      2197          addq.w    #8,A7
                    2198   ; break;
                    2199   OSEventPendMulti_41:
                    2200   ; }
                    2201   ; switch (OSTCBCur->OSTCBStatPend) {
00000EC2  2052      2202          move.l    (A2),A0
00000EC4  1028 0033 2203          move.b    51(A0),D0
00000EC8  C0BC 0000 2204          and.l     #255,D0
00000ECC  00FF      
00000ECE  0C80 0000 2205          cmp.l     #1,D0
00000ED2  0001      
00000ED4  6700 0072 2206          beq       OSEventPendMulti_53
00000ED8  6208      2207          bhi.s     OSEventPendMulti_55
00000EDA  4A80      2208          tst.l     D0
00000EDC  6712      2209          beq.s     OSEventPendMulti_51
00000EDE  6000 0068 2210          bra       OSEventPendMulti_53
                    2211   OSEventPendMulti_55:
00000EE2  0C80 0000 2212          cmp.l     #2,D0
00000EE6  0002      
00000EE8  6700 0054 2213          beq       OSEventPendMulti_52
00000EEC  6000 005A 2214          bra       OSEventPendMulti_53
                    2215   OSEventPendMulti_51:
                    2216   ; case OS_STAT_PEND_OK:
                    2217   ; switch (pevent->OSEventType) {             /* Return event's message                      */
00000EF0  2042      2218          move.l    D2,A0
00000EF2  1010      2219          move.b    (A0),D0
00000EF4  C0BC 0000 2220          and.l     #255,D0
00000EF8  00FF      
00000EFA  5380      2221          subq.l    #1,D0
00000EFC  6528      2222          blo.s     OSEventPendMulti_62
00000EFE  0C80 0000 2223          cmp.l     #5,D0
00000F02  0005      
00000F04  6420      2224          bhs.s     OSEventPendMulti_62
00000F06  E380      2225          asl.l     #1,D0
00000F08  303B 0806 2226          move.w    OSEventPendMulti_58(PC,D0.L),D0
00000F0C  4EFB 0002 2227          jmp       OSEventPendMulti_58(PC,D0.W)
                    2228   OSEventPendMulti_58:
00000F10  000E      2229          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000F12  000E      2230          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000F14  000A      2231          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
00000F16  0016      2232          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00000F18  0016      2233          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    2234   OSEventPendMulti_59:
                    2235   ; #if (OS_SEM_EN > 0u)
                    2236   ; case OS_EVENT_TYPE_SEM:
                    2237   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00000F1A  429B      2238          clr.l     (A3)+
                    2239   ; break;
00000F1C  601A      2240          bra.s     OSEventPendMulti_57
                    2241   OSEventPendMulti_60:
                    2242   ; #endif
                    2243   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2244   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2245   ; case OS_EVENT_TYPE_MBOX:
                    2246   ; case OS_EVENT_TYPE_Q:
                    2247   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
00000F1E  2052      2248          move.l    (A2),A0
00000F20  26E8 0024 2249          move.l    36(A0),(A3)+
                    2250   ; break;
00000F24  6012      2251          bra.s     OSEventPendMulti_57
                    2252   OSEventPendMulti_62:
                    2253   ; #endif
                    2254   ; case OS_EVENT_TYPE_MUTEX:
                    2255   ; case OS_EVENT_TYPE_FLAG:
                    2256   ; default:
                    2257   ; OS_EXIT_CRITICAL();
00000F26  46DF      2258          dc.w      18143
                    2259   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00000F28  2045      2260          move.l    D5,A0
00000F2A  4290      2261          clr.l     (A0)
                    2262   ; *perr        =  OS_ERR_EVENT_TYPE;
00000F2C  2044      2263          move.l    D4,A0
00000F2E  10BC 0001 2264          move.b    #1,(A0)
                    2265   ; return (events_rdy_nbr);
00000F32  3003      2266          move.w    D3,D0
00000F34  6000 003C 2267          bra       OSEventPendMulti_13
                    2268   OSEventPendMulti_57:
                    2269   ; }
                    2270   ; *perr = OS_ERR_NONE;
00000F38  2044      2271          move.l    D4,A0
00000F3A  4210      2272          clr.b     (A0)
                    2273   ; break;
00000F3C  6012      2274          bra.s     OSEventPendMulti_50
                    2275   OSEventPendMulti_52:
                    2276   ; case OS_STAT_PEND_ABORT:
                    2277   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
00000F3E  429B      2278          clr.l     (A3)+
                    2279   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
00000F40  2044      2280          move.l    D4,A0
00000F42  10BC 000E 2281          move.b    #14,(A0)
                    2282   ; break;
00000F46  6008      2283          bra.s     OSEventPendMulti_50
                    2284   OSEventPendMulti_53:
                    2285   ; case OS_STAT_PEND_TO:
                    2286   ; default:
                    2287   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00000F48  429B      2288          clr.l     (A3)+
                    2289   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00000F4A  2044      2290          move.l    D4,A0
00000F4C  10BC 000A 2291          move.b    #10,(A0)
                    2292   ; break;
                    2293   OSEventPendMulti_50:
                    2294   ; }
                    2295   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00000F50  2052      2296          move.l    (A2),A0
00000F52  4228 0032 2297          clr.b     50(A0)
                    2298   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
00000F56  2052      2299          move.l    (A2),A0
00000F58  4228 0033 2300          clr.b     51(A0)
                    2301   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00000F5C  2052      2302          move.l    (A2),A0
00000F5E  42A8 001C 2303          clr.l     28(A0)
                    2304   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00000F62  2052      2305          move.l    (A2),A0
00000F64  42A8 0020 2306          clr.l     32(A0)
                    2307   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2308   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2309   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00000F68  2052      2310          move.l    (A2),A0
00000F6A  42A8 0024 2311          clr.l     36(A0)
                    2312   ; #endif
                    2313   ; OS_EXIT_CRITICAL();
00000F6E  46DF      2314          dc.w      18143
                    2315   ; return (events_rdy_nbr);
00000F70  3003      2316          move.w    D3,D0
                    2317   OSEventPendMulti_13:
00000F72  4CDF 1CFC 2318          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00000F76  4E5E      2319          unlk      A6
00000F78  4E75      2320          rts
                    2321   ; }
                    2322   ; #endif
                    2323   ; /*$PAGE*/
                    2324   ; /*
                    2325   ; *********************************************************************************************************
                    2326   ; *                                           INITIALIZATION
                    2327   ; *
                    2328   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2329   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2330   ; *
                    2331   ; * Arguments  : none
                    2332   ; *
                    2333   ; * Returns    : none
                    2334   ; *********************************************************************************************************
                    2335   ; */
                    2336   ; void  OSInit (void)
                    2337   ; {
                    2338   _OSInit:
                    2339   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00000F7A  4EB8 0AF0 2340          jsr       _OSInitHookBegin
                    2341   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00000F7E  4EB9 0000 2342          jsr       @ucos_ii_OS_InitMisc
00000F82  15D6      
                    2343   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
00000F84  4EB9 0000 2344          jsr       @ucos_ii_OS_InitRdyList
00000F88  161A      
                    2345   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000F8A  4EB9 0000 2346          jsr       @ucos_ii_OS_InitTCBList
00000F8E  1712      
                    2347   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00000F90  4EB9 0000 2348          jsr       @ucos_ii_OS_InitEventList
00000F94  152E      
                    2349   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2350   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
00000F96  4EB9 0000 2351          jsr       _OS_FlagInit
00000F9A  2524      
                    2352   ; #endif
                    2353   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2354   ; OS_MemInit();                                                /* Initialize the memory manager            */
00000F9C  4EB9 0000 2355          jsr       _OS_MemInit
00000FA0  2DE2      
                    2356   ; #endif
                    2357   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2358   ; OS_QInit();                                                  /* Initialize the message queue structures  */
00000FA2  4EB9 0000 2359          jsr       _OS_QInit
00000FA6  3F48      
                    2360   ; #endif
                    2361   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00000FA8  4EB9 0000 2362          jsr       @ucos_ii_OS_InitTaskIdle
00000FAC  165A      
                    2363   ; #if OS_TASK_STAT_EN > 0u
                    2364   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
00000FAE  4EB9 0000 2365          jsr       @ucos_ii_OS_InitTaskStat
00000FB2  16B6      
                    2366   ; #endif
                    2367   ; #if OS_TMR_EN > 0u
                    2368   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
00000FB4  4EB9 0000 2369          jsr       _OSTmr_Init
00000FB8  589A      
                    2370   ; #endif
                    2371   ; OSInitHookEnd();                                             /* Call port specific init. code            */
00000FBA  4EB8 0AF2 2372          jsr       _OSInitHookEnd
00000FBE  4E75      2373          rts
                    2374   ; #if OS_DEBUG_EN > 0u
                    2375   ; OSDebugInit();
                    2376   ; #endif
                    2377   ; }
                    2378   ; /*$PAGE*/
                    2379   ; /*
                    2380   ; *********************************************************************************************************
                    2381   ; *                                              ENTER ISR
                    2382   ; *
                    2383   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2384   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2385   ; *              only perform rescheduling at the last nested ISR.
                    2386   ; *
                    2387   ; * Arguments  : none
                    2388   ; *
                    2389   ; * Returns    : none
                    2390   ; *
                    2391   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2392   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2393   ; *                 OSIntNesting has been declared 'global'.
                    2394   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2395   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2396   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2397   ; *                 end of the ISR.
                    2398   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2399   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2400   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2401   ; *********************************************************************************************************
                    2402   ; */
                    2403   ; void  OSIntEnter (void)
                    2404   ; {
                    2405   _OSIntEnter:
                    2406   ; if (OSRunning == OS_TRUE) {
00000FC0  1039 0800 2407          move.b    _OSRunning.L,D0
00000FC4  0F18      
00000FC6  0C00 0001 2408          cmp.b     #1,D0
00000FCA  6612      2409          bne.s     OSIntEnter_3
                    2410   ; if (OSIntNesting < 255u) {
00000FCC  1039 0800 2411          move.b    _OSIntNesting.L,D0
00000FD0  0F06      
00000FD2  0C00 00FF 2412          cmp.b     #255,D0
00000FD6  6406      2413          bhs.s     OSIntEnter_3
                    2414   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
00000FD8  5239 0800 2415          addq.b    #1,_OSIntNesting.L
00000FDC  0F06      
                    2416   OSIntEnter_3:
00000FDE  4E75      2417          rts
                    2418   ; }
                    2419   ; }
                    2420   ; }
                    2421   ; /*$PAGE*/
                    2422   ; /*
                    2423   ; *********************************************************************************************************
                    2424   ; *                                              EXIT ISR
                    2425   ; *
                    2426   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2427   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2428   ; *              a new, high-priority task, is ready to run.
                    2429   ; *
                    2430   ; * Arguments  : none
                    2431   ; *
                    2432   ; * Returns    : none
                    2433   ; *
                    2434   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2435   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2436   ; *                 end of the ISR.
                    2437   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2438   ; *********************************************************************************************************
                    2439   ; */
                    2440   ; void  OSIntExit (void)
                    2441   ; {
                    2442   _OSIntExit:
                    2443   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2444   ; OS_CPU_SR  cpu_sr = 0u;
                    2445   ; #endif
                    2446   ; if (OSRunning == OS_TRUE) {
00000FE0  1039 0800 2447          move.b    _OSRunning.L,D0
00000FE4  0F18      
00000FE6  0C00 0001 2448          cmp.b     #1,D0
00000FEA  6600 0078 2449          bne       OSIntExit_1
                    2450   ; OS_ENTER_CRITICAL();
00000FEE  40E7      2451          dc.w      16615
00000FF0  007C      2452          dc.w      124
00000FF2  0700      2453          dc.w      1792
                    2454   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00000FF4  1039 0800 2455          move.b    _OSIntNesting.L,D0
00000FF8  0F06      
00000FFA  0C00 0000 2456          cmp.b     #0,D0
00000FFE  6306      2457          bls.s     OSIntExit_3
                    2458   ; OSIntNesting--;
00001000  5339 0800 2459          subq.b    #1,_OSIntNesting.L
00001004  0F06      
                    2460   OSIntExit_3:
                    2461   ; }
                    2462   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00001006  1039 0800 2463          move.b    _OSIntNesting.L,D0
0000100A  0F06      
0000100C  6600 0054 2464          bne       OSIntExit_9
                    2465   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00001010  1039 0800 2466          move.b    _OSLockNesting.L,D0
00001014  0F08      
00001016  664A      2467          bne.s     OSIntExit_9
                    2468   ; OS_SchedNew();
00001018  4EB9 0000 2469          jsr       @ucos_ii_OS_SchedNew
0000101C  187A      
                    2470   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0000101E  1039 0800 2471          move.b    _OSPrioHighRdy.L,D0
00001022  0F0C      
00001024  C0BC 0000 2472          and.l     #255,D0
00001028  00FF      
0000102A  E588      2473          lsl.l     #2,D0
0000102C  41F9 0800 2474          lea       _OSTCBPrioTbl.L,A0
00001030  1030      
00001032  23F0 0800 2475          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001036  0800 1028 
                    2476   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
0000103A  1039 0800 2477          move.b    _OSPrioHighRdy.L,D0
0000103E  0F0C      
00001040  B039 0800 2478          cmp.b     _OSPrioCur.L,D0
00001044  0F0A      
00001046  671A      2479          beq.s     OSIntExit_9
                    2480   ; #if OS_TASK_PROFILE_EN > 0u
                    2481   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00001048  2039 0800 2482          move.l    _OSTCBHighRdy.L,D0
0000104C  1028      
0000104E  0680 0000 2483          add.l     #58,D0
00001052  003A      
00001054  2040      2484          move.l    D0,A0
00001056  5290      2485          addq.l    #1,(A0)
                    2486   ; #endif
                    2487   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00001058  52B9 0800 2488          addq.l    #1,_OSCtxSwCtr.L
0000105C  0CD6      
                    2489   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
0000105E  4EB8 091E 2490          jsr       _OSIntCtxSw
                    2491   OSIntExit_9:
                    2492   ; }
                    2493   ; }
                    2494   ; }
                    2495   ; OS_EXIT_CRITICAL();
00001062  46DF      2496          dc.w      18143
                    2497   OSIntExit_1:
00001064  4E75      2498          rts
                    2499   ; }
                    2500   ; }
                    2501   ; /*$PAGE*/
                    2502   ; /*
                    2503   ; *********************************************************************************************************
                    2504   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2505   ; *
                    2506   ; * Description: This function is called by the application code to indicate that all initialization has
                    2507   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2508   ; *
                    2509   ; * Arguments  : none
                    2510   ; *
                    2511   ; * Returns    : none
                    2512   ; *
                    2513   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2514   ; *                 create kernel objects.
                    2515   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2516   ; *********************************************************************************************************
                    2517   ; */
                    2518   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2519   ; void  OSSafetyCriticalStart (void)
                    2520   ; {
                    2521   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2522   ; }
                    2523   ; #endif
                    2524   ; /*$PAGE*/
                    2525   ; /*
                    2526   ; *********************************************************************************************************
                    2527   ; *                                         PREVENT SCHEDULING
                    2528   ; *
                    2529   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2530   ; *              to prevent context switches until you are ready to permit context switching.
                    2531   ; *
                    2532   ; * Arguments  : none
                    2533   ; *
                    2534   ; * Returns    : none
                    2535   ; *
                    2536   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2537   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2538   ; *********************************************************************************************************
                    2539   ; */
                    2540   ; #if OS_SCHED_LOCK_EN > 0u
                    2541   ; void  OSSchedLock (void)
                    2542   ; {
                    2543   _OSSchedLock:
                    2544   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2545   ; OS_CPU_SR  cpu_sr = 0u;
                    2546   ; #endif
                    2547   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
00001066  1039 0800 2548          move.b    _OSRunning.L,D0
0000106A  0F18      
0000106C  0C00 0001 2549          cmp.b     #1,D0
00001070  6622      2550          bne.s     OSSchedLock_1
                    2551   ; OS_ENTER_CRITICAL();
00001072  40E7      2552          dc.w      16615
00001074  007C      2553          dc.w      124
00001076  0700      2554          dc.w      1792
                    2555   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00001078  1039 0800 2556          move.b    _OSIntNesting.L,D0
0000107C  0F06      
0000107E  6612      2557          bne.s     OSSchedLock_5
                    2558   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
00001080  1039 0800 2559          move.b    _OSLockNesting.L,D0
00001084  0F08      
00001086  0C00 00FF 2560          cmp.b     #255,D0
0000108A  6406      2561          bhs.s     OSSchedLock_5
                    2562   ; OSLockNesting++;                 /* Increment lock nesting level                       */
0000108C  5239 0800 2563          addq.b    #1,_OSLockNesting.L
00001090  0F08      
                    2564   OSSchedLock_5:
                    2565   ; }
                    2566   ; }
                    2567   ; OS_EXIT_CRITICAL();
00001092  46DF      2568          dc.w      18143
                    2569   OSSchedLock_1:
00001094  4E75      2570          rts
                    2571   ; }
                    2572   ; }
                    2573   ; #endif
                    2574   ; /*$PAGE*/
                    2575   ; /*
                    2576   ; *********************************************************************************************************
                    2577   ; *                                          ENABLE SCHEDULING
                    2578   ; *
                    2579   ; * Description: This function is used to re-allow rescheduling.
                    2580   ; *
                    2581   ; * Arguments  : none
                    2582   ; *
                    2583   ; * Returns    : none
                    2584   ; *
                    2585   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2586   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2587   ; *********************************************************************************************************
                    2588   ; */
                    2589   ; #if OS_SCHED_LOCK_EN > 0u
                    2590   ; void  OSSchedUnlock (void)
                    2591   ; {
                    2592   _OSSchedUnlock:
                    2593   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2594   ; OS_CPU_SR  cpu_sr = 0u;
                    2595   ; #endif
                    2596   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
00001096  1039 0800 2597          move.b    _OSRunning.L,D0
0000109A  0F18      
0000109C  0C00 0001 2598          cmp.b     #1,D0
000010A0  6600 003E 2599          bne       OSSchedUnlock_4
                    2600   ; OS_ENTER_CRITICAL();
000010A4  40E7      2601          dc.w      16615
000010A6  007C      2602          dc.w      124
000010A8  0700      2603          dc.w      1792
                    2604   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000010AA  1039 0800 2605          move.b    _OSIntNesting.L,D0
000010AE  0F06      
000010B0  662C      2606          bne.s     OSSchedUnlock_3
                    2607   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000010B2  1039 0800 2608          move.b    _OSLockNesting.L,D0
000010B6  0F08      
000010B8  0C00 0000 2609          cmp.b     #0,D0
000010BC  631C      2610          bls.s     OSSchedUnlock_5
                    2611   ; OSLockNesting--;                           /* Decrement lock nesting level             */
000010BE  5339 0800 2612          subq.b    #1,_OSLockNesting.L
000010C2  0F08      
                    2613   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000010C4  1039 0800 2614          move.b    _OSLockNesting.L,D0
000010C8  0F08      
000010CA  660A      2615          bne.s     OSSchedUnlock_7
                    2616   ; OS_EXIT_CRITICAL();
000010CC  46DF      2617          dc.w      18143
                    2618   ; OS_Sched();                            /* See if a HPT is ready                    */
000010CE  4EB9 0000 2619          jsr       _OS_Sched
000010D2  1816      
000010D4  6002      2620          bra.s     OSSchedUnlock_8
                    2621   OSSchedUnlock_7:
                    2622   ; } else {
                    2623   ; OS_EXIT_CRITICAL();
000010D6  46DF      2624          dc.w      18143
                    2625   OSSchedUnlock_8:
000010D8  6002      2626          bra.s     OSSchedUnlock_6
                    2627   OSSchedUnlock_5:
                    2628   ; }
                    2629   ; } else {
                    2630   ; OS_EXIT_CRITICAL();
000010DA  46DF      2631          dc.w      18143
                    2632   OSSchedUnlock_6:
000010DC  6002      2633          bra.s     OSSchedUnlock_4
                    2634   OSSchedUnlock_3:
                    2635   ; }
                    2636   ; } else {
                    2637   ; OS_EXIT_CRITICAL();
000010DE  46DF      2638          dc.w      18143
                    2639   OSSchedUnlock_4:
000010E0  4E75      2640          rts
                    2641   ; }
                    2642   ; }
                    2643   ; }
                    2644   ; #endif
                    2645   ; /*$PAGE*/
                    2646   ; /*
                    2647   ; *********************************************************************************************************
                    2648   ; *                                         START MULTITASKING
                    2649   ; *
                    2650   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2651   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2652   ; *              and you MUST have created at least one task.
                    2653   ; *
                    2654   ; * Arguments  : none
                    2655   ; *
                    2656   ; * Returns    : none
                    2657   ; *
                    2658   ; * Note       : OSStartHighRdy() MUST:
                    2659   ; *                 a) Call OSTaskSwHook() then,
                    2660   ; *                 b) Set OSRunning to OS_TRUE.
                    2661   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2662   ; *                 d_ Execute the task.
                    2663   ; *********************************************************************************************************
                    2664   ; */
                    2665   ; void  OSStart (void)
                    2666   ; {
                    2667   _OSStart:
                    2668   ; if (OSRunning == OS_FALSE) {
000010E2  1039 0800 2669          move.b    _OSRunning.L,D0
000010E6  0F18      
000010E8  663A      2670          bne.s     OSStart_1
                    2671   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
000010EA  4EB9 0000 2672          jsr       @ucos_ii_OS_SchedNew
000010EE  187A      
                    2673   ; OSPrioCur     = OSPrioHighRdy;
000010F0  13F9 0800 2674          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
000010F4  0F0C 0800 
000010F8  0F0A      
                    2675   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000010FA  1039 0800 2676          move.b    _OSPrioHighRdy.L,D0
000010FE  0F0C      
00001100  C0BC 0000 2677          and.l     #255,D0
00001104  00FF      
00001106  E588      2678          lsl.l     #2,D0
00001108  41F9 0800 2679          lea       _OSTCBPrioTbl.L,A0
0000110C  1030      
0000110E  23F0 0800 2680          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001112  0800 1028 
                    2681   ; OSTCBCur      = OSTCBHighRdy;
00001116  23F9 0800 2682          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
0000111A  1028 0800 
0000111E  1020      
                    2683   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
00001120  4EB8 08D4 2684          jsr       _OSStartHighRdy
                    2685   OSStart_1:
00001124  4E75      2686          rts
                    2687   ; }
                    2688   ; }
                    2689   ; /*$PAGE*/
                    2690   ; /*
                    2691   ; *********************************************************************************************************
                    2692   ; *                                      STATISTICS INITIALIZATION
                    2693   ; *
                    2694   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2695   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2696   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2697   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2698   ; *              determined by:
                    2699   ; *
                    2700   ; *                                             OSIdleCtr
                    2701   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2702   ; *                                            OSIdleCtrMax
                    2703   ; *
                    2704   ; * Arguments  : none
                    2705   ; *
                    2706   ; * Returns    : none
                    2707   ; *********************************************************************************************************
                    2708   ; */
                    2709   ; #if OS_TASK_STAT_EN > 0u
                    2710   ; void  OSStatInit (void)
                    2711   ; {
                    2712   _OSStatInit:
                    2713   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2714   ; OS_CPU_SR  cpu_sr = 0u;
                    2715   ; #endif
                    2716   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
00001126  4878 0002 2717          pea       2
0000112A  4EB9 0000 2718          jsr       _OSTimeDly
0000112E  5012      
00001130  584F      2719          addq.w    #4,A7
                    2720   ; OS_ENTER_CRITICAL();
00001132  40E7      2721          dc.w      16615
00001134  007C      2722          dc.w      124
00001136  0700      2723          dc.w      1792
                    2724   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00001138  42B9 0800 2725          clr.l     _OSIdleCtr.L
0000113C  0F1C      
                    2726   ; OS_EXIT_CRITICAL();
0000113E  46DF      2727          dc.w      18143
                    2728   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001140  4878 000A 2729          pea       10
00001144  4EB9 0000 2730          jsr       _OSTimeDly
00001148  5012      
0000114A  584F      2731          addq.w    #4,A7
                    2732   ; OS_ENTER_CRITICAL();
0000114C  40E7      2733          dc.w      16615
0000114E  007C      2734          dc.w      124
00001150  0700      2735          dc.w      1792
                    2736   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00001152  23F9 0800 2737          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
00001156  0F1C 0800 
0000115A  0DFC      
                    2738   ; OSStatRdy    = OS_TRUE;
0000115C  13FC 0001 2739          move.b    #1,_OSStatRdy.L
00001160  0800 0E04 
                    2740   ; OS_EXIT_CRITICAL();
00001164  46DF      2741          dc.w      18143
00001166  4E75      2742          rts
                    2743   ; }
                    2744   ; #endif
                    2745   ; /*$PAGE*/
                    2746   ; /*
                    2747   ; *********************************************************************************************************
                    2748   ; *                                         PROCESS SYSTEM TICK
                    2749   ; *
                    2750   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2751   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2752   ; *              called by a high priority task.
                    2753   ; *
                    2754   ; * Arguments  : none
                    2755   ; *
                    2756   ; * Returns    : none
                    2757   ; *********************************************************************************************************
                    2758   ; */
                    2759   ; void  OSTimeTick (void)
                    2760   ; {
                    2761   _OSTimeTick:
00001168  2F02      2762          move.l    D2,-(A7)
                    2763   ; OS_TCB    *ptcb;
                    2764   ; #if OS_TICK_STEP_EN > 0u
                    2765   ; BOOLEAN    step;
                    2766   ; #endif
                    2767   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2768   ; OS_CPU_SR  cpu_sr = 0u;
                    2769   ; #endif
                    2770   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2771   ; OSTimeTickHook();                                      /* Call user definable hook                     */
0000116A  4EB8 0B18 2772          jsr       _OSTimeTickHook
                    2773   ; #endif
                    2774   ; #if OS_TIME_GET_SET_EN > 0u
                    2775   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
0000116E  40E7      2776          dc.w      16615
00001170  007C      2777          dc.w      124
00001172  0700      2778          dc.w      1792
                    2779   ; OSTime++;
00001174  52B9 0800 2780          addq.l    #1,_OSTime.L
00001178  1976      
                    2781   ; OS_EXIT_CRITICAL();
0000117A  46DF      2782          dc.w      18143
                    2783   ; #endif
                    2784   ; if (OSRunning == OS_TRUE) {
0000117C  1039 0800 2785          move.b    _OSRunning.L,D0
00001180  0F18      
00001182  0C00 0001 2786          cmp.b     #1,D0
00001186  6600 00A2 2787          bne       OSTimeTick_5
                    2788   ; #if OS_TICK_STEP_EN > 0u
                    2789   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2790   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2791   ; step = OS_TRUE;
                    2792   ; break;
                    2793   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2794   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2795   ; break;
                    2796   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2797   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2798   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2799   ; break;
                    2800   ; default:                                       /* Invalid case, correct situation              */
                    2801   ; step            = OS_TRUE;
                    2802   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2803   ; break;
                    2804   ; }
                    2805   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2806   ; return;
                    2807   ; }
                    2808   ; #endif
                    2809   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
0000118A  2439 0800 2810          move.l    _OSTCBList.L,D2
0000118E  102C      
                    2811   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2812   OSTimeTick_3:
00001190  2042      2813          move.l    D2,A0
00001192  1028 0034 2814          move.b    52(A0),D0
00001196  0C00 003F 2815          cmp.b     #63,D0
0000119A  6700 008E 2816          beq       OSTimeTick_5
                    2817   ; OS_ENTER_CRITICAL();
0000119E  40E7      2818          dc.w      16615
000011A0  007C      2819          dc.w      124
000011A2  0700      2820          dc.w      1792
                    2821   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
000011A4  2042      2822          move.l    D2,A0
000011A6  2028 002E 2823          move.l    46(A0),D0
000011AA  6700 0072 2824          beq       OSTimeTick_12
                    2825   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
000011AE  2002      2826          move.l    D2,D0
000011B0  0680 0000 2827          add.l     #46,D0
000011B4  002E      
000011B6  2040      2828          move.l    D0,A0
000011B8  5390      2829          subq.l    #1,(A0)
                    2830   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
000011BA  2042      2831          move.l    D2,A0
000011BC  2028 002E 2832          move.l    46(A0),D0
000011C0  6600 005C 2833          bne       OSTimeTick_12
                    2834   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000011C4  2042      2835          move.l    D2,A0
000011C6  1028 0032 2836          move.b    50(A0),D0
000011CA  C03C 0037 2837          and.b     #55,D0
000011CE  6714      2838          beq.s     OSTimeTick_10
                    2839   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000011D0  2042      2840          move.l    D2,A0
000011D2  7037      2841          moveq     #55,D0
000011D4  4600      2842          not.b     D0
000011D6  C128 0032 2843          and.b     D0,50(A0)
                    2844   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
000011DA  2042      2845          move.l    D2,A0
000011DC  117C 0001 2846          move.b    #1,51(A0)
000011E0  0033      
000011E2  6006      2847          bra.s     OSTimeTick_11
                    2848   OSTimeTick_10:
                    2849   ; } else {
                    2850   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000011E4  2042      2851          move.l    D2,A0
000011E6  4228 0033 2852          clr.b     51(A0)
                    2853   OSTimeTick_11:
                    2854   ; }
                    2855   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
000011EA  2042      2856          move.l    D2,A0
000011EC  1028 0032 2857          move.b    50(A0),D0
000011F0  C03C 0008 2858          and.b     #8,D0
000011F4  6628      2859          bne.s     OSTimeTick_12
                    2860   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
000011F6  2042      2861          move.l    D2,A0
000011F8  1028 0038 2862          move.b    56(A0),D0
000011FC  8139 0800 2863          or.b      D0,_OSRdyGrp.L
00001200  0F0E      
                    2864   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00001202  2042      2865          move.l    D2,A0
00001204  1028 0036 2866          move.b    54(A0),D0
00001208  C0BC 0000 2867          and.l     #255,D0
0000120C  00FF      
0000120E  41F9 0800 2868          lea       _OSRdyTbl.L,A0
00001212  0F10      
00001214  2242      2869          move.l    D2,A1
00001216  1229 0037 2870          move.b    55(A1),D1
0000121A  8330 0800 2871          or.b      D1,0(A0,D0.L)
                    2872   OSTimeTick_12:
                    2873   ; }
                    2874   ; }
                    2875   ; }
                    2876   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
0000121E  2042      2877          move.l    D2,A0
00001220  2428 0014 2878          move.l    20(A0),D2
                    2879   ; OS_EXIT_CRITICAL();
00001224  46DF      2880          dc.w      18143
00001226  6000 FF68 2881          bra       OSTimeTick_3
                    2882   OSTimeTick_5:
0000122A  241F      2883          move.l    (A7)+,D2
0000122C  4E75      2884          rts
                    2885   ; }
                    2886   ; }
                    2887   ; }
                    2888   ; /*$PAGE*/
                    2889   ; /*
                    2890   ; *********************************************************************************************************
                    2891   ; *                                             GET VERSION
                    2892   ; *
                    2893   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2894   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2895   ; *              2.01.00 would be returned as 20100.
                    2896   ; *
                    2897   ; * Arguments  : none
                    2898   ; *
                    2899   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2900   ; *********************************************************************************************************
                    2901   ; */
                    2902   ; INT16U  OSVersion (void)
                    2903   ; {
                    2904   _OSVersion:
                    2905   ; return (OS_VERSION);
0000122E  303C 7217 2906          move.w    #29207,D0
00001232  4E75      2907          rts
                    2908   ; }
                    2909   ; /*$PAGE*/
                    2910   ; /*
                    2911   ; *********************************************************************************************************
                    2912   ; *                                           DUMMY FUNCTION
                    2913   ; *
                    2914   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2915   ; *
                    2916   ; * Arguments  : none
                    2917   ; *
                    2918   ; * Returns    : none
                    2919   ; *********************************************************************************************************
                    2920   ; */
                    2921   ; #if OS_TASK_DEL_EN > 0u
                    2922   ; void  OS_Dummy (void)
                    2923   ; {
                    2924   _OS_Dummy:
00001234  4E75      2925          rts
                    2926   ; }
                    2927   ; #endif
                    2928   ; /*$PAGE*/
                    2929   ; /*
                    2930   ; *********************************************************************************************************
                    2931   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    2932   ; *
                    2933   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    2934   ; *              waiting for an event to occur.
                    2935   ; *
                    2936   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    2937   ; *
                    2938   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    2939   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    2940   ; *                          service functions.
                    2941   ; *
                    2942   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    2943   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    2944   ; *
                    2945   ; *              pend_stat   is used to indicate the readied task's pending status:
                    2946   ; *
                    2947   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    2948   ; *                                               an abort.
                    2949   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    2950   ; *
                    2951   ; * Returns    : none
                    2952   ; *
                    2953   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2954   ; *********************************************************************************************************
                    2955   ; */
                    2956   ; #if (OS_EVENT_EN)
                    2957   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    2958   ; void      *pmsg,
                    2959   ; INT8U      msk,
                    2960   ; INT8U      pend_stat)
                    2961   ; {
                    2962   _OS_EventTaskRdy:
00001236  4E56 FFFC 2963          link      A6,#-4
0000123A  48E7 3C00 2964          movem.l   D2/D3/D4/D5,-(A7)
0000123E  262E 0008 2965          move.l    8(A6),D3
                    2966   ; OS_TCB   *ptcb;
                    2967   ; INT8U     y;
                    2968   ; INT8U     x;
                    2969   ; INT8U     prio;
                    2970   ; #if OS_LOWEST_PRIO > 63u
                    2971   ; OS_PRIO  *ptbl;
                    2972   ; #endif
                    2973   ; #if OS_LOWEST_PRIO <= 63u
                    2974   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00001242  2043      2975          move.l    D3,A0
00001244  1028 0008 2976          move.b    8(A0),D0
00001248  C0BC 0000 2977          and.l     #255,D0
0000124C  00FF      
0000124E  41F9 0000 2978          lea       _OSUnMapTbl.L,A0
00001252  68F6      
00001254  1830 0800 2979          move.b    0(A0,D0.L),D4
                    2980   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00001258  2043      2981          move.l    D3,A0
0000125A  C8BC 0000 2982          and.l     #255,D4
0000125E  00FF      
00001260  D1C4      2983          add.l     D4,A0
00001262  1028 000A 2984          move.b    10(A0),D0
00001266  C0BC 0000 2985          and.l     #255,D0
0000126A  00FF      
0000126C  41F9 0000 2986          lea       _OSUnMapTbl.L,A0
00001270  68F6      
00001272  1D70 0800 2987          move.b    0(A0,D0.L),-1(A6)
00001276  FFFF      
                    2988   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001278  1004      2989          move.b    D4,D0
0000127A  E708      2990          lsl.b     #3,D0
0000127C  D02E FFFF 2991          add.b     -1(A6),D0
00001280  1A00      2992          move.b    D0,D5
                    2993   ; #else
                    2994   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    2995   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    2996   ; } else {
                    2997   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    2998   ; }
                    2999   ; ptbl = &pevent->OSEventTbl[y];
                    3000   ; if ((*ptbl & 0xFFu) != 0u) {
                    3001   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    3002   ; } else {
                    3003   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    3004   ; }
                    3005   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    3006   ; #endif
                    3007   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00001282  CABC 0000 3008          and.l     #255,D5
00001286  00FF      
00001288  2005      3009          move.l    D5,D0
0000128A  E588      3010          lsl.l     #2,D0
0000128C  41F9 0800 3011          lea       _OSTCBPrioTbl.L,A0
00001290  1030      
00001292  2430 0800 3012          move.l    0(A0,D0.L),D2
                    3013   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00001296  2042      3014          move.l    D2,A0
00001298  42A8 002E 3015          clr.l     46(A0)
                    3016   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    3017   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
0000129C  2042      3018          move.l    D2,A0
0000129E  216E 000C 3019          move.l    12(A6),36(A0)
000012A2  0024      
                    3020   ; #else
                    3021   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    3022   ; #endif
                    3023   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000012A4  2042      3024          move.l    D2,A0
000012A6  102E 0013 3025          move.b    19(A6),D0
000012AA  4600      3026          not.b     D0
000012AC  C128 0032 3027          and.b     D0,50(A0)
                    3028   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000012B0  2042      3029          move.l    D2,A0
000012B2  116E 0017 3030          move.b    23(A6),51(A0)
000012B6  0033      
                    3031   ; /* See if task is ready (could be susp'd)      */
                    3032   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000012B8  2042      3033          move.l    D2,A0
000012BA  1028 0032 3034          move.b    50(A0),D0
000012BE  C03C 0008 3035          and.b     #8,D0
000012C2  6622      3036          bne.s     OS_EventTaskRdy_1
                    3037   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000012C4  2042      3038          move.l    D2,A0
000012C6  1028 0038 3039          move.b    56(A0),D0
000012CA  8139 0800 3040          or.b      D0,_OSRdyGrp.L
000012CE  0F0E      
                    3041   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000012D0  C8BC 0000 3042          and.l     #255,D4
000012D4  00FF      
000012D6  41F9 0800 3043          lea       _OSRdyTbl.L,A0
000012DA  0F10      
000012DC  2242      3044          move.l    D2,A1
000012DE  1029 0037 3045          move.b    55(A1),D0
000012E2  8130 4800 3046          or.b      D0,0(A0,D4.L)
                    3047   OS_EventTaskRdy_1:
                    3048   ; }
                    3049   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000012E6  2F03      3050          move.l    D3,-(A7)
000012E8  2F02      3051          move.l    D2,-(A7)
000012EA  4EB9 0000 3052          jsr       _OS_EventTaskRemove
000012EE  143C      
000012F0  504F      3053          addq.w    #8,A7
                    3054   ; #if (OS_EVENT_MULTI_EN > 0u)
                    3055   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000012F2  2042      3056          move.l    D2,A0
000012F4  2028 0020 3057          move.l    32(A0),D0
000012F8  6716      3058          beq.s     OS_EventTaskRdy_3
                    3059   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000012FA  2042      3060          move.l    D2,A0
000012FC  2F28 0020 3061          move.l    32(A0),-(A7)
00001300  2F02      3062          move.l    D2,-(A7)
00001302  4EB9 0000 3063          jsr       _OS_EventTaskRemoveMulti
00001306  148E      
00001308  504F      3064          addq.w    #8,A7
                    3065   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
0000130A  2042      3066          move.l    D2,A0
0000130C  2143 001C 3067          move.l    D3,28(A0)
                    3068   OS_EventTaskRdy_3:
                    3069   ; }
                    3070   ; #endif
                    3071   ; return (prio);
00001310  1005      3072          move.b    D5,D0
00001312  4CDF 003C 3073          movem.l   (A7)+,D2/D3/D4/D5
00001316  4E5E      3074          unlk      A6
00001318  4E75      3075          rts
                    3076   ; }
                    3077   ; #endif
                    3078   ; /*$PAGE*/
                    3079   ; /*
                    3080   ; *********************************************************************************************************
                    3081   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    3082   ; *
                    3083   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    3084   ; *              not occurred.
                    3085   ; *
                    3086   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    3087   ; *
                    3088   ; * Returns    : none
                    3089   ; *
                    3090   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3091   ; *********************************************************************************************************
                    3092   ; */
                    3093   ; #if (OS_EVENT_EN)
                    3094   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    3095   ; {
                    3096   _OS_EventTaskWait:
0000131A  4E56 0000 3097          link      A6,#0
0000131E  48E7 3020 3098          movem.l   D2/D3/A2,-(A7)
00001322  45F9 0800 3099          lea       _OSTCBCur.L,A2
00001326  1020      
00001328  262E 0008 3100          move.l    8(A6),D3
                    3101   ; INT8U  y;
                    3102   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
0000132C  2052      3103          move.l    (A2),A0
0000132E  2143 001C 3104          move.l    D3,28(A0)
                    3105   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
00001332  2043      3106          move.l    D3,A0
00001334  2252      3107          move.l    (A2),A1
00001336  1029 0036 3108          move.b    54(A1),D0
0000133A  C0BC 0000 3109          and.l     #255,D0
0000133E  00FF      
00001340  D1C0      3110          add.l     D0,A0
00001342  2252      3111          move.l    (A2),A1
00001344  1029 0037 3112          move.b    55(A1),D0
00001348  8128 000A 3113          or.b      D0,10(A0)
                    3114   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0000134C  2043      3115          move.l    D3,A0
0000134E  2252      3116          move.l    (A2),A1
00001350  1029 0038 3117          move.b    56(A1),D0
00001354  8128 0008 3118          or.b      D0,8(A0)
                    3119   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00001358  2052      3120          move.l    (A2),A0
0000135A  1428 0036 3121          move.b    54(A0),D2
                    3122   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0000135E  C4BC 0000 3123          and.l     #255,D2
00001362  00FF      
00001364  41F9 0800 3124          lea       _OSRdyTbl.L,A0
00001368  0F10      
0000136A  2252      3125          move.l    (A2),A1
0000136C  1029 0037 3126          move.b    55(A1),D0
00001370  4600      3127          not.b     D0
00001372  C130 2800 3128          and.b     D0,0(A0,D2.L)
                    3129   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00001376  C4BC 0000 3130          and.l     #255,D2
0000137A  00FF      
0000137C  41F9 0800 3131          lea       _OSRdyTbl.L,A0
00001380  0F10      
00001382  1030 2800 3132          move.b    0(A0,D2.L),D0
00001386  660E      3133          bne.s     OS_EventTaskWait_1
                    3134   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001388  2052      3135          move.l    (A2),A0
0000138A  1028 0038 3136          move.b    56(A0),D0
0000138E  4600      3137          not.b     D0
00001390  C139 0800 3138          and.b     D0,_OSRdyGrp.L
00001394  0F0E      
                    3139   OS_EventTaskWait_1:
00001396  4CDF 040C 3140          movem.l   (A7)+,D2/D3/A2
0000139A  4E5E      3141          unlk      A6
0000139C  4E75      3142          rts
                    3143   ; }
                    3144   ; }
                    3145   ; #endif
                    3146   ; /*$PAGE*/
                    3147   ; /*
                    3148   ; *********************************************************************************************************
                    3149   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    3150   ; *
                    3151   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    3152   ; *              multiple events has not occurred.
                    3153   ; *
                    3154   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    3155   ; *                               which the task will be waiting for.
                    3156   ; *
                    3157   ; * Returns    : none.
                    3158   ; *
                    3159   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3160   ; *********************************************************************************************************
                    3161   ; */
                    3162   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3163   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    3164   ; {
                    3165   _OS_EventTaskWaitMulti:
0000139E  4E56 0000 3166          link      A6,#0
000013A2  48E7 3820 3167          movem.l   D2/D3/D4/A2,-(A7)
000013A6  45F9 0800 3168          lea       _OSTCBCur.L,A2
000013AA  1020      
                    3169   ; OS_EVENT **pevents;
                    3170   ; OS_EVENT  *pevent;
                    3171   ; INT8U      y;
                    3172   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000013AC  2052      3173          move.l    (A2),A0
000013AE  42A8 001C 3174          clr.l     28(A0)
                    3175   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
000013B2  2052      3176          move.l    (A2),A0
000013B4  216E 0008 3177          move.l    8(A6),32(A0)
000013B8  0020      
                    3178   ; pevents =  pevents_wait;
000013BA  262E 0008 3179          move.l    8(A6),D3
                    3180   ; pevent  = *pevents;
000013BE  2043      3181          move.l    D3,A0
000013C0  2410      3182          move.l    (A0),D2
                    3183   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    3184   OS_EventTaskWaitMulti_1:
000013C2  4A82      3185          tst.l     D2
000013C4  6700 0030 3186          beq       OS_EventTaskWaitMulti_3
                    3187   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000013C8  2042      3188          move.l    D2,A0
000013CA  2252      3189          move.l    (A2),A1
000013CC  1029 0036 3190          move.b    54(A1),D0
000013D0  C0BC 0000 3191          and.l     #255,D0
000013D4  00FF      
000013D6  D1C0      3192          add.l     D0,A0
000013D8  2252      3193          move.l    (A2),A1
000013DA  1029 0037 3194          move.b    55(A1),D0
000013DE  8128 000A 3195          or.b      D0,10(A0)
                    3196   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000013E2  2042      3197          move.l    D2,A0
000013E4  2252      3198          move.l    (A2),A1
000013E6  1029 0038 3199          move.b    56(A1),D0
000013EA  8128 0008 3200          or.b      D0,8(A0)
                    3201   ; pevents++;
000013EE  5883      3202          addq.l    #4,D3
                    3203   ; pevent = *pevents;
000013F0  2043      3204          move.l    D3,A0
000013F2  2410      3205          move.l    (A0),D2
000013F4  60CC      3206          bra       OS_EventTaskWaitMulti_1
                    3207   OS_EventTaskWaitMulti_3:
                    3208   ; }
                    3209   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000013F6  2052      3210          move.l    (A2),A0
000013F8  1828 0036 3211          move.b    54(A0),D4
                    3212   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000013FC  C8BC 0000 3213          and.l     #255,D4
00001400  00FF      
00001402  41F9 0800 3214          lea       _OSRdyTbl.L,A0
00001406  0F10      
00001408  2252      3215          move.l    (A2),A1
0000140A  1029 0037 3216          move.b    55(A1),D0
0000140E  4600      3217          not.b     D0
00001410  C130 4800 3218          and.b     D0,0(A0,D4.L)
                    3219   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00001414  C8BC 0000 3220          and.l     #255,D4
00001418  00FF      
0000141A  41F9 0800 3221          lea       _OSRdyTbl.L,A0
0000141E  0F10      
00001420  1030 4800 3222          move.b    0(A0,D4.L),D0
00001424  660E      3223          bne.s     OS_EventTaskWaitMulti_4
                    3224   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001426  2052      3225          move.l    (A2),A0
00001428  1028 0038 3226          move.b    56(A0),D0
0000142C  4600      3227          not.b     D0
0000142E  C139 0800 3228          and.b     D0,_OSRdyGrp.L
00001432  0F0E      
                    3229   OS_EventTaskWaitMulti_4:
00001434  4CDF 041C 3230          movem.l   (A7)+,D2/D3/D4/A2
00001438  4E5E      3231          unlk      A6
0000143A  4E75      3232          rts
                    3233   ; }
                    3234   ; }
                    3235   ; #endif
                    3236   ; /*$PAGE*/
                    3237   ; /*
                    3238   ; *********************************************************************************************************
                    3239   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    3240   ; *
                    3241   ; * Description: Remove a task from an event's wait list.
                    3242   ; *
                    3243   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    3244   ; *
                    3245   ; *              pevent   is a pointer to the event control block.
                    3246   ; *
                    3247   ; * Returns    : none
                    3248   ; *
                    3249   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3250   ; *********************************************************************************************************
                    3251   ; */
                    3252   ; #if (OS_EVENT_EN)
                    3253   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    3254   ; OS_EVENT *pevent)
                    3255   ; {
                    3256   _OS_EventTaskRemove:
0000143C  4E56 0000 3257          link      A6,#0
00001440  48E7 3800 3258          movem.l   D2/D3/D4,-(A7)
00001444  242E 000C 3259          move.l    12(A6),D2
00001448  262E 0008 3260          move.l    8(A6),D3
                    3261   ; INT8U  y;
                    3262   ; y                       =  ptcb->OSTCBY;
0000144C  2043      3263          move.l    D3,A0
0000144E  1828 0036 3264          move.b    54(A0),D4
                    3265   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
00001452  2042      3266          move.l    D2,A0
00001454  C8BC 0000 3267          and.l     #255,D4
00001458  00FF      
0000145A  D1C4      3268          add.l     D4,A0
0000145C  2243      3269          move.l    D3,A1
0000145E  1029 0037 3270          move.b    55(A1),D0
00001462  4600      3271          not.b     D0
00001464  C128 000A 3272          and.b     D0,10(A0)
                    3273   ; if (pevent->OSEventTbl[y] == 0u) {
00001468  2042      3274          move.l    D2,A0
0000146A  C8BC 0000 3275          and.l     #255,D4
0000146E  00FF      
00001470  D1C4      3276          add.l     D4,A0
00001472  1028 000A 3277          move.b    10(A0),D0
00001476  660E      3278          bne.s     OS_EventTaskRemove_1
                    3279   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001478  2042      3280          move.l    D2,A0
0000147A  2243      3281          move.l    D3,A1
0000147C  1029 0038 3282          move.b    56(A1),D0
00001480  4600      3283          not.b     D0
00001482  C128 0008 3284          and.b     D0,8(A0)
                    3285   OS_EventTaskRemove_1:
00001486  4CDF 001C 3286          movem.l   (A7)+,D2/D3/D4
0000148A  4E5E      3287          unlk      A6
0000148C  4E75      3288          rts
                    3289   ; }
                    3290   ; }
                    3291   ; #endif
                    3292   ; /*$PAGE*/
                    3293   ; /*
                    3294   ; *********************************************************************************************************
                    3295   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    3296   ; *
                    3297   ; * Description: Remove a task from multiple events' wait lists.
                    3298   ; *
                    3299   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3300   ; *
                    3301   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3302   ; *
                    3303   ; * Returns    : none
                    3304   ; *
                    3305   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3306   ; *********************************************************************************************************
                    3307   ; */
                    3308   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3309   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3310   ; OS_EVENT **pevents_multi)
                    3311   ; {
                    3312   _OS_EventTaskRemoveMulti:
0000148E  4E56 FFFC 3313          link      A6,#-4
00001492  48E7 3C00 3314          movem.l   D2/D3/D4/D5,-(A7)
00001496  282E 0008 3315          move.l    8(A6),D4
                    3316   ; OS_EVENT **pevents;
                    3317   ; OS_EVENT  *pevent;
                    3318   ; INT8U      y;
                    3319   ; OS_PRIO    bity;
                    3320   ; OS_PRIO    bitx;
                    3321   ; y       =  ptcb->OSTCBY;
0000149A  2044      3322          move.l    D4,A0
0000149C  1A28 0036 3323          move.b    54(A0),D5
                    3324   ; bity    =  ptcb->OSTCBBitY;
000014A0  2044      3325          move.l    D4,A0
000014A2  1D68 0038 3326          move.b    56(A0),-2(A6)
000014A6  FFFE      
                    3327   ; bitx    =  ptcb->OSTCBBitX;
000014A8  2044      3328          move.l    D4,A0
000014AA  1D68 0037 3329          move.b    55(A0),-1(A6)
000014AE  FFFF      
                    3330   ; pevents =  pevents_multi;
000014B0  262E 000C 3331          move.l    12(A6),D3
                    3332   ; pevent  = *pevents;
000014B4  2043      3333          move.l    D3,A0
000014B6  2410      3334          move.l    (A0),D2
                    3335   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3336   OS_EventTaskRemoveMulti_1:
000014B8  4A82      3337          tst.l     D2
000014BA  6700 003A 3338          beq       OS_EventTaskRemoveMulti_3
                    3339   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
000014BE  2042      3340          move.l    D2,A0
000014C0  CABC 0000 3341          and.l     #255,D5
000014C4  00FF      
000014C6  D1C5      3342          add.l     D5,A0
000014C8  102E FFFF 3343          move.b    -1(A6),D0
000014CC  4600      3344          not.b     D0
000014CE  C128 000A 3345          and.b     D0,10(A0)
                    3346   ; if (pevent->OSEventTbl[y] == 0u) {
000014D2  2042      3347          move.l    D2,A0
000014D4  CABC 0000 3348          and.l     #255,D5
000014D8  00FF      
000014DA  D1C5      3349          add.l     D5,A0
000014DC  1028 000A 3350          move.b    10(A0),D0
000014E0  660C      3351          bne.s     OS_EventTaskRemoveMulti_4
                    3352   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
000014E2  2042      3353          move.l    D2,A0
000014E4  102E FFFE 3354          move.b    -2(A6),D0
000014E8  4600      3355          not.b     D0
000014EA  C128 0008 3356          and.b     D0,8(A0)
                    3357   OS_EventTaskRemoveMulti_4:
                    3358   ; }
                    3359   ; pevents++;
000014EE  5883      3360          addq.l    #4,D3
                    3361   ; pevent = *pevents;
000014F0  2043      3362          move.l    D3,A0
000014F2  2410      3363          move.l    (A0),D2
000014F4  60C2      3364          bra       OS_EventTaskRemoveMulti_1
                    3365   OS_EventTaskRemoveMulti_3:
000014F6  4CDF 003C 3366          movem.l   (A7)+,D2/D3/D4/D5
000014FA  4E5E      3367          unlk      A6
000014FC  4E75      3368          rts
                    3369   ; }
                    3370   ; }
                    3371   ; #endif
                    3372   ; /*$PAGE*/
                    3373   ; /*
                    3374   ; *********************************************************************************************************
                    3375   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3376   ; *
                    3377   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3378   ; *
                    3379   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3380   ; *
                    3381   ; * Returns    : none
                    3382   ; *
                    3383   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3384   ; *********************************************************************************************************
                    3385   ; */
                    3386   ; #if (OS_EVENT_EN)
                    3387   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3388   ; {
                    3389   _OS_EventWaitListInit:
000014FE  4E56 0000 3390          link      A6,#0
00001502  2F02      3391          move.l    D2,-(A7)
                    3392   ; INT8U  i;
                    3393   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
00001504  206E 0008 3394          move.l    8(A6),A0
00001508  4228 0008 3395          clr.b     8(A0)
                    3396   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0000150C  4202      3397          clr.b     D2
                    3398   OS_EventWaitListInit_1:
0000150E  0C02 0008 3399          cmp.b     #8,D2
00001512  6414      3400          bhs.s     OS_EventWaitListInit_3
                    3401   ; pevent->OSEventTbl[i] = 0u;
00001514  206E 0008 3402          move.l    8(A6),A0
00001518  C4BC 0000 3403          and.l     #255,D2
0000151C  00FF      
0000151E  D1C2      3404          add.l     D2,A0
00001520  4228 000A 3405          clr.b     10(A0)
00001524  5202      3406          addq.b    #1,D2
00001526  60E6      3407          bra       OS_EventWaitListInit_1
                    3408   OS_EventWaitListInit_3:
00001528  241F      3409          move.l    (A7)+,D2
0000152A  4E5E      3410          unlk      A6
0000152C  4E75      3411          rts
                    3412   ; }
                    3413   ; }
                    3414   ; #endif
                    3415   ; /*$PAGE*/
                    3416   ; /*
                    3417   ; *********************************************************************************************************
                    3418   ; *                                             INITIALIZATION
                    3419   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3420   ; *
                    3421   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3422   ; *
                    3423   ; * Arguments  : none
                    3424   ; *
                    3425   ; * Returns    : none
                    3426   ; *********************************************************************************************************
                    3427   ; */
                    3428   ; static  void  OS_InitEventList (void)
                    3429   ; {
                    3430   @ucos_ii_OS_InitEventList:
0000152E  4E56 FFF8 3431          link      A6,#-8
00001532  48E7 3020 3432          movem.l   D2/D3/A2,-(A7)
00001536  45F9 0800 3433          lea       _OSEventTbl.L,A2
0000153A  0CDE      
                    3434   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3435   ; #if (OS_MAX_EVENTS > 1u)
                    3436   ; INT16U     ix;
                    3437   ; INT16U     ix_next;
                    3438   ; OS_EVENT  *pevent1;
                    3439   ; OS_EVENT  *pevent2;
                    3440   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0000153C  4878 00DC 3441          pea       220
00001540  2F0A      3442          move.l    A2,-(A7)
00001542  4EB9 0000 3443          jsr       _OS_MemClr
00001546  17CA      
00001548  504F      3444          addq.w    #8,A7
                    3445   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
0000154A  4243      3446          clr.w     D3
                    3447   @ucos_ii_OS_InitEventList_1:
0000154C  0C43 0009 3448          cmp.w     #9,D3
00001550  6400 004E 3449          bhs       @ucos_ii_OS_InitEventList_3
                    3450   ; ix_next = ix + 1u;
00001554  3003      3451          move.w    D3,D0
00001556  5240      3452          addq.w    #1,D0
00001558  3D40 FFFA 3453          move.w    D0,-6(A6)
                    3454   ; pevent1 = &OSEventTbl[ix];
0000155C  200A      3455          move.l    A2,D0
0000155E  C6BC 0000 3456          and.l     #65535,D3
00001562  FFFF      
00001564  2203      3457          move.l    D3,D1
00001566  C3FC 0016 3458          muls      #22,D1
0000156A  D081      3459          add.l     D1,D0
0000156C  2400      3460          move.l    D0,D2
                    3461   ; pevent2 = &OSEventTbl[ix_next];
0000156E  200A      3462          move.l    A2,D0
00001570  322E FFFA 3463          move.w    -6(A6),D1
00001574  C2BC 0000 3464          and.l     #65535,D1
00001578  FFFF      
0000157A  C3FC 0016 3465          muls      #22,D1
0000157E  D081      3466          add.l     D1,D0
00001580  2D40 FFFC 3467          move.l    D0,-4(A6)
                    3468   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00001584  2042      3469          move.l    D2,A0
00001586  4210      3470          clr.b     (A0)
                    3471   ; pevent1->OSEventPtr     = pevent2;
00001588  2042      3472          move.l    D2,A0
0000158A  216E FFFC 3473          move.l    -4(A6),2(A0)
0000158E  0002      
                    3474   ; #if OS_EVENT_NAME_EN > 0u
                    3475   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00001590  41F9 0000 3476          lea       @ucos_ii_1.L,A0
00001594  68A4      
00001596  2242      3477          move.l    D2,A1
00001598  2348 0012 3478          move.l    A0,18(A1)
0000159C  5243      3479          addq.w    #1,D3
0000159E  60AC      3480          bra       @ucos_ii_OS_InitEventList_1
                    3481   @ucos_ii_OS_InitEventList_3:
                    3482   ; #endif
                    3483   ; }
                    3484   ; pevent1                         = &OSEventTbl[ix];
000015A0  200A      3485          move.l    A2,D0
000015A2  C6BC 0000 3486          and.l     #65535,D3
000015A6  FFFF      
000015A8  2203      3487          move.l    D3,D1
000015AA  C3FC 0016 3488          muls      #22,D1
000015AE  D081      3489          add.l     D1,D0
000015B0  2400      3490          move.l    D0,D2
                    3491   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000015B2  2042      3492          move.l    D2,A0
000015B4  4210      3493          clr.b     (A0)
                    3494   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
000015B6  2042      3495          move.l    D2,A0
000015B8  42A8 0002 3496          clr.l     2(A0)
                    3497   ; #if OS_EVENT_NAME_EN > 0u
                    3498   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
000015BC  41F9 0000 3499          lea       @ucos_ii_1.L,A0
000015C0  68A4      
000015C2  2242      3500          move.l    D2,A1
000015C4  2348 0012 3501          move.l    A0,18(A1)
                    3502   ; #endif
                    3503   ; OSEventFreeList                 = &OSEventTbl[0];
000015C8  23CA 0800 3504          move.l    A2,_OSEventFreeList.L
000015CC  0CDA      
000015CE  4CDF 040C 3505          movem.l   (A7)+,D2/D3/A2
000015D2  4E5E      3506          unlk      A6
000015D4  4E75      3507          rts
                    3508   ; #else
                    3509   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3510   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3511   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3512   ; #if OS_EVENT_NAME_EN > 0u
                    3513   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3514   ; #endif
                    3515   ; #endif
                    3516   ; #endif
                    3517   ; }
                    3518   ; /*$PAGE*/
                    3519   ; /*
                    3520   ; *********************************************************************************************************
                    3521   ; *                                             INITIALIZATION
                    3522   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3523   ; *
                    3524   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3525   ; *
                    3526   ; * Arguments  : none
                    3527   ; *
                    3528   ; * Returns    : none
                    3529   ; *********************************************************************************************************
                    3530   ; */
                    3531   ; static  void  OS_InitMisc (void)
                    3532   ; {
                    3533   @ucos_ii_OS_InitMisc:
                    3534   ; #if OS_TIME_GET_SET_EN > 0u
                    3535   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000015D6  42B9 0800 3536          clr.l     _OSTime.L
000015DA  1976      
                    3537   ; #endif
                    3538   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000015DC  4239 0800 3539          clr.b     _OSIntNesting.L
000015E0  0F06      
                    3540   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
000015E2  4239 0800 3541          clr.b     _OSLockNesting.L
000015E6  0F08      
                    3542   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
000015E8  4239 0800 3543          clr.b     _OSTaskCtr.L
000015EC  0F1A      
                    3544   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000015EE  4239 0800 3545          clr.b     _OSRunning.L
000015F2  0F18      
                    3546   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000015F4  42B9 0800 3547          clr.l     _OSCtxSwCtr.L
000015F8  0CD6      
                    3548   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
000015FA  42B9 0800 3549          clr.l     _OSIdleCtr.L
000015FE  0F1C      
                    3550   ; #if OS_TASK_STAT_EN > 0u
                    3551   ; OSIdleCtrRun              = 0uL;
00001600  42B9 0800 3552          clr.l     _OSIdleCtrRun.L
00001604  0E00      
                    3553   ; OSIdleCtrMax              = 0uL;
00001606  42B9 0800 3554          clr.l     _OSIdleCtrMax.L
0000160A  0DFC      
                    3555   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
0000160C  4239 0800 3556          clr.b     _OSStatRdy.L
00001610  0E04      
                    3557   ; #endif
                    3558   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3559   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3560   ; #endif
                    3561   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3562   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
00001612  4239 0800 3563          clr.b     _OSTaskRegNextAvailID.L
00001616  1974      
00001618  4E75      3564          rts
                    3565   ; #endif
                    3566   ; }
                    3567   ; /*$PAGE*/
                    3568   ; /*
                    3569   ; *********************************************************************************************************
                    3570   ; *                                             INITIALIZATION
                    3571   ; *                                       INITIALIZE THE READY LIST
                    3572   ; *
                    3573   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3574   ; *
                    3575   ; * Arguments  : none
                    3576   ; *
                    3577   ; * Returns    : none
                    3578   ; *********************************************************************************************************
                    3579   ; */
                    3580   ; static  void  OS_InitRdyList (void)
                    3581   ; {
                    3582   @ucos_ii_OS_InitRdyList:
0000161A  2F02      3583          move.l    D2,-(A7)
                    3584   ; INT8U  i;
                    3585   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
0000161C  4239 0800 3586          clr.b     _OSRdyGrp.L
00001620  0F0E      
                    3587   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
00001622  4202      3588          clr.b     D2
                    3589   @ucos_ii_OS_InitRdyList_1:
00001624  0C02 0008 3590          cmp.b     #8,D2
00001628  6414      3591          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3592   ; OSRdyTbl[i] = 0u;
0000162A  C4BC 0000 3593          and.l     #255,D2
0000162E  00FF      
00001630  41F9 0800 3594          lea       _OSRdyTbl.L,A0
00001634  0F10      
00001636  4230 2800 3595          clr.b     0(A0,D2.L)
0000163A  5202      3596          addq.b    #1,D2
0000163C  60E6      3597          bra       @ucos_ii_OS_InitRdyList_1
                    3598   @ucos_ii_OS_InitRdyList_3:
                    3599   ; }
                    3600   ; OSPrioCur     = 0u;
0000163E  4239 0800 3601          clr.b     _OSPrioCur.L
00001642  0F0A      
                    3602   ; OSPrioHighRdy = 0u;
00001644  4239 0800 3603          clr.b     _OSPrioHighRdy.L
00001648  0F0C      
                    3604   ; OSTCBHighRdy  = (OS_TCB *)0;
0000164A  42B9 0800 3605          clr.l     _OSTCBHighRdy.L
0000164E  1028      
                    3606   ; OSTCBCur      = (OS_TCB *)0;
00001650  42B9 0800 3607          clr.l     _OSTCBCur.L
00001654  1020      
00001656  241F      3608          move.l    (A7)+,D2
00001658  4E75      3609          rts
                    3610   ; }
                    3611   ; /*$PAGE*/
                    3612   ; /*
                    3613   ; *********************************************************************************************************
                    3614   ; *                                             INITIALIZATION
                    3615   ; *                                         CREATING THE IDLE TASK
                    3616   ; *
                    3617   ; * Description: This function creates the Idle Task.
                    3618   ; *
                    3619   ; * Arguments  : none
                    3620   ; *
                    3621   ; * Returns    : none
                    3622   ; *********************************************************************************************************
                    3623   ; */
                    3624   ; static  void  OS_InitTaskIdle (void)
                    3625   ; {
                    3626   @ucos_ii_OS_InitTaskIdle:
0000165A  4E56 FFFC 3627          link      A6,#-4
                    3628   ; #if OS_TASK_NAME_EN > 0u
                    3629   ; INT8U  err;
                    3630   ; #endif
                    3631   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3632   ; #if OS_STK_GROWTH == 1u
                    3633   ; (void)OSTaskCreateExt(OS_TaskIdle,
0000165E  4878 0003 3634          pea       3
00001662  42A7      3635          clr.l     -(A7)
00001664  4878 0080 3636          pea       128
00001668  4879 0800 3637          pea       _OSTaskIdleStk.L
0000166C  0F20      
0000166E  4878 FFFF 3638          pea       65535
00001672  4878 003F 3639          pea       63
00001676  41F9 0800 3640          lea       _OSTaskIdleStk.L,A0
0000167A  0F20      
0000167C  D0FC 00FE 3641          add.w     #254,A0
00001680  2F08      3642          move.l    A0,-(A7)
00001682  42A7      3643          clr.l     -(A7)
00001684  4879 0000 3644          pea       _OS_TaskIdle.L
00001688  18E0      
0000168A  4EB9 0000 3645          jsr       _OSTaskCreateExt
0000168E  4780      
00001690  DEFC 0024 3646          add.w     #36,A7
00001694  C0BC 0000 3647          and.l     #255,D0
00001698  00FF      
                    3648   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3649   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3650   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3651   ; OS_TASK_IDLE_ID,
                    3652   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3653   ; OS_TASK_IDLE_STK_SIZE,
                    3654   ; (void *)0,                                 /* No TCB extension                     */
                    3655   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3656   ; #else
                    3657   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3658   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3659   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3660   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3661   ; OS_TASK_IDLE_ID,
                    3662   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3663   ; OS_TASK_IDLE_STK_SIZE,
                    3664   ; (void *)0,                                 /* No TCB extension                     */
                    3665   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3666   ; #endif
                    3667   ; #else
                    3668   ; #if OS_STK_GROWTH == 1u
                    3669   ; (void)OSTaskCreate(OS_TaskIdle,
                    3670   ; (void *)0,
                    3671   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3672   ; OS_TASK_IDLE_PRIO);
                    3673   ; #else
                    3674   ; (void)OSTaskCreate(OS_TaskIdle,
                    3675   ; (void *)0,
                    3676   ; &OSTaskIdleStk[0],
                    3677   ; OS_TASK_IDLE_PRIO);
                    3678   ; #endif
                    3679   ; #endif
                    3680   ; #if OS_TASK_NAME_EN > 0u
                    3681   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
0000169A  486E FFFF 3682          pea       -1(A6)
0000169E  4879 0000 3683          pea       @ucos_ii_2.L
000016A2  68A6      
000016A4  4878 003F 3684          pea       63
000016A8  4EB9 0000 3685          jsr       _OSTaskNameSet
000016AC  4B8C      
000016AE  DEFC 000C 3686          add.w     #12,A7
000016B2  4E5E      3687          unlk      A6
000016B4  4E75      3688          rts
                    3689   ; #endif
                    3690   ; }
                    3691   ; /*$PAGE*/
                    3692   ; /*
                    3693   ; *********************************************************************************************************
                    3694   ; *                                             INITIALIZATION
                    3695   ; *                                      CREATING THE STATISTIC TASK
                    3696   ; *
                    3697   ; * Description: This function creates the Statistic Task.
                    3698   ; *
                    3699   ; * Arguments  : none
                    3700   ; *
                    3701   ; * Returns    : none
                    3702   ; *********************************************************************************************************
                    3703   ; */
                    3704   ; #if OS_TASK_STAT_EN > 0u
                    3705   ; static  void  OS_InitTaskStat (void)
                    3706   ; {
                    3707   @ucos_ii_OS_InitTaskStat:
000016B6  4E56 FFFC 3708          link      A6,#-4
                    3709   ; #if OS_TASK_NAME_EN > 0u
                    3710   ; INT8U  err;
                    3711   ; #endif
                    3712   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3713   ; #if OS_STK_GROWTH == 1u
                    3714   ; (void)OSTaskCreateExt(OS_TaskStat,
000016BA  4878 0003 3715          pea       3
000016BE  42A7      3716          clr.l     -(A7)
000016C0  4878 0080 3717          pea       128
000016C4  4879 0800 3718          pea       _OSTaskStatStk.L
000016C8  0E06      
000016CA  4878 FFFE 3719          pea       65534
000016CE  4878 003E 3720          pea       62
000016D2  41F9 0800 3721          lea       _OSTaskStatStk.L,A0
000016D6  0E06      
000016D8  D0FC 00FE 3722          add.w     #254,A0
000016DC  2F08      3723          move.l    A0,-(A7)
000016DE  42A7      3724          clr.l     -(A7)
000016E0  4879 0000 3725          pea       _OS_TaskStat.L
000016E4  18F8      
000016E6  4EB9 0000 3726          jsr       _OSTaskCreateExt
000016EA  4780      
000016EC  DEFC 0024 3727          add.w     #36,A7
000016F0  C0BC 0000 3728          and.l     #255,D0
000016F4  00FF      
                    3729   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3730   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3731   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3732   ; OS_TASK_STAT_ID,
                    3733   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3734   ; OS_TASK_STAT_STK_SIZE,
                    3735   ; (void *)0,                                   /* No TCB extension               */
                    3736   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3737   ; #else
                    3738   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3739   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3740   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3741   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3742   ; OS_TASK_STAT_ID,
                    3743   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3744   ; OS_TASK_STAT_STK_SIZE,
                    3745   ; (void *)0,                                   /* No TCB extension               */
                    3746   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3747   ; #endif
                    3748   ; #else
                    3749   ; #if OS_STK_GROWTH == 1u
                    3750   ; (void)OSTaskCreate(OS_TaskStat,
                    3751   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3752   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3753   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3754   ; #else
                    3755   ; (void)OSTaskCreate(OS_TaskStat,
                    3756   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3757   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3758   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3759   ; #endif
                    3760   ; #endif
                    3761   ; #if OS_TASK_NAME_EN > 0u
                    3762   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000016F6  486E FFFF 3763          pea       -1(A6)
000016FA  4879 0000 3764          pea       @ucos_ii_3.L
000016FE  68B4      
00001700  4878 003E 3765          pea       62
00001704  4EB9 0000 3766          jsr       _OSTaskNameSet
00001708  4B8C      
0000170A  DEFC 000C 3767          add.w     #12,A7
0000170E  4E5E      3768          unlk      A6
00001710  4E75      3769          rts
                    3770   ; #endif
                    3771   ; }
                    3772   ; #endif
                    3773   ; /*$PAGE*/
                    3774   ; /*
                    3775   ; *********************************************************************************************************
                    3776   ; *                                             INITIALIZATION
                    3777   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3778   ; *
                    3779   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3780   ; *
                    3781   ; * Arguments  : none
                    3782   ; *
                    3783   ; * Returns    : none
                    3784   ; *********************************************************************************************************
                    3785   ; */
                    3786   ; static  void  OS_InitTCBList (void)
                    3787   ; {
                    3788   @ucos_ii_OS_InitTCBList:
00001712  4E56 FFF8 3789          link      A6,#-8
00001716  48E7 3020 3790          movem.l   D2/D3/A2,-(A7)
0000171A  45F9 0800 3791          lea       _OSTCBTbl.L,A2
0000171E  1130      
                    3792   ; INT8U    ix;
                    3793   ; INT8U    ix_next;
                    3794   ; OS_TCB  *ptcb1;
                    3795   ; OS_TCB  *ptcb2;
                    3796   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
00001720  4878 0764 3797          pea       1892
00001724  2F0A      3798          move.l    A2,-(A7)
00001726  4EB9 0000 3799          jsr       _OS_MemClr
0000172A  17CA      
0000172C  504F      3800          addq.w    #8,A7
                    3801   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
0000172E  4878 0100 3802          pea       256
00001732  4879 0800 3803          pea       _OSTCBPrioTbl.L
00001736  1030      
00001738  4EB9 0000 3804          jsr       _OS_MemClr
0000173C  17CA      
0000173E  504F      3805          addq.w    #8,A7
                    3806   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
00001740  4203      3807          clr.b     D3
                    3808   @ucos_ii_OS_InitTCBList_1:
00001742  0C03 0015 3809          cmp.b     #21,D3
00001746  6400 004A 3810          bhs       @ucos_ii_OS_InitTCBList_3
                    3811   ; ix_next =  ix + 1u;
0000174A  7001      3812          moveq     #1,D0
0000174C  D003      3813          add.b     D3,D0
0000174E  1D40 FFFB 3814          move.b    D0,-5(A6)
                    3815   ; ptcb1   = &OSTCBTbl[ix];
00001752  200A      3816          move.l    A2,D0
00001754  C6BC 0000 3817          and.l     #255,D3
00001758  00FF      
0000175A  2203      3818          move.l    D3,D1
0000175C  C3FC 0056 3819          muls      #86,D1
00001760  D081      3820          add.l     D1,D0
00001762  2400      3821          move.l    D0,D2
                    3822   ; ptcb2   = &OSTCBTbl[ix_next];
00001764  200A      3823          move.l    A2,D0
00001766  122E FFFB 3824          move.b    -5(A6),D1
0000176A  C2BC 0000 3825          and.l     #255,D1
0000176E  00FF      
00001770  C3FC 0056 3826          muls      #86,D1
00001774  D081      3827          add.l     D1,D0
00001776  2D40 FFFC 3828          move.l    D0,-4(A6)
                    3829   ; ptcb1->OSTCBNext = ptcb2;
0000177A  2042      3830          move.l    D2,A0
0000177C  216E FFFC 3831          move.l    -4(A6),20(A0)
00001780  0014      
                    3832   ; #if OS_TASK_NAME_EN > 0u
                    3833   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00001782  41F9 0000 3834          lea       @ucos_ii_1.L,A0
00001786  68A4      
00001788  2242      3835          move.l    D2,A1
0000178A  2348 004E 3836          move.l    A0,78(A1)
0000178E  5203      3837          addq.b    #1,D3
00001790  60B0      3838          bra       @ucos_ii_OS_InitTCBList_1
                    3839   @ucos_ii_OS_InitTCBList_3:
                    3840   ; #endif
                    3841   ; }
                    3842   ; ptcb1                   = &OSTCBTbl[ix];
00001792  200A      3843          move.l    A2,D0
00001794  C6BC 0000 3844          and.l     #255,D3
00001798  00FF      
0000179A  2203      3845          move.l    D3,D1
0000179C  C3FC 0056 3846          muls      #86,D1
000017A0  D081      3847          add.l     D1,D0
000017A2  2400      3848          move.l    D0,D2
                    3849   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000017A4  2042      3850          move.l    D2,A0
000017A6  42A8 0014 3851          clr.l     20(A0)
                    3852   ; #if OS_TASK_NAME_EN > 0u
                    3853   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000017AA  41F9 0000 3854          lea       @ucos_ii_1.L,A0
000017AE  68A4      
000017B0  2242      3855          move.l    D2,A1
000017B2  2348 004E 3856          move.l    A0,78(A1)
                    3857   ; #endif
                    3858   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000017B6  42B9 0800 3859          clr.l     _OSTCBList.L
000017BA  102C      
                    3860   ; OSTCBFreeList           = &OSTCBTbl[0];
000017BC  23CA 0800 3861          move.l    A2,_OSTCBFreeList.L
000017C0  1024      
000017C2  4CDF 040C 3862          movem.l   (A7)+,D2/D3/A2
000017C6  4E5E      3863          unlk      A6
000017C8  4E75      3864          rts
                    3865   ; }
                    3866   ; /*$PAGE*/
                    3867   ; /*
                    3868   ; *********************************************************************************************************
                    3869   ; *                                      CLEAR A SECTION OF MEMORY
                    3870   ; *
                    3871   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3872   ; *
                    3873   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3874   ; *
                    3875   ; *              size     is the number of bytes to clear.
                    3876   ; *
                    3877   ; * Returns    : none
                    3878   ; *
                    3879   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3880   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3881   ; *                 of the uses of this function gets close to this limit.
                    3882   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3883   ; *                 of the alignment of the destination.
                    3884   ; *********************************************************************************************************
                    3885   ; */
                    3886   ; void  OS_MemClr (INT8U  *pdest,
                    3887   ; INT16U  size)
                    3888   ; {
                    3889   _OS_MemClr:
000017CA  4E56 0000 3890          link      A6,#0
                    3891   ; while (size > 0u) {
                    3892   OS_MemClr_1:
000017CE  302E 000E 3893          move.w    14(A6),D0
000017D2  0C40 0000 3894          cmp.w     #0,D0
000017D6  6310      3895          bls.s     OS_MemClr_3
                    3896   ; *pdest++ = (INT8U)0;
000017D8  206E 0008 3897          move.l    8(A6),A0
000017DC  52AE 0008 3898          addq.l    #1,8(A6)
000017E0  4210      3899          clr.b     (A0)
                    3900   ; size--;
000017E2  536E 000E 3901          subq.w    #1,14(A6)
000017E6  60E6      3902          bra       OS_MemClr_1
                    3903   OS_MemClr_3:
000017E8  4E5E      3904          unlk      A6
000017EA  4E75      3905          rts
                    3906   ; }
                    3907   ; }
                    3908   ; /*$PAGE*/
                    3909   ; /*
                    3910   ; *********************************************************************************************************
                    3911   ; *                                       COPY A BLOCK OF MEMORY
                    3912   ; *
                    3913   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3914   ; *              location to another.
                    3915   ; *
                    3916   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    3917   ; *
                    3918   ; *              psrc     is a pointer to the 'source'      memory block
                    3919   ; *
                    3920   ; *              size     is the number of bytes to copy.
                    3921   ; *
                    3922   ; * Returns    : none
                    3923   ; *
                    3924   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    3925   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    3926   ; *                 is not a situation that will happen.
                    3927   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    3928   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    3929   ; *                 of the alignment of the source and destination.
                    3930   ; *********************************************************************************************************
                    3931   ; */
                    3932   ; void  OS_MemCopy (INT8U  *pdest,
                    3933   ; INT8U  *psrc,
                    3934   ; INT16U  size)
                    3935   ; {
                    3936   _OS_MemCopy:
000017EC  4E56 0000 3937          link      A6,#0
                    3938   ; while (size > 0u) {
                    3939   OS_MemCopy_1:
000017F0  302E 0012 3940          move.w    18(A6),D0
000017F4  0C40 0000 3941          cmp.w     #0,D0
000017F8  6318      3942          bls.s     OS_MemCopy_3
                    3943   ; *pdest++ = *psrc++;
000017FA  206E 000C 3944          move.l    12(A6),A0
000017FE  52AE 000C 3945          addq.l    #1,12(A6)
00001802  226E 0008 3946          move.l    8(A6),A1
00001806  52AE 0008 3947          addq.l    #1,8(A6)
0000180A  1290      3948          move.b    (A0),(A1)
                    3949   ; size--;
0000180C  536E 0012 3950          subq.w    #1,18(A6)
00001810  60DE      3951          bra       OS_MemCopy_1
                    3952   OS_MemCopy_3:
00001812  4E5E      3953          unlk      A6
00001814  4E75      3954          rts
                    3955   ; }
                    3956   ; }
                    3957   ; /*$PAGE*/
                    3958   ; /*
                    3959   ; *********************************************************************************************************
                    3960   ; *                                              SCHEDULER
                    3961   ; *
                    3962   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    3963   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    3964   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    3965   ; *
                    3966   ; * Arguments  : none
                    3967   ; *
                    3968   ; * Returns    : none
                    3969   ; *
                    3970   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3971   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    3972   ; *********************************************************************************************************
                    3973   ; */
                    3974   ; void  OS_Sched (void)
                    3975   ; {
                    3976   _OS_Sched:
                    3977   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    3978   ; OS_CPU_SR  cpu_sr = 0u;
                    3979   ; #endif
                    3980   ; OS_ENTER_CRITICAL();
00001816  40E7      3981          dc.w      16615
00001818  007C      3982          dc.w      124
0000181A  0700      3983          dc.w      1792
                    3984   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
0000181C  1039 0800 3985          move.b    _OSIntNesting.L,D0
00001820  0F06      
00001822  6600 0052 3986          bne       OS_Sched_5
                    3987   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
00001826  1039 0800 3988          move.b    _OSLockNesting.L,D0
0000182A  0F08      
0000182C  6648      3989          bne.s     OS_Sched_5
                    3990   ; OS_SchedNew();
0000182E  4EB9 0000 3991          jsr       @ucos_ii_OS_SchedNew
00001832  187A      
                    3992   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001834  1039 0800 3993          move.b    _OSPrioHighRdy.L,D0
00001838  0F0C      
0000183A  C0BC 0000 3994          and.l     #255,D0
0000183E  00FF      
00001840  E588      3995          lsl.l     #2,D0
00001842  41F9 0800 3996          lea       _OSTCBPrioTbl.L,A0
00001846  1030      
00001848  23F0 0800 3997          move.l    0(A0,D0.L),_OSTCBHighRdy.L
0000184C  0800 1028 
                    3998   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001850  1039 0800 3999          move.b    _OSPrioHighRdy.L,D0
00001854  0F0C      
00001856  B039 0800 4000          cmp.b     _OSPrioCur.L,D0
0000185A  0F0A      
0000185C  6718      4001          beq.s     OS_Sched_5
                    4002   ; #if OS_TASK_PROFILE_EN > 0u
                    4003   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
0000185E  2039 0800 4004          move.l    _OSTCBHighRdy.L,D0
00001862  1028      
00001864  0680 0000 4005          add.l     #58,D0
00001868  003A      
0000186A  2040      4006          move.l    D0,A0
0000186C  5290      4007          addq.l    #1,(A0)
                    4008   ; #endif
                    4009   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
0000186E  52B9 0800 4010          addq.l    #1,_OSCtxSwCtr.L
00001872  0CD6      
                    4011   ; OS_TASK_SW();                          /* Perform a context switch                     */
00001874  4E40      4012          trap      #0
                    4013   OS_Sched_5:
                    4014   ; }
                    4015   ; }
                    4016   ; }
                    4017   ; OS_EXIT_CRITICAL();
00001876  46DF      4018          dc.w      18143
00001878  4E75      4019          rts
                    4020   ; }
                    4021   ; /*
                    4022   ; *********************************************************************************************************
                    4023   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    4024   ; *
                    4025   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    4026   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    4027   ; *
                    4028   ; * Arguments  : none
                    4029   ; *
                    4030   ; * Returns    : none
                    4031   ; *
                    4032   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4033   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    4034   ; *********************************************************************************************************
                    4035   ; */
                    4036   ; static  void  OS_SchedNew (void)
                    4037   ; {
                    4038   @ucos_ii_OS_SchedNew:
0000187A  2F02      4039          move.l    D2,-(A7)
                    4040   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    4041   ; INT8U   y;
                    4042   ; y             = OSUnMapTbl[OSRdyGrp];
0000187C  1039 0800 4043          move.b    _OSRdyGrp.L,D0
00001880  0F0E      
00001882  C0BC 0000 4044          and.l     #255,D0
00001886  00FF      
00001888  41F9 0000 4045          lea       _OSUnMapTbl.L,A0
0000188C  68F6      
0000188E  1430 0800 4046          move.b    0(A0,D0.L),D2
                    4047   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00001892  1002      4048          move.b    D2,D0
00001894  E708      4049          lsl.b     #3,D0
00001896  C4BC 0000 4050          and.l     #255,D2
0000189A  00FF      
0000189C  41F9 0800 4051          lea       _OSRdyTbl.L,A0
000018A0  0F10      
000018A2  1230 2800 4052          move.b    0(A0,D2.L),D1
000018A6  C2BC 0000 4053          and.l     #255,D1
000018AA  00FF      
000018AC  41F9 0000 4054          lea       _OSUnMapTbl.L,A0
000018B0  68F6      
000018B2  D030 1800 4055          add.b     0(A0,D1.L),D0
000018B6  13C0 0800 4056          move.b    D0,_OSPrioHighRdy.L
000018BA  0F0C      
000018BC  241F      4057          move.l    (A7)+,D2
000018BE  4E75      4058          rts
                    4059   ; #else                                            /* We support up to 256 tasks                         */
                    4060   ; INT8U     y;
                    4061   ; OS_PRIO  *ptbl;
                    4062   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    4063   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    4064   ; } else {
                    4065   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    4066   ; }
                    4067   ; ptbl = &OSRdyTbl[y];
                    4068   ; if ((*ptbl & 0xFFu) != 0u) {
                    4069   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    4070   ; } else {
                    4071   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    4072   ; }
                    4073   ; #endif
                    4074   ; }
                    4075   ; /*$PAGE*/
                    4076   ; /*
                    4077   ; *********************************************************************************************************
                    4078   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    4079   ; *
                    4080   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    4081   ; *              (excluding the NUL character).
                    4082   ; *
                    4083   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    4084   ; *
                    4085   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    4086   ; *
                    4087   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4088   ; *              2) The string to check must be less than 255 characters long.
                    4089   ; *********************************************************************************************************
                    4090   ; */
                    4091   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    4092   ; INT8U  OS_StrLen (INT8U *psrc)
                    4093   ; {
                    4094   _OS_StrLen:
000018C0  4E56 0000 4095          link      A6,#0
000018C4  2F02      4096          move.l    D2,-(A7)
                    4097   ; INT8U  len;
                    4098   ; #if OS_ARG_CHK_EN > 0u
                    4099   ; if (psrc == (INT8U *)0) {
                    4100   ; return (0u);
                    4101   ; }
                    4102   ; #endif
                    4103   ; len = 0u;
000018C6  4202      4104          clr.b     D2
                    4105   ; while (*psrc != OS_ASCII_NUL) {
                    4106   OS_StrLen_1:
000018C8  206E 0008 4107          move.l    8(A6),A0
000018CC  1010      4108          move.b    (A0),D0
000018CE  6708      4109          beq.s     OS_StrLen_3
                    4110   ; psrc++;
000018D0  52AE 0008 4111          addq.l    #1,8(A6)
                    4112   ; len++;
000018D4  5202      4113          addq.b    #1,D2
000018D6  60F0      4114          bra       OS_StrLen_1
                    4115   OS_StrLen_3:
                    4116   ; }
                    4117   ; return (len);
000018D8  1002      4118          move.b    D2,D0
000018DA  241F      4119          move.l    (A7)+,D2
000018DC  4E5E      4120          unlk      A6
000018DE  4E75      4121          rts
                    4122   ; }
                    4123   ; #endif
                    4124   ; /*$PAGE*/
                    4125   ; /*
                    4126   ; *********************************************************************************************************
                    4127   ; *                                              IDLE TASK
                    4128   ; *
                    4129   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    4130   ; *              executes because they are ALL waiting for event(s) to occur.
                    4131   ; *
                    4132   ; * Arguments  : none
                    4133   ; *
                    4134   ; * Returns    : none
                    4135   ; *
                    4136   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    4137   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    4138   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    4139   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    4140   ; *                 interrupts.
                    4141   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    4142   ; *                 power.
                    4143   ; *********************************************************************************************************
                    4144   ; */
                    4145   ; void  OS_TaskIdle (void *p_arg)
                    4146   ; {
                    4147   _OS_TaskIdle:
000018E0  4E56 0000 4148          link      A6,#0
                    4149   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4150   ; OS_CPU_SR  cpu_sr = 0u;
                    4151   ; #endif
                    4152   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4153   ; for (;;) {
                    4154   OS_TaskIdle_1:
                    4155   ; OS_ENTER_CRITICAL();
000018E4  40E7      4156          dc.w      16615
000018E6  007C      4157          dc.w      124
000018E8  0700      4158          dc.w      1792
                    4159   ; OSIdleCtr++;
000018EA  52B9 0800 4160          addq.l    #1,_OSIdleCtr.L
000018EE  0F1C      
                    4161   ; OS_EXIT_CRITICAL();
000018F0  46DF      4162          dc.w      18143
                    4163   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
000018F2  4EB8 0B0C 4164          jsr       _OSTaskIdleHook
000018F6  60EC      4165          bra       OS_TaskIdle_1
                    4166   ; }
                    4167   ; }
                    4168   ; /*$PAGE*/
                    4169   ; /*
                    4170   ; *********************************************************************************************************
                    4171   ; *                                           STATISTICS TASK
                    4172   ; *
                    4173   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    4174   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    4175   ; *              CPU usage is determined by:
                    4176   ; *
                    4177   ; *                                          OSIdleCtr
                    4178   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    4179   ; *                                         OSIdleCtrMax
                    4180   ; *
                    4181   ; * Arguments  : parg     this pointer is not used at this time.
                    4182   ; *
                    4183   ; * Returns    : none
                    4184   ; *
                    4185   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    4186   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    4187   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    4188   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    4189   ; *                 maximum value for the idle counter.
                    4190   ; *********************************************************************************************************
                    4191   ; */
                    4192   ; #if OS_TASK_STAT_EN > 0u
                    4193   ; void  OS_TaskStat (void *p_arg)
                    4194   ; {
                    4195   _OS_TaskStat:
000018F8  4E56 0000 4196          link      A6,#0
000018FC  2F0A      4197          move.l    A2,-(A7)
000018FE  45F9 0800 4198          lea       _OSIdleCtrMax.L,A2
00001902  0DFC      
                    4199   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4200   ; OS_CPU_SR  cpu_sr = 0u;
                    4201   ; #endif
                    4202   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4203   ; while (OSStatRdy == OS_FALSE) {
                    4204   OS_TaskStat_1:
00001904  1039 0800 4205          move.b    _OSStatRdy.L,D0
00001908  0E04      
0000190A  660E      4206          bne.s     OS_TaskStat_3
                    4207   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
0000190C  4878 0014 4208          pea       20
00001910  4EB9 0000 4209          jsr       _OSTimeDly
00001914  5012      
00001916  584F      4210          addq.w    #4,A7
00001918  60EA      4211          bra       OS_TaskStat_1
                    4212   OS_TaskStat_3:
                    4213   ; }
                    4214   ; OSIdleCtrMax /= 100uL;
0000191A  2F12      4215          move.l    (A2),-(A7)
0000191C  4878 0064 4216          pea       100
00001920  4EB9 0000 4217          jsr       ULDIV
00001924  5EDA      
00001926  2497      4218          move.l    (A7),(A2)
00001928  504F      4219          addq.w    #8,A7
                    4220   ; if (OSIdleCtrMax == 0uL) {
0000192A  2012      4221          move.l    (A2),D0
0000192C  6618      4222          bne.s     OS_TaskStat_4
                    4223   ; OSCPUUsage = 0u;
0000192E  4239 0800 4224          clr.b     _OSCPUUsage.L
00001932  0DFA      
                    4225   ; #if OS_TASK_SUSPEND_EN > 0u
                    4226   ; (void)OSTaskSuspend(OS_PRIO_SELF);
00001934  4878 00FF 4227          pea       255
00001938  4EB9 0000 4228          jsr       _OSTaskSuspend
0000193C  4D8A      
0000193E  584F      4229          addq.w    #4,A7
00001940  C0BC 0000 4230          and.l     #255,D0
00001944  00FF      
                    4231   OS_TaskStat_4:
                    4232   ; #else
                    4233   ; for (;;) {
                    4234   ; OSTimeDly(OS_TICKS_PER_SEC);
                    4235   ; }
                    4236   ; #endif
                    4237   ; }
                    4238   ; OS_ENTER_CRITICAL();
00001946  40E7      4239          dc.w      16615
00001948  007C      4240          dc.w      124
0000194A  0700      4241          dc.w      1792
                    4242   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
0000194C  2F12      4243          move.l    (A2),-(A7)
0000194E  4878 0064 4244          pea       100
00001952  4EB9 0000 4245          jsr       ULMUL
00001956  5E3A      
00001958  2017      4246          move.l    (A7),D0
0000195A  504F      4247          addq.w    #8,A7
0000195C  23C0 0800 4248          move.l    D0,_OSIdleCtr.L
00001960  0F1C      
                    4249   ; OS_EXIT_CRITICAL();
00001962  46DF      4250          dc.w      18143
                    4251   ; for (;;) {
                    4252   OS_TaskStat_6:
                    4253   ; OS_ENTER_CRITICAL();
00001964  40E7      4254          dc.w      16615
00001966  007C      4255          dc.w      124
00001968  0700      4256          dc.w      1792
                    4257   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0000196A  23F9 0800 4258          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
0000196E  0F1C 0800 
00001972  0E00      
                    4259   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001974  42B9 0800 4260          clr.l     _OSIdleCtr.L
00001978  0F1C      
                    4261   ; OS_EXIT_CRITICAL();
0000197A  46DF      4262          dc.w      18143
                    4263   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
0000197C  7064      4264          moveq     #100,D0
0000197E  2F39 0800 4265          move.l    _OSIdleCtrRun.L,-(A7)
00001982  0E00      
00001984  2F12      4266          move.l    (A2),-(A7)
00001986  4EB9 0000 4267          jsr       ULDIV
0000198A  5EDA      
0000198C  2217      4268          move.l    (A7),D1
0000198E  504F      4269          addq.w    #8,A7
00001990  9081      4270          sub.l     D1,D0
00001992  13C0 0800 4271          move.b    D0,_OSCPUUsage.L
00001996  0DFA      
                    4272   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
00001998  4EB8 0B16 4273          jsr       _OSTaskStatHook
                    4274   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4275   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
0000199C  4EB9 0000 4276          jsr       _OS_TaskStatStkChk
000019A0  19B0      
                    4277   ; #endif
                    4278   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
000019A2  4878 000A 4279          pea       10
000019A6  4EB9 0000 4280          jsr       _OSTimeDly
000019AA  5012      
000019AC  584F      4281          addq.w    #4,A7
000019AE  60B4      4282          bra       OS_TaskStat_6
                    4283   ; }
                    4284   ; }
                    4285   ; #endif
                    4286   ; /*$PAGE*/
                    4287   ; /*
                    4288   ; *********************************************************************************************************
                    4289   ; *                                        CHECK ALL TASK STACKS
                    4290   ; *
                    4291   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    4292   ; *
                    4293   ; * Arguments  : none
                    4294   ; *
                    4295   ; * Returns    : none
                    4296   ; *********************************************************************************************************
                    4297   ; */
                    4298   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4299   ; void  OS_TaskStatStkChk (void)
                    4300   ; {
                    4301   _OS_TaskStatStkChk:
000019B0  4E56 FFF4 4302          link      A6,#-12
000019B4  48E7 3000 4303          movem.l   D2/D3,-(A7)
                    4304   ; OS_TCB      *ptcb;
                    4305   ; OS_STK_DATA  stk_data;
                    4306   ; INT8U        err;
                    4307   ; INT8U        prio;
                    4308   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
000019B8  4203      4309          clr.b     D3
                    4310   OS_TaskStatStkChk_1:
000019BA  0C03 003F 4311          cmp.b     #63,D3
000019BE  6200 0068 4312          bhi       OS_TaskStatStkChk_3
                    4313   ; err = OSTaskStkChk(prio, &stk_data);
000019C2  486E FFF6 4314          pea       -10(A6)
000019C6  C6BC 0000 4315          and.l     #255,D3
000019CA  00FF      
000019CC  2F03      4316          move.l    D3,-(A7)
000019CE  4EB9 0000 4317          jsr       _OSTaskStkChk
000019D2  4CD2      
000019D4  504F      4318          addq.w    #8,A7
000019D6  1D40 FFFF 4319          move.b    D0,-1(A6)
                    4320   ; if (err == OS_ERR_NONE) {
000019DA  102E FFFF 4321          move.b    -1(A6),D0
000019DE  6600 0044 4322          bne       OS_TaskStatStkChk_8
                    4323   ; ptcb = OSTCBPrioTbl[prio];
000019E2  C6BC 0000 4324          and.l     #255,D3
000019E6  00FF      
000019E8  2003      4325          move.l    D3,D0
000019EA  E588      4326          lsl.l     #2,D0
000019EC  41F9 0800 4327          lea       _OSTCBPrioTbl.L,A0
000019F0  1030      
000019F2  2430 0800 4328          move.l    0(A0,D0.L),D2
                    4329   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000019F6  4A82      4330          tst.l     D2
000019F8  672A      4331          beq.s     OS_TaskStatStkChk_8
                    4332   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000019FA  0C82 0000 4333          cmp.l     #1,D2
000019FE  0001      
00001A00  6722      4334          beq.s     OS_TaskStatStkChk_8
                    4335   ; #if OS_TASK_PROFILE_EN > 0u
                    4336   ; #if OS_STK_GROWTH == 1u
                    4337   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001A02  2042      4338          move.l    D2,A0
00001A04  2028 0008 4339          move.l    8(A0),D0
00001A08  2042      4340          move.l    D2,A0
00001A0A  2228 000C 4341          move.l    12(A0),D1
00001A0E  E389      4342          lsl.l     #1,D1
00001A10  D081      4343          add.l     D1,D0
00001A12  2042      4344          move.l    D2,A0
00001A14  2140 0046 4345          move.l    D0,70(A0)
                    4346   ; #else
                    4347   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4348   ; #endif
                    4349   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
00001A18  41EE FFF6 4350          lea       -10(A6),A0
00001A1C  2242      4351          move.l    D2,A1
00001A1E  2368 0004 4352          move.l    4(A0),74(A1)
00001A22  004A      
                    4353   OS_TaskStatStkChk_8:
00001A24  5203      4354          addq.b    #1,D3
00001A26  6092      4355          bra       OS_TaskStatStkChk_1
                    4356   OS_TaskStatStkChk_3:
00001A28  4CDF 000C 4357          movem.l   (A7)+,D2/D3
00001A2C  4E5E      4358          unlk      A6
00001A2E  4E75      4359          rts
                    4360   ; #endif
                    4361   ; }
                    4362   ; }
                    4363   ; }
                    4364   ; }
                    4365   ; }
                    4366   ; #endif
                    4367   ; /*$PAGE*/
                    4368   ; /*
                    4369   ; *********************************************************************************************************
                    4370   ; *                                           INITIALIZE TCB
                    4371   ; *
                    4372   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4373   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4374   ; *
                    4375   ; * Arguments  : prio          is the priority of the task being created
                    4376   ; *
                    4377   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4378   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4379   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4380   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4381   ; *                            specific.
                    4382   ; *
                    4383   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4384   ; *                            'OSTaskCreate()'.
                    4385   ; *
                    4386   ; *              id            is the task's ID (0..65535)
                    4387   ; *
                    4388   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4389   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4390   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4391   ; *                            units are established by the #define constant OS_STK which is CPU
                    4392   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4393   ; *
                    4394   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4395   ; *                            control block.  This allows you to store the contents of floating-point
                    4396   ; *                            registers, MMU registers or anything else you could find useful during a
                    4397   ; *                            context switch.  You can even assign a name to each task and store this name
                    4398   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4399   ; *
                    4400   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4401   ; *                            0 if called from 'OSTaskCreate()'.
                    4402   ; *
                    4403   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4404   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4405   ; *                                  be created.
                    4406   ; *
                    4407   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4408   ; *********************************************************************************************************
                    4409   ; */
                    4410   ; INT8U  OS_TCBInit (INT8U    prio,
                    4411   ; OS_STK  *ptos,
                    4412   ; OS_STK  *pbos,
                    4413   ; INT16U   id,
                    4414   ; INT32U   stk_size,
                    4415   ; void    *pext,
                    4416   ; INT16U   opt)
                    4417   ; {
                    4418   _OS_TCBInit:
00001A30  4E56 0000 4419          link      A6,#0
00001A34  48E7 3820 4420          movem.l   D2/D3/D4/A2,-(A7)
00001A38  45F9 0800 4421          lea       _OSTCBList.L,A2
00001A3C  102C      
00001A3E  182E 000B 4422          move.b    11(A6),D4
00001A42  C8BC 0000 4423          and.l     #255,D4
00001A46  00FF      
                    4424   ; OS_TCB    *ptcb;
                    4425   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4426   ; OS_CPU_SR  cpu_sr = 0u;
                    4427   ; #endif
                    4428   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4429   ; INT8U      i;
                    4430   ; #endif
                    4431   ; OS_ENTER_CRITICAL();
00001A48  40E7      4432          dc.w      16615
00001A4A  007C      4433          dc.w      124
00001A4C  0700      4434          dc.w      1792
                    4435   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001A4E  2439 0800 4436          move.l    _OSTCBFreeList.L,D2
00001A52  1024      
                    4437   ; if (ptcb != (OS_TCB *)0) {
00001A54  4A82      4438          tst.l     D2
00001A56  6700 017A 4439          beq       OS_TCBInit_1
                    4440   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00001A5A  2042      4441          move.l    D2,A0
00001A5C  23E8 0014 4442          move.l    20(A0),_OSTCBFreeList.L
00001A60  0800 1024 
                    4443   ; OS_EXIT_CRITICAL();
00001A64  46DF      4444          dc.w      18143
                    4445   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00001A66  2042      4446          move.l    D2,A0
00001A68  20AE 000C 4447          move.l    12(A6),(A0)
                    4448   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00001A6C  2042      4449          move.l    D2,A0
00001A6E  1144 0034 4450          move.b    D4,52(A0)
                    4451   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001A72  2042      4452          move.l    D2,A0
00001A74  4228 0032 4453          clr.b     50(A0)
                    4454   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00001A78  2042      4455          move.l    D2,A0
00001A7A  4228 0033 4456          clr.b     51(A0)
                    4457   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001A7E  2042      4458          move.l    D2,A0
00001A80  42A8 002E 4459          clr.l     46(A0)
                    4460   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4461   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001A84  2042      4462          move.l    D2,A0
00001A86  216E 001C 4463          move.l    28(A6),4(A0)
00001A8A  0004      
                    4464   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00001A8C  2042      4465          move.l    D2,A0
00001A8E  216E 0018 4466          move.l    24(A6),12(A0)
00001A92  000C      
                    4467   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001A94  2042      4468          move.l    D2,A0
00001A96  216E 0010 4469          move.l    16(A6),8(A0)
00001A9A  0008      
                    4470   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00001A9C  2042      4471          move.l    D2,A0
00001A9E  316E 0022 4472          move.w    34(A6),16(A0)
00001AA2  0010      
                    4473   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001AA4  2042      4474          move.l    D2,A0
00001AA6  316E 0016 4475          move.w    22(A6),18(A0)
00001AAA  0012      
                    4476   ; #else
                    4477   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4478   ; stk_size                 = stk_size;
                    4479   ; pbos                     = pbos;
                    4480   ; opt                      = opt;
                    4481   ; id                       = id;
                    4482   ; #endif
                    4483   ; #if OS_TASK_DEL_EN > 0u
                    4484   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
00001AAC  2042      4485          move.l    D2,A0
00001AAE  4228 0039 4486          clr.b     57(A0)
                    4487   ; #endif
                    4488   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4489   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001AB2  1004      4490          move.b    D4,D0
00001AB4  E608      4491          lsr.b     #3,D0
00001AB6  2042      4492          move.l    D2,A0
00001AB8  1140 0036 4493          move.b    D0,54(A0)
                    4494   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00001ABC  1004      4495          move.b    D4,D0
00001ABE  C03C 0007 4496          and.b     #7,D0
00001AC2  2042      4497          move.l    D2,A0
00001AC4  1140 0035 4498          move.b    D0,53(A0)
                    4499   ; #else                                                             /* Pre-compute X, Y                  */
                    4500   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4501   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4502   ; #endif
                    4503   ; /* Pre-compute BitX and BitY         */
                    4504   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
00001AC8  7001      4505          moveq     #1,D0
00001ACA  2042      4506          move.l    D2,A0
00001ACC  1228 0036 4507          move.b    54(A0),D1
00001AD0  C2BC 0000 4508          and.l     #255,D1
00001AD4  00FF      
00001AD6  E3A8      4509          lsl.l     D1,D0
00001AD8  2042      4510          move.l    D2,A0
00001ADA  1140 0038 4511          move.b    D0,56(A0)
                    4512   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00001ADE  7001      4513          moveq     #1,D0
00001AE0  2042      4514          move.l    D2,A0
00001AE2  1228 0035 4515          move.b    53(A0),D1
00001AE6  C2BC 0000 4516          and.l     #255,D1
00001AEA  00FF      
00001AEC  E3A8      4517          lsl.l     D1,D0
00001AEE  2042      4518          move.l    D2,A0
00001AF0  1140 0037 4519          move.b    D0,55(A0)
                    4520   ; #if (OS_EVENT_EN)
                    4521   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
00001AF4  2042      4522          move.l    D2,A0
00001AF6  42A8 001C 4523          clr.l     28(A0)
                    4524   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4525   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
00001AFA  2042      4526          move.l    D2,A0
00001AFC  42A8 0020 4527          clr.l     32(A0)
                    4528   ; #endif
                    4529   ; #endif
                    4530   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4531   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00001B00  2042      4532          move.l    D2,A0
00001B02  42A8 0028 4533          clr.l     40(A0)
                    4534   ; #endif
                    4535   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4536   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00001B06  2042      4537          move.l    D2,A0
00001B08  42A8 0024 4538          clr.l     36(A0)
                    4539   ; #endif
                    4540   ; #if OS_TASK_PROFILE_EN > 0u
                    4541   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00001B0C  2042      4542          move.l    D2,A0
00001B0E  42A8 003A 4543          clr.l     58(A0)
                    4544   ; ptcb->OSTCBCyclesStart = 0uL;
00001B12  2042      4545          move.l    D2,A0
00001B14  42A8 0042 4546          clr.l     66(A0)
                    4547   ; ptcb->OSTCBCyclesTot   = 0uL;
00001B18  2042      4548          move.l    D2,A0
00001B1A  42A8 003E 4549          clr.l     62(A0)
                    4550   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
00001B1E  2042      4551          move.l    D2,A0
00001B20  42A8 0046 4552          clr.l     70(A0)
                    4553   ; ptcb->OSTCBStkUsed     = 0uL;
00001B24  2042      4554          move.l    D2,A0
00001B26  42A8 004A 4555          clr.l     74(A0)
                    4556   ; #endif
                    4557   ; #if OS_TASK_NAME_EN > 0u
                    4558   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
00001B2A  41F9 0000 4559          lea       @ucos_ii_1.L,A0
00001B2E  68A4      
00001B30  2242      4560          move.l    D2,A1
00001B32  2348 004E 4561          move.l    A0,78(A1)
                    4562   ; #endif
                    4563   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4564   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00001B36  4203      4565          clr.b     D3
                    4566   OS_TCBInit_3:
00001B38  0C03 0001 4567          cmp.b     #1,D3
00001B3C  6416      4568          bhs.s     OS_TCBInit_5
                    4569   ; ptcb->OSTCBRegTbl[i] = 0u;
00001B3E  2042      4570          move.l    D2,A0
00001B40  C6BC 0000 4571          and.l     #255,D3
00001B44  00FF      
00001B46  2003      4572          move.l    D3,D0
00001B48  E588      4573          lsl.l     #2,D0
00001B4A  D1C0      4574          add.l     D0,A0
00001B4C  42A8 0052 4575          clr.l     82(A0)
00001B50  5203      4576          addq.b    #1,D3
00001B52  60E4      4577          bra       OS_TCBInit_3
                    4578   OS_TCBInit_5:
                    4579   ; }
                    4580   ; #endif
                    4581   ; OSTCBInitHook(ptcb);
00001B54  2F02      4582          move.l    D2,-(A7)
00001B56  4EB8 0B44 4583          jsr       _OSTCBInitHook
00001B5A  584F      4584          addq.w    #4,A7
                    4585   ; OS_ENTER_CRITICAL();
00001B5C  40E7      4586          dc.w      16615
00001B5E  007C      4587          dc.w      124
00001B60  0700      4588          dc.w      1792
                    4589   ; OSTCBPrioTbl[prio] = ptcb;
00001B62  C8BC 0000 4590          and.l     #255,D4
00001B66  00FF      
00001B68  2004      4591          move.l    D4,D0
00001B6A  E588      4592          lsl.l     #2,D0
00001B6C  41F9 0800 4593          lea       _OSTCBPrioTbl.L,A0
00001B70  1030      
00001B72  2182 0800 4594          move.l    D2,0(A0,D0.L)
                    4595   ; OS_EXIT_CRITICAL();
00001B76  46DF      4596          dc.w      18143
                    4597   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00001B78  2F02      4598          move.l    D2,-(A7)
00001B7A  4EB8 0AFA 4599          jsr       _OSTaskCreateHook
00001B7E  584F      4600          addq.w    #4,A7
                    4601   ; OS_ENTER_CRITICAL();
00001B80  40E7      4602          dc.w      16615
00001B82  007C      4603          dc.w      124
00001B84  0700      4604          dc.w      1792
                    4605   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00001B86  2042      4606          move.l    D2,A0
00001B88  2152 0014 4607          move.l    (A2),20(A0)
                    4608   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
00001B8C  2042      4609          move.l    D2,A0
00001B8E  42A8 0018 4610          clr.l     24(A0)
                    4611   ; if (OSTCBList != (OS_TCB *)0) {
00001B92  2012      4612          move.l    (A2),D0
00001B94  6706      4613          beq.s     OS_TCBInit_6
                    4614   ; OSTCBList->OSTCBPrev = ptcb;
00001B96  2052      4615          move.l    (A2),A0
00001B98  2142 0018 4616          move.l    D2,24(A0)
                    4617   OS_TCBInit_6:
                    4618   ; }
                    4619   ; OSTCBList               = ptcb;
00001B9C  2482      4620          move.l    D2,(A2)
                    4621   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001B9E  2042      4622          move.l    D2,A0
00001BA0  1028 0038 4623          move.b    56(A0),D0
00001BA4  8139 0800 4624          or.b      D0,_OSRdyGrp.L
00001BA8  0F0E      
                    4625   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00001BAA  2042      4626          move.l    D2,A0
00001BAC  1028 0036 4627          move.b    54(A0),D0
00001BB0  C0BC 0000 4628          and.l     #255,D0
00001BB4  00FF      
00001BB6  41F9 0800 4629          lea       _OSRdyTbl.L,A0
00001BBA  0F10      
00001BBC  2242      4630          move.l    D2,A1
00001BBE  1229 0037 4631          move.b    55(A1),D1
00001BC2  8330 0800 4632          or.b      D1,0(A0,D0.L)
                    4633   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
00001BC6  5239 0800 4634          addq.b    #1,_OSTaskCtr.L
00001BCA  0F1A      
                    4635   ; OS_EXIT_CRITICAL();
00001BCC  46DF      4636          dc.w      18143
                    4637   ; return (OS_ERR_NONE);
00001BCE  4200      4638          clr.b     D0
00001BD0  6004      4639          bra.s     OS_TCBInit_8
                    4640   OS_TCBInit_1:
                    4641   ; }
                    4642   ; OS_EXIT_CRITICAL();
00001BD2  46DF      4643          dc.w      18143
                    4644   ; return (OS_ERR_TASK_NO_MORE_TCB);
00001BD4  7042      4645          moveq     #66,D0
                    4646   OS_TCBInit_8:
00001BD6  4CDF 041C 4647          movem.l   (A7)+,D2/D3/D4/A2
00001BDA  4E5E      4648          unlk      A6
00001BDC  4E75      4649          rts
                    4650   ; /*
                    4651   ; *********************************************************************************************************
                    4652   ; *                                                uC/OS-II
                    4653   ; *                                          The Real-Time Kernel
                    4654   ; *                                         EVENT FLAG  MANAGEMENT
                    4655   ; *
                    4656   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4657   ; *                                           All Rights Reserved
                    4658   ; *
                    4659   ; * File    : OS_FLAG.C
                    4660   ; * By      : Jean J. Labrosse
                    4661   ; * Version : V2.92.07
                    4662   ; *
                    4663   ; * LICENSING TERMS:
                    4664   ; * ---------------
                    4665   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4666   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4667   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4668   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4669   ; * licensing fee.
                    4670   ; *********************************************************************************************************
                    4671   ; */
                    4672   ; #define  MICRIUM_SOURCE
                    4673   ; #ifndef  OS_MASTER_FILE
                    4674   ; #include <ucos_ii.h>
                    4675   ; #endif
                    4676   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4677   ; /*
                    4678   ; *********************************************************************************************************
                    4679   ; *                                          LOCAL PROTOTYPES
                    4680   ; *********************************************************************************************************
                    4681   ; */
                    4682   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4683   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4684   ; /*$PAGE*/
                    4685   ; /*
                    4686   ; *********************************************************************************************************
                    4687   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4688   ; *
                    4689   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4690   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4691   ; *              bits to be set/cleared.
                    4692   ; *
                    4693   ; *              This call does not block if the desired flags are not present.
                    4694   ; *
                    4695   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4696   ; *
                    4697   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4698   ; *                            The bits you want are specified by setting the corresponding bits in
                    4699   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4700   ; *                            'flags' would contain 0x03.
                    4701   ; *
                    4702   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4703   ; *                            to be set/cleared.
                    4704   ; *                            You can specify the following argument:
                    4705   ; *
                    4706   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4707   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4708   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4709   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4710   ; *
                    4711   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4712   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4713   ; *                                  the flags that are present, set 'wait_type' to:
                    4714   ; *
                    4715   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4716   ; *
                    4717   ; *              perr          is a pointer to an error code and can be:
                    4718   ; *                            OS_ERR_NONE               No error
                    4719   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4720   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4721   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4722   ; *                                                      group handle.
                    4723   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4724   ; *                                                      available.
                    4725   ; *
                    4726   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4727   ; *              occurred.
                    4728   ; *
                    4729   ; * Called from: Task or ISR
                    4730   ; *
                    4731   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4732   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4733   ; *                 event flags.
                    4734   ; *********************************************************************************************************
                    4735   ; */
                    4736   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4737   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4738   ; OS_FLAGS      flags,
                    4739   ; INT8U         wait_type,
                    4740   ; INT8U        *perr)
                    4741   ; {
                    4742   _OSFlagAccept:
00001BDE  4E56 FFFC 4743          link      A6,#-4
00001BE2  48E7 3F00 4744          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
00001BE6  262E 0008 4745          move.l    8(A6),D3
00001BEA  282E 0014 4746          move.l    20(A6),D4
00001BEE  3A2E 000E 4747          move.w    14(A6),D5
00001BF2  CABC 0000 4748          and.l     #65535,D5
00001BF6  FFFF      
00001BF8  1E2E 0013 4749          move.b    19(A6),D7
00001BFC  CEBC 0000 4750          and.l     #255,D7
00001C00  00FF      
                    4751   ; OS_FLAGS      flags_rdy;
                    4752   ; INT8U         result;
                    4753   ; BOOLEAN       consume;
                    4754   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4755   ; OS_CPU_SR     cpu_sr = 0u;
                    4756   ; #endif
                    4757   ; #ifdef OS_SAFETY_CRITICAL
                    4758   ; if (perr == (INT8U *)0) {
                    4759   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4760   ; return ((OS_FLAGS)0);
                    4761   ; }
                    4762   ; #endif
                    4763   ; #if OS_ARG_CHK_EN > 0u
                    4764   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4765   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4766   ; return ((OS_FLAGS)0);
                    4767   ; }
                    4768   ; #endif
                    4769   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001C02  2043      4770          move.l    D3,A0
00001C04  1010      4771          move.b    (A0),D0
00001C06  0C00 0005 4772          cmp.b     #5,D0
00001C0A  670C      4773          beq.s     OSFlagAccept_1
                    4774   ; *perr = OS_ERR_EVENT_TYPE;
00001C0C  2044      4775          move.l    D4,A0
00001C0E  10BC 0001 4776          move.b    #1,(A0)
                    4777   ; return ((OS_FLAGS)0);
00001C12  4240      4778          clr.w     D0
00001C14  6000 0100 4779          bra       OSFlagAccept_3
                    4780   OSFlagAccept_1:
                    4781   ; }
                    4782   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001C18  1007      4783          move.b    D7,D0
00001C1A  C03C 0080 4784          and.b     #128,D0
00001C1E  1D40 FFFF 4785          move.b    D0,-1(A6)
                    4786   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001C22  102E FFFF 4787          move.b    -1(A6),D0
00001C26  6708      4788          beq.s     OSFlagAccept_4
                    4789   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
00001C28  CE3C 007F 4790          and.b     #127,D7
                    4791   ; consume    = OS_TRUE;
00001C2C  7C01      4792          moveq     #1,D6
00001C2E  6002      4793          bra.s     OSFlagAccept_5
                    4794   OSFlagAccept_4:
                    4795   ; } else {
                    4796   ; consume    = OS_FALSE;
00001C30  4206      4797          clr.b     D6
                    4798   OSFlagAccept_5:
                    4799   ; }
                    4800   ; /*$PAGE*/
                    4801   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
00001C32  2044      4802          move.l    D4,A0
00001C34  4210      4803          clr.b     (A0)
                    4804   ; OS_ENTER_CRITICAL();
00001C36  40E7      4805          dc.w      16615
00001C38  007C      4806          dc.w      124
00001C3A  0700      4807          dc.w      1792
                    4808   ; switch (wait_type) {
00001C3C  CEBC 0000 4809          and.l     #255,D7
00001C40  00FF      
00001C42  2007      4810          move.l    D7,D0
00001C44  0C80 0000 4811          cmp.l     #4,D0
00001C48  0004      
00001C4A  6400 00BE 4812          bhs       OSFlagAccept_6
00001C4E  E380      4813          asl.l     #1,D0
00001C50  303B 0806 4814          move.w    OSFlagAccept_8(PC,D0.L),D0
00001C54  4EFB 0002 4815          jmp       OSFlagAccept_8(PC,D0.W)
                    4816   OSFlagAccept_8:
00001C58  0060      4817          dc.w      OSFlagAccept_11-OSFlagAccept_8
00001C5A  008A      4818          dc.w      OSFlagAccept_12-OSFlagAccept_8
00001C5C  0008      4819          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001C5E  0034      4820          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4821   OSFlagAccept_9:
                    4822   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4823   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001C60  2043      4824          move.l    D3,A0
00001C62  3028 0006 4825          move.w    6(A0),D0
00001C66  C045      4826          and.w     D5,D0
00001C68  3400      4827          move.w    D0,D2
                    4828   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001C6A  B445      4829          cmp.w     D5,D2
00001C6C  6612      4830          bne.s     OSFlagAccept_14
                    4831   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001C6E  0C06 0001 4832          cmp.b     #1,D6
00001C72  660A      4833          bne.s     OSFlagAccept_16
                    4834   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001C74  2043      4835          move.l    D3,A0
00001C76  3002      4836          move.w    D2,D0
00001C78  4640      4837          not.w     D0
00001C7A  C168 0006 4838          and.w     D0,6(A0)
                    4839   OSFlagAccept_16:
00001C7E  6006      4840          bra.s     OSFlagAccept_15
                    4841   OSFlagAccept_14:
                    4842   ; }
                    4843   ; } else {
                    4844   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001C80  2044      4845          move.l    D4,A0
00001C82  10BC 0070 4846          move.b    #112,(A0)
                    4847   OSFlagAccept_15:
                    4848   ; }
                    4849   ; OS_EXIT_CRITICAL();
00001C86  46DF      4850          dc.w      18143
                    4851   ; break;
00001C88  6000 008A 4852          bra       OSFlagAccept_7
                    4853   OSFlagAccept_10:
                    4854   ; case OS_FLAG_WAIT_SET_ANY:
                    4855   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001C8C  2043      4856          move.l    D3,A0
00001C8E  3028 0006 4857          move.w    6(A0),D0
00001C92  C045      4858          and.w     D5,D0
00001C94  3400      4859          move.w    D0,D2
                    4860   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001C96  4A42      4861          tst.w     D2
00001C98  6712      4862          beq.s     OSFlagAccept_18
                    4863   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001C9A  0C06 0001 4864          cmp.b     #1,D6
00001C9E  660A      4865          bne.s     OSFlagAccept_20
                    4866   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001CA0  2043      4867          move.l    D3,A0
00001CA2  3002      4868          move.w    D2,D0
00001CA4  4640      4869          not.w     D0
00001CA6  C168 0006 4870          and.w     D0,6(A0)
                    4871   OSFlagAccept_20:
00001CAA  6006      4872          bra.s     OSFlagAccept_19
                    4873   OSFlagAccept_18:
                    4874   ; }
                    4875   ; } else {
                    4876   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001CAC  2044      4877          move.l    D4,A0
00001CAE  10BC 0070 4878          move.b    #112,(A0)
                    4879   OSFlagAccept_19:
                    4880   ; }
                    4881   ; OS_EXIT_CRITICAL();
00001CB2  46DF      4882          dc.w      18143
                    4883   ; break;
00001CB4  6000 005E 4884          bra       OSFlagAccept_7
                    4885   OSFlagAccept_11:
                    4886   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4887   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4888   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001CB8  2043      4889          move.l    D3,A0
00001CBA  3028 0006 4890          move.w    6(A0),D0
00001CBE  4640      4891          not.w     D0
00001CC0  C045      4892          and.w     D5,D0
00001CC2  3400      4893          move.w    D0,D2
                    4894   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001CC4  B445      4895          cmp.w     D5,D2
00001CC6  660E      4896          bne.s     OSFlagAccept_22
                    4897   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001CC8  0C06 0001 4898          cmp.b     #1,D6
00001CCC  6606      4899          bne.s     OSFlagAccept_24
                    4900   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001CCE  2043      4901          move.l    D3,A0
00001CD0  8568 0006 4902          or.w      D2,6(A0)
                    4903   OSFlagAccept_24:
00001CD4  6006      4904          bra.s     OSFlagAccept_23
                    4905   OSFlagAccept_22:
                    4906   ; }
                    4907   ; } else {
                    4908   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001CD6  2044      4909          move.l    D4,A0
00001CD8  10BC 0070 4910          move.b    #112,(A0)
                    4911   OSFlagAccept_23:
                    4912   ; }
                    4913   ; OS_EXIT_CRITICAL();
00001CDC  46DF      4914          dc.w      18143
                    4915   ; break;
00001CDE  6000 0034 4916          bra       OSFlagAccept_7
                    4917   OSFlagAccept_12:
                    4918   ; case OS_FLAG_WAIT_CLR_ANY:
                    4919   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001CE2  2043      4920          move.l    D3,A0
00001CE4  3028 0006 4921          move.w    6(A0),D0
00001CE8  4640      4922          not.w     D0
00001CEA  C045      4923          and.w     D5,D0
00001CEC  3400      4924          move.w    D0,D2
                    4925   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001CEE  4A42      4926          tst.w     D2
00001CF0  670E      4927          beq.s     OSFlagAccept_26
                    4928   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001CF2  0C06 0001 4929          cmp.b     #1,D6
00001CF6  6606      4930          bne.s     OSFlagAccept_28
                    4931   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001CF8  2043      4932          move.l    D3,A0
00001CFA  8568 0006 4933          or.w      D2,6(A0)
                    4934   OSFlagAccept_28:
00001CFE  6006      4935          bra.s     OSFlagAccept_27
                    4936   OSFlagAccept_26:
                    4937   ; }
                    4938   ; } else {
                    4939   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001D00  2044      4940          move.l    D4,A0
00001D02  10BC 0070 4941          move.b    #112,(A0)
                    4942   OSFlagAccept_27:
                    4943   ; }
                    4944   ; OS_EXIT_CRITICAL();
00001D06  46DF      4945          dc.w      18143
                    4946   ; break;
00001D08  600A      4947          bra.s     OSFlagAccept_7
                    4948   OSFlagAccept_6:
                    4949   ; #endif
                    4950   ; default:
                    4951   ; OS_EXIT_CRITICAL();
00001D0A  46DF      4952          dc.w      18143
                    4953   ; flags_rdy = (OS_FLAGS)0;
00001D0C  4242      4954          clr.w     D2
                    4955   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
00001D0E  2044      4956          move.l    D4,A0
00001D10  10BC 006F 4957          move.b    #111,(A0)
                    4958   ; break;
                    4959   OSFlagAccept_7:
                    4960   ; }
                    4961   ; return (flags_rdy);
00001D14  3002      4962          move.w    D2,D0
                    4963   OSFlagAccept_3:
00001D16  4CDF 00FC 4964          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
00001D1A  4E5E      4965          unlk      A6
00001D1C  4E75      4966          rts
                    4967   ; }
                    4968   ; #endif
                    4969   ; /*$PAGE*/
                    4970   ; /*
                    4971   ; *********************************************************************************************************
                    4972   ; *                                        CREATE AN EVENT FLAG
                    4973   ; *
                    4974   ; * Description: This function is called to create an event flag group.
                    4975   ; *
                    4976   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    4977   ; *
                    4978   ; *              perr          is a pointer to an error code which will be returned to your application:
                    4979   ; *                               OS_ERR_NONE               if the call was successful.
                    4980   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    4981   ; *                                                         ISR.
                    4982   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    4983   ; *
                    4984   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    4985   ; *
                    4986   ; * Called from: Task ONLY
                    4987   ; *********************************************************************************************************
                    4988   ; */
                    4989   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    4990   ; INT8U    *perr)
                    4991   ; {
                    4992   _OSFlagCreate:
00001D1E  4E56 0000 4993          link      A6,#0
00001D22  48E7 3020 4994          movem.l   D2/D3/A2,-(A7)
00001D26  45F9 0800 4995          lea       _OSFlagFreeList.L,A2
00001D2A  0DF6      
00001D2C  262E 000C 4996          move.l    12(A6),D3
                    4997   ; OS_FLAG_GRP *pgrp;
                    4998   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    4999   ; OS_CPU_SR    cpu_sr = 0u;
                    5000   ; #endif
                    5001   ; #ifdef OS_SAFETY_CRITICAL
                    5002   ; if (perr == (INT8U *)0) {
                    5003   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5004   ; return ((OS_FLAG_GRP *)0);
                    5005   ; }
                    5006   ; #endif
                    5007   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    5008   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    5009   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5010   ; return ((OS_FLAG_GRP *)0);
                    5011   ; }
                    5012   ; #endif
                    5013   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001D30  1039 0800 5014          move.b    _OSIntNesting.L,D0
00001D34  0F06      
00001D36  0C00 0000 5015          cmp.b     #0,D0
00001D3A  630C      5016          bls.s     OSFlagCreate_1
                    5017   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
00001D3C  2043      5018          move.l    D3,A0
00001D3E  10BC 0010 5019          move.b    #16,(A0)
                    5020   ; return ((OS_FLAG_GRP *)0);
00001D42  4280      5021          clr.l     D0
00001D44  6000 0046 5022          bra       OSFlagCreate_3
                    5023   OSFlagCreate_1:
                    5024   ; }
                    5025   ; OS_ENTER_CRITICAL();
00001D48  40E7      5026          dc.w      16615
00001D4A  007C      5027          dc.w      124
00001D4C  0700      5028          dc.w      1792
                    5029   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001D4E  2412      5030          move.l    (A2),D2
                    5031   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001D50  4A82      5032          tst.l     D2
00001D52  672E      5033          beq.s     OSFlagCreate_4
                    5034   ; /* Adjust free list                                */
                    5035   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001D54  2052      5036          move.l    (A2),A0
00001D56  24A8 0002 5037          move.l    2(A0),(A2)
                    5038   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
00001D5A  2042      5039          move.l    D2,A0
00001D5C  10BC 0005 5040          move.b    #5,(A0)
                    5041   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001D60  2042      5042          move.l    D2,A0
00001D62  316E 000A 5043          move.w    10(A6),6(A0)
00001D66  0006      
                    5044   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
00001D68  2042      5045          move.l    D2,A0
00001D6A  42A8 0002 5046          clr.l     2(A0)
                    5047   ; #if OS_FLAG_NAME_EN > 0u
                    5048   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001D6E  41F9 0000 5049          lea       @ucos_ii_1.L,A0
00001D72  68A4      
00001D74  2242      5050          move.l    D2,A1
00001D76  2348 0008 5051          move.l    A0,8(A1)
                    5052   ; #endif
                    5053   ; OS_EXIT_CRITICAL();
00001D7A  46DF      5054          dc.w      18143
                    5055   ; *perr                = OS_ERR_NONE;
00001D7C  2043      5056          move.l    D3,A0
00001D7E  4210      5057          clr.b     (A0)
00001D80  6008      5058          bra.s     OSFlagCreate_5
                    5059   OSFlagCreate_4:
                    5060   ; } else {
                    5061   ; OS_EXIT_CRITICAL();
00001D82  46DF      5062          dc.w      18143
                    5063   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001D84  2043      5064          move.l    D3,A0
00001D86  10BC 0072 5065          move.b    #114,(A0)
                    5066   OSFlagCreate_5:
                    5067   ; }
                    5068   ; return (pgrp);                                  /* Return pointer to event flag group              */
00001D8A  2002      5069          move.l    D2,D0
                    5070   OSFlagCreate_3:
00001D8C  4CDF 040C 5071          movem.l   (A7)+,D2/D3/A2
00001D90  4E5E      5072          unlk      A6
00001D92  4E75      5073          rts
                    5074   ; }
                    5075   ; /*$PAGE*/
                    5076   ; /*
                    5077   ; *********************************************************************************************************
                    5078   ; *                                     DELETE AN EVENT FLAG GROUP
                    5079   ; *
                    5080   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    5081   ; *              group.
                    5082   ; *
                    5083   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5084   ; *
                    5085   ; *              opt           determines delete options as follows:
                    5086   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    5087   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    5088   ; *                                                    waiting.  In this case, all the tasks pending will be
                    5089   ; *                                                    readied.
                    5090   ; *
                    5091   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    5092   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    5093   ; *                                                      deleted
                    5094   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    5095   ; *                                                      an ISR
                    5096   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5097   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    5098   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    5099   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    5100   ; *                                                      group.
                    5101   ; *
                    5102   ; * Returns    : pgrp          upon error
                    5103   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    5104   ; *
                    5105   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    5106   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    5107   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    5108   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    5109   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    5110   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    5111   ; *********************************************************************************************************
                    5112   ; */
                    5113   ; #if OS_FLAG_DEL_EN > 0u
                    5114   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    5115   ; INT8U         opt,
                    5116   ; INT8U        *perr)
                    5117   ; {
                    5118   _OSFlagDel:
00001D94  4E56 0000 5119          link      A6,#0
00001D98  48E7 3E20 5120          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
00001D9C  242E 0008 5121          move.l    8(A6),D2
00001DA0  262E 0010 5122          move.l    16(A6),D3
00001DA4  45F9 0800 5123          lea       _OSFlagFreeList.L,A2
00001DA8  0DF6      
                    5124   ; BOOLEAN       tasks_waiting;
                    5125   ; OS_FLAG_NODE *pnode;
                    5126   ; OS_FLAG_GRP  *pgrp_return;
                    5127   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5128   ; OS_CPU_SR     cpu_sr = 0u;
                    5129   ; #endif
                    5130   ; #ifdef OS_SAFETY_CRITICAL
                    5131   ; if (perr == (INT8U *)0) {
                    5132   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5133   ; return ((OS_FLAG_GRP *)0);
                    5134   ; }
                    5135   ; #endif
                    5136   ; #if OS_ARG_CHK_EN > 0u
                    5137   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5138   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5139   ; return (pgrp);
                    5140   ; }
                    5141   ; #endif
                    5142   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001DAA  1039 0800 5143          move.b    _OSIntNesting.L,D0
00001DAE  0F06      
00001DB0  0C00 0000 5144          cmp.b     #0,D0
00001DB4  630C      5145          bls.s     OSFlagDel_1
                    5146   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001DB6  2043      5147          move.l    D3,A0
00001DB8  10BC 000F 5148          move.b    #15,(A0)
                    5149   ; return (pgrp);
00001DBC  2002      5150          move.l    D2,D0
00001DBE  6000 00EC 5151          bra       OSFlagDel_3
                    5152   OSFlagDel_1:
                    5153   ; }
                    5154   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
00001DC2  2042      5155          move.l    D2,A0
00001DC4  1010      5156          move.b    (A0),D0
00001DC6  0C00 0005 5157          cmp.b     #5,D0
00001DCA  670C      5158          beq.s     OSFlagDel_4
                    5159   ; *perr = OS_ERR_EVENT_TYPE;
00001DCC  2043      5160          move.l    D3,A0
00001DCE  10BC 0001 5161          move.b    #1,(A0)
                    5162   ; return (pgrp);
00001DD2  2002      5163          move.l    D2,D0
00001DD4  6000 00D6 5164          bra       OSFlagDel_3
                    5165   OSFlagDel_4:
                    5166   ; }
                    5167   ; OS_ENTER_CRITICAL();
00001DD8  40E7      5168          dc.w      16615
00001DDA  007C      5169          dc.w      124
00001DDC  0700      5170          dc.w      1792
                    5171   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
00001DDE  2042      5172          move.l    D2,A0
00001DE0  2028 0002 5173          move.l    2(A0),D0
00001DE4  6704      5174          beq.s     OSFlagDel_6
                    5175   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00001DE6  7C01      5176          moveq     #1,D6
00001DE8  6002      5177          bra.s     OSFlagDel_7
                    5178   OSFlagDel_6:
                    5179   ; } else {
                    5180   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00001DEA  4206      5181          clr.b     D6
                    5182   OSFlagDel_7:
                    5183   ; }
                    5184   ; switch (opt) {
00001DEC  102E 000F 5185          move.b    15(A6),D0
00001DF0  C0BC 0000 5186          and.l     #255,D0
00001DF4  00FF      
00001DF6  0C80 0000 5187          cmp.l     #1,D0
00001DFA  0001      
00001DFC  6700 0048 5188          beq       OSFlagDel_11
00001E00  6200 009E 5189          bhi       OSFlagDel_8
00001E04  4A80      5190          tst.l     D0
00001E06  6704      5191          beq.s     OSFlagDel_10
00001E08  6000 0096 5192          bra       OSFlagDel_8
                    5193   OSFlagDel_10:
                    5194   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    5195   ; if (tasks_waiting == OS_FALSE) {
00001E0C  4A06      5196          tst.b     D6
00001E0E  6628      5197          bne.s     OSFlagDel_13
                    5198   ; #if OS_FLAG_NAME_EN > 0u
                    5199   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001E10  41F9 0000 5200          lea       @ucos_ii_1.L,A0
00001E14  68A4      
00001E16  2242      5201          move.l    D2,A1
00001E18  2348 0008 5202          move.l    A0,8(A1)
                    5203   ; #endif
                    5204   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001E1C  2042      5205          move.l    D2,A0
00001E1E  4210      5206          clr.b     (A0)
                    5207   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
00001E20  2042      5208          move.l    D2,A0
00001E22  2152 0002 5209          move.l    (A2),2(A0)
                    5210   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001E26  2042      5211          move.l    D2,A0
00001E28  4268 0006 5212          clr.w     6(A0)
                    5213   ; OSFlagFreeList       = pgrp;
00001E2C  2482      5214          move.l    D2,(A2)
                    5215   ; OS_EXIT_CRITICAL();
00001E2E  46DF      5216          dc.w      18143
                    5217   ; *perr                = OS_ERR_NONE;
00001E30  2043      5218          move.l    D3,A0
00001E32  4210      5219          clr.b     (A0)
                    5220   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00001E34  4285      5221          clr.l     D5
00001E36  600A      5222          bra.s     OSFlagDel_14
                    5223   OSFlagDel_13:
                    5224   ; } else {
                    5225   ; OS_EXIT_CRITICAL();
00001E38  46DF      5226          dc.w      18143
                    5227   ; *perr                = OS_ERR_TASK_WAITING;
00001E3A  2043      5228          move.l    D3,A0
00001E3C  10BC 0049 5229          move.b    #73,(A0)
                    5230   ; pgrp_return          = pgrp;
00001E40  2A02      5231          move.l    D2,D5
                    5232   OSFlagDel_14:
                    5233   ; }
                    5234   ; break;
00001E42  6000 0066 5235          bra       OSFlagDel_9
                    5236   OSFlagDel_11:
                    5237   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    5238   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001E46  2042      5239          move.l    D2,A0
00001E48  2828 0002 5240          move.l    2(A0),D4
                    5241   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    5242   OSFlagDel_15:
00001E4C  4A84      5243          tst.l     D4
00001E4E  671E      5244          beq.s     OSFlagDel_17
                    5245   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
00001E50  4878 0002 5246          pea       2
00001E54  42A7      5247          clr.l     -(A7)
00001E56  2F04      5248          move.l    D4,-(A7)
00001E58  4EB9 0000 5249          jsr       @ucos_ii_OS_FlagTaskRdy
00001E5C  25CA      
00001E5E  DEFC 000C 5250          add.w     #12,A7
00001E62  C0BC 0000 5251          and.l     #255,D0
00001E66  00FF      
                    5252   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00001E68  2044      5253          move.l    D4,A0
00001E6A  2810      5254          move.l    (A0),D4
00001E6C  60DE      5255          bra       OSFlagDel_15
                    5256   OSFlagDel_17:
                    5257   ; }
                    5258   ; #if OS_FLAG_NAME_EN > 0u
                    5259   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001E6E  41F9 0000 5260          lea       @ucos_ii_1.L,A0
00001E72  68A4      
00001E74  2242      5261          move.l    D2,A1
00001E76  2348 0008 5262          move.l    A0,8(A1)
                    5263   ; #endif
                    5264   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001E7A  2042      5265          move.l    D2,A0
00001E7C  4210      5266          clr.b     (A0)
                    5267   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
00001E7E  2042      5268          move.l    D2,A0
00001E80  2152 0002 5269          move.l    (A2),2(A0)
                    5270   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001E84  2042      5271          move.l    D2,A0
00001E86  4268 0006 5272          clr.w     6(A0)
                    5273   ; OSFlagFreeList       = pgrp;
00001E8A  2482      5274          move.l    D2,(A2)
                    5275   ; OS_EXIT_CRITICAL();
00001E8C  46DF      5276          dc.w      18143
                    5277   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00001E8E  0C06 0001 5278          cmp.b     #1,D6
00001E92  6604      5279          bne.s     OSFlagDel_18
                    5280   ; OS_Sched();                               /* Find highest priority task ready to run  */
00001E94  4EB8 1816 5281          jsr       _OS_Sched
                    5282   OSFlagDel_18:
                    5283   ; }
                    5284   ; *perr = OS_ERR_NONE;
00001E98  2043      5285          move.l    D3,A0
00001E9A  4210      5286          clr.b     (A0)
                    5287   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
00001E9C  4285      5288          clr.l     D5
                    5289   ; break;
00001E9E  600A      5290          bra.s     OSFlagDel_9
                    5291   OSFlagDel_8:
                    5292   ; default:
                    5293   ; OS_EXIT_CRITICAL();
00001EA0  46DF      5294          dc.w      18143
                    5295   ; *perr                = OS_ERR_INVALID_OPT;
00001EA2  2043      5296          move.l    D3,A0
00001EA4  10BC 0007 5297          move.b    #7,(A0)
                    5298   ; pgrp_return          = pgrp;
00001EA8  2A02      5299          move.l    D2,D5
                    5300   ; break;
                    5301   OSFlagDel_9:
                    5302   ; }
                    5303   ; return (pgrp_return);
00001EAA  2005      5304          move.l    D5,D0
                    5305   OSFlagDel_3:
00001EAC  4CDF 047C 5306          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001EB0  4E5E      5307          unlk      A6
00001EB2  4E75      5308          rts
                    5309   ; }
                    5310   ; #endif
                    5311   ; /*$PAGE*/
                    5312   ; /*
                    5313   ; *********************************************************************************************************
                    5314   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5315   ; *
                    5316   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5317   ; *
                    5318   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5319   ; *
                    5320   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5321   ; *                        group.
                    5322   ; *
                    5323   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5324   ; *
                    5325   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5326   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5327   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5328   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5329   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5330   ; *
                    5331   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5332   ; *********************************************************************************************************
                    5333   ; */
                    5334   ; #if OS_FLAG_NAME_EN > 0u
                    5335   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5336   ; INT8U        **pname,
                    5337   ; INT8U         *perr)
                    5338   ; {
                    5339   _OSFlagNameGet:
00001EB4  4E56 FFFC 5340          link      A6,#-4
00001EB8  2F02      5341          move.l    D2,-(A7)
00001EBA  242E 0010 5342          move.l    16(A6),D2
                    5343   ; INT8U      len;
                    5344   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5345   ; OS_CPU_SR  cpu_sr = 0u;
                    5346   ; #endif
                    5347   ; #ifdef OS_SAFETY_CRITICAL
                    5348   ; if (perr == (INT8U *)0) {
                    5349   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5350   ; return (0u);
                    5351   ; }
                    5352   ; #endif
                    5353   ; #if OS_ARG_CHK_EN > 0u
                    5354   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5355   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5356   ; return (0u);
                    5357   ; }
                    5358   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5359   ; *perr = OS_ERR_PNAME_NULL;
                    5360   ; return (0u);
                    5361   ; }
                    5362   ; #endif
                    5363   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001EBE  1039 0800 5364          move.b    _OSIntNesting.L,D0
00001EC2  0F06      
00001EC4  0C00 0000 5365          cmp.b     #0,D0
00001EC8  630C      5366          bls.s     OSFlagNameGet_1
                    5367   ; *perr = OS_ERR_NAME_GET_ISR;
00001ECA  2042      5368          move.l    D2,A0
00001ECC  10BC 0011 5369          move.b    #17,(A0)
                    5370   ; return (0u);
00001ED0  4200      5371          clr.b     D0
00001ED2  6000 0046 5372          bra       OSFlagNameGet_3
                    5373   OSFlagNameGet_1:
                    5374   ; }
                    5375   ; OS_ENTER_CRITICAL();
00001ED6  40E7      5376          dc.w      16615
00001ED8  007C      5377          dc.w      124
00001EDA  0700      5378          dc.w      1792
                    5379   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001EDC  206E 0008 5380          move.l    8(A6),A0
00001EE0  1010      5381          move.b    (A0),D0
00001EE2  0C00 0005 5382          cmp.b     #5,D0
00001EE6  670C      5383          beq.s     OSFlagNameGet_4
                    5384   ; OS_EXIT_CRITICAL();
00001EE8  46DF      5385          dc.w      18143
                    5386   ; *perr = OS_ERR_EVENT_TYPE;
00001EEA  2042      5387          move.l    D2,A0
00001EEC  10BC 0001 5388          move.b    #1,(A0)
                    5389   ; return (0u);
00001EF0  4200      5390          clr.b     D0
00001EF2  6026      5391          bra.s     OSFlagNameGet_3
                    5392   OSFlagNameGet_4:
                    5393   ; }
                    5394   ; *pname = pgrp->OSFlagName;
00001EF4  206E 0008 5395          move.l    8(A6),A0
00001EF8  226E 000C 5396          move.l    12(A6),A1
00001EFC  22A8 0008 5397          move.l    8(A0),(A1)
                    5398   ; len    = OS_StrLen(*pname);
00001F00  206E 000C 5399          move.l    12(A6),A0
00001F04  2F10      5400          move.l    (A0),-(A7)
00001F06  4EB8 18C0 5401          jsr       _OS_StrLen
00001F0A  584F      5402          addq.w    #4,A7
00001F0C  1D40 FFFF 5403          move.b    D0,-1(A6)
                    5404   ; OS_EXIT_CRITICAL();
00001F10  46DF      5405          dc.w      18143
                    5406   ; *perr  = OS_ERR_NONE;
00001F12  2042      5407          move.l    D2,A0
00001F14  4210      5408          clr.b     (A0)
                    5409   ; return (len);
00001F16  102E FFFF 5410          move.b    -1(A6),D0
                    5411   OSFlagNameGet_3:
00001F1A  241F      5412          move.l    (A7)+,D2
00001F1C  4E5E      5413          unlk      A6
00001F1E  4E75      5414          rts
                    5415   ; }
                    5416   ; #endif
                    5417   ; /*$PAGE*/
                    5418   ; /*
                    5419   ; *********************************************************************************************************
                    5420   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5421   ; *
                    5422   ; * Description: This function assigns a name to an event flag group.
                    5423   ; *
                    5424   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5425   ; *
                    5426   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5427   ; *                        group.
                    5428   ; *
                    5429   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5430   ; *
                    5431   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5432   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5433   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5434   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5435   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5436   ; *
                    5437   ; * Returns    : None
                    5438   ; *********************************************************************************************************
                    5439   ; */
                    5440   ; #if OS_FLAG_NAME_EN > 0u
                    5441   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5442   ; INT8U        *pname,
                    5443   ; INT8U        *perr)
                    5444   ; {
                    5445   _OSFlagNameSet:
00001F20  4E56 0000 5446          link      A6,#0
00001F24  2F02      5447          move.l    D2,-(A7)
00001F26  242E 0010 5448          move.l    16(A6),D2
                    5449   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5450   ; OS_CPU_SR  cpu_sr = 0u;
                    5451   ; #endif
                    5452   ; #ifdef OS_SAFETY_CRITICAL
                    5453   ; if (perr == (INT8U *)0) {
                    5454   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5455   ; return;
                    5456   ; }
                    5457   ; #endif
                    5458   ; #if OS_ARG_CHK_EN > 0u
                    5459   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5460   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5461   ; return;
                    5462   ; }
                    5463   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5464   ; *perr = OS_ERR_PNAME_NULL;
                    5465   ; return;
                    5466   ; }
                    5467   ; #endif
                    5468   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001F2A  1039 0800 5469          move.b    _OSIntNesting.L,D0
00001F2E  0F06      
00001F30  0C00 0000 5470          cmp.b     #0,D0
00001F34  630A      5471          bls.s     OSFlagNameSet_1
                    5472   ; *perr = OS_ERR_NAME_SET_ISR;
00001F36  2042      5473          move.l    D2,A0
00001F38  10BC 0012 5474          move.b    #18,(A0)
                    5475   ; return;
00001F3C  6000 002E 5476          bra       OSFlagNameSet_3
                    5477   OSFlagNameSet_1:
                    5478   ; }
                    5479   ; OS_ENTER_CRITICAL();
00001F40  40E7      5480          dc.w      16615
00001F42  007C      5481          dc.w      124
00001F44  0700      5482          dc.w      1792
                    5483   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001F46  206E 0008 5484          move.l    8(A6),A0
00001F4A  1010      5485          move.b    (A0),D0
00001F4C  0C00 0005 5486          cmp.b     #5,D0
00001F50  670A      5487          beq.s     OSFlagNameSet_4
                    5488   ; OS_EXIT_CRITICAL();
00001F52  46DF      5489          dc.w      18143
                    5490   ; *perr = OS_ERR_EVENT_TYPE;
00001F54  2042      5491          move.l    D2,A0
00001F56  10BC 0001 5492          move.b    #1,(A0)
                    5493   ; return;
00001F5A  6010      5494          bra.s     OSFlagNameSet_3
                    5495   OSFlagNameSet_4:
                    5496   ; }
                    5497   ; pgrp->OSFlagName = pname;
00001F5C  206E 0008 5498          move.l    8(A6),A0
00001F60  216E 000C 5499          move.l    12(A6),8(A0)
00001F64  0008      
                    5500   ; OS_EXIT_CRITICAL();
00001F66  46DF      5501          dc.w      18143
                    5502   ; *perr            = OS_ERR_NONE;
00001F68  2042      5503          move.l    D2,A0
00001F6A  4210      5504          clr.b     (A0)
                    5505   ; return;
                    5506   OSFlagNameSet_3:
00001F6C  241F      5507          move.l    (A7)+,D2
00001F6E  4E5E      5508          unlk      A6
00001F70  4E75      5509          rts
                    5510   ; }
                    5511   ; #endif
                    5512   ; /*$PAGE*/
                    5513   ; /*
                    5514   ; *********************************************************************************************************
                    5515   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5516   ; *
                    5517   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5518   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5519   ; *
                    5520   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5521   ; *
                    5522   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5523   ; *                            The bits you want are specified by setting the corresponding bits in
                    5524   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5525   ; *                            'flags' would contain 0x03.
                    5526   ; *
                    5527   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5528   ; *                            You can specify the following argument:
                    5529   ; *
                    5530   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5531   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5532   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5533   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5534   ; *
                    5535   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5536   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5537   ; *                                  the flags that are present, set 'wait_type' to:
                    5538   ; *
                    5539   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5540   ; *
                    5541   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5542   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5543   ; *                            forever at the specified event flag group or, until a message arrives.
                    5544   ; *
                    5545   ; *              perr          is a pointer to an error code and can be:
                    5546   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5547   ; *                                                      'timeout'.
                    5548   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5549   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5550   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5551   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5552   ; *                                                      'timeout'.
                    5553   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5554   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5555   ; *
                    5556   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5557   ; *              occurred.
                    5558   ; *
                    5559   ; * Called from: Task ONLY
                    5560   ; *
                    5561   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5562   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5563   ; *                 event flags.
                    5564   ; *********************************************************************************************************
                    5565   ; */
                    5566   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5567   ; OS_FLAGS      flags,
                    5568   ; INT8U         wait_type,
                    5569   ; INT32U        timeout,
                    5570   ; INT8U        *perr)
                    5571   ; {
                    5572   _OSFlagPend:
00001F72  4E56 FFE8 5573          link      A6,#-24
00001F76  48E7 3F3C 5574          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001F7A  262E 0008 5575          move.l    8(A6),D3
00001F7E  282E 0018 5576          move.l    24(A6),D4
00001F82  3A2E 000E 5577          move.w    14(A6),D5
00001F86  CABC 0000 5578          and.l     #65535,D5
00001F8A  FFFF      
00001F8C  45F9 0800 5579          lea       _OSTCBCur.L,A2
00001F90  1020      
00001F92  1C2E 0013 5580          move.b    19(A6),D6
00001F96  CCBC 0000 5581          and.l     #255,D6
00001F9A  00FF      
00001F9C  47EE FFEA 5582          lea       -22(A6),A3
00001FA0  286E 0014 5583          move.l    20(A6),A4
00001FA4  4BF9 0000 5584          lea       @ucos_ii_OS_FlagBlock.L,A5
00001FA8  246C      
                    5585   ; OS_FLAG_NODE  node;
                    5586   ; OS_FLAGS      flags_rdy;
                    5587   ; INT8U         result;
                    5588   ; INT8U         pend_stat;
                    5589   ; BOOLEAN       consume;
                    5590   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5591   ; OS_CPU_SR     cpu_sr = 0u;
                    5592   ; #endif
                    5593   ; #ifdef OS_SAFETY_CRITICAL
                    5594   ; if (perr == (INT8U *)0) {
                    5595   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5596   ; return ((OS_FLAGS)0);
                    5597   ; }
                    5598   ; #endif
                    5599   ; #if OS_ARG_CHK_EN > 0u
                    5600   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5601   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5602   ; return ((OS_FLAGS)0);
                    5603   ; }
                    5604   ; #endif
                    5605   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001FAA  1039 0800 5606          move.b    _OSIntNesting.L,D0
00001FAE  0F06      
00001FB0  0C00 0000 5607          cmp.b     #0,D0
00001FB4  630C      5608          bls.s     OSFlagPend_1
                    5609   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001FB6  2044      5610          move.l    D4,A0
00001FB8  10BC 0002 5611          move.b    #2,(A0)
                    5612   ; return ((OS_FLAGS)0);
00001FBC  4240      5613          clr.w     D0
00001FBE  6000 028A 5614          bra       OSFlagPend_3
                    5615   OSFlagPend_1:
                    5616   ; }
                    5617   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00001FC2  1039 0800 5618          move.b    _OSLockNesting.L,D0
00001FC6  0F08      
00001FC8  0C00 0000 5619          cmp.b     #0,D0
00001FCC  630C      5620          bls.s     OSFlagPend_4
                    5621   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00001FCE  2044      5622          move.l    D4,A0
00001FD0  10BC 000D 5623          move.b    #13,(A0)
                    5624   ; return ((OS_FLAGS)0);
00001FD4  4240      5625          clr.w     D0
00001FD6  6000 0272 5626          bra       OSFlagPend_3
                    5627   OSFlagPend_4:
                    5628   ; }
                    5629   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001FDA  2043      5630          move.l    D3,A0
00001FDC  1010      5631          move.b    (A0),D0
00001FDE  0C00 0005 5632          cmp.b     #5,D0
00001FE2  670C      5633          beq.s     OSFlagPend_6
                    5634   ; *perr = OS_ERR_EVENT_TYPE;
00001FE4  2044      5635          move.l    D4,A0
00001FE6  10BC 0001 5636          move.b    #1,(A0)
                    5637   ; return ((OS_FLAGS)0);
00001FEA  4240      5638          clr.w     D0
00001FEC  6000 025C 5639          bra       OSFlagPend_3
                    5640   OSFlagPend_6:
                    5641   ; }
                    5642   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001FF0  1006      5643          move.b    D6,D0
00001FF2  C03C 0080 5644          and.b     #128,D0
00001FF6  1D40 FFFE 5645          move.b    D0,-2(A6)
                    5646   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001FFA  102E FFFE 5647          move.b    -2(A6),D0
00001FFE  670C      5648          beq.s     OSFlagPend_8
                    5649   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
00002000  103C 0080 5650          move.b    #128,D0
00002004  4600      5651          not.b     D0
00002006  CC00      5652          and.b     D0,D6
                    5653   ; consume    = OS_TRUE;
00002008  7E01      5654          moveq     #1,D7
0000200A  6002      5655          bra.s     OSFlagPend_9
                    5656   OSFlagPend_8:
                    5657   ; } else {
                    5658   ; consume    = OS_FALSE;
0000200C  7E00      5659          moveq     #0,D7
                    5660   OSFlagPend_9:
                    5661   ; }
                    5662   ; /*$PAGE*/
                    5663   ; OS_ENTER_CRITICAL();
0000200E  40E7      5664          dc.w      16615
00002010  007C      5665          dc.w      124
00002012  0700      5666          dc.w      1792
                    5667   ; switch (wait_type) {
00002014  CCBC 0000 5668          and.l     #255,D6
00002018  00FF      
0000201A  2006      5669          move.l    D6,D0
0000201C  0C80 0000 5670          cmp.l     #4,D0
00002020  0004      
00002022  6400 0156 5671          bhs       OSFlagPend_10
00002026  E380      5672          asl.l     #1,D0
00002028  303B 0806 5673          move.w    OSFlagPend_12(PC,D0.L),D0
0000202C  4EFB 0002 5674          jmp       OSFlagPend_12(PC,D0.W)
                    5675   OSFlagPend_12:
00002030  00AC      5676          dc.w      OSFlagPend_15-OSFlagPend_12
00002032  00FC      5677          dc.w      OSFlagPend_16-OSFlagPend_12
00002034  0008      5678          dc.w      OSFlagPend_13-OSFlagPend_12
00002036  005A      5679          dc.w      OSFlagPend_14-OSFlagPend_12
                    5680   OSFlagPend_13:
                    5681   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5682   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00002038  2043      5683          move.l    D3,A0
0000203A  3028 0006 5684          move.w    6(A0),D0
0000203E  C045      5685          and.w     D5,D0
00002040  3400      5686          move.w    D0,D2
                    5687   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00002042  B445      5688          cmp.w     D5,D2
00002044  6622      5689          bne.s     OSFlagPend_18
                    5690   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002046  0C07 0001 5691          cmp.b     #1,D7
0000204A  660A      5692          bne.s     OSFlagPend_20
                    5693   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
0000204C  2043      5694          move.l    D3,A0
0000204E  3002      5695          move.w    D2,D0
00002050  4640      5696          not.w     D0
00002052  C168 0006 5697          and.w     D0,6(A0)
                    5698   OSFlagPend_20:
                    5699   ; }
                    5700   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002056  2052      5701          move.l    (A2),A0
00002058  3142 002C 5702          move.w    D2,44(A0)
                    5703   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0000205C  46DF      5704          dc.w      18143
                    5705   ; *perr                   = OS_ERR_NONE;
0000205E  2044      5706          move.l    D4,A0
00002060  4210      5707          clr.b     (A0)
                    5708   ; return (flags_rdy);
00002062  3002      5709          move.w    D2,D0
00002064  6000 01E4 5710          bra       OSFlagPend_3
                    5711   OSFlagPend_18:
                    5712   ; } else {                                      /* Block task until events occur or timeout */
                    5713   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002068  2F0C      5714          move.l    A4,-(A7)
0000206A  CCBC 0000 5715          and.l     #255,D6
0000206E  00FF      
00002070  2F06      5716          move.l    D6,-(A7)
00002072  CABC 0000 5717          and.l     #65535,D5
00002076  FFFF      
00002078  2F05      5718          move.l    D5,-(A7)
0000207A  2F0B      5719          move.l    A3,-(A7)
0000207C  2F03      5720          move.l    D3,-(A7)
0000207E  4E95      5721          jsr       (A5)
00002080  DEFC 0014 5722          add.w     #20,A7
                    5723   ; OS_EXIT_CRITICAL();
00002084  46DF      5724          dc.w      18143
                    5725   ; }
                    5726   ; break;
00002086  6000 0102 5727          bra       OSFlagPend_11
                    5728   OSFlagPend_14:
                    5729   ; case OS_FLAG_WAIT_SET_ANY:
                    5730   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
0000208A  2043      5731          move.l    D3,A0
0000208C  3028 0006 5732          move.w    6(A0),D0
00002090  C045      5733          and.w     D5,D0
00002092  3400      5734          move.w    D0,D2
                    5735   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00002094  4A42      5736          tst.w     D2
00002096  6722      5737          beq.s     OSFlagPend_22
                    5738   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002098  0C07 0001 5739          cmp.b     #1,D7
0000209C  660A      5740          bne.s     OSFlagPend_24
                    5741   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
0000209E  2043      5742          move.l    D3,A0
000020A0  3002      5743          move.w    D2,D0
000020A2  4640      5744          not.w     D0
000020A4  C168 0006 5745          and.w     D0,6(A0)
                    5746   OSFlagPend_24:
                    5747   ; }
                    5748   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
000020A8  2052      5749          move.l    (A2),A0
000020AA  3142 002C 5750          move.w    D2,44(A0)
                    5751   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
000020AE  46DF      5752          dc.w      18143
                    5753   ; *perr                   = OS_ERR_NONE;
000020B0  2044      5754          move.l    D4,A0
000020B2  4210      5755          clr.b     (A0)
                    5756   ; return (flags_rdy);
000020B4  3002      5757          move.w    D2,D0
000020B6  6000 0192 5758          bra       OSFlagPend_3
                    5759   OSFlagPend_22:
                    5760   ; } else {                                      /* Block task until events occur or timeout */
                    5761   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
000020BA  2F0C      5762          move.l    A4,-(A7)
000020BC  CCBC 0000 5763          and.l     #255,D6
000020C0  00FF      
000020C2  2F06      5764          move.l    D6,-(A7)
000020C4  CABC 0000 5765          and.l     #65535,D5
000020C8  FFFF      
000020CA  2F05      5766          move.l    D5,-(A7)
000020CC  2F0B      5767          move.l    A3,-(A7)
000020CE  2F03      5768          move.l    D3,-(A7)
000020D0  4E95      5769          jsr       (A5)
000020D2  DEFC 0014 5770          add.w     #20,A7
                    5771   ; OS_EXIT_CRITICAL();
000020D6  46DF      5772          dc.w      18143
                    5773   ; }
                    5774   ; break;
000020D8  6000 00B0 5775          bra       OSFlagPend_11
                    5776   OSFlagPend_15:
                    5777   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5778   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5779   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
000020DC  2043      5780          move.l    D3,A0
000020DE  3028 0006 5781          move.w    6(A0),D0
000020E2  4640      5782          not.w     D0
000020E4  C045      5783          and.w     D5,D0
000020E6  3400      5784          move.w    D0,D2
                    5785   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
000020E8  B445      5786          cmp.w     D5,D2
000020EA  661E      5787          bne.s     OSFlagPend_26
                    5788   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000020EC  0C07 0001 5789          cmp.b     #1,D7
000020F0  6606      5790          bne.s     OSFlagPend_28
                    5791   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
000020F2  2043      5792          move.l    D3,A0
000020F4  8568 0006 5793          or.w      D2,6(A0)
                    5794   OSFlagPend_28:
                    5795   ; }
                    5796   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
000020F8  2052      5797          move.l    (A2),A0
000020FA  3142 002C 5798          move.w    D2,44(A0)
                    5799   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
000020FE  46DF      5800          dc.w      18143
                    5801   ; *perr                   = OS_ERR_NONE;
00002100  2044      5802          move.l    D4,A0
00002102  4210      5803          clr.b     (A0)
                    5804   ; return (flags_rdy);
00002104  3002      5805          move.w    D2,D0
00002106  6000 0142 5806          bra       OSFlagPend_3
                    5807   OSFlagPend_26:
                    5808   ; } else {                                      /* Block task until events occur or timeout */
                    5809   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
0000210A  2F0C      5810          move.l    A4,-(A7)
0000210C  CCBC 0000 5811          and.l     #255,D6
00002110  00FF      
00002112  2F06      5812          move.l    D6,-(A7)
00002114  CABC 0000 5813          and.l     #65535,D5
00002118  FFFF      
0000211A  2F05      5814          move.l    D5,-(A7)
0000211C  2F0B      5815          move.l    A3,-(A7)
0000211E  2F03      5816          move.l    D3,-(A7)
00002120  4E95      5817          jsr       (A5)
00002122  DEFC 0014 5818          add.w     #20,A7
                    5819   ; OS_EXIT_CRITICAL();
00002126  46DF      5820          dc.w      18143
                    5821   ; }
                    5822   ; break;
00002128  6000 0060 5823          bra       OSFlagPend_11
                    5824   OSFlagPend_16:
                    5825   ; case OS_FLAG_WAIT_CLR_ANY:
                    5826   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
0000212C  2043      5827          move.l    D3,A0
0000212E  3028 0006 5828          move.w    6(A0),D0
00002132  4640      5829          not.w     D0
00002134  C045      5830          and.w     D5,D0
00002136  3400      5831          move.w    D0,D2
                    5832   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00002138  4A42      5833          tst.w     D2
0000213A  671E      5834          beq.s     OSFlagPend_30
                    5835   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
0000213C  0C07 0001 5836          cmp.b     #1,D7
00002140  6606      5837          bne.s     OSFlagPend_32
                    5838   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00002142  2043      5839          move.l    D3,A0
00002144  8568 0006 5840          or.w      D2,6(A0)
                    5841   OSFlagPend_32:
                    5842   ; }
                    5843   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002148  2052      5844          move.l    (A2),A0
0000214A  3142 002C 5845          move.w    D2,44(A0)
                    5846   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
0000214E  46DF      5847          dc.w      18143
                    5848   ; *perr                   = OS_ERR_NONE;
00002150  2044      5849          move.l    D4,A0
00002152  4210      5850          clr.b     (A0)
                    5851   ; return (flags_rdy);
00002154  3002      5852          move.w    D2,D0
00002156  6000 00F2 5853          bra       OSFlagPend_3
                    5854   OSFlagPend_30:
                    5855   ; } else {                                      /* Block task until events occur or timeout */
                    5856   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
0000215A  2F0C      5857          move.l    A4,-(A7)
0000215C  CCBC 0000 5858          and.l     #255,D6
00002160  00FF      
00002162  2F06      5859          move.l    D6,-(A7)
00002164  CABC 0000 5860          and.l     #65535,D5
00002168  FFFF      
0000216A  2F05      5861          move.l    D5,-(A7)
0000216C  2F0B      5862          move.l    A3,-(A7)
0000216E  2F03      5863          move.l    D3,-(A7)
00002170  4E95      5864          jsr       (A5)
00002172  DEFC 0014 5865          add.w     #20,A7
                    5866   ; OS_EXIT_CRITICAL();
00002176  46DF      5867          dc.w      18143
                    5868   ; }
                    5869   ; break;
00002178  6010      5870          bra.s     OSFlagPend_11
                    5871   OSFlagPend_10:
                    5872   ; #endif
                    5873   ; default:
                    5874   ; OS_EXIT_CRITICAL();
0000217A  46DF      5875          dc.w      18143
                    5876   ; flags_rdy = (OS_FLAGS)0;
0000217C  4242      5877          clr.w     D2
                    5878   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
0000217E  2044      5879          move.l    D4,A0
00002180  10BC 006F 5880          move.b    #111,(A0)
                    5881   ; return (flags_rdy);
00002184  3002      5882          move.w    D2,D0
00002186  6000 00C2 5883          bra       OSFlagPend_3
                    5884   OSFlagPend_11:
                    5885   ; }
                    5886   ; /*$PAGE*/
                    5887   ; OS_Sched();                                            /* Find next HPT ready to run               */
0000218A  4EB8 1816 5888          jsr       _OS_Sched
                    5889   ; OS_ENTER_CRITICAL();
0000218E  40E7      5890          dc.w      16615
00002190  007C      5891          dc.w      124
00002192  0700      5892          dc.w      1792
                    5893   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
00002194  2052      5894          move.l    (A2),A0
00002196  1028 0033 5895          move.b    51(A0),D0
0000219A  6700 0056 5896          beq       OSFlagPend_34
                    5897   ; pend_stat                = OSTCBCur->OSTCBStatPend;
0000219E  2052      5898          move.l    (A2),A0
000021A0  1D68 0033 5899          move.b    51(A0),-1(A6)
000021A4  FFFF      
                    5900   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000021A6  2052      5901          move.l    (A2),A0
000021A8  4228 0033 5902          clr.b     51(A0)
                    5903   ; OS_FlagUnlink(&node);
000021AC  2F0B      5904          move.l    A3,-(A7)
000021AE  4EB9 0000 5905          jsr       _OS_FlagUnlink
000021B2  2646      
000021B4  584F      5906          addq.w    #4,A7
                    5907   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
000021B6  2052      5908          move.l    (A2),A0
000021B8  4228 0032 5909          clr.b     50(A0)
                    5910   ; OS_EXIT_CRITICAL();
000021BC  46DF      5911          dc.w      18143
                    5912   ; flags_rdy                = (OS_FLAGS)0;
000021BE  4242      5913          clr.w     D2
                    5914   ; switch (pend_stat) {
000021C0  102E FFFF 5915          move.b    -1(A6),D0
000021C4  C0BC 0000 5916          and.l     #255,D0
000021C8  00FF      
000021CA  0C80 0000 5917          cmp.l     #2,D0
000021CE  0002      
000021D0  670C      5918          beq.s     OSFlagPend_38
000021D2  6212      5919          bhi.s     OSFlagPend_39
000021D4  0C80 0000 5920          cmp.l     #1,D0
000021D8  0001      
000021DA  670A      5921          beq.s     OSFlagPend_39
000021DC  6008      5922          bra.s     OSFlagPend_39
                    5923   OSFlagPend_38:
                    5924   ; case OS_STAT_PEND_ABORT:
                    5925   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
000021DE  2044      5926          move.l    D4,A0
000021E0  10BC 000E 5927          move.b    #14,(A0)
                    5928   ; break;
000021E4  6006      5929          bra.s     OSFlagPend_37
                    5930   OSFlagPend_39:
                    5931   ; case OS_STAT_PEND_TO:
                    5932   ; default:
                    5933   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
000021E6  2044      5934          move.l    D4,A0
000021E8  10BC 000A 5935          move.b    #10,(A0)
                    5936   ; break;
                    5937   OSFlagPend_37:
                    5938   ; }
                    5939   ; return (flags_rdy);
000021EC  3002      5940          move.w    D2,D0
000021EE  6000 005A 5941          bra       OSFlagPend_3
                    5942   OSFlagPend_34:
                    5943   ; }
                    5944   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
000021F2  2052      5945          move.l    (A2),A0
000021F4  3428 002C 5946          move.w    44(A0),D2
                    5947   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
000021F8  0C07 0001 5948          cmp.b     #1,D7
000021FC  6600 0044 5949          bne       OSFlagPend_44
                    5950   ; switch (wait_type) {
00002200  CCBC 0000 5951          and.l     #255,D6
00002204  00FF      
00002206  2006      5952          move.l    D6,D0
00002208  0C80 0000 5953          cmp.l     #4,D0
0000220C  0004      
0000220E  6426      5954          bhs.s     OSFlagPend_43
00002210  E380      5955          asl.l     #1,D0
00002212  303B 0806 5956          move.w    OSFlagPend_45(PC,D0.L),D0
00002216  4EFB 0002 5957          jmp       OSFlagPend_45(PC,D0.W)
                    5958   OSFlagPend_45:
0000221A  0014      5959          dc.w      OSFlagPend_48-OSFlagPend_45
0000221C  0014      5960          dc.w      OSFlagPend_48-OSFlagPend_45
0000221E  0008      5961          dc.w      OSFlagPend_46-OSFlagPend_45
00002220  0008      5962          dc.w      OSFlagPend_46-OSFlagPend_45
                    5963   OSFlagPend_46:
                    5964   ; case OS_FLAG_WAIT_SET_ALL:
                    5965   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    5966   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
00002222  2043      5967          move.l    D3,A0
00002224  3002      5968          move.w    D2,D0
00002226  4640      5969          not.w     D0
00002228  C168 0006 5970          and.w     D0,6(A0)
                    5971   ; break;
0000222C  6014      5972          bra.s     OSFlagPend_44
                    5973   OSFlagPend_48:
                    5974   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5975   ; case OS_FLAG_WAIT_CLR_ALL:
                    5976   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    5977   ; pgrp->OSFlagFlags |=  flags_rdy;
0000222E  2043      5978          move.l    D3,A0
00002230  8568 0006 5979          or.w      D2,6(A0)
                    5980   ; break;
00002234  600C      5981          bra.s     OSFlagPend_44
                    5982   OSFlagPend_43:
                    5983   ; #endif
                    5984   ; default:
                    5985   ; OS_EXIT_CRITICAL();
00002236  46DF      5986          dc.w      18143
                    5987   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00002238  2044      5988          move.l    D4,A0
0000223A  10BC 006F 5989          move.b    #111,(A0)
                    5990   ; return ((OS_FLAGS)0);
0000223E  4240      5991          clr.w     D0
00002240  6008      5992          bra.s     OSFlagPend_3
                    5993   OSFlagPend_44:
                    5994   ; }
                    5995   ; }
                    5996   ; OS_EXIT_CRITICAL();
00002242  46DF      5997          dc.w      18143
                    5998   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
00002244  2044      5999          move.l    D4,A0
00002246  4210      6000          clr.b     (A0)
                    6001   ; return (flags_rdy);
00002248  3002      6002          move.w    D2,D0
                    6003   OSFlagPend_3:
0000224A  4CDF 3CFC 6004          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000224E  4E5E      6005          unlk      A6
00002250  4E75      6006          rts
                    6007   ; }
                    6008   ; /*$PAGE*/
                    6009   ; /*
                    6010   ; *********************************************************************************************************
                    6011   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    6012   ; *
                    6013   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    6014   ; *              In other words, this function allows you to tell "Who done it!".
                    6015   ; *
                    6016   ; * Arguments  : None
                    6017   ; *
                    6018   ; * Returns    : The flags that caused the task to be ready.
                    6019   ; *
                    6020   ; * Called from: Task ONLY
                    6021   ; *********************************************************************************************************
                    6022   ; */
                    6023   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    6024   ; {
                    6025   _OSFlagPendGetFlagsRdy:
00002252  4E56 FFFC 6026          link      A6,#-4
                    6027   ; OS_FLAGS      flags;
                    6028   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6029   ; OS_CPU_SR     cpu_sr = 0u;
                    6030   ; #endif
                    6031   ; OS_ENTER_CRITICAL();
00002256  40E7      6032          dc.w      16615
00002258  007C      6033          dc.w      124
0000225A  0700      6034          dc.w      1792
                    6035   ; flags = OSTCBCur->OSTCBFlagsRdy;
0000225C  2079 0800 6036          move.l    _OSTCBCur.L,A0
00002260  1020      
00002262  3D68 002C 6037          move.w    44(A0),-2(A6)
00002266  FFFE      
                    6038   ; OS_EXIT_CRITICAL();
00002268  46DF      6039          dc.w      18143
                    6040   ; return (flags);
0000226A  302E FFFE 6041          move.w    -2(A6),D0
0000226E  4E5E      6042          unlk      A6
00002270  4E75      6043          rts
                    6044   ; }
                    6045   ; /*$PAGE*/
                    6046   ; /*
                    6047   ; *********************************************************************************************************
                    6048   ; *                                       POST EVENT FLAG BIT(S)
                    6049   ; *
                    6050   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    6051   ; *              set or clear are specified by a 'bit mask'.
                    6052   ; *
                    6053   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6054   ; *
                    6055   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    6056   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    6057   ; *                            and 5 you would set 'flags' to:
                    6058   ; *
                    6059   ; *                                0x31     (note, bit 0 is least significant bit)
                    6060   ; *
                    6061   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    6062   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    6063   ; *                            4 and 5 you would specify 'flags' as:
                    6064   ; *
                    6065   ; *                                0x31     (note, bit 0 is least significant bit)
                    6066   ; *
                    6067   ; *              opt           indicates whether the flags will be:
                    6068   ; *                                set     (OS_FLAG_SET) or
                    6069   ; *                                cleared (OS_FLAG_CLR)
                    6070   ; *
                    6071   ; *              perr          is a pointer to an error code and can be:
                    6072   ; *                            OS_ERR_NONE                The call was successfull
                    6073   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6074   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6075   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    6076   ; *
                    6077   ; * Returns    : the new value of the event flags bits that are still set.
                    6078   ; *
                    6079   ; * Called From: Task or ISR
                    6080   ; *
                    6081   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    6082   ; *                 flag group.
                    6083   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    6084   ; *                 the event flag group.
                    6085   ; *********************************************************************************************************
                    6086   ; */
                    6087   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    6088   ; OS_FLAGS      flags,
                    6089   ; INT8U         opt,
                    6090   ; INT8U        *perr)
                    6091   ; {
                    6092   _OSFlagPost:
00002272  4E56 FFFC 6093          link      A6,#-4
00002276  48E7 3F20 6094          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
0000227A  282E 0008 6095          move.l    8(A6),D4
0000227E  45F9 0000 6096          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
00002282  25CA      
00002284  2E2E 0014 6097          move.l    20(A6),D7
                    6098   ; OS_FLAG_NODE *pnode;
                    6099   ; BOOLEAN       sched;
                    6100   ; OS_FLAGS      flags_cur;
                    6101   ; OS_FLAGS      flags_rdy;
                    6102   ; BOOLEAN       rdy;
                    6103   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    6104   ; OS_CPU_SR     cpu_sr = 0u;
                    6105   ; #endif
                    6106   ; #ifdef OS_SAFETY_CRITICAL
                    6107   ; if (perr == (INT8U *)0) {
                    6108   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6109   ; return ((OS_FLAGS)0);
                    6110   ; }
                    6111   ; #endif
                    6112   ; #if OS_ARG_CHK_EN > 0u
                    6113   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    6114   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6115   ; return ((OS_FLAGS)0);
                    6116   ; }
                    6117   ; #endif
                    6118   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00002288  2044      6119          move.l    D4,A0
0000228A  1010      6120          move.b    (A0),D0
0000228C  0C00 0005 6121          cmp.b     #5,D0
00002290  670C      6122          beq.s     OSFlagPost_1
                    6123   ; *perr = OS_ERR_EVENT_TYPE;
00002292  2047      6124          move.l    D7,A0
00002294  10BC 0001 6125          move.b    #1,(A0)
                    6126   ; return ((OS_FLAGS)0);
00002298  4240      6127          clr.w     D0
0000229A  6000 018C 6128          bra       OSFlagPost_3
                    6129   OSFlagPost_1:
                    6130   ; }
                    6131   ; /*$PAGE*/
                    6132   ; OS_ENTER_CRITICAL();
0000229E  40E7      6133          dc.w      16615
000022A0  007C      6134          dc.w      124
000022A2  0700      6135          dc.w      1792
                    6136   ; switch (opt) {
000022A4  102E 0013 6137          move.b    19(A6),D0
000022A8  C0BC 0000 6138          and.l     #255,D0
000022AC  00FF      
000022AE  0C80 0000 6139          cmp.l     #1,D0
000022B2  0001      
000022B4  6716      6140          beq.s     OSFlagPost_7
000022B6  6220      6141          bhi.s     OSFlagPost_4
000022B8  4A80      6142          tst.l     D0
000022BA  6702      6143          beq.s     OSFlagPost_6
000022BC  601A      6144          bra.s     OSFlagPost_4
                    6145   OSFlagPost_6:
                    6146   ; case OS_FLAG_CLR:
                    6147   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
000022BE  2044      6148          move.l    D4,A0
000022C0  302E 000E 6149          move.w    14(A6),D0
000022C4  4640      6150          not.w     D0
000022C6  C168 0006 6151          and.w     D0,6(A0)
                    6152   ; break;
000022CA  601A      6153          bra.s     OSFlagPost_5
                    6154   OSFlagPost_7:
                    6155   ; case OS_FLAG_SET:
                    6156   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
000022CC  2044      6157          move.l    D4,A0
000022CE  302E 000E 6158          move.w    14(A6),D0
000022D2  8168 0006 6159          or.w      D0,6(A0)
                    6160   ; break;
000022D6  600E      6161          bra.s     OSFlagPost_5
                    6162   OSFlagPost_4:
                    6163   ; default:
                    6164   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
000022D8  46DF      6165          dc.w      18143
                    6166   ; *perr = OS_ERR_FLAG_INVALID_OPT;
000022DA  2047      6167          move.l    D7,A0
000022DC  10BC 0071 6168          move.b    #113,(A0)
                    6169   ; return ((OS_FLAGS)0);
000022E0  4240      6170          clr.w     D0
000022E2  6000 0144 6171          bra       OSFlagPost_3
                    6172   OSFlagPost_5:
                    6173   ; }
                    6174   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
000022E6  4206      6175          clr.b     D6
                    6176   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000022E8  2044      6177          move.l    D4,A0
000022EA  2428 0002 6178          move.l    2(A0),D2
                    6179   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    6180   OSFlagPost_9:
000022EE  4A82      6181          tst.l     D2
000022F0  6700 0112 6182          beq       OSFlagPost_11
                    6183   ; switch (pnode->OSFlagNodeWaitType) {
000022F4  2042      6184          move.l    D2,A0
000022F6  1028 0012 6185          move.b    18(A0),D0
000022FA  C0BC 0000 6186          and.l     #255,D0
000022FE  00FF      
00002300  0C80 0000 6187          cmp.l     #4,D0
00002304  0004      
00002306  6400 00E6 6188          bhs       OSFlagPost_12
0000230A  E380      6189          asl.l     #1,D0
0000230C  303B 0806 6190          move.w    OSFlagPost_14(PC,D0.L),D0
00002310  4EFB 0002 6191          jmp       OSFlagPost_14(PC,D0.W)
                    6192   OSFlagPost_14:
00002314  0070      6193          dc.w      OSFlagPost_17-OSFlagPost_14
00002316  00A8      6194          dc.w      OSFlagPost_18-OSFlagPost_14
00002318  0008      6195          dc.w      OSFlagPost_15-OSFlagPost_14
0000231A  003E      6196          dc.w      OSFlagPost_16-OSFlagPost_14
                    6197   OSFlagPost_15:
                    6198   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    6199   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
0000231C  2044      6200          move.l    D4,A0
0000231E  3028 0006 6201          move.w    6(A0),D0
00002322  2042      6202          move.l    D2,A0
00002324  C068 0010 6203          and.w     16(A0),D0
00002328  3600      6204          move.w    D0,D3
                    6205   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
0000232A  2042      6206          move.l    D2,A0
0000232C  B668 0010 6207          cmp.w     16(A0),D3
00002330  661C      6208          bne.s     OSFlagPost_22
                    6209   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002332  42A7      6210          clr.l     -(A7)
00002334  C6BC 0000 6211          and.l     #65535,D3
00002338  FFFF      
0000233A  2F03      6212          move.l    D3,-(A7)
0000233C  2F02      6213          move.l    D2,-(A7)
0000233E  4E92      6214          jsr       (A2)
00002340  DEFC 000C 6215          add.w     #12,A7
00002344  1A00      6216          move.b    D0,D5
                    6217   ; if (rdy == OS_TRUE) {
00002346  0C05 0001 6218          cmp.b     #1,D5
0000234A  6602      6219          bne.s     OSFlagPost_22
                    6220   ; sched = OS_TRUE;                     /* When done we will reschedule          */
0000234C  7C01      6221          moveq     #1,D6
                    6222   OSFlagPost_22:
                    6223   ; }
                    6224   ; }
                    6225   ; break;
0000234E  6000 00AC 6226          bra       OSFlagPost_13
                    6227   OSFlagPost_16:
                    6228   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    6229   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00002352  2044      6230          move.l    D4,A0
00002354  3028 0006 6231          move.w    6(A0),D0
00002358  2042      6232          move.l    D2,A0
0000235A  C068 0010 6233          and.w     16(A0),D0
0000235E  3600      6234          move.w    D0,D3
                    6235   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00002360  4A43      6236          tst.w     D3
00002362  671C      6237          beq.s     OSFlagPost_26
                    6238   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002364  42A7      6239          clr.l     -(A7)
00002366  C6BC 0000 6240          and.l     #65535,D3
0000236A  FFFF      
0000236C  2F03      6241          move.l    D3,-(A7)
0000236E  2F02      6242          move.l    D2,-(A7)
00002370  4E92      6243          jsr       (A2)
00002372  DEFC 000C 6244          add.w     #12,A7
00002376  1A00      6245          move.b    D0,D5
                    6246   ; if (rdy == OS_TRUE) {
00002378  0C05 0001 6247          cmp.b     #1,D5
0000237C  6602      6248          bne.s     OSFlagPost_26
                    6249   ; sched = OS_TRUE;                     /* When done we will reschedule          */
0000237E  7C01      6250          moveq     #1,D6
                    6251   OSFlagPost_26:
                    6252   ; }
                    6253   ; }
                    6254   ; break;
00002380  6000 007A 6255          bra       OSFlagPost_13
                    6256   OSFlagPost_17:
                    6257   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6258   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    6259   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00002384  2044      6260          move.l    D4,A0
00002386  3028 0006 6261          move.w    6(A0),D0
0000238A  4640      6262          not.w     D0
0000238C  2042      6263          move.l    D2,A0
0000238E  C068 0010 6264          and.w     16(A0),D0
00002392  3600      6265          move.w    D0,D3
                    6266   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00002394  2042      6267          move.l    D2,A0
00002396  B668 0010 6268          cmp.w     16(A0),D3
0000239A  661C      6269          bne.s     OSFlagPost_30
                    6270   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
0000239C  42A7      6271          clr.l     -(A7)
0000239E  C6BC 0000 6272          and.l     #65535,D3
000023A2  FFFF      
000023A4  2F03      6273          move.l    D3,-(A7)
000023A6  2F02      6274          move.l    D2,-(A7)
000023A8  4E92      6275          jsr       (A2)
000023AA  DEFC 000C 6276          add.w     #12,A7
000023AE  1A00      6277          move.b    D0,D5
                    6278   ; if (rdy == OS_TRUE) {
000023B0  0C05 0001 6279          cmp.b     #1,D5
000023B4  6602      6280          bne.s     OSFlagPost_30
                    6281   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000023B6  7C01      6282          moveq     #1,D6
                    6283   OSFlagPost_30:
                    6284   ; }
                    6285   ; }
                    6286   ; break;
000023B8  6000 0042 6287          bra       OSFlagPost_13
                    6288   OSFlagPost_18:
                    6289   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    6290   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
000023BC  2044      6291          move.l    D4,A0
000023BE  3028 0006 6292          move.w    6(A0),D0
000023C2  4640      6293          not.w     D0
000023C4  2042      6294          move.l    D2,A0
000023C6  C068 0010 6295          and.w     16(A0),D0
000023CA  3600      6296          move.w    D0,D3
                    6297   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
000023CC  4A43      6298          tst.w     D3
000023CE  671C      6299          beq.s     OSFlagPost_34
                    6300   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000023D0  42A7      6301          clr.l     -(A7)
000023D2  C6BC 0000 6302          and.l     #65535,D3
000023D6  FFFF      
000023D8  2F03      6303          move.l    D3,-(A7)
000023DA  2F02      6304          move.l    D2,-(A7)
000023DC  4E92      6305          jsr       (A2)
000023DE  DEFC 000C 6306          add.w     #12,A7
000023E2  1A00      6307          move.b    D0,D5
                    6308   ; if (rdy == OS_TRUE) {
000023E4  0C05 0001 6309          cmp.b     #1,D5
000023E8  6602      6310          bne.s     OSFlagPost_34
                    6311   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000023EA  7C01      6312          moveq     #1,D6
                    6313   OSFlagPost_34:
                    6314   ; }
                    6315   ; }
                    6316   ; break;
000023EC  600E      6317          bra.s     OSFlagPost_13
                    6318   OSFlagPost_12:
                    6319   ; #endif
                    6320   ; default:
                    6321   ; OS_EXIT_CRITICAL();
000023EE  46DF      6322          dc.w      18143
                    6323   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
000023F0  2047      6324          move.l    D7,A0
000023F2  10BC 006F 6325          move.b    #111,(A0)
                    6326   ; return ((OS_FLAGS)0);
000023F6  4240      6327          clr.w     D0
000023F8  6000 002E 6328          bra       OSFlagPost_3
                    6329   OSFlagPost_13:
                    6330   ; }
                    6331   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
000023FC  2042      6332          move.l    D2,A0
000023FE  2410      6333          move.l    (A0),D2
00002400  6000 FEEC 6334          bra       OSFlagPost_9
                    6335   OSFlagPost_11:
                    6336   ; }
                    6337   ; OS_EXIT_CRITICAL();
00002404  46DF      6338          dc.w      18143
                    6339   ; if (sched == OS_TRUE) {
00002406  0C06 0001 6340          cmp.b     #1,D6
0000240A  6604      6341          bne.s     OSFlagPost_36
                    6342   ; OS_Sched();
0000240C  4EB8 1816 6343          jsr       _OS_Sched
                    6344   OSFlagPost_36:
                    6345   ; }
                    6346   ; OS_ENTER_CRITICAL();
00002410  40E7      6347          dc.w      16615
00002412  007C      6348          dc.w      124
00002414  0700      6349          dc.w      1792
                    6350   ; flags_cur = pgrp->OSFlagFlags;
00002416  2044      6351          move.l    D4,A0
00002418  3D68 0006 6352          move.w    6(A0),-2(A6)
0000241C  FFFE      
                    6353   ; OS_EXIT_CRITICAL();
0000241E  46DF      6354          dc.w      18143
                    6355   ; *perr     = OS_ERR_NONE;
00002420  2047      6356          move.l    D7,A0
00002422  4210      6357          clr.b     (A0)
                    6358   ; return (flags_cur);
00002424  302E FFFE 6359          move.w    -2(A6),D0
                    6360   OSFlagPost_3:
00002428  4CDF 04FC 6361          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
0000242C  4E5E      6362          unlk      A6
0000242E  4E75      6363          rts
                    6364   ; }
                    6365   ; /*$PAGE*/
                    6366   ; /*
                    6367   ; *********************************************************************************************************
                    6368   ; *                                          QUERY EVENT FLAG
                    6369   ; *
                    6370   ; * Description: This function is used to check the value of the event flag group.
                    6371   ; *
                    6372   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6373   ; *
                    6374   ; *              perr          is a pointer to an error code returned to the called:
                    6375   ; *                            OS_ERR_NONE                The call was successfull
                    6376   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6377   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6378   ; *
                    6379   ; * Returns    : The current value of the event flag group.
                    6380   ; *
                    6381   ; * Called From: Task or ISR
                    6382   ; *********************************************************************************************************
                    6383   ; */
                    6384   ; #if OS_FLAG_QUERY_EN > 0u
                    6385   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6386   ; INT8U        *perr)
                    6387   ; {
                    6388   _OSFlagQuery:
00002430  4E56 FFFC 6389          link      A6,#-4
                    6390   ; OS_FLAGS   flags;
                    6391   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6392   ; OS_CPU_SR  cpu_sr = 0u;
                    6393   ; #endif
                    6394   ; #ifdef OS_SAFETY_CRITICAL
                    6395   ; if (perr == (INT8U *)0) {
                    6396   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6397   ; return ((OS_FLAGS)0);
                    6398   ; }
                    6399   ; #endif
                    6400   ; #if OS_ARG_CHK_EN > 0u
                    6401   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6402   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6403   ; return ((OS_FLAGS)0);
                    6404   ; }
                    6405   ; #endif
                    6406   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00002434  206E 0008 6407          move.l    8(A6),A0
00002438  1010      6408          move.b    (A0),D0
0000243A  0C00 0005 6409          cmp.b     #5,D0
0000243E  670C      6410          beq.s     OSFlagQuery_1
                    6411   ; *perr = OS_ERR_EVENT_TYPE;
00002440  206E 000C 6412          move.l    12(A6),A0
00002444  10BC 0001 6413          move.b    #1,(A0)
                    6414   ; return ((OS_FLAGS)0);
00002448  4240      6415          clr.w     D0
0000244A  601C      6416          bra.s     OSFlagQuery_3
                    6417   OSFlagQuery_1:
                    6418   ; }
                    6419   ; OS_ENTER_CRITICAL();
0000244C  40E7      6420          dc.w      16615
0000244E  007C      6421          dc.w      124
00002450  0700      6422          dc.w      1792
                    6423   ; flags = pgrp->OSFlagFlags;
00002452  206E 0008 6424          move.l    8(A6),A0
00002456  3D68 0006 6425          move.w    6(A0),-2(A6)
0000245A  FFFE      
                    6426   ; OS_EXIT_CRITICAL();
0000245C  46DF      6427          dc.w      18143
                    6428   ; *perr = OS_ERR_NONE;
0000245E  206E 000C 6429          move.l    12(A6),A0
00002462  4210      6430          clr.b     (A0)
                    6431   ; return (flags);                               /* Return the current value of the event flags       */
00002464  302E FFFE 6432          move.w    -2(A6),D0
                    6433   OSFlagQuery_3:
00002468  4E5E      6434          unlk      A6
0000246A  4E75      6435          rts
                    6436   ; }
                    6437   ; #endif
                    6438   ; /*$PAGE*/
                    6439   ; /*
                    6440   ; *********************************************************************************************************
                    6441   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6442   ; *
                    6443   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6444   ; *              event flag bit(s) are set.
                    6445   ; *
                    6446   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6447   ; *
                    6448   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6449   ; *                            event flag bit(s) to be set.
                    6450   ; *
                    6451   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6452   ; *                            The bits you want are specified by setting the corresponding bits in
                    6453   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6454   ; *                            'flags' would contain 0x03.
                    6455   ; *
                    6456   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6457   ; *                            to be set/cleared.
                    6458   ; *                            You can specify the following argument:
                    6459   ; *
                    6460   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6461   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6462   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6463   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6464   ; *
                    6465   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6466   ; *                            bit(s) to be set.
                    6467   ; *
                    6468   ; * Returns    : none
                    6469   ; *
                    6470   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6471   ; *
                    6472   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6473   ; *********************************************************************************************************
                    6474   ; */
                    6475   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6476   ; OS_FLAG_NODE *pnode,
                    6477   ; OS_FLAGS      flags,
                    6478   ; INT8U         wait_type,
                    6479   ; INT32U        timeout)
                    6480   ; {
                    6481   @ucos_ii_OS_FlagBlock:
0000246C  4E56 0000 6482          link      A6,#0
00002470  48E7 3C20 6483          movem.l   D2/D3/D4/D5/A2,-(A7)
00002474  242E 000C 6484          move.l    12(A6),D2
00002478  45F9 0800 6485          lea       _OSTCBCur.L,A2
0000247C  1020      
0000247E  262E 0008 6486          move.l    8(A6),D3
                    6487   ; OS_FLAG_NODE  *pnode_next;
                    6488   ; INT8U          y;
                    6489   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
00002482  2052      6490          move.l    (A2),A0
00002484  0028 0020 6491          or.b      #32,50(A0)
00002488  0032      
                    6492   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0000248A  2052      6493          move.l    (A2),A0
0000248C  4228 0033 6494          clr.b     51(A0)
                    6495   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002490  2052      6496          move.l    (A2),A0
00002492  216E 0018 6497          move.l    24(A6),46(A0)
00002496  002E      
                    6498   ; #if OS_TASK_DEL_EN > 0u
                    6499   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
00002498  2052      6500          move.l    (A2),A0
0000249A  2142 0028 6501          move.l    D2,40(A0)
                    6502   ; #endif
                    6503   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
0000249E  2042      6504          move.l    D2,A0
000024A0  316E 0012 6505          move.w    18(A6),16(A0)
000024A4  0010      
                    6506   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
000024A6  2042      6507          move.l    D2,A0
000024A8  116E 0017 6508          move.b    23(A6),18(A0)
000024AC  0012      
                    6509   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
000024AE  2042      6510          move.l    D2,A0
000024B0  2152 0008 6511          move.l    (A2),8(A0)
                    6512   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000024B4  2043      6513          move.l    D3,A0
000024B6  2242      6514          move.l    D2,A1
000024B8  22A8 0002 6515          move.l    2(A0),(A1)
                    6516   ; pnode->OSFlagNodePrev     = (void *)0;
000024BC  2042      6517          move.l    D2,A0
000024BE  42A8 0004 6518          clr.l     4(A0)
                    6519   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000024C2  2042      6520          move.l    D2,A0
000024C4  2143 000C 6521          move.l    D3,12(A0)
                    6522   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000024C8  2043      6523          move.l    D3,A0
000024CA  2A28 0002 6524          move.l    2(A0),D5
                    6525   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000024CE  4A85      6526          tst.l     D5
000024D0  6706      6527          beq.s     @ucos_ii_OS_FlagBlock_1
                    6528   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000024D2  2045      6529          move.l    D5,A0
000024D4  2142 0004 6530          move.l    D2,4(A0)
                    6531   @ucos_ii_OS_FlagBlock_1:
                    6532   ; }
                    6533   ; pgrp->OSFlagWaitList = (void *)pnode;
000024D8  2043      6534          move.l    D3,A0
000024DA  2142 0002 6535          move.l    D2,2(A0)
                    6536   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000024DE  2052      6537          move.l    (A2),A0
000024E0  1828 0036 6538          move.b    54(A0),D4
                    6539   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000024E4  C8BC 0000 6540          and.l     #255,D4
000024E8  00FF      
000024EA  41F9 0800 6541          lea       _OSRdyTbl.L,A0
000024EE  0F10      
000024F0  2252      6542          move.l    (A2),A1
000024F2  1029 0037 6543          move.b    55(A1),D0
000024F6  4600      6544          not.b     D0
000024F8  C130 4800 6545          and.b     D0,0(A0,D4.L)
                    6546   ; if (OSRdyTbl[y] == 0x00u) {
000024FC  C8BC 0000 6547          and.l     #255,D4
00002500  00FF      
00002502  41F9 0800 6548          lea       _OSRdyTbl.L,A0
00002506  0F10      
00002508  1030 4800 6549          move.b    0(A0,D4.L),D0
0000250C  660E      6550          bne.s     @ucos_ii_OS_FlagBlock_3
                    6551   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000250E  2052      6552          move.l    (A2),A0
00002510  1028 0038 6553          move.b    56(A0),D0
00002514  4600      6554          not.b     D0
00002516  C139 0800 6555          and.b     D0,_OSRdyGrp.L
0000251A  0F0E      
                    6556   @ucos_ii_OS_FlagBlock_3:
0000251C  4CDF 043C 6557          movem.l   (A7)+,D2/D3/D4/D5/A2
00002520  4E5E      6558          unlk      A6
00002522  4E75      6559          rts
                    6560   ; }
                    6561   ; }
                    6562   ; /*$PAGE*/
                    6563   ; /*
                    6564   ; *********************************************************************************************************
                    6565   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6566   ; *
                    6567   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6568   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6569   ; *
                    6570   ; * Arguments  : none
                    6571   ; *
                    6572   ; * Returns    : none
                    6573   ; *
                    6574   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6575   ; *********************************************************************************************************
                    6576   ; */
                    6577   ; void  OS_FlagInit (void)
                    6578   ; {
                    6579   _OS_FlagInit:
00002524  4E56 FFF8 6580          link      A6,#-8
00002528  48E7 3020 6581          movem.l   D2/D3/A2,-(A7)
0000252C  45F9 0800 6582          lea       _OSFlagTbl.L,A2
00002530  0DBA      
                    6583   ; #if OS_MAX_FLAGS == 1u
                    6584   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6585   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6586   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6587   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6588   ; #if OS_FLAG_NAME_EN > 0u
                    6589   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6590   ; #endif
                    6591   ; #endif
                    6592   ; #if OS_MAX_FLAGS >= 2u
                    6593   ; INT16U        ix;
                    6594   ; INT16U        ix_next;
                    6595   ; OS_FLAG_GRP  *pgrp1;
                    6596   ; OS_FLAG_GRP  *pgrp2;
                    6597   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
00002532  4878 003C 6598          pea       60
00002536  2F0A      6599          move.l    A2,-(A7)
00002538  4EB8 17CA 6600          jsr       _OS_MemClr
0000253C  504F      6601          addq.w    #8,A7
                    6602   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
0000253E  4243      6603          clr.w     D3
                    6604   OS_FlagInit_1:
00002540  0C43 0004 6605          cmp.w     #4,D3
00002544  6400 004E 6606          bhs       OS_FlagInit_3
                    6607   ; ix_next = ix + 1u;
00002548  3003      6608          move.w    D3,D0
0000254A  5240      6609          addq.w    #1,D0
0000254C  3D40 FFFA 6610          move.w    D0,-6(A6)
                    6611   ; pgrp1 = &OSFlagTbl[ix];
00002550  200A      6612          move.l    A2,D0
00002552  C6BC 0000 6613          and.l     #65535,D3
00002556  FFFF      
00002558  2203      6614          move.l    D3,D1
0000255A  C3FC 000C 6615          muls      #12,D1
0000255E  D081      6616          add.l     D1,D0
00002560  2400      6617          move.l    D0,D2
                    6618   ; pgrp2 = &OSFlagTbl[ix_next];
00002562  200A      6619          move.l    A2,D0
00002564  322E FFFA 6620          move.w    -6(A6),D1
00002568  C2BC 0000 6621          and.l     #65535,D1
0000256C  FFFF      
0000256E  C3FC 000C 6622          muls      #12,D1
00002572  D081      6623          add.l     D1,D0
00002574  2D40 FFFC 6624          move.l    D0,-4(A6)
                    6625   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002578  2042      6626          move.l    D2,A0
0000257A  4210      6627          clr.b     (A0)
                    6628   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
0000257C  2042      6629          move.l    D2,A0
0000257E  216E FFFC 6630          move.l    -4(A6),2(A0)
00002582  0002      
                    6631   ; #if OS_FLAG_NAME_EN > 0u
                    6632   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
00002584  41F9 0000 6633          lea       @ucos_ii_1.L,A0
00002588  68A4      
0000258A  2242      6634          move.l    D2,A1
0000258C  2348 0008 6635          move.l    A0,8(A1)
00002590  5243      6636          addq.w    #1,D3
00002592  60AC      6637          bra       OS_FlagInit_1
                    6638   OS_FlagInit_3:
                    6639   ; #endif
                    6640   ; }
                    6641   ; pgrp1                 = &OSFlagTbl[ix];
00002594  200A      6642          move.l    A2,D0
00002596  C6BC 0000 6643          and.l     #65535,D3
0000259A  FFFF      
0000259C  2203      6644          move.l    D3,D1
0000259E  C3FC 000C 6645          muls      #12,D1
000025A2  D081      6646          add.l     D1,D0
000025A4  2400      6647          move.l    D0,D2
                    6648   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000025A6  2042      6649          move.l    D2,A0
000025A8  4210      6650          clr.b     (A0)
                    6651   ; pgrp1->OSFlagWaitList = (void *)0;
000025AA  2042      6652          move.l    D2,A0
000025AC  42A8 0002 6653          clr.l     2(A0)
                    6654   ; #if OS_FLAG_NAME_EN > 0u
                    6655   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
000025B0  41F9 0000 6656          lea       @ucos_ii_1.L,A0
000025B4  68A4      
000025B6  2242      6657          move.l    D2,A1
000025B8  2348 0008 6658          move.l    A0,8(A1)
                    6659   ; #endif
                    6660   ; OSFlagFreeList        = &OSFlagTbl[0];
000025BC  23CA 0800 6661          move.l    A2,_OSFlagFreeList.L
000025C0  0DF6      
000025C2  4CDF 040C 6662          movem.l   (A7)+,D2/D3/A2
000025C6  4E5E      6663          unlk      A6
000025C8  4E75      6664          rts
                    6665   ; #endif
                    6666   ; }
                    6667   ; /*$PAGE*/
                    6668   ; /*
                    6669   ; *********************************************************************************************************
                    6670   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6671   ; *
                    6672   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6673   ; *              desired event flag bits have been set.
                    6674   ; *
                    6675   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6676   ; *                            event flag bit(s) to be set.
                    6677   ; *
                    6678   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6679   ; *                            ready-to-run.
                    6680   ; *
                    6681   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6682   ; *
                    6683   ; *
                    6684   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6685   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6686   ; *
                    6687   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6688   ; *
                    6689   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6690   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6691   ; *********************************************************************************************************
                    6692   ; */
                    6693   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6694   ; OS_FLAGS      flags_rdy,
                    6695   ; INT8U         pend_stat)
                    6696   ; {
                    6697   @ucos_ii_OS_FlagTaskRdy:
000025CA  4E56 0000 6698          link      A6,#0
000025CE  48E7 3000 6699          movem.l   D2/D3,-(A7)
                    6700   ; OS_TCB   *ptcb;
                    6701   ; BOOLEAN   sched;
                    6702   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000025D2  206E 0008 6703          move.l    8(A6),A0
000025D6  2428 0008 6704          move.l    8(A0),D2
                    6705   ; ptcb->OSTCBDly       = 0u;
000025DA  2042      6706          move.l    D2,A0
000025DC  42A8 002E 6707          clr.l     46(A0)
                    6708   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
000025E0  2042      6709          move.l    D2,A0
000025E2  316E 000E 6710          move.w    14(A6),44(A0)
000025E6  002C      
                    6711   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000025E8  2042      6712          move.l    D2,A0
000025EA  7020      6713          moveq     #32,D0
000025EC  4600      6714          not.b     D0
000025EE  C128 0032 6715          and.b     D0,50(A0)
                    6716   ; ptcb->OSTCBStatPend  = pend_stat;
000025F2  2042      6717          move.l    D2,A0
000025F4  116E 0013 6718          move.b    19(A6),51(A0)
000025F8  0033      
                    6719   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000025FA  2042      6720          move.l    D2,A0
000025FC  1028 0032 6721          move.b    50(A0),D0
00002600  662C      6722          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6723   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
00002602  2042      6724          move.l    D2,A0
00002604  1028 0038 6725          move.b    56(A0),D0
00002608  8139 0800 6726          or.b      D0,_OSRdyGrp.L
0000260C  0F0E      
                    6727   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000260E  2042      6728          move.l    D2,A0
00002610  1028 0036 6729          move.b    54(A0),D0
00002614  C0BC 0000 6730          and.l     #255,D0
00002618  00FF      
0000261A  41F9 0800 6731          lea       _OSRdyTbl.L,A0
0000261E  0F10      
00002620  2242      6732          move.l    D2,A1
00002622  1229 0037 6733          move.b    55(A1),D1
00002626  8330 0800 6734          or.b      D1,0(A0,D0.L)
                    6735   ; sched                   = OS_TRUE;
0000262A  7601      6736          moveq     #1,D3
0000262C  6002      6737          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6738   @ucos_ii_OS_FlagTaskRdy_1:
                    6739   ; } else {
                    6740   ; sched                   = OS_FALSE;
0000262E  4203      6741          clr.b     D3
                    6742   @ucos_ii_OS_FlagTaskRdy_2:
                    6743   ; }
                    6744   ; OS_FlagUnlink(pnode);
00002630  2F2E 0008 6745          move.l    8(A6),-(A7)
00002634  4EB9 0000 6746          jsr       _OS_FlagUnlink
00002638  2646      
0000263A  584F      6747          addq.w    #4,A7
                    6748   ; return (sched);
0000263C  1003      6749          move.b    D3,D0
0000263E  4CDF 000C 6750          movem.l   (A7)+,D2/D3
00002642  4E5E      6751          unlk      A6
00002644  4E75      6752          rts
                    6753   ; }
                    6754   ; /*$PAGE*/
                    6755   ; /*
                    6756   ; *********************************************************************************************************
                    6757   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6758   ; *
                    6759   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6760   ; *              list of tasks waiting for the event flag.
                    6761   ; *
                    6762   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6763   ; *                            event flag bit(s) to be set.
                    6764   ; *
                    6765   ; * Returns    : none
                    6766   ; *
                    6767   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6768   ; *              OSFlagPend()     OS_FLAG.C
                    6769   ; *              OSTaskDel()      OS_TASK.C
                    6770   ; *
                    6771   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6772   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6773   ; *********************************************************************************************************
                    6774   ; */
                    6775   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6776   ; {
                    6777   _OS_FlagUnlink:
00002646  4E56 FFF8 6778          link      A6,#-8
0000264A  48E7 3800 6779          movem.l   D2/D3/D4,-(A7)
0000264E  262E 0008 6780          move.l    8(A6),D3
                    6781   ; #if OS_TASK_DEL_EN > 0u
                    6782   ; OS_TCB       *ptcb;
                    6783   ; #endif
                    6784   ; OS_FLAG_GRP  *pgrp;
                    6785   ; OS_FLAG_NODE *pnode_prev;
                    6786   ; OS_FLAG_NODE *pnode_next;
                    6787   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
00002652  2043      6788          move.l    D3,A0
00002654  2828 0004 6789          move.l    4(A0),D4
                    6790   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00002658  2043      6791          move.l    D3,A0
0000265A  2410      6792          move.l    (A0),D2
                    6793   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
0000265C  4A84      6794          tst.l     D4
0000265E  661C      6795          bne.s     OS_FlagUnlink_1
                    6796   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00002660  2043      6797          move.l    D3,A0
00002662  2D68 000C 6798          move.l    12(A0),-4(A6)
00002666  FFFC      
                    6799   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00002668  206E FFFC 6800          move.l    -4(A6),A0
0000266C  2142 0002 6801          move.l    D2,2(A0)
                    6802   ; if (pnode_next != (OS_FLAG_NODE *)0) {
00002670  4A82      6803          tst.l     D2
00002672  6706      6804          beq.s     OS_FlagUnlink_3
                    6805   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00002674  2042      6806          move.l    D2,A0
00002676  42A8 0004 6807          clr.l     4(A0)
                    6808   OS_FlagUnlink_3:
0000267A  600E      6809          bra.s     OS_FlagUnlink_5
                    6810   OS_FlagUnlink_1:
                    6811   ; }
                    6812   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6813   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
0000267C  2044      6814          move.l    D4,A0
0000267E  2082      6815          move.l    D2,(A0)
                    6816   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
00002680  4A82      6817          tst.l     D2
00002682  6706      6818          beq.s     OS_FlagUnlink_5
                    6819   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00002684  2042      6820          move.l    D2,A0
00002686  2144 0004 6821          move.l    D4,4(A0)
                    6822   OS_FlagUnlink_5:
                    6823   ; }
                    6824   ; }
                    6825   ; #if OS_TASK_DEL_EN > 0u
                    6826   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0000268A  2043      6827          move.l    D3,A0
0000268C  2D68 0008 6828          move.l    8(A0),-8(A6)
00002690  FFF8      
                    6829   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00002692  206E FFF8 6830          move.l    -8(A6),A0
00002696  42A8 0028 6831          clr.l     40(A0)
0000269A  4CDF 001C 6832          movem.l   (A7)+,D2/D3/D4
0000269E  4E5E      6833          unlk      A6
000026A0  4E75      6834          rts
                    6835   ; /*
                    6836   ; *********************************************************************************************************
                    6837   ; *                                                uC/OS-II
                    6838   ; *                                          The Real-Time Kernel
                    6839   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6840   ; *
                    6841   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6842   ; *                                           All Rights Reserved
                    6843   ; *
                    6844   ; * File    : OS_MBOX.C
                    6845   ; * By      : Jean J. Labrosse
                    6846   ; * Version : V2.92.07
                    6847   ; *
                    6848   ; * LICENSING TERMS:
                    6849   ; * ---------------
                    6850   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6851   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6852   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6853   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6854   ; * licensing fee.
                    6855   ; *********************************************************************************************************
                    6856   ; */
                    6857   ; #define  MICRIUM_SOURCE
                    6858   ; #ifndef  OS_MASTER_FILE
                    6859   ; #include <ucos_ii.h>
                    6860   ; #endif
                    6861   ; #if OS_MBOX_EN > 0u
                    6862   ; /*
                    6863   ; *********************************************************************************************************
                    6864   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6865   ; *
                    6866   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6867   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6868   ; *
                    6869   ; * Arguments  : pevent        is a pointer to the event control block
                    6870   ; *
                    6871   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6872   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6873   ; *              == (void *)0  if the mailbox is empty or,
                    6874   ; *                            if 'pevent' is a NULL pointer or,
                    6875   ; *                            if you didn't pass the proper event pointer.
                    6876   ; *********************************************************************************************************
                    6877   ; */
                    6878   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6879   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6880   ; {
                    6881   _OSMboxAccept:
000026A2  4E56 FFFC 6882          link      A6,#-4
000026A6  2F02      6883          move.l    D2,-(A7)
000026A8  242E 0008 6884          move.l    8(A6),D2
                    6885   ; void      *pmsg;
                    6886   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6887   ; OS_CPU_SR  cpu_sr = 0u;
                    6888   ; #endif
                    6889   ; #if OS_ARG_CHK_EN > 0u
                    6890   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6891   ; return ((void *)0);
                    6892   ; }
                    6893   ; #endif
                    6894   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000026AC  2042      6895          move.l    D2,A0
000026AE  1010      6896          move.b    (A0),D0
000026B0  0C00 0001 6897          cmp.b     #1,D0
000026B4  6704      6898          beq.s     OSMboxAccept_1
                    6899   ; return ((void *)0);
000026B6  4280      6900          clr.l     D0
000026B8  601A      6901          bra.s     OSMboxAccept_3
                    6902   OSMboxAccept_1:
                    6903   ; }
                    6904   ; OS_ENTER_CRITICAL();
000026BA  40E7      6905          dc.w      16615
000026BC  007C      6906          dc.w      124
000026BE  0700      6907          dc.w      1792
                    6908   ; pmsg               = pevent->OSEventPtr;
000026C0  2042      6909          move.l    D2,A0
000026C2  2D68 0002 6910          move.l    2(A0),-4(A6)
000026C6  FFFC      
                    6911   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
000026C8  2042      6912          move.l    D2,A0
000026CA  42A8 0002 6913          clr.l     2(A0)
                    6914   ; OS_EXIT_CRITICAL();
000026CE  46DF      6915          dc.w      18143
                    6916   ; return (pmsg);                                        /* Return the message received (or NULL)     */
000026D0  202E FFFC 6917          move.l    -4(A6),D0
                    6918   OSMboxAccept_3:
000026D4  241F      6919          move.l    (A7)+,D2
000026D6  4E5E      6920          unlk      A6
000026D8  4E75      6921          rts
                    6922   ; }
                    6923   ; #endif
                    6924   ; /*$PAGE*/
                    6925   ; /*
                    6926   ; *********************************************************************************************************
                    6927   ; *                                          CREATE A MESSAGE MAILBOX
                    6928   ; *
                    6929   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    6930   ; *
                    6931   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    6932   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    6933   ; *                            will be considered empty.
                    6934   ; *
                    6935   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    6936   ; *                                created mailbox
                    6937   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    6938   ; *********************************************************************************************************
                    6939   ; */
                    6940   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    6941   ; {
                    6942   _OSMboxCreate:
000026DA  4E56 0000 6943          link      A6,#0
000026DE  48E7 2020 6944          movem.l   D2/A2,-(A7)
000026E2  45F9 0800 6945          lea       _OSEventFreeList.L,A2
000026E6  0CDA      
                    6946   ; OS_EVENT  *pevent;
                    6947   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    6948   ; OS_CPU_SR  cpu_sr = 0u;
                    6949   ; #endif
                    6950   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    6951   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    6952   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6953   ; return ((OS_EVENT *)0);
                    6954   ; }
                    6955   ; #endif
                    6956   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000026E8  1039 0800 6957          move.b    _OSIntNesting.L,D0
000026EC  0F06      
000026EE  0C00 0000 6958          cmp.b     #0,D0
000026F2  6306      6959          bls.s     OSMboxCreate_1
                    6960   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000026F4  4280      6961          clr.l     D0
000026F6  6000 0044 6962          bra       OSMboxCreate_3
                    6963   OSMboxCreate_1:
                    6964   ; }
                    6965   ; OS_ENTER_CRITICAL();
000026FA  40E7      6966          dc.w      16615
000026FC  007C      6967          dc.w      124
000026FE  0700      6968          dc.w      1792
                    6969   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
00002700  2412      6970          move.l    (A2),D2
                    6971   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
00002702  2012      6972          move.l    (A2),D0
00002704  6706      6973          beq.s     OSMboxCreate_4
                    6974   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00002706  2052      6975          move.l    (A2),A0
00002708  24A8 0002 6976          move.l    2(A0),(A2)
                    6977   OSMboxCreate_4:
                    6978   ; }
                    6979   ; OS_EXIT_CRITICAL();
0000270C  46DF      6980          dc.w      18143
                    6981   ; if (pevent != (OS_EVENT *)0) {
0000270E  4A82      6982          tst.l     D2
00002710  6728      6983          beq.s     OSMboxCreate_6
                    6984   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
00002712  2042      6985          move.l    D2,A0
00002714  10BC 0001 6986          move.b    #1,(A0)
                    6987   ; pevent->OSEventCnt     = 0u;
00002718  2042      6988          move.l    D2,A0
0000271A  4268 0006 6989          clr.w     6(A0)
                    6990   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
0000271E  2042      6991          move.l    D2,A0
00002720  216E 0008 6992          move.l    8(A6),2(A0)
00002724  0002      
                    6993   ; #if OS_EVENT_NAME_EN > 0u
                    6994   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00002726  41F9 0000 6995          lea       @ucos_ii_1.L,A0
0000272A  68A4      
0000272C  2242      6996          move.l    D2,A1
0000272E  2348 0012 6997          move.l    A0,18(A1)
                    6998   ; #endif
                    6999   ; OS_EventWaitListInit(pevent);
00002732  2F02      7000          move.l    D2,-(A7)
00002734  4EB8 14FE 7001          jsr       _OS_EventWaitListInit
00002738  584F      7002          addq.w    #4,A7
                    7003   OSMboxCreate_6:
                    7004   ; }
                    7005   ; return (pevent);                             /* Return pointer to event control block              */
0000273A  2002      7006          move.l    D2,D0
                    7007   OSMboxCreate_3:
0000273C  4CDF 0404 7008          movem.l   (A7)+,D2/A2
00002740  4E5E      7009          unlk      A6
00002742  4E75      7010          rts
                    7011   ; }
                    7012   ; /*$PAGE*/
                    7013   ; /*
                    7014   ; *********************************************************************************************************
                    7015   ; *                                           DELETE A MAIBOX
                    7016   ; *
                    7017   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    7018   ; *
                    7019   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    7020   ; *                            mailbox.
                    7021   ; *
                    7022   ; *              opt           determines delete options as follows:
                    7023   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    7024   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    7025   ; *                                                    In this case, all the tasks pending will be readied.
                    7026   ; *
                    7027   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    7028   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    7029   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    7030   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    7031   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    7032   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    7033   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    7034   ; *
                    7035   ; * Returns    : pevent        upon error
                    7036   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    7037   ; *
                    7038   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    7039   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    7040   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    7041   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    7042   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    7043   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    7044   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    7045   ; *                 will no longer be guarded by the mailbox.
                    7046   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    7047   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    7048   ; *********************************************************************************************************
                    7049   ; */
                    7050   ; #if OS_MBOX_DEL_EN > 0u
                    7051   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    7052   ; INT8U      opt,
                    7053   ; INT8U     *perr)
                    7054   ; {
                    7055   _OSMboxDel:
00002744  4E56 0000 7056          link      A6,#0
00002748  48E7 3C20 7057          movem.l   D2/D3/D4/D5/A2,-(A7)
0000274C  242E 0008 7058          move.l    8(A6),D2
00002750  262E 0010 7059          move.l    16(A6),D3
00002754  45F9 0800 7060          lea       _OSEventFreeList.L,A2
00002758  0CDA      
                    7061   ; BOOLEAN    tasks_waiting;
                    7062   ; OS_EVENT  *pevent_return;
                    7063   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7064   ; OS_CPU_SR  cpu_sr = 0u;
                    7065   ; #endif
                    7066   ; #ifdef OS_SAFETY_CRITICAL
                    7067   ; if (perr == (INT8U *)0) {
                    7068   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7069   ; return ((OS_EVENT *)0);
                    7070   ; }
                    7071   ; #endif
                    7072   ; #if OS_ARG_CHK_EN > 0u
                    7073   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7074   ; *perr = OS_ERR_PEVENT_NULL;
                    7075   ; return (pevent);
                    7076   ; }
                    7077   ; #endif
                    7078   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
0000275A  2042      7079          move.l    D2,A0
0000275C  1010      7080          move.b    (A0),D0
0000275E  0C00 0001 7081          cmp.b     #1,D0
00002762  670C      7082          beq.s     OSMboxDel_1
                    7083   ; *perr = OS_ERR_EVENT_TYPE;
00002764  2043      7084          move.l    D3,A0
00002766  10BC 0001 7085          move.b    #1,(A0)
                    7086   ; return (pevent);
0000276A  2002      7087          move.l    D2,D0
0000276C  6000 00EA 7088          bra       OSMboxDel_3
                    7089   OSMboxDel_1:
                    7090   ; }
                    7091   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002770  1039 0800 7092          move.b    _OSIntNesting.L,D0
00002774  0F06      
00002776  0C00 0000 7093          cmp.b     #0,D0
0000277A  630C      7094          bls.s     OSMboxDel_4
                    7095   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0000277C  2043      7096          move.l    D3,A0
0000277E  10BC 000F 7097          move.b    #15,(A0)
                    7098   ; return (pevent);
00002782  2002      7099          move.l    D2,D0
00002784  6000 00D2 7100          bra       OSMboxDel_3
                    7101   OSMboxDel_4:
                    7102   ; }
                    7103   ; OS_ENTER_CRITICAL();
00002788  40E7      7104          dc.w      16615
0000278A  007C      7105          dc.w      124
0000278C  0700      7106          dc.w      1792
                    7107   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
0000278E  2042      7108          move.l    D2,A0
00002790  1028 0008 7109          move.b    8(A0),D0
00002794  6704      7110          beq.s     OSMboxDel_6
                    7111   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002796  7A01      7112          moveq     #1,D5
00002798  6002      7113          bra.s     OSMboxDel_7
                    7114   OSMboxDel_6:
                    7115   ; } else {
                    7116   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000279A  4205      7117          clr.b     D5
                    7118   OSMboxDel_7:
                    7119   ; }
                    7120   ; switch (opt) {
0000279C  102E 000F 7121          move.b    15(A6),D0
000027A0  C0BC 0000 7122          and.l     #255,D0
000027A4  00FF      
000027A6  0C80 0000 7123          cmp.l     #1,D0
000027AA  0001      
000027AC  6700 0048 7124          beq       OSMboxDel_11
000027B0  6200 009A 7125          bhi       OSMboxDel_8
000027B4  4A80      7126          tst.l     D0
000027B6  6704      7127          beq.s     OSMboxDel_10
000027B8  6000 0092 7128          bra       OSMboxDel_8
                    7129   OSMboxDel_10:
                    7130   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    7131   ; if (tasks_waiting == OS_FALSE) {
000027BC  4A05      7132          tst.b     D5
000027BE  6628      7133          bne.s     OSMboxDel_13
                    7134   ; #if OS_EVENT_NAME_EN > 0u
                    7135   ; pevent->OSEventName = (INT8U *)(void *)"?";
000027C0  41F9 0000 7136          lea       @ucos_ii_1.L,A0
000027C4  68A4      
000027C6  2242      7137          move.l    D2,A1
000027C8  2348 0012 7138          move.l    A0,18(A1)
                    7139   ; #endif
                    7140   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
000027CC  2042      7141          move.l    D2,A0
000027CE  4210      7142          clr.b     (A0)
                    7143   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
000027D0  2042      7144          move.l    D2,A0
000027D2  2152 0002 7145          move.l    (A2),2(A0)
                    7146   ; pevent->OSEventCnt  = 0u;
000027D6  2042      7147          move.l    D2,A0
000027D8  4268 0006 7148          clr.w     6(A0)
                    7149   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
000027DC  2482      7150          move.l    D2,(A2)
                    7151   ; OS_EXIT_CRITICAL();
000027DE  46DF      7152          dc.w      18143
                    7153   ; *perr               = OS_ERR_NONE;
000027E0  2043      7154          move.l    D3,A0
000027E2  4210      7155          clr.b     (A0)
                    7156   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
000027E4  4284      7157          clr.l     D4
000027E6  600A      7158          bra.s     OSMboxDel_14
                    7159   OSMboxDel_13:
                    7160   ; } else {
                    7161   ; OS_EXIT_CRITICAL();
000027E8  46DF      7162          dc.w      18143
                    7163   ; *perr               = OS_ERR_TASK_WAITING;
000027EA  2043      7164          move.l    D3,A0
000027EC  10BC 0049 7165          move.b    #73,(A0)
                    7166   ; pevent_return       = pevent;
000027F0  2802      7167          move.l    D2,D4
                    7168   OSMboxDel_14:
                    7169   ; }
                    7170   ; break;
000027F2  6000 0062 7171          bra       OSMboxDel_9
                    7172   OSMboxDel_11:
                    7173   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    7174   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    7175   OSMboxDel_15:
000027F6  2042      7176          move.l    D2,A0
000027F8  1028 0008 7177          move.b    8(A0),D0
000027FC  671C      7178          beq.s     OSMboxDel_17
                    7179   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000027FE  4878 0002 7180          pea       2
00002802  4878 0002 7181          pea       2
00002806  42A7      7182          clr.l     -(A7)
00002808  2F02      7183          move.l    D2,-(A7)
0000280A  4EB8 1236 7184          jsr       _OS_EventTaskRdy
0000280E  DEFC 0010 7185          add.w     #16,A7
00002812  C0BC 0000 7186          and.l     #255,D0
00002816  00FF      
00002818  60DC      7187          bra       OSMboxDel_15
                    7188   OSMboxDel_17:
                    7189   ; }
                    7190   ; #if OS_EVENT_NAME_EN > 0u
                    7191   ; pevent->OSEventName    = (INT8U *)(void *)"?";
0000281A  41F9 0000 7192          lea       @ucos_ii_1.L,A0
0000281E  68A4      
00002820  2242      7193          move.l    D2,A1
00002822  2348 0012 7194          move.l    A0,18(A1)
                    7195   ; #endif
                    7196   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00002826  2042      7197          move.l    D2,A0
00002828  4210      7198          clr.b     (A0)
                    7199   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
0000282A  2042      7200          move.l    D2,A0
0000282C  2152 0002 7201          move.l    (A2),2(A0)
                    7202   ; pevent->OSEventCnt     = 0u;
00002830  2042      7203          move.l    D2,A0
00002832  4268 0006 7204          clr.w     6(A0)
                    7205   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00002836  2482      7206          move.l    D2,(A2)
                    7207   ; OS_EXIT_CRITICAL();
00002838  46DF      7208          dc.w      18143
                    7209   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000283A  0C05 0001 7210          cmp.b     #1,D5
0000283E  6604      7211          bne.s     OSMboxDel_18
                    7212   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002840  4EB8 1816 7213          jsr       _OS_Sched
                    7214   OSMboxDel_18:
                    7215   ; }
                    7216   ; *perr         = OS_ERR_NONE;
00002844  2043      7217          move.l    D3,A0
00002846  4210      7218          clr.b     (A0)
                    7219   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
00002848  4284      7220          clr.l     D4
                    7221   ; break;
0000284A  600A      7222          bra.s     OSMboxDel_9
                    7223   OSMboxDel_8:
                    7224   ; default:
                    7225   ; OS_EXIT_CRITICAL();
0000284C  46DF      7226          dc.w      18143
                    7227   ; *perr         = OS_ERR_INVALID_OPT;
0000284E  2043      7228          move.l    D3,A0
00002850  10BC 0007 7229          move.b    #7,(A0)
                    7230   ; pevent_return = pevent;
00002854  2802      7231          move.l    D2,D4
                    7232   ; break;
                    7233   OSMboxDel_9:
                    7234   ; }
                    7235   ; return (pevent_return);
00002856  2004      7236          move.l    D4,D0
                    7237   OSMboxDel_3:
00002858  4CDF 043C 7238          movem.l   (A7)+,D2/D3/D4/D5/A2
0000285C  4E5E      7239          unlk      A6
0000285E  4E75      7240          rts
                    7241   ; }
                    7242   ; #endif
                    7243   ; /*$PAGE*/
                    7244   ; /*
                    7245   ; *********************************************************************************************************
                    7246   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    7247   ; *
                    7248   ; * Description: This function waits for a message to be sent to a mailbox
                    7249   ; *
                    7250   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7251   ; *
                    7252   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    7253   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    7254   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    7255   ; *                            forever at the specified mailbox or, until a message arrives.
                    7256   ; *
                    7257   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7258   ; *                            messages are:
                    7259   ; *
                    7260   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    7261   ; *                                                message.
                    7262   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    7263   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    7264   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    7265   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    7266   ; *                                                would lead to a suspension.
                    7267   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    7268   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    7269   ; *
                    7270   ; * Returns    : != (void *)0  is a pointer to the message received
                    7271   ; *              == (void *)0  if no message was received or,
                    7272   ; *                            if 'pevent' is a NULL pointer or,
                    7273   ; *                            if you didn't pass the proper pointer to the event control block.
                    7274   ; *********************************************************************************************************
                    7275   ; */
                    7276   ; /*$PAGE*/
                    7277   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    7278   ; INT32U     timeout,
                    7279   ; INT8U     *perr)
                    7280   ; {
                    7281   _OSMboxPend:
00002860  4E56 0000 7282          link      A6,#0
00002864  48E7 3820 7283          movem.l   D2/D3/D4/A2,-(A7)
00002868  45F9 0800 7284          lea       _OSTCBCur.L,A2
0000286C  1020      
0000286E  262E 0010 7285          move.l    16(A6),D3
00002872  282E 0008 7286          move.l    8(A6),D4
                    7287   ; void      *pmsg;
                    7288   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7289   ; OS_CPU_SR  cpu_sr = 0u;
                    7290   ; #endif
                    7291   ; #ifdef OS_SAFETY_CRITICAL
                    7292   ; if (perr == (INT8U *)0) {
                    7293   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7294   ; return ((void *)0);
                    7295   ; }
                    7296   ; #endif
                    7297   ; #if OS_ARG_CHK_EN > 0u
                    7298   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7299   ; *perr = OS_ERR_PEVENT_NULL;
                    7300   ; return ((void *)0);
                    7301   ; }
                    7302   ; #endif
                    7303   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002876  2044      7304          move.l    D4,A0
00002878  1010      7305          move.b    (A0),D0
0000287A  0C00 0001 7306          cmp.b     #1,D0
0000287E  670C      7307          beq.s     OSMboxPend_1
                    7308   ; *perr = OS_ERR_EVENT_TYPE;
00002880  2043      7309          move.l    D3,A0
00002882  10BC 0001 7310          move.b    #1,(A0)
                    7311   ; return ((void *)0);
00002886  4280      7312          clr.l     D0
00002888  6000 00F0 7313          bra       OSMboxPend_3
                    7314   OSMboxPend_1:
                    7315   ; }
                    7316   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000288C  1039 0800 7317          move.b    _OSIntNesting.L,D0
00002890  0F06      
00002892  0C00 0000 7318          cmp.b     #0,D0
00002896  630C      7319          bls.s     OSMboxPend_4
                    7320   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00002898  2043      7321          move.l    D3,A0
0000289A  10BC 0002 7322          move.b    #2,(A0)
                    7323   ; return ((void *)0);
0000289E  4280      7324          clr.l     D0
000028A0  6000 00D8 7325          bra       OSMboxPend_3
                    7326   OSMboxPend_4:
                    7327   ; }
                    7328   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000028A4  1039 0800 7329          move.b    _OSLockNesting.L,D0
000028A8  0F08      
000028AA  0C00 0000 7330          cmp.b     #0,D0
000028AE  630C      7331          bls.s     OSMboxPend_6
                    7332   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
000028B0  2043      7333          move.l    D3,A0
000028B2  10BC 000D 7334          move.b    #13,(A0)
                    7335   ; return ((void *)0);
000028B6  4280      7336          clr.l     D0
000028B8  6000 00C0 7337          bra       OSMboxPend_3
                    7338   OSMboxPend_6:
                    7339   ; }
                    7340   ; OS_ENTER_CRITICAL();
000028BC  40E7      7341          dc.w      16615
000028BE  007C      7342          dc.w      124
000028C0  0700      7343          dc.w      1792
                    7344   ; pmsg = pevent->OSEventPtr;
000028C2  2044      7345          move.l    D4,A0
000028C4  2428 0002 7346          move.l    2(A0),D2
                    7347   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
000028C8  4A82      7348          tst.l     D2
000028CA  6712      7349          beq.s     OSMboxPend_8
                    7350   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
000028CC  2044      7351          move.l    D4,A0
000028CE  42A8 0002 7352          clr.l     2(A0)
                    7353   ; OS_EXIT_CRITICAL();
000028D2  46DF      7354          dc.w      18143
                    7355   ; *perr = OS_ERR_NONE;
000028D4  2043      7356          move.l    D3,A0
000028D6  4210      7357          clr.b     (A0)
                    7358   ; return (pmsg);                                /* Return the message received (or NULL)         */
000028D8  2002      7359          move.l    D2,D0
000028DA  6000 009E 7360          bra       OSMboxPend_3
                    7361   OSMboxPend_8:
                    7362   ; }
                    7363   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
000028DE  2052      7364          move.l    (A2),A0
000028E0  0028 0002 7365          or.b      #2,50(A0)
000028E4  0032      
                    7366   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000028E6  2052      7367          move.l    (A2),A0
000028E8  4228 0033 7368          clr.b     51(A0)
                    7369   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
000028EC  2052      7370          move.l    (A2),A0
000028EE  216E 000C 7371          move.l    12(A6),46(A0)
000028F2  002E      
                    7372   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000028F4  2F04      7373          move.l    D4,-(A7)
000028F6  4EB8 131A 7374          jsr       _OS_EventTaskWait
000028FA  584F      7375          addq.w    #4,A7
                    7376   ; OS_EXIT_CRITICAL();
000028FC  46DF      7377          dc.w      18143
                    7378   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
000028FE  4EB8 1816 7379          jsr       _OS_Sched
                    7380   ; OS_ENTER_CRITICAL();
00002902  40E7      7381          dc.w      16615
00002904  007C      7382          dc.w      124
00002906  0700      7383          dc.w      1792
                    7384   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00002908  2052      7385          move.l    (A2),A0
0000290A  1028 0033 7386          move.b    51(A0),D0
0000290E  C0BC 0000 7387          and.l     #255,D0
00002912  00FF      
00002914  0C80 0000 7388          cmp.l     #1,D0
00002918  0001      
0000291A  6700 002A 7389          beq       OSMboxPend_14
0000291E  6206      7390          bhi.s     OSMboxPend_16
00002920  4A80      7391          tst.l     D0
00002922  670C      7392          beq.s     OSMboxPend_12
00002924  6020      7393          bra.s     OSMboxPend_14
                    7394   OSMboxPend_16:
00002926  0C80 0000 7395          cmp.l     #2,D0
0000292A  0002      
0000292C  670E      7396          beq.s     OSMboxPend_13
0000292E  6016      7397          bra.s     OSMboxPend_14
                    7398   OSMboxPend_12:
                    7399   ; case OS_STAT_PEND_OK:
                    7400   ; pmsg =  OSTCBCur->OSTCBMsg;
00002930  2052      7401          move.l    (A2),A0
00002932  2428 0024 7402          move.l    36(A0),D2
                    7403   ; *perr =  OS_ERR_NONE;
00002936  2043      7404          move.l    D3,A0
00002938  4210      7405          clr.b     (A0)
                    7406   ; break;
0000293A  601C      7407          bra.s     OSMboxPend_11
                    7408   OSMboxPend_13:
                    7409   ; case OS_STAT_PEND_ABORT:
                    7410   ; pmsg = (void *)0;
0000293C  4282      7411          clr.l     D2
                    7412   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
0000293E  2043      7413          move.l    D3,A0
00002940  10BC 000E 7414          move.b    #14,(A0)
                    7415   ; break;
00002944  6012      7416          bra.s     OSMboxPend_11
                    7417   OSMboxPend_14:
                    7418   ; case OS_STAT_PEND_TO:
                    7419   ; default:
                    7420   ; OS_EventTaskRemove(OSTCBCur, pevent);
00002946  2F04      7421          move.l    D4,-(A7)
00002948  2F12      7422          move.l    (A2),-(A7)
0000294A  4EB8 143C 7423          jsr       _OS_EventTaskRemove
0000294E  504F      7424          addq.w    #8,A7
                    7425   ; pmsg = (void *)0;
00002950  4282      7426          clr.l     D2
                    7427   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00002952  2043      7428          move.l    D3,A0
00002954  10BC 000A 7429          move.b    #10,(A0)
                    7430   ; break;
                    7431   OSMboxPend_11:
                    7432   ; }
                    7433   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00002958  2052      7434          move.l    (A2),A0
0000295A  4228 0032 7435          clr.b     50(A0)
                    7436   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000295E  2052      7437          move.l    (A2),A0
00002960  4228 0033 7438          clr.b     51(A0)
                    7439   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002964  2052      7440          move.l    (A2),A0
00002966  42A8 001C 7441          clr.l     28(A0)
                    7442   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7443   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000296A  2052      7444          move.l    (A2),A0
0000296C  42A8 0020 7445          clr.l     32(A0)
                    7446   ; #endif
                    7447   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002970  2052      7448          move.l    (A2),A0
00002972  42A8 0024 7449          clr.l     36(A0)
                    7450   ; OS_EXIT_CRITICAL();
00002976  46DF      7451          dc.w      18143
                    7452   ; return (pmsg);                                    /* Return received message                       */
00002978  2002      7453          move.l    D2,D0
                    7454   OSMboxPend_3:
0000297A  4CDF 041C 7455          movem.l   (A7)+,D2/D3/D4/A2
0000297E  4E5E      7456          unlk      A6
00002980  4E75      7457          rts
                    7458   ; }
                    7459   ; /*$PAGE*/
                    7460   ; /*
                    7461   ; *********************************************************************************************************
                    7462   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7463   ; *
                    7464   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7465   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7466   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7467   ; *
                    7468   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7469   ; *
                    7470   ; *              opt           determines the type of ABORT performed:
                    7471   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7472   ; *                                                     mailbox
                    7473   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7474   ; *                                                     mailbox
                    7475   ; *
                    7476   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7477   ; *                            messages are:
                    7478   ; *
                    7479   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7480   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7481   ; *                                                and informed of the aborted wait; check return value
                    7482   ; *                                                for the number of tasks whose wait on the mailbox
                    7483   ; *                                                was aborted.
                    7484   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7485   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7486   ; *
                    7487   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7488   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7489   ; *********************************************************************************************************
                    7490   ; */
                    7491   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7492   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7493   ; INT8U      opt,
                    7494   ; INT8U     *perr)
                    7495   ; {
                    7496   _OSMboxPendAbort:
00002982  4E56 0000 7497          link      A6,#0
00002986  48E7 3800 7498          movem.l   D2/D3/D4,-(A7)
0000298A  242E 0008 7499          move.l    8(A6),D2
0000298E  282E 0010 7500          move.l    16(A6),D4
                    7501   ; INT8U      nbr_tasks;
                    7502   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7503   ; OS_CPU_SR  cpu_sr = 0u;
                    7504   ; #endif
                    7505   ; #ifdef OS_SAFETY_CRITICAL
                    7506   ; if (perr == (INT8U *)0) {
                    7507   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7508   ; return (0u);
                    7509   ; }
                    7510   ; #endif
                    7511   ; #if OS_ARG_CHK_EN > 0u
                    7512   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7513   ; *perr = OS_ERR_PEVENT_NULL;
                    7514   ; return (0u);
                    7515   ; }
                    7516   ; #endif
                    7517   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002992  2042      7518          move.l    D2,A0
00002994  1010      7519          move.b    (A0),D0
00002996  0C00 0001 7520          cmp.b     #1,D0
0000299A  670C      7521          beq.s     OSMboxPendAbort_1
                    7522   ; *perr = OS_ERR_EVENT_TYPE;
0000299C  2044      7523          move.l    D4,A0
0000299E  10BC 0001 7524          move.b    #1,(A0)
                    7525   ; return (0u);
000029A2  4200      7526          clr.b     D0
000029A4  6000 008C 7527          bra       OSMboxPendAbort_3
                    7528   OSMboxPendAbort_1:
                    7529   ; }
                    7530   ; OS_ENTER_CRITICAL();
000029A8  40E7      7531          dc.w      16615
000029AA  007C      7532          dc.w      124
000029AC  0700      7533          dc.w      1792
                    7534   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
000029AE  2042      7535          move.l    D2,A0
000029B0  1028 0008 7536          move.b    8(A0),D0
000029B4  6700 0074 7537          beq       OSMboxPendAbort_4
                    7538   ; nbr_tasks = 0u;
000029B8  4203      7539          clr.b     D3
                    7540   ; switch (opt) {
000029BA  102E 000F 7541          move.b    15(A6),D0
000029BE  C0BC 0000 7542          and.l     #255,D0
000029C2  00FF      
000029C4  0C80 0000 7543          cmp.l     #1,D0
000029C8  0001      
000029CA  670A      7544          beq.s     OSMboxPendAbort_8
000029CC  6200 0030 7545          bhi       OSMboxPendAbort_9
000029D0  4A80      7546          tst.l     D0
000029D2  672A      7547          beq.s     OSMboxPendAbort_9
000029D4  6028      7548          bra.s     OSMboxPendAbort_9
                    7549   OSMboxPendAbort_8:
                    7550   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7551   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7552   OSMboxPendAbort_11:
000029D6  2042      7553          move.l    D2,A0
000029D8  1028 0008 7554          move.b    8(A0),D0
000029DC  671E      7555          beq.s     OSMboxPendAbort_13
                    7556   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000029DE  4878 0002 7557          pea       2
000029E2  4878 0002 7558          pea       2
000029E6  42A7      7559          clr.l     -(A7)
000029E8  2F02      7560          move.l    D2,-(A7)
000029EA  4EB8 1236 7561          jsr       _OS_EventTaskRdy
000029EE  DEFC 0010 7562          add.w     #16,A7
000029F2  C0BC 0000 7563          and.l     #255,D0
000029F6  00FF      
                    7564   ; nbr_tasks++;
000029F8  5203      7565          addq.b    #1,D3
000029FA  60DA      7566          bra       OSMboxPendAbort_11
                    7567   OSMboxPendAbort_13:
                    7568   ; }
                    7569   ; break;
000029FC  601C      7570          bra.s     OSMboxPendAbort_7
                    7571   OSMboxPendAbort_9:
                    7572   ; case OS_PEND_OPT_NONE:
                    7573   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7574   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000029FE  4878 0002 7575          pea       2
00002A02  4878 0002 7576          pea       2
00002A06  42A7      7577          clr.l     -(A7)
00002A08  2F02      7578          move.l    D2,-(A7)
00002A0A  4EB8 1236 7579          jsr       _OS_EventTaskRdy
00002A0E  DEFC 0010 7580          add.w     #16,A7
00002A12  C0BC 0000 7581          and.l     #255,D0
00002A16  00FF      
                    7582   ; nbr_tasks++;
00002A18  5203      7583          addq.b    #1,D3
                    7584   ; break;
                    7585   OSMboxPendAbort_7:
                    7586   ; }
                    7587   ; OS_EXIT_CRITICAL();
00002A1A  46DF      7588          dc.w      18143
                    7589   ; OS_Sched();                                        /* Find HPT ready to run                    */
00002A1C  4EB8 1816 7590          jsr       _OS_Sched
                    7591   ; *perr = OS_ERR_PEND_ABORT;
00002A20  2044      7592          move.l    D4,A0
00002A22  10BC 000E 7593          move.b    #14,(A0)
                    7594   ; return (nbr_tasks);
00002A26  1003      7595          move.b    D3,D0
00002A28  6008      7596          bra.s     OSMboxPendAbort_3
                    7597   OSMboxPendAbort_4:
                    7598   ; }
                    7599   ; OS_EXIT_CRITICAL();
00002A2A  46DF      7600          dc.w      18143
                    7601   ; *perr = OS_ERR_NONE;
00002A2C  2044      7602          move.l    D4,A0
00002A2E  4210      7603          clr.b     (A0)
                    7604   ; return (0u);                                           /* No tasks waiting on mailbox              */
00002A30  4200      7605          clr.b     D0
                    7606   OSMboxPendAbort_3:
00002A32  4CDF 001C 7607          movem.l   (A7)+,D2/D3/D4
00002A36  4E5E      7608          unlk      A6
00002A38  4E75      7609          rts
                    7610   ; }
                    7611   ; #endif
                    7612   ; /*$PAGE*/
                    7613   ; /*
                    7614   ; *********************************************************************************************************
                    7615   ; *                                      POST MESSAGE TO A MAILBOX
                    7616   ; *
                    7617   ; * Description: This function sends a message to a mailbox
                    7618   ; *
                    7619   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7620   ; *
                    7621   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7622   ; *
                    7623   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7624   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7625   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7626   ; *                                   are allowed to send another one.
                    7627   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7628   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7629   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7630   ; *
                    7631   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7632   ; *********************************************************************************************************
                    7633   ; */
                    7634   ; #if OS_MBOX_POST_EN > 0u
                    7635   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7636   ; void      *pmsg)
                    7637   ; {
                    7638   _OSMboxPost:
00002A3A  4E56 0000 7639          link      A6,#0
00002A3E  2F02      7640          move.l    D2,-(A7)
00002A40  242E 0008 7641          move.l    8(A6),D2
                    7642   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7643   ; OS_CPU_SR  cpu_sr = 0u;
                    7644   ; #endif
                    7645   ; #if OS_ARG_CHK_EN > 0u
                    7646   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7647   ; return (OS_ERR_PEVENT_NULL);
                    7648   ; }
                    7649   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7650   ; return (OS_ERR_POST_NULL_PTR);
                    7651   ; }
                    7652   ; #endif
                    7653   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002A44  2042      7654          move.l    D2,A0
00002A46  1010      7655          move.b    (A0),D0
00002A48  0C00 0001 7656          cmp.b     #1,D0
00002A4C  6706      7657          beq.s     OSMboxPost_1
                    7658   ; return (OS_ERR_EVENT_TYPE);
00002A4E  7001      7659          moveq     #1,D0
00002A50  6000 004E 7660          bra       OSMboxPost_3
                    7661   OSMboxPost_1:
                    7662   ; }
                    7663   ; OS_ENTER_CRITICAL();
00002A54  40E7      7664          dc.w      16615
00002A56  007C      7665          dc.w      124
00002A58  0700      7666          dc.w      1792
                    7667   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002A5A  2042      7668          move.l    D2,A0
00002A5C  1028 0008 7669          move.b    8(A0),D0
00002A60  6724      7670          beq.s     OSMboxPost_4
                    7671   ; /* Ready HPT waiting on event                    */
                    7672   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002A62  42A7      7673          clr.l     -(A7)
00002A64  4878 0002 7674          pea       2
00002A68  2F2E 000C 7675          move.l    12(A6),-(A7)
00002A6C  2F02      7676          move.l    D2,-(A7)
00002A6E  4EB8 1236 7677          jsr       _OS_EventTaskRdy
00002A72  DEFC 0010 7678          add.w     #16,A7
00002A76  C0BC 0000 7679          and.l     #255,D0
00002A7A  00FF      
                    7680   ; OS_EXIT_CRITICAL();
00002A7C  46DF      7681          dc.w      18143
                    7682   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002A7E  4EB8 1816 7683          jsr       _OS_Sched
                    7684   ; return (OS_ERR_NONE);
00002A82  4200      7685          clr.b     D0
00002A84  601A      7686          bra.s     OSMboxPost_3
                    7687   OSMboxPost_4:
                    7688   ; }
                    7689   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002A86  2042      7690          move.l    D2,A0
00002A88  2028 0002 7691          move.l    2(A0),D0
00002A8C  6706      7692          beq.s     OSMboxPost_6
                    7693   ; OS_EXIT_CRITICAL();
00002A8E  46DF      7694          dc.w      18143
                    7695   ; return (OS_ERR_MBOX_FULL);
00002A90  7014      7696          moveq     #20,D0
00002A92  600C      7697          bra.s     OSMboxPost_3
                    7698   OSMboxPost_6:
                    7699   ; }
                    7700   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002A94  2042      7701          move.l    D2,A0
00002A96  216E 000C 7702          move.l    12(A6),2(A0)
00002A9A  0002      
                    7703   ; OS_EXIT_CRITICAL();
00002A9C  46DF      7704          dc.w      18143
                    7705   ; return (OS_ERR_NONE);
00002A9E  4200      7706          clr.b     D0
                    7707   OSMboxPost_3:
00002AA0  241F      7708          move.l    (A7)+,D2
00002AA2  4E5E      7709          unlk      A6
00002AA4  4E75      7710          rts
                    7711   ; }
                    7712   ; #endif
                    7713   ; /*$PAGE*/
                    7714   ; /*
                    7715   ; *********************************************************************************************************
                    7716   ; *                                      POST MESSAGE TO A MAILBOX
                    7717   ; *
                    7718   ; * Description: This function sends a message to a mailbox
                    7719   ; *
                    7720   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7721   ; *
                    7722   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7723   ; *
                    7724   ; *              opt           determines the type of POST performed:
                    7725   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7726   ; *                                                     (Identical to OSMboxPost())
                    7727   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7728   ; *
                    7729   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7730   ; *
                    7731   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7732   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7733   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7734   ; *                                   are allowed to send another one.
                    7735   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7736   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7737   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7738   ; *
                    7739   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7740   ; *
                    7741   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7742   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7743   ; *********************************************************************************************************
                    7744   ; */
                    7745   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7746   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7747   ; void      *pmsg,
                    7748   ; INT8U      opt)
                    7749   ; {
                    7750   _OSMboxPostOpt:
00002AA6  4E56 0000 7751          link      A6,#0
00002AAA  48E7 3000 7752          movem.l   D2/D3,-(A7)
00002AAE  242E 0008 7753          move.l    8(A6),D2
00002AB2  262E 000C 7754          move.l    12(A6),D3
                    7755   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7756   ; OS_CPU_SR  cpu_sr = 0u;
                    7757   ; #endif
                    7758   ; #if OS_ARG_CHK_EN > 0u
                    7759   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7760   ; return (OS_ERR_PEVENT_NULL);
                    7761   ; }
                    7762   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7763   ; return (OS_ERR_POST_NULL_PTR);
                    7764   ; }
                    7765   ; #endif
                    7766   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002AB6  2042      7767          move.l    D2,A0
00002AB8  1010      7768          move.b    (A0),D0
00002ABA  0C00 0001 7769          cmp.b     #1,D0
00002ABE  6706      7770          beq.s     OSMboxPostOpt_1
                    7771   ; return (OS_ERR_EVENT_TYPE);
00002AC0  7001      7772          moveq     #1,D0
00002AC2  6000 0084 7773          bra       OSMboxPostOpt_3
                    7774   OSMboxPostOpt_1:
                    7775   ; }
                    7776   ; OS_ENTER_CRITICAL();
00002AC6  40E7      7777          dc.w      16615
00002AC8  007C      7778          dc.w      124
00002ACA  0700      7779          dc.w      1792
                    7780   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002ACC  2042      7781          move.l    D2,A0
00002ACE  1028 0008 7782          move.b    8(A0),D0
00002AD2  6700 005C 7783          beq       OSMboxPostOpt_4
                    7784   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00002AD6  102E 0013 7785          move.b    19(A6),D0
00002ADA  C03C 0001 7786          and.b     #1,D0
00002ADE  6724      7787          beq.s     OSMboxPostOpt_6
                    7788   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7789   OSMboxPostOpt_8:
00002AE0  2042      7790          move.l    D2,A0
00002AE2  1028 0008 7791          move.b    8(A0),D0
00002AE6  671A      7792          beq.s     OSMboxPostOpt_10
                    7793   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002AE8  42A7      7794          clr.l     -(A7)
00002AEA  4878 0002 7795          pea       2
00002AEE  2F03      7796          move.l    D3,-(A7)
00002AF0  2F02      7797          move.l    D2,-(A7)
00002AF2  4EB8 1236 7798          jsr       _OS_EventTaskRdy
00002AF6  DEFC 0010 7799          add.w     #16,A7
00002AFA  C0BC 0000 7800          and.l     #255,D0
00002AFE  00FF      
00002B00  60DE      7801          bra       OSMboxPostOpt_8
                    7802   OSMboxPostOpt_10:
00002B02  6018      7803          bra.s     OSMboxPostOpt_7
                    7804   OSMboxPostOpt_6:
                    7805   ; }
                    7806   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7807   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002B04  42A7      7808          clr.l     -(A7)
00002B06  4878 0002 7809          pea       2
00002B0A  2F03      7810          move.l    D3,-(A7)
00002B0C  2F02      7811          move.l    D2,-(A7)
00002B0E  4EB8 1236 7812          jsr       _OS_EventTaskRdy
00002B12  DEFC 0010 7813          add.w     #16,A7
00002B16  C0BC 0000 7814          and.l     #255,D0
00002B1A  00FF      
                    7815   OSMboxPostOpt_7:
                    7816   ; }
                    7817   ; OS_EXIT_CRITICAL();
00002B1C  46DF      7818          dc.w      18143
                    7819   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00002B1E  102E 0013 7820          move.b    19(A6),D0
00002B22  C03C 0004 7821          and.b     #4,D0
00002B26  6604      7822          bne.s     OSMboxPostOpt_11
                    7823   ; OS_Sched();                               /* Find HPT ready to run                         */
00002B28  4EB8 1816 7824          jsr       _OS_Sched
                    7825   OSMboxPostOpt_11:
                    7826   ; }
                    7827   ; return (OS_ERR_NONE);
00002B2C  4200      7828          clr.b     D0
00002B2E  6018      7829          bra.s     OSMboxPostOpt_3
                    7830   OSMboxPostOpt_4:
                    7831   ; }
                    7832   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002B30  2042      7833          move.l    D2,A0
00002B32  2028 0002 7834          move.l    2(A0),D0
00002B36  6706      7835          beq.s     OSMboxPostOpt_13
                    7836   ; OS_EXIT_CRITICAL();
00002B38  46DF      7837          dc.w      18143
                    7838   ; return (OS_ERR_MBOX_FULL);
00002B3A  7014      7839          moveq     #20,D0
00002B3C  600A      7840          bra.s     OSMboxPostOpt_3
                    7841   OSMboxPostOpt_13:
                    7842   ; }
                    7843   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002B3E  2042      7844          move.l    D2,A0
00002B40  2143 0002 7845          move.l    D3,2(A0)
                    7846   ; OS_EXIT_CRITICAL();
00002B44  46DF      7847          dc.w      18143
                    7848   ; return (OS_ERR_NONE);
00002B46  4200      7849          clr.b     D0
                    7850   OSMboxPostOpt_3:
00002B48  4CDF 000C 7851          movem.l   (A7)+,D2/D3
00002B4C  4E5E      7852          unlk      A6
00002B4E  4E75      7853          rts
                    7854   ; }
                    7855   ; #endif
                    7856   ; /*$PAGE*/
                    7857   ; /*
                    7858   ; *********************************************************************************************************
                    7859   ; *                                       QUERY A MESSAGE MAILBOX
                    7860   ; *
                    7861   ; * Description: This function obtains information about a message mailbox.
                    7862   ; *
                    7863   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7864   ; *
                    7865   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7866   ; *                            mailbox.
                    7867   ; *
                    7868   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7869   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7870   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7871   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7872   ; *********************************************************************************************************
                    7873   ; */
                    7874   ; #if OS_MBOX_QUERY_EN > 0u
                    7875   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7876   ; OS_MBOX_DATA  *p_mbox_data)
                    7877   ; {
                    7878   _OSMboxQuery:
00002B50  4E56 FFF8 7879          link      A6,#-8
00002B54  48E7 3800 7880          movem.l   D2/D3/D4,-(A7)
00002B58  242E 0008 7881          move.l    8(A6),D2
00002B5C  282E 000C 7882          move.l    12(A6),D4
                    7883   ; INT8U       i;
                    7884   ; OS_PRIO    *psrc;
                    7885   ; OS_PRIO    *pdest;
                    7886   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7887   ; OS_CPU_SR   cpu_sr = 0u;
                    7888   ; #endif
                    7889   ; #if OS_ARG_CHK_EN > 0u
                    7890   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7891   ; return (OS_ERR_PEVENT_NULL);
                    7892   ; }
                    7893   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7894   ; return (OS_ERR_PDATA_NULL);
                    7895   ; }
                    7896   ; #endif
                    7897   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002B60  2042      7898          move.l    D2,A0
00002B62  1010      7899          move.b    (A0),D0
00002B64  0C00 0001 7900          cmp.b     #1,D0
00002B68  6706      7901          beq.s     OSMboxQuery_1
                    7902   ; return (OS_ERR_EVENT_TYPE);
00002B6A  7001      7903          moveq     #1,D0
00002B6C  6000 004C 7904          bra       OSMboxQuery_3
                    7905   OSMboxQuery_1:
                    7906   ; }
                    7907   ; OS_ENTER_CRITICAL();
00002B70  40E7      7908          dc.w      16615
00002B72  007C      7909          dc.w      124
00002B74  0700      7910          dc.w      1792
                    7911   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
00002B76  2042      7912          move.l    D2,A0
00002B78  2244      7913          move.l    D4,A1
00002B7A  1368 0008 7914          move.b    8(A0),12(A1)
00002B7E  000C      
                    7915   ; psrc                    = &pevent->OSEventTbl[0];
00002B80  700A      7916          moveq     #10,D0
00002B82  D082      7917          add.l     D2,D0
00002B84  2D40 FFF8 7918          move.l    D0,-8(A6)
                    7919   ; pdest                   = &p_mbox_data->OSEventTbl[0];
00002B88  7004      7920          moveq     #4,D0
00002B8A  D084      7921          add.l     D4,D0
00002B8C  2D40 FFFC 7922          move.l    D0,-4(A6)
                    7923   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002B90  4203      7924          clr.b     D3
                    7925   OSMboxQuery_4:
00002B92  0C03 0008 7926          cmp.b     #8,D3
00002B96  6416      7927          bhs.s     OSMboxQuery_6
                    7928   ; *pdest++ = *psrc++;
00002B98  206E FFF8 7929          move.l    -8(A6),A0
00002B9C  52AE FFF8 7930          addq.l    #1,-8(A6)
00002BA0  226E FFFC 7931          move.l    -4(A6),A1
00002BA4  52AE FFFC 7932          addq.l    #1,-4(A6)
00002BA8  1290      7933          move.b    (A0),(A1)
00002BAA  5203      7934          addq.b    #1,D3
00002BAC  60E4      7935          bra       OSMboxQuery_4
                    7936   OSMboxQuery_6:
                    7937   ; }
                    7938   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002BAE  2042      7939          move.l    D2,A0
00002BB0  2244      7940          move.l    D4,A1
00002BB2  22A8 0002 7941          move.l    2(A0),(A1)
                    7942   ; OS_EXIT_CRITICAL();
00002BB6  46DF      7943          dc.w      18143
                    7944   ; return (OS_ERR_NONE);
00002BB8  4200      7945          clr.b     D0
                    7946   OSMboxQuery_3:
00002BBA  4CDF 001C 7947          movem.l   (A7)+,D2/D3/D4
00002BBE  4E5E      7948          unlk      A6
00002BC0  4E75      7949          rts
                    7950   ; /*
                    7951   ; *********************************************************************************************************
                    7952   ; *                                                uC/OS-II
                    7953   ; *                                          The Real-Time Kernel
                    7954   ; *                                            MEMORY MANAGEMENT
                    7955   ; *
                    7956   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7957   ; *                                           All Rights Reserved
                    7958   ; *
                    7959   ; * File    : OS_MEM.C
                    7960   ; * By      : Jean J. Labrosse
                    7961   ; * Version : V2.92.07
                    7962   ; *
                    7963   ; * LICENSING TERMS:
                    7964   ; * ---------------
                    7965   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7966   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7967   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7968   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7969   ; * licensing fee.
                    7970   ; *********************************************************************************************************
                    7971   ; */
                    7972   ; #define  MICRIUM_SOURCE
                    7973   ; #ifndef  OS_MASTER_FILE
                    7974   ; #include <ucos_ii.h>
                    7975   ; #endif
                    7976   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    7977   ; /*
                    7978   ; *********************************************************************************************************
                    7979   ; *                                      CREATE A MEMORY PARTITION
                    7980   ; *
                    7981   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    7982   ; *
                    7983   ; * Arguments   : addr     is the starting address of the memory partition
                    7984   ; *
                    7985   ; *               nblks    is the number of memory blocks to create from the partition.
                    7986   ; *
                    7987   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    7988   ; *
                    7989   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    7990   ; *                        this function to either:
                    7991   ; *
                    7992   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    7993   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    7994   ; *                                                 storage of the partition or, the block does not align
                    7995   ; *                                                 on a pointer boundary
                    7996   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    7997   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    7998   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    7999   ; *                                                   - must be greater than the size of a pointer
                    8000   ; *                                                   - must be able to hold an integral number of pointers
                    8001   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    8002   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    8003   ; *                              free partition is available.
                    8004   ; *********************************************************************************************************
                    8005   ; */
                    8006   ; OS_MEM  *OSMemCreate (void   *addr,
                    8007   ; INT32U  nblks,
                    8008   ; INT32U  blksize,
                    8009   ; INT8U  *perr)
                    8010   ; {
                    8011   _OSMemCreate:
00002BC2  4E56 FFFC 8012          link      A6,#-4
00002BC6  48E7 3F20 8013          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002BCA  282E 0008 8014          move.l    8(A6),D4
00002BCE  45F9 0800 8015          lea       _OSMemFreeList.L,A2
00002BD2  1894      
00002BD4  2E2E 000C 8016          move.l    12(A6),D7
                    8017   ; OS_MEM    *pmem;
                    8018   ; INT8U     *pblk;
                    8019   ; void     **plink;
                    8020   ; INT32U     loops;
                    8021   ; INT32U     i;
                    8022   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8023   ; OS_CPU_SR  cpu_sr = 0u;
                    8024   ; #endif
                    8025   ; #ifdef OS_SAFETY_CRITICAL
                    8026   ; if (perr == (INT8U *)0) {
                    8027   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8028   ; return ((OS_MEM *)0);
                    8029   ; }
                    8030   ; #endif
                    8031   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8032   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8033   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8034   ; return ((OS_MEM *)0);
                    8035   ; }
                    8036   ; #endif
                    8037   ; #if OS_ARG_CHK_EN > 0u
                    8038   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    8039   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8040   ; return ((OS_MEM *)0);
                    8041   ; }
                    8042   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    8043   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8044   ; return ((OS_MEM *)0);
                    8045   ; }
                    8046   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    8047   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    8048   ; return ((OS_MEM *)0);
                    8049   ; }
                    8050   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    8051   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    8052   ; return ((OS_MEM *)0);
                    8053   ; }
                    8054   ; #endif
                    8055   ; OS_ENTER_CRITICAL();
00002BD8  40E7      8056          dc.w      16615
00002BDA  007C      8057          dc.w      124
00002BDC  0700      8058          dc.w      1792
                    8059   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
00002BDE  2412      8060          move.l    (A2),D2
                    8061   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
00002BE0  2012      8062          move.l    (A2),D0
00002BE2  6706      8063          beq.s     OSMemCreate_1
                    8064   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
00002BE4  2052      8065          move.l    (A2),A0
00002BE6  24A8 0004 8066          move.l    4(A0),(A2)
                    8067   OSMemCreate_1:
                    8068   ; }
                    8069   ; OS_EXIT_CRITICAL();
00002BEA  46DF      8070          dc.w      18143
                    8071   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
00002BEC  4A82      8072          tst.l     D2
00002BEE  660E      8073          bne.s     OSMemCreate_3
                    8074   ; *perr = OS_ERR_MEM_INVALID_PART;
00002BF0  206E 0014 8075          move.l    20(A6),A0
00002BF4  10BC 005A 8076          move.b    #90,(A0)
                    8077   ; return ((OS_MEM *)0);
00002BF8  4280      8078          clr.l     D0
00002BFA  6000 0050 8079          bra       OSMemCreate_5
                    8080   OSMemCreate_3:
                    8081   ; }
                    8082   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
00002BFE  2A04      8083          move.l    D4,D5
                    8084   ; pblk  = (INT8U *)addr;
00002C00  2604      8085          move.l    D4,D3
                    8086   ; loops  = nblks - 1u;
00002C02  2007      8087          move.l    D7,D0
00002C04  5380      8088          subq.l    #1,D0
00002C06  2D40 FFFC 8089          move.l    D0,-4(A6)
                    8090   ; for (i = 0u; i < loops; i++) {
00002C0A  4286      8091          clr.l     D6
                    8092   OSMemCreate_6:
00002C0C  BCAE FFFC 8093          cmp.l     -4(A6),D6
00002C10  6410      8094          bhs.s     OSMemCreate_8
                    8095   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
00002C12  202E 0010 8096          move.l    16(A6),D0
00002C16  D680      8097          add.l     D0,D3
                    8098   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
00002C18  2045      8099          move.l    D5,A0
00002C1A  2083      8100          move.l    D3,(A0)
                    8101   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
00002C1C  2A03      8102          move.l    D3,D5
00002C1E  5286      8103          addq.l    #1,D6
00002C20  60EA      8104          bra       OSMemCreate_6
                    8105   OSMemCreate_8:
                    8106   ; }
                    8107   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
00002C22  2045      8108          move.l    D5,A0
00002C24  4290      8109          clr.l     (A0)
                    8110   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
00002C26  2042      8111          move.l    D2,A0
00002C28  2084      8112          move.l    D4,(A0)
                    8113   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
00002C2A  2042      8114          move.l    D2,A0
00002C2C  2144 0004 8115          move.l    D4,4(A0)
                    8116   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
00002C30  2042      8117          move.l    D2,A0
00002C32  2147 0010 8118          move.l    D7,16(A0)
                    8119   ; pmem->OSMemNBlks    = nblks;
00002C36  2042      8120          move.l    D2,A0
00002C38  2147 000C 8121          move.l    D7,12(A0)
                    8122   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
00002C3C  2042      8123          move.l    D2,A0
00002C3E  216E 0010 8124          move.l    16(A6),8(A0)
00002C42  0008      
                    8125   ; *perr               = OS_ERR_NONE;
00002C44  206E 0014 8126          move.l    20(A6),A0
00002C48  4210      8127          clr.b     (A0)
                    8128   ; return (pmem);
00002C4A  2002      8129          move.l    D2,D0
                    8130   OSMemCreate_5:
00002C4C  4CDF 04FC 8131          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002C50  4E5E      8132          unlk      A6
00002C52  4E75      8133          rts
                    8134   ; }
                    8135   ; /*$PAGE*/
                    8136   ; /*
                    8137   ; *********************************************************************************************************
                    8138   ; *                                         GET A MEMORY BLOCK
                    8139   ; *
                    8140   ; * Description : Get a memory block from a partition
                    8141   ; *
                    8142   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8143   ; *
                    8144   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    8145   ; *                       function to either:
                    8146   ; *
                    8147   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    8148   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    8149   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    8150   ; *
                    8151   ; * Returns     : A pointer to a memory block if no error is detected
                    8152   ; *               A pointer to NULL if an error is detected
                    8153   ; *********************************************************************************************************
                    8154   ; */
                    8155   ; void  *OSMemGet (OS_MEM  *pmem,
                    8156   ; INT8U   *perr)
                    8157   ; {
                    8158   _OSMemGet:
00002C54  4E56 0000 8159          link      A6,#0
00002C58  48E7 3000 8160          movem.l   D2/D3,-(A7)
00002C5C  242E 0008 8161          move.l    8(A6),D2
                    8162   ; void      *pblk;
                    8163   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8164   ; OS_CPU_SR  cpu_sr = 0u;
                    8165   ; #endif
                    8166   ; #ifdef OS_SAFETY_CRITICAL
                    8167   ; if (perr == (INT8U *)0) {
                    8168   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8169   ; return ((void *)0);
                    8170   ; }
                    8171   ; #endif
                    8172   ; #if OS_ARG_CHK_EN > 0u
                    8173   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    8174   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8175   ; return ((void *)0);
                    8176   ; }
                    8177   ; #endif
                    8178   ; OS_ENTER_CRITICAL();
00002C60  40E7      8179          dc.w      16615
00002C62  007C      8180          dc.w      124
00002C64  0700      8181          dc.w      1792
                    8182   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002C66  2042      8183          move.l    D2,A0
00002C68  2028 0010 8184          move.l    16(A0),D0
00002C6C  0C80 0000 8185          cmp.l     #0,D0
00002C70  0000      
00002C72  6326      8186          bls.s     OSMemGet_1
                    8187   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002C74  2042      8188          move.l    D2,A0
00002C76  2628 0004 8189          move.l    4(A0),D3
                    8190   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
00002C7A  2043      8191          move.l    D3,A0
00002C7C  2242      8192          move.l    D2,A1
00002C7E  2350 0004 8193          move.l    (A0),4(A1)
                    8194   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002C82  2002      8195          move.l    D2,D0
00002C84  0680 0000 8196          add.l     #16,D0
00002C88  0010      
00002C8A  2040      8197          move.l    D0,A0
00002C8C  5390      8198          subq.l    #1,(A0)
                    8199   ; OS_EXIT_CRITICAL();
00002C8E  46DF      8200          dc.w      18143
                    8201   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002C90  206E 000C 8202          move.l    12(A6),A0
00002C94  4210      8203          clr.b     (A0)
                    8204   ; return (pblk);                                /*      Return memory block to caller            */
00002C96  2003      8205          move.l    D3,D0
00002C98  600C      8206          bra.s     OSMemGet_3
                    8207   OSMemGet_1:
                    8208   ; }
                    8209   ; OS_EXIT_CRITICAL();
00002C9A  46DF      8210          dc.w      18143
                    8211   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
00002C9C  206E 000C 8212          move.l    12(A6),A0
00002CA0  10BC 005D 8213          move.b    #93,(A0)
                    8214   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002CA4  4280      8215          clr.l     D0
                    8216   OSMemGet_3:
00002CA6  4CDF 000C 8217          movem.l   (A7)+,D2/D3
00002CAA  4E5E      8218          unlk      A6
00002CAC  4E75      8219          rts
                    8220   ; }
                    8221   ; /*$PAGE*/
                    8222   ; /*
                    8223   ; *********************************************************************************************************
                    8224   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    8225   ; *
                    8226   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    8227   ; *
                    8228   ; * Arguments  : pmem      is a pointer to the memory partition
                    8229   ; *
                    8230   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    8231   ; *
                    8232   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8233   ; *
                    8234   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8235   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8236   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8237   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    8238   ; *
                    8239   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    8240   ; *********************************************************************************************************
                    8241   ; */
                    8242   ; #if OS_MEM_NAME_EN > 0u
                    8243   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    8244   ; INT8U   **pname,
                    8245   ; INT8U    *perr)
                    8246   ; {
                    8247   _OSMemNameGet:
00002CAE  4E56 FFFC 8248          link      A6,#-4
                    8249   ; INT8U      len;
                    8250   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8251   ; OS_CPU_SR  cpu_sr = 0u;
                    8252   ; #endif
                    8253   ; #ifdef OS_SAFETY_CRITICAL
                    8254   ; if (perr == (INT8U *)0) {
                    8255   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8256   ; return (0u);
                    8257   ; }
                    8258   ; #endif
                    8259   ; #if OS_ARG_CHK_EN > 0u
                    8260   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8261   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8262   ; return (0u);
                    8263   ; }
                    8264   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    8265   ; *perr = OS_ERR_PNAME_NULL;
                    8266   ; return (0u);
                    8267   ; }
                    8268   ; #endif
                    8269   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002CB2  1039 0800 8270          move.b    _OSIntNesting.L,D0
00002CB6  0F06      
00002CB8  0C00 0000 8271          cmp.b     #0,D0
00002CBC  630C      8272          bls.s     OSMemNameGet_1
                    8273   ; *perr = OS_ERR_NAME_GET_ISR;
00002CBE  206E 0010 8274          move.l    16(A6),A0
00002CC2  10BC 0011 8275          move.b    #17,(A0)
                    8276   ; return (0u);
00002CC6  4200      8277          clr.b     D0
00002CC8  602E      8278          bra.s     OSMemNameGet_3
                    8279   OSMemNameGet_1:
                    8280   ; }
                    8281   ; OS_ENTER_CRITICAL();
00002CCA  40E7      8282          dc.w      16615
00002CCC  007C      8283          dc.w      124
00002CCE  0700      8284          dc.w      1792
                    8285   ; *pname = pmem->OSMemName;
00002CD0  206E 0008 8286          move.l    8(A6),A0
00002CD4  226E 000C 8287          move.l    12(A6),A1
00002CD8  22A8 0014 8288          move.l    20(A0),(A1)
                    8289   ; len    = OS_StrLen(*pname);
00002CDC  206E 000C 8290          move.l    12(A6),A0
00002CE0  2F10      8291          move.l    (A0),-(A7)
00002CE2  4EB8 18C0 8292          jsr       _OS_StrLen
00002CE6  584F      8293          addq.w    #4,A7
00002CE8  1D40 FFFF 8294          move.b    D0,-1(A6)
                    8295   ; OS_EXIT_CRITICAL();
00002CEC  46DF      8296          dc.w      18143
                    8297   ; *perr  = OS_ERR_NONE;
00002CEE  206E 0010 8298          move.l    16(A6),A0
00002CF2  4210      8299          clr.b     (A0)
                    8300   ; return (len);
00002CF4  102E FFFF 8301          move.b    -1(A6),D0
                    8302   OSMemNameGet_3:
00002CF8  4E5E      8303          unlk      A6
00002CFA  4E75      8304          rts
                    8305   ; }
                    8306   ; #endif
                    8307   ; /*$PAGE*/
                    8308   ; /*
                    8309   ; *********************************************************************************************************
                    8310   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8311   ; *
                    8312   ; * Description: This function assigns a name to a memory partition.
                    8313   ; *
                    8314   ; * Arguments  : pmem      is a pointer to the memory partition
                    8315   ; *
                    8316   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8317   ; *
                    8318   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8319   ; *
                    8320   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8321   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8322   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8323   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8324   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8325   ; *
                    8326   ; * Returns    : None
                    8327   ; *********************************************************************************************************
                    8328   ; */
                    8329   ; #if OS_MEM_NAME_EN > 0u
                    8330   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8331   ; INT8U   *pname,
                    8332   ; INT8U   *perr)
                    8333   ; {
                    8334   _OSMemNameSet:
00002CFC  4E56 0000 8335          link      A6,#0
                    8336   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8337   ; OS_CPU_SR  cpu_sr = 0u;
                    8338   ; #endif
                    8339   ; #ifdef OS_SAFETY_CRITICAL
                    8340   ; if (perr == (INT8U *)0) {
                    8341   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8342   ; return;
                    8343   ; }
                    8344   ; #endif
                    8345   ; #if OS_ARG_CHK_EN > 0u
                    8346   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8347   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8348   ; return;
                    8349   ; }
                    8350   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8351   ; *perr = OS_ERR_PNAME_NULL;
                    8352   ; return;
                    8353   ; }
                    8354   ; #endif
                    8355   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002D00  1039 0800 8356          move.b    _OSIntNesting.L,D0
00002D04  0F06      
00002D06  0C00 0000 8357          cmp.b     #0,D0
00002D0A  630A      8358          bls.s     OSMemNameSet_1
                    8359   ; *perr = OS_ERR_NAME_SET_ISR;
00002D0C  206E 0010 8360          move.l    16(A6),A0
00002D10  10BC 0012 8361          move.b    #18,(A0)
                    8362   ; return;
00002D14  6018      8363          bra.s     OSMemNameSet_3
                    8364   OSMemNameSet_1:
                    8365   ; }
                    8366   ; OS_ENTER_CRITICAL();
00002D16  40E7      8367          dc.w      16615
00002D18  007C      8368          dc.w      124
00002D1A  0700      8369          dc.w      1792
                    8370   ; pmem->OSMemName = pname;
00002D1C  206E 0008 8371          move.l    8(A6),A0
00002D20  216E 000C 8372          move.l    12(A6),20(A0)
00002D24  0014      
                    8373   ; OS_EXIT_CRITICAL();
00002D26  46DF      8374          dc.w      18143
                    8375   ; *perr           = OS_ERR_NONE;
00002D28  206E 0010 8376          move.l    16(A6),A0
00002D2C  4210      8377          clr.b     (A0)
                    8378   OSMemNameSet_3:
00002D2E  4E5E      8379          unlk      A6
00002D30  4E75      8380          rts
                    8381   ; }
                    8382   ; #endif
                    8383   ; /*$PAGE*/
                    8384   ; /*
                    8385   ; *********************************************************************************************************
                    8386   ; *                                       RELEASE A MEMORY BLOCK
                    8387   ; *
                    8388   ; * Description : Returns a memory block to a partition
                    8389   ; *
                    8390   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8391   ; *
                    8392   ; *               pblk    is a pointer to the memory block being released.
                    8393   ; *
                    8394   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8395   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8396   ; *                                        partition (You freed more blocks than you allocated!)
                    8397   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8398   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8399   ; *********************************************************************************************************
                    8400   ; */
                    8401   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8402   ; void    *pblk)
                    8403   ; {
                    8404   _OSMemPut:
00002D32  4E56 0000 8405          link      A6,#0
00002D36  2F02      8406          move.l    D2,-(A7)
00002D38  242E 0008 8407          move.l    8(A6),D2
                    8408   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8409   ; OS_CPU_SR  cpu_sr = 0u;
                    8410   ; #endif
                    8411   ; #if OS_ARG_CHK_EN > 0u
                    8412   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8413   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8414   ; }
                    8415   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8416   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8417   ; }
                    8418   ; #endif
                    8419   ; OS_ENTER_CRITICAL();
00002D3C  40E7      8420          dc.w      16615
00002D3E  007C      8421          dc.w      124
00002D40  0700      8422          dc.w      1792
                    8423   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002D42  2042      8424          move.l    D2,A0
00002D44  2242      8425          move.l    D2,A1
00002D46  2028 0010 8426          move.l    16(A0),D0
00002D4A  B0A9 000C 8427          cmp.l     12(A1),D0
00002D4E  6506      8428          blo.s     OSMemPut_1
                    8429   ; OS_EXIT_CRITICAL();
00002D50  46DF      8430          dc.w      18143
                    8431   ; return (OS_ERR_MEM_FULL);
00002D52  705E      8432          moveq     #94,D0
00002D54  6024      8433          bra.s     OSMemPut_3
                    8434   OSMemPut_1:
                    8435   ; }
                    8436   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002D56  2042      8437          move.l    D2,A0
00002D58  202E 000C 8438          move.l    12(A6),D0
00002D5C  2240      8439          move.l    D0,A1
00002D5E  22A8 0004 8440          move.l    4(A0),(A1)
                    8441   ; pmem->OSMemFreeList = pblk;
00002D62  2042      8442          move.l    D2,A0
00002D64  216E 000C 8443          move.l    12(A6),4(A0)
00002D68  0004      
                    8444   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
00002D6A  2002      8445          move.l    D2,D0
00002D6C  0680 0000 8446          add.l     #16,D0
00002D70  0010      
00002D72  2040      8447          move.l    D0,A0
00002D74  5290      8448          addq.l    #1,(A0)
                    8449   ; OS_EXIT_CRITICAL();
00002D76  46DF      8450          dc.w      18143
                    8451   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
00002D78  4200      8452          clr.b     D0
                    8453   OSMemPut_3:
00002D7A  241F      8454          move.l    (A7)+,D2
00002D7C  4E5E      8455          unlk      A6
00002D7E  4E75      8456          rts
                    8457   ; }
                    8458   ; /*$PAGE*/
                    8459   ; /*
                    8460   ; *********************************************************************************************************
                    8461   ; *                                       QUERY MEMORY PARTITION
                    8462   ; *
                    8463   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8464   ; *               used memory blocks from a memory partition.
                    8465   ; *
                    8466   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8467   ; *
                    8468   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8469   ; *                           partition.
                    8470   ; *
                    8471   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8472   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8473   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8474   ; *********************************************************************************************************
                    8475   ; */
                    8476   ; #if OS_MEM_QUERY_EN > 0u
                    8477   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8478   ; OS_MEM_DATA  *p_mem_data)
                    8479   ; {
                    8480   _OSMemQuery:
00002D80  4E56 0000 8481          link      A6,#0
00002D84  48E7 3000 8482          movem.l   D2/D3,-(A7)
00002D88  242E 000C 8483          move.l    12(A6),D2
00002D8C  262E 0008 8484          move.l    8(A6),D3
                    8485   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8486   ; OS_CPU_SR  cpu_sr = 0u;
                    8487   ; #endif
                    8488   ; #if OS_ARG_CHK_EN > 0u
                    8489   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8490   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8491   ; }
                    8492   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8493   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8494   ; }
                    8495   ; #endif
                    8496   ; OS_ENTER_CRITICAL();
00002D90  40E7      8497          dc.w      16615
00002D92  007C      8498          dc.w      124
00002D94  0700      8499          dc.w      1792
                    8500   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002D96  2043      8501          move.l    D3,A0
00002D98  2242      8502          move.l    D2,A1
00002D9A  2290      8503          move.l    (A0),(A1)
                    8504   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
00002D9C  2043      8505          move.l    D3,A0
00002D9E  2242      8506          move.l    D2,A1
00002DA0  2368 0004 8507          move.l    4(A0),4(A1)
00002DA4  0004      
                    8508   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002DA6  2043      8509          move.l    D3,A0
00002DA8  2242      8510          move.l    D2,A1
00002DAA  2368 0008 8511          move.l    8(A0),8(A1)
00002DAE  0008      
                    8512   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002DB0  2043      8513          move.l    D3,A0
00002DB2  2242      8514          move.l    D2,A1
00002DB4  2368 000C 8515          move.l    12(A0),12(A1)
00002DB8  000C      
                    8516   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
00002DBA  2043      8517          move.l    D3,A0
00002DBC  2242      8518          move.l    D2,A1
00002DBE  2368 0010 8519          move.l    16(A0),16(A1)
00002DC2  0010      
                    8520   ; OS_EXIT_CRITICAL();
00002DC4  46DF      8521          dc.w      18143
                    8522   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
00002DC6  2042      8523          move.l    D2,A0
00002DC8  2028 000C 8524          move.l    12(A0),D0
00002DCC  2042      8525          move.l    D2,A0
00002DCE  90A8 0010 8526          sub.l     16(A0),D0
00002DD2  2042      8527          move.l    D2,A0
00002DD4  2140 0014 8528          move.l    D0,20(A0)
                    8529   ; return (OS_ERR_NONE);
00002DD8  4200      8530          clr.b     D0
00002DDA  4CDF 000C 8531          movem.l   (A7)+,D2/D3
00002DDE  4E5E      8532          unlk      A6
00002DE0  4E75      8533          rts
                    8534   ; }
                    8535   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8536   ; /*$PAGE*/
                    8537   ; /*
                    8538   ; *********************************************************************************************************
                    8539   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8540   ; *
                    8541   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8542   ; *               application MUST NOT call this function.
                    8543   ; *
                    8544   ; * Arguments   : none
                    8545   ; *
                    8546   ; * Returns     : none
                    8547   ; *
                    8548   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8549   ; *********************************************************************************************************
                    8550   ; */
                    8551   ; void  OS_MemInit (void)
                    8552   ; {
                    8553   _OS_MemInit:
00002DE2  48E7 3020 8554          movem.l   D2/D3/A2,-(A7)
00002DE6  45F9 0800 8555          lea       _OSMemTbl.L,A2
00002DEA  1898      
                    8556   ; #if OS_MAX_MEM_PART == 1u
                    8557   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8558   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8559   ; #if OS_MEM_NAME_EN > 0u
                    8560   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8561   ; #endif
                    8562   ; #endif
                    8563   ; #if OS_MAX_MEM_PART >= 2u
                    8564   ; OS_MEM  *pmem;
                    8565   ; INT16U   i;
                    8566   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
00002DEC  4878 0078 8567          pea       120
00002DF0  2F0A      8568          move.l    A2,-(A7)
00002DF2  4EB8 17CA 8569          jsr       _OS_MemClr
00002DF6  504F      8570          addq.w    #8,A7
                    8571   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00002DF8  4243      8572          clr.w     D3
                    8573   OS_MemInit_1:
00002DFA  0C43 0004 8574          cmp.w     #4,D3
00002DFE  6400 003C 8575          bhs       OS_MemInit_3
                    8576   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
00002E02  200A      8577          move.l    A2,D0
00002E04  C6BC 0000 8578          and.l     #65535,D3
00002E08  FFFF      
00002E0A  2203      8579          move.l    D3,D1
00002E0C  C3FC 0018 8580          muls      #24,D1
00002E10  D081      8581          add.l     D1,D0
00002E12  2400      8582          move.l    D0,D2
                    8583   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
00002E14  200A      8584          move.l    A2,D0
00002E16  C6BC 0000 8585          and.l     #65535,D3
00002E1A  FFFF      
00002E1C  2203      8586          move.l    D3,D1
00002E1E  5281      8587          addq.l    #1,D1
00002E20  C3FC 0018 8588          muls      #24,D1
00002E24  D081      8589          add.l     D1,D0
00002E26  2042      8590          move.l    D2,A0
00002E28  2140 0004 8591          move.l    D0,4(A0)
                    8592   ; #if OS_MEM_NAME_EN > 0u
                    8593   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00002E2C  41F9 0000 8594          lea       @ucos_ii_1.L,A0
00002E30  68A4      
00002E32  2242      8595          move.l    D2,A1
00002E34  2348 0014 8596          move.l    A0,20(A1)
00002E38  5243      8597          addq.w    #1,D3
00002E3A  60BE      8598          bra       OS_MemInit_1
                    8599   OS_MemInit_3:
                    8600   ; #endif
                    8601   ; }
                    8602   ; pmem                = &OSMemTbl[i];
00002E3C  200A      8603          move.l    A2,D0
00002E3E  C6BC 0000 8604          and.l     #65535,D3
00002E42  FFFF      
00002E44  2203      8605          move.l    D3,D1
00002E46  C3FC 0018 8606          muls      #24,D1
00002E4A  D081      8607          add.l     D1,D0
00002E4C  2400      8608          move.l    D0,D2
                    8609   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00002E4E  2042      8610          move.l    D2,A0
00002E50  42A8 0004 8611          clr.l     4(A0)
                    8612   ; #if OS_MEM_NAME_EN > 0u
                    8613   ; pmem->OSMemName = (INT8U *)(void *)"?";
00002E54  41F9 0000 8614          lea       @ucos_ii_1.L,A0
00002E58  68A4      
00002E5A  2242      8615          move.l    D2,A1
00002E5C  2348 0014 8616          move.l    A0,20(A1)
                    8617   ; #endif
                    8618   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
00002E60  23CA 0800 8619          move.l    A2,_OSMemFreeList.L
00002E64  1894      
00002E66  4CDF 040C 8620          movem.l   (A7)+,D2/D3/A2
00002E6A  4E75      8621          rts
                    8622   ; /*
                    8623   ; *********************************************************************************************************
                    8624   ; *                                                uC/OS-II
                    8625   ; *                                          The Real-Time Kernel
                    8626   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8627   ; *
                    8628   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8629   ; *                                           All Rights Reserved
                    8630   ; *
                    8631   ; * File    : OS_MUTEX.C
                    8632   ; * By      : Jean J. Labrosse
                    8633   ; * Version : V2.92.07
                    8634   ; *
                    8635   ; * LICENSING TERMS:
                    8636   ; * ---------------
                    8637   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8638   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8639   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8640   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8641   ; * licensing fee.
                    8642   ; *********************************************************************************************************
                    8643   ; */
                    8644   ; #define  MICRIUM_SOURCE
                    8645   ; #ifndef  OS_MASTER_FILE
                    8646   ; #include <ucos_ii.h>
                    8647   ; #endif
                    8648   ; #if OS_MUTEX_EN > 0u
                    8649   ; /*
                    8650   ; *********************************************************************************************************
                    8651   ; *                                           LOCAL CONSTANTS
                    8652   ; *********************************************************************************************************
                    8653   ; */
                    8654   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8655   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8656   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8657   ; /*
                    8658   ; *********************************************************************************************************
                    8659   ; *                                           LOCAL CONSTANTS
                    8660   ; *********************************************************************************************************
                    8661   ; */
                    8662   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8663   ; /*$PAGE*/
                    8664   ; /*
                    8665   ; *********************************************************************************************************
                    8666   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8667   ; *
                    8668   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8669   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8670   ; *              not available or the event did not occur.
                    8671   ; *
                    8672   ; * Arguments  : pevent     is a pointer to the event control block
                    8673   ; *
                    8674   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8675   ; *                            OS_ERR_NONE         if the call was successful.
                    8676   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8677   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8678   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8679   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8680   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8681   ; *                                                indicates that you did not set the PCP higher (lower
                    8682   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8683   ; *                                                Unfortunately, this is something that could not be
                    8684   ; *                                                detected when the Mutex is created because we don't know
                    8685   ; *                                                what tasks will be using the Mutex.
                    8686   ; *
                    8687   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8688   ; *              == OS_FALSE   a) if the resource is not available
                    8689   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8690   ; *                            c) you called this function from an ISR
                    8691   ; *
                    8692   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8693   ; *              intended to be used by tasks only.
                    8694   ; *********************************************************************************************************
                    8695   ; */
                    8696   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8697   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8698   ; INT8U     *perr)
                    8699   ; {
                    8700   _OSMutexAccept:
00002E6C  4E56 0000 8701          link      A6,#0
00002E70  48E7 3820 8702          movem.l   D2/D3/D4/A2,-(A7)
00002E74  242E 0008 8703          move.l    8(A6),D2
00002E78  262E 000C 8704          move.l    12(A6),D3
00002E7C  45F9 0800 8705          lea       _OSTCBCur.L,A2
00002E80  1020      
                    8706   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8707   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8708   ; OS_CPU_SR  cpu_sr = 0u;
                    8709   ; #endif
                    8710   ; #ifdef OS_SAFETY_CRITICAL
                    8711   ; if (perr == (INT8U *)0) {
                    8712   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8713   ; return (OS_FALSE);
                    8714   ; }
                    8715   ; #endif
                    8716   ; #if OS_ARG_CHK_EN > 0u
                    8717   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8718   ; *perr = OS_ERR_PEVENT_NULL;
                    8719   ; return (OS_FALSE);
                    8720   ; }
                    8721   ; #endif
                    8722   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00002E82  2042      8723          move.l    D2,A0
00002E84  1010      8724          move.b    (A0),D0
00002E86  0C00 0004 8725          cmp.b     #4,D0
00002E8A  670C      8726          beq.s     OSMutexAccept_1
                    8727   ; *perr = OS_ERR_EVENT_TYPE;
00002E8C  2043      8728          move.l    D3,A0
00002E8E  10BC 0001 8729          move.b    #1,(A0)
                    8730   ; return (OS_FALSE);
00002E92  4200      8731          clr.b     D0
00002E94  6000 0084 8732          bra       OSMutexAccept_3
                    8733   OSMutexAccept_1:
                    8734   ; }
                    8735   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
00002E98  1039 0800 8736          move.b    _OSIntNesting.L,D0
00002E9C  0F06      
00002E9E  0C00 0000 8737          cmp.b     #0,D0
00002EA2  630C      8738          bls.s     OSMutexAccept_4
                    8739   ; *perr = OS_ERR_PEND_ISR;
00002EA4  2043      8740          move.l    D3,A0
00002EA6  10BC 0002 8741          move.b    #2,(A0)
                    8742   ; return (OS_FALSE);
00002EAA  4200      8743          clr.b     D0
00002EAC  6000 006C 8744          bra       OSMutexAccept_3
                    8745   OSMutexAccept_4:
                    8746   ; }
                    8747   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
00002EB0  40E7      8748          dc.w      16615
00002EB2  007C      8749          dc.w      124
00002EB4  0700      8750          dc.w      1792
                    8751   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00002EB6  2042      8752          move.l    D2,A0
00002EB8  3028 0006 8753          move.w    6(A0),D0
00002EBC  E048      8754          lsr.w     #8,D0
00002EBE  1800      8755          move.b    D0,D4
                    8756   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002EC0  2042      8757          move.l    D2,A0
00002EC2  3028 0006 8758          move.w    6(A0),D0
00002EC6  C07C 00FF 8759          and.w     #255,D0
00002ECA  0C40 00FF 8760          cmp.w     #255,D0
00002ECE  6600 0042 8761          bne       OSMutexAccept_6
                    8762   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
00002ED2  2042      8763          move.l    D2,A0
00002ED4  0268 FF00 8764          and.w     #65280,6(A0)
00002ED8  0006      
                    8765   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
00002EDA  2042      8766          move.l    D2,A0
00002EDC  2252      8767          move.l    (A2),A1
00002EDE  1029 0034 8768          move.b    52(A1),D0
00002EE2  C07C 00FF 8769          and.w     #255,D0
00002EE6  8168 0006 8770          or.w      D0,6(A0)
                    8771   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
00002EEA  2042      8772          move.l    D2,A0
00002EEC  2152 0002 8773          move.l    (A2),2(A0)
                    8774   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002EF0  0C04 00FF 8775          cmp.b     #255,D4
00002EF4  6712      8776          beq.s     OSMutexAccept_8
00002EF6  2052      8777          move.l    (A2),A0
00002EF8  B828 0034 8778          cmp.b     52(A0),D4
00002EFC  650A      8779          blo.s     OSMutexAccept_8
                    8780   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8781   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
00002EFE  46DF      8782          dc.w      18143
                    8783   ; *perr = OS_ERR_PCP_LOWER;
00002F00  2043      8784          move.l    D3,A0
00002F02  10BC 0078 8785          move.b    #120,(A0)
00002F06  6006      8786          bra.s     OSMutexAccept_9
                    8787   OSMutexAccept_8:
                    8788   ; } else {
                    8789   ; OS_EXIT_CRITICAL();
00002F08  46DF      8790          dc.w      18143
                    8791   ; *perr = OS_ERR_NONE;
00002F0A  2043      8792          move.l    D3,A0
00002F0C  4210      8793          clr.b     (A0)
                    8794   OSMutexAccept_9:
                    8795   ; }
                    8796   ; return (OS_TRUE);
00002F0E  7001      8797          moveq     #1,D0
00002F10  6008      8798          bra.s     OSMutexAccept_3
                    8799   OSMutexAccept_6:
                    8800   ; }
                    8801   ; OS_EXIT_CRITICAL();
00002F12  46DF      8802          dc.w      18143
                    8803   ; *perr = OS_ERR_NONE;
00002F14  2043      8804          move.l    D3,A0
00002F16  4210      8805          clr.b     (A0)
                    8806   ; return (OS_FALSE);
00002F18  4200      8807          clr.b     D0
                    8808   OSMutexAccept_3:
00002F1A  4CDF 041C 8809          movem.l   (A7)+,D2/D3/D4/A2
00002F1E  4E5E      8810          unlk      A6
00002F20  4E75      8811          rts
                    8812   ; }
                    8813   ; #endif
                    8814   ; /*$PAGE*/
                    8815   ; /*
                    8816   ; *********************************************************************************************************
                    8817   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8818   ; *
                    8819   ; * Description: This function creates a mutual exclusion semaphore.
                    8820   ; *
                    8821   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8822   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8823   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8824   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8825   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8826   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8827   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8828   ; *                            semaphore do not have their priority promoted.
                    8829   ; *
                    8830   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8831   ; *                               OS_ERR_NONE         if the call was successful.
                    8832   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8833   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8834   ; *                                                   already exist.
                    8835   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8836   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8837   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8838   ; *
                    8839   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8840   ; *                            created mutex.
                    8841   ; *              == (void *)0  if an error is detected.
                    8842   ; *
                    8843   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8844   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8845   ; *
                    8846   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8847   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8848   ; *                 promotion is disabled.
                    8849   ; *********************************************************************************************************
                    8850   ; */
                    8851   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8852   ; INT8U  *perr)
                    8853   ; {
                    8854   _OSMutexCreate:
00002F22  4E56 0000 8855          link      A6,#0
00002F26  48E7 3830 8856          movem.l   D2/D3/D4/A2/A3,-(A7)
00002F2A  162E 000B 8857          move.b    11(A6),D3
00002F2E  C6BC 0000 8858          and.l     #255,D3
00002F32  00FF      
00002F34  282E 000C 8859          move.l    12(A6),D4
00002F38  45F9 0800 8860          lea       _OSEventFreeList.L,A2
00002F3C  0CDA      
00002F3E  47F9 0800 8861          lea       _OSTCBPrioTbl.L,A3
00002F42  1030      
                    8862   ; OS_EVENT  *pevent;
                    8863   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8864   ; OS_CPU_SR  cpu_sr = 0u;
                    8865   ; #endif
                    8866   ; #ifdef OS_SAFETY_CRITICAL
                    8867   ; if (perr == (INT8U *)0) {
                    8868   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8869   ; return ((OS_EVENT *)0);
                    8870   ; }
                    8871   ; #endif
                    8872   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8873   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8874   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8875   ; return ((OS_EVENT *)0);
                    8876   ; }
                    8877   ; #endif
                    8878   ; #if OS_ARG_CHK_EN > 0u
                    8879   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8880   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8881   ; *perr = OS_ERR_PRIO_INVALID;
                    8882   ; return ((OS_EVENT *)0);
                    8883   ; }
                    8884   ; }
                    8885   ; #endif
                    8886   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002F44  1039 0800 8887          move.b    _OSIntNesting.L,D0
00002F48  0F06      
00002F4A  0C00 0000 8888          cmp.b     #0,D0
00002F4E  630C      8889          bls.s     OSMutexCreate_1
                    8890   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
00002F50  2044      8891          move.l    D4,A0
00002F52  10BC 0010 8892          move.b    #16,(A0)
                    8893   ; return ((OS_EVENT *)0);
00002F56  4280      8894          clr.l     D0
00002F58  6000 00A6 8895          bra       OSMutexCreate_3
                    8896   OSMutexCreate_1:
                    8897   ; }
                    8898   ; OS_ENTER_CRITICAL();
00002F5C  40E7      8899          dc.w      16615
00002F5E  007C      8900          dc.w      124
00002F60  0700      8901          dc.w      1792
                    8902   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002F62  0C03 00FF 8903          cmp.b     #255,D3
00002F66  6730      8904          beq.s     OSMutexCreate_4
                    8905   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00002F68  C6BC 0000 8906          and.l     #255,D3
00002F6C  00FF      
00002F6E  2003      8907          move.l    D3,D0
00002F70  E588      8908          lsl.l     #2,D0
00002F72  2033 0800 8909          move.l    0(A3,D0.L),D0
00002F76  670E      8910          beq.s     OSMutexCreate_6
                    8911   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00002F78  46DF      8912          dc.w      18143
                    8913   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00002F7A  2044      8914          move.l    D4,A0
00002F7C  10BC 0028 8915          move.b    #40,(A0)
                    8916   ; return ((OS_EVENT *)0);
00002F80  4280      8917          clr.l     D0
00002F82  6000 007C 8918          bra       OSMutexCreate_3
                    8919   OSMutexCreate_6:
                    8920   ; }
                    8921   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
00002F86  C6BC 0000 8922          and.l     #255,D3
00002F8A  00FF      
00002F8C  2003      8923          move.l    D3,D0
00002F8E  E588      8924          lsl.l     #2,D0
00002F90  27BC 0000 8925          move.l    #1,0(A3,D0.L)
00002F94  0001 0800 
                    8926   OSMutexCreate_4:
                    8927   ; }
                    8928   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00002F98  2412      8929          move.l    (A2),D2
                    8930   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
00002F9A  4A82      8931          tst.l     D2
00002F9C  6622      8932          bne.s     OSMutexCreate_8
                    8933   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002F9E  0C03 00FF 8934          cmp.b     #255,D3
00002FA2  670E      8935          beq.s     OSMutexCreate_10
                    8936   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
00002FA4  C6BC 0000 8937          and.l     #255,D3
00002FA8  00FF      
00002FAA  2003      8938          move.l    D3,D0
00002FAC  E588      8939          lsl.l     #2,D0
00002FAE  42B3 0800 8940          clr.l     0(A3,D0.L)
                    8941   OSMutexCreate_10:
                    8942   ; }
                    8943   ; OS_EXIT_CRITICAL();
00002FB2  46DF      8944          dc.w      18143
                    8945   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
00002FB4  2044      8946          move.l    D4,A0
00002FB6  10BC 0004 8947          move.b    #4,(A0)
                    8948   ; return (pevent);
00002FBA  2002      8949          move.l    D2,D0
00002FBC  6000 0042 8950          bra       OSMutexCreate_3
                    8951   OSMutexCreate_8:
                    8952   ; }
                    8953   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
00002FC0  2052      8954          move.l    (A2),A0
00002FC2  24A8 0002 8955          move.l    2(A0),(A2)
                    8956   ; OS_EXIT_CRITICAL();
00002FC6  46DF      8957          dc.w      18143
                    8958   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
00002FC8  2042      8959          move.l    D2,A0
00002FCA  10BC 0004 8960          move.b    #4,(A0)
                    8961   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
00002FCE  1003      8962          move.b    D3,D0
00002FD0  C07C 00FF 8963          and.w     #255,D0
00002FD4  E148      8964          lsl.w     #8,D0
00002FD6  807C 00FF 8965          or.w      #255,D0
00002FDA  2042      8966          move.l    D2,A0
00002FDC  3140 0006 8967          move.w    D0,6(A0)
                    8968   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
00002FE0  2042      8969          move.l    D2,A0
00002FE2  42A8 0002 8970          clr.l     2(A0)
                    8971   ; #if OS_EVENT_NAME_EN > 0u
                    8972   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002FE6  41F9 0000 8973          lea       @ucos_ii_1.L,A0
00002FEA  68A4      
00002FEC  2242      8974          move.l    D2,A1
00002FEE  2348 0012 8975          move.l    A0,18(A1)
                    8976   ; #endif
                    8977   ; OS_EventWaitListInit(pevent);
00002FF2  2F02      8978          move.l    D2,-(A7)
00002FF4  4EB8 14FE 8979          jsr       _OS_EventWaitListInit
00002FF8  584F      8980          addq.w    #4,A7
                    8981   ; *perr = OS_ERR_NONE;
00002FFA  2044      8982          move.l    D4,A0
00002FFC  4210      8983          clr.b     (A0)
                    8984   ; return (pevent);
00002FFE  2002      8985          move.l    D2,D0
                    8986   OSMutexCreate_3:
00003000  4CDF 0C1C 8987          movem.l   (A7)+,D2/D3/D4/A2/A3
00003004  4E5E      8988          unlk      A6
00003006  4E75      8989          rts
                    8990   ; }
                    8991   ; /*$PAGE*/
                    8992   ; /*
                    8993   ; *********************************************************************************************************
                    8994   ; *                                           DELETE A MUTEX
                    8995   ; *
                    8996   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    8997   ; *
                    8998   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    8999   ; *
                    9000   ; *              opt           determines delete options as follows:
                    9001   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    9002   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    9003   ; *                                                    In this case, all the tasks pending will be readied.
                    9004   ; *
                    9005   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    9006   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    9007   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    9008   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    9009   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    9010   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9011   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    9012   ; *
                    9013   ; * Returns    : pevent        upon error
                    9014   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    9015   ; *
                    9016   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    9017   ; *                 the mutex MUST check the return code of OSMutexPend().
                    9018   ; *
                    9019   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    9020   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    9021   ; *
                    9022   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    9023   ; *                 resource(s) will no longer be guarded by the mutex.
                    9024   ; *
                    9025   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    9026   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    9027   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    9028   ; *                            that task will be made ready-to-run at its original priority.
                    9029   ; *********************************************************************************************************
                    9030   ; */
                    9031   ; #if OS_MUTEX_DEL_EN > 0u
                    9032   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    9033   ; INT8U      opt,
                    9034   ; INT8U     *perr)
                    9035   ; {
                    9036   _OSMutexDel:
00003008  4E56 FFFC 9037          link      A6,#-4
0000300C  48E7 3F20 9038          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00003010  242E 0008 9039          move.l    8(A6),D2
00003014  282E 0010 9040          move.l    16(A6),D4
00003018  45F9 0800 9041          lea       _OSEventFreeList.L,A2
0000301C  0CDA      
                    9042   ; BOOLEAN    tasks_waiting;
                    9043   ; OS_EVENT  *pevent_return;
                    9044   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    9045   ; INT8U      prio;
                    9046   ; OS_TCB    *ptcb;
                    9047   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9048   ; OS_CPU_SR  cpu_sr = 0u;
                    9049   ; #endif
                    9050   ; #ifdef OS_SAFETY_CRITICAL
                    9051   ; if (perr == (INT8U *)0) {
                    9052   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9053   ; return ((OS_EVENT *)0);
                    9054   ; }
                    9055   ; #endif
                    9056   ; #if OS_ARG_CHK_EN > 0u
                    9057   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9058   ; *perr = OS_ERR_PEVENT_NULL;
                    9059   ; return (pevent);
                    9060   ; }
                    9061   ; #endif
                    9062   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
0000301E  2042      9063          move.l    D2,A0
00003020  1010      9064          move.b    (A0),D0
00003022  0C00 0004 9065          cmp.b     #4,D0
00003026  670C      9066          beq.s     OSMutexDel_1
                    9067   ; *perr = OS_ERR_EVENT_TYPE;
00003028  2044      9068          move.l    D4,A0
0000302A  10BC 0001 9069          move.b    #1,(A0)
                    9070   ; return (pevent);
0000302E  2002      9071          move.l    D2,D0
00003030  6000 017C 9072          bra       OSMutexDel_3
                    9073   OSMutexDel_1:
                    9074   ; }
                    9075   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003034  1039 0800 9076          move.b    _OSIntNesting.L,D0
00003038  0F06      
0000303A  0C00 0000 9077          cmp.b     #0,D0
0000303E  630C      9078          bls.s     OSMutexDel_4
                    9079   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
00003040  2044      9080          move.l    D4,A0
00003042  10BC 000F 9081          move.b    #15,(A0)
                    9082   ; return (pevent);
00003046  2002      9083          move.l    D2,D0
00003048  6000 0164 9084          bra       OSMutexDel_3
                    9085   OSMutexDel_4:
                    9086   ; }
                    9087   ; OS_ENTER_CRITICAL();
0000304C  40E7      9088          dc.w      16615
0000304E  007C      9089          dc.w      124
00003050  0700      9090          dc.w      1792
                    9091   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
00003052  2042      9092          move.l    D2,A0
00003054  1028 0008 9093          move.b    8(A0),D0
00003058  6704      9094          beq.s     OSMutexDel_6
                    9095   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
0000305A  7E01      9096          moveq     #1,D7
0000305C  6002      9097          bra.s     OSMutexDel_7
                    9098   OSMutexDel_6:
                    9099   ; } else {
                    9100   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000305E  7E00      9101          moveq     #0,D7
                    9102   OSMutexDel_7:
                    9103   ; }
                    9104   ; switch (opt) {
00003060  102E 000F 9105          move.b    15(A6),D0
00003064  C0BC 0000 9106          and.l     #255,D0
00003068  00FF      
0000306A  0C80 0000 9107          cmp.l     #1,D0
0000306E  0001      
00003070  6700 006E 9108          beq       OSMutexDel_11
00003074  6200 012C 9109          bhi       OSMutexDel_8
00003078  4A80      9110          tst.l     D0
0000307A  6704      9111          beq.s     OSMutexDel_10
0000307C  6000 0124 9112          bra       OSMutexDel_8
                    9113   OSMutexDel_10:
                    9114   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    9115   ; if (tasks_waiting == OS_FALSE) {
00003080  4A07      9116          tst.b     D7
00003082  6600 004E 9117          bne       OSMutexDel_13
                    9118   ; #if OS_EVENT_NAME_EN > 0u
                    9119   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00003086  41F9 0000 9120          lea       @ucos_ii_1.L,A0
0000308A  68A4      
0000308C  2242      9121          move.l    D2,A1
0000308E  2348 0012 9122          move.l    A0,18(A1)
                    9123   ; #endif
                    9124   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00003092  2042      9125          move.l    D2,A0
00003094  3028 0006 9126          move.w    6(A0),D0
00003098  E048      9127          lsr.w     #8,D0
0000309A  1600      9128          move.b    D0,D3
                    9129   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000309C  0C03 00FF 9130          cmp.b     #255,D3
000030A0  6714      9131          beq.s     OSMutexDel_15
                    9132   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
000030A2  C6BC 0000 9133          and.l     #255,D3
000030A6  00FF      
000030A8  2003      9134          move.l    D3,D0
000030AA  E588      9135          lsl.l     #2,D0
000030AC  41F9 0800 9136          lea       _OSTCBPrioTbl.L,A0
000030B0  1030      
000030B2  42B0 0800 9137          clr.l     0(A0,D0.L)
                    9138   OSMutexDel_15:
                    9139   ; }
                    9140   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
000030B6  2042      9141          move.l    D2,A0
000030B8  4210      9142          clr.b     (A0)
                    9143   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
000030BA  2042      9144          move.l    D2,A0
000030BC  2152 0002 9145          move.l    (A2),2(A0)
                    9146   ; pevent->OSEventCnt    = 0u;
000030C0  2042      9147          move.l    D2,A0
000030C2  4268 0006 9148          clr.w     6(A0)
                    9149   ; OSEventFreeList       = pevent;
000030C6  2482      9150          move.l    D2,(A2)
                    9151   ; OS_EXIT_CRITICAL();
000030C8  46DF      9152          dc.w      18143
                    9153   ; *perr                 = OS_ERR_NONE;
000030CA  2044      9154          move.l    D4,A0
000030CC  4210      9155          clr.b     (A0)
                    9156   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
000030CE  4285      9157          clr.l     D5
000030D0  600A      9158          bra.s     OSMutexDel_14
                    9159   OSMutexDel_13:
                    9160   ; } else {
                    9161   ; OS_EXIT_CRITICAL();
000030D2  46DF      9162          dc.w      18143
                    9163   ; *perr                 = OS_ERR_TASK_WAITING;
000030D4  2044      9164          move.l    D4,A0
000030D6  10BC 0049 9165          move.b    #73,(A0)
                    9166   ; pevent_return         = pevent;
000030DA  2A02      9167          move.l    D2,D5
                    9168   OSMutexDel_14:
                    9169   ; }
                    9170   ; break;
000030DC  6000 00CE 9171          bra       OSMutexDel_9
                    9172   OSMutexDel_11:
                    9173   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    9174   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
000030E0  2042      9175          move.l    D2,A0
000030E2  3028 0006 9176          move.w    6(A0),D0
000030E6  E048      9177          lsr.w     #8,D0
000030E8  1600      9178          move.b    D0,D3
                    9179   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000030EA  0C03 00FF 9180          cmp.b     #255,D3
000030EE  6700 0038 9181          beq       OSMutexDel_21
                    9182   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
000030F2  2042      9183          move.l    D2,A0
000030F4  3028 0006 9184          move.w    6(A0),D0
000030F8  C07C 00FF 9185          and.w     #255,D0
000030FC  1D40 FFFF 9186          move.b    D0,-1(A6)
                    9187   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
00003100  2042      9188          move.l    D2,A0
00003102  2C28 0002 9189          move.l    2(A0),D6
                    9190   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
00003106  4A86      9191          tst.l     D6
00003108  671E      9192          beq.s     OSMutexDel_21
                    9193   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
0000310A  2046      9194          move.l    D6,A0
0000310C  B628 0034 9195          cmp.b     52(A0),D3
00003110  6616      9196          bne.s     OSMutexDel_21
                    9197   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
00003112  122E FFFF 9198          move.b    -1(A6),D1
00003116  C2BC 0000 9199          and.l     #255,D1
0000311A  00FF      
0000311C  2F01      9200          move.l    D1,-(A7)
0000311E  2F06      9201          move.l    D6,-(A7)
00003120  4EB9 0000 9202          jsr       @ucos_ii_OSMutex_RdyAtPrio
00003124  3664      
00003126  504F      9203          addq.w    #8,A7
                    9204   OSMutexDel_21:
                    9205   ; }
                    9206   ; }
                    9207   ; }
                    9208   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    9209   OSMutexDel_23:
00003128  2042      9210          move.l    D2,A0
0000312A  1028 0008 9211          move.b    8(A0),D0
0000312E  671C      9212          beq.s     OSMutexDel_25
                    9213   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00003130  4878 0002 9214          pea       2
00003134  4878 0010 9215          pea       16
00003138  42A7      9216          clr.l     -(A7)
0000313A  2F02      9217          move.l    D2,-(A7)
0000313C  4EB8 1236 9218          jsr       _OS_EventTaskRdy
00003140  DEFC 0010 9219          add.w     #16,A7
00003144  C0BC 0000 9220          and.l     #255,D0
00003148  00FF      
0000314A  60DC      9221          bra       OSMutexDel_23
                    9222   OSMutexDel_25:
                    9223   ; }
                    9224   ; #if OS_EVENT_NAME_EN > 0u
                    9225   ; pevent->OSEventName   = (INT8U *)(void *)"?";
0000314C  41F9 0000 9226          lea       @ucos_ii_1.L,A0
00003150  68A4      
00003152  2242      9227          move.l    D2,A1
00003154  2348 0012 9228          move.l    A0,18(A1)
                    9229   ; #endif
                    9230   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00003158  2042      9231          move.l    D2,A0
0000315A  3028 0006 9232          move.w    6(A0),D0
0000315E  E048      9233          lsr.w     #8,D0
00003160  1600      9234          move.b    D0,D3
                    9235   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003162  0C03 00FF 9236          cmp.b     #255,D3
00003166  6714      9237          beq.s     OSMutexDel_26
                    9238   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
00003168  C6BC 0000 9239          and.l     #255,D3
0000316C  00FF      
0000316E  2003      9240          move.l    D3,D0
00003170  E588      9241          lsl.l     #2,D0
00003172  41F9 0800 9242          lea       _OSTCBPrioTbl.L,A0
00003176  1030      
00003178  42B0 0800 9243          clr.l     0(A0,D0.L)
                    9244   OSMutexDel_26:
                    9245   ; }
                    9246   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
0000317C  2042      9247          move.l    D2,A0
0000317E  4210      9248          clr.b     (A0)
                    9249   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
00003180  2042      9250          move.l    D2,A0
00003182  2152 0002 9251          move.l    (A2),2(A0)
                    9252   ; pevent->OSEventCnt    = 0u;
00003186  2042      9253          move.l    D2,A0
00003188  4268 0006 9254          clr.w     6(A0)
                    9255   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
0000318C  2482      9256          move.l    D2,(A2)
                    9257   ; OS_EXIT_CRITICAL();
0000318E  46DF      9258          dc.w      18143
                    9259   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003190  0C07 0001 9260          cmp.b     #1,D7
00003194  6604      9261          bne.s     OSMutexDel_28
                    9262   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003196  4EB8 1816 9263          jsr       _OS_Sched
                    9264   OSMutexDel_28:
                    9265   ; }
                    9266   ; *perr         = OS_ERR_NONE;
0000319A  2044      9267          move.l    D4,A0
0000319C  4210      9268          clr.b     (A0)
                    9269   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
0000319E  4285      9270          clr.l     D5
                    9271   ; break;
000031A0  600A      9272          bra.s     OSMutexDel_9
                    9273   OSMutexDel_8:
                    9274   ; default:
                    9275   ; OS_EXIT_CRITICAL();
000031A2  46DF      9276          dc.w      18143
                    9277   ; *perr         = OS_ERR_INVALID_OPT;
000031A4  2044      9278          move.l    D4,A0
000031A6  10BC 0007 9279          move.b    #7,(A0)
                    9280   ; pevent_return = pevent;
000031AA  2A02      9281          move.l    D2,D5
                    9282   ; break;
                    9283   OSMutexDel_9:
                    9284   ; }
                    9285   ; return (pevent_return);
000031AC  2005      9286          move.l    D5,D0
                    9287   OSMutexDel_3:
000031AE  4CDF 04FC 9288          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000031B2  4E5E      9289          unlk      A6
000031B4  4E75      9290          rts
                    9291   ; }
                    9292   ; #endif
                    9293   ; /*$PAGE*/
                    9294   ; /*
                    9295   ; *********************************************************************************************************
                    9296   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9297   ; *
                    9298   ; * Description: This function waits for a mutual exclusion semaphore.
                    9299   ; *
                    9300   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9301   ; *                            mutex.
                    9302   ; *
                    9303   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9304   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9305   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9306   ; *                            mutex or, until the resource becomes available.
                    9307   ; *
                    9308   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9309   ; *                            messages are:
                    9310   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9311   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9312   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9313   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9314   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9315   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9316   ; *                                                  would lead to a suspension.
                    9317   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9318   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9319   ; *                                                  indicates that you did not set the PCP higher (lower
                    9320   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9321   ; *                                                  Unfortunately, this is something that could not be
                    9322   ; *                                                  detected when the Mutex is created because we don't know
                    9323   ; *                                                  what tasks will be using the Mutex.
                    9324   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9325   ; *
                    9326   ; * Returns    : none
                    9327   ; *
                    9328   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9329   ; *
                    9330   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9331   ; *********************************************************************************************************
                    9332   ; */
                    9333   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9334   ; INT32U     timeout,
                    9335   ; INT8U     *perr)
                    9336   ; {
                    9337   _OSMutexPend:
000031B6  4E56 FFFC 9338          link      A6,#-4
000031BA  48E7 3F30 9339          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
000031BE  45F9 0800 9340          lea       _OSTCBCur.L,A2
000031C2  1020      
000031C4  262E 0008 9341          move.l    8(A6),D3
000031C8  2A2E 0010 9342          move.l    16(A6),D5
000031CC  47F9 0800 9343          lea       _OSRdyTbl.L,A3
000031D0  0F10      
                    9344   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9345   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9346   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9347   ; OS_TCB    *ptcb;
                    9348   ; OS_EVENT  *pevent2;
                    9349   ; INT8U      y;
                    9350   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9351   ; OS_CPU_SR  cpu_sr = 0u;
                    9352   ; #endif
                    9353   ; #ifdef OS_SAFETY_CRITICAL
                    9354   ; if (perr == (INT8U *)0) {
                    9355   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9356   ; return;
                    9357   ; }
                    9358   ; #endif
                    9359   ; #if OS_ARG_CHK_EN > 0u
                    9360   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9361   ; *perr = OS_ERR_PEVENT_NULL;
                    9362   ; return;
                    9363   ; }
                    9364   ; #endif
                    9365   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000031D2  2043      9366          move.l    D3,A0
000031D4  1010      9367          move.b    (A0),D0
000031D6  0C00 0004 9368          cmp.b     #4,D0
000031DA  670A      9369          beq.s     OSMutexPend_1
                    9370   ; *perr = OS_ERR_EVENT_TYPE;
000031DC  2045      9371          move.l    D5,A0
000031DE  10BC 0001 9372          move.b    #1,(A0)
                    9373   ; return;
000031E2  6000 02AC 9374          bra       OSMutexPend_3
                    9375   OSMutexPend_1:
                    9376   ; }
                    9377   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000031E6  1039 0800 9378          move.b    _OSIntNesting.L,D0
000031EA  0F06      
000031EC  0C00 0000 9379          cmp.b     #0,D0
000031F0  630A      9380          bls.s     OSMutexPend_4
                    9381   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000031F2  2045      9382          move.l    D5,A0
000031F4  10BC 0002 9383          move.b    #2,(A0)
                    9384   ; return;
000031F8  6000 0296 9385          bra       OSMutexPend_3
                    9386   OSMutexPend_4:
                    9387   ; }
                    9388   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
000031FC  1039 0800 9389          move.b    _OSLockNesting.L,D0
00003200  0F08      
00003202  0C00 0000 9390          cmp.b     #0,D0
00003206  630A      9391          bls.s     OSMutexPend_6
                    9392   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00003208  2045      9393          move.l    D5,A0
0000320A  10BC 000D 9394          move.b    #13,(A0)
                    9395   ; return;
0000320E  6000 0280 9396          bra       OSMutexPend_3
                    9397   OSMutexPend_6:
                    9398   ; }
                    9399   ; /*$PAGE*/
                    9400   ; OS_ENTER_CRITICAL();
00003212  40E7      9401          dc.w      16615
00003214  007C      9402          dc.w      124
00003216  0700      9403          dc.w      1792
                    9404   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
00003218  2043      9405          move.l    D3,A0
0000321A  3028 0006 9406          move.w    6(A0),D0
0000321E  E048      9407          lsr.w     #8,D0
00003220  1E00      9408          move.b    D0,D7
                    9409   ; /* Is Mutex available?                      */
                    9410   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00003222  2043      9411          move.l    D3,A0
00003224  3028 0006 9412          move.w    6(A0),D0
00003228  C07C 00FF 9413          and.w     #255,D0
0000322C  C07C 00FF 9414          and.w     #255,D0
00003230  0C40 00FF 9415          cmp.w     #255,D0
00003234  6600 0042 9416          bne       OSMutexPend_8
                    9417   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
00003238  2043      9418          move.l    D3,A0
0000323A  0268 FF00 9419          and.w     #65280,6(A0)
0000323E  0006      
                    9420   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
00003240  2043      9421          move.l    D3,A0
00003242  2252      9422          move.l    (A2),A1
00003244  1029 0034 9423          move.b    52(A1),D0
00003248  C07C 00FF 9424          and.w     #255,D0
0000324C  8168 0006 9425          or.w      D0,6(A0)
                    9426   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
00003250  2043      9427          move.l    D3,A0
00003252  2152 0002 9428          move.l    (A2),2(A0)
                    9429   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00003256  0C07 00FF 9430          cmp.b     #255,D7
0000325A  6712      9431          beq.s     OSMutexPend_10
0000325C  2052      9432          move.l    (A2),A0
0000325E  BE28 0034 9433          cmp.b     52(A0),D7
00003262  650A      9434          blo.s     OSMutexPend_10
                    9435   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9436   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00003264  46DF      9437          dc.w      18143
                    9438   ; *perr = OS_ERR_PCP_LOWER;
00003266  2045      9439          move.l    D5,A0
00003268  10BC 0078 9440          move.b    #120,(A0)
0000326C  6006      9441          bra.s     OSMutexPend_11
                    9442   OSMutexPend_10:
                    9443   ; } else {
                    9444   ; OS_EXIT_CRITICAL();
0000326E  46DF      9445          dc.w      18143
                    9446   ; *perr = OS_ERR_NONE;
00003270  2045      9447          move.l    D5,A0
00003272  4210      9448          clr.b     (A0)
                    9449   OSMutexPend_11:
                    9450   ; }
                    9451   ; return;
00003274  6000 021A 9452          bra       OSMutexPend_3
                    9453   OSMutexPend_8:
                    9454   ; }
                    9455   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003278  0C07 00FF 9456          cmp.b     #255,D7
0000327C  6700 018A 9457          beq       OSMutexPend_16
                    9458   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
00003280  2043      9459          move.l    D3,A0
00003282  3028 0006 9460          move.w    6(A0),D0
00003286  C07C 00FF 9461          and.w     #255,D0
0000328A  1D40 FFFE 9462          move.b    D0,-2(A6)
                    9463   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
0000328E  2043      9464          move.l    D3,A0
00003290  2428 0002 9465          move.l    2(A0),D2
                    9466   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
00003294  2042      9467          move.l    D2,A0
00003296  BE28 0034 9468          cmp.b     52(A0),D7
0000329A  6400 016C 9469          bhs       OSMutexPend_16
                    9470   ; if (mprio > OSTCBCur->OSTCBPrio) {
0000329E  2052      9471          move.l    (A2),A0
000032A0  102E FFFE 9472          move.b    -2(A6),D0
000032A4  B028 0034 9473          cmp.b     52(A0),D0
000032A8  6300 015E 9474          bls       OSMutexPend_16
                    9475   ; y = ptcb->OSTCBY;
000032AC  2042      9476          move.l    D2,A0
000032AE  1C28 0036 9477          move.b    54(A0),D6
                    9478   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
000032B2  CCBC 0000 9479          and.l     #255,D6
000032B6  00FF      
000032B8  1033 6800 9480          move.b    0(A3,D6.L),D0
000032BC  2042      9481          move.l    D2,A0
000032BE  C028 0037 9482          and.b     55(A0),D0
000032C2  6736      9483          beq.s     OSMutexPend_18
                    9484   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
000032C4  CCBC 0000 9485          and.l     #255,D6
000032C8  00FF      
000032CA  2042      9486          move.l    D2,A0
000032CC  1028 0037 9487          move.b    55(A0),D0
000032D0  4600      9488          not.b     D0
000032D2  C133 6800 9489          and.b     D0,0(A3,D6.L)
                    9490   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
000032D6  CCBC 0000 9491          and.l     #255,D6
000032DA  00FF      
000032DC  1033 6800 9492          move.b    0(A3,D6.L),D0
000032E0  660E      9493          bne.s     OSMutexPend_20
                    9494   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000032E2  2042      9495          move.l    D2,A0
000032E4  1028 0038 9496          move.b    56(A0),D0
000032E8  4600      9497          not.b     D0
000032EA  C139 0800 9498          and.b     D0,_OSRdyGrp.L
000032EE  0F0E      
                    9499   OSMutexPend_20:
                    9500   ; }
                    9501   ; rdy = OS_TRUE;
000032F0  1D7C 0001 9502          move.b    #1,-1(A6)
000032F4  FFFF      
000032F6  6000 004C 9503          bra       OSMutexPend_19
                    9504   OSMutexPend_18:
                    9505   ; } else {
                    9506   ; pevent2 = ptcb->OSTCBEventPtr;
000032FA  2042      9507          move.l    D2,A0
000032FC  2828 001C 9508          move.l    28(A0),D4
                    9509   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
00003300  4A84      9510          tst.l     D4
00003302  6700 003C 9511          beq       OSMutexPend_24
                    9512   ; y = ptcb->OSTCBY;
00003306  2042      9513          move.l    D2,A0
00003308  1C28 0036 9514          move.b    54(A0),D6
                    9515   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
0000330C  2044      9516          move.l    D4,A0
0000330E  CCBC 0000 9517          and.l     #255,D6
00003312  00FF      
00003314  D1C6      9518          add.l     D6,A0
00003316  2242      9519          move.l    D2,A1
00003318  1029 0037 9520          move.b    55(A1),D0
0000331C  4600      9521          not.b     D0
0000331E  C128 000A 9522          and.b     D0,10(A0)
                    9523   ; if (pevent2->OSEventTbl[y] == 0u) {
00003322  2044      9524          move.l    D4,A0
00003324  CCBC 0000 9525          and.l     #255,D6
00003328  00FF      
0000332A  D1C6      9526          add.l     D6,A0
0000332C  1028 000A 9527          move.b    10(A0),D0
00003330  660E      9528          bne.s     OSMutexPend_24
                    9529   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00003332  2044      9530          move.l    D4,A0
00003334  2242      9531          move.l    D2,A1
00003336  1029 0038 9532          move.b    56(A1),D0
0000333A  4600      9533          not.b     D0
0000333C  C128 0008 9534          and.b     D0,8(A0)
                    9535   OSMutexPend_24:
                    9536   ; }
                    9537   ; }
                    9538   ; rdy = OS_FALSE;                        /* No                                       */
00003340  422E FFFF 9539          clr.b     -1(A6)
                    9540   OSMutexPend_19:
                    9541   ; }
                    9542   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
00003344  2042      9543          move.l    D2,A0
00003346  1147 0034 9544          move.b    D7,52(A0)
                    9545   ; #if OS_LOWEST_PRIO <= 63u
                    9546   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
0000334A  2042      9547          move.l    D2,A0
0000334C  1028 0034 9548          move.b    52(A0),D0
00003350  E608      9549          lsr.b     #3,D0
00003352  2042      9550          move.l    D2,A0
00003354  1140 0036 9551          move.b    D0,54(A0)
                    9552   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
00003358  2042      9553          move.l    D2,A0
0000335A  1028 0034 9554          move.b    52(A0),D0
0000335E  C03C 0007 9555          and.b     #7,D0
00003362  2042      9556          move.l    D2,A0
00003364  1140 0035 9557          move.b    D0,53(A0)
                    9558   ; #else
                    9559   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9560   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9561   ; #endif
                    9562   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
00003368  7001      9563          moveq     #1,D0
0000336A  2042      9564          move.l    D2,A0
0000336C  1228 0036 9565          move.b    54(A0),D1
00003370  C2BC 0000 9566          and.l     #255,D1
00003374  00FF      
00003376  E3A8      9567          lsl.l     D1,D0
00003378  2042      9568          move.l    D2,A0
0000337A  1140 0038 9569          move.b    D0,56(A0)
                    9570   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
0000337E  7001      9571          moveq     #1,D0
00003380  2042      9572          move.l    D2,A0
00003382  1228 0035 9573          move.b    53(A0),D1
00003386  C2BC 0000 9574          and.l     #255,D1
0000338A  00FF      
0000338C  E3A8      9575          lsl.l     D1,D0
0000338E  2042      9576          move.l    D2,A0
00003390  1140 0037 9577          move.b    D0,55(A0)
                    9578   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
00003394  102E FFFF 9579          move.b    -1(A6),D0
00003398  0C00 0001 9580          cmp.b     #1,D0
0000339C  6626      9581          bne.s     OSMutexPend_26
                    9582   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
0000339E  2042      9583          move.l    D2,A0
000033A0  1028 0038 9584          move.b    56(A0),D0
000033A4  8139 0800 9585          or.b      D0,_OSRdyGrp.L
000033A8  0F0E      
                    9586   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000033AA  2042      9587          move.l    D2,A0
000033AC  1028 0036 9588          move.b    54(A0),D0
000033B0  C0BC 0000 9589          and.l     #255,D0
000033B4  00FF      
000033B6  2042      9590          move.l    D2,A0
000033B8  1228 0037 9591          move.b    55(A0),D1
000033BC  8333 0800 9592          or.b      D1,0(A3,D0.L)
000033C0  6000 0032 9593          bra       OSMutexPend_28
                    9594   OSMutexPend_26:
                    9595   ; } else {
                    9596   ; pevent2 = ptcb->OSTCBEventPtr;
000033C4  2042      9597          move.l    D2,A0
000033C6  2828 001C 9598          move.l    28(A0),D4
                    9599   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
000033CA  4A84      9600          tst.l     D4
000033CC  6726      9601          beq.s     OSMutexPend_28
                    9602   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
000033CE  2044      9603          move.l    D4,A0
000033D0  2242      9604          move.l    D2,A1
000033D2  1029 0038 9605          move.b    56(A1),D0
000033D6  8128 0008 9606          or.b      D0,8(A0)
                    9607   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000033DA  2044      9608          move.l    D4,A0
000033DC  2242      9609          move.l    D2,A1
000033DE  1029 0036 9610          move.b    54(A1),D0
000033E2  C0BC 0000 9611          and.l     #255,D0
000033E6  00FF      
000033E8  D1C0      9612          add.l     D0,A0
000033EA  2242      9613          move.l    D2,A1
000033EC  1029 0037 9614          move.b    55(A1),D0
000033F0  8128 000A 9615          or.b      D0,10(A0)
                    9616   OSMutexPend_28:
                    9617   ; }
                    9618   ; }
                    9619   ; OSTCBPrioTbl[pcp] = ptcb;
000033F4  CEBC 0000 9620          and.l     #255,D7
000033F8  00FF      
000033FA  2007      9621          move.l    D7,D0
000033FC  E588      9622          lsl.l     #2,D0
000033FE  41F9 0800 9623          lea       _OSTCBPrioTbl.L,A0
00003402  1030      
00003404  2182 0800 9624          move.l    D2,0(A0,D0.L)
                    9625   OSMutexPend_16:
                    9626   ; }
                    9627   ; }
                    9628   ; }
                    9629   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
00003408  2052      9630          move.l    (A2),A0
0000340A  0028 0010 9631          or.b      #16,50(A0)
0000340E  0032      
                    9632   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003410  2052      9633          move.l    (A2),A0
00003412  4228 0033 9634          clr.b     51(A0)
                    9635   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
00003416  2052      9636          move.l    (A2),A0
00003418  216E 000C 9637          move.l    12(A6),46(A0)
0000341C  002E      
                    9638   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
0000341E  2F03      9639          move.l    D3,-(A7)
00003420  4EB8 131A 9640          jsr       _OS_EventTaskWait
00003424  584F      9641          addq.w    #4,A7
                    9642   ; OS_EXIT_CRITICAL();
00003426  46DF      9643          dc.w      18143
                    9644   ; OS_Sched();                                       /* Find next highest priority task ready         */
00003428  4EB8 1816 9645          jsr       _OS_Sched
                    9646   ; OS_ENTER_CRITICAL();
0000342C  40E7      9647          dc.w      16615
0000342E  007C      9648          dc.w      124
00003430  0700      9649          dc.w      1792
                    9650   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003432  2052      9651          move.l    (A2),A0
00003434  1028 0033 9652          move.b    51(A0),D0
00003438  C0BC 0000 9653          and.l     #255,D0
0000343C  00FF      
0000343E  0C80 0000 9654          cmp.l     #1,D0
00003442  0001      
00003444  6720      9655          beq.s     OSMutexPend_34
00003446  6206      9656          bhi.s     OSMutexPend_36
00003448  4A80      9657          tst.l     D0
0000344A  670C      9658          beq.s     OSMutexPend_32
0000344C  6018      9659          bra.s     OSMutexPend_34
                    9660   OSMutexPend_36:
0000344E  0C80 0000 9661          cmp.l     #2,D0
00003452  0002      
00003454  6708      9662          beq.s     OSMutexPend_33
00003456  600E      9663          bra.s     OSMutexPend_34
                    9664   OSMutexPend_32:
                    9665   ; case OS_STAT_PEND_OK:
                    9666   ; *perr = OS_ERR_NONE;
00003458  2045      9667          move.l    D5,A0
0000345A  4210      9668          clr.b     (A0)
                    9669   ; break;
0000345C  6018      9670          bra.s     OSMutexPend_31
                    9671   OSMutexPend_33:
                    9672   ; case OS_STAT_PEND_ABORT:
                    9673   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
0000345E  2045      9674          move.l    D5,A0
00003460  10BC 000E 9675          move.b    #14,(A0)
                    9676   ; break;
00003464  6010      9677          bra.s     OSMutexPend_31
                    9678   OSMutexPend_34:
                    9679   ; case OS_STAT_PEND_TO:
                    9680   ; default:
                    9681   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003466  2F03      9682          move.l    D3,-(A7)
00003468  2F12      9683          move.l    (A2),-(A7)
0000346A  4EB8 143C 9684          jsr       _OS_EventTaskRemove
0000346E  504F      9685          addq.w    #8,A7
                    9686   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
00003470  2045      9687          move.l    D5,A0
00003472  10BC 000A 9688          move.b    #10,(A0)
                    9689   ; break;
                    9690   OSMutexPend_31:
                    9691   ; }
                    9692   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003476  2052      9693          move.l    (A2),A0
00003478  4228 0032 9694          clr.b     50(A0)
                    9695   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000347C  2052      9696          move.l    (A2),A0
0000347E  4228 0033 9697          clr.b     51(A0)
                    9698   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003482  2052      9699          move.l    (A2),A0
00003484  42A8 001C 9700          clr.l     28(A0)
                    9701   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9702   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003488  2052      9703          move.l    (A2),A0
0000348A  42A8 0020 9704          clr.l     32(A0)
                    9705   ; #endif
                    9706   ; OS_EXIT_CRITICAL();
0000348E  46DF      9707          dc.w      18143
                    9708   OSMutexPend_3:
00003490  4CDF 0CFC 9709          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
00003494  4E5E      9710          unlk      A6
00003496  4E75      9711          rts
                    9712   ; }
                    9713   ; /*$PAGE*/
                    9714   ; /*
                    9715   ; *********************************************************************************************************
                    9716   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9717   ; *
                    9718   ; * Description: This function signals a mutual exclusion semaphore
                    9719   ; *
                    9720   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9721   ; *                                  mutex.
                    9722   ; *
                    9723   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9724   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9725   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9726   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9727   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9728   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9729   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9730   ; *                                      indicates that you did not set the PCP higher (lower
                    9731   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9732   ; *                                      Unfortunately, this is something that could not be
                    9733   ; *                                      detected when the Mutex is created because we don't know
                    9734   ; *                                      what tasks will be using the Mutex.
                    9735   ; *********************************************************************************************************
                    9736   ; */
                    9737   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9738   ; {
                    9739   _OSMutexPost:
00003498  4E56 0000 9740          link      A6,#0
0000349C  48E7 3820 9741          movem.l   D2/D3/D4/A2,-(A7)
000034A0  242E 0008 9742          move.l    8(A6),D2
000034A4  45F9 0800 9743          lea       _OSTCBCur.L,A2
000034A8  1020      
                    9744   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9745   ; INT8U      prio;
                    9746   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9747   ; OS_CPU_SR  cpu_sr = 0u;
                    9748   ; #endif
                    9749   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000034AA  1039 0800 9750          move.b    _OSIntNesting.L,D0
000034AE  0F06      
000034B0  0C00 0000 9751          cmp.b     #0,D0
000034B4  6306      9752          bls.s     OSMutexPost_1
                    9753   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
000034B6  7005      9754          moveq     #5,D0
000034B8  6000 00F0 9755          bra       OSMutexPost_3
                    9756   OSMutexPost_1:
                    9757   ; }
                    9758   ; #if OS_ARG_CHK_EN > 0u
                    9759   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9760   ; return (OS_ERR_PEVENT_NULL);
                    9761   ; }
                    9762   ; #endif
                    9763   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
000034BC  2042      9764          move.l    D2,A0
000034BE  1010      9765          move.b    (A0),D0
000034C0  0C00 0004 9766          cmp.b     #4,D0
000034C4  6706      9767          beq.s     OSMutexPost_4
                    9768   ; return (OS_ERR_EVENT_TYPE);
000034C6  7001      9769          moveq     #1,D0
000034C8  6000 00E0 9770          bra       OSMutexPost_3
                    9771   OSMutexPost_4:
                    9772   ; }
                    9773   ; OS_ENTER_CRITICAL();
000034CC  40E7      9774          dc.w      16615
000034CE  007C      9775          dc.w      124
000034D0  0700      9776          dc.w      1792
                    9777   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
000034D2  2042      9778          move.l    D2,A0
000034D4  3028 0006 9779          move.w    6(A0),D0
000034D8  E048      9780          lsr.w     #8,D0
000034DA  1800      9781          move.b    D0,D4
                    9782   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
000034DC  2042      9783          move.l    D2,A0
000034DE  3028 0006 9784          move.w    6(A0),D0
000034E2  C07C 00FF 9785          and.w     #255,D0
000034E6  1600      9786          move.b    D0,D3
                    9787   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
000034E8  2042      9788          move.l    D2,A0
000034EA  2012      9789          move.l    (A2),D0
000034EC  B0A8 0002 9790          cmp.l     2(A0),D0
000034F0  6708      9791          beq.s     OSMutexPost_6
                    9792   ; OS_EXIT_CRITICAL();
000034F2  46DF      9793          dc.w      18143
                    9794   ; return (OS_ERR_NOT_MUTEX_OWNER);
000034F4  7064      9795          moveq     #100,D0
000034F6  6000 00B2 9796          bra       OSMutexPost_3
                    9797   OSMutexPost_6:
                    9798   ; }
                    9799   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000034FA  0C04 00FF 9800          cmp.b     #255,D4
000034FE  6732      9801          beq.s     OSMutexPost_8
                    9802   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
00003500  2052      9803          move.l    (A2),A0
00003502  B828 0034 9804          cmp.b     52(A0),D4
00003506  6612      9805          bne.s     OSMutexPost_10
                    9806   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
00003508  C6BC 0000 9807          and.l     #255,D3
0000350C  00FF      
0000350E  2F03      9808          move.l    D3,-(A7)
00003510  2F12      9809          move.l    (A2),-(A7)
00003512  4EB9 0000 9810          jsr       @ucos_ii_OSMutex_RdyAtPrio
00003516  3664      
00003518  504F      9811          addq.w    #8,A7
                    9812   OSMutexPost_10:
                    9813   ; }
                    9814   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
0000351A  C8BC 0000 9815          and.l     #255,D4
0000351E  00FF      
00003520  2004      9816          move.l    D4,D0
00003522  E588      9817          lsl.l     #2,D0
00003524  41F9 0800 9818          lea       _OSTCBPrioTbl.L,A0
00003528  1030      
0000352A  21BC 0000 9819          move.l    #1,0(A0,D0.L)
0000352E  0001 0800 
                    9820   OSMutexPost_8:
                    9821   ; }
                    9822   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
00003532  2042      9823          move.l    D2,A0
00003534  1028 0008 9824          move.b    8(A0),D0
00003538  6700 005E 9825          beq       OSMutexPost_12
                    9826   ; /* Yes, Make HPT waiting for mutex ready         */
                    9827   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
0000353C  42A7      9828          clr.l     -(A7)
0000353E  4878 0010 9829          pea       16
00003542  42A7      9830          clr.l     -(A7)
00003544  2F02      9831          move.l    D2,-(A7)
00003546  4EB8 1236 9832          jsr       _OS_EventTaskRdy
0000354A  DEFC 0010 9833          add.w     #16,A7
0000354E  1600      9834          move.b    D0,D3
                    9835   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
00003550  2042      9836          move.l    D2,A0
00003552  0268 FF00 9837          and.w     #65280,6(A0)
00003556  0006      
                    9838   ; pevent->OSEventCnt |= prio;
00003558  2042      9839          move.l    D2,A0
0000355A  C67C 00FF 9840          and.w     #255,D3
0000355E  8768 0006 9841          or.w      D3,6(A0)
                    9842   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
00003562  C6BC 0000 9843          and.l     #255,D3
00003566  00FF      
00003568  2003      9844          move.l    D3,D0
0000356A  E588      9845          lsl.l     #2,D0
0000356C  41F9 0800 9846          lea       _OSTCBPrioTbl.L,A0
00003570  1030      
00003572  2242      9847          move.l    D2,A1
00003574  2370 0800 9848          move.l    0(A0,D0.L),2(A1)
00003578  0002      
                    9849   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
0000357A  0C04 00FF 9850          cmp.b     #255,D4
0000357E  670E      9851          beq.s     OSMutexPost_14
00003580  B604      9852          cmp.b     D4,D3
00003582  620A      9853          bhi.s     OSMutexPost_14
                    9854   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9855   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
00003584  46DF      9856          dc.w      18143
                    9857   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003586  4EB8 1816 9858          jsr       _OS_Sched
                    9859   ; return (OS_ERR_PCP_LOWER);
0000358A  7078      9860          moveq     #120,D0
0000358C  601C      9861          bra.s     OSMutexPost_3
                    9862   OSMutexPost_14:
                    9863   ; } else {
                    9864   ; OS_EXIT_CRITICAL();
0000358E  46DF      9865          dc.w      18143
                    9866   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003590  4EB8 1816 9867          jsr       _OS_Sched
                    9868   ; return (OS_ERR_NONE);
00003594  4200      9869          clr.b     D0
00003596  6012      9870          bra.s     OSMutexPost_3
                    9871   OSMutexPost_12:
                    9872   ; }
                    9873   ; }
                    9874   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
00003598  2042      9875          move.l    D2,A0
0000359A  0068 00FF 9876          or.w      #255,6(A0)
0000359E  0006      
                    9877   ; pevent->OSEventPtr  = (void *)0;
000035A0  2042      9878          move.l    D2,A0
000035A2  42A8 0002 9879          clr.l     2(A0)
                    9880   ; OS_EXIT_CRITICAL();
000035A6  46DF      9881          dc.w      18143
                    9882   ; return (OS_ERR_NONE);
000035A8  4200      9883          clr.b     D0
                    9884   OSMutexPost_3:
000035AA  4CDF 041C 9885          movem.l   (A7)+,D2/D3/D4/A2
000035AE  4E5E      9886          unlk      A6
000035B0  4E75      9887          rts
                    9888   ; }
                    9889   ; /*$PAGE*/
                    9890   ; /*
                    9891   ; *********************************************************************************************************
                    9892   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9893   ; *
                    9894   ; * Description: This function obtains information about a mutex
                    9895   ; *
                    9896   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9897   ; *
                    9898   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9899   ; *
                    9900   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9901   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9902   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9903   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9904   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9905   ; *********************************************************************************************************
                    9906   ; */
                    9907   ; #if OS_MUTEX_QUERY_EN > 0u
                    9908   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9909   ; OS_MUTEX_DATA  *p_mutex_data)
                    9910   ; {
                    9911   _OSMutexQuery:
000035B2  4E56 FFF8 9912          link      A6,#-8
000035B6  48E7 3800 9913          movem.l   D2/D3/D4,-(A7)
000035BA  242E 000C 9914          move.l    12(A6),D2
000035BE  262E 0008 9915          move.l    8(A6),D3
                    9916   ; INT8U       i;
                    9917   ; OS_PRIO    *psrc;
                    9918   ; OS_PRIO    *pdest;
                    9919   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9920   ; OS_CPU_SR   cpu_sr = 0u;
                    9921   ; #endif
                    9922   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000035C2  1039 0800 9923          move.b    _OSIntNesting.L,D0
000035C6  0F06      
000035C8  0C00 0000 9924          cmp.b     #0,D0
000035CC  6306      9925          bls.s     OSMutexQuery_1
                    9926   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
000035CE  7006      9927          moveq     #6,D0
000035D0  6000 008A 9928          bra       OSMutexQuery_3
                    9929   OSMutexQuery_1:
                    9930   ; }
                    9931   ; #if OS_ARG_CHK_EN > 0u
                    9932   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9933   ; return (OS_ERR_PEVENT_NULL);
                    9934   ; }
                    9935   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    9936   ; return (OS_ERR_PDATA_NULL);
                    9937   ; }
                    9938   ; #endif
                    9939   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000035D4  2043      9940          move.l    D3,A0
000035D6  1010      9941          move.b    (A0),D0
000035D8  0C00 0004 9942          cmp.b     #4,D0
000035DC  6706      9943          beq.s     OSMutexQuery_4
                    9944   ; return (OS_ERR_EVENT_TYPE);
000035DE  7001      9945          moveq     #1,D0
000035E0  6000 007A 9946          bra       OSMutexQuery_3
                    9947   OSMutexQuery_4:
                    9948   ; }
                    9949   ; OS_ENTER_CRITICAL();
000035E4  40E7      9950          dc.w      16615
000035E6  007C      9951          dc.w      124
000035E8  0700      9952          dc.w      1792
                    9953   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
000035EA  2043      9954          move.l    D3,A0
000035EC  3028 0006 9955          move.w    6(A0),D0
000035F0  E048      9956          lsr.w     #8,D0
000035F2  2042      9957          move.l    D2,A0
000035F4  1140 000B 9958          move.b    D0,11(A0)
                    9959   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
000035F8  2043      9960          move.l    D3,A0
000035FA  3028 0006 9961          move.w    6(A0),D0
000035FE  C07C 00FF 9962          and.w     #255,D0
00003602  2042      9963          move.l    D2,A0
00003604  1140 000A 9964          move.b    D0,10(A0)
                    9965   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
00003608  2042      9966          move.l    D2,A0
0000360A  1028 000A 9967          move.b    10(A0),D0
0000360E  0C00 00FF 9968          cmp.b     #255,D0
00003612  660A      9969          bne.s     OSMutexQuery_6
                    9970   ; p_mutex_data->OSValue = OS_TRUE;
00003614  2042      9971          move.l    D2,A0
00003616  117C 0001 9972          move.b    #1,9(A0)
0000361A  0009      
0000361C  6006      9973          bra.s     OSMutexQuery_7
                    9974   OSMutexQuery_6:
                    9975   ; } else {
                    9976   ; p_mutex_data->OSValue = OS_FALSE;
0000361E  2042      9977          move.l    D2,A0
00003620  4228 0009 9978          clr.b     9(A0)
                    9979   OSMutexQuery_7:
                    9980   ; }
                    9981   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
00003624  2043      9982          move.l    D3,A0
00003626  2242      9983          move.l    D2,A1
00003628  1368 0008 9984          move.b    8(A0),8(A1)
0000362C  0008      
                    9985   ; psrc                      = &pevent->OSEventTbl[0];
0000362E  700A      9986          moveq     #10,D0
00003630  D083      9987          add.l     D3,D0
00003632  2D40 FFF8 9988          move.l    D0,-8(A6)
                    9989   ; pdest                     = &p_mutex_data->OSEventTbl[0];
00003636  2D42 FFFC 9990          move.l    D2,-4(A6)
                    9991   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0000363A  4204      9992          clr.b     D4
                    9993   OSMutexQuery_8:
0000363C  0C04 0008 9994          cmp.b     #8,D4
00003640  6416      9995          bhs.s     OSMutexQuery_10
                    9996   ; *pdest++ = *psrc++;
00003642  206E FFF8 9997          move.l    -8(A6),A0
00003646  52AE FFF8 9998          addq.l    #1,-8(A6)
0000364A  226E FFFC 9999          move.l    -4(A6),A1
0000364E  52AE FFFC 10000          addq.l    #1,-4(A6)
00003652  1290      10001          move.b    (A0),(A1)
00003654  5204      10002          addq.b    #1,D4
00003656  60E4      10003          bra       OSMutexQuery_8
                    10004   OSMutexQuery_10:
                    10005   ; }
                    10006   ; OS_EXIT_CRITICAL();
00003658  46DF      10007          dc.w      18143
                    10008   ; return (OS_ERR_NONE);
0000365A  4200      10009          clr.b     D0
                    10010   OSMutexQuery_3:
0000365C  4CDF 001C 10011          movem.l   (A7)+,D2/D3/D4
00003660  4E5E      10012          unlk      A6
00003662  4E75      10013          rts
                    10014   ; }
                    10015   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    10016   ; /*$PAGE*/
                    10017   ; /*
                    10018   ; *********************************************************************************************************
                    10019   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    10020   ; *
                    10021   ; * Description: This function makes a task ready at the specified priority
                    10022   ; *
                    10023   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    10024   ; *
                    10025   ; *              prio            is the desired priority
                    10026   ; *
                    10027   ; * Returns    : none
                    10028   ; *********************************************************************************************************
                    10029   ; */
                    10030   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    10031   ; INT8U    prio)
                    10032   ; {
                    10033   @ucos_ii_OSMutex_RdyAtPrio:
00003664  4E56 0000 10034          link      A6,#0
00003668  48E7 3820 10035          movem.l   D2/D3/D4/A2,-(A7)
0000366C  242E 0008 10036          move.l    8(A6),D2
00003670  162E 000F 10037          move.b    15(A6),D3
00003674  C6BC 0000 10038          and.l     #255,D3
00003678  00FF      
0000367A  45F9 0800 10039          lea       _OSRdyTbl.L,A2
0000367E  0F10      
                    10040   ; INT8U  y;
                    10041   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
00003680  2042      10042          move.l    D2,A0
00003682  1828 0036 10043          move.b    54(A0),D4
                    10044   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003686  C8BC 0000 10045          and.l     #255,D4
0000368A  00FF      
0000368C  2042      10046          move.l    D2,A0
0000368E  1028 0037 10047          move.b    55(A0),D0
00003692  4600      10048          not.b     D0
00003694  C132 4800 10049          and.b     D0,0(A2,D4.L)
                    10050   ; if (OSRdyTbl[y] == 0u) {
00003698  C8BC 0000 10051          and.l     #255,D4
0000369C  00FF      
0000369E  1032 4800 10052          move.b    0(A2,D4.L),D0
000036A2  660E      10053          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    10054   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000036A4  2042      10055          move.l    D2,A0
000036A6  1028 0038 10056          move.b    56(A0),D0
000036AA  4600      10057          not.b     D0
000036AC  C139 0800 10058          and.b     D0,_OSRdyGrp.L
000036B0  0F0E      
                    10059   @ucos_ii_OSMutex_RdyAtPrio_1:
                    10060   ; }
                    10061   ; ptcb->OSTCBPrio         = prio;
000036B2  2042      10062          move.l    D2,A0
000036B4  1143 0034 10063          move.b    D3,52(A0)
                    10064   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
000036B8  13C3 0800 10065          move.b    D3,_OSPrioCur.L
000036BC  0F0A      
                    10066   ; #if OS_LOWEST_PRIO <= 63u
                    10067   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
000036BE  1003      10068          move.b    D3,D0
000036C0  E608      10069          lsr.b     #3,D0
000036C2  C03C 0007 10070          and.b     #7,D0
000036C6  2042      10071          move.l    D2,A0
000036C8  1140 0036 10072          move.b    D0,54(A0)
                    10073   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
000036CC  1003      10074          move.b    D3,D0
000036CE  C03C 0007 10075          and.b     #7,D0
000036D2  2042      10076          move.l    D2,A0
000036D4  1140 0035 10077          move.b    D0,53(A0)
                    10078   ; #else
                    10079   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    10080   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    10081   ; #endif
                    10082   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
000036D8  7001      10083          moveq     #1,D0
000036DA  2042      10084          move.l    D2,A0
000036DC  1228 0036 10085          move.b    54(A0),D1
000036E0  C2BC 0000 10086          and.l     #255,D1
000036E4  00FF      
000036E6  E3A8      10087          lsl.l     D1,D0
000036E8  2042      10088          move.l    D2,A0
000036EA  1140 0038 10089          move.b    D0,56(A0)
                    10090   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000036EE  7001      10091          moveq     #1,D0
000036F0  2042      10092          move.l    D2,A0
000036F2  1228 0035 10093          move.b    53(A0),D1
000036F6  C2BC 0000 10094          and.l     #255,D1
000036FA  00FF      
000036FC  E3A8      10095          lsl.l     D1,D0
000036FE  2042      10096          move.l    D2,A0
00003700  1140 0037 10097          move.b    D0,55(A0)
                    10098   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
00003704  2042      10099          move.l    D2,A0
00003706  1028 0038 10100          move.b    56(A0),D0
0000370A  8139 0800 10101          or.b      D0,_OSRdyGrp.L
0000370E  0F0E      
                    10102   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00003710  2042      10103          move.l    D2,A0
00003712  1028 0036 10104          move.b    54(A0),D0
00003716  C0BC 0000 10105          and.l     #255,D0
0000371A  00FF      
0000371C  2042      10106          move.l    D2,A0
0000371E  1228 0037 10107          move.b    55(A0),D1
00003722  8332 0800 10108          or.b      D1,0(A2,D0.L)
                    10109   ; OSTCBPrioTbl[prio]      = ptcb;
00003726  C6BC 0000 10110          and.l     #255,D3
0000372A  00FF      
0000372C  2003      10111          move.l    D3,D0
0000372E  E588      10112          lsl.l     #2,D0
00003730  41F9 0800 10113          lea       _OSTCBPrioTbl.L,A0
00003734  1030      
00003736  2182 0800 10114          move.l    D2,0(A0,D0.L)
0000373A  4CDF 041C 10115          movem.l   (A7)+,D2/D3/D4/A2
0000373E  4E5E      10116          unlk      A6
00003740  4E75      10117          rts
                    10118   ; /*
                    10119   ; *********************************************************************************************************
                    10120   ; *                                                uC/OS-II
                    10121   ; *                                          The Real-Time Kernel
                    10122   ; *                                        MESSAGE QUEUE MANAGEMENT
                    10123   ; *
                    10124   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    10125   ; *                                           All Rights Reserved
                    10126   ; *
                    10127   ; * File    : OS_Q.C
                    10128   ; * By      : Jean J. Labrosse
                    10129   ; * Version : V2.92.07
                    10130   ; *
                    10131   ; * LICENSING TERMS:
                    10132   ; * ---------------
                    10133   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    10134   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    10135   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    10136   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    10137   ; * licensing fee.
                    10138   ; *********************************************************************************************************
                    10139   ; */
                    10140   ; #define  MICRIUM_SOURCE
                    10141   ; #ifndef  OS_MASTER_FILE
                    10142   ; #include <ucos_ii.h>
                    10143   ; #endif
                    10144   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    10145   ; /*
                    10146   ; *********************************************************************************************************
                    10147   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    10148   ; *
                    10149   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    10150   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    10151   ; *
                    10152   ; * Arguments  : pevent        is a pointer to the event control block
                    10153   ; *
                    10154   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10155   ; *                            messages are:
                    10156   ; *
                    10157   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10158   ; *                                                message.
                    10159   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10160   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10161   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    10162   ; *
                    10163   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    10164   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    10165   ; *                            one less entry.
                    10166   ; *              == (void *)0  if you received a NULL pointer message
                    10167   ; *                            if the queue is empty or,
                    10168   ; *                            if 'pevent' is a NULL pointer or,
                    10169   ; *                            if you passed an invalid event type
                    10170   ; *
                    10171   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    10172   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    10173   ; *********************************************************************************************************
                    10174   ; */
                    10175   ; #if OS_Q_ACCEPT_EN > 0u
                    10176   ; void  *OSQAccept (OS_EVENT  *pevent,
                    10177   ; INT8U     *perr)
                    10178   ; {
                    10179   _OSQAccept:
00003742  4E56 0000 10180          link      A6,#0
00003746  48E7 3800 10181          movem.l   D2/D3/D4,-(A7)
0000374A  282E 000C 10182          move.l    12(A6),D4
                    10183   ; void      *pmsg;
                    10184   ; OS_Q      *pq;
                    10185   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10186   ; OS_CPU_SR  cpu_sr = 0u;
                    10187   ; #endif
                    10188   ; #ifdef OS_SAFETY_CRITICAL
                    10189   ; if (perr == (INT8U *)0) {
                    10190   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10191   ; return ((void *)0);
                    10192   ; }
                    10193   ; #endif
                    10194   ; #if OS_ARG_CHK_EN > 0u
                    10195   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10196   ; *perr = OS_ERR_PEVENT_NULL;
                    10197   ; return ((void *)0);
                    10198   ; }
                    10199   ; #endif
                    10200   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
0000374E  206E 0008 10201          move.l    8(A6),A0
00003752  1010      10202          move.b    (A0),D0
00003754  0C00 0002 10203          cmp.b     #2,D0
00003758  670C      10204          beq.s     OSQAccept_1
                    10205   ; *perr = OS_ERR_EVENT_TYPE;
0000375A  2044      10206          move.l    D4,A0
0000375C  10BC 0001 10207          move.b    #1,(A0)
                    10208   ; return ((void *)0);
00003760  4280      10209          clr.l     D0
00003762  6000 0064 10210          bra       OSQAccept_3
                    10211   OSQAccept_1:
                    10212   ; }
                    10213   ; OS_ENTER_CRITICAL();
00003766  40E7      10214          dc.w      16615
00003768  007C      10215          dc.w      124
0000376A  0700      10216          dc.w      1792
                    10217   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
0000376C  206E 0008 10218          move.l    8(A6),A0
00003770  2428 0002 10219          move.l    2(A0),D2
                    10220   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003774  2042      10221          move.l    D2,A0
00003776  3028 0016 10222          move.w    22(A0),D0
0000377A  0C40 0000 10223          cmp.w     #0,D0
0000377E  6300 003C 10224          bls       OSQAccept_4
                    10225   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003782  2002      10226          move.l    D2,D0
00003784  0680 0000 10227          add.l     #16,D0
00003788  0010      
0000378A  2040      10228          move.l    D0,A0
0000378C  2250      10229          move.l    (A0),A1
0000378E  5890      10230          addq.l    #4,(A0)
00003790  2611      10231          move.l    (A1),D3
                    10232   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003792  2002      10233          move.l    D2,D0
00003794  0680 0000 10234          add.l     #22,D0
00003798  0016      
0000379A  2040      10235          move.l    D0,A0
0000379C  5350      10236          subq.w    #1,(A0)
                    10237   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
0000379E  2042      10238          move.l    D2,A0
000037A0  2242      10239          move.l    D2,A1
000037A2  2028 0010 10240          move.l    16(A0),D0
000037A6  B0A9 0008 10241          cmp.l     8(A1),D0
000037AA  660A      10242          bne.s     OSQAccept_6
                    10243   ; pq->OSQOut = pq->OSQStart;
000037AC  2042      10244          move.l    D2,A0
000037AE  2242      10245          move.l    D2,A1
000037B0  2368 0004 10246          move.l    4(A0),16(A1)
000037B4  0010      
                    10247   OSQAccept_6:
                    10248   ; }
                    10249   ; *perr = OS_ERR_NONE;
000037B6  2044      10250          move.l    D4,A0
000037B8  4210      10251          clr.b     (A0)
000037BA  6008      10252          bra.s     OSQAccept_5
                    10253   OSQAccept_4:
                    10254   ; } else {
                    10255   ; *perr = OS_ERR_Q_EMPTY;
000037BC  2044      10256          move.l    D4,A0
000037BE  10BC 001F 10257          move.b    #31,(A0)
                    10258   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
000037C2  4283      10259          clr.l     D3
                    10260   OSQAccept_5:
                    10261   ; }
                    10262   ; OS_EXIT_CRITICAL();
000037C4  46DF      10263          dc.w      18143
                    10264   ; return (pmsg);                               /* Return message received (or NULL)                  */
000037C6  2003      10265          move.l    D3,D0
                    10266   OSQAccept_3:
000037C8  4CDF 001C 10267          movem.l   (A7)+,D2/D3/D4
000037CC  4E5E      10268          unlk      A6
000037CE  4E75      10269          rts
                    10270   ; }
                    10271   ; #endif
                    10272   ; /*$PAGE*/
                    10273   ; /*
                    10274   ; *********************************************************************************************************
                    10275   ; *                                       CREATE A MESSAGE QUEUE
                    10276   ; *
                    10277   ; * Description: This function creates a message queue if free event control blocks are available.
                    10278   ; *
                    10279   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    10280   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    10281   ; *
                    10282   ; *                            void *MessageStorage[size]
                    10283   ; *
                    10284   ; *              size          is the number of elements in the storage area
                    10285   ; *
                    10286   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    10287   ; *                                created queue
                    10288   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    10289   ; *********************************************************************************************************
                    10290   ; */
                    10291   ; OS_EVENT  *OSQCreate (void    **start,
                    10292   ; INT16U    size)
                    10293   ; {
                    10294   _OSQCreate:
000037D0  4E56 0000 10295          link      A6,#0
000037D4  48E7 3830 10296          movem.l   D2/D3/D4/A2/A3,-(A7)
000037D8  45F9 0800 10297          lea       _OSEventFreeList.L,A2
000037DC  0CDA      
000037DE  282E 0008 10298          move.l    8(A6),D4
000037E2  47F9 0800 10299          lea       _OSQFreeList.L,A3
000037E6  1910      
                    10300   ; OS_EVENT  *pevent;
                    10301   ; OS_Q      *pq;
                    10302   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10303   ; OS_CPU_SR  cpu_sr = 0u;
                    10304   ; #endif
                    10305   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10306   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10307   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10308   ; return ((OS_EVENT *)0);
                    10309   ; }
                    10310   ; #endif
                    10311   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000037E8  1039 0800 10312          move.b    _OSIntNesting.L,D0
000037EC  0F06      
000037EE  0C00 0000 10313          cmp.b     #0,D0
000037F2  6306      10314          bls.s     OSQCreate_1
                    10315   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000037F4  4280      10316          clr.l     D0
000037F6  6000 009C 10317          bra       OSQCreate_3
                    10318   OSQCreate_1:
                    10319   ; }
                    10320   ; OS_ENTER_CRITICAL();
000037FA  40E7      10321          dc.w      16615
000037FC  007C      10322          dc.w      124
000037FE  0700      10323          dc.w      1792
                    10324   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
00003800  2412      10325          move.l    (A2),D2
                    10326   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
00003802  2012      10327          move.l    (A2),D0
00003804  6706      10328          beq.s     OSQCreate_4
                    10329   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00003806  2052      10330          move.l    (A2),A0
00003808  24A8 0002 10331          move.l    2(A0),(A2)
                    10332   OSQCreate_4:
                    10333   ; }
                    10334   ; OS_EXIT_CRITICAL();
0000380C  46DF      10335          dc.w      18143
                    10336   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
0000380E  4A82      10337          tst.l     D2
00003810  6700 0080 10338          beq       OSQCreate_9
                    10339   ; OS_ENTER_CRITICAL();
00003814  40E7      10340          dc.w      16615
00003816  007C      10341          dc.w      124
00003818  0700      10342          dc.w      1792
                    10343   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
0000381A  2613      10344          move.l    (A3),D3
                    10345   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
0000381C  4A83      10346          tst.l     D3
0000381E  6700 0066 10347          beq       OSQCreate_8
                    10348   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
00003822  2053      10349          move.l    (A3),A0
00003824  2690      10350          move.l    (A0),(A3)
                    10351   ; OS_EXIT_CRITICAL();
00003826  46DF      10352          dc.w      18143
                    10353   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
00003828  2043      10354          move.l    D3,A0
0000382A  2144 0004 10355          move.l    D4,4(A0)
                    10356   ; pq->OSQEnd             = &start[size];
0000382E  2004      10357          move.l    D4,D0
00003830  322E 000E 10358          move.w    14(A6),D1
00003834  C2BC 0000 10359          and.l     #65535,D1
00003838  FFFF      
0000383A  E589      10360          lsl.l     #2,D1
0000383C  D081      10361          add.l     D1,D0
0000383E  2043      10362          move.l    D3,A0
00003840  2140 0008 10363          move.l    D0,8(A0)
                    10364   ; pq->OSQIn              = start;
00003844  2043      10365          move.l    D3,A0
00003846  2144 000C 10366          move.l    D4,12(A0)
                    10367   ; pq->OSQOut             = start;
0000384A  2043      10368          move.l    D3,A0
0000384C  2144 0010 10369          move.l    D4,16(A0)
                    10370   ; pq->OSQSize            = size;
00003850  2043      10371          move.l    D3,A0
00003852  316E 000E 10372          move.w    14(A6),20(A0)
00003856  0014      
                    10373   ; pq->OSQEntries         = 0u;
00003858  2043      10374          move.l    D3,A0
0000385A  4268 0016 10375          clr.w     22(A0)
                    10376   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
0000385E  2042      10377          move.l    D2,A0
00003860  10BC 0002 10378          move.b    #2,(A0)
                    10379   ; pevent->OSEventCnt     = 0u;
00003864  2042      10380          move.l    D2,A0
00003866  4268 0006 10381          clr.w     6(A0)
                    10382   ; pevent->OSEventPtr     = pq;
0000386A  2042      10383          move.l    D2,A0
0000386C  2143 0002 10384          move.l    D3,2(A0)
                    10385   ; #if OS_EVENT_NAME_EN > 0u
                    10386   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003870  41F9 0000 10387          lea       @ucos_ii_1.L,A0
00003874  68A4      
00003876  2242      10388          move.l    D2,A1
00003878  2348 0012 10389          move.l    A0,18(A1)
                    10390   ; #endif
                    10391   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
0000387C  2F02      10392          move.l    D2,-(A7)
0000387E  4EB8 14FE 10393          jsr       _OS_EventWaitListInit
00003882  584F      10394          addq.w    #4,A7
00003884  600C      10395          bra.s     OSQCreate_9
                    10396   OSQCreate_8:
                    10397   ; } else {
                    10398   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
00003886  2042      10399          move.l    D2,A0
00003888  2152 0002 10400          move.l    (A2),2(A0)
                    10401   ; OSEventFreeList    = pevent;
0000388C  2482      10402          move.l    D2,(A2)
                    10403   ; OS_EXIT_CRITICAL();
0000388E  46DF      10404          dc.w      18143
                    10405   ; pevent = (OS_EVENT *)0;
00003890  4282      10406          clr.l     D2
                    10407   OSQCreate_9:
                    10408   ; }
                    10409   ; }
                    10410   ; return (pevent);
00003892  2002      10411          move.l    D2,D0
                    10412   OSQCreate_3:
00003894  4CDF 0C1C 10413          movem.l   (A7)+,D2/D3/D4/A2/A3
00003898  4E5E      10414          unlk      A6
0000389A  4E75      10415          rts
                    10416   ; }
                    10417   ; /*$PAGE*/
                    10418   ; /*
                    10419   ; *********************************************************************************************************
                    10420   ; *                                       DELETE A MESSAGE QUEUE
                    10421   ; *
                    10422   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10423   ; *
                    10424   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10425   ; *                            queue.
                    10426   ; *
                    10427   ; *              opt           determines delete options as follows:
                    10428   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10429   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10430   ; *                                                    In this case, all the tasks pending will be readied.
                    10431   ; *
                    10432   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10433   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10434   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10435   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10436   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10437   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10438   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10439   ; *
                    10440   ; * Returns    : pevent        upon error
                    10441   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10442   ; *
                    10443   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10444   ; *                 the queue MUST check the return code of OSQPend().
                    10445   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10446   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10447   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10448   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10449   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10450   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10451   ; *                 will no longer be guarded by the queue.
                    10452   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10453   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10454   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10455   ; *                 then, the storage can be reused.
                    10456   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10457   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10458   ; *********************************************************************************************************
                    10459   ; */
                    10460   ; #if OS_Q_DEL_EN > 0u
                    10461   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10462   ; INT8U      opt,
                    10463   ; INT8U     *perr)
                    10464   ; {
                    10465   _OSQDel:
0000389C  4E56 0000 10466          link      A6,#0
000038A0  48E7 3E30 10467          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
000038A4  242E 0008 10468          move.l    8(A6),D2
000038A8  282E 0010 10469          move.l    16(A6),D4
000038AC  45F9 0800 10470          lea       _OSEventFreeList.L,A2
000038B0  0CDA      
000038B2  47F9 0800 10471          lea       _OSQFreeList.L,A3
000038B6  1910      
                    10472   ; BOOLEAN    tasks_waiting;
                    10473   ; OS_EVENT  *pevent_return;
                    10474   ; OS_Q      *pq;
                    10475   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10476   ; OS_CPU_SR  cpu_sr = 0u;
                    10477   ; #endif
                    10478   ; #ifdef OS_SAFETY_CRITICAL
                    10479   ; if (perr == (INT8U *)0) {
                    10480   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10481   ; return ((OS_EVENT *)0);
                    10482   ; }
                    10483   ; #endif
                    10484   ; #if OS_ARG_CHK_EN > 0u
                    10485   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10486   ; *perr = OS_ERR_PEVENT_NULL;
                    10487   ; return (pevent);
                    10488   ; }
                    10489   ; #endif
                    10490   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
000038B8  2042      10491          move.l    D2,A0
000038BA  1010      10492          move.b    (A0),D0
000038BC  0C00 0002 10493          cmp.b     #2,D0
000038C0  670C      10494          beq.s     OSQDel_1
                    10495   ; *perr = OS_ERR_EVENT_TYPE;
000038C2  2044      10496          move.l    D4,A0
000038C4  10BC 0001 10497          move.b    #1,(A0)
                    10498   ; return (pevent);
000038C8  2002      10499          move.l    D2,D0
000038CA  6000 0104 10500          bra       OSQDel_3
                    10501   OSQDel_1:
                    10502   ; }
                    10503   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000038CE  1039 0800 10504          move.b    _OSIntNesting.L,D0
000038D2  0F06      
000038D4  0C00 0000 10505          cmp.b     #0,D0
000038D8  630C      10506          bls.s     OSQDel_4
                    10507   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000038DA  2044      10508          move.l    D4,A0
000038DC  10BC 000F 10509          move.b    #15,(A0)
                    10510   ; return (pevent);
000038E0  2002      10511          move.l    D2,D0
000038E2  6000 00EC 10512          bra       OSQDel_3
                    10513   OSQDel_4:
                    10514   ; }
                    10515   ; OS_ENTER_CRITICAL();
000038E6  40E7      10516          dc.w      16615
000038E8  007C      10517          dc.w      124
000038EA  0700      10518          dc.w      1792
                    10519   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
000038EC  2042      10520          move.l    D2,A0
000038EE  1028 0008 10521          move.b    8(A0),D0
000038F2  6704      10522          beq.s     OSQDel_6
                    10523   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000038F4  7C01      10524          moveq     #1,D6
000038F6  6002      10525          bra.s     OSQDel_7
                    10526   OSQDel_6:
                    10527   ; } else {
                    10528   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000038F8  4206      10529          clr.b     D6
                    10530   OSQDel_7:
                    10531   ; }
                    10532   ; switch (opt) {
000038FA  102E 000F 10533          move.b    15(A6),D0
000038FE  C0BC 0000 10534          and.l     #255,D0
00003902  00FF      
00003904  0C80 0000 10535          cmp.l     #1,D0
00003908  0001      
0000390A  6700 0056 10536          beq       OSQDel_11
0000390E  6200 00B4 10537          bhi       OSQDel_8
00003912  4A80      10538          tst.l     D0
00003914  6704      10539          beq.s     OSQDel_10
00003916  6000 00AC 10540          bra       OSQDel_8
                    10541   OSQDel_10:
                    10542   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10543   ; if (tasks_waiting == OS_FALSE) {
0000391A  4A06      10544          tst.b     D6
0000391C  6600 0036 10545          bne       OSQDel_13
                    10546   ; #if OS_EVENT_NAME_EN > 0u
                    10547   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003920  41F9 0000 10548          lea       @ucos_ii_1.L,A0
00003924  68A4      
00003926  2242      10549          move.l    D2,A1
00003928  2348 0012 10550          move.l    A0,18(A1)
                    10551   ; #endif
                    10552   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
0000392C  2042      10553          move.l    D2,A0
0000392E  2628 0002 10554          move.l    2(A0),D3
                    10555   ; pq->OSQPtr             = OSQFreeList;
00003932  2043      10556          move.l    D3,A0
00003934  2093      10557          move.l    (A3),(A0)
                    10558   ; OSQFreeList            = pq;
00003936  2683      10559          move.l    D3,(A3)
                    10560   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003938  2042      10561          move.l    D2,A0
0000393A  4210      10562          clr.b     (A0)
                    10563   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
0000393C  2042      10564          move.l    D2,A0
0000393E  2152 0002 10565          move.l    (A2),2(A0)
                    10566   ; pevent->OSEventCnt     = 0u;
00003942  2042      10567          move.l    D2,A0
00003944  4268 0006 10568          clr.w     6(A0)
                    10569   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003948  2482      10570          move.l    D2,(A2)
                    10571   ; OS_EXIT_CRITICAL();
0000394A  46DF      10572          dc.w      18143
                    10573   ; *perr                  = OS_ERR_NONE;
0000394C  2044      10574          move.l    D4,A0
0000394E  4210      10575          clr.b     (A0)
                    10576   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
00003950  4285      10577          clr.l     D5
00003952  600A      10578          bra.s     OSQDel_14
                    10579   OSQDel_13:
                    10580   ; } else {
                    10581   ; OS_EXIT_CRITICAL();
00003954  46DF      10582          dc.w      18143
                    10583   ; *perr                  = OS_ERR_TASK_WAITING;
00003956  2044      10584          move.l    D4,A0
00003958  10BC 0049 10585          move.b    #73,(A0)
                    10586   ; pevent_return          = pevent;
0000395C  2A02      10587          move.l    D2,D5
                    10588   OSQDel_14:
                    10589   ; }
                    10590   ; break;
0000395E  6000 006E 10591          bra       OSQDel_9
                    10592   OSQDel_11:
                    10593   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10594   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10595   OSQDel_15:
00003962  2042      10596          move.l    D2,A0
00003964  1028 0008 10597          move.b    8(A0),D0
00003968  671C      10598          beq.s     OSQDel_17
                    10599   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0000396A  4878 0002 10600          pea       2
0000396E  4878 0004 10601          pea       4
00003972  42A7      10602          clr.l     -(A7)
00003974  2F02      10603          move.l    D2,-(A7)
00003976  4EB8 1236 10604          jsr       _OS_EventTaskRdy
0000397A  DEFC 0010 10605          add.w     #16,A7
0000397E  C0BC 0000 10606          and.l     #255,D0
00003982  00FF      
00003984  60DC      10607          bra       OSQDel_15
                    10608   OSQDel_17:
                    10609   ; }
                    10610   ; #if OS_EVENT_NAME_EN > 0u
                    10611   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003986  41F9 0000 10612          lea       @ucos_ii_1.L,A0
0000398A  68A4      
0000398C  2242      10613          move.l    D2,A1
0000398E  2348 0012 10614          move.l    A0,18(A1)
                    10615   ; #endif
                    10616   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003992  2042      10617          move.l    D2,A0
00003994  2628 0002 10618          move.l    2(A0),D3
                    10619   ; pq->OSQPtr             = OSQFreeList;
00003998  2043      10620          move.l    D3,A0
0000399A  2093      10621          move.l    (A3),(A0)
                    10622   ; OSQFreeList            = pq;
0000399C  2683      10623          move.l    D3,(A3)
                    10624   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0000399E  2042      10625          move.l    D2,A0
000039A0  4210      10626          clr.b     (A0)
                    10627   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
000039A2  2042      10628          move.l    D2,A0
000039A4  2152 0002 10629          move.l    (A2),2(A0)
                    10630   ; pevent->OSEventCnt     = 0u;
000039A8  2042      10631          move.l    D2,A0
000039AA  4268 0006 10632          clr.w     6(A0)
                    10633   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
000039AE  2482      10634          move.l    D2,(A2)
                    10635   ; OS_EXIT_CRITICAL();
000039B0  46DF      10636          dc.w      18143
                    10637   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
000039B2  0C06 0001 10638          cmp.b     #1,D6
000039B6  6604      10639          bne.s     OSQDel_18
                    10640   ; OS_Sched();                               /* Find highest priority task ready to run  */
000039B8  4EB8 1816 10641          jsr       _OS_Sched
                    10642   OSQDel_18:
                    10643   ; }
                    10644   ; *perr                  = OS_ERR_NONE;
000039BC  2044      10645          move.l    D4,A0
000039BE  4210      10646          clr.b     (A0)
                    10647   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
000039C0  4285      10648          clr.l     D5
                    10649   ; break;
000039C2  600A      10650          bra.s     OSQDel_9
                    10651   OSQDel_8:
                    10652   ; default:
                    10653   ; OS_EXIT_CRITICAL();
000039C4  46DF      10654          dc.w      18143
                    10655   ; *perr                  = OS_ERR_INVALID_OPT;
000039C6  2044      10656          move.l    D4,A0
000039C8  10BC 0007 10657          move.b    #7,(A0)
                    10658   ; pevent_return          = pevent;
000039CC  2A02      10659          move.l    D2,D5
                    10660   ; break;
                    10661   OSQDel_9:
                    10662   ; }
                    10663   ; return (pevent_return);
000039CE  2005      10664          move.l    D5,D0
                    10665   OSQDel_3:
000039D0  4CDF 0C7C 10666          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
000039D4  4E5E      10667          unlk      A6
000039D6  4E75      10668          rts
                    10669   ; }
                    10670   ; #endif
                    10671   ; /*$PAGE*/
                    10672   ; /*
                    10673   ; *********************************************************************************************************
                    10674   ; *                                             FLUSH QUEUE
                    10675   ; *
                    10676   ; * Description : This function is used to flush the contents of the message queue.
                    10677   ; *
                    10678   ; * Arguments   : none
                    10679   ; *
                    10680   ; * Returns     : OS_ERR_NONE         upon success
                    10681   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10682   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10683   ; *
                    10684   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10685   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10686   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10687   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10688   ; *********************************************************************************************************
                    10689   ; */
                    10690   ; #if OS_Q_FLUSH_EN > 0u
                    10691   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10692   ; {
                    10693   _OSQFlush:
000039D8  4E56 0000 10694          link      A6,#0
000039DC  2F02      10695          move.l    D2,-(A7)
                    10696   ; OS_Q      *pq;
                    10697   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10698   ; OS_CPU_SR  cpu_sr = 0u;
                    10699   ; #endif
                    10700   ; #if OS_ARG_CHK_EN > 0u
                    10701   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10702   ; return (OS_ERR_PEVENT_NULL);
                    10703   ; }
                    10704   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10705   ; return (OS_ERR_EVENT_TYPE);
                    10706   ; }
                    10707   ; #endif
                    10708   ; OS_ENTER_CRITICAL();
000039DE  40E7      10709          dc.w      16615
000039E0  007C      10710          dc.w      124
000039E2  0700      10711          dc.w      1792
                    10712   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
000039E4  206E 0008 10713          move.l    8(A6),A0
000039E8  2428 0002 10714          move.l    2(A0),D2
                    10715   ; pq->OSQIn      = pq->OSQStart;
000039EC  2042      10716          move.l    D2,A0
000039EE  2242      10717          move.l    D2,A1
000039F0  2368 0004 10718          move.l    4(A0),12(A1)
000039F4  000C      
                    10719   ; pq->OSQOut     = pq->OSQStart;
000039F6  2042      10720          move.l    D2,A0
000039F8  2242      10721          move.l    D2,A1
000039FA  2368 0004 10722          move.l    4(A0),16(A1)
000039FE  0010      
                    10723   ; pq->OSQEntries = 0u;
00003A00  2042      10724          move.l    D2,A0
00003A02  4268 0016 10725          clr.w     22(A0)
                    10726   ; OS_EXIT_CRITICAL();
00003A06  46DF      10727          dc.w      18143
                    10728   ; return (OS_ERR_NONE);
00003A08  4200      10729          clr.b     D0
00003A0A  241F      10730          move.l    (A7)+,D2
00003A0C  4E5E      10731          unlk      A6
00003A0E  4E75      10732          rts
                    10733   ; }
                    10734   ; #endif
                    10735   ; /*$PAGE*/
                    10736   ; /*
                    10737   ; *********************************************************************************************************
                    10738   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10739   ; *
                    10740   ; * Description: This function waits for a message to be sent to a queue
                    10741   ; *
                    10742   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10743   ; *
                    10744   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10745   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10746   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10747   ; *                            forever at the specified queue or, until a message arrives.
                    10748   ; *
                    10749   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10750   ; *                            messages are:
                    10751   ; *
                    10752   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10753   ; *                                                message.
                    10754   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10755   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10756   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10757   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10758   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10759   ; *                                                would lead to a suspension.
                    10760   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10761   ; *
                    10762   ; * Returns    : != (void *)0  is a pointer to the message received
                    10763   ; *              == (void *)0  if you received a NULL pointer message or,
                    10764   ; *                            if no message was received or,
                    10765   ; *                            if 'pevent' is a NULL pointer or,
                    10766   ; *                            if you didn't pass a pointer to a queue.
                    10767   ; *
                    10768   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10769   ; *********************************************************************************************************
                    10770   ; */
                    10771   ; void  *OSQPend (OS_EVENT  *pevent,
                    10772   ; INT32U     timeout,
                    10773   ; INT8U     *perr)
                    10774   ; {
                    10775   _OSQPend:
00003A10  4E56 0000 10776          link      A6,#0
00003A14  48E7 3C20 10777          movem.l   D2/D3/D4/D5/A2,-(A7)
00003A18  45F9 0800 10778          lea       _OSTCBCur.L,A2
00003A1C  1020      
00003A1E  262E 0010 10779          move.l    16(A6),D3
00003A22  2A2E 0008 10780          move.l    8(A6),D5
                    10781   ; void      *pmsg;
                    10782   ; OS_Q      *pq;
                    10783   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10784   ; OS_CPU_SR  cpu_sr = 0u;
                    10785   ; #endif
                    10786   ; #ifdef OS_SAFETY_CRITICAL
                    10787   ; if (perr == (INT8U *)0) {
                    10788   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10789   ; return ((void *)0);
                    10790   ; }
                    10791   ; #endif
                    10792   ; #if OS_ARG_CHK_EN > 0u
                    10793   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10794   ; *perr = OS_ERR_PEVENT_NULL;
                    10795   ; return ((void *)0);
                    10796   ; }
                    10797   ; #endif
                    10798   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003A26  2045      10799          move.l    D5,A0
00003A28  1010      10800          move.b    (A0),D0
00003A2A  0C00 0002 10801          cmp.b     #2,D0
00003A2E  670C      10802          beq.s     OSQPend_1
                    10803   ; *perr = OS_ERR_EVENT_TYPE;
00003A30  2043      10804          move.l    D3,A0
00003A32  10BC 0001 10805          move.b    #1,(A0)
                    10806   ; return ((void *)0);
00003A36  4280      10807          clr.l     D0
00003A38  6000 0128 10808          bra       OSQPend_3
                    10809   OSQPend_1:
                    10810   ; }
                    10811   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00003A3C  1039 0800 10812          move.b    _OSIntNesting.L,D0
00003A40  0F06      
00003A42  0C00 0000 10813          cmp.b     #0,D0
00003A46  630C      10814          bls.s     OSQPend_4
                    10815   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
00003A48  2043      10816          move.l    D3,A0
00003A4A  10BC 0002 10817          move.b    #2,(A0)
                    10818   ; return ((void *)0);
00003A4E  4280      10819          clr.l     D0
00003A50  6000 0110 10820          bra       OSQPend_3
                    10821   OSQPend_4:
                    10822   ; }
                    10823   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00003A54  1039 0800 10824          move.b    _OSLockNesting.L,D0
00003A58  0F08      
00003A5A  0C00 0000 10825          cmp.b     #0,D0
00003A5E  630C      10826          bls.s     OSQPend_6
                    10827   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003A60  2043      10828          move.l    D3,A0
00003A62  10BC 000D 10829          move.b    #13,(A0)
                    10830   ; return ((void *)0);
00003A66  4280      10831          clr.l     D0
00003A68  6000 00F8 10832          bra       OSQPend_3
                    10833   OSQPend_6:
                    10834   ; }
                    10835   ; OS_ENTER_CRITICAL();
00003A6C  40E7      10836          dc.w      16615
00003A6E  007C      10837          dc.w      124
00003A70  0700      10838          dc.w      1792
                    10839   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003A72  2045      10840          move.l    D5,A0
00003A74  2428 0002 10841          move.l    2(A0),D2
                    10842   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003A78  2042      10843          move.l    D2,A0
00003A7A  3028 0016 10844          move.w    22(A0),D0
00003A7E  0C40 0000 10845          cmp.w     #0,D0
00003A82  6300 0042 10846          bls       OSQPend_8
                    10847   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003A86  2002      10848          move.l    D2,D0
00003A88  0680 0000 10849          add.l     #16,D0
00003A8C  0010      
00003A8E  2040      10850          move.l    D0,A0
00003A90  2250      10851          move.l    (A0),A1
00003A92  5890      10852          addq.l    #4,(A0)
00003A94  2811      10853          move.l    (A1),D4
                    10854   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003A96  2002      10855          move.l    D2,D0
00003A98  0680 0000 10856          add.l     #22,D0
00003A9C  0016      
00003A9E  2040      10857          move.l    D0,A0
00003AA0  5350      10858          subq.w    #1,(A0)
                    10859   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003AA2  2042      10860          move.l    D2,A0
00003AA4  2242      10861          move.l    D2,A1
00003AA6  2028 0010 10862          move.l    16(A0),D0
00003AAA  B0A9 0008 10863          cmp.l     8(A1),D0
00003AAE  660A      10864          bne.s     OSQPend_10
                    10865   ; pq->OSQOut = pq->OSQStart;
00003AB0  2042      10866          move.l    D2,A0
00003AB2  2242      10867          move.l    D2,A1
00003AB4  2368 0004 10868          move.l    4(A0),16(A1)
00003AB8  0010      
                    10869   OSQPend_10:
                    10870   ; }
                    10871   ; OS_EXIT_CRITICAL();
00003ABA  46DF      10872          dc.w      18143
                    10873   ; *perr = OS_ERR_NONE;
00003ABC  2043      10874          move.l    D3,A0
00003ABE  4210      10875          clr.b     (A0)
                    10876   ; return (pmsg);                           /* Return message received                            */
00003AC0  2004      10877          move.l    D4,D0
00003AC2  6000 009E 10878          bra       OSQPend_3
                    10879   OSQPend_8:
                    10880   ; }
                    10881   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
00003AC6  2052      10882          move.l    (A2),A0
00003AC8  0028 0004 10883          or.b      #4,50(A0)
00003ACC  0032      
                    10884   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003ACE  2052      10885          move.l    (A2),A0
00003AD0  4228 0033 10886          clr.b     51(A0)
                    10887   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00003AD4  2052      10888          move.l    (A2),A0
00003AD6  216E 000C 10889          move.l    12(A6),46(A0)
00003ADA  002E      
                    10890   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
00003ADC  2F05      10891          move.l    D5,-(A7)
00003ADE  4EB8 131A 10892          jsr       _OS_EventTaskWait
00003AE2  584F      10893          addq.w    #4,A7
                    10894   ; OS_EXIT_CRITICAL();
00003AE4  46DF      10895          dc.w      18143
                    10896   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
00003AE6  4EB8 1816 10897          jsr       _OS_Sched
                    10898   ; OS_ENTER_CRITICAL();
00003AEA  40E7      10899          dc.w      16615
00003AEC  007C      10900          dc.w      124
00003AEE  0700      10901          dc.w      1792
                    10902   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003AF0  2052      10903          move.l    (A2),A0
00003AF2  1028 0033 10904          move.b    51(A0),D0
00003AF6  C0BC 0000 10905          and.l     #255,D0
00003AFA  00FF      
00003AFC  0C80 0000 10906          cmp.l     #1,D0
00003B00  0001      
00003B02  6700 002A 10907          beq       OSQPend_16
00003B06  6206      10908          bhi.s     OSQPend_18
00003B08  4A80      10909          tst.l     D0
00003B0A  670C      10910          beq.s     OSQPend_14
00003B0C  6020      10911          bra.s     OSQPend_16
                    10912   OSQPend_18:
00003B0E  0C80 0000 10913          cmp.l     #2,D0
00003B12  0002      
00003B14  670E      10914          beq.s     OSQPend_15
00003B16  6016      10915          bra.s     OSQPend_16
                    10916   OSQPend_14:
                    10917   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    10918   ; pmsg =  OSTCBCur->OSTCBMsg;
00003B18  2052      10919          move.l    (A2),A0
00003B1A  2828 0024 10920          move.l    36(A0),D4
                    10921   ; *perr =  OS_ERR_NONE;
00003B1E  2043      10922          move.l    D3,A0
00003B20  4210      10923          clr.b     (A0)
                    10924   ; break;
00003B22  601C      10925          bra.s     OSQPend_13
                    10926   OSQPend_15:
                    10927   ; case OS_STAT_PEND_ABORT:
                    10928   ; pmsg = (void *)0;
00003B24  4284      10929          clr.l     D4
                    10930   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00003B26  2043      10931          move.l    D3,A0
00003B28  10BC 000E 10932          move.b    #14,(A0)
                    10933   ; break;
00003B2C  6012      10934          bra.s     OSQPend_13
                    10935   OSQPend_16:
                    10936   ; case OS_STAT_PEND_TO:
                    10937   ; default:
                    10938   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003B2E  2F05      10939          move.l    D5,-(A7)
00003B30  2F12      10940          move.l    (A2),-(A7)
00003B32  4EB8 143C 10941          jsr       _OS_EventTaskRemove
00003B36  504F      10942          addq.w    #8,A7
                    10943   ; pmsg = (void *)0;
00003B38  4284      10944          clr.l     D4
                    10945   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00003B3A  2043      10946          move.l    D3,A0
00003B3C  10BC 000A 10947          move.b    #10,(A0)
                    10948   ; break;
                    10949   OSQPend_13:
                    10950   ; }
                    10951   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003B40  2052      10952          move.l    (A2),A0
00003B42  4228 0032 10953          clr.b     50(A0)
                    10954   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003B46  2052      10955          move.l    (A2),A0
00003B48  4228 0033 10956          clr.b     51(A0)
                    10957   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003B4C  2052      10958          move.l    (A2),A0
00003B4E  42A8 001C 10959          clr.l     28(A0)
                    10960   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10961   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003B52  2052      10962          move.l    (A2),A0
00003B54  42A8 0020 10963          clr.l     32(A0)
                    10964   ; #endif
                    10965   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00003B58  2052      10966          move.l    (A2),A0
00003B5A  42A8 0024 10967          clr.l     36(A0)
                    10968   ; OS_EXIT_CRITICAL();
00003B5E  46DF      10969          dc.w      18143
                    10970   ; return (pmsg);                                    /* Return received message                       */
00003B60  2004      10971          move.l    D4,D0
                    10972   OSQPend_3:
00003B62  4CDF 043C 10973          movem.l   (A7)+,D2/D3/D4/D5/A2
00003B66  4E5E      10974          unlk      A6
00003B68  4E75      10975          rts
                    10976   ; }
                    10977   ; /*$PAGE*/
                    10978   ; /*
                    10979   ; *********************************************************************************************************
                    10980   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    10981   ; *
                    10982   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    10983   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    10984   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    10985   ; *
                    10986   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    10987   ; *
                    10988   ; *              opt           determines the type of ABORT performed:
                    10989   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    10990   ; *                                                     queue
                    10991   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    10992   ; *                                                     queue
                    10993   ; *
                    10994   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10995   ; *                            messages are:
                    10996   ; *
                    10997   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    10998   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    10999   ; *                                                and informed of the aborted wait; check return value
                    11000   ; *                                                for the number of tasks whose wait on the queue
                    11001   ; *                                                was aborted.
                    11002   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    11003   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11004   ; *
                    11005   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    11006   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    11007   ; *********************************************************************************************************
                    11008   ; */
                    11009   ; #if OS_Q_PEND_ABORT_EN > 0u
                    11010   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    11011   ; INT8U      opt,
                    11012   ; INT8U     *perr)
                    11013   ; {
                    11014   _OSQPendAbort:
00003B6A  4E56 0000 11015          link      A6,#0
00003B6E  48E7 3800 11016          movem.l   D2/D3/D4,-(A7)
00003B72  242E 0008 11017          move.l    8(A6),D2
00003B76  282E 0010 11018          move.l    16(A6),D4
                    11019   ; INT8U      nbr_tasks;
                    11020   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11021   ; OS_CPU_SR  cpu_sr = 0u;
                    11022   ; #endif
                    11023   ; #ifdef OS_SAFETY_CRITICAL
                    11024   ; if (perr == (INT8U *)0) {
                    11025   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11026   ; return (0u);
                    11027   ; }
                    11028   ; #endif
                    11029   ; #if OS_ARG_CHK_EN > 0u
                    11030   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11031   ; *perr = OS_ERR_PEVENT_NULL;
                    11032   ; return (0u);
                    11033   ; }
                    11034   ; #endif
                    11035   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00003B7A  2042      11036          move.l    D2,A0
00003B7C  1010      11037          move.b    (A0),D0
00003B7E  0C00 0002 11038          cmp.b     #2,D0
00003B82  670C      11039          beq.s     OSQPendAbort_1
                    11040   ; *perr = OS_ERR_EVENT_TYPE;
00003B84  2044      11041          move.l    D4,A0
00003B86  10BC 0001 11042          move.b    #1,(A0)
                    11043   ; return (0u);
00003B8A  4200      11044          clr.b     D0
00003B8C  6000 008C 11045          bra       OSQPendAbort_3
                    11046   OSQPendAbort_1:
                    11047   ; }
                    11048   ; OS_ENTER_CRITICAL();
00003B90  40E7      11049          dc.w      16615
00003B92  007C      11050          dc.w      124
00003B94  0700      11051          dc.w      1792
                    11052   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00003B96  2042      11053          move.l    D2,A0
00003B98  1028 0008 11054          move.b    8(A0),D0
00003B9C  6700 0074 11055          beq       OSQPendAbort_4
                    11056   ; nbr_tasks = 0u;
00003BA0  4203      11057          clr.b     D3
                    11058   ; switch (opt) {
00003BA2  102E 000F 11059          move.b    15(A6),D0
00003BA6  C0BC 0000 11060          and.l     #255,D0
00003BAA  00FF      
00003BAC  0C80 0000 11061          cmp.l     #1,D0
00003BB0  0001      
00003BB2  670A      11062          beq.s     OSQPendAbort_8
00003BB4  6200 0030 11063          bhi       OSQPendAbort_9
00003BB8  4A80      11064          tst.l     D0
00003BBA  672A      11065          beq.s     OSQPendAbort_9
00003BBC  6028      11066          bra.s     OSQPendAbort_9
                    11067   OSQPendAbort_8:
                    11068   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    11069   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    11070   OSQPendAbort_11:
00003BBE  2042      11071          move.l    D2,A0
00003BC0  1028 0008 11072          move.b    8(A0),D0
00003BC4  671E      11073          beq.s     OSQPendAbort_13
                    11074   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003BC6  4878 0002 11075          pea       2
00003BCA  4878 0004 11076          pea       4
00003BCE  42A7      11077          clr.l     -(A7)
00003BD0  2F02      11078          move.l    D2,-(A7)
00003BD2  4EB8 1236 11079          jsr       _OS_EventTaskRdy
00003BD6  DEFC 0010 11080          add.w     #16,A7
00003BDA  C0BC 0000 11081          and.l     #255,D0
00003BDE  00FF      
                    11082   ; nbr_tasks++;
00003BE0  5203      11083          addq.b    #1,D3
00003BE2  60DA      11084          bra       OSQPendAbort_11
                    11085   OSQPendAbort_13:
                    11086   ; }
                    11087   ; break;
00003BE4  601C      11088          bra.s     OSQPendAbort_7
                    11089   OSQPendAbort_9:
                    11090   ; case OS_PEND_OPT_NONE:
                    11091   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    11092   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003BE6  4878 0002 11093          pea       2
00003BEA  4878 0004 11094          pea       4
00003BEE  42A7      11095          clr.l     -(A7)
00003BF0  2F02      11096          move.l    D2,-(A7)
00003BF2  4EB8 1236 11097          jsr       _OS_EventTaskRdy
00003BF6  DEFC 0010 11098          add.w     #16,A7
00003BFA  C0BC 0000 11099          and.l     #255,D0
00003BFE  00FF      
                    11100   ; nbr_tasks++;
00003C00  5203      11101          addq.b    #1,D3
                    11102   ; break;
                    11103   OSQPendAbort_7:
                    11104   ; }
                    11105   ; OS_EXIT_CRITICAL();
00003C02  46DF      11106          dc.w      18143
                    11107   ; OS_Sched();                                        /* Find HPT ready to run                    */
00003C04  4EB8 1816 11108          jsr       _OS_Sched
                    11109   ; *perr = OS_ERR_PEND_ABORT;
00003C08  2044      11110          move.l    D4,A0
00003C0A  10BC 000E 11111          move.b    #14,(A0)
                    11112   ; return (nbr_tasks);
00003C0E  1003      11113          move.b    D3,D0
00003C10  6008      11114          bra.s     OSQPendAbort_3
                    11115   OSQPendAbort_4:
                    11116   ; }
                    11117   ; OS_EXIT_CRITICAL();
00003C12  46DF      11118          dc.w      18143
                    11119   ; *perr = OS_ERR_NONE;
00003C14  2044      11120          move.l    D4,A0
00003C16  4210      11121          clr.b     (A0)
                    11122   ; return (0u);                                           /* No tasks waiting on queue                */
00003C18  4200      11123          clr.b     D0
                    11124   OSQPendAbort_3:
00003C1A  4CDF 001C 11125          movem.l   (A7)+,D2/D3/D4
00003C1E  4E5E      11126          unlk      A6
00003C20  4E75      11127          rts
                    11128   ; }
                    11129   ; #endif
                    11130   ; /*$PAGE*/
                    11131   ; /*
                    11132   ; *********************************************************************************************************
                    11133   ; *                                       POST MESSAGE TO A QUEUE
                    11134   ; *
                    11135   ; * Description: This function sends a message to a queue
                    11136   ; *
                    11137   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11138   ; *
                    11139   ; *              pmsg          is a pointer to the message to send.
                    11140   ; *
                    11141   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11142   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11143   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11144   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11145   ; *
                    11146   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11147   ; *********************************************************************************************************
                    11148   ; */
                    11149   ; #if OS_Q_POST_EN > 0u
                    11150   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    11151   ; void      *pmsg)
                    11152   ; {
                    11153   _OSQPost:
00003C22  4E56 0000 11154          link      A6,#0
00003C26  48E7 3000 11155          movem.l   D2/D3,-(A7)
00003C2A  262E 0008 11156          move.l    8(A6),D3
                    11157   ; OS_Q      *pq;
                    11158   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11159   ; OS_CPU_SR  cpu_sr = 0u;
                    11160   ; #endif
                    11161   ; #if OS_ARG_CHK_EN > 0u
                    11162   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11163   ; return (OS_ERR_PEVENT_NULL);
                    11164   ; }
                    11165   ; #endif
                    11166   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003C2E  2043      11167          move.l    D3,A0
00003C30  1010      11168          move.b    (A0),D0
00003C32  0C00 0002 11169          cmp.b     #2,D0
00003C36  6706      11170          beq.s     OSQPost_1
                    11171   ; return (OS_ERR_EVENT_TYPE);
00003C38  7001      11172          moveq     #1,D0
00003C3A  6000 008C 11173          bra       OSQPost_3
                    11174   OSQPost_1:
                    11175   ; }
                    11176   ; OS_ENTER_CRITICAL();
00003C3E  40E7      11177          dc.w      16615
00003C40  007C      11178          dc.w      124
00003C42  0700      11179          dc.w      1792
                    11180   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003C44  2043      11181          move.l    D3,A0
00003C46  1028 0008 11182          move.b    8(A0),D0
00003C4A  6726      11183          beq.s     OSQPost_4
                    11184   ; /* Ready highest priority task waiting on event */
                    11185   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003C4C  42A7      11186          clr.l     -(A7)
00003C4E  4878 0004 11187          pea       4
00003C52  2F2E 000C 11188          move.l    12(A6),-(A7)
00003C56  2F03      11189          move.l    D3,-(A7)
00003C58  4EB8 1236 11190          jsr       _OS_EventTaskRdy
00003C5C  DEFC 0010 11191          add.w     #16,A7
00003C60  C0BC 0000 11192          and.l     #255,D0
00003C64  00FF      
                    11193   ; OS_EXIT_CRITICAL();
00003C66  46DF      11194          dc.w      18143
                    11195   ; OS_Sched();                                    /* Find highest priority task ready to run      */
00003C68  4EB8 1816 11196          jsr       _OS_Sched
                    11197   ; return (OS_ERR_NONE);
00003C6C  4200      11198          clr.b     D0
00003C6E  6000 0058 11199          bra       OSQPost_3
                    11200   OSQPost_4:
                    11201   ; }
                    11202   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003C72  2043      11203          move.l    D3,A0
00003C74  2428 0002 11204          move.l    2(A0),D2
                    11205   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
00003C78  2042      11206          move.l    D2,A0
00003C7A  2242      11207          move.l    D2,A1
00003C7C  3028 0016 11208          move.w    22(A0),D0
00003C80  B069 0014 11209          cmp.w     20(A1),D0
00003C84  6508      11210          blo.s     OSQPost_6
                    11211   ; OS_EXIT_CRITICAL();
00003C86  46DF      11212          dc.w      18143
                    11213   ; return (OS_ERR_Q_FULL);
00003C88  701E      11214          moveq     #30,D0
00003C8A  6000 003C 11215          bra       OSQPost_3
                    11216   OSQPost_6:
                    11217   ; }
                    11218   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003C8E  2002      11219          move.l    D2,D0
00003C90  0680 0000 11220          add.l     #12,D0
00003C94  000C      
00003C96  2040      11221          move.l    D0,A0
00003C98  2250      11222          move.l    (A0),A1
00003C9A  5890      11223          addq.l    #4,(A0)
00003C9C  22AE 000C 11224          move.l    12(A6),(A1)
                    11225   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003CA0  2002      11226          move.l    D2,D0
00003CA2  0680 0000 11227          add.l     #22,D0
00003CA6  0016      
00003CA8  2040      11228          move.l    D0,A0
00003CAA  5250      11229          addq.w    #1,(A0)
                    11230   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
00003CAC  2042      11231          move.l    D2,A0
00003CAE  2242      11232          move.l    D2,A1
00003CB0  2028 000C 11233          move.l    12(A0),D0
00003CB4  B0A9 0008 11234          cmp.l     8(A1),D0
00003CB8  660A      11235          bne.s     OSQPost_8
                    11236   ; pq->OSQIn = pq->OSQStart;
00003CBA  2042      11237          move.l    D2,A0
00003CBC  2242      11238          move.l    D2,A1
00003CBE  2368 0004 11239          move.l    4(A0),12(A1)
00003CC2  000C      
                    11240   OSQPost_8:
                    11241   ; }
                    11242   ; OS_EXIT_CRITICAL();
00003CC4  46DF      11243          dc.w      18143
                    11244   ; return (OS_ERR_NONE);
00003CC6  4200      11245          clr.b     D0
                    11246   OSQPost_3:
00003CC8  4CDF 000C 11247          movem.l   (A7)+,D2/D3
00003CCC  4E5E      11248          unlk      A6
00003CCE  4E75      11249          rts
                    11250   ; }
                    11251   ; #endif
                    11252   ; /*$PAGE*/
                    11253   ; /*
                    11254   ; *********************************************************************************************************
                    11255   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    11256   ; *
                    11257   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    11258   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    11259   ; *              'priority' messages.
                    11260   ; *
                    11261   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11262   ; *
                    11263   ; *              pmsg          is a pointer to the message to send.
                    11264   ; *
                    11265   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11266   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11267   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11268   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11269   ; *
                    11270   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11271   ; *********************************************************************************************************
                    11272   ; */
                    11273   ; #if OS_Q_POST_FRONT_EN > 0u
                    11274   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    11275   ; void      *pmsg)
                    11276   ; {
                    11277   _OSQPostFront:
00003CD0  4E56 0000 11278          link      A6,#0
00003CD4  48E7 3000 11279          movem.l   D2/D3,-(A7)
00003CD8  262E 0008 11280          move.l    8(A6),D3
                    11281   ; OS_Q      *pq;
                    11282   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11283   ; OS_CPU_SR  cpu_sr = 0u;
                    11284   ; #endif
                    11285   ; #if OS_ARG_CHK_EN > 0u
                    11286   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11287   ; return (OS_ERR_PEVENT_NULL);
                    11288   ; }
                    11289   ; #endif
                    11290   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003CDC  2043      11291          move.l    D3,A0
00003CDE  1010      11292          move.b    (A0),D0
00003CE0  0C00 0002 11293          cmp.b     #2,D0
00003CE4  6706      11294          beq.s     OSQPostFront_1
                    11295   ; return (OS_ERR_EVENT_TYPE);
00003CE6  7001      11296          moveq     #1,D0
00003CE8  6000 0090 11297          bra       OSQPostFront_3
                    11298   OSQPostFront_1:
                    11299   ; }
                    11300   ; OS_ENTER_CRITICAL();
00003CEC  40E7      11301          dc.w      16615
00003CEE  007C      11302          dc.w      124
00003CF0  0700      11303          dc.w      1792
                    11304   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00003CF2  2043      11305          move.l    D3,A0
00003CF4  1028 0008 11306          move.b    8(A0),D0
00003CF8  6726      11307          beq.s     OSQPostFront_4
                    11308   ; /* Ready highest priority task waiting on event  */
                    11309   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003CFA  42A7      11310          clr.l     -(A7)
00003CFC  4878 0004 11311          pea       4
00003D00  2F2E 000C 11312          move.l    12(A6),-(A7)
00003D04  2F03      11313          move.l    D3,-(A7)
00003D06  4EB8 1236 11314          jsr       _OS_EventTaskRdy
00003D0A  DEFC 0010 11315          add.w     #16,A7
00003D0E  C0BC 0000 11316          and.l     #255,D0
00003D12  00FF      
                    11317   ; OS_EXIT_CRITICAL();
00003D14  46DF      11318          dc.w      18143
                    11319   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00003D16  4EB8 1816 11320          jsr       _OS_Sched
                    11321   ; return (OS_ERR_NONE);
00003D1A  4200      11322          clr.b     D0
00003D1C  6000 005C 11323          bra       OSQPostFront_3
                    11324   OSQPostFront_4:
                    11325   ; }
                    11326   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003D20  2043      11327          move.l    D3,A0
00003D22  2428 0002 11328          move.l    2(A0),D2
                    11329   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003D26  2042      11330          move.l    D2,A0
00003D28  2242      11331          move.l    D2,A1
00003D2A  3028 0016 11332          move.w    22(A0),D0
00003D2E  B069 0014 11333          cmp.w     20(A1),D0
00003D32  6508      11334          blo.s     OSQPostFront_6
                    11335   ; OS_EXIT_CRITICAL();
00003D34  46DF      11336          dc.w      18143
                    11337   ; return (OS_ERR_Q_FULL);
00003D36  701E      11338          moveq     #30,D0
00003D38  6000 0040 11339          bra       OSQPostFront_3
                    11340   OSQPostFront_6:
                    11341   ; }
                    11342   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
00003D3C  2042      11343          move.l    D2,A0
00003D3E  2242      11344          move.l    D2,A1
00003D40  2028 0010 11345          move.l    16(A0),D0
00003D44  B0A9 0004 11346          cmp.l     4(A1),D0
00003D48  660A      11347          bne.s     OSQPostFront_8
                    11348   ; pq->OSQOut = pq->OSQEnd;
00003D4A  2042      11349          move.l    D2,A0
00003D4C  2242      11350          move.l    D2,A1
00003D4E  2368 0008 11351          move.l    8(A0),16(A1)
00003D52  0010      
                    11352   OSQPostFront_8:
                    11353   ; }
                    11354   ; pq->OSQOut--;
00003D54  2002      11355          move.l    D2,D0
00003D56  0680 0000 11356          add.l     #16,D0
00003D5A  0010      
00003D5C  2040      11357          move.l    D0,A0
00003D5E  5990      11358          subq.l    #4,(A0)
                    11359   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003D60  2042      11360          move.l    D2,A0
00003D62  2068 0010 11361          move.l    16(A0),A0
00003D66  20AE 000C 11362          move.l    12(A6),(A0)
                    11363   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003D6A  2002      11364          move.l    D2,D0
00003D6C  0680 0000 11365          add.l     #22,D0
00003D70  0016      
00003D72  2040      11366          move.l    D0,A0
00003D74  5250      11367          addq.w    #1,(A0)
                    11368   ; OS_EXIT_CRITICAL();
00003D76  46DF      11369          dc.w      18143
                    11370   ; return (OS_ERR_NONE);
00003D78  4200      11371          clr.b     D0
                    11372   OSQPostFront_3:
00003D7A  4CDF 000C 11373          movem.l   (A7)+,D2/D3
00003D7E  4E5E      11374          unlk      A6
00003D80  4E75      11375          rts
                    11376   ; }
                    11377   ; #endif
                    11378   ; /*$PAGE*/
                    11379   ; /*
                    11380   ; *********************************************************************************************************
                    11381   ; *                                       POST MESSAGE TO A QUEUE
                    11382   ; *
                    11383   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11384   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11385   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11386   ; *
                    11387   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11388   ; *
                    11389   ; *              pmsg          is a pointer to the message to send.
                    11390   ; *
                    11391   ; *              opt           determines the type of POST performed:
                    11392   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11393   ; *                                                     (Identical to OSQPost())
                    11394   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11395   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11396   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11397   ; *
                    11398   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11399   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11400   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11401   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11402   ; *
                    11403   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11404   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11405   ; *********************************************************************************************************
                    11406   ; */
                    11407   ; #if OS_Q_POST_OPT_EN > 0u
                    11408   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11409   ; void      *pmsg,
                    11410   ; INT8U      opt)
                    11411   ; {
                    11412   _OSQPostOpt:
00003D82  4E56 0000 11413          link      A6,#0
00003D86  48E7 3C00 11414          movem.l   D2/D3/D4/D5,-(A7)
00003D8A  262E 0008 11415          move.l    8(A6),D3
00003D8E  282E 000C 11416          move.l    12(A6),D4
00003D92  1A2E 0013 11417          move.b    19(A6),D5
00003D96  CABC 0000 11418          and.l     #255,D5
00003D9A  00FF      
                    11419   ; OS_Q      *pq;
                    11420   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11421   ; OS_CPU_SR  cpu_sr = 0u;
                    11422   ; #endif
                    11423   ; #if OS_ARG_CHK_EN > 0u
                    11424   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11425   ; return (OS_ERR_PEVENT_NULL);
                    11426   ; }
                    11427   ; #endif
                    11428   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003D9C  2043      11429          move.l    D3,A0
00003D9E  1010      11430          move.b    (A0),D0
00003DA0  0C00 0002 11431          cmp.b     #2,D0
00003DA4  6706      11432          beq.s     OSQPostOpt_1
                    11433   ; return (OS_ERR_EVENT_TYPE);
00003DA6  7001      11434          moveq     #1,D0
00003DA8  6000 00F6 11435          bra       OSQPostOpt_3
                    11436   OSQPostOpt_1:
                    11437   ; }
                    11438   ; OS_ENTER_CRITICAL();
00003DAC  40E7      11439          dc.w      16615
00003DAE  007C      11440          dc.w      124
00003DB0  0700      11441          dc.w      1792
                    11442   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003DB2  2043      11443          move.l    D3,A0
00003DB4  1028 0008 11444          move.b    8(A0),D0
00003DB8  6700 005A 11445          beq       OSQPostOpt_4
                    11446   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00003DBC  1005      11447          move.b    D5,D0
00003DBE  C03C 0001 11448          and.b     #1,D0
00003DC2  6724      11449          beq.s     OSQPostOpt_6
                    11450   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11451   OSQPostOpt_8:
00003DC4  2043      11452          move.l    D3,A0
00003DC6  1028 0008 11453          move.b    8(A0),D0
00003DCA  671A      11454          beq.s     OSQPostOpt_10
                    11455   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003DCC  42A7      11456          clr.l     -(A7)
00003DCE  4878 0004 11457          pea       4
00003DD2  2F04      11458          move.l    D4,-(A7)
00003DD4  2F03      11459          move.l    D3,-(A7)
00003DD6  4EB8 1236 11460          jsr       _OS_EventTaskRdy
00003DDA  DEFC 0010 11461          add.w     #16,A7
00003DDE  C0BC 0000 11462          and.l     #255,D0
00003DE2  00FF      
00003DE4  60DE      11463          bra       OSQPostOpt_8
                    11464   OSQPostOpt_10:
00003DE6  6018      11465          bra.s     OSQPostOpt_7
                    11466   OSQPostOpt_6:
                    11467   ; }
                    11468   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11469   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003DE8  42A7      11470          clr.l     -(A7)
00003DEA  4878 0004 11471          pea       4
00003DEE  2F04      11472          move.l    D4,-(A7)
00003DF0  2F03      11473          move.l    D3,-(A7)
00003DF2  4EB8 1236 11474          jsr       _OS_EventTaskRdy
00003DF6  DEFC 0010 11475          add.w     #16,A7
00003DFA  C0BC 0000 11476          and.l     #255,D0
00003DFE  00FF      
                    11477   OSQPostOpt_7:
                    11478   ; }
                    11479   ; OS_EXIT_CRITICAL();
00003E00  46DF      11480          dc.w      18143
                    11481   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00003E02  1005      11482          move.b    D5,D0
00003E04  C03C 0004 11483          and.b     #4,D0
00003E08  6604      11484          bne.s     OSQPostOpt_11
                    11485   ; OS_Sched();                               /* Find highest priority task ready to run       */
00003E0A  4EB8 1816 11486          jsr       _OS_Sched
                    11487   OSQPostOpt_11:
                    11488   ; }
                    11489   ; return (OS_ERR_NONE);
00003E0E  4200      11490          clr.b     D0
00003E10  6000 008E 11491          bra       OSQPostOpt_3
                    11492   OSQPostOpt_4:
                    11493   ; }
                    11494   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003E14  2043      11495          move.l    D3,A0
00003E16  2428 0002 11496          move.l    2(A0),D2
                    11497   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003E1A  2042      11498          move.l    D2,A0
00003E1C  2242      11499          move.l    D2,A1
00003E1E  3028 0016 11500          move.w    22(A0),D0
00003E22  B069 0014 11501          cmp.w     20(A1),D0
00003E26  6508      11502          blo.s     OSQPostOpt_13
                    11503   ; OS_EXIT_CRITICAL();
00003E28  46DF      11504          dc.w      18143
                    11505   ; return (OS_ERR_Q_FULL);
00003E2A  701E      11506          moveq     #30,D0
00003E2C  6000 0072 11507          bra       OSQPostOpt_3
                    11508   OSQPostOpt_13:
                    11509   ; }
                    11510   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00003E30  1005      11511          move.b    D5,D0
00003E32  C03C 0002 11512          and.b     #2,D0
00003E36  6700 0030 11513          beq       OSQPostOpt_15
                    11514   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00003E3A  2042      11515          move.l    D2,A0
00003E3C  2242      11516          move.l    D2,A1
00003E3E  2028 0010 11517          move.l    16(A0),D0
00003E42  B0A9 0004 11518          cmp.l     4(A1),D0
00003E46  660A      11519          bne.s     OSQPostOpt_17
                    11520   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00003E48  2042      11521          move.l    D2,A0
00003E4A  2242      11522          move.l    D2,A1
00003E4C  2368 0008 11523          move.l    8(A0),16(A1)
00003E50  0010      
                    11524   OSQPostOpt_17:
                    11525   ; }
                    11526   ; pq->OSQOut--;
00003E52  2002      11527          move.l    D2,D0
00003E54  0680 0000 11528          add.l     #16,D0
00003E58  0010      
00003E5A  2040      11529          move.l    D0,A0
00003E5C  5990      11530          subq.l    #4,(A0)
                    11531   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
00003E5E  2042      11532          move.l    D2,A0
00003E60  2068 0010 11533          move.l    16(A0),A0
00003E64  2084      11534          move.l    D4,(A0)
00003E66  6028      11535          bra.s     OSQPostOpt_19
                    11536   OSQPostOpt_15:
                    11537   ; } else {                                          /* No,  Post as FIFO                             */
                    11538   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00003E68  2002      11539          move.l    D2,D0
00003E6A  0680 0000 11540          add.l     #12,D0
00003E6E  000C      
00003E70  2040      11541          move.l    D0,A0
00003E72  2250      11542          move.l    (A0),A1
00003E74  5890      11543          addq.l    #4,(A0)
00003E76  2284      11544          move.l    D4,(A1)
                    11545   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00003E78  2042      11546          move.l    D2,A0
00003E7A  2242      11547          move.l    D2,A1
00003E7C  2028 000C 11548          move.l    12(A0),D0
00003E80  B0A9 0008 11549          cmp.l     8(A1),D0
00003E84  660A      11550          bne.s     OSQPostOpt_19
                    11551   ; pq->OSQIn = pq->OSQStart;
00003E86  2042      11552          move.l    D2,A0
00003E88  2242      11553          move.l    D2,A1
00003E8A  2368 0004 11554          move.l    4(A0),12(A1)
00003E8E  000C      
                    11555   OSQPostOpt_19:
                    11556   ; }
                    11557   ; }
                    11558   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003E90  2002      11559          move.l    D2,D0
00003E92  0680 0000 11560          add.l     #22,D0
00003E96  0016      
00003E98  2040      11561          move.l    D0,A0
00003E9A  5250      11562          addq.w    #1,(A0)
                    11563   ; OS_EXIT_CRITICAL();
00003E9C  46DF      11564          dc.w      18143
                    11565   ; return (OS_ERR_NONE);
00003E9E  4200      11566          clr.b     D0
                    11567   OSQPostOpt_3:
00003EA0  4CDF 003C 11568          movem.l   (A7)+,D2/D3/D4/D5
00003EA4  4E5E      11569          unlk      A6
00003EA6  4E75      11570          rts
                    11571   ; }
                    11572   ; #endif
                    11573   ; /*$PAGE*/
                    11574   ; /*
                    11575   ; *********************************************************************************************************
                    11576   ; *                                        QUERY A MESSAGE QUEUE
                    11577   ; *
                    11578   ; * Description: This function obtains information about a message queue.
                    11579   ; *
                    11580   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11581   ; *
                    11582   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11583   ; *                            queue.
                    11584   ; *
                    11585   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11586   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11587   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11588   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11589   ; *********************************************************************************************************
                    11590   ; */
                    11591   ; #if OS_Q_QUERY_EN > 0u
                    11592   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11593   ; OS_Q_DATA *p_q_data)
                    11594   ; {
                    11595   _OSQQuery:
00003EA8  4E56 FFF8 11596          link      A6,#-8
00003EAC  48E7 3C00 11597          movem.l   D2/D3/D4/D5,-(A7)
00003EB0  242E 000C 11598          move.l    12(A6),D2
00003EB4  282E 0008 11599          move.l    8(A6),D4
                    11600   ; OS_Q       *pq;
                    11601   ; INT8U       i;
                    11602   ; OS_PRIO    *psrc;
                    11603   ; OS_PRIO    *pdest;
                    11604   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11605   ; OS_CPU_SR   cpu_sr = 0u;
                    11606   ; #endif
                    11607   ; #if OS_ARG_CHK_EN > 0u
                    11608   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11609   ; return (OS_ERR_PEVENT_NULL);
                    11610   ; }
                    11611   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11612   ; return (OS_ERR_PDATA_NULL);
                    11613   ; }
                    11614   ; #endif
                    11615   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003EB8  2044      11616          move.l    D4,A0
00003EBA  1010      11617          move.b    (A0),D0
00003EBC  0C00 0002 11618          cmp.b     #2,D0
00003EC0  6706      11619          beq.s     OSQQuery_1
                    11620   ; return (OS_ERR_EVENT_TYPE);
00003EC2  7001      11621          moveq     #1,D0
00003EC4  6000 007A 11622          bra       OSQQuery_3
                    11623   OSQQuery_1:
                    11624   ; }
                    11625   ; OS_ENTER_CRITICAL();
00003EC8  40E7      11626          dc.w      16615
00003ECA  007C      11627          dc.w      124
00003ECC  0700      11628          dc.w      1792
                    11629   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00003ECE  2044      11630          move.l    D4,A0
00003ED0  2242      11631          move.l    D2,A1
00003ED2  1368 0008 11632          move.b    8(A0),16(A1)
00003ED6  0010      
                    11633   ; psrc                 = &pevent->OSEventTbl[0];
00003ED8  700A      11634          moveq     #10,D0
00003EDA  D084      11635          add.l     D4,D0
00003EDC  2D40 FFF8 11636          move.l    D0,-8(A6)
                    11637   ; pdest                = &p_q_data->OSEventTbl[0];
00003EE0  7008      11638          moveq     #8,D0
00003EE2  D082      11639          add.l     D2,D0
00003EE4  2D40 FFFC 11640          move.l    D0,-4(A6)
                    11641   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003EE8  4205      11642          clr.b     D5
                    11643   OSQQuery_4:
00003EEA  0C05 0008 11644          cmp.b     #8,D5
00003EEE  6416      11645          bhs.s     OSQQuery_6
                    11646   ; *pdest++ = *psrc++;
00003EF0  206E FFF8 11647          move.l    -8(A6),A0
00003EF4  52AE FFF8 11648          addq.l    #1,-8(A6)
00003EF8  226E FFFC 11649          move.l    -4(A6),A1
00003EFC  52AE FFFC 11650          addq.l    #1,-4(A6)
00003F00  1290      11651          move.b    (A0),(A1)
00003F02  5205      11652          addq.b    #1,D5
00003F04  60E4      11653          bra       OSQQuery_4
                    11654   OSQQuery_6:
                    11655   ; }
                    11656   ; pq = (OS_Q *)pevent->OSEventPtr;
00003F06  2044      11657          move.l    D4,A0
00003F08  2628 0002 11658          move.l    2(A0),D3
                    11659   ; if (pq->OSQEntries > 0u) {
00003F0C  2043      11660          move.l    D3,A0
00003F0E  3028 0016 11661          move.w    22(A0),D0
00003F12  0C40 0000 11662          cmp.w     #0,D0
00003F16  630C      11663          bls.s     OSQQuery_7
                    11664   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00003F18  2043      11665          move.l    D3,A0
00003F1A  2068 0010 11666          move.l    16(A0),A0
00003F1E  2242      11667          move.l    D2,A1
00003F20  2290      11668          move.l    (A0),(A1)
00003F22  6004      11669          bra.s     OSQQuery_8
                    11670   OSQQuery_7:
                    11671   ; } else {
                    11672   ; p_q_data->OSMsg = (void *)0;
00003F24  2042      11673          move.l    D2,A0
00003F26  4290      11674          clr.l     (A0)
                    11675   OSQQuery_8:
                    11676   ; }
                    11677   ; p_q_data->OSNMsgs = pq->OSQEntries;
00003F28  2043      11678          move.l    D3,A0
00003F2A  2242      11679          move.l    D2,A1
00003F2C  3368 0016 11680          move.w    22(A0),4(A1)
00003F30  0004      
                    11681   ; p_q_data->OSQSize = pq->OSQSize;
00003F32  2043      11682          move.l    D3,A0
00003F34  2242      11683          move.l    D2,A1
00003F36  3368 0014 11684          move.w    20(A0),6(A1)
00003F3A  0006      
                    11685   ; OS_EXIT_CRITICAL();
00003F3C  46DF      11686          dc.w      18143
                    11687   ; return (OS_ERR_NONE);
00003F3E  4200      11688          clr.b     D0
                    11689   OSQQuery_3:
00003F40  4CDF 003C 11690          movem.l   (A7)+,D2/D3/D4/D5
00003F44  4E5E      11691          unlk      A6
00003F46  4E75      11692          rts
                    11693   ; }
                    11694   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11695   ; /*$PAGE*/
                    11696   ; /*
                    11697   ; *********************************************************************************************************
                    11698   ; *                                     QUEUE MODULE INITIALIZATION
                    11699   ; *
                    11700   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11701   ; *               application MUST NOT call this function.
                    11702   ; *
                    11703   ; * Arguments   :  none
                    11704   ; *
                    11705   ; * Returns     : none
                    11706   ; *
                    11707   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11708   ; *********************************************************************************************************
                    11709   ; */
                    11710   ; void  OS_QInit (void)
                    11711   ; {
                    11712   _OS_QInit:
00003F48  4E56 FFF8 11713          link      A6,#-8
00003F4C  48E7 3020 11714          movem.l   D2/D3/A2,-(A7)
00003F50  45F9 0800 11715          lea       _OSQTbl.L,A2
00003F54  1914      
                    11716   ; #if OS_MAX_QS == 1u
                    11717   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11718   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11719   ; #endif
                    11720   ; #if OS_MAX_QS >= 2u
                    11721   ; INT16U   ix;
                    11722   ; INT16U   ix_next;
                    11723   ; OS_Q    *pq1;
                    11724   ; OS_Q    *pq2;
                    11725   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00003F56  4878 0060 11726          pea       96
00003F5A  2F0A      11727          move.l    A2,-(A7)
00003F5C  4EB8 17CA 11728          jsr       _OS_MemClr
00003F60  504F      11729          addq.w    #8,A7
                    11730   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00003F62  4242      11731          clr.w     D2
                    11732   OS_QInit_1:
00003F64  0C42 0003 11733          cmp.w     #3,D2
00003F68  6400 003C 11734          bhs       OS_QInit_3
                    11735   ; ix_next = ix + 1u;
00003F6C  3002      11736          move.w    D2,D0
00003F6E  5240      11737          addq.w    #1,D0
00003F70  3D40 FFFA 11738          move.w    D0,-6(A6)
                    11739   ; pq1 = &OSQTbl[ix];
00003F74  200A      11740          move.l    A2,D0
00003F76  C4BC 0000 11741          and.l     #65535,D2
00003F7A  FFFF      
00003F7C  2202      11742          move.l    D2,D1
00003F7E  C3FC 0018 11743          muls      #24,D1
00003F82  D081      11744          add.l     D1,D0
00003F84  2600      11745          move.l    D0,D3
                    11746   ; pq2 = &OSQTbl[ix_next];
00003F86  200A      11747          move.l    A2,D0
00003F88  322E FFFA 11748          move.w    -6(A6),D1
00003F8C  C2BC 0000 11749          and.l     #65535,D1
00003F90  FFFF      
00003F92  C3FC 0018 11750          muls      #24,D1
00003F96  D081      11751          add.l     D1,D0
00003F98  2D40 FFFC 11752          move.l    D0,-4(A6)
                    11753   ; pq1->OSQPtr = pq2;
00003F9C  2043      11754          move.l    D3,A0
00003F9E  20AE FFFC 11755          move.l    -4(A6),(A0)
00003FA2  5242      11756          addq.w    #1,D2
00003FA4  60BE      11757          bra       OS_QInit_1
                    11758   OS_QInit_3:
                    11759   ; }
                    11760   ; pq1         = &OSQTbl[ix];
00003FA6  200A      11761          move.l    A2,D0
00003FA8  C4BC 0000 11762          and.l     #65535,D2
00003FAC  FFFF      
00003FAE  2202      11763          move.l    D2,D1
00003FB0  C3FC 0018 11764          muls      #24,D1
00003FB4  D081      11765          add.l     D1,D0
00003FB6  2600      11766          move.l    D0,D3
                    11767   ; pq1->OSQPtr = (OS_Q *)0;
00003FB8  2043      11768          move.l    D3,A0
00003FBA  4290      11769          clr.l     (A0)
                    11770   ; OSQFreeList = &OSQTbl[0];
00003FBC  23CA 0800 11771          move.l    A2,_OSQFreeList.L
00003FC0  1910      
00003FC2  4CDF 040C 11772          movem.l   (A7)+,D2/D3/A2
00003FC6  4E5E      11773          unlk      A6
00003FC8  4E75      11774          rts
                    11775   ; /*
                    11776   ; *********************************************************************************************************
                    11777   ; *                                                uC/OS-II
                    11778   ; *                                          The Real-Time Kernel
                    11779   ; *                                          SEMAPHORE MANAGEMENT
                    11780   ; *
                    11781   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11782   ; *                                           All Rights Reserved
                    11783   ; *
                    11784   ; * File    : OS_SEM.C
                    11785   ; * By      : Jean J. Labrosse
                    11786   ; * Version : V2.92.07
                    11787   ; *
                    11788   ; * LICENSING TERMS:
                    11789   ; * ---------------
                    11790   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11791   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11792   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11793   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11794   ; * licensing fee.
                    11795   ; *********************************************************************************************************
                    11796   ; */
                    11797   ; #define  MICRIUM_SOURCE
                    11798   ; #ifndef  OS_MASTER_FILE
                    11799   ; #include <ucos_ii.h>
                    11800   ; #endif
                    11801   ; #if OS_SEM_EN > 0u
                    11802   ; /*$PAGE*/
                    11803   ; /*
                    11804   ; *********************************************************************************************************
                    11805   ; *                                          ACCEPT SEMAPHORE
                    11806   ; *
                    11807   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11808   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11809   ; *              resource is not available or the event did not occur.
                    11810   ; *
                    11811   ; * Arguments  : pevent     is a pointer to the event control block
                    11812   ; *
                    11813   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11814   ; *                         decremented to obtain the resource.
                    11815   ; *              == 0       if the resource is not available or the event did not occur or,
                    11816   ; *                         if 'pevent' is a NULL pointer or,
                    11817   ; *                         if you didn't pass a pointer to a semaphore
                    11818   ; *********************************************************************************************************
                    11819   ; */
                    11820   ; #if OS_SEM_ACCEPT_EN > 0u
                    11821   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11822   ; {
                    11823   _OSSemAccept:
00003FCA  4E56 0000 11824          link      A6,#0
00003FCE  48E7 3000 11825          movem.l   D2/D3,-(A7)
00003FD2  262E 0008 11826          move.l    8(A6),D3
                    11827   ; INT16U     cnt;
                    11828   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11829   ; OS_CPU_SR  cpu_sr = 0u;
                    11830   ; #endif
                    11831   ; #if OS_ARG_CHK_EN > 0u
                    11832   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11833   ; return (0u);
                    11834   ; }
                    11835   ; #endif
                    11836   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003FD6  2043      11837          move.l    D3,A0
00003FD8  1010      11838          move.b    (A0),D0
00003FDA  0C00 0003 11839          cmp.b     #3,D0
00003FDE  6704      11840          beq.s     OSSemAccept_1
                    11841   ; return (0u);
00003FE0  4240      11842          clr.w     D0
00003FE2  601E      11843          bra.s     OSSemAccept_3
                    11844   OSSemAccept_1:
                    11845   ; }
                    11846   ; OS_ENTER_CRITICAL();
00003FE4  40E7      11847          dc.w      16615
00003FE6  007C      11848          dc.w      124
00003FE8  0700      11849          dc.w      1792
                    11850   ; cnt = pevent->OSEventCnt;
00003FEA  2043      11851          move.l    D3,A0
00003FEC  3428 0006 11852          move.w    6(A0),D2
                    11853   ; if (cnt > 0u) {                                   /* See if resource is available                  */
00003FF0  0C42 0000 11854          cmp.w     #0,D2
00003FF4  6308      11855          bls.s     OSSemAccept_4
                    11856   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
00003FF6  2003      11857          move.l    D3,D0
00003FF8  5C80      11858          addq.l    #6,D0
00003FFA  2040      11859          move.l    D0,A0
00003FFC  5350      11860          subq.w    #1,(A0)
                    11861   OSSemAccept_4:
                    11862   ; }
                    11863   ; OS_EXIT_CRITICAL();
00003FFE  46DF      11864          dc.w      18143
                    11865   ; return (cnt);                                     /* Return semaphore count                        */
00004000  3002      11866          move.w    D2,D0
                    11867   OSSemAccept_3:
00004002  4CDF 000C 11868          movem.l   (A7)+,D2/D3
00004006  4E5E      11869          unlk      A6
00004008  4E75      11870          rts
                    11871   ; }
                    11872   ; #endif
                    11873   ; /*$PAGE*/
                    11874   ; /*
                    11875   ; *********************************************************************************************************
                    11876   ; *                                         CREATE A SEMAPHORE
                    11877   ; *
                    11878   ; * Description: This function creates a semaphore.
                    11879   ; *
                    11880   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11881   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11882   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11883   ; *                            10 resources, you would initialize the semaphore to 10).
                    11884   ; *
                    11885   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11886   ; *                            created semaphore
                    11887   ; *              == (void *)0  if no event control blocks were available
                    11888   ; *********************************************************************************************************
                    11889   ; */
                    11890   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11891   ; {
                    11892   _OSSemCreate:
0000400A  4E56 0000 11893          link      A6,#0
0000400E  48E7 2020 11894          movem.l   D2/A2,-(A7)
00004012  45F9 0800 11895          lea       _OSEventFreeList.L,A2
00004016  0CDA      
                    11896   ; OS_EVENT  *pevent;
                    11897   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11898   ; OS_CPU_SR  cpu_sr = 0u;
                    11899   ; #endif
                    11900   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11901   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11902   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11903   ; return ((OS_EVENT *)0);
                    11904   ; }
                    11905   ; #endif
                    11906   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00004018  1039 0800 11907          move.b    _OSIntNesting.L,D0
0000401C  0F06      
0000401E  0C00 0000 11908          cmp.b     #0,D0
00004022  6306      11909          bls.s     OSSemCreate_1
                    11910   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00004024  4280      11911          clr.l     D0
00004026  6000 0044 11912          bra       OSSemCreate_3
                    11913   OSSemCreate_1:
                    11914   ; }
                    11915   ; OS_ENTER_CRITICAL();
0000402A  40E7      11916          dc.w      16615
0000402C  007C      11917          dc.w      124
0000402E  0700      11918          dc.w      1792
                    11919   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00004030  2412      11920          move.l    (A2),D2
                    11921   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
00004032  2012      11922          move.l    (A2),D0
00004034  6706      11923          beq.s     OSSemCreate_4
                    11924   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00004036  2052      11925          move.l    (A2),A0
00004038  24A8 0002 11926          move.l    2(A0),(A2)
                    11927   OSSemCreate_4:
                    11928   ; }
                    11929   ; OS_EXIT_CRITICAL();
0000403C  46DF      11930          dc.w      18143
                    11931   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
0000403E  4A82      11932          tst.l     D2
00004040  6728      11933          beq.s     OSSemCreate_6
                    11934   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00004042  2042      11935          move.l    D2,A0
00004044  10BC 0003 11936          move.b    #3,(A0)
                    11937   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00004048  2042      11938          move.l    D2,A0
0000404A  316E 000A 11939          move.w    10(A6),6(A0)
0000404E  0006      
                    11940   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
00004050  2042      11941          move.l    D2,A0
00004052  42A8 0002 11942          clr.l     2(A0)
                    11943   ; #if OS_EVENT_NAME_EN > 0u
                    11944   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00004056  41F9 0000 11945          lea       @ucos_ii_1.L,A0
0000405A  68A4      
0000405C  2242      11946          move.l    D2,A1
0000405E  2348 0012 11947          move.l    A0,18(A1)
                    11948   ; #endif
                    11949   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
00004062  2F02      11950          move.l    D2,-(A7)
00004064  4EB8 14FE 11951          jsr       _OS_EventWaitListInit
00004068  584F      11952          addq.w    #4,A7
                    11953   OSSemCreate_6:
                    11954   ; }
                    11955   ; return (pevent);
0000406A  2002      11956          move.l    D2,D0
                    11957   OSSemCreate_3:
0000406C  4CDF 0404 11958          movem.l   (A7)+,D2/A2
00004070  4E5E      11959          unlk      A6
00004072  4E75      11960          rts
                    11961   ; }
                    11962   ; /*$PAGE*/
                    11963   ; /*
                    11964   ; *********************************************************************************************************
                    11965   ; *                                         DELETE A SEMAPHORE
                    11966   ; *
                    11967   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    11968   ; *
                    11969   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11970   ; *                            semaphore.
                    11971   ; *
                    11972   ; *              opt           determines delete options as follows:
                    11973   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    11974   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    11975   ; *                                                    In this case, all the tasks pending will be readied.
                    11976   ; *
                    11977   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    11978   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    11979   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    11980   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    11981   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    11982   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    11983   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    11984   ; *
                    11985   ; * Returns    : pevent        upon error
                    11986   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    11987   ; *
                    11988   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    11989   ; *                 the semaphore MUST check the return code of OSSemPend().
                    11990   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    11991   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    11992   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    11993   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    11994   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    11995   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    11996   ; *                 will no longer be guarded by the semaphore.
                    11997   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    11998   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    11999   ; *********************************************************************************************************
                    12000   ; */
                    12001   ; #if OS_SEM_DEL_EN > 0u
                    12002   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    12003   ; INT8U      opt,
                    12004   ; INT8U     *perr)
                    12005   ; {
                    12006   _OSSemDel:
00004074  4E56 0000 12007          link      A6,#0
00004078  48E7 3C20 12008          movem.l   D2/D3/D4/D5/A2,-(A7)
0000407C  242E 0008 12009          move.l    8(A6),D2
00004080  262E 0010 12010          move.l    16(A6),D3
00004084  45F9 0800 12011          lea       _OSEventFreeList.L,A2
00004088  0CDA      
                    12012   ; BOOLEAN    tasks_waiting;
                    12013   ; OS_EVENT  *pevent_return;
                    12014   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12015   ; OS_CPU_SR  cpu_sr = 0u;
                    12016   ; #endif
                    12017   ; #ifdef OS_SAFETY_CRITICAL
                    12018   ; if (perr == (INT8U *)0) {
                    12019   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12020   ; return ((OS_EVENT *)0);
                    12021   ; }
                    12022   ; #endif
                    12023   ; #if OS_ARG_CHK_EN > 0u
                    12024   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12025   ; *perr = OS_ERR_PEVENT_NULL;
                    12026   ; return (pevent);
                    12027   ; }
                    12028   ; #endif
                    12029   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
0000408A  2042      12030          move.l    D2,A0
0000408C  1010      12031          move.b    (A0),D0
0000408E  0C00 0003 12032          cmp.b     #3,D0
00004092  670C      12033          beq.s     OSSemDel_1
                    12034   ; *perr = OS_ERR_EVENT_TYPE;
00004094  2043      12035          move.l    D3,A0
00004096  10BC 0001 12036          move.b    #1,(A0)
                    12037   ; return (pevent);
0000409A  2002      12038          move.l    D2,D0
0000409C  6000 00EA 12039          bra       OSSemDel_3
                    12040   OSSemDel_1:
                    12041   ; }
                    12042   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000040A0  1039 0800 12043          move.b    _OSIntNesting.L,D0
000040A4  0F06      
000040A6  0C00 0000 12044          cmp.b     #0,D0
000040AA  630C      12045          bls.s     OSSemDel_4
                    12046   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000040AC  2043      12047          move.l    D3,A0
000040AE  10BC 000F 12048          move.b    #15,(A0)
                    12049   ; return (pevent);
000040B2  2002      12050          move.l    D2,D0
000040B4  6000 00D2 12051          bra       OSSemDel_3
                    12052   OSSemDel_4:
                    12053   ; }
                    12054   ; OS_ENTER_CRITICAL();
000040B8  40E7      12055          dc.w      16615
000040BA  007C      12056          dc.w      124
000040BC  0700      12057          dc.w      1792
                    12058   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
000040BE  2042      12059          move.l    D2,A0
000040C0  1028 0008 12060          move.b    8(A0),D0
000040C4  6704      12061          beq.s     OSSemDel_6
                    12062   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000040C6  7A01      12063          moveq     #1,D5
000040C8  6002      12064          bra.s     OSSemDel_7
                    12065   OSSemDel_6:
                    12066   ; } else {
                    12067   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000040CA  4205      12068          clr.b     D5
                    12069   OSSemDel_7:
                    12070   ; }
                    12071   ; switch (opt) {
000040CC  102E 000F 12072          move.b    15(A6),D0
000040D0  C0BC 0000 12073          and.l     #255,D0
000040D4  00FF      
000040D6  0C80 0000 12074          cmp.l     #1,D0
000040DA  0001      
000040DC  6700 0048 12075          beq       OSSemDel_11
000040E0  6200 009A 12076          bhi       OSSemDel_8
000040E4  4A80      12077          tst.l     D0
000040E6  6704      12078          beq.s     OSSemDel_10
000040E8  6000 0092 12079          bra       OSSemDel_8
                    12080   OSSemDel_10:
                    12081   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    12082   ; if (tasks_waiting == OS_FALSE) {
000040EC  4A05      12083          tst.b     D5
000040EE  6628      12084          bne.s     OSSemDel_13
                    12085   ; #if OS_EVENT_NAME_EN > 0u
                    12086   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000040F0  41F9 0000 12087          lea       @ucos_ii_1.L,A0
000040F4  68A4      
000040F6  2242      12088          move.l    D2,A1
000040F8  2348 0012 12089          move.l    A0,18(A1)
                    12090   ; #endif
                    12091   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000040FC  2042      12092          move.l    D2,A0
000040FE  4210      12093          clr.b     (A0)
                    12094   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00004100  2042      12095          move.l    D2,A0
00004102  2152 0002 12096          move.l    (A2),2(A0)
                    12097   ; pevent->OSEventCnt     = 0u;
00004106  2042      12098          move.l    D2,A0
00004108  4268 0006 12099          clr.w     6(A0)
                    12100   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
0000410C  2482      12101          move.l    D2,(A2)
                    12102   ; OS_EXIT_CRITICAL();
0000410E  46DF      12103          dc.w      18143
                    12104   ; *perr                  = OS_ERR_NONE;
00004110  2043      12105          move.l    D3,A0
00004112  4210      12106          clr.b     (A0)
                    12107   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
00004114  4284      12108          clr.l     D4
00004116  600A      12109          bra.s     OSSemDel_14
                    12110   OSSemDel_13:
                    12111   ; } else {
                    12112   ; OS_EXIT_CRITICAL();
00004118  46DF      12113          dc.w      18143
                    12114   ; *perr                  = OS_ERR_TASK_WAITING;
0000411A  2043      12115          move.l    D3,A0
0000411C  10BC 0049 12116          move.b    #73,(A0)
                    12117   ; pevent_return          = pevent;
00004120  2802      12118          move.l    D2,D4
                    12119   OSSemDel_14:
                    12120   ; }
                    12121   ; break;
00004122  6000 0062 12122          bra       OSSemDel_9
                    12123   OSSemDel_11:
                    12124   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    12125   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    12126   OSSemDel_15:
00004126  2042      12127          move.l    D2,A0
00004128  1028 0008 12128          move.b    8(A0),D0
0000412C  671C      12129          beq.s     OSSemDel_17
                    12130   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0000412E  4878 0002 12131          pea       2
00004132  4878 0001 12132          pea       1
00004136  42A7      12133          clr.l     -(A7)
00004138  2F02      12134          move.l    D2,-(A7)
0000413A  4EB8 1236 12135          jsr       _OS_EventTaskRdy
0000413E  DEFC 0010 12136          add.w     #16,A7
00004142  C0BC 0000 12137          and.l     #255,D0
00004146  00FF      
00004148  60DC      12138          bra       OSSemDel_15
                    12139   OSSemDel_17:
                    12140   ; }
                    12141   ; #if OS_EVENT_NAME_EN > 0u
                    12142   ; pevent->OSEventName    = (INT8U *)(void *)"?";
0000414A  41F9 0000 12143          lea       @ucos_ii_1.L,A0
0000414E  68A4      
00004150  2242      12144          move.l    D2,A1
00004152  2348 0012 12145          move.l    A0,18(A1)
                    12146   ; #endif
                    12147   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00004156  2042      12148          move.l    D2,A0
00004158  4210      12149          clr.b     (A0)
                    12150   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
0000415A  2042      12151          move.l    D2,A0
0000415C  2152 0002 12152          move.l    (A2),2(A0)
                    12153   ; pevent->OSEventCnt     = 0u;
00004160  2042      12154          move.l    D2,A0
00004162  4268 0006 12155          clr.w     6(A0)
                    12156   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00004166  2482      12157          move.l    D2,(A2)
                    12158   ; OS_EXIT_CRITICAL();
00004168  46DF      12159          dc.w      18143
                    12160   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000416A  0C05 0001 12161          cmp.b     #1,D5
0000416E  6604      12162          bne.s     OSSemDel_18
                    12163   ; OS_Sched();                               /* Find highest priority task ready to run  */
00004170  4EB8 1816 12164          jsr       _OS_Sched
                    12165   OSSemDel_18:
                    12166   ; }
                    12167   ; *perr                  = OS_ERR_NONE;
00004174  2043      12168          move.l    D3,A0
00004176  4210      12169          clr.b     (A0)
                    12170   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00004178  4284      12171          clr.l     D4
                    12172   ; break;
0000417A  600A      12173          bra.s     OSSemDel_9
                    12174   OSSemDel_8:
                    12175   ; default:
                    12176   ; OS_EXIT_CRITICAL();
0000417C  46DF      12177          dc.w      18143
                    12178   ; *perr                  = OS_ERR_INVALID_OPT;
0000417E  2043      12179          move.l    D3,A0
00004180  10BC 0007 12180          move.b    #7,(A0)
                    12181   ; pevent_return          = pevent;
00004184  2802      12182          move.l    D2,D4
                    12183   ; break;
                    12184   OSSemDel_9:
                    12185   ; }
                    12186   ; return (pevent_return);
00004186  2004      12187          move.l    D4,D0
                    12188   OSSemDel_3:
00004188  4CDF 043C 12189          movem.l   (A7)+,D2/D3/D4/D5/A2
0000418C  4E5E      12190          unlk      A6
0000418E  4E75      12191          rts
                    12192   ; }
                    12193   ; #endif
                    12194   ; /*$PAGE*/
                    12195   ; /*
                    12196   ; *********************************************************************************************************
                    12197   ; *                                          PEND ON SEMAPHORE
                    12198   ; *
                    12199   ; * Description: This function waits for a semaphore.
                    12200   ; *
                    12201   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12202   ; *                            semaphore.
                    12203   ; *
                    12204   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    12205   ; *                            wait for the resource up to the amount of time specified by this argument.
                    12206   ; *                            If you specify 0, however, your task will wait forever at the specified
                    12207   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    12208   ; *
                    12209   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12210   ; *                            messages are:
                    12211   ; *
                    12212   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    12213   ; *                                                or, the event you are waiting for occurred.
                    12214   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    12215   ; *                                                'timeout'.
                    12216   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    12217   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12218   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    12219   ; *                                                would lead to a suspension.
                    12220   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12221   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    12222   ; *
                    12223   ; * Returns    : none
                    12224   ; *********************************************************************************************************
                    12225   ; */
                    12226   ; /*$PAGE*/
                    12227   ; void  OSSemPend (OS_EVENT  *pevent,
                    12228   ; INT32U     timeout,
                    12229   ; INT8U     *perr)
                    12230   ; {
                    12231   _OSSemPend:
00004190  4E56 0000 12232          link      A6,#0
00004194  48E7 3020 12233          movem.l   D2/D3/A2,-(A7)
00004198  45F9 0800 12234          lea       _OSTCBCur.L,A2
0000419C  1020      
0000419E  242E 0010 12235          move.l    16(A6),D2
000041A2  262E 0008 12236          move.l    8(A6),D3
                    12237   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12238   ; OS_CPU_SR  cpu_sr = 0u;
                    12239   ; #endif
                    12240   ; #ifdef OS_SAFETY_CRITICAL
                    12241   ; if (perr == (INT8U *)0) {
                    12242   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12243   ; return;
                    12244   ; }
                    12245   ; #endif
                    12246   ; #if OS_ARG_CHK_EN > 0u
                    12247   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12248   ; *perr = OS_ERR_PEVENT_NULL;
                    12249   ; return;
                    12250   ; }
                    12251   ; #endif
                    12252   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000041A6  2043      12253          move.l    D3,A0
000041A8  1010      12254          move.b    (A0),D0
000041AA  0C00 0003 12255          cmp.b     #3,D0
000041AE  670A      12256          beq.s     OSSemPend_1
                    12257   ; *perr = OS_ERR_EVENT_TYPE;
000041B0  2042      12258          move.l    D2,A0
000041B2  10BC 0001 12259          move.b    #1,(A0)
                    12260   ; return;
000041B6  6000 00DA 12261          bra       OSSemPend_3
                    12262   OSSemPend_1:
                    12263   ; }
                    12264   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000041BA  1039 0800 12265          move.b    _OSIntNesting.L,D0
000041BE  0F06      
000041C0  0C00 0000 12266          cmp.b     #0,D0
000041C4  630A      12267          bls.s     OSSemPend_4
                    12268   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
000041C6  2042      12269          move.l    D2,A0
000041C8  10BC 0002 12270          move.b    #2,(A0)
                    12271   ; return;
000041CC  6000 00C4 12272          bra       OSSemPend_3
                    12273   OSSemPend_4:
                    12274   ; }
                    12275   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000041D0  1039 0800 12276          move.b    _OSLockNesting.L,D0
000041D4  0F08      
000041D6  0C00 0000 12277          cmp.b     #0,D0
000041DA  630A      12278          bls.s     OSSemPend_6
                    12279   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
000041DC  2042      12280          move.l    D2,A0
000041DE  10BC 000D 12281          move.b    #13,(A0)
                    12282   ; return;
000041E2  6000 00AE 12283          bra       OSSemPend_3
                    12284   OSSemPend_6:
                    12285   ; }
                    12286   ; OS_ENTER_CRITICAL();
000041E6  40E7      12287          dc.w      16615
000041E8  007C      12288          dc.w      124
000041EA  0700      12289          dc.w      1792
                    12290   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
000041EC  2043      12291          move.l    D3,A0
000041EE  3028 0006 12292          move.w    6(A0),D0
000041F2  0C40 0000 12293          cmp.w     #0,D0
000041F6  6312      12294          bls.s     OSSemPend_8
                    12295   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
000041F8  2003      12296          move.l    D3,D0
000041FA  5C80      12297          addq.l    #6,D0
000041FC  2040      12298          move.l    D0,A0
000041FE  5350      12299          subq.w    #1,(A0)
                    12300   ; OS_EXIT_CRITICAL();
00004200  46DF      12301          dc.w      18143
                    12302   ; *perr = OS_ERR_NONE;
00004202  2042      12303          move.l    D2,A0
00004204  4210      12304          clr.b     (A0)
                    12305   ; return;
00004206  6000 008A 12306          bra       OSSemPend_3
                    12307   OSSemPend_8:
                    12308   ; }
                    12309   ; /* Otherwise, must wait until event occurs       */
                    12310   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
0000420A  2052      12311          move.l    (A2),A0
0000420C  0028 0001 12312          or.b      #1,50(A0)
00004210  0032      
                    12313   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00004212  2052      12314          move.l    (A2),A0
00004214  4228 0033 12315          clr.b     51(A0)
                    12316   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00004218  2052      12317          move.l    (A2),A0
0000421A  216E 000C 12318          move.l    12(A6),46(A0)
0000421E  002E      
                    12319   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00004220  2F03      12320          move.l    D3,-(A7)
00004222  4EB8 131A 12321          jsr       _OS_EventTaskWait
00004226  584F      12322          addq.w    #4,A7
                    12323   ; OS_EXIT_CRITICAL();
00004228  46DF      12324          dc.w      18143
                    12325   ; OS_Sched();                                       /* Find next highest priority task ready         */
0000422A  4EB8 1816 12326          jsr       _OS_Sched
                    12327   ; OS_ENTER_CRITICAL();
0000422E  40E7      12328          dc.w      16615
00004230  007C      12329          dc.w      124
00004232  0700      12330          dc.w      1792
                    12331   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00004234  2052      12332          move.l    (A2),A0
00004236  1028 0033 12333          move.b    51(A0),D0
0000423A  C0BC 0000 12334          and.l     #255,D0
0000423E  00FF      
00004240  0C80 0000 12335          cmp.l     #1,D0
00004244  0001      
00004246  6720      12336          beq.s     OSSemPend_14
00004248  6206      12337          bhi.s     OSSemPend_16
0000424A  4A80      12338          tst.l     D0
0000424C  670C      12339          beq.s     OSSemPend_12
0000424E  6018      12340          bra.s     OSSemPend_14
                    12341   OSSemPend_16:
00004250  0C80 0000 12342          cmp.l     #2,D0
00004254  0002      
00004256  6708      12343          beq.s     OSSemPend_13
00004258  600E      12344          bra.s     OSSemPend_14
                    12345   OSSemPend_12:
                    12346   ; case OS_STAT_PEND_OK:
                    12347   ; *perr = OS_ERR_NONE;
0000425A  2042      12348          move.l    D2,A0
0000425C  4210      12349          clr.b     (A0)
                    12350   ; break;
0000425E  6018      12351          bra.s     OSSemPend_11
                    12352   OSSemPend_13:
                    12353   ; case OS_STAT_PEND_ABORT:
                    12354   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00004260  2042      12355          move.l    D2,A0
00004262  10BC 000E 12356          move.b    #14,(A0)
                    12357   ; break;
00004266  6010      12358          bra.s     OSSemPend_11
                    12359   OSSemPend_14:
                    12360   ; case OS_STAT_PEND_TO:
                    12361   ; default:
                    12362   ; OS_EventTaskRemove(OSTCBCur, pevent);
00004268  2F03      12363          move.l    D3,-(A7)
0000426A  2F12      12364          move.l    (A2),-(A7)
0000426C  4EB8 143C 12365          jsr       _OS_EventTaskRemove
00004270  504F      12366          addq.w    #8,A7
                    12367   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00004272  2042      12368          move.l    D2,A0
00004274  10BC 000A 12369          move.b    #10,(A0)
                    12370   ; break;
                    12371   OSSemPend_11:
                    12372   ; }
                    12373   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00004278  2052      12374          move.l    (A2),A0
0000427A  4228 0032 12375          clr.b     50(A0)
                    12376   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000427E  2052      12377          move.l    (A2),A0
00004280  4228 0033 12378          clr.b     51(A0)
                    12379   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00004284  2052      12380          move.l    (A2),A0
00004286  42A8 001C 12381          clr.l     28(A0)
                    12382   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12383   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000428A  2052      12384          move.l    (A2),A0
0000428C  42A8 0020 12385          clr.l     32(A0)
                    12386   ; #endif
                    12387   ; OS_EXIT_CRITICAL();
00004290  46DF      12388          dc.w      18143
                    12389   OSSemPend_3:
00004292  4CDF 040C 12390          movem.l   (A7)+,D2/D3/A2
00004296  4E5E      12391          unlk      A6
00004298  4E75      12392          rts
                    12393   ; }
                    12394   ; /*$PAGE*/
                    12395   ; /*
                    12396   ; *********************************************************************************************************
                    12397   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12398   ; *
                    12399   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12400   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12401   ; *              the semaphore via OSSemPost().
                    12402   ; *
                    12403   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12404   ; *                            semaphore.
                    12405   ; *
                    12406   ; *              opt           determines the type of ABORT performed:
                    12407   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12408   ; *                                                     semaphore
                    12409   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12410   ; *                                                     semaphore
                    12411   ; *
                    12412   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12413   ; *                            messages are:
                    12414   ; *
                    12415   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12416   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12417   ; *                                                and informed of the aborted wait; check return value
                    12418   ; *                                                for the number of tasks whose wait on the semaphore
                    12419   ; *                                                was aborted.
                    12420   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12421   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12422   ; *
                    12423   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12424   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12425   ; *********************************************************************************************************
                    12426   ; */
                    12427   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12428   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12429   ; INT8U      opt,
                    12430   ; INT8U     *perr)
                    12431   ; {
                    12432   _OSSemPendAbort:
0000429A  4E56 0000 12433          link      A6,#0
0000429E  48E7 3800 12434          movem.l   D2/D3/D4,-(A7)
000042A2  242E 0008 12435          move.l    8(A6),D2
000042A6  282E 0010 12436          move.l    16(A6),D4
                    12437   ; INT8U      nbr_tasks;
                    12438   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12439   ; OS_CPU_SR  cpu_sr = 0u;
                    12440   ; #endif
                    12441   ; #ifdef OS_SAFETY_CRITICAL
                    12442   ; if (perr == (INT8U *)0) {
                    12443   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12444   ; return (0u);
                    12445   ; }
                    12446   ; #endif
                    12447   ; #if OS_ARG_CHK_EN > 0u
                    12448   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12449   ; *perr = OS_ERR_PEVENT_NULL;
                    12450   ; return (0u);
                    12451   ; }
                    12452   ; #endif
                    12453   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000042AA  2042      12454          move.l    D2,A0
000042AC  1010      12455          move.b    (A0),D0
000042AE  0C00 0003 12456          cmp.b     #3,D0
000042B2  670C      12457          beq.s     OSSemPendAbort_1
                    12458   ; *perr = OS_ERR_EVENT_TYPE;
000042B4  2044      12459          move.l    D4,A0
000042B6  10BC 0001 12460          move.b    #1,(A0)
                    12461   ; return (0u);
000042BA  4200      12462          clr.b     D0
000042BC  6000 008C 12463          bra       OSSemPendAbort_3
                    12464   OSSemPendAbort_1:
                    12465   ; }
                    12466   ; OS_ENTER_CRITICAL();
000042C0  40E7      12467          dc.w      16615
000042C2  007C      12468          dc.w      124
000042C4  0700      12469          dc.w      1792
                    12470   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
000042C6  2042      12471          move.l    D2,A0
000042C8  1028 0008 12472          move.b    8(A0),D0
000042CC  6700 0074 12473          beq       OSSemPendAbort_4
                    12474   ; nbr_tasks = 0u;
000042D0  4203      12475          clr.b     D3
                    12476   ; switch (opt) {
000042D2  102E 000F 12477          move.b    15(A6),D0
000042D6  C0BC 0000 12478          and.l     #255,D0
000042DA  00FF      
000042DC  0C80 0000 12479          cmp.l     #1,D0
000042E0  0001      
000042E2  670A      12480          beq.s     OSSemPendAbort_8
000042E4  6200 0030 12481          bhi       OSSemPendAbort_9
000042E8  4A80      12482          tst.l     D0
000042EA  672A      12483          beq.s     OSSemPendAbort_9
000042EC  6028      12484          bra.s     OSSemPendAbort_9
                    12485   OSSemPendAbort_8:
                    12486   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12487   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12488   OSSemPendAbort_11:
000042EE  2042      12489          move.l    D2,A0
000042F0  1028 0008 12490          move.b    8(A0),D0
000042F4  671E      12491          beq.s     OSSemPendAbort_13
                    12492   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
000042F6  4878 0002 12493          pea       2
000042FA  4878 0001 12494          pea       1
000042FE  42A7      12495          clr.l     -(A7)
00004300  2F02      12496          move.l    D2,-(A7)
00004302  4EB8 1236 12497          jsr       _OS_EventTaskRdy
00004306  DEFC 0010 12498          add.w     #16,A7
0000430A  C0BC 0000 12499          and.l     #255,D0
0000430E  00FF      
                    12500   ; nbr_tasks++;
00004310  5203      12501          addq.b    #1,D3
00004312  60DA      12502          bra       OSSemPendAbort_11
                    12503   OSSemPendAbort_13:
                    12504   ; }
                    12505   ; break;
00004314  601C      12506          bra.s     OSSemPendAbort_7
                    12507   OSSemPendAbort_9:
                    12508   ; case OS_PEND_OPT_NONE:
                    12509   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12510   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00004316  4878 0002 12511          pea       2
0000431A  4878 0001 12512          pea       1
0000431E  42A7      12513          clr.l     -(A7)
00004320  2F02      12514          move.l    D2,-(A7)
00004322  4EB8 1236 12515          jsr       _OS_EventTaskRdy
00004326  DEFC 0010 12516          add.w     #16,A7
0000432A  C0BC 0000 12517          and.l     #255,D0
0000432E  00FF      
                    12518   ; nbr_tasks++;
00004330  5203      12519          addq.b    #1,D3
                    12520   ; break;
                    12521   OSSemPendAbort_7:
                    12522   ; }
                    12523   ; OS_EXIT_CRITICAL();
00004332  46DF      12524          dc.w      18143
                    12525   ; OS_Sched();                                   /* Find HPT ready to run                         */
00004334  4EB8 1816 12526          jsr       _OS_Sched
                    12527   ; *perr = OS_ERR_PEND_ABORT;
00004338  2044      12528          move.l    D4,A0
0000433A  10BC 000E 12529          move.b    #14,(A0)
                    12530   ; return (nbr_tasks);
0000433E  1003      12531          move.b    D3,D0
00004340  6008      12532          bra.s     OSSemPendAbort_3
                    12533   OSSemPendAbort_4:
                    12534   ; }
                    12535   ; OS_EXIT_CRITICAL();
00004342  46DF      12536          dc.w      18143
                    12537   ; *perr = OS_ERR_NONE;
00004344  2044      12538          move.l    D4,A0
00004346  4210      12539          clr.b     (A0)
                    12540   ; return (0u);                                      /* No tasks waiting on semaphore                 */
00004348  4200      12541          clr.b     D0
                    12542   OSSemPendAbort_3:
0000434A  4CDF 001C 12543          movem.l   (A7)+,D2/D3/D4
0000434E  4E5E      12544          unlk      A6
00004350  4E75      12545          rts
                    12546   ; }
                    12547   ; #endif
                    12548   ; /*$PAGE*/
                    12549   ; /*
                    12550   ; *********************************************************************************************************
                    12551   ; *                                         POST TO A SEMAPHORE
                    12552   ; *
                    12553   ; * Description: This function signals a semaphore
                    12554   ; *
                    12555   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12556   ; *                            semaphore.
                    12557   ; *
                    12558   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12559   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12560   ; *                                  signaled the semaphore more often than you waited on it with either
                    12561   ; *                                  OSSemAccept() or OSSemPend().
                    12562   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12563   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12564   ; *********************************************************************************************************
                    12565   ; */
                    12566   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12567   ; {
                    12568   _OSSemPost:
00004352  4E56 0000 12569          link      A6,#0
00004356  2F02      12570          move.l    D2,-(A7)
00004358  242E 0008 12571          move.l    8(A6),D2
                    12572   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12573   ; OS_CPU_SR  cpu_sr = 0u;
                    12574   ; #endif
                    12575   ; #if OS_ARG_CHK_EN > 0u
                    12576   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12577   ; return (OS_ERR_PEVENT_NULL);
                    12578   ; }
                    12579   ; #endif
                    12580   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000435C  2042      12581          move.l    D2,A0
0000435E  1010      12582          move.b    (A0),D0
00004360  0C00 0003 12583          cmp.b     #3,D0
00004364  6706      12584          beq.s     OSSemPost_1
                    12585   ; return (OS_ERR_EVENT_TYPE);
00004366  7001      12586          moveq     #1,D0
00004368  6000 0050 12587          bra       OSSemPost_3
                    12588   OSSemPost_1:
                    12589   ; }
                    12590   ; OS_ENTER_CRITICAL();
0000436C  40E7      12591          dc.w      16615
0000436E  007C      12592          dc.w      124
00004370  0700      12593          dc.w      1792
                    12594   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
00004372  2042      12595          move.l    D2,A0
00004374  1028 0008 12596          move.b    8(A0),D0
00004378  6722      12597          beq.s     OSSemPost_4
                    12598   ; /* Ready HPT waiting on event                    */
                    12599   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
0000437A  42A7      12600          clr.l     -(A7)
0000437C  4878 0001 12601          pea       1
00004380  42A7      12602          clr.l     -(A7)
00004382  2F02      12603          move.l    D2,-(A7)
00004384  4EB8 1236 12604          jsr       _OS_EventTaskRdy
00004388  DEFC 0010 12605          add.w     #16,A7
0000438C  C0BC 0000 12606          and.l     #255,D0
00004390  00FF      
                    12607   ; OS_EXIT_CRITICAL();
00004392  46DF      12608          dc.w      18143
                    12609   ; OS_Sched();                                   /* Find HPT ready to run                         */
00004394  4EB8 1816 12610          jsr       _OS_Sched
                    12611   ; return (OS_ERR_NONE);
00004398  4200      12612          clr.b     D0
0000439A  601E      12613          bra.s     OSSemPost_3
                    12614   OSSemPost_4:
                    12615   ; }
                    12616   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
0000439C  2042      12617          move.l    D2,A0
0000439E  3028 0006 12618          move.w    6(A0),D0
000043A2  0C40 FFFF 12619          cmp.w     #65535,D0
000043A6  640E      12620          bhs.s     OSSemPost_6
                    12621   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
000043A8  2002      12622          move.l    D2,D0
000043AA  5C80      12623          addq.l    #6,D0
000043AC  2040      12624          move.l    D0,A0
000043AE  5250      12625          addq.w    #1,(A0)
                    12626   ; OS_EXIT_CRITICAL();
000043B0  46DF      12627          dc.w      18143
                    12628   ; return (OS_ERR_NONE);
000043B2  4200      12629          clr.b     D0
000043B4  6004      12630          bra.s     OSSemPost_3
                    12631   OSSemPost_6:
                    12632   ; }
                    12633   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
000043B6  46DF      12634          dc.w      18143
                    12635   ; return (OS_ERR_SEM_OVF);
000043B8  7033      12636          moveq     #51,D0
                    12637   OSSemPost_3:
000043BA  241F      12638          move.l    (A7)+,D2
000043BC  4E5E      12639          unlk      A6
000043BE  4E75      12640          rts
                    12641   ; }
                    12642   ; /*$PAGE*/
                    12643   ; /*
                    12644   ; *********************************************************************************************************
                    12645   ; *                                          QUERY A SEMAPHORE
                    12646   ; *
                    12647   ; * Description: This function obtains information about a semaphore
                    12648   ; *
                    12649   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12650   ; *                            semaphore
                    12651   ; *
                    12652   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12653   ; *                            semaphore.
                    12654   ; *
                    12655   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12656   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12657   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12658   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12659   ; *********************************************************************************************************
                    12660   ; */
                    12661   ; #if OS_SEM_QUERY_EN > 0u
                    12662   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12663   ; OS_SEM_DATA  *p_sem_data)
                    12664   ; {
                    12665   _OSSemQuery:
000043C0  4E56 FFF8 12666          link      A6,#-8
000043C4  48E7 3800 12667          movem.l   D2/D3/D4,-(A7)
000043C8  242E 0008 12668          move.l    8(A6),D2
000043CC  282E 000C 12669          move.l    12(A6),D4
                    12670   ; INT8U       i;
                    12671   ; OS_PRIO    *psrc;
                    12672   ; OS_PRIO    *pdest;
                    12673   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12674   ; OS_CPU_SR   cpu_sr = 0u;
                    12675   ; #endif
                    12676   ; #if OS_ARG_CHK_EN > 0u
                    12677   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12678   ; return (OS_ERR_PEVENT_NULL);
                    12679   ; }
                    12680   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12681   ; return (OS_ERR_PDATA_NULL);
                    12682   ; }
                    12683   ; #endif
                    12684   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
000043D0  2042      12685          move.l    D2,A0
000043D2  1010      12686          move.b    (A0),D0
000043D4  0C00 0003 12687          cmp.b     #3,D0
000043D8  6706      12688          beq.s     OSSemQuery_1
                    12689   ; return (OS_ERR_EVENT_TYPE);
000043DA  7001      12690          moveq     #1,D0
000043DC  6000 004C 12691          bra       OSSemQuery_3
                    12692   OSSemQuery_1:
                    12693   ; }
                    12694   ; OS_ENTER_CRITICAL();
000043E0  40E7      12695          dc.w      16615
000043E2  007C      12696          dc.w      124
000043E4  0700      12697          dc.w      1792
                    12698   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
000043E6  2042      12699          move.l    D2,A0
000043E8  2244      12700          move.l    D4,A1
000043EA  1368 0008 12701          move.b    8(A0),10(A1)
000043EE  000A      
                    12702   ; psrc                   = &pevent->OSEventTbl[0];
000043F0  700A      12703          moveq     #10,D0
000043F2  D082      12704          add.l     D2,D0
000043F4  2D40 FFF8 12705          move.l    D0,-8(A6)
                    12706   ; pdest                  = &p_sem_data->OSEventTbl[0];
000043F8  7002      12707          moveq     #2,D0
000043FA  D084      12708          add.l     D4,D0
000043FC  2D40 FFFC 12709          move.l    D0,-4(A6)
                    12710   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00004400  4203      12711          clr.b     D3
                    12712   OSSemQuery_4:
00004402  0C03 0008 12713          cmp.b     #8,D3
00004406  6416      12714          bhs.s     OSSemQuery_6
                    12715   ; *pdest++ = *psrc++;
00004408  206E FFF8 12716          move.l    -8(A6),A0
0000440C  52AE FFF8 12717          addq.l    #1,-8(A6)
00004410  226E FFFC 12718          move.l    -4(A6),A1
00004414  52AE FFFC 12719          addq.l    #1,-4(A6)
00004418  1290      12720          move.b    (A0),(A1)
0000441A  5203      12721          addq.b    #1,D3
0000441C  60E4      12722          bra       OSSemQuery_4
                    12723   OSSemQuery_6:
                    12724   ; }
                    12725   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
0000441E  2042      12726          move.l    D2,A0
00004420  2244      12727          move.l    D4,A1
00004422  32A8 0006 12728          move.w    6(A0),(A1)
                    12729   ; OS_EXIT_CRITICAL();
00004426  46DF      12730          dc.w      18143
                    12731   ; return (OS_ERR_NONE);
00004428  4200      12732          clr.b     D0
                    12733   OSSemQuery_3:
0000442A  4CDF 001C 12734          movem.l   (A7)+,D2/D3/D4
0000442E  4E5E      12735          unlk      A6
00004430  4E75      12736          rts
                    12737   ; }
                    12738   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12739   ; /*$PAGE*/
                    12740   ; /*
                    12741   ; *********************************************************************************************************
                    12742   ; *                                            SET SEMAPHORE
                    12743   ; *
                    12744   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12745   ; *              this value would be 0.
                    12746   ; *
                    12747   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12748   ; *              and, you want to reset the count value.
                    12749   ; *
                    12750   ; * Arguments  : pevent     is a pointer to the event control block
                    12751   ; *
                    12752   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12753   ; *                         semaphore count.
                    12754   ; *
                    12755   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12756   ; *
                    12757   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12758   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12759   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12760   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12761   ; *********************************************************************************************************
                    12762   ; */
                    12763   ; #if OS_SEM_SET_EN > 0u
                    12764   ; void  OSSemSet (OS_EVENT  *pevent,
                    12765   ; INT16U     cnt,
                    12766   ; INT8U     *perr)
                    12767   ; {
                    12768   _OSSemSet:
00004432  4E56 0000 12769          link      A6,#0
00004436  48E7 3000 12770          movem.l   D2/D3,-(A7)
0000443A  242E 0008 12771          move.l    8(A6),D2
0000443E  262E 0010 12772          move.l    16(A6),D3
                    12773   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12774   ; OS_CPU_SR  cpu_sr = 0u;
                    12775   ; #endif
                    12776   ; #ifdef OS_SAFETY_CRITICAL
                    12777   ; if (perr == (INT8U *)0) {
                    12778   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12779   ; return;
                    12780   ; }
                    12781   ; #endif
                    12782   ; #if OS_ARG_CHK_EN > 0u
                    12783   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12784   ; *perr = OS_ERR_PEVENT_NULL;
                    12785   ; return;
                    12786   ; }
                    12787   ; #endif
                    12788   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004442  2042      12789          move.l    D2,A0
00004444  1010      12790          move.b    (A0),D0
00004446  0C00 0003 12791          cmp.b     #3,D0
0000444A  670A      12792          beq.s     OSSemSet_1
                    12793   ; *perr = OS_ERR_EVENT_TYPE;
0000444C  2043      12794          move.l    D3,A0
0000444E  10BC 0001 12795          move.b    #1,(A0)
                    12796   ; return;
00004452  6000 003C 12797          bra       OSSemSet_3
                    12798   OSSemSet_1:
                    12799   ; }
                    12800   ; OS_ENTER_CRITICAL();
00004456  40E7      12801          dc.w      16615
00004458  007C      12802          dc.w      124
0000445A  0700      12803          dc.w      1792
                    12804   ; *perr = OS_ERR_NONE;
0000445C  2043      12805          move.l    D3,A0
0000445E  4210      12806          clr.b     (A0)
                    12807   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
00004460  2042      12808          move.l    D2,A0
00004462  3028 0006 12809          move.w    6(A0),D0
00004466  0C40 0000 12810          cmp.w     #0,D0
0000446A  630A      12811          bls.s     OSSemSet_4
                    12812   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
0000446C  2042      12813          move.l    D2,A0
0000446E  316E 000E 12814          move.w    14(A6),6(A0)
00004472  0006      
00004474  6018      12815          bra.s     OSSemSet_7
                    12816   OSSemSet_4:
                    12817   ; } else {                                          /* No                                            */
                    12818   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
00004476  2042      12819          move.l    D2,A0
00004478  1028 0008 12820          move.b    8(A0),D0
0000447C  660A      12821          bne.s     OSSemSet_6
                    12822   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
0000447E  2042      12823          move.l    D2,A0
00004480  316E 000E 12824          move.w    14(A6),6(A0)
00004484  0006      
00004486  6006      12825          bra.s     OSSemSet_7
                    12826   OSSemSet_6:
                    12827   ; } else {
                    12828   ; *perr              = OS_ERR_TASK_WAITING;
00004488  2043      12829          move.l    D3,A0
0000448A  10BC 0049 12830          move.b    #73,(A0)
                    12831   OSSemSet_7:
                    12832   ; }
                    12833   ; }
                    12834   ; OS_EXIT_CRITICAL();
0000448E  46DF      12835          dc.w      18143
                    12836   OSSemSet_3:
00004490  4CDF 000C 12837          movem.l   (A7)+,D2/D3
00004494  4E5E      12838          unlk      A6
00004496  4E75      12839          rts
                    12840   ; /*
                    12841   ; *********************************************************************************************************
                    12842   ; *                                                uC/OS-II
                    12843   ; *                                          The Real-Time Kernel
                    12844   ; *                                            TASK MANAGEMENT
                    12845   ; *
                    12846   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12847   ; *                                           All Rights Reserved
                    12848   ; *
                    12849   ; * File    : OS_TASK.C
                    12850   ; * By      : Jean J. Labrosse
                    12851   ; * Version : V2.92.07
                    12852   ; *
                    12853   ; * LICENSING TERMS:
                    12854   ; * ---------------
                    12855   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12856   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12857   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12858   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12859   ; * licensing fee.
                    12860   ; *********************************************************************************************************
                    12861   ; */
                    12862   ; #define  MICRIUM_SOURCE
                    12863   ; #ifndef  OS_MASTER_FILE
                    12864   ; #include <ucos_ii.h>
                    12865   ; #endif
                    12866   ; /*$PAGE*/
                    12867   ; /*
                    12868   ; *********************************************************************************************************
                    12869   ; *                                      CHANGE PRIORITY OF A TASK
                    12870   ; *
                    12871   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12872   ; *              priority MUST be available.
                    12873   ; *
                    12874   ; * Arguments  : oldp     is the old priority
                    12875   ; *
                    12876   ; *              newp     is the new priority
                    12877   ; *
                    12878   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12879   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12880   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12881   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12882   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12883   ; *                                     not exist.
                    12884   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12885   ; *********************************************************************************************************
                    12886   ; */
                    12887   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12888   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12889   ; INT8U  newprio)
                    12890   ; {
                    12891   _OSTaskChangePrio:
00004498  4E56 FFFC 12892          link      A6,#-4
0000449C  48E7 3F38 12893          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
000044A0  47F9 0800 12894          lea       _OSRdyTbl.L,A3
000044A4  0F10      
000044A6  49F9 0800 12895          lea       _OSTCBPrioTbl.L,A4
000044AA  1030      
                    12896   ; #if (OS_EVENT_EN)
                    12897   ; OS_EVENT  *pevent;
                    12898   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12899   ; OS_EVENT **pevents;
                    12900   ; #endif
                    12901   ; #endif
                    12902   ; OS_TCB    *ptcb;
                    12903   ; INT8U      y_new;
                    12904   ; INT8U      x_new;
                    12905   ; INT8U      y_old;
                    12906   ; OS_PRIO    bity_new;
                    12907   ; OS_PRIO    bitx_new;
                    12908   ; OS_PRIO    bity_old;
                    12909   ; OS_PRIO    bitx_old;
                    12910   ; #if OS_CRITICAL_METHOD == 3u
                    12911   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12912   ; #endif
                    12913   ; /*$PAGE*/
                    12914   ; #if OS_ARG_CHK_EN > 0u
                    12915   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12916   ; if (oldprio != OS_PRIO_SELF) {
                    12917   ; return (OS_ERR_PRIO_INVALID);
                    12918   ; }
                    12919   ; }
                    12920   ; if (newprio >= OS_LOWEST_PRIO) {
                    12921   ; return (OS_ERR_PRIO_INVALID);
                    12922   ; }
                    12923   ; #endif
                    12924   ; OS_ENTER_CRITICAL();
000044AC  40E7      12925          dc.w      16615
000044AE  007C      12926          dc.w      124
000044B0  0700      12927          dc.w      1792
                    12928   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
000044B2  102E 000F 12929          move.b    15(A6),D0
000044B6  C0BC 0000 12930          and.l     #255,D0
000044BA  00FF      
000044BC  E588      12931          lsl.l     #2,D0
000044BE  2034 0800 12932          move.l    0(A4,D0.L),D0
000044C2  6708      12933          beq.s     OSTaskChangePrio_1
                    12934   ; OS_EXIT_CRITICAL();
000044C4  46DF      12935          dc.w      18143
                    12936   ; return (OS_ERR_PRIO_EXIST);
000044C6  7028      12937          moveq     #40,D0
000044C8  6000 01E0 12938          bra       OSTaskChangePrio_3
                    12939   OSTaskChangePrio_1:
                    12940   ; }
                    12941   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
000044CC  102E 000B 12942          move.b    11(A6),D0
000044D0  0C00 00FF 12943          cmp.b     #255,D0
000044D4  660C      12944          bne.s     OSTaskChangePrio_4
                    12945   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
000044D6  2079 0800 12946          move.l    _OSTCBCur.L,A0
000044DA  1020      
000044DC  1D68 0034 12947          move.b    52(A0),11(A6)
000044E0  000B      
                    12948   OSTaskChangePrio_4:
                    12949   ; }
                    12950   ; ptcb = OSTCBPrioTbl[oldprio];
000044E2  102E 000B 12951          move.b    11(A6),D0
000044E6  C0BC 0000 12952          and.l     #255,D0
000044EA  00FF      
000044EC  E588      12953          lsl.l     #2,D0
000044EE  2634 0800 12954          move.l    0(A4,D0.L),D3
                    12955   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
000044F2  4A83      12956          tst.l     D3
000044F4  6608      12957          bne.s     OSTaskChangePrio_6
                    12958   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000044F6  46DF      12959          dc.w      18143
                    12960   ; return (OS_ERR_PRIO);
000044F8  7029      12961          moveq     #41,D0
000044FA  6000 01AE 12962          bra       OSTaskChangePrio_3
                    12963   OSTaskChangePrio_6:
                    12964   ; }
                    12965   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
000044FE  0C83 0000 12966          cmp.l     #1,D3
00004502  0001      
00004504  6608      12967          bne.s     OSTaskChangePrio_8
                    12968   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
00004506  46DF      12969          dc.w      18143
                    12970   ; return (OS_ERR_TASK_NOT_EXIST);
00004508  7043      12971          moveq     #67,D0
0000450A  6000 019E 12972          bra       OSTaskChangePrio_3
                    12973   OSTaskChangePrio_8:
                    12974   ; }
                    12975   ; #if OS_LOWEST_PRIO <= 63u
                    12976   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
0000450E  102E 000F 12977          move.b    15(A6),D0
00004512  E608      12978          lsr.b     #3,D0
00004514  1A00      12979          move.b    D0,D5
                    12980   ; x_new                 = (INT8U)(newprio & 0x07u);
00004516  102E 000F 12981          move.b    15(A6),D0
0000451A  C03C 0007 12982          and.b     #7,D0
0000451E  1D40 FFFD 12983          move.b    D0,-3(A6)
                    12984   ; #else
                    12985   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    12986   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    12987   ; #endif
                    12988   ; bity_new              = (OS_PRIO)(1uL << y_new);
00004522  7001      12989          moveq     #1,D0
00004524  CABC 0000 12990          and.l     #255,D5
00004528  00FF      
0000452A  EBA8      12991          lsl.l     D5,D0
0000452C  1D40 FFFE 12992          move.b    D0,-2(A6)
                    12993   ; bitx_new              = (OS_PRIO)(1uL << x_new);
00004530  7001      12994          moveq     #1,D0
00004532  122E FFFD 12995          move.b    -3(A6),D1
00004536  C2BC 0000 12996          and.l     #255,D1
0000453A  00FF      
0000453C  E3A8      12997          lsl.l     D1,D0
0000453E  1E00      12998          move.b    D0,D7
                    12999   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
00004540  102E 000B 13000          move.b    11(A6),D0
00004544  C0BC 0000 13001          and.l     #255,D0
00004548  00FF      
0000454A  E588      13002          lsl.l     #2,D0
0000454C  42B4 0800 13003          clr.l     0(A4,D0.L)
                    13004   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00004550  102E 000F 13005          move.b    15(A6),D0
00004554  C0BC 0000 13006          and.l     #255,D0
00004558  00FF      
0000455A  E588      13007          lsl.l     #2,D0
0000455C  2983 0800 13008          move.l    D3,0(A4,D0.L)
                    13009   ; y_old                 =  ptcb->OSTCBY;
00004560  2043      13010          move.l    D3,A0
00004562  1828 0036 13011          move.b    54(A0),D4
                    13012   ; bity_old              =  ptcb->OSTCBBitY;
00004566  2043      13013          move.l    D3,A0
00004568  1D68 0038 13014          move.b    56(A0),-1(A6)
0000456C  FFFF      
                    13015   ; bitx_old              =  ptcb->OSTCBBitX;
0000456E  2043      13016          move.l    D3,A0
00004570  1C28 0037 13017          move.b    55(A0),D6
                    13018   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00004574  C8BC 0000 13019          and.l     #255,D4
00004578  00FF      
0000457A  1033 4800 13020          move.b    0(A3,D4.L),D0
0000457E  C006      13021          and.b     D6,D0
00004580  673A      13022          beq.s     OSTaskChangePrio_10
                    13023   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
00004582  C8BC 0000 13024          and.l     #255,D4
00004586  00FF      
00004588  1006      13025          move.b    D6,D0
0000458A  4600      13026          not.b     D0
0000458C  C133 4800 13027          and.b     D0,0(A3,D4.L)
                    13028   ; if (OSRdyTbl[y_old] == 0u) {
00004590  C8BC 0000 13029          and.l     #255,D4
00004594  00FF      
00004596  1033 4800 13030          move.b    0(A3,D4.L),D0
0000459A  660C      13031          bne.s     OSTaskChangePrio_12
                    13032   ; OSRdyGrp &= (OS_PRIO)~bity_old;
0000459C  102E FFFF 13033          move.b    -1(A6),D0
000045A0  4600      13034          not.b     D0
000045A2  C139 0800 13035          and.b     D0,_OSRdyGrp.L
000045A6  0F0E      
                    13036   OSTaskChangePrio_12:
                    13037   ; }
                    13038   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
000045A8  102E FFFE 13039          move.b    -2(A6),D0
000045AC  8139 0800 13040          or.b      D0,_OSRdyGrp.L
000045B0  0F0E      
                    13041   ; OSRdyTbl[y_new] |= bitx_new;
000045B2  CABC 0000 13042          and.l     #255,D5
000045B6  00FF      
000045B8  8F33 5800 13043          or.b      D7,0(A3,D5.L)
                    13044   OSTaskChangePrio_10:
                    13045   ; }
                    13046   ; #if (OS_EVENT_EN)
                    13047   ; pevent = ptcb->OSTCBEventPtr;
000045BC  2043      13048          move.l    D3,A0
000045BE  2428 001C 13049          move.l    28(A0),D2
                    13050   ; if (pevent != (OS_EVENT *)0) {
000045C2  4A82      13051          tst.l     D2
000045C4  6700 0048 13052          beq       OSTaskChangePrio_14
                    13053   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
000045C8  2042      13054          move.l    D2,A0
000045CA  C8BC 0000 13055          and.l     #255,D4
000045CE  00FF      
000045D0  D1C4      13056          add.l     D4,A0
000045D2  1006      13057          move.b    D6,D0
000045D4  4600      13058          not.b     D0
000045D6  C128 000A 13059          and.b     D0,10(A0)
                    13060   ; if (pevent->OSEventTbl[y_old] == 0u) {
000045DA  2042      13061          move.l    D2,A0
000045DC  C8BC 0000 13062          and.l     #255,D4
000045E0  00FF      
000045E2  D1C4      13063          add.l     D4,A0
000045E4  1028 000A 13064          move.b    10(A0),D0
000045E8  660C      13065          bne.s     OSTaskChangePrio_16
                    13066   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000045EA  2042      13067          move.l    D2,A0
000045EC  102E FFFF 13068          move.b    -1(A6),D0
000045F0  4600      13069          not.b     D0
000045F2  C128 0008 13070          and.b     D0,8(A0)
                    13071   OSTaskChangePrio_16:
                    13072   ; }
                    13073   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
000045F6  2042      13074          move.l    D2,A0
000045F8  102E FFFE 13075          move.b    -2(A6),D0
000045FC  8128 0008 13076          or.b      D0,8(A0)
                    13077   ; pevent->OSEventTbl[y_new] |= bitx_new;
00004600  2042      13078          move.l    D2,A0
00004602  CABC 0000 13079          and.l     #255,D5
00004606  00FF      
00004608  D1C5      13080          add.l     D5,A0
0000460A  8F28 000A 13081          or.b      D7,10(A0)
                    13082   OSTaskChangePrio_14:
                    13083   ; }
                    13084   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13085   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
0000460E  2043      13086          move.l    D3,A0
00004610  2028 0020 13087          move.l    32(A0),D0
00004614  6700 005C 13088          beq       OSTaskChangePrio_22
                    13089   ; pevents =  ptcb->OSTCBEventMultiPtr;
00004618  2043      13090          move.l    D3,A0
0000461A  2468 0020 13091          move.l    32(A0),A2
                    13092   ; pevent  = *pevents;
0000461E  2412      13093          move.l    (A2),D2
                    13094   ; while (pevent != (OS_EVENT *)0) {
                    13095   OSTaskChangePrio_20:
00004620  4A82      13096          tst.l     D2
00004622  6700 004E 13097          beq       OSTaskChangePrio_22
                    13098   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
00004626  2042      13099          move.l    D2,A0
00004628  C8BC 0000 13100          and.l     #255,D4
0000462C  00FF      
0000462E  D1C4      13101          add.l     D4,A0
00004630  1006      13102          move.b    D6,D0
00004632  4600      13103          not.b     D0
00004634  C128 000A 13104          and.b     D0,10(A0)
                    13105   ; if (pevent->OSEventTbl[y_old] == 0u) {
00004638  2042      13106          move.l    D2,A0
0000463A  C8BC 0000 13107          and.l     #255,D4
0000463E  00FF      
00004640  D1C4      13108          add.l     D4,A0
00004642  1028 000A 13109          move.b    10(A0),D0
00004646  660C      13110          bne.s     OSTaskChangePrio_23
                    13111   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
00004648  2042      13112          move.l    D2,A0
0000464A  102E FFFF 13113          move.b    -1(A6),D0
0000464E  4600      13114          not.b     D0
00004650  C128 0008 13115          and.b     D0,8(A0)
                    13116   OSTaskChangePrio_23:
                    13117   ; }
                    13118   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
00004654  2042      13119          move.l    D2,A0
00004656  102E FFFE 13120          move.b    -2(A6),D0
0000465A  8128 0008 13121          or.b      D0,8(A0)
                    13122   ; pevent->OSEventTbl[y_new] |= bitx_new;
0000465E  2042      13123          move.l    D2,A0
00004660  CABC 0000 13124          and.l     #255,D5
00004664  00FF      
00004666  D1C5      13125          add.l     D5,A0
00004668  8F28 000A 13126          or.b      D7,10(A0)
                    13127   ; pevents++;
0000466C  584A      13128          addq.w    #4,A2
                    13129   ; pevent                     = *pevents;
0000466E  2412      13130          move.l    (A2),D2
00004670  60AE      13131          bra       OSTaskChangePrio_20
                    13132   OSTaskChangePrio_22:
                    13133   ; }
                    13134   ; }
                    13135   ; #endif
                    13136   ; #endif
                    13137   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
00004672  2043      13138          move.l    D3,A0
00004674  116E 000F 13139          move.b    15(A6),52(A0)
00004678  0034      
                    13140   ; ptcb->OSTCBY    = y_new;
0000467A  2043      13141          move.l    D3,A0
0000467C  1145 0036 13142          move.b    D5,54(A0)
                    13143   ; ptcb->OSTCBX    = x_new;
00004680  2043      13144          move.l    D3,A0
00004682  116E FFFD 13145          move.b    -3(A6),53(A0)
00004686  0035      
                    13146   ; ptcb->OSTCBBitY = bity_new;
00004688  2043      13147          move.l    D3,A0
0000468A  116E FFFE 13148          move.b    -2(A6),56(A0)
0000468E  0038      
                    13149   ; ptcb->OSTCBBitX = bitx_new;
00004690  2043      13150          move.l    D3,A0
00004692  1147 0037 13151          move.b    D7,55(A0)
                    13152   ; OS_EXIT_CRITICAL();
00004696  46DF      13153          dc.w      18143
                    13154   ; if (OSRunning == OS_TRUE) {
00004698  1039 0800 13155          move.b    _OSRunning.L,D0
0000469C  0F18      
0000469E  0C00 0001 13156          cmp.b     #1,D0
000046A2  6604      13157          bne.s     OSTaskChangePrio_25
                    13158   ; OS_Sched();                                         /* Find new highest priority task          */
000046A4  4EB8 1816 13159          jsr       _OS_Sched
                    13160   OSTaskChangePrio_25:
                    13161   ; }
                    13162   ; return (OS_ERR_NONE);
000046A8  4200      13163          clr.b     D0
                    13164   OSTaskChangePrio_3:
000046AA  4CDF 1CFC 13165          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
000046AE  4E5E      13166          unlk      A6
000046B0  4E75      13167          rts
                    13168   ; }
                    13169   ; #endif
                    13170   ; /*$PAGE*/
                    13171   ; /*
                    13172   ; *********************************************************************************************************
                    13173   ; *                                            CREATE A TASK
                    13174   ; *
                    13175   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13176   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13177   ; *              created by an ISR.
                    13178   ; *
                    13179   ; * Arguments  : task     is a pointer to the task's code
                    13180   ; *
                    13181   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    13182   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    13183   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    13184   ; *
                    13185   ; *                           void Task (void *p_arg)
                    13186   ; *                           {
                    13187   ; *                               for (;;) {
                    13188   ; *                                   Task code;
                    13189   ; *                               }
                    13190   ; *                           }
                    13191   ; *
                    13192   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    13193   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13194   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    13195   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    13196   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    13197   ; *                       memory locations.
                    13198   ; *
                    13199   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    13200   ; *                       lower the number, the higher the priority.
                    13201   ; *
                    13202   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13203   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13204   ; *                                               (each task MUST have a unique priority).
                    13205   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13206   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    13207   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13208   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13209   ; *                                               operation started.
                    13210   ; *********************************************************************************************************
                    13211   ; */
                    13212   ; #if OS_TASK_CREATE_EN > 0u
                    13213   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    13214   ; void    *p_arg,
                    13215   ; OS_STK  *ptos,
                    13216   ; INT8U    prio)
                    13217   ; {
                    13218   _OSTaskCreate:
000046B2  4E56 FFFC 13219          link      A6,#-4
000046B6  48E7 3020 13220          movem.l   D2/D3/A2,-(A7)
000046BA  142E 0017 13221          move.b    23(A6),D2
000046BE  C4BC 0000 13222          and.l     #255,D2
000046C2  00FF      
000046C4  45F9 0800 13223          lea       _OSTCBPrioTbl.L,A2
000046C8  1030      
                    13224   ; OS_STK     *psp;
                    13225   ; INT8U       err;
                    13226   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13227   ; OS_CPU_SR   cpu_sr = 0u;
                    13228   ; #endif
                    13229   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13230   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13231   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13232   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13233   ; }
                    13234   ; #endif
                    13235   ; #if OS_ARG_CHK_EN > 0u
                    13236   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13237   ; return (OS_ERR_PRIO_INVALID);
                    13238   ; }
                    13239   ; #endif
                    13240   ; OS_ENTER_CRITICAL();
000046CA  40E7      13241          dc.w      16615
000046CC  007C      13242          dc.w      124
000046CE  0700      13243          dc.w      1792
                    13244   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000046D0  1039 0800 13245          move.b    _OSIntNesting.L,D0
000046D4  0F06      
000046D6  0C00 0000 13246          cmp.b     #0,D0
000046DA  6308      13247          bls.s     OSTaskCreate_1
                    13248   ; OS_EXIT_CRITICAL();
000046DC  46DF      13249          dc.w      18143
                    13250   ; return (OS_ERR_TASK_CREATE_ISR);
000046DE  703C      13251          moveq     #60,D0
000046E0  6000 0096 13252          bra       OSTaskCreate_3
                    13253   OSTaskCreate_1:
                    13254   ; }
                    13255   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000046E4  C4BC 0000 13256          and.l     #255,D2
000046E8  00FF      
000046EA  2002      13257          move.l    D2,D0
000046EC  E588      13258          lsl.l     #2,D0
000046EE  2032 0800 13259          move.l    0(A2,D0.L),D0
000046F2  6600 0080 13260          bne       OSTaskCreate_4
                    13261   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000046F6  C4BC 0000 13262          and.l     #255,D2
000046FA  00FF      
000046FC  2002      13263          move.l    D2,D0
000046FE  E588      13264          lsl.l     #2,D0
00004700  25BC 0000 13265          move.l    #1,0(A2,D0.L)
00004704  0001 0800 
                    13266   ; /* ... the same thing until task is created.              */
                    13267   ; OS_EXIT_CRITICAL();
00004708  46DF      13268          dc.w      18143
                    13269   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
0000470A  42A7      13270          clr.l     -(A7)
0000470C  2F2E 0010 13271          move.l    16(A6),-(A7)
00004710  2F2E 000C 13272          move.l    12(A6),-(A7)
00004714  2F2E 0008 13273          move.l    8(A6),-(A7)
00004718  4EB8 0A18 13274          jsr       _OSTaskStkInit
0000471C  DEFC 0010 13275          add.w     #16,A7
00004720  2D40 FFFC 13276          move.l    D0,-4(A6)
                    13277   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00004724  42A7      13278          clr.l     -(A7)
00004726  42A7      13279          clr.l     -(A7)
00004728  42A7      13280          clr.l     -(A7)
0000472A  42A7      13281          clr.l     -(A7)
0000472C  42A7      13282          clr.l     -(A7)
0000472E  2F2E FFFC 13283          move.l    -4(A6),-(A7)
00004732  C4BC 0000 13284          and.l     #255,D2
00004736  00FF      
00004738  2F02      13285          move.l    D2,-(A7)
0000473A  4EB8 1A30 13286          jsr       _OS_TCBInit
0000473E  DEFC 001C 13287          add.w     #28,A7
00004742  1600      13288          move.b    D0,D3
                    13289   ; if (err == OS_ERR_NONE) {
00004744  4A03      13290          tst.b     D3
00004746  6612      13291          bne.s     OSTaskCreate_6
                    13292   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
00004748  1039 0800 13293          move.b    _OSRunning.L,D0
0000474C  0F18      
0000474E  0C00 0001 13294          cmp.b     #1,D0
00004752  6604      13295          bne.s     OSTaskCreate_8
                    13296   ; OS_Sched();
00004754  4EB8 1816 13297          jsr       _OS_Sched
                    13298   OSTaskCreate_8:
00004758  6016      13299          bra.s     OSTaskCreate_7
                    13300   OSTaskCreate_6:
                    13301   ; }
                    13302   ; } else {
                    13303   ; OS_ENTER_CRITICAL();
0000475A  40E7      13304          dc.w      16615
0000475C  007C      13305          dc.w      124
0000475E  0700      13306          dc.w      1792
                    13307   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00004760  C4BC 0000 13308          and.l     #255,D2
00004764  00FF      
00004766  2002      13309          move.l    D2,D0
00004768  E588      13310          lsl.l     #2,D0
0000476A  42B2 0800 13311          clr.l     0(A2,D0.L)
                    13312   ; OS_EXIT_CRITICAL();
0000476E  46DF      13313          dc.w      18143
                    13314   OSTaskCreate_7:
                    13315   ; }
                    13316   ; return (err);
00004770  1003      13317          move.b    D3,D0
00004772  6004      13318          bra.s     OSTaskCreate_3
                    13319   OSTaskCreate_4:
                    13320   ; }
                    13321   ; OS_EXIT_CRITICAL();
00004774  46DF      13322          dc.w      18143
                    13323   ; return (OS_ERR_PRIO_EXIST);
00004776  7028      13324          moveq     #40,D0
                    13325   OSTaskCreate_3:
00004778  4CDF 040C 13326          movem.l   (A7)+,D2/D3/A2
0000477C  4E5E      13327          unlk      A6
0000477E  4E75      13328          rts
                    13329   ; }
                    13330   ; #endif
                    13331   ; /*$PAGE*/
                    13332   ; /*
                    13333   ; *********************************************************************************************************
                    13334   ; *                                  CREATE A TASK (Extended Version)
                    13335   ; *
                    13336   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13337   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13338   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13339   ; *              additional information about a task to be specified.
                    13340   ; *
                    13341   ; * Arguments  : task      is a pointer to the task's code
                    13342   ; *
                    13343   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13344   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13345   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13346   ; *
                    13347   ; *                            void Task (void *p_arg)
                    13348   ; *                            {
                    13349   ; *                                for (;;) {
                    13350   ; *                                    Task code;
                    13351   ; *                                }
                    13352   ; *                            }
                    13353   ; *
                    13354   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13355   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13356   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13357   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13358   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13359   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13360   ; *
                    13361   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13362   ; *                        lower the number, the higher the priority.
                    13363   ; *
                    13364   ; *              id        is the task's ID (0..65535)
                    13365   ; *
                    13366   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13367   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13368   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13369   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13370   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13371   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13372   ; *
                    13373   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13374   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13375   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13376   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13377   ; *                        available on the stack.
                    13378   ; *
                    13379   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13380   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13381   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13382   ; *                        the task has been switched-in, etc.
                    13383   ; *
                    13384   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13385   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13386   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13387   ; *
                    13388   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13389   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13390   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13391   ; *                                                 during a context switch.
                    13392   ; *
                    13393   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13394   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13395   ; *                                               (each task MUST have a unique priority).
                    13396   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13397   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13398   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13399   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13400   ; *                                               operation started.
                    13401   ; *********************************************************************************************************
                    13402   ; */
                    13403   ; /*$PAGE*/
                    13404   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13405   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13406   ; void    *p_arg,
                    13407   ; OS_STK  *ptos,
                    13408   ; INT8U    prio,
                    13409   ; INT16U   id,
                    13410   ; OS_STK  *pbos,
                    13411   ; INT32U   stk_size,
                    13412   ; void    *pext,
                    13413   ; INT16U   opt)
                    13414   ; {
                    13415   _OSTaskCreateExt:
00004780  4E56 FFFC 13416          link      A6,#-4
00004784  48E7 3820 13417          movem.l   D2/D3/D4/A2,-(A7)
00004788  142E 0017 13418          move.b    23(A6),D2
0000478C  C4BC 0000 13419          and.l     #255,D2
00004790  00FF      
00004792  382E 002A 13420          move.w    42(A6),D4
00004796  C8BC 0000 13421          and.l     #65535,D4
0000479A  FFFF      
0000479C  45F9 0800 13422          lea       _OSTCBPrioTbl.L,A2
000047A0  1030      
                    13423   ; OS_STK     *psp;
                    13424   ; INT8U       err;
                    13425   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13426   ; OS_CPU_SR   cpu_sr = 0u;
                    13427   ; #endif
                    13428   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13429   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13430   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13431   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13432   ; }
                    13433   ; #endif
                    13434   ; #if OS_ARG_CHK_EN > 0u
                    13435   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13436   ; return (OS_ERR_PRIO_INVALID);
                    13437   ; }
                    13438   ; #endif
                    13439   ; OS_ENTER_CRITICAL();
000047A2  40E7      13440          dc.w      16615
000047A4  007C      13441          dc.w      124
000047A6  0700      13442          dc.w      1792
                    13443   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000047A8  1039 0800 13444          move.b    _OSIntNesting.L,D0
000047AC  0F06      
000047AE  0C00 0000 13445          cmp.b     #0,D0
000047B2  6308      13446          bls.s     OSTaskCreateExt_1
                    13447   ; OS_EXIT_CRITICAL();
000047B4  46DF      13448          dc.w      18143
                    13449   ; return (OS_ERR_TASK_CREATE_ISR);
000047B6  703C      13450          moveq     #60,D0
000047B8  6000 00CC 13451          bra       OSTaskCreateExt_3
                    13452   OSTaskCreateExt_1:
                    13453   ; }
                    13454   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000047BC  C4BC 0000 13455          and.l     #255,D2
000047C0  00FF      
000047C2  2002      13456          move.l    D2,D0
000047C4  E588      13457          lsl.l     #2,D0
000047C6  2032 0800 13458          move.l    0(A2,D0.L),D0
000047CA  6600 00B6 13459          bne       OSTaskCreateExt_4
                    13460   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000047CE  C4BC 0000 13461          and.l     #255,D2
000047D2  00FF      
000047D4  2002      13462          move.l    D2,D0
000047D6  E588      13463          lsl.l     #2,D0
000047D8  25BC 0000 13464          move.l    #1,0(A2,D0.L)
000047DC  0001 0800 
                    13465   ; /* ... the same thing until task is created.              */
                    13466   ; OS_EXIT_CRITICAL();
000047E0  46DF      13467          dc.w      18143
                    13468   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13469   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
000047E2  C8BC 0000 13470          and.l     #65535,D4
000047E6  FFFF      
000047E8  2F04      13471          move.l    D4,-(A7)
000047EA  2F2E 0020 13472          move.l    32(A6),-(A7)
000047EE  2F2E 001C 13473          move.l    28(A6),-(A7)
000047F2  4EB9 0000 13474          jsr       _OS_TaskStkClr
000047F6  4FDA      
000047F8  DEFC 000C 13475          add.w     #12,A7
                    13476   ; #endif
                    13477   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
000047FC  C8BC 0000 13478          and.l     #65535,D4
00004800  FFFF      
00004802  2F04      13479          move.l    D4,-(A7)
00004804  2F2E 0010 13480          move.l    16(A6),-(A7)
00004808  2F2E 000C 13481          move.l    12(A6),-(A7)
0000480C  2F2E 0008 13482          move.l    8(A6),-(A7)
00004810  4EB8 0A18 13483          jsr       _OSTaskStkInit
00004814  DEFC 0010 13484          add.w     #16,A7
00004818  2D40 FFFC 13485          move.l    D0,-4(A6)
                    13486   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
0000481C  C8BC 0000 13487          and.l     #65535,D4
00004820  FFFF      
00004822  2F04      13488          move.l    D4,-(A7)
00004824  2F2E 0024 13489          move.l    36(A6),-(A7)
00004828  2F2E 0020 13490          move.l    32(A6),-(A7)
0000482C  322E 001A 13491          move.w    26(A6),D1
00004830  C2BC 0000 13492          and.l     #65535,D1
00004834  FFFF      
00004836  2F01      13493          move.l    D1,-(A7)
00004838  2F2E 001C 13494          move.l    28(A6),-(A7)
0000483C  2F2E FFFC 13495          move.l    -4(A6),-(A7)
00004840  C4BC 0000 13496          and.l     #255,D2
00004844  00FF      
00004846  2F02      13497          move.l    D2,-(A7)
00004848  4EB8 1A30 13498          jsr       _OS_TCBInit
0000484C  DEFC 001C 13499          add.w     #28,A7
00004850  1600      13500          move.b    D0,D3
                    13501   ; if (err == OS_ERR_NONE) {
00004852  4A03      13502          tst.b     D3
00004854  6612      13503          bne.s     OSTaskCreateExt_6
                    13504   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
00004856  1039 0800 13505          move.b    _OSRunning.L,D0
0000485A  0F18      
0000485C  0C00 0001 13506          cmp.b     #1,D0
00004860  6604      13507          bne.s     OSTaskCreateExt_8
                    13508   ; OS_Sched();
00004862  4EB8 1816 13509          jsr       _OS_Sched
                    13510   OSTaskCreateExt_8:
00004866  6016      13511          bra.s     OSTaskCreateExt_7
                    13512   OSTaskCreateExt_6:
                    13513   ; }
                    13514   ; } else {
                    13515   ; OS_ENTER_CRITICAL();
00004868  40E7      13516          dc.w      16615
0000486A  007C      13517          dc.w      124
0000486C  0700      13518          dc.w      1792
                    13519   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
0000486E  C4BC 0000 13520          and.l     #255,D2
00004872  00FF      
00004874  2002      13521          move.l    D2,D0
00004876  E588      13522          lsl.l     #2,D0
00004878  42B2 0800 13523          clr.l     0(A2,D0.L)
                    13524   ; OS_EXIT_CRITICAL();
0000487C  46DF      13525          dc.w      18143
                    13526   OSTaskCreateExt_7:
                    13527   ; }
                    13528   ; return (err);
0000487E  1003      13529          move.b    D3,D0
00004880  6004      13530          bra.s     OSTaskCreateExt_3
                    13531   OSTaskCreateExt_4:
                    13532   ; }
                    13533   ; OS_EXIT_CRITICAL();
00004882  46DF      13534          dc.w      18143
                    13535   ; return (OS_ERR_PRIO_EXIST);
00004884  7028      13536          moveq     #40,D0
                    13537   OSTaskCreateExt_3:
00004886  4CDF 041C 13538          movem.l   (A7)+,D2/D3/D4/A2
0000488A  4E5E      13539          unlk      A6
0000488C  4E75      13540          rts
                    13541   ; }
                    13542   ; #endif
                    13543   ; /*$PAGE*/
                    13544   ; /*
                    13545   ; *********************************************************************************************************
                    13546   ; *                                            DELETE A TASK
                    13547   ; *
                    13548   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13549   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13550   ; *              re-activated by creating the deleted task again.
                    13551   ; *
                    13552   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13553   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13554   ; *                      OS_PRIO_SELF.
                    13555   ; *
                    13556   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13557   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13558   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13559   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13560   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13561   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13562   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13563   ; *
                    13564   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13565   ; *                    a) by making it not ready
                    13566   ; *                    b) by removing it from any wait lists
                    13567   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13568   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13569   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13570   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13571   ; *              3) An ISR cannot delete a task.
                    13572   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13573   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13574   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13575   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13576   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13577   ; *********************************************************************************************************
                    13578   ; */
                    13579   ; #if OS_TASK_DEL_EN > 0u
                    13580   ; INT8U  OSTaskDel (INT8U prio)
                    13581   ; {
                    13582   _OSTaskDel:
0000488E  4E56 0000 13583          link      A6,#0
00004892  48E7 3800 13584          movem.l   D2/D3/D4,-(A7)
00004896  162E 000B 13585          move.b    11(A6),D3
0000489A  C6BC 0000 13586          and.l     #255,D3
0000489E  00FF      
                    13587   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13588   ; OS_FLAG_NODE *pnode;
                    13589   ; #endif
                    13590   ; OS_TCB       *ptcb;
                    13591   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13592   ; OS_CPU_SR     cpu_sr = 0u;
                    13593   ; #endif
                    13594   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
000048A0  1039 0800 13595          move.b    _OSIntNesting.L,D0
000048A4  0F06      
000048A6  0C00 0000 13596          cmp.b     #0,D0
000048AA  6306      13597          bls.s     OSTaskDel_1
                    13598   ; return (OS_ERR_TASK_DEL_ISR);
000048AC  7040      13599          moveq     #64,D0
000048AE  6000 01A4 13600          bra       OSTaskDel_3
                    13601   OSTaskDel_1:
                    13602   ; }
                    13603   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
000048B2  0C03 003F 13604          cmp.b     #63,D3
000048B6  6606      13605          bne.s     OSTaskDel_4
                    13606   ; return (OS_ERR_TASK_DEL_IDLE);
000048B8  703E      13607          moveq     #62,D0
000048BA  6000 0198 13608          bra       OSTaskDel_3
                    13609   OSTaskDel_4:
                    13610   ; }
                    13611   ; #if OS_ARG_CHK_EN > 0u
                    13612   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13613   ; if (prio != OS_PRIO_SELF) {
                    13614   ; return (OS_ERR_PRIO_INVALID);
                    13615   ; }
                    13616   ; }
                    13617   ; #endif
                    13618   ; /*$PAGE*/
                    13619   ; OS_ENTER_CRITICAL();
000048BE  40E7      13620          dc.w      16615
000048C0  007C      13621          dc.w      124
000048C2  0700      13622          dc.w      1792
                    13623   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
000048C4  0C03 00FF 13624          cmp.b     #255,D3
000048C8  660A      13625          bne.s     OSTaskDel_6
                    13626   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
000048CA  2079 0800 13627          move.l    _OSTCBCur.L,A0
000048CE  1020      
000048D0  1628 0034 13628          move.b    52(A0),D3
                    13629   OSTaskDel_6:
                    13630   ; }
                    13631   ; ptcb = OSTCBPrioTbl[prio];
000048D4  C6BC 0000 13632          and.l     #255,D3
000048D8  00FF      
000048DA  2003      13633          move.l    D3,D0
000048DC  E588      13634          lsl.l     #2,D0
000048DE  41F9 0800 13635          lea       _OSTCBPrioTbl.L,A0
000048E2  1030      
000048E4  2430 0800 13636          move.l    0(A0,D0.L),D2
                    13637   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
000048E8  4A82      13638          tst.l     D2
000048EA  6608      13639          bne.s     OSTaskDel_8
                    13640   ; OS_EXIT_CRITICAL();
000048EC  46DF      13641          dc.w      18143
                    13642   ; return (OS_ERR_TASK_NOT_EXIST);
000048EE  7043      13643          moveq     #67,D0
000048F0  6000 0162 13644          bra       OSTaskDel_3
                    13645   OSTaskDel_8:
                    13646   ; }
                    13647   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
000048F4  0C82 0000 13648          cmp.l     #1,D2
000048F8  0001      
000048FA  6608      13649          bne.s     OSTaskDel_10
                    13650   ; OS_EXIT_CRITICAL();
000048FC  46DF      13651          dc.w      18143
                    13652   ; return (OS_ERR_TASK_DEL);
000048FE  703D      13653          moveq     #61,D0
00004900  6000 0152 13654          bra       OSTaskDel_3
                    13655   OSTaskDel_10:
                    13656   ; }
                    13657   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
00004904  2042      13658          move.l    D2,A0
00004906  1028 0036 13659          move.b    54(A0),D0
0000490A  C0BC 0000 13660          and.l     #255,D0
0000490E  00FF      
00004910  41F9 0800 13661          lea       _OSRdyTbl.L,A0
00004914  0F10      
00004916  2242      13662          move.l    D2,A1
00004918  1229 0037 13663          move.b    55(A1),D1
0000491C  4601      13664          not.b     D1
0000491E  C330 0800 13665          and.b     D1,0(A0,D0.L)
                    13666   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
00004922  2042      13667          move.l    D2,A0
00004924  1028 0036 13668          move.b    54(A0),D0
00004928  C0BC 0000 13669          and.l     #255,D0
0000492C  00FF      
0000492E  41F9 0800 13670          lea       _OSRdyTbl.L,A0
00004932  0F10      
00004934  1030 0800 13671          move.b    0(A0,D0.L),D0
00004938  660E      13672          bne.s     OSTaskDel_12
                    13673   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
0000493A  2042      13674          move.l    D2,A0
0000493C  1028 0038 13675          move.b    56(A0),D0
00004940  4600      13676          not.b     D0
00004942  C139 0800 13677          and.b     D0,_OSRdyGrp.L
00004946  0F0E      
                    13678   OSTaskDel_12:
                    13679   ; }
                    13680   ; #if (OS_EVENT_EN)
                    13681   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
00004948  2042      13682          move.l    D2,A0
0000494A  2028 001C 13683          move.l    28(A0),D0
0000494E  670E      13684          beq.s     OSTaskDel_14
                    13685   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
00004950  2042      13686          move.l    D2,A0
00004952  2F28 001C 13687          move.l    28(A0),-(A7)
00004956  2F02      13688          move.l    D2,-(A7)
00004958  4EB8 143C 13689          jsr       _OS_EventTaskRemove
0000495C  504F      13690          addq.w    #8,A7
                    13691   OSTaskDel_14:
                    13692   ; }
                    13693   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13694   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
0000495E  2042      13695          move.l    D2,A0
00004960  2028 0020 13696          move.l    32(A0),D0
00004964  670E      13697          beq.s     OSTaskDel_16
                    13698   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00004966  2042      13699          move.l    D2,A0
00004968  2F28 0020 13700          move.l    32(A0),-(A7)
0000496C  2F02      13701          move.l    D2,-(A7)
0000496E  4EB8 148E 13702          jsr       _OS_EventTaskRemoveMulti
00004972  504F      13703          addq.w    #8,A7
                    13704   OSTaskDel_16:
                    13705   ; }
                    13706   ; #endif
                    13707   ; #endif
                    13708   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13709   ; pnode = ptcb->OSTCBFlagNode;
00004974  2042      13710          move.l    D2,A0
00004976  2828 0028 13711          move.l    40(A0),D4
                    13712   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
0000497A  4A84      13713          tst.l     D4
0000497C  6708      13714          beq.s     OSTaskDel_18
                    13715   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
0000497E  2F04      13716          move.l    D4,-(A7)
00004980  4EB8 2646 13717          jsr       _OS_FlagUnlink
00004984  584F      13718          addq.w    #4,A7
                    13719   OSTaskDel_18:
                    13720   ; }
                    13721   ; #endif
                    13722   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
00004986  2042      13723          move.l    D2,A0
00004988  42A8 002E 13724          clr.l     46(A0)
                    13725   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
0000498C  2042      13726          move.l    D2,A0
0000498E  4228 0032 13727          clr.b     50(A0)
                    13728   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004992  2042      13729          move.l    D2,A0
00004994  4228 0033 13730          clr.b     51(A0)
                    13731   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
00004998  1039 0800 13732          move.b    _OSLockNesting.L,D0
0000499C  0F08      
0000499E  0C00 00FF 13733          cmp.b     #255,D0
000049A2  6406      13734          bhs.s     OSTaskDel_20
                    13735   ; OSLockNesting++;
000049A4  5239 0800 13736          addq.b    #1,_OSLockNesting.L
000049A8  0F08      
                    13737   OSTaskDel_20:
                    13738   ; }
                    13739   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
000049AA  46DF      13740          dc.w      18143
                    13741   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
000049AC  4EB8 1234 13742          jsr       _OS_Dummy
                    13743   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
000049B0  40E7      13744          dc.w      16615
000049B2  007C      13745          dc.w      124
000049B4  0700      13746          dc.w      1792
                    13747   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
000049B6  1039 0800 13748          move.b    _OSLockNesting.L,D0
000049BA  0F08      
000049BC  0C00 0000 13749          cmp.b     #0,D0
000049C0  6306      13750          bls.s     OSTaskDel_22
                    13751   ; OSLockNesting--;
000049C2  5339 0800 13752          subq.b    #1,_OSLockNesting.L
000049C6  0F08      
                    13753   OSTaskDel_22:
                    13754   ; }
                    13755   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
000049C8  2F02      13756          move.l    D2,-(A7)
000049CA  4EB8 0B02 13757          jsr       _OSTaskDelHook
000049CE  584F      13758          addq.w    #4,A7
                    13759   ; OSTaskCtr--;                                        /* One less task being managed                 */
000049D0  5339 0800 13760          subq.b    #1,_OSTaskCtr.L
000049D4  0F1A      
                    13761   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
000049D6  C6BC 0000 13762          and.l     #255,D3
000049DA  00FF      
000049DC  2003      13763          move.l    D3,D0
000049DE  E588      13764          lsl.l     #2,D0
000049E0  41F9 0800 13765          lea       _OSTCBPrioTbl.L,A0
000049E4  1030      
000049E6  42B0 0800 13766          clr.l     0(A0,D0.L)
                    13767   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
000049EA  2042      13768          move.l    D2,A0
000049EC  2028 0018 13769          move.l    24(A0),D0
000049F0  6616      13770          bne.s     OSTaskDel_24
                    13771   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
000049F2  2042      13772          move.l    D2,A0
000049F4  2068 0014 13773          move.l    20(A0),A0
000049F8  42A8 0018 13774          clr.l     24(A0)
                    13775   ; OSTCBList                  = ptcb->OSTCBNext;
000049FC  2042      13776          move.l    D2,A0
000049FE  23E8 0014 13777          move.l    20(A0),_OSTCBList.L
00004A02  0800 102C 
00004A06  601C      13778          bra.s     OSTaskDel_25
                    13779   OSTaskDel_24:
                    13780   ; } else {
                    13781   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
00004A08  2042      13782          move.l    D2,A0
00004A0A  2242      13783          move.l    D2,A1
00004A0C  2269 0018 13784          move.l    24(A1),A1
00004A10  2368 0014 13785          move.l    20(A0),20(A1)
00004A14  0014      
                    13786   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
00004A16  2042      13787          move.l    D2,A0
00004A18  2242      13788          move.l    D2,A1
00004A1A  2269 0014 13789          move.l    20(A1),A1
00004A1E  2368 0018 13790          move.l    24(A0),24(A1)
00004A22  0018      
                    13791   OSTaskDel_25:
                    13792   ; }
                    13793   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
00004A24  2042      13794          move.l    D2,A0
00004A26  2179 0800 13795          move.l    _OSTCBFreeList.L,20(A0)
00004A2A  1024 0014 
                    13796   ; OSTCBFreeList       = ptcb;
00004A2E  23C2 0800 13797          move.l    D2,_OSTCBFreeList.L
00004A32  1024      
                    13798   ; #if OS_TASK_NAME_EN > 0u
                    13799   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
00004A34  41F9 0000 13800          lea       @ucos_ii_1.L,A0
00004A38  68A4      
00004A3A  2242      13801          move.l    D2,A1
00004A3C  2348 004E 13802          move.l    A0,78(A1)
                    13803   ; #endif
                    13804   ; OS_EXIT_CRITICAL();
00004A40  46DF      13805          dc.w      18143
                    13806   ; if (OSRunning == OS_TRUE) {
00004A42  1039 0800 13807          move.b    _OSRunning.L,D0
00004A46  0F18      
00004A48  0C00 0001 13808          cmp.b     #1,D0
00004A4C  6604      13809          bne.s     OSTaskDel_26
                    13810   ; OS_Sched();                                     /* Find new highest priority task              */
00004A4E  4EB8 1816 13811          jsr       _OS_Sched
                    13812   OSTaskDel_26:
                    13813   ; }
                    13814   ; return (OS_ERR_NONE);
00004A52  4200      13815          clr.b     D0
                    13816   OSTaskDel_3:
00004A54  4CDF 001C 13817          movem.l   (A7)+,D2/D3/D4
00004A58  4E5E      13818          unlk      A6
00004A5A  4E75      13819          rts
                    13820   ; }
                    13821   ; #endif
                    13822   ; /*$PAGE*/
                    13823   ; /*
                    13824   ; *********************************************************************************************************
                    13825   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13826   ; *
                    13827   ; * Description: This function is used to:
                    13828   ; *                   a) notify a task to delete itself.
                    13829   ; *                   b) to see if a task requested that the current task delete itself.
                    13830   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13831   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13832   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13833   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13834   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13835   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13836   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13837   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13838   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13839   ; *              this:
                    13840   ; *
                    13841   ; *                   void Task(void *p_arg)
                    13842   ; *                   {
                    13843   ; *                       .
                    13844   ; *                       .
                    13845   ; *                       while (1) {
                    13846   ; *                           OSTimeDly(1);
                    13847   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13848   ; *                               Release any owned resources;
                    13849   ; *                               De-allocate any dynamic memory;
                    13850   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13851   ; *                           }
                    13852   ; *                       }
                    13853   ; *                   }
                    13854   ; *
                    13855   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13856   ; *
                    13857   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13858   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13859   ; *                                     the request has been executed.
                    13860   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13861   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13862   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13863   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13864   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13865   ; *                                     deleted.
                    13866   ; *********************************************************************************************************
                    13867   ; */
                    13868   ; /*$PAGE*/
                    13869   ; #if OS_TASK_DEL_EN > 0u
                    13870   ; INT8U  OSTaskDelReq (INT8U prio)
                    13871   ; {
                    13872   _OSTaskDelReq:
00004A5C  4E56 FFFC 13873          link      A6,#-4
00004A60  48E7 3000 13874          movem.l   D2/D3,-(A7)
00004A64  162E 000B 13875          move.b    11(A6),D3
00004A68  C6BC 0000 13876          and.l     #255,D3
00004A6C  00FF      
                    13877   ; INT8U      stat;
                    13878   ; OS_TCB    *ptcb;
                    13879   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13880   ; OS_CPU_SR  cpu_sr = 0u;
                    13881   ; #endif
                    13882   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004A6E  0C03 003F 13883          cmp.b     #63,D3
00004A72  6606      13884          bne.s     OSTaskDelReq_1
                    13885   ; return (OS_ERR_TASK_DEL_IDLE);
00004A74  703E      13886          moveq     #62,D0
00004A76  6000 0062 13887          bra       OSTaskDelReq_3
                    13888   OSTaskDelReq_1:
                    13889   ; }
                    13890   ; #if OS_ARG_CHK_EN > 0u
                    13891   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13892   ; if (prio != OS_PRIO_SELF) {
                    13893   ; return (OS_ERR_PRIO_INVALID);
                    13894   ; }
                    13895   ; }
                    13896   ; #endif
                    13897   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
00004A7A  0C03 00FF 13898          cmp.b     #255,D3
00004A7E  661C      13899          bne.s     OSTaskDelReq_4
                    13900   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004A80  40E7      13901          dc.w      16615
00004A82  007C      13902          dc.w      124
00004A84  0700      13903          dc.w      1792
                    13904   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
00004A86  2079 0800 13905          move.l    _OSTCBCur.L,A0
00004A8A  1020      
00004A8C  1D68 0039 13906          move.b    57(A0),-1(A6)
00004A90  FFFF      
                    13907   ; OS_EXIT_CRITICAL();
00004A92  46DF      13908          dc.w      18143
                    13909   ; return (stat);
00004A94  102E FFFF 13910          move.b    -1(A6),D0
00004A98  6000 0040 13911          bra       OSTaskDelReq_3
                    13912   OSTaskDelReq_4:
                    13913   ; }
                    13914   ; OS_ENTER_CRITICAL();
00004A9C  40E7      13915          dc.w      16615
00004A9E  007C      13916          dc.w      124
00004AA0  0700      13917          dc.w      1792
                    13918   ; ptcb = OSTCBPrioTbl[prio];
00004AA2  C6BC 0000 13919          and.l     #255,D3
00004AA6  00FF      
00004AA8  2003      13920          move.l    D3,D0
00004AAA  E588      13921          lsl.l     #2,D0
00004AAC  41F9 0800 13922          lea       _OSTCBPrioTbl.L,A0
00004AB0  1030      
00004AB2  2430 0800 13923          move.l    0(A0,D0.L),D2
                    13924   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00004AB6  4A82      13925          tst.l     D2
00004AB8  6606      13926          bne.s     OSTaskDelReq_6
                    13927   ; OS_EXIT_CRITICAL();
00004ABA  46DF      13928          dc.w      18143
                    13929   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
00004ABC  7043      13930          moveq     #67,D0
00004ABE  601A      13931          bra.s     OSTaskDelReq_3
                    13932   OSTaskDelReq_6:
                    13933   ; }
                    13934   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00004AC0  0C82 0000 13935          cmp.l     #1,D2
00004AC4  0001      
00004AC6  6606      13936          bne.s     OSTaskDelReq_8
                    13937   ; OS_EXIT_CRITICAL();
00004AC8  46DF      13938          dc.w      18143
                    13939   ; return (OS_ERR_TASK_DEL);
00004ACA  703D      13940          moveq     #61,D0
00004ACC  600C      13941          bra.s     OSTaskDelReq_3
                    13942   OSTaskDelReq_8:
                    13943   ; }
                    13944   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00004ACE  2042      13945          move.l    D2,A0
00004AD0  117C 003F 13946          move.b    #63,57(A0)
00004AD4  0039      
                    13947   ; OS_EXIT_CRITICAL();
00004AD6  46DF      13948          dc.w      18143
                    13949   ; return (OS_ERR_NONE);
00004AD8  4200      13950          clr.b     D0
                    13951   OSTaskDelReq_3:
00004ADA  4CDF 000C 13952          movem.l   (A7)+,D2/D3
00004ADE  4E5E      13953          unlk      A6
00004AE0  4E75      13954          rts
                    13955   ; }
                    13956   ; #endif
                    13957   ; /*$PAGE*/
                    13958   ; /*
                    13959   ; *********************************************************************************************************
                    13960   ; *                                       GET THE NAME OF A TASK
                    13961   ; *
                    13962   ; * Description: This function is called to obtain the name of a task.
                    13963   ; *
                    13964   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    13965   ; *
                    13966   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    13967   ; *
                    13968   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    13969   ; *
                    13970   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13971   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13972   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13973   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13974   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13975   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    13976   ; *
                    13977   ; *
                    13978   ; * Returns    : The length of the string or 0 if the task does not exist.
                    13979   ; *********************************************************************************************************
                    13980   ; */
                    13981   ; #if OS_TASK_NAME_EN > 0u
                    13982   ; INT8U  OSTaskNameGet (INT8U    prio,
                    13983   ; INT8U  **pname,
                    13984   ; INT8U   *perr)
                    13985   ; {
                    13986   _OSTaskNameGet:
00004AE2  4E56 FFFC 13987          link      A6,#-4
00004AE6  48E7 3800 13988          movem.l   D2/D3/D4,-(A7)
00004AEA  262E 0010 13989          move.l    16(A6),D3
00004AEE  182E 000B 13990          move.b    11(A6),D4
00004AF2  C8BC 0000 13991          and.l     #255,D4
00004AF6  00FF      
                    13992   ; OS_TCB    *ptcb;
                    13993   ; INT8U      len;
                    13994   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    13995   ; OS_CPU_SR  cpu_sr = 0u;
                    13996   ; #endif
                    13997   ; #ifdef OS_SAFETY_CRITICAL
                    13998   ; if (perr == (INT8U *)0) {
                    13999   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14000   ; return (0u);
                    14001   ; }
                    14002   ; #endif
                    14003   ; #if OS_ARG_CHK_EN > 0u
                    14004   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    14005   ; if (prio != OS_PRIO_SELF) {
                    14006   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    14007   ; return (0u);
                    14008   ; }
                    14009   ; }
                    14010   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    14011   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    14012   ; return (0u);
                    14013   ; }
                    14014   ; #endif
                    14015   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00004AF8  1039 0800 14016          move.b    _OSIntNesting.L,D0
00004AFC  0F06      
00004AFE  0C00 0000 14017          cmp.b     #0,D0
00004B02  630C      14018          bls.s     OSTaskNameGet_1
                    14019   ; *perr = OS_ERR_NAME_GET_ISR;
00004B04  2043      14020          move.l    D3,A0
00004B06  10BC 0011 14021          move.b    #17,(A0)
                    14022   ; return (0u);
00004B0A  4200      14023          clr.b     D0
00004B0C  6000 0076 14024          bra       OSTaskNameGet_3
                    14025   OSTaskNameGet_1:
                    14026   ; }
                    14027   ; OS_ENTER_CRITICAL();
00004B10  40E7      14028          dc.w      16615
00004B12  007C      14029          dc.w      124
00004B14  0700      14030          dc.w      1792
                    14031   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
00004B16  0C04 00FF 14032          cmp.b     #255,D4
00004B1A  660A      14033          bne.s     OSTaskNameGet_4
                    14034   ; prio = OSTCBCur->OSTCBPrio;
00004B1C  2079 0800 14035          move.l    _OSTCBCur.L,A0
00004B20  1020      
00004B22  1828 0034 14036          move.b    52(A0),D4
                    14037   OSTaskNameGet_4:
                    14038   ; }
                    14039   ; ptcb = OSTCBPrioTbl[prio];
00004B26  C8BC 0000 14040          and.l     #255,D4
00004B2A  00FF      
00004B2C  2004      14041          move.l    D4,D0
00004B2E  E588      14042          lsl.l     #2,D0
00004B30  41F9 0800 14043          lea       _OSTCBPrioTbl.L,A0
00004B34  1030      
00004B36  2430 0800 14044          move.l    0(A0,D0.L),D2
                    14045   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
00004B3A  4A82      14046          tst.l     D2
00004B3C  660E      14047          bne.s     OSTaskNameGet_6
                    14048   ; OS_EXIT_CRITICAL();                              /* No                                         */
00004B3E  46DF      14049          dc.w      18143
                    14050   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004B40  2043      14051          move.l    D3,A0
00004B42  10BC 0043 14052          move.b    #67,(A0)
                    14053   ; return (0u);
00004B46  4200      14054          clr.b     D0
00004B48  6000 003A 14055          bra       OSTaskNameGet_3
                    14056   OSTaskNameGet_6:
                    14057   ; }
                    14058   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
00004B4C  0C82 0000 14059          cmp.l     #1,D2
00004B50  0001      
00004B52  660C      14060          bne.s     OSTaskNameGet_8
                    14061   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
00004B54  46DF      14062          dc.w      18143
                    14063   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004B56  2043      14064          move.l    D3,A0
00004B58  10BC 0043 14065          move.b    #67,(A0)
                    14066   ; return (0u);
00004B5C  4200      14067          clr.b     D0
00004B5E  6024      14068          bra.s     OSTaskNameGet_3
                    14069   OSTaskNameGet_8:
                    14070   ; }
                    14071   ; *pname = ptcb->OSTCBTaskName;
00004B60  2042      14072          move.l    D2,A0
00004B62  226E 000C 14073          move.l    12(A6),A1
00004B66  22A8 004E 14074          move.l    78(A0),(A1)
                    14075   ; len    = OS_StrLen(*pname);
00004B6A  206E 000C 14076          move.l    12(A6),A0
00004B6E  2F10      14077          move.l    (A0),-(A7)
00004B70  4EB8 18C0 14078          jsr       _OS_StrLen
00004B74  584F      14079          addq.w    #4,A7
00004B76  1D40 FFFF 14080          move.b    D0,-1(A6)
                    14081   ; OS_EXIT_CRITICAL();
00004B7A  46DF      14082          dc.w      18143
                    14083   ; *perr  = OS_ERR_NONE;
00004B7C  2043      14084          move.l    D3,A0
00004B7E  4210      14085          clr.b     (A0)
                    14086   ; return (len);
00004B80  102E FFFF 14087          move.b    -1(A6),D0
                    14088   OSTaskNameGet_3:
00004B84  4CDF 001C 14089          movem.l   (A7)+,D2/D3/D4
00004B88  4E5E      14090          unlk      A6
00004B8A  4E75      14091          rts
                    14092   ; }
                    14093   ; #endif
                    14094   ; /*$PAGE*/
                    14095   ; /*
                    14096   ; *********************************************************************************************************
                    14097   ; *                                       ASSIGN A NAME TO A TASK
                    14098   ; *
                    14099   ; * Description: This function is used to set the name of a task.
                    14100   ; *
                    14101   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    14102   ; *
                    14103   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    14104   ; *
                    14105   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    14106   ; *
                    14107   ; *                        OS_ERR_NONE                if the requested task is resumed
                    14108   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    14109   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    14110   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    14111   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    14112   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    14113   ; *
                    14114   ; * Returns    : None
                    14115   ; *********************************************************************************************************
                    14116   ; */
                    14117   ; #if OS_TASK_NAME_EN > 0u
                    14118   ; void  OSTaskNameSet (INT8U   prio,
                    14119   ; INT8U  *pname,
                    14120   ; INT8U  *perr)
                    14121   ; {
                    14122   _OSTaskNameSet:
00004B8C  4E56 0000 14123          link      A6,#0
00004B90  48E7 3800 14124          movem.l   D2/D3/D4,-(A7)
00004B94  262E 0010 14125          move.l    16(A6),D3
00004B98  182E 000B 14126          move.b    11(A6),D4
00004B9C  C8BC 0000 14127          and.l     #255,D4
00004BA0  00FF      
                    14128   ; OS_TCB    *ptcb;
                    14129   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    14130   ; OS_CPU_SR  cpu_sr = 0u;
                    14131   ; #endif
                    14132   ; #ifdef OS_SAFETY_CRITICAL
                    14133   ; if (perr == (INT8U *)0) {
                    14134   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14135   ; return;
                    14136   ; }
                    14137   ; #endif
                    14138   ; #if OS_ARG_CHK_EN > 0u
                    14139   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    14140   ; if (prio != OS_PRIO_SELF) {
                    14141   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    14142   ; return;
                    14143   ; }
                    14144   ; }
                    14145   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    14146   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    14147   ; return;
                    14148   ; }
                    14149   ; #endif
                    14150   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004BA2  1039 0800 14151          move.b    _OSIntNesting.L,D0
00004BA6  0F06      
00004BA8  0C00 0000 14152          cmp.b     #0,D0
00004BAC  630A      14153          bls.s     OSTaskNameSet_1
                    14154   ; *perr = OS_ERR_NAME_SET_ISR;
00004BAE  2043      14155          move.l    D3,A0
00004BB0  10BC 0012 14156          move.b    #18,(A0)
                    14157   ; return;
00004BB4  6000 005A 14158          bra       OSTaskNameSet_3
                    14159   OSTaskNameSet_1:
                    14160   ; }
                    14161   ; OS_ENTER_CRITICAL();
00004BB8  40E7      14162          dc.w      16615
00004BBA  007C      14163          dc.w      124
00004BBC  0700      14164          dc.w      1792
                    14165   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
00004BBE  0C04 00FF 14166          cmp.b     #255,D4
00004BC2  660A      14167          bne.s     OSTaskNameSet_4
                    14168   ; prio = OSTCBCur->OSTCBPrio;
00004BC4  2079 0800 14169          move.l    _OSTCBCur.L,A0
00004BC8  1020      
00004BCA  1828 0034 14170          move.b    52(A0),D4
                    14171   OSTaskNameSet_4:
                    14172   ; }
                    14173   ; ptcb = OSTCBPrioTbl[prio];
00004BCE  C8BC 0000 14174          and.l     #255,D4
00004BD2  00FF      
00004BD4  2004      14175          move.l    D4,D0
00004BD6  E588      14176          lsl.l     #2,D0
00004BD8  41F9 0800 14177          lea       _OSTCBPrioTbl.L,A0
00004BDC  1030      
00004BDE  2430 0800 14178          move.l    0(A0,D0.L),D2
                    14179   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
00004BE2  4A82      14180          tst.l     D2
00004BE4  660A      14181          bne.s     OSTaskNameSet_6
                    14182   ; OS_EXIT_CRITICAL();                          /* No                                             */
00004BE6  46DF      14183          dc.w      18143
                    14184   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004BE8  2043      14185          move.l    D3,A0
00004BEA  10BC 0043 14186          move.b    #67,(A0)
                    14187   ; return;
00004BEE  6020      14188          bra.s     OSTaskNameSet_3
                    14189   OSTaskNameSet_6:
                    14190   ; }
                    14191   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
00004BF0  0C82 0000 14192          cmp.l     #1,D2
00004BF4  0001      
00004BF6  660A      14193          bne.s     OSTaskNameSet_8
                    14194   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
00004BF8  46DF      14195          dc.w      18143
                    14196   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004BFA  2043      14197          move.l    D3,A0
00004BFC  10BC 0043 14198          move.b    #67,(A0)
                    14199   ; return;
00004C00  600E      14200          bra.s     OSTaskNameSet_3
                    14201   OSTaskNameSet_8:
                    14202   ; }
                    14203   ; ptcb->OSTCBTaskName = pname;
00004C02  2042      14204          move.l    D2,A0
00004C04  216E 000C 14205          move.l    12(A6),78(A0)
00004C08  004E      
                    14206   ; OS_EXIT_CRITICAL();
00004C0A  46DF      14207          dc.w      18143
                    14208   ; *perr               = OS_ERR_NONE;
00004C0C  2043      14209          move.l    D3,A0
00004C0E  4210      14210          clr.b     (A0)
                    14211   OSTaskNameSet_3:
00004C10  4CDF 001C 14212          movem.l   (A7)+,D2/D3/D4
00004C14  4E5E      14213          unlk      A6
00004C16  4E75      14214          rts
                    14215   ; }
                    14216   ; #endif
                    14217   ; /*$PAGE*/
                    14218   ; /*
                    14219   ; *********************************************************************************************************
                    14220   ; *                                       RESUME A SUSPENDED TASK
                    14221   ; *
                    14222   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    14223   ; *              will remove an explicit task suspension.
                    14224   ; *
                    14225   ; * Arguments  : prio     is the priority of the task to resume.
                    14226   ; *
                    14227   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    14228   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    14229   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    14230   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    14231   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    14232   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    14233   ; *********************************************************************************************************
                    14234   ; */
                    14235   ; #if OS_TASK_SUSPEND_EN > 0u
                    14236   ; INT8U  OSTaskResume (INT8U prio)
                    14237   ; {
                    14238   _OSTaskResume:
00004C18  4E56 0000 14239          link      A6,#0
00004C1C  2F02      14240          move.l    D2,-(A7)
                    14241   ; OS_TCB    *ptcb;
                    14242   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    14243   ; OS_CPU_SR  cpu_sr = 0u;
                    14244   ; #endif
                    14245   ; #if OS_ARG_CHK_EN > 0u
                    14246   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    14247   ; return (OS_ERR_PRIO_INVALID);
                    14248   ; }
                    14249   ; #endif
                    14250   ; OS_ENTER_CRITICAL();
00004C1E  40E7      14251          dc.w      16615
00004C20  007C      14252          dc.w      124
00004C22  0700      14253          dc.w      1792
                    14254   ; ptcb = OSTCBPrioTbl[prio];
00004C24  102E 000B 14255          move.b    11(A6),D0
00004C28  C0BC 0000 14256          and.l     #255,D0
00004C2C  00FF      
00004C2E  E588      14257          lsl.l     #2,D0
00004C30  41F9 0800 14258          lea       _OSTCBPrioTbl.L,A0
00004C34  1030      
00004C36  2430 0800 14259          move.l    0(A0,D0.L),D2
                    14260   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
00004C3A  4A82      14261          tst.l     D2
00004C3C  6608      14262          bne.s     OSTaskResume_1
                    14263   ; OS_EXIT_CRITICAL();
00004C3E  46DF      14264          dc.w      18143
                    14265   ; return (OS_ERR_TASK_RESUME_PRIO);
00004C40  7046      14266          moveq     #70,D0
00004C42  6000 0088 14267          bra       OSTaskResume_3
                    14268   OSTaskResume_1:
                    14269   ; }
                    14270   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004C46  0C82 0000 14271          cmp.l     #1,D2
00004C4A  0001      
00004C4C  6608      14272          bne.s     OSTaskResume_4
                    14273   ; OS_EXIT_CRITICAL();
00004C4E  46DF      14274          dc.w      18143
                    14275   ; return (OS_ERR_TASK_NOT_EXIST);
00004C50  7043      14276          moveq     #67,D0
00004C52  6000 0078 14277          bra       OSTaskResume_3
                    14278   OSTaskResume_4:
                    14279   ; }
                    14280   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004C56  2042      14281          move.l    D2,A0
00004C58  1028 0032 14282          move.b    50(A0),D0
00004C5C  C03C 0008 14283          and.b     #8,D0
00004C60  6700 0066 14284          beq       OSTaskResume_6
                    14285   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004C64  2042      14286          move.l    D2,A0
00004C66  7008      14287          moveq     #8,D0
00004C68  4600      14288          not.b     D0
00004C6A  C128 0032 14289          and.b     D0,50(A0)
                    14290   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004C6E  2042      14291          move.l    D2,A0
00004C70  1028 0032 14292          move.b    50(A0),D0
00004C74  6600 004C 14293          bne       OSTaskResume_8
                    14294   ; if (ptcb->OSTCBDly == 0u) {
00004C78  2042      14295          move.l    D2,A0
00004C7A  2028 002E 14296          move.l    46(A0),D0
00004C7E  6600 003E 14297          bne       OSTaskResume_10
                    14298   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004C82  2042      14299          move.l    D2,A0
00004C84  1028 0038 14300          move.b    56(A0),D0
00004C88  8139 0800 14301          or.b      D0,_OSRdyGrp.L
00004C8C  0F0E      
                    14302   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004C8E  2042      14303          move.l    D2,A0
00004C90  1028 0036 14304          move.b    54(A0),D0
00004C94  C0BC 0000 14305          and.l     #255,D0
00004C98  00FF      
00004C9A  41F9 0800 14306          lea       _OSRdyTbl.L,A0
00004C9E  0F10      
00004CA0  2242      14307          move.l    D2,A1
00004CA2  1229 0037 14308          move.b    55(A1),D1
00004CA6  8330 0800 14309          or.b      D1,0(A0,D0.L)
                    14310   ; OS_EXIT_CRITICAL();
00004CAA  46DF      14311          dc.w      18143
                    14312   ; if (OSRunning == OS_TRUE) {
00004CAC  1039 0800 14313          move.b    _OSRunning.L,D0
00004CB0  0F18      
00004CB2  0C00 0001 14314          cmp.b     #1,D0
00004CB6  6604      14315          bne.s     OSTaskResume_12
                    14316   ; OS_Sched();                               /* Find new highest priority task        */
00004CB8  4EB8 1816 14317          jsr       _OS_Sched
                    14318   OSTaskResume_12:
00004CBC  6002      14319          bra.s     OSTaskResume_11
                    14320   OSTaskResume_10:
                    14321   ; }
                    14322   ; } else {
                    14323   ; OS_EXIT_CRITICAL();
00004CBE  46DF      14324          dc.w      18143
                    14325   OSTaskResume_11:
00004CC0  6002      14326          bra.s     OSTaskResume_9
                    14327   OSTaskResume_8:
                    14328   ; }
                    14329   ; } else {                                              /* Must be pending on event              */
                    14330   ; OS_EXIT_CRITICAL();
00004CC2  46DF      14331          dc.w      18143
                    14332   OSTaskResume_9:
                    14333   ; }
                    14334   ; return (OS_ERR_NONE);
00004CC4  4200      14335          clr.b     D0
00004CC6  6004      14336          bra.s     OSTaskResume_3
                    14337   OSTaskResume_6:
                    14338   ; }
                    14339   ; OS_EXIT_CRITICAL();
00004CC8  46DF      14340          dc.w      18143
                    14341   ; return (OS_ERR_TASK_NOT_SUSPENDED);
00004CCA  7044      14342          moveq     #68,D0
                    14343   OSTaskResume_3:
00004CCC  241F      14344          move.l    (A7)+,D2
00004CCE  4E5E      14345          unlk      A6
00004CD0  4E75      14346          rts
                    14347   ; }
                    14348   ; #endif
                    14349   ; /*$PAGE*/
                    14350   ; /*
                    14351   ; *********************************************************************************************************
                    14352   ; *                                           STACK CHECKING
                    14353   ; *
                    14354   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14355   ; *              stack.
                    14356   ; *
                    14357   ; * Arguments  : prio          is the task priority
                    14358   ; *
                    14359   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14360   ; *
                    14361   ; * Returns    : OS_ERR_NONE            upon success
                    14362   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14363   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14364   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14365   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14366   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14367   ; *********************************************************************************************************
                    14368   ; */
                    14369   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14370   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14371   ; OS_STK_DATA  *p_stk_data)
                    14372   ; {
                    14373   _OSTaskStkChk:
00004CD2  4E56 FFF8 14374          link      A6,#-8
00004CD6  48E7 3C00 14375          movem.l   D2/D3/D4/D5,-(A7)
00004CDA  282E 000C 14376          move.l    12(A6),D4
00004CDE  1A2E 000B 14377          move.b    11(A6),D5
00004CE2  CABC 0000 14378          and.l     #255,D5
00004CE6  00FF      
                    14379   ; OS_TCB    *ptcb;
                    14380   ; OS_STK    *pchk;
                    14381   ; INT32U     nfree;
                    14382   ; INT32U     size;
                    14383   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14384   ; OS_CPU_SR  cpu_sr = 0u;
                    14385   ; #endif
                    14386   ; #if OS_ARG_CHK_EN > 0u
                    14387   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14388   ; if (prio != OS_PRIO_SELF) {
                    14389   ; return (OS_ERR_PRIO_INVALID);
                    14390   ; }
                    14391   ; }
                    14392   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14393   ; return (OS_ERR_PDATA_NULL);
                    14394   ; }
                    14395   ; #endif
                    14396   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00004CE8  2044      14397          move.l    D4,A0
00004CEA  4290      14398          clr.l     (A0)
                    14399   ; p_stk_data->OSUsed = 0u;
00004CEC  2044      14400          move.l    D4,A0
00004CEE  42A8 0004 14401          clr.l     4(A0)
                    14402   ; OS_ENTER_CRITICAL();
00004CF2  40E7      14403          dc.w      16615
00004CF4  007C      14404          dc.w      124
00004CF6  0700      14405          dc.w      1792
                    14406   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
00004CF8  0C05 00FF 14407          cmp.b     #255,D5
00004CFC  660A      14408          bne.s     OSTaskStkChk_1
                    14409   ; prio = OSTCBCur->OSTCBPrio;
00004CFE  2079 0800 14410          move.l    _OSTCBCur.L,A0
00004D02  1020      
00004D04  1A28 0034 14411          move.b    52(A0),D5
                    14412   OSTaskStkChk_1:
                    14413   ; }
                    14414   ; ptcb = OSTCBPrioTbl[prio];
00004D08  CABC 0000 14415          and.l     #255,D5
00004D0C  00FF      
00004D0E  2005      14416          move.l    D5,D0
00004D10  E588      14417          lsl.l     #2,D0
00004D12  41F9 0800 14418          lea       _OSTCBPrioTbl.L,A0
00004D16  1030      
00004D18  2430 0800 14419          move.l    0(A0,D0.L),D2
                    14420   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00004D1C  4A82      14421          tst.l     D2
00004D1E  6608      14422          bne.s     OSTaskStkChk_3
                    14423   ; OS_EXIT_CRITICAL();
00004D20  46DF      14424          dc.w      18143
                    14425   ; return (OS_ERR_TASK_NOT_EXIST);
00004D22  7043      14426          moveq     #67,D0
00004D24  6000 005C 14427          bra       OSTaskStkChk_5
                    14428   OSTaskStkChk_3:
                    14429   ; }
                    14430   ; if (ptcb == OS_TCB_RESERVED) {
00004D28  0C82 0000 14431          cmp.l     #1,D2
00004D2C  0001      
00004D2E  6608      14432          bne.s     OSTaskStkChk_6
                    14433   ; OS_EXIT_CRITICAL();
00004D30  46DF      14434          dc.w      18143
                    14435   ; return (OS_ERR_TASK_NOT_EXIST);
00004D32  7043      14436          moveq     #67,D0
00004D34  6000 004C 14437          bra       OSTaskStkChk_5
                    14438   OSTaskStkChk_6:
                    14439   ; }
                    14440   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
00004D38  2042      14441          move.l    D2,A0
00004D3A  3028 0010 14442          move.w    16(A0),D0
00004D3E  C07C 0001 14443          and.w     #1,D0
00004D42  6608      14444          bne.s     OSTaskStkChk_8
                    14445   ; OS_EXIT_CRITICAL();
00004D44  46DF      14446          dc.w      18143
                    14447   ; return (OS_ERR_TASK_OPT);
00004D46  7045      14448          moveq     #69,D0
00004D48  6000 0038 14449          bra       OSTaskStkChk_5
                    14450   OSTaskStkChk_8:
                    14451   ; }
                    14452   ; nfree = 0u;
00004D4C  4283      14453          clr.l     D3
                    14454   ; size  = ptcb->OSTCBStkSize;
00004D4E  2042      14455          move.l    D2,A0
00004D50  2D68 000C 14456          move.l    12(A0),-4(A6)
00004D54  FFFC      
                    14457   ; pchk  = ptcb->OSTCBStkBottom;
00004D56  2042      14458          move.l    D2,A0
00004D58  2D68 0008 14459          move.l    8(A0),-8(A6)
00004D5C  FFF8      
                    14460   ; OS_EXIT_CRITICAL();
00004D5E  46DF      14461          dc.w      18143
                    14462   ; #if OS_STK_GROWTH == 1u
                    14463   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14464   OSTaskStkChk_10:
00004D60  206E FFF8 14465          move.l    -8(A6),A0
00004D64  54AE FFF8 14466          addq.l    #2,-8(A6)
00004D68  3010      14467          move.w    (A0),D0
00004D6A  6604      14468          bne.s     OSTaskStkChk_12
                    14469   ; nfree++;
00004D6C  5283      14470          addq.l    #1,D3
00004D6E  60F0      14471          bra       OSTaskStkChk_10
                    14472   OSTaskStkChk_12:
                    14473   ; }
                    14474   ; #else
                    14475   ; while (*pchk-- == (OS_STK)0) {
                    14476   ; nfree++;
                    14477   ; }
                    14478   ; #endif
                    14479   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004D70  2044      14480          move.l    D4,A0
00004D72  2083      14481          move.l    D3,(A0)
                    14482   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004D74  202E FFFC 14483          move.l    -4(A6),D0
00004D78  9083      14484          sub.l     D3,D0
00004D7A  2044      14485          move.l    D4,A0
00004D7C  2140 0004 14486          move.l    D0,4(A0)
                    14487   ; return (OS_ERR_NONE);
00004D80  4200      14488          clr.b     D0
                    14489   OSTaskStkChk_5:
00004D82  4CDF 003C 14490          movem.l   (A7)+,D2/D3/D4/D5
00004D86  4E5E      14491          unlk      A6
00004D88  4E75      14492          rts
                    14493   ; }
                    14494   ; #endif
                    14495   ; /*$PAGE*/
                    14496   ; /*
                    14497   ; *********************************************************************************************************
                    14498   ; *                                           SUSPEND A TASK
                    14499   ; *
                    14500   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14501   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14502   ; *
                    14503   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14504   ; *                       calling task will suspend itself and rescheduling will occur.
                    14505   ; *
                    14506   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14507   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14508   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14509   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14510   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14511   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14512   ; *
                    14513   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14514   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14515   ; *              running when the event arrives.
                    14516   ; *********************************************************************************************************
                    14517   ; */
                    14518   ; #if OS_TASK_SUSPEND_EN > 0u
                    14519   ; INT8U  OSTaskSuspend (INT8U prio)
                    14520   ; {
                    14521   _OSTaskSuspend:
00004D8A  4E56 0000 14522          link      A6,#0
00004D8E  48E7 3C00 14523          movem.l   D2/D3/D4/D5,-(A7)
00004D92  182E 000B 14524          move.b    11(A6),D4
00004D96  C8BC 0000 14525          and.l     #255,D4
00004D9A  00FF      
                    14526   ; BOOLEAN    self;
                    14527   ; OS_TCB    *ptcb;
                    14528   ; INT8U      y;
                    14529   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14530   ; OS_CPU_SR  cpu_sr = 0u;
                    14531   ; #endif
                    14532   ; #if OS_ARG_CHK_EN > 0u
                    14533   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14534   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14535   ; }
                    14536   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14537   ; if (prio != OS_PRIO_SELF) {
                    14538   ; return (OS_ERR_PRIO_INVALID);
                    14539   ; }
                    14540   ; }
                    14541   ; #endif
                    14542   ; OS_ENTER_CRITICAL();
00004D9C  40E7      14543          dc.w      16615
00004D9E  007C      14544          dc.w      124
00004DA0  0700      14545          dc.w      1792
                    14546   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004DA2  0C04 00FF 14547          cmp.b     #255,D4
00004DA6  660E      14548          bne.s     OSTaskSuspend_1
                    14549   ; prio = OSTCBCur->OSTCBPrio;
00004DA8  2079 0800 14550          move.l    _OSTCBCur.L,A0
00004DAC  1020      
00004DAE  1828 0034 14551          move.b    52(A0),D4
                    14552   ; self = OS_TRUE;
00004DB2  7601      14553          moveq     #1,D3
00004DB4  6012      14554          bra.s     OSTaskSuspend_4
                    14555   OSTaskSuspend_1:
                    14556   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004DB6  2079 0800 14557          move.l    _OSTCBCur.L,A0
00004DBA  1020      
00004DBC  B828 0034 14558          cmp.b     52(A0),D4
00004DC0  6604      14559          bne.s     OSTaskSuspend_3
                    14560   ; self = OS_TRUE;
00004DC2  7601      14561          moveq     #1,D3
00004DC4  6002      14562          bra.s     OSTaskSuspend_4
                    14563   OSTaskSuspend_3:
                    14564   ; } else {
                    14565   ; self = OS_FALSE;                                        /* No suspending another task          */
00004DC6  4203      14566          clr.b     D3
                    14567   OSTaskSuspend_4:
                    14568   ; }
                    14569   ; ptcb = OSTCBPrioTbl[prio];
00004DC8  C8BC 0000 14570          and.l     #255,D4
00004DCC  00FF      
00004DCE  2004      14571          move.l    D4,D0
00004DD0  E588      14572          lsl.l     #2,D0
00004DD2  41F9 0800 14573          lea       _OSTCBPrioTbl.L,A0
00004DD6  1030      
00004DD8  2430 0800 14574          move.l    0(A0,D0.L),D2
                    14575   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00004DDC  4A82      14576          tst.l     D2
00004DDE  6608      14577          bne.s     OSTaskSuspend_5
                    14578   ; OS_EXIT_CRITICAL();
00004DE0  46DF      14579          dc.w      18143
                    14580   ; return (OS_ERR_TASK_SUSPEND_PRIO);
00004DE2  7048      14581          moveq     #72,D0
00004DE4  6000 0066 14582          bra       OSTaskSuspend_7
                    14583   OSTaskSuspend_5:
                    14584   ; }
                    14585   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
00004DE8  0C82 0000 14586          cmp.l     #1,D2
00004DEC  0001      
00004DEE  6608      14587          bne.s     OSTaskSuspend_8
                    14588   ; OS_EXIT_CRITICAL();
00004DF0  46DF      14589          dc.w      18143
                    14590   ; return (OS_ERR_TASK_NOT_EXIST);
00004DF2  7043      14591          moveq     #67,D0
00004DF4  6000 0056 14592          bra       OSTaskSuspend_7
                    14593   OSTaskSuspend_8:
                    14594   ; }
                    14595   ; y            = ptcb->OSTCBY;
00004DF8  2042      14596          move.l    D2,A0
00004DFA  1A28 0036 14597          move.b    54(A0),D5
                    14598   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
00004DFE  CABC 0000 14599          and.l     #255,D5
00004E02  00FF      
00004E04  41F9 0800 14600          lea       _OSRdyTbl.L,A0
00004E08  0F10      
00004E0A  2242      14601          move.l    D2,A1
00004E0C  1029 0037 14602          move.b    55(A1),D0
00004E10  4600      14603          not.b     D0
00004E12  C130 5800 14604          and.b     D0,0(A0,D5.L)
                    14605   ; if (OSRdyTbl[y] == 0u) {
00004E16  CABC 0000 14606          and.l     #255,D5
00004E1A  00FF      
00004E1C  41F9 0800 14607          lea       _OSRdyTbl.L,A0
00004E20  0F10      
00004E22  1030 5800 14608          move.b    0(A0,D5.L),D0
00004E26  660E      14609          bne.s     OSTaskSuspend_10
                    14610   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00004E28  2042      14611          move.l    D2,A0
00004E2A  1028 0038 14612          move.b    56(A0),D0
00004E2E  4600      14613          not.b     D0
00004E30  C139 0800 14614          and.b     D0,_OSRdyGrp.L
00004E34  0F0E      
                    14615   OSTaskSuspend_10:
                    14616   ; }
                    14617   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00004E36  2042      14618          move.l    D2,A0
00004E38  0028 0008 14619          or.b      #8,50(A0)
00004E3C  0032      
                    14620   ; OS_EXIT_CRITICAL();
00004E3E  46DF      14621          dc.w      18143
                    14622   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
00004E40  0C03 0001 14623          cmp.b     #1,D3
00004E44  6604      14624          bne.s     OSTaskSuspend_12
                    14625   ; OS_Sched();                                             /* Find new highest priority task      */
00004E46  4EB8 1816 14626          jsr       _OS_Sched
                    14627   OSTaskSuspend_12:
                    14628   ; }
                    14629   ; return (OS_ERR_NONE);
00004E4A  4200      14630          clr.b     D0
                    14631   OSTaskSuspend_7:
00004E4C  4CDF 003C 14632          movem.l   (A7)+,D2/D3/D4/D5
00004E50  4E5E      14633          unlk      A6
00004E52  4E75      14634          rts
                    14635   ; }
                    14636   ; #endif
                    14637   ; /*$PAGE*/
                    14638   ; /*
                    14639   ; *********************************************************************************************************
                    14640   ; *                                            QUERY A TASK
                    14641   ; *
                    14642   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14643   ; *
                    14644   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14645   ; *
                    14646   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14647   ; *
                    14648   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14649   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14650   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14651   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14652   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14653   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14654   ; *********************************************************************************************************
                    14655   ; */
                    14656   ; #if OS_TASK_QUERY_EN > 0u
                    14657   ; INT8U  OSTaskQuery (INT8U    prio,
                    14658   ; OS_TCB  *p_task_data)
                    14659   ; {
                    14660   _OSTaskQuery:
00004E54  4E56 0000 14661          link      A6,#0
00004E58  48E7 3000 14662          movem.l   D2/D3,-(A7)
00004E5C  162E 000B 14663          move.b    11(A6),D3
00004E60  C6BC 0000 14664          and.l     #255,D3
00004E64  00FF      
                    14665   ; OS_TCB    *ptcb;
                    14666   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14667   ; OS_CPU_SR  cpu_sr = 0u;
                    14668   ; #endif
                    14669   ; #if OS_ARG_CHK_EN > 0u
                    14670   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14671   ; if (prio != OS_PRIO_SELF) {
                    14672   ; return (OS_ERR_PRIO_INVALID);
                    14673   ; }
                    14674   ; }
                    14675   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14676   ; return (OS_ERR_PDATA_NULL);
                    14677   ; }
                    14678   ; #endif
                    14679   ; OS_ENTER_CRITICAL();
00004E66  40E7      14680          dc.w      16615
00004E68  007C      14681          dc.w      124
00004E6A  0700      14682          dc.w      1792
                    14683   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00004E6C  0C03 00FF 14684          cmp.b     #255,D3
00004E70  660A      14685          bne.s     OSTaskQuery_1
                    14686   ; prio = OSTCBCur->OSTCBPrio;
00004E72  2079 0800 14687          move.l    _OSTCBCur.L,A0
00004E76  1020      
00004E78  1628 0034 14688          move.b    52(A0),D3
                    14689   OSTaskQuery_1:
                    14690   ; }
                    14691   ; ptcb = OSTCBPrioTbl[prio];
00004E7C  C6BC 0000 14692          and.l     #255,D3
00004E80  00FF      
00004E82  2003      14693          move.l    D3,D0
00004E84  E588      14694          lsl.l     #2,D0
00004E86  41F9 0800 14695          lea       _OSTCBPrioTbl.L,A0
00004E8A  1030      
00004E8C  2430 0800 14696          move.l    0(A0,D0.L),D2
                    14697   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00004E90  4A82      14698          tst.l     D2
00004E92  6606      14699          bne.s     OSTaskQuery_3
                    14700   ; OS_EXIT_CRITICAL();
00004E94  46DF      14701          dc.w      18143
                    14702   ; return (OS_ERR_PRIO);
00004E96  7029      14703          moveq     #41,D0
00004E98  6024      14704          bra.s     OSTaskQuery_5
                    14705   OSTaskQuery_3:
                    14706   ; }
                    14707   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
00004E9A  0C82 0000 14708          cmp.l     #1,D2
00004E9E  0001      
00004EA0  6606      14709          bne.s     OSTaskQuery_6
                    14710   ; OS_EXIT_CRITICAL();
00004EA2  46DF      14711          dc.w      18143
                    14712   ; return (OS_ERR_TASK_NOT_EXIST);
00004EA4  7043      14713          moveq     #67,D0
00004EA6  6016      14714          bra.s     OSTaskQuery_5
                    14715   OSTaskQuery_6:
                    14716   ; }
                    14717   ; /* Copy TCB into user storage area                    */
                    14718   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
00004EA8  4878 0056 14719          pea       86
00004EAC  2F02      14720          move.l    D2,-(A7)
00004EAE  2F2E 000C 14721          move.l    12(A6),-(A7)
00004EB2  4EB8 17EC 14722          jsr       _OS_MemCopy
00004EB6  DEFC 000C 14723          add.w     #12,A7
                    14724   ; OS_EXIT_CRITICAL();
00004EBA  46DF      14725          dc.w      18143
                    14726   ; return (OS_ERR_NONE);
00004EBC  4200      14727          clr.b     D0
                    14728   OSTaskQuery_5:
00004EBE  4CDF 000C 14729          movem.l   (A7)+,D2/D3
00004EC2  4E5E      14730          unlk      A6
00004EC4  4E75      14731          rts
                    14732   ; }
                    14733   ; #endif
                    14734   ; /*$PAGE*/
                    14735   ; /*
                    14736   ; *********************************************************************************************************
                    14737   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14738   ; *
                    14739   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14740   ; *              are application specific and can be used to store task specific values such as 'error
                    14741   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14742   ; *
                    14743   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14744   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14745   ; *
                    14746   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14747   ; *                        than OS_TASK_REG_TBL_SIZE
                    14748   ; *
                    14749   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14750   ; *
                    14751   ; *                        OS_ERR_NONE            if the call was successful
                    14752   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14753   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14754   ; *
                    14755   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14756   ; *
                    14757   ; * Note(s)    : The maximum number of task variables is 254
                    14758   ; *********************************************************************************************************
                    14759   ; */
                    14760   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14761   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14762   ; INT8U   id,
                    14763   ; INT8U  *perr)
                    14764   ; {
                    14765   _OSTaskRegGet:
00004EC6  4E56 FFFC 14766          link      A6,#-4
00004ECA  2F02      14767          move.l    D2,-(A7)
                    14768   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14769   ; OS_CPU_SR  cpu_sr = 0u;
                    14770   ; #endif
                    14771   ; INT32U     value;
                    14772   ; OS_TCB    *ptcb;
                    14773   ; #ifdef OS_SAFETY_CRITICAL
                    14774   ; if (perr == (INT8U *)0) {
                    14775   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14776   ; return (0u);
                    14777   ; }
                    14778   ; #endif
                    14779   ; #if OS_ARG_CHK_EN > 0u
                    14780   ; if (prio >= OS_LOWEST_PRIO) {
                    14781   ; if (prio != OS_PRIO_SELF) {
                    14782   ; *perr = OS_ERR_PRIO_INVALID;
                    14783   ; return (0u);
                    14784   ; }
                    14785   ; }
                    14786   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14787   ; *perr = OS_ERR_ID_INVALID;
                    14788   ; return (0u);
                    14789   ; }
                    14790   ; #endif
                    14791   ; OS_ENTER_CRITICAL();
00004ECC  40E7      14792          dc.w      16615
00004ECE  007C      14793          dc.w      124
00004ED0  0700      14794          dc.w      1792
                    14795   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004ED2  102E 000B 14796          move.b    11(A6),D0
00004ED6  0C00 00FF 14797          cmp.b     #255,D0
00004EDA  6608      14798          bne.s     OSTaskRegGet_1
                    14799   ; ptcb = OSTCBCur;
00004EDC  2439 0800 14800          move.l    _OSTCBCur.L,D2
00004EE0  1020      
00004EE2  6016      14801          bra.s     OSTaskRegGet_2
                    14802   OSTaskRegGet_1:
                    14803   ; } else {
                    14804   ; ptcb = OSTCBPrioTbl[prio];
00004EE4  102E 000B 14805          move.b    11(A6),D0
00004EE8  C0BC 0000 14806          and.l     #255,D0
00004EEC  00FF      
00004EEE  E588      14807          lsl.l     #2,D0
00004EF0  41F9 0800 14808          lea       _OSTCBPrioTbl.L,A0
00004EF4  1030      
00004EF6  2430 0800 14809          move.l    0(A0,D0.L),D2
                    14810   OSTaskRegGet_2:
                    14811   ; }
                    14812   ; value = ptcb->OSTCBRegTbl[id];
00004EFA  2042      14813          move.l    D2,A0
00004EFC  102E 000F 14814          move.b    15(A6),D0
00004F00  C0BC 0000 14815          and.l     #255,D0
00004F04  00FF      
00004F06  E588      14816          lsl.l     #2,D0
00004F08  D1C0      14817          add.l     D0,A0
00004F0A  2D68 0052 14818          move.l    82(A0),-4(A6)
00004F0E  FFFC      
                    14819   ; OS_EXIT_CRITICAL();
00004F10  46DF      14820          dc.w      18143
                    14821   ; *perr = OS_ERR_NONE;
00004F12  206E 0010 14822          move.l    16(A6),A0
00004F16  4210      14823          clr.b     (A0)
                    14824   ; return (value);
00004F18  202E FFFC 14825          move.l    -4(A6),D0
00004F1C  241F      14826          move.l    (A7)+,D2
00004F1E  4E5E      14827          unlk      A6
00004F20  4E75      14828          rts
                    14829   ; }
                    14830   ; #endif
                    14831   ; /*$PAGE*/
                    14832   ; /*
                    14833   ; ************************************************************************************************************************
                    14834   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14835   ; *
                    14836   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14837   ; *              allocated dynamically instead of statically.
                    14838   ; *
                    14839   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14840   ; *
                    14841   ; *                            OS_ERR_NONE               if the call was successful
                    14842   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14843   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14844   ; *
                    14845   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14846   ; ************************************************************************************************************************
                    14847   ; */
                    14848   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14849   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14850   ; {
                    14851   _OSTaskRegGetID:
00004F22  4E56 FFFC 14852          link      A6,#-4
                    14853   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14854   ; OS_CPU_SR  cpu_sr = 0u;
                    14855   ; #endif
                    14856   ; INT8U      id;
                    14857   ; #ifdef OS_SAFETY_CRITICAL
                    14858   ; if (perr == (INT8U *)0) {
                    14859   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14860   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14861   ; }
                    14862   ; #endif
                    14863   ; OS_ENTER_CRITICAL();
00004F26  40E7      14864          dc.w      16615
00004F28  007C      14865          dc.w      124
00004F2A  0700      14866          dc.w      1792
                    14867   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00004F2C  1039 0800 14868          move.b    _OSTaskRegNextAvailID.L,D0
00004F30  1974      
00004F32  0C00 0001 14869          cmp.b     #1,D0
00004F36  650E      14870          blo.s     OSTaskRegGetID_1
                    14871   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00004F38  206E 0008 14872          move.l    8(A6),A0
00004F3C  10BC 0096 14873          move.b    #150,(A0)
                    14874   ; OS_EXIT_CRITICAL();
00004F40  46DF      14875          dc.w      18143
                    14876   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
00004F42  7001      14877          moveq     #1,D0
00004F44  601A      14878          bra.s     OSTaskRegGetID_3
                    14879   OSTaskRegGetID_1:
                    14880   ; }
                    14881   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
00004F46  1D79 0800 14882          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00004F4A  1974 FFFF 
                    14883   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
00004F4E  5239 0800 14884          addq.b    #1,_OSTaskRegNextAvailID.L
00004F52  1974      
                    14885   ; OS_EXIT_CRITICAL();
00004F54  46DF      14886          dc.w      18143
                    14887   ; *perr = OS_ERR_NONE;
00004F56  206E 0008 14888          move.l    8(A6),A0
00004F5A  4210      14889          clr.b     (A0)
                    14890   ; return (id);
00004F5C  102E FFFF 14891          move.b    -1(A6),D0
                    14892   OSTaskRegGetID_3:
00004F60  4E5E      14893          unlk      A6
00004F62  4E75      14894          rts
                    14895   ; }
                    14896   ; #endif
                    14897   ; /*$PAGE*/
                    14898   ; /*
                    14899   ; *********************************************************************************************************
                    14900   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14901   ; *
                    14902   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14903   ; *              are application specific and can be used to store task specific values such as 'error
                    14904   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14905   ; *
                    14906   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14907   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14908   ; *
                    14909   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14910   ; *                        than OS_TASK_REG_TBL_SIZE
                    14911   ; *
                    14912   ; *              value     is the desired value for the task register.
                    14913   ; *
                    14914   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14915   ; *
                    14916   ; *                        OS_ERR_NONE            if the call was successful
                    14917   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14918   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14919   ; *
                    14920   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    14921   ; *
                    14922   ; * Note(s)    : The maximum number of task variables is 254
                    14923   ; *********************************************************************************************************
                    14924   ; */
                    14925   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14926   ; void  OSTaskRegSet (INT8U    prio,
                    14927   ; INT8U    id,
                    14928   ; INT32U   value,
                    14929   ; INT8U   *perr)
                    14930   ; {
                    14931   _OSTaskRegSet:
00004F64  4E56 0000 14932          link      A6,#0
00004F68  2F02      14933          move.l    D2,-(A7)
                    14934   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14935   ; OS_CPU_SR  cpu_sr = 0u;
                    14936   ; #endif
                    14937   ; OS_TCB    *ptcb;
                    14938   ; #ifdef OS_SAFETY_CRITICAL
                    14939   ; if (perr == (INT8U *)0) {
                    14940   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14941   ; return;
                    14942   ; }
                    14943   ; #endif
                    14944   ; #if OS_ARG_CHK_EN > 0u
                    14945   ; if (prio >= OS_LOWEST_PRIO) {
                    14946   ; if (prio != OS_PRIO_SELF) {
                    14947   ; *perr = OS_ERR_PRIO_INVALID;
                    14948   ; return;
                    14949   ; }
                    14950   ; }
                    14951   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14952   ; *perr = OS_ERR_ID_INVALID;
                    14953   ; return;
                    14954   ; }
                    14955   ; #endif
                    14956   ; OS_ENTER_CRITICAL();
00004F6A  40E7      14957          dc.w      16615
00004F6C  007C      14958          dc.w      124
00004F6E  0700      14959          dc.w      1792
                    14960   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004F70  102E 000B 14961          move.b    11(A6),D0
00004F74  0C00 00FF 14962          cmp.b     #255,D0
00004F78  6608      14963          bne.s     OSTaskRegSet_1
                    14964   ; ptcb = OSTCBCur;
00004F7A  2439 0800 14965          move.l    _OSTCBCur.L,D2
00004F7E  1020      
00004F80  6016      14966          bra.s     OSTaskRegSet_2
                    14967   OSTaskRegSet_1:
                    14968   ; } else {
                    14969   ; ptcb = OSTCBPrioTbl[prio];
00004F82  102E 000B 14970          move.b    11(A6),D0
00004F86  C0BC 0000 14971          and.l     #255,D0
00004F8A  00FF      
00004F8C  E588      14972          lsl.l     #2,D0
00004F8E  41F9 0800 14973          lea       _OSTCBPrioTbl.L,A0
00004F92  1030      
00004F94  2430 0800 14974          move.l    0(A0,D0.L),D2
                    14975   OSTaskRegSet_2:
                    14976   ; }
                    14977   ; ptcb->OSTCBRegTbl[id] = value;
00004F98  2042      14978          move.l    D2,A0
00004F9A  102E 000F 14979          move.b    15(A6),D0
00004F9E  C0BC 0000 14980          and.l     #255,D0
00004FA2  00FF      
00004FA4  E588      14981          lsl.l     #2,D0
00004FA6  D1C0      14982          add.l     D0,A0
00004FA8  216E 0010 14983          move.l    16(A6),82(A0)
00004FAC  0052      
                    14984   ; OS_EXIT_CRITICAL();
00004FAE  46DF      14985          dc.w      18143
                    14986   ; *perr                 = OS_ERR_NONE;
00004FB0  206E 0014 14987          move.l    20(A6),A0
00004FB4  4210      14988          clr.b     (A0)
00004FB6  241F      14989          move.l    (A7)+,D2
00004FB8  4E5E      14990          unlk      A6
00004FBA  4E75      14991          rts
                    14992   ; }
                    14993   ; #endif
                    14994   ; /*$PAGE*/
                    14995   ; /*
                    14996   ; *********************************************************************************************************
                    14997   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    14998   ; *
                    14999   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    15000   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    15001   ; *
                    15002   ; * Arguments  : none
                    15003   ; *
                    15004   ; * Returns    : none
                    15005   ; *
                    15006   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    15007   ; *********************************************************************************************************
                    15008   ; */
                    15009   ; void  OS_TaskReturn (void)
                    15010   ; {
                    15011   _OS_TaskReturn:
                    15012   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
00004FBC  2F39 0800 15013          move.l    _OSTCBCur.L,-(A7)
00004FC0  1020      
00004FC2  4EB8 0B0E 15014          jsr       _OSTaskReturnHook
00004FC6  584F      15015          addq.w    #4,A7
                    15016   ; #if OS_TASK_DEL_EN > 0u
                    15017   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00004FC8  4878 00FF 15018          pea       255
00004FCC  4EB8 488E 15019          jsr       _OSTaskDel
00004FD0  584F      15020          addq.w    #4,A7
00004FD2  C0BC 0000 15021          and.l     #255,D0
00004FD6  00FF      
00004FD8  4E75      15022          rts
                    15023   ; #else
                    15024   ; for (;;) {
                    15025   ; OSTimeDly(OS_TICKS_PER_SEC);
                    15026   ; }
                    15027   ; #endif
                    15028   ; }
                    15029   ; /*$PAGE*/
                    15030   ; /*
                    15031   ; *********************************************************************************************************
                    15032   ; *                                          CLEAR TASK STACK
                    15033   ; *
                    15034   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    15035   ; *
                    15036   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    15037   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    15038   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    15039   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    15040   ; *                       highest memory location of the stack and the stack will grow with increasing
                    15041   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    15042   ; *
                    15043   ; *              size     is the number of 'stack elements' to clear.
                    15044   ; *
                    15045   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    15046   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    15047   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    15048   ; *
                    15049   ; * Returns    : none
                    15050   ; *********************************************************************************************************
                    15051   ; */
                    15052   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    15053   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    15054   ; INT32U   size,
                    15055   ; INT16U   opt)
                    15056   ; {
                    15057   _OS_TaskStkClr:
00004FDA  4E56 0000 15058          link      A6,#0
                    15059   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
00004FDE  302E 0012 15060          move.w    18(A6),D0
00004FE2  C07C 0001 15061          and.w     #1,D0
00004FE6  6726      15062          beq.s     OS_TaskStkClr_7
                    15063   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
00004FE8  302E 0012 15064          move.w    18(A6),D0
00004FEC  C07C 0002 15065          and.w     #2,D0
00004FF0  671C      15066          beq.s     OS_TaskStkClr_7
                    15067   ; #if OS_STK_GROWTH == 1u
                    15068   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    15069   OS_TaskStkClr_5:
00004FF2  202E 000C 15070          move.l    12(A6),D0
00004FF6  0C80 0000 15071          cmp.l     #0,D0
00004FFA  0000      
00004FFC  6310      15072          bls.s     OS_TaskStkClr_7
                    15073   ; size--;
00004FFE  53AE 000C 15074          subq.l    #1,12(A6)
                    15075   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
00005002  206E 0008 15076          move.l    8(A6),A0
00005006  54AE 0008 15077          addq.l    #2,8(A6)
0000500A  4250      15078          clr.w     (A0)
0000500C  60E4      15079          bra       OS_TaskStkClr_5
                    15080   OS_TaskStkClr_7:
0000500E  4E5E      15081          unlk      A6
00005010  4E75      15082          rts
                    15083   ; /*
                    15084   ; *********************************************************************************************************
                    15085   ; *                                                uC/OS-II
                    15086   ; *                                          The Real-Time Kernel
                    15087   ; *                                             TIME MANAGEMENT
                    15088   ; *
                    15089   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15090   ; *                                           All Rights Reserved
                    15091   ; *
                    15092   ; * File    : OS_TIME.C
                    15093   ; * By      : Jean J. Labrosse
                    15094   ; * Version : V2.92.07
                    15095   ; *
                    15096   ; * LICENSING TERMS:
                    15097   ; * ---------------
                    15098   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15099   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15100   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15101   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15102   ; * licensing fee.
                    15103   ; *********************************************************************************************************
                    15104   ; */
                    15105   ; #define  MICRIUM_SOURCE
                    15106   ; #ifndef  OS_MASTER_FILE
                    15107   ; #include <ucos_ii.h>
                    15108   ; #endif
                    15109   ; /*
                    15110   ; *********************************************************************************************************
                    15111   ; *                                        DELAY TASK 'n' TICKS
                    15112   ; *
                    15113   ; * Description: This function is called to delay execution of the currently running task until the
                    15114   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    15115   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    15116   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    15117   ; *
                    15118   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    15119   ; *                        Note that by specifying 0, the task will not be delayed.
                    15120   ; *
                    15121   ; * Returns    : none
                    15122   ; *********************************************************************************************************
                    15123   ; */
                    15124   ; void  OSTimeDly (INT32U ticks)
                    15125   ; {
                    15126   _OSTimeDly:
00005012  4E56 0000 15127          link      A6,#0
00005016  48E7 2020 15128          movem.l   D2/A2,-(A7)
0000501A  45F9 0800 15129          lea       _OSTCBCur.L,A2
0000501E  1020      
                    15130   ; INT8U      y;
                    15131   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15132   ; OS_CPU_SR  cpu_sr = 0u;
                    15133   ; #endif
                    15134   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00005020  1039 0800 15135          move.b    _OSIntNesting.L,D0
00005024  0F06      
00005026  0C00 0000 15136          cmp.b     #0,D0
0000502A  6304      15137          bls.s     OSTimeDly_1
                    15138   ; return;
0000502C  6000 0072 15139          bra       OSTimeDly_6
                    15140   OSTimeDly_1:
                    15141   ; }
                    15142   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00005030  1039 0800 15143          move.b    _OSLockNesting.L,D0
00005034  0F08      
00005036  0C00 0000 15144          cmp.b     #0,D0
0000503A  6304      15145          bls.s     OSTimeDly_4
                    15146   ; return;
0000503C  6000 0062 15147          bra       OSTimeDly_6
                    15148   OSTimeDly_4:
                    15149   ; }
                    15150   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
00005040  202E 0008 15151          move.l    8(A6),D0
00005044  0C80 0000 15152          cmp.l     #0,D0
00005048  0000      
0000504A  6300 0054 15153          bls       OSTimeDly_6
                    15154   ; OS_ENTER_CRITICAL();
0000504E  40E7      15155          dc.w      16615
00005050  007C      15156          dc.w      124
00005052  0700      15157          dc.w      1792
                    15158   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
00005054  2052      15159          move.l    (A2),A0
00005056  1428 0036 15160          move.b    54(A0),D2
                    15161   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0000505A  C4BC 0000 15162          and.l     #255,D2
0000505E  00FF      
00005060  41F9 0800 15163          lea       _OSRdyTbl.L,A0
00005064  0F10      
00005066  2252      15164          move.l    (A2),A1
00005068  1029 0037 15165          move.b    55(A1),D0
0000506C  4600      15166          not.b     D0
0000506E  C130 2800 15167          and.b     D0,0(A0,D2.L)
                    15168   ; if (OSRdyTbl[y] == 0u) {
00005072  C4BC 0000 15169          and.l     #255,D2
00005076  00FF      
00005078  41F9 0800 15170          lea       _OSRdyTbl.L,A0
0000507C  0F10      
0000507E  1030 2800 15171          move.b    0(A0,D2.L),D0
00005082  660E      15172          bne.s     OSTimeDly_8
                    15173   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005084  2052      15174          move.l    (A2),A0
00005086  1028 0038 15175          move.b    56(A0),D0
0000508A  4600      15176          not.b     D0
0000508C  C139 0800 15177          and.b     D0,_OSRdyGrp.L
00005090  0F0E      
                    15178   OSTimeDly_8:
                    15179   ; }
                    15180   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
00005092  2052      15181          move.l    (A2),A0
00005094  216E 0008 15182          move.l    8(A6),46(A0)
00005098  002E      
                    15183   ; OS_EXIT_CRITICAL();
0000509A  46DF      15184          dc.w      18143
                    15185   ; OS_Sched();                              /* Find next task to run!                             */
0000509C  4EB8 1816 15186          jsr       _OS_Sched
                    15187   OSTimeDly_6:
000050A0  4CDF 0404 15188          movem.l   (A7)+,D2/A2
000050A4  4E5E      15189          unlk      A6
000050A6  4E75      15190          rts
                    15191   ; }
                    15192   ; }
                    15193   ; /*$PAGE*/
                    15194   ; /*
                    15195   ; *********************************************************************************************************
                    15196   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    15197   ; *
                    15198   ; * Description: This function is called to delay execution of the currently running task until some time
                    15199   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    15200   ; *              MILLISECONDS instead of ticks.
                    15201   ; *
                    15202   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    15203   ; *              minutes   specifies the number of minutes (max. 59)
                    15204   ; *              seconds   specifies the number of seconds (max. 59)
                    15205   ; *              ms        specifies the number of milliseconds (max. 999)
                    15206   ; *
                    15207   ; * Returns    : OS_ERR_NONE
                    15208   ; *              OS_ERR_TIME_INVALID_MINUTES
                    15209   ; *              OS_ERR_TIME_INVALID_SECONDS
                    15210   ; *              OS_ERR_TIME_INVALID_MS
                    15211   ; *              OS_ERR_TIME_ZERO_DLY
                    15212   ; *              OS_ERR_TIME_DLY_ISR
                    15213   ; *
                    15214   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    15215   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    15216   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    15217   ; *********************************************************************************************************
                    15218   ; */
                    15219   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    15220   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    15221   ; INT8U   minutes,
                    15222   ; INT8U   seconds,
                    15223   ; INT16U  ms)
                    15224   ; {
                    15225   _OSTimeDlyHMSM:
000050A8  4E56 FFFC 15226          link      A6,#-4
                    15227   ; INT32U ticks;
                    15228   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000050AC  1039 0800 15229          move.b    _OSIntNesting.L,D0
000050B0  0F06      
000050B2  0C00 0000 15230          cmp.b     #0,D0
000050B6  6306      15231          bls.s     OSTimeDlyHMSM_1
                    15232   ; return (OS_ERR_TIME_DLY_ISR);
000050B8  7055      15233          moveq     #85,D0
000050BA  6000 00A4 15234          bra       OSTimeDlyHMSM_3
                    15235   OSTimeDlyHMSM_1:
                    15236   ; }
                    15237   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
000050BE  1039 0800 15238          move.b    _OSLockNesting.L,D0
000050C2  0F08      
000050C4  0C00 0000 15239          cmp.b     #0,D0
000050C8  6306      15240          bls.s     OSTimeDlyHMSM_4
                    15241   ; return (OS_ERR_SCHED_LOCKED);
000050CA  7032      15242          moveq     #50,D0
000050CC  6000 0092 15243          bra       OSTimeDlyHMSM_3
                    15244   OSTimeDlyHMSM_4:
                    15245   ; }
                    15246   ; #if OS_ARG_CHK_EN > 0u
                    15247   ; if (hours == 0u) {
                    15248   ; if (minutes == 0u) {
                    15249   ; if (seconds == 0u) {
                    15250   ; if (ms == 0u) {
                    15251   ; return (OS_ERR_TIME_ZERO_DLY);
                    15252   ; }
                    15253   ; }
                    15254   ; }
                    15255   ; }
                    15256   ; if (minutes > 59u) {
                    15257   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    15258   ; }
                    15259   ; if (seconds > 59u) {
                    15260   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    15261   ; }
                    15262   ; if (ms > 999u) {
                    15263   ; return (OS_ERR_TIME_INVALID_MS);
                    15264   ; }
                    15265   ; #endif
                    15266   ; /* Compute the total number of clock ticks required.. */
                    15267   ; /* .. (rounded to the nearest tick)                   */
                    15268   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
000050D0  102E 000B 15269          move.b    11(A6),D0
000050D4  C0BC 0000 15270          and.l     #255,D0
000050D8  00FF      
000050DA  2F00      15271          move.l    D0,-(A7)
000050DC  4878 0E10 15272          pea       3600
000050E0  4EB9 0000 15273          jsr       ULMUL
000050E4  5E3A      
000050E6  2017      15274          move.l    (A7),D0
000050E8  504F      15275          addq.w    #8,A7
000050EA  122E 000F 15276          move.b    15(A6),D1
000050EE  C2BC 0000 15277          and.l     #255,D1
000050F2  00FF      
000050F4  2F01      15278          move.l    D1,-(A7)
000050F6  4878 003C 15279          pea       60
000050FA  4EB9 0000 15280          jsr       ULMUL
000050FE  5E3A      
00005100  2217      15281          move.l    (A7),D1
00005102  504F      15282          addq.w    #8,A7
00005104  D081      15283          add.l     D1,D0
00005106  122E 0013 15284          move.b    19(A6),D1
0000510A  C2BC 0000 15285          and.l     #255,D1
0000510E  00FF      
00005110  D081      15286          add.l     D1,D0
00005112  2F00      15287          move.l    D0,-(A7)
00005114  4878 0064 15288          pea       100
00005118  4EB9 0000 15289          jsr       ULMUL
0000511C  5E3A      
0000511E  2017      15290          move.l    (A7),D0
00005120  504F      15291          addq.w    #8,A7
00005122  322E 0016 15292          move.w    22(A6),D1
00005126  C2BC 0000 15293          and.l     #65535,D1
0000512A  FFFF      
0000512C  5A81      15294          addq.l    #5,D1
0000512E  2F01      15295          move.l    D1,-(A7)
00005130  4878 0064 15296          pea       100
00005134  4EB9 0000 15297          jsr       ULMUL
00005138  5E3A      
0000513A  2217      15298          move.l    (A7),D1
0000513C  504F      15299          addq.w    #8,A7
0000513E  2F01      15300          move.l    D1,-(A7)
00005140  4878 03E8 15301          pea       1000
00005144  4EB9 0000 15302          jsr       ULDIV
00005148  5EDA      
0000514A  2217      15303          move.l    (A7),D1
0000514C  504F      15304          addq.w    #8,A7
0000514E  D081      15305          add.l     D1,D0
00005150  2D40 FFFC 15306          move.l    D0,-4(A6)
                    15307   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15308   ; OSTimeDly(ticks);
00005154  2F2E FFFC 15309          move.l    -4(A6),-(A7)
00005158  4EB8 5012 15310          jsr       _OSTimeDly
0000515C  584F      15311          addq.w    #4,A7
                    15312   ; return (OS_ERR_NONE);
0000515E  4200      15313          clr.b     D0
                    15314   OSTimeDlyHMSM_3:
00005160  4E5E      15315          unlk      A6
00005162  4E75      15316          rts
                    15317   ; }
                    15318   ; #endif
                    15319   ; /*$PAGE*/
                    15320   ; /*
                    15321   ; *********************************************************************************************************
                    15322   ; *                                        RESUME A DELAYED TASK
                    15323   ; *
                    15324   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15325   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15326   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15327   ; *              like a timeout occurred.
                    15328   ; *
                    15329   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15330   ; *
                    15331   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15332   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15333   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15334   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15335   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15336   ; *********************************************************************************************************
                    15337   ; */
                    15338   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15339   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15340   ; {
                    15341   _OSTimeDlyResume:
00005164  4E56 0000 15342          link      A6,#0
00005168  2F02      15343          move.l    D2,-(A7)
                    15344   ; OS_TCB    *ptcb;
                    15345   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15346   ; OS_CPU_SR  cpu_sr = 0u;
                    15347   ; #endif
                    15348   ; if (prio >= OS_LOWEST_PRIO) {
0000516A  102E 000B 15349          move.b    11(A6),D0
0000516E  0C00 003F 15350          cmp.b     #63,D0
00005172  6506      15351          blo.s     OSTimeDlyResume_1
                    15352   ; return (OS_ERR_PRIO_INVALID);
00005174  702A      15353          moveq     #42,D0
00005176  6000 00B4 15354          bra       OSTimeDlyResume_3
                    15355   OSTimeDlyResume_1:
                    15356   ; }
                    15357   ; OS_ENTER_CRITICAL();
0000517A  40E7      15358          dc.w      16615
0000517C  007C      15359          dc.w      124
0000517E  0700      15360          dc.w      1792
                    15361   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
00005180  102E 000B 15362          move.b    11(A6),D0
00005184  C0BC 0000 15363          and.l     #255,D0
00005188  00FF      
0000518A  E588      15364          lsl.l     #2,D0
0000518C  41F9 0800 15365          lea       _OSTCBPrioTbl.L,A0
00005190  1030      
00005192  2430 0800 15366          move.l    0(A0,D0.L),D2
                    15367   ; if (ptcb == (OS_TCB *)0) {
00005196  4A82      15368          tst.l     D2
00005198  6608      15369          bne.s     OSTimeDlyResume_4
                    15370   ; OS_EXIT_CRITICAL();
0000519A  46DF      15371          dc.w      18143
                    15372   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
0000519C  7043      15373          moveq     #67,D0
0000519E  6000 008C 15374          bra       OSTimeDlyResume_3
                    15375   OSTimeDlyResume_4:
                    15376   ; }
                    15377   ; if (ptcb == OS_TCB_RESERVED) {
000051A2  0C82 0000 15378          cmp.l     #1,D2
000051A6  0001      
000051A8  6608      15379          bne.s     OSTimeDlyResume_6
                    15380   ; OS_EXIT_CRITICAL();
000051AA  46DF      15381          dc.w      18143
                    15382   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
000051AC  7043      15383          moveq     #67,D0
000051AE  6000 007C 15384          bra       OSTimeDlyResume_3
                    15385   OSTimeDlyResume_6:
                    15386   ; }
                    15387   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
000051B2  2042      15388          move.l    D2,A0
000051B4  2028 002E 15389          move.l    46(A0),D0
000051B8  6608      15390          bne.s     OSTimeDlyResume_8
                    15391   ; OS_EXIT_CRITICAL();
000051BA  46DF      15392          dc.w      18143
                    15393   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
000051BC  7050      15394          moveq     #80,D0
000051BE  6000 006C 15395          bra       OSTimeDlyResume_3
                    15396   OSTimeDlyResume_8:
                    15397   ; }
                    15398   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
000051C2  2042      15399          move.l    D2,A0
000051C4  42A8 002E 15400          clr.l     46(A0)
                    15401   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000051C8  2042      15402          move.l    D2,A0
000051CA  1028 0032 15403          move.b    50(A0),D0
000051CE  C03C 0037 15404          and.b     #55,D0
000051D2  6712      15405          beq.s     OSTimeDlyResume_10
                    15406   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
000051D4  2042      15407          move.l    D2,A0
000051D6  0228 00C8 15408          and.b     #-56,50(A0)
000051DA  0032      
                    15409   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
000051DC  2042      15410          move.l    D2,A0
000051DE  117C 0001 15411          move.b    #1,51(A0)
000051E2  0033      
000051E4  6006      15412          bra.s     OSTimeDlyResume_11
                    15413   OSTimeDlyResume_10:
                    15414   ; } else {
                    15415   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
000051E6  2042      15416          move.l    D2,A0
000051E8  4228 0033 15417          clr.b     51(A0)
                    15418   OSTimeDlyResume_11:
                    15419   ; }
                    15420   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
000051EC  2042      15421          move.l    D2,A0
000051EE  1028 0032 15422          move.b    50(A0),D0
000051F2  C03C 0008 15423          and.b     #8,D0
000051F6  6630      15424          bne.s     OSTimeDlyResume_12
                    15425   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
000051F8  2042      15426          move.l    D2,A0
000051FA  1028 0038 15427          move.b    56(A0),D0
000051FE  8139 0800 15428          or.b      D0,_OSRdyGrp.L
00005202  0F0E      
                    15429   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00005204  2042      15430          move.l    D2,A0
00005206  1028 0036 15431          move.b    54(A0),D0
0000520A  C0BC 0000 15432          and.l     #255,D0
0000520E  00FF      
00005210  41F9 0800 15433          lea       _OSRdyTbl.L,A0
00005214  0F10      
00005216  2242      15434          move.l    D2,A1
00005218  1229 0037 15435          move.b    55(A1),D1
0000521C  8330 0800 15436          or.b      D1,0(A0,D0.L)
                    15437   ; OS_EXIT_CRITICAL();
00005220  46DF      15438          dc.w      18143
                    15439   ; OS_Sched();                                            /* See if this is new highest priority  */
00005222  4EB8 1816 15440          jsr       _OS_Sched
00005226  6002      15441          bra.s     OSTimeDlyResume_13
                    15442   OSTimeDlyResume_12:
                    15443   ; } else {
                    15444   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
00005228  46DF      15445          dc.w      18143
                    15446   OSTimeDlyResume_13:
                    15447   ; }
                    15448   ; return (OS_ERR_NONE);
0000522A  4200      15449          clr.b     D0
                    15450   OSTimeDlyResume_3:
0000522C  241F      15451          move.l    (A7)+,D2
0000522E  4E5E      15452          unlk      A6
00005230  4E75      15453          rts
                    15454   ; }
                    15455   ; #endif
                    15456   ; /*$PAGE*/
                    15457   ; /*
                    15458   ; *********************************************************************************************************
                    15459   ; *                                       GET CURRENT SYSTEM TIME
                    15460   ; *
                    15461   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15462   ; *              counter which keeps track of the number of clock ticks.
                    15463   ; *
                    15464   ; * Arguments  : none
                    15465   ; *
                    15466   ; * Returns    : The current value of OSTime
                    15467   ; *********************************************************************************************************
                    15468   ; */
                    15469   ; #if OS_TIME_GET_SET_EN > 0u
                    15470   ; INT32U  OSTimeGet (void)
                    15471   ; {
                    15472   _OSTimeGet:
00005232  4E56 FFFC 15473          link      A6,#-4
                    15474   ; INT32U     ticks;
                    15475   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15476   ; OS_CPU_SR  cpu_sr = 0u;
                    15477   ; #endif
                    15478   ; OS_ENTER_CRITICAL();
00005236  40E7      15479          dc.w      16615
00005238  007C      15480          dc.w      124
0000523A  0700      15481          dc.w      1792
                    15482   ; ticks = OSTime;
0000523C  2D79 0800 15483          move.l    _OSTime.L,-4(A6)
00005240  1976 FFFC 
                    15484   ; OS_EXIT_CRITICAL();
00005244  46DF      15485          dc.w      18143
                    15486   ; return (ticks);
00005246  202E FFFC 15487          move.l    -4(A6),D0
0000524A  4E5E      15488          unlk      A6
0000524C  4E75      15489          rts
                    15490   ; }
                    15491   ; #endif
                    15492   ; /*
                    15493   ; *********************************************************************************************************
                    15494   ; *                                          SET SYSTEM CLOCK
                    15495   ; *
                    15496   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15497   ; *
                    15498   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15499   ; *
                    15500   ; * Returns    : none
                    15501   ; *********************************************************************************************************
                    15502   ; */
                    15503   ; #if OS_TIME_GET_SET_EN > 0u
                    15504   ; void  OSTimeSet (INT32U ticks)
                    15505   ; {
                    15506   _OSTimeSet:
0000524E  4E56 0000 15507          link      A6,#0
                    15508   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15509   ; OS_CPU_SR  cpu_sr = 0u;
                    15510   ; #endif
                    15511   ; OS_ENTER_CRITICAL();
00005252  40E7      15512          dc.w      16615
00005254  007C      15513          dc.w      124
00005256  0700      15514          dc.w      1792
                    15515   ; OSTime = ticks;
00005258  23EE 0008 15516          move.l    8(A6),_OSTime.L
0000525C  0800 1976 
                    15517   ; OS_EXIT_CRITICAL();
00005260  46DF      15518          dc.w      18143
00005262  4E5E      15519          unlk      A6
00005264  4E75      15520          rts
                    15521   ; /*
                    15522   ; *********************************************************************************************************
                    15523   ; *                                                uC/OS-II
                    15524   ; *                                          The Real-Time Kernel
                    15525   ; *                                            TIMER MANAGEMENT
                    15526   ; *
                    15527   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15528   ; *                                           All Rights Reserved
                    15529   ; *
                    15530   ; *
                    15531   ; * File    : OS_TMR.C
                    15532   ; * By      : Jean J. Labrosse
                    15533   ; * Version : V2.92.07
                    15534   ; *
                    15535   ; * LICENSING TERMS:
                    15536   ; * ---------------
                    15537   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15538   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15539   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15540   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15541   ; * licensing fee.
                    15542   ; *********************************************************************************************************
                    15543   ; */
                    15544   ; #define  MICRIUM_SOURCE
                    15545   ; #ifndef  OS_MASTER_FILE
                    15546   ; #include <ucos_ii.h>
                    15547   ; #endif
                    15548   ; /*
                    15549   ; *********************************************************************************************************
                    15550   ; *                                                        NOTES
                    15551   ; *
                    15552   ; * 1) Your application MUST define the following #define constants:
                    15553   ; *
                    15554   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15555   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15556   ; *
                    15557   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15558   ; *********************************************************************************************************
                    15559   ; */
                    15560   ; /*
                    15561   ; *********************************************************************************************************
                    15562   ; *                                              CONSTANTS
                    15563   ; *********************************************************************************************************
                    15564   ; */
                    15565   ; #define  OS_TMR_LINK_DLY       0u
                    15566   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15567   ; /*
                    15568   ; *********************************************************************************************************
                    15569   ; *                                          LOCAL PROTOTYPES
                    15570   ; *********************************************************************************************************
                    15571   ; */
                    15572   ; #if OS_TMR_EN > 0u
                    15573   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15574   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15575   ; static  void     OSTmr_InitTask      (void);
                    15576   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15577   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15578   ; static  void     OSTmr_Task          (void   *p_arg);
                    15579   ; #endif
                    15580   ; /*$PAGE*/
                    15581   ; /*
                    15582   ; *********************************************************************************************************
                    15583   ; *                                           CREATE A TIMER
                    15584   ; *
                    15585   ; * Description: This function is called by your application code to create a timer.
                    15586   ; *
                    15587   ; * Arguments  : dly           Initial delay.
                    15588   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15589   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15590   ; *                               wait for before the timer starts entering periodic mode.
                    15591   ; *
                    15592   ; *              period        The 'period' being repeated for the timer.
                    15593   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15594   ; *                               expires, it will automatically restart with the same period.
                    15595   ; *
                    15596   ; *              opt           Specifies either:
                    15597   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15598   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15599   ; *
                    15600   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15601   ; *                               The callback function must be declared as follows:
                    15602   ; *
                    15603   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15604   ; *
                    15605   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15606   ; *
                    15607   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15608   ; *                               useful for debugging.
                    15609   ; *
                    15610   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15611   ; *                               OS_ERR_NONE
                    15612   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15613   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15614   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15615   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15616   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15617   ; *
                    15618   ; * Returns    : A pointer to an OS_TMR data structure.
                    15619   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15620   ; *********************************************************************************************************
                    15621   ; */
                    15622   ; #if OS_TMR_EN > 0u
                    15623   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15624   ; INT32U           period,
                    15625   ; INT8U            opt,
                    15626   ; OS_TMR_CALLBACK  callback,
                    15627   ; void            *callback_arg,
                    15628   ; INT8U           *pname,
                    15629   ; INT8U           *perr)
                    15630   ; {
                    15631   _OSTmrCreate:
00005266  4E56 0000 15632          link      A6,#0
0000526A  48E7 3000 15633          movem.l   D2/D3,-(A7)
0000526E  262E 0020 15634          move.l    32(A6),D3
                    15635   ; OS_TMR   *ptmr;
                    15636   ; #ifdef OS_SAFETY_CRITICAL
                    15637   ; if (perr == (INT8U *)0) {
                    15638   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15639   ; return ((OS_TMR *)0);
                    15640   ; }
                    15641   ; #endif
                    15642   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15643   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15644   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15645   ; return ((OS_TMR *)0);
                    15646   ; }
                    15647   ; #endif
                    15648   ; #if OS_ARG_CHK_EN > 0u
                    15649   ; switch (opt) {                                          /* Validate arguments                                     */
                    15650   ; case OS_TMR_OPT_PERIODIC:
                    15651   ; if (period == 0u) {
                    15652   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15653   ; return ((OS_TMR *)0);
                    15654   ; }
                    15655   ; break;
                    15656   ; case OS_TMR_OPT_ONE_SHOT:
                    15657   ; if (dly == 0u) {
                    15658   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15659   ; return ((OS_TMR *)0);
                    15660   ; }
                    15661   ; break;
                    15662   ; default:
                    15663   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15664   ; return ((OS_TMR *)0);
                    15665   ; }
                    15666   ; #endif
                    15667   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005272  1039 0800 15668          move.b    _OSIntNesting.L,D0
00005276  0F06      
00005278  0C00 0000 15669          cmp.b     #0,D0
0000527C  630C      15670          bls.s     OSTmrCreate_1
                    15671   ; *perr  = OS_ERR_TMR_ISR;
0000527E  2043      15672          move.l    D3,A0
00005280  10BC 008B 15673          move.b    #139,(A0)
                    15674   ; return ((OS_TMR *)0);
00005284  4280      15675          clr.l     D0
00005286  6000 0078 15676          bra       OSTmrCreate_3
                    15677   OSTmrCreate_1:
                    15678   ; }
                    15679   ; OSSchedLock();
0000528A  4EB8 1066 15680          jsr       _OSSchedLock
                    15681   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
0000528E  4EB9 0000 15682          jsr       @ucos_ii_OSTmr_Alloc
00005292  57FE      
00005294  2400      15683          move.l    D0,D2
                    15684   ; if (ptmr == (OS_TMR *)0) {
00005296  4A82      15685          tst.l     D2
00005298  6610      15686          bne.s     OSTmrCreate_4
                    15687   ; OSSchedUnlock();
0000529A  4EB8 1096 15688          jsr       _OSSchedUnlock
                    15689   ; *perr = OS_ERR_TMR_NON_AVAIL;
0000529E  2043      15690          move.l    D3,A0
000052A0  10BC 0086 15691          move.b    #134,(A0)
                    15692   ; return ((OS_TMR *)0);
000052A4  4280      15693          clr.l     D0
000052A6  6000 0058 15694          bra       OSTmrCreate_3
                    15695   OSTmrCreate_4:
                    15696   ; }
                    15697   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
000052AA  2042      15698          move.l    D2,A0
000052AC  117C 0001 15699          move.b    #1,35(A0)
000052B0  0023      
                    15700   ; ptmr->OSTmrDly         = dly;
000052B2  2042      15701          move.l    D2,A0
000052B4  216E 0008 15702          move.l    8(A6),22(A0)
000052B8  0016      
                    15703   ; ptmr->OSTmrPeriod      = period;
000052BA  2042      15704          move.l    D2,A0
000052BC  216E 000C 15705          move.l    12(A6),26(A0)
000052C0  001A      
                    15706   ; ptmr->OSTmrOpt         = opt;
000052C2  2042      15707          move.l    D2,A0
000052C4  116E 0013 15708          move.b    19(A6),34(A0)
000052C8  0022      
                    15709   ; ptmr->OSTmrCallback    = callback;
000052CA  2042      15710          move.l    D2,A0
000052CC  216E 0014 15711          move.l    20(A6),2(A0)
000052D0  0002      
                    15712   ; ptmr->OSTmrCallbackArg = callback_arg;
000052D2  2042      15713          move.l    D2,A0
000052D4  216E 0018 15714          move.l    24(A6),6(A0)
000052D8  0006      
                    15715   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15716   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
000052DA  202E 001C 15717          move.l    28(A6),D0
000052DE  660E      15718          bne.s     OSTmrCreate_6
                    15719   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
000052E0  41F9 0000 15720          lea       @ucos_ii_1.L,A0
000052E4  68A4      
000052E6  2242      15721          move.l    D2,A1
000052E8  2348 001E 15722          move.l    A0,30(A1)
000052EC  6008      15723          bra.s     OSTmrCreate_7
                    15724   OSTmrCreate_6:
                    15725   ; } else {
                    15726   ; ptmr->OSTmrName    = pname;
000052EE  2042      15727          move.l    D2,A0
000052F0  216E 001C 15728          move.l    28(A6),30(A0)
000052F4  001E      
                    15729   OSTmrCreate_7:
                    15730   ; }
                    15731   ; #endif
                    15732   ; OSSchedUnlock();
000052F6  4EB8 1096 15733          jsr       _OSSchedUnlock
                    15734   ; *perr = OS_ERR_NONE;
000052FA  2043      15735          move.l    D3,A0
000052FC  4210      15736          clr.b     (A0)
                    15737   ; return (ptmr);
000052FE  2002      15738          move.l    D2,D0
                    15739   OSTmrCreate_3:
00005300  4CDF 000C 15740          movem.l   (A7)+,D2/D3
00005304  4E5E      15741          unlk      A6
00005306  4E75      15742          rts
                    15743   ; }
                    15744   ; #endif
                    15745   ; /*$PAGE*/
                    15746   ; /*
                    15747   ; *********************************************************************************************************
                    15748   ; *                                           DELETE A TIMER
                    15749   ; *
                    15750   ; * Description: This function is called by your application code to delete a timer.
                    15751   ; *
                    15752   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15753   ; *
                    15754   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15755   ; *                               OS_ERR_NONE
                    15756   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15757   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15758   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15759   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15760   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15761   ; *
                    15762   ; * Returns    : OS_TRUE       If the call was successful
                    15763   ; *              OS_FALSE      If not
                    15764   ; *********************************************************************************************************
                    15765   ; */
                    15766   ; #if OS_TMR_EN > 0u
                    15767   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15768   ; INT8U   *perr)
                    15769   ; {
                    15770   _OSTmrDel:
00005308  4E56 0000 15771          link      A6,#0
0000530C  48E7 3020 15772          movem.l   D2/D3/A2,-(A7)
00005310  242E 000C 15773          move.l    12(A6),D2
00005314  262E 0008 15774          move.l    8(A6),D3
00005318  45F8 1096 15775          lea       _OSSchedUnlock.L,A2
                    15776   ; #ifdef OS_SAFETY_CRITICAL
                    15777   ; if (perr == (INT8U *)0) {
                    15778   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15779   ; return (OS_FALSE);
                    15780   ; }
                    15781   ; #endif
                    15782   ; #if OS_ARG_CHK_EN > 0u
                    15783   ; if (ptmr == (OS_TMR *)0) {
                    15784   ; *perr = OS_ERR_TMR_INVALID;
                    15785   ; return (OS_FALSE);
                    15786   ; }
                    15787   ; #endif
                    15788   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
0000531C  2043      15789          move.l    D3,A0
0000531E  1010      15790          move.b    (A0),D0
00005320  0C00 0064 15791          cmp.b     #100,D0
00005324  670C      15792          beq.s     OSTmrDel_1
                    15793   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005326  2042      15794          move.l    D2,A0
00005328  10BC 0089 15795          move.b    #137,(A0)
                    15796   ; return (OS_FALSE);
0000532C  4200      15797          clr.b     D0
0000532E  6000 0090 15798          bra       OSTmrDel_3
                    15799   OSTmrDel_1:
                    15800   ; }
                    15801   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005332  1039 0800 15802          move.b    _OSIntNesting.L,D0
00005336  0F06      
00005338  0C00 0000 15803          cmp.b     #0,D0
0000533C  630C      15804          bls.s     OSTmrDel_4
                    15805   ; *perr  = OS_ERR_TMR_ISR;
0000533E  2042      15806          move.l    D2,A0
00005340  10BC 008B 15807          move.b    #139,(A0)
                    15808   ; return (OS_FALSE);
00005344  4200      15809          clr.b     D0
00005346  6000 0078 15810          bra       OSTmrDel_3
                    15811   OSTmrDel_4:
                    15812   ; }
                    15813   ; OSSchedLock();
0000534A  4EB8 1066 15814          jsr       _OSSchedLock
                    15815   ; switch (ptmr->OSTmrState) {
0000534E  2043      15816          move.l    D3,A0
00005350  1028 0023 15817          move.b    35(A0),D0
00005354  C0BC 0000 15818          and.l     #255,D0
00005358  00FF      
0000535A  0C80 0000 15819          cmp.l     #4,D0
0000535E  0004      
00005360  6400 0054 15820          bhs       OSTmrDel_6
00005364  E380      15821          asl.l     #1,D0
00005366  303B 0806 15822          move.w    OSTmrDel_8(PC,D0.L),D0
0000536A  4EFB 0002 15823          jmp       OSTmrDel_8(PC,D0.W)
                    15824   OSTmrDel_8:
0000536E  003C      15825          dc.w      OSTmrDel_12-OSTmrDel_8
00005370  0028      15826          dc.w      OSTmrDel_10-OSTmrDel_8
00005372  0028      15827          dc.w      OSTmrDel_10-OSTmrDel_8
00005374  0008      15828          dc.w      OSTmrDel_9-OSTmrDel_8
                    15829   OSTmrDel_9:
                    15830   ; case OS_TMR_STATE_RUNNING:
                    15831   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
00005376  2F03      15832          move.l    D3,-(A7)
00005378  4EB9 0000 15833          jsr       @ucos_ii_OSTmr_Unlink
0000537C  5AF4      
0000537E  584F      15834          addq.w    #4,A7
                    15835   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005380  2F03      15836          move.l    D3,-(A7)
00005382  4EB9 0000 15837          jsr       @ucos_ii_OSTmr_Free
00005386  5838      
00005388  584F      15838          addq.w    #4,A7
                    15839   ; OSSchedUnlock();
0000538A  4E92      15840          jsr       (A2)
                    15841   ; *perr = OS_ERR_NONE;
0000538C  2042      15842          move.l    D2,A0
0000538E  4210      15843          clr.b     (A0)
                    15844   ; return (OS_TRUE);
00005390  7001      15845          moveq     #1,D0
00005392  6000 002C 15846          bra       OSTmrDel_3
                    15847   OSTmrDel_10:
                    15848   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15849   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15850   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005396  2F03      15851          move.l    D3,-(A7)
00005398  4EB9 0000 15852          jsr       @ucos_ii_OSTmr_Free
0000539C  5838      
0000539E  584F      15853          addq.w    #4,A7
                    15854   ; OSSchedUnlock();
000053A0  4E92      15855          jsr       (A2)
                    15856   ; *perr = OS_ERR_NONE;
000053A2  2042      15857          move.l    D2,A0
000053A4  4210      15858          clr.b     (A0)
                    15859   ; return (OS_TRUE);
000053A6  7001      15860          moveq     #1,D0
000053A8  6016      15861          bra.s     OSTmrDel_3
                    15862   OSTmrDel_12:
                    15863   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15864   ; OSSchedUnlock();
000053AA  4E92      15865          jsr       (A2)
                    15866   ; *perr = OS_ERR_TMR_INACTIVE;
000053AC  2042      15867          move.l    D2,A0
000053AE  10BC 0087 15868          move.b    #135,(A0)
                    15869   ; return (OS_FALSE);
000053B2  4200      15870          clr.b     D0
000053B4  600A      15871          bra.s     OSTmrDel_3
                    15872   OSTmrDel_6:
                    15873   ; default:
                    15874   ; OSSchedUnlock();
000053B6  4E92      15875          jsr       (A2)
                    15876   ; *perr = OS_ERR_TMR_INVALID_STATE;
000053B8  2042      15877          move.l    D2,A0
000053BA  10BC 008D 15878          move.b    #141,(A0)
                    15879   ; return (OS_FALSE);
000053BE  4200      15880          clr.b     D0
                    15881   OSTmrDel_3:
000053C0  4CDF 040C 15882          movem.l   (A7)+,D2/D3/A2
000053C4  4E5E      15883          unlk      A6
000053C6  4E75      15884          rts
                    15885   ; }
                    15886   ; }
                    15887   ; #endif
                    15888   ; /*$PAGE*/
                    15889   ; /*
                    15890   ; *********************************************************************************************************
                    15891   ; *                                       GET THE NAME OF A TIMER
                    15892   ; *
                    15893   ; * Description: This function is called to obtain the name of a timer.
                    15894   ; *
                    15895   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15896   ; *
                    15897   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15898   ; *
                    15899   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15900   ; *                               OS_ERR_NONE               The call was successful
                    15901   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15902   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15903   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15904   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15905   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15906   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15907   ; *
                    15908   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15909   ; *********************************************************************************************************
                    15910   ; */
                    15911   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15912   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15913   ; INT8U   **pdest,
                    15914   ; INT8U    *perr)
                    15915   ; {
                    15916   _OSTmrNameGet:
000053C8  4E56 FFFC 15917          link      A6,#-4
000053CC  48E7 3020 15918          movem.l   D2/D3/A2,-(A7)
000053D0  242E 0010 15919          move.l    16(A6),D2
000053D4  45F8 1096 15920          lea       _OSSchedUnlock.L,A2
000053D8  262E 0008 15921          move.l    8(A6),D3
                    15922   ; INT8U  len;
                    15923   ; #ifdef OS_SAFETY_CRITICAL
                    15924   ; if (perr == (INT8U *)0) {
                    15925   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15926   ; return (0u);
                    15927   ; }
                    15928   ; #endif
                    15929   ; #if OS_ARG_CHK_EN > 0u
                    15930   ; if (pdest == (INT8U **)0) {
                    15931   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    15932   ; return (0u);
                    15933   ; }
                    15934   ; if (ptmr == (OS_TMR *)0) {
                    15935   ; *perr = OS_ERR_TMR_INVALID;
                    15936   ; return (0u);
                    15937   ; }
                    15938   ; #endif
                    15939   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000053DC  2043      15940          move.l    D3,A0
000053DE  1010      15941          move.b    (A0),D0
000053E0  0C00 0064 15942          cmp.b     #100,D0
000053E4  670C      15943          beq.s     OSTmrNameGet_1
                    15944   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000053E6  2042      15945          move.l    D2,A0
000053E8  10BC 0089 15946          move.b    #137,(A0)
                    15947   ; return (0u);
000053EC  4200      15948          clr.b     D0
000053EE  6000 0082 15949          bra       OSTmrNameGet_3
                    15950   OSTmrNameGet_1:
                    15951   ; }
                    15952   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000053F2  1039 0800 15953          move.b    _OSIntNesting.L,D0
000053F6  0F06      
000053F8  0C00 0000 15954          cmp.b     #0,D0
000053FC  630C      15955          bls.s     OSTmrNameGet_4
                    15956   ; *perr = OS_ERR_NAME_GET_ISR;
000053FE  2042      15957          move.l    D2,A0
00005400  10BC 0011 15958          move.b    #17,(A0)
                    15959   ; return (0u);
00005404  4200      15960          clr.b     D0
00005406  6000 006A 15961          bra       OSTmrNameGet_3
                    15962   OSTmrNameGet_4:
                    15963   ; }
                    15964   ; OSSchedLock();
0000540A  4EB8 1066 15965          jsr       _OSSchedLock
                    15966   ; switch (ptmr->OSTmrState) {
0000540E  2043      15967          move.l    D3,A0
00005410  1028 0023 15968          move.b    35(A0),D0
00005414  C0BC 0000 15969          and.l     #255,D0
00005418  00FF      
0000541A  0C80 0000 15970          cmp.l     #4,D0
0000541E  0004      
00005420  6400 0046 15971          bhs       OSTmrNameGet_6
00005424  E380      15972          asl.l     #1,D0
00005426  303B 0806 15973          move.w    OSTmrNameGet_8(PC,D0.L),D0
0000542A  4EFB 0002 15974          jmp       OSTmrNameGet_8(PC,D0.W)
                    15975   OSTmrNameGet_8:
0000542E  002E      15976          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
00005430  0008      15977          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
00005432  0008      15978          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
00005434  0008      15979          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    15980   OSTmrNameGet_9:
                    15981   ; case OS_TMR_STATE_RUNNING:
                    15982   ; case OS_TMR_STATE_STOPPED:
                    15983   ; case OS_TMR_STATE_COMPLETED:
                    15984   ; *pdest = ptmr->OSTmrName;
00005436  2043      15985          move.l    D3,A0
00005438  226E 000C 15986          move.l    12(A6),A1
0000543C  22A8 001E 15987          move.l    30(A0),(A1)
                    15988   ; len    = OS_StrLen(*pdest);
00005440  206E 000C 15989          move.l    12(A6),A0
00005444  2F10      15990          move.l    (A0),-(A7)
00005446  4EB8 18C0 15991          jsr       _OS_StrLen
0000544A  584F      15992          addq.w    #4,A7
0000544C  1D40 FFFF 15993          move.b    D0,-1(A6)
                    15994   ; OSSchedUnlock();
00005450  4E92      15995          jsr       (A2)
                    15996   ; *perr = OS_ERR_NONE;
00005452  2042      15997          move.l    D2,A0
00005454  4210      15998          clr.b     (A0)
                    15999   ; return (len);
00005456  102E FFFF 16000          move.b    -1(A6),D0
0000545A  6016      16001          bra.s     OSTmrNameGet_3
                    16002   OSTmrNameGet_12:
                    16003   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    16004   ; OSSchedUnlock();
0000545C  4E92      16005          jsr       (A2)
                    16006   ; *perr = OS_ERR_TMR_INACTIVE;
0000545E  2042      16007          move.l    D2,A0
00005460  10BC 0087 16008          move.b    #135,(A0)
                    16009   ; return (0u);
00005464  4200      16010          clr.b     D0
00005466  600A      16011          bra.s     OSTmrNameGet_3
                    16012   OSTmrNameGet_6:
                    16013   ; default:
                    16014   ; OSSchedUnlock();
00005468  4E92      16015          jsr       (A2)
                    16016   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000546A  2042      16017          move.l    D2,A0
0000546C  10BC 008D 16018          move.b    #141,(A0)
                    16019   ; return (0u);
00005470  4200      16020          clr.b     D0
                    16021   OSTmrNameGet_3:
00005472  4CDF 040C 16022          movem.l   (A7)+,D2/D3/A2
00005476  4E5E      16023          unlk      A6
00005478  4E75      16024          rts
                    16025   ; }
                    16026   ; }
                    16027   ; #endif
                    16028   ; /*$PAGE*/
                    16029   ; /*
                    16030   ; *********************************************************************************************************
                    16031   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    16032   ; *
                    16033   ; * Description: This function is called to get the number of ticks before a timer times out.
                    16034   ; *
                    16035   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    16036   ; *
                    16037   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16038   ; *                               OS_ERR_NONE
                    16039   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16040   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16041   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16042   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16043   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    16044   ; *
                    16045   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    16046   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    16047   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    16048   ; *********************************************************************************************************
                    16049   ; */
                    16050   ; #if OS_TMR_EN > 0u
                    16051   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    16052   ; INT8U   *perr)
                    16053   ; {
                    16054   _OSTmrRemainGet:
0000547A  4E56 0000 16055          link      A6,#0
0000547E  48E7 3820 16056          movem.l   D2/D3/D4/A2,-(A7)
00005482  242E 000C 16057          move.l    12(A6),D2
00005486  262E 0008 16058          move.l    8(A6),D3
0000548A  45F8 1096 16059          lea       _OSSchedUnlock.L,A2
                    16060   ; INT32U  remain;
                    16061   ; #ifdef OS_SAFETY_CRITICAL
                    16062   ; if (perr == (INT8U *)0) {
                    16063   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16064   ; return (0u);
                    16065   ; }
                    16066   ; #endif
                    16067   ; #if OS_ARG_CHK_EN > 0u
                    16068   ; if (ptmr == (OS_TMR *)0) {
                    16069   ; *perr = OS_ERR_TMR_INVALID;
                    16070   ; return (0u);
                    16071   ; }
                    16072   ; #endif
                    16073   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
0000548E  2043      16074          move.l    D3,A0
00005490  1010      16075          move.b    (A0),D0
00005492  0C00 0064 16076          cmp.b     #100,D0
00005496  670C      16077          beq.s     OSTmrRemainGet_1
                    16078   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005498  2042      16079          move.l    D2,A0
0000549A  10BC 0089 16080          move.b    #137,(A0)
                    16081   ; return (0u);
0000549E  4280      16082          clr.l     D0
000054A0  6000 00CE 16083          bra       OSTmrRemainGet_3
                    16084   OSTmrRemainGet_1:
                    16085   ; }
                    16086   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000054A4  1039 0800 16087          move.b    _OSIntNesting.L,D0
000054A8  0F06      
000054AA  0C00 0000 16088          cmp.b     #0,D0
000054AE  630C      16089          bls.s     OSTmrRemainGet_4
                    16090   ; *perr = OS_ERR_TMR_ISR;
000054B0  2042      16091          move.l    D2,A0
000054B2  10BC 008B 16092          move.b    #139,(A0)
                    16093   ; return (0u);
000054B6  4280      16094          clr.l     D0
000054B8  6000 00B6 16095          bra       OSTmrRemainGet_3
                    16096   OSTmrRemainGet_4:
                    16097   ; }
                    16098   ; OSSchedLock();
000054BC  4EB8 1066 16099          jsr       _OSSchedLock
                    16100   ; switch (ptmr->OSTmrState) {
000054C0  2043      16101          move.l    D3,A0
000054C2  1028 0023 16102          move.b    35(A0),D0
000054C6  C0BC 0000 16103          and.l     #255,D0
000054CA  00FF      
000054CC  0C80 0000 16104          cmp.l     #4,D0
000054D0  0004      
000054D2  6400 0092 16105          bhs       OSTmrRemainGet_6
000054D6  E380      16106          asl.l     #1,D0
000054D8  303B 0806 16107          move.w    OSTmrRemainGet_8(PC,D0.L),D0
000054DC  4EFB 0002 16108          jmp       OSTmrRemainGet_8(PC,D0.W)
                    16109   OSTmrRemainGet_8:
000054E0  007A      16110          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
000054E2  0022      16111          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
000054E4  0070      16112          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
000054E6  0008      16113          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    16114   OSTmrRemainGet_9:
                    16115   ; case OS_TMR_STATE_RUNNING:
                    16116   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
000054E8  2043      16117          move.l    D3,A0
000054EA  2028 0012 16118          move.l    18(A0),D0
000054EE  90B9 0800 16119          sub.l     _OSTmrTime.L,D0
000054F2  197E      
000054F4  2800      16120          move.l    D0,D4
                    16121   ; OSSchedUnlock();
000054F6  4E92      16122          jsr       (A2)
                    16123   ; *perr  = OS_ERR_NONE;
000054F8  2042      16124          move.l    D2,A0
000054FA  4210      16125          clr.b     (A0)
                    16126   ; return (remain);
000054FC  2004      16127          move.l    D4,D0
000054FE  6000 0070 16128          bra       OSTmrRemainGet_3
                    16129   OSTmrRemainGet_10:
                    16130   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    16131   ; switch (ptmr->OSTmrOpt) {
00005502  2043      16132          move.l    D3,A0
00005504  1028 0022 16133          move.b    34(A0),D0
00005508  C0BC 0000 16134          and.l     #255,D0
0000550C  00FF      
0000550E  0C80 0000 16135          cmp.l     #2,D0
00005512  0002      
00005514  670C      16136          beq.s     OSTmrRemainGet_16
00005516  6228      16137          bhi.s     OSTmrRemainGet_17
00005518  0C80 0000 16138          cmp.l     #1,D0
0000551C  0001      
0000551E  6720      16139          beq.s     OSTmrRemainGet_17
00005520  601E      16140          bra.s     OSTmrRemainGet_17
                    16141   OSTmrRemainGet_16:
                    16142   ; case OS_TMR_OPT_PERIODIC:
                    16143   ; if (ptmr->OSTmrDly == 0u) {
00005522  2043      16144          move.l    D3,A0
00005524  2028 0016 16145          move.l    22(A0),D0
00005528  6608      16146          bne.s     OSTmrRemainGet_19
                    16147   ; remain = ptmr->OSTmrPeriod;
0000552A  2043      16148          move.l    D3,A0
0000552C  2828 001A 16149          move.l    26(A0),D4
00005530  6006      16150          bra.s     OSTmrRemainGet_20
                    16151   OSTmrRemainGet_19:
                    16152   ; } else {
                    16153   ; remain = ptmr->OSTmrDly;
00005532  2043      16154          move.l    D3,A0
00005534  2828 0016 16155          move.l    22(A0),D4
                    16156   OSTmrRemainGet_20:
                    16157   ; }
                    16158   ; OSSchedUnlock();
00005538  4E92      16159          jsr       (A2)
                    16160   ; *perr  = OS_ERR_NONE;
0000553A  2042      16161          move.l    D2,A0
0000553C  4210      16162          clr.b     (A0)
                    16163   ; break;
0000553E  600C      16164          bra.s     OSTmrRemainGet_15
                    16165   OSTmrRemainGet_17:
                    16166   ; case OS_TMR_OPT_ONE_SHOT:
                    16167   ; default:
                    16168   ; remain = ptmr->OSTmrDly;
00005540  2043      16169          move.l    D3,A0
00005542  2828 0016 16170          move.l    22(A0),D4
                    16171   ; OSSchedUnlock();
00005546  4E92      16172          jsr       (A2)
                    16173   ; *perr  = OS_ERR_NONE;
00005548  2042      16174          move.l    D2,A0
0000554A  4210      16175          clr.b     (A0)
                    16176   ; break;
                    16177   OSTmrRemainGet_15:
                    16178   ; }
                    16179   ; return (remain);
0000554C  2004      16180          move.l    D4,D0
0000554E  6020      16181          bra.s     OSTmrRemainGet_3
                    16182   OSTmrRemainGet_11:
                    16183   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    16184   ; OSSchedUnlock();
00005550  4E92      16185          jsr       (A2)
                    16186   ; *perr = OS_ERR_NONE;
00005552  2042      16187          move.l    D2,A0
00005554  4210      16188          clr.b     (A0)
                    16189   ; return (0u);
00005556  4280      16190          clr.l     D0
00005558  6016      16191          bra.s     OSTmrRemainGet_3
                    16192   OSTmrRemainGet_12:
                    16193   ; case OS_TMR_STATE_UNUSED:
                    16194   ; OSSchedUnlock();
0000555A  4E92      16195          jsr       (A2)
                    16196   ; *perr = OS_ERR_TMR_INACTIVE;
0000555C  2042      16197          move.l    D2,A0
0000555E  10BC 0087 16198          move.b    #135,(A0)
                    16199   ; return (0u);
00005562  4280      16200          clr.l     D0
00005564  600A      16201          bra.s     OSTmrRemainGet_3
                    16202   OSTmrRemainGet_6:
                    16203   ; default:
                    16204   ; OSSchedUnlock();
00005566  4E92      16205          jsr       (A2)
                    16206   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005568  2042      16207          move.l    D2,A0
0000556A  10BC 008D 16208          move.b    #141,(A0)
                    16209   ; return (0u);
0000556E  4280      16210          clr.l     D0
                    16211   OSTmrRemainGet_3:
00005570  4CDF 041C 16212          movem.l   (A7)+,D2/D3/D4/A2
00005574  4E5E      16213          unlk      A6
00005576  4E75      16214          rts
                    16215   ; }
                    16216   ; }
                    16217   ; #endif
                    16218   ; /*$PAGE*/
                    16219   ; /*
                    16220   ; *********************************************************************************************************
                    16221   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    16222   ; *
                    16223   ; * Description: This function is called to determine what state the timer is in:
                    16224   ; *
                    16225   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    16226   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    16227   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    16228   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    16229   ; *
                    16230   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    16231   ; *
                    16232   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16233   ; *                               OS_ERR_NONE
                    16234   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16235   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16236   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16237   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16238   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    16239   ; *
                    16240   ; * Returns    : The current state of the timer (see description).
                    16241   ; *********************************************************************************************************
                    16242   ; */
                    16243   ; #if OS_TMR_EN > 0u
                    16244   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    16245   ; INT8U   *perr)
                    16246   ; {
                    16247   _OSTmrStateGet:
00005578  4E56 0000 16248          link      A6,#0
0000557C  48E7 3000 16249          movem.l   D2/D3,-(A7)
00005580  242E 000C 16250          move.l    12(A6),D2
                    16251   ; INT8U  state;
                    16252   ; #ifdef OS_SAFETY_CRITICAL
                    16253   ; if (perr == (INT8U *)0) {
                    16254   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16255   ; return (0u);
                    16256   ; }
                    16257   ; #endif
                    16258   ; #if OS_ARG_CHK_EN > 0u
                    16259   ; if (ptmr == (OS_TMR *)0) {
                    16260   ; *perr = OS_ERR_TMR_INVALID;
                    16261   ; return (0u);
                    16262   ; }
                    16263   ; #endif
                    16264   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005584  206E 0008 16265          move.l    8(A6),A0
00005588  1010      16266          move.b    (A0),D0
0000558A  0C00 0064 16267          cmp.b     #100,D0
0000558E  670C      16268          beq.s     OSTmrStateGet_1
                    16269   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005590  2042      16270          move.l    D2,A0
00005592  10BC 0089 16271          move.b    #137,(A0)
                    16272   ; return (0u);
00005596  4200      16273          clr.b     D0
00005598  6000 005A 16274          bra       OSTmrStateGet_3
                    16275   OSTmrStateGet_1:
                    16276   ; }
                    16277   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
0000559C  1039 0800 16278          move.b    _OSIntNesting.L,D0
000055A0  0F06      
000055A2  0C00 0000 16279          cmp.b     #0,D0
000055A6  630C      16280          bls.s     OSTmrStateGet_4
                    16281   ; *perr = OS_ERR_TMR_ISR;
000055A8  2042      16282          move.l    D2,A0
000055AA  10BC 008B 16283          move.b    #139,(A0)
                    16284   ; return (0u);
000055AE  4200      16285          clr.b     D0
000055B0  6000 0042 16286          bra       OSTmrStateGet_3
                    16287   OSTmrStateGet_4:
                    16288   ; }
                    16289   ; OSSchedLock();
000055B4  4EB8 1066 16290          jsr       _OSSchedLock
                    16291   ; state = ptmr->OSTmrState;
000055B8  206E 0008 16292          move.l    8(A6),A0
000055BC  1628 0023 16293          move.b    35(A0),D3
                    16294   ; switch (state) {
000055C0  C6BC 0000 16295          and.l     #255,D3
000055C4  00FF      
000055C6  2003      16296          move.l    D3,D0
000055C8  0C80 0000 16297          cmp.l     #4,D0
000055CC  0004      
000055CE  6418      16298          bhs.s     OSTmrStateGet_6
000055D0  E380      16299          asl.l     #1,D0
000055D2  303B 0806 16300          move.w    OSTmrStateGet_8(PC,D0.L),D0
000055D6  4EFB 0002 16301          jmp       OSTmrStateGet_8(PC,D0.W)
                    16302   OSTmrStateGet_8:
000055DA  0008      16303          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000055DC  0008      16304          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000055DE  0008      16305          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000055E0  0008      16306          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16307   OSTmrStateGet_9:
                    16308   ; case OS_TMR_STATE_UNUSED:
                    16309   ; case OS_TMR_STATE_STOPPED:
                    16310   ; case OS_TMR_STATE_COMPLETED:
                    16311   ; case OS_TMR_STATE_RUNNING:
                    16312   ; *perr = OS_ERR_NONE;
000055E2  2042      16313          move.l    D2,A0
000055E4  4210      16314          clr.b     (A0)
                    16315   ; break;
000055E6  6006      16316          bra.s     OSTmrStateGet_7
                    16317   OSTmrStateGet_6:
                    16318   ; default:
                    16319   ; *perr = OS_ERR_TMR_INVALID_STATE;
000055E8  2042      16320          move.l    D2,A0
000055EA  10BC 008D 16321          move.b    #141,(A0)
                    16322   ; break;
                    16323   OSTmrStateGet_7:
                    16324   ; }
                    16325   ; OSSchedUnlock();
000055EE  4EB8 1096 16326          jsr       _OSSchedUnlock
                    16327   ; return (state);
000055F2  1003      16328          move.b    D3,D0
                    16329   OSTmrStateGet_3:
000055F4  4CDF 000C 16330          movem.l   (A7)+,D2/D3
000055F8  4E5E      16331          unlk      A6
000055FA  4E75      16332          rts
                    16333   ; }
                    16334   ; #endif
                    16335   ; /*$PAGE*/
                    16336   ; /*
                    16337   ; *********************************************************************************************************
                    16338   ; *                                            START A TIMER
                    16339   ; *
                    16340   ; * Description: This function is called by your application code to start a timer.
                    16341   ; *
                    16342   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16343   ; *
                    16344   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16345   ; *                               OS_ERR_NONE
                    16346   ; *                               OS_ERR_TMR_INVALID
                    16347   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16348   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16349   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16350   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16351   ; *
                    16352   ; * Returns    : OS_TRUE    if the timer was started
                    16353   ; *              OS_FALSE   if an error was detected
                    16354   ; *********************************************************************************************************
                    16355   ; */
                    16356   ; #if OS_TMR_EN > 0u
                    16357   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16358   ; INT8U    *perr)
                    16359   ; {
                    16360   _OSTmrStart:
000055FC  4E56 0000 16361          link      A6,#0
00005600  48E7 3020 16362          movem.l   D2/D3/A2,-(A7)
00005604  242E 000C 16363          move.l    12(A6),D2
00005608  262E 0008 16364          move.l    8(A6),D3
0000560C  45F8 1096 16365          lea       _OSSchedUnlock.L,A2
                    16366   ; #ifdef OS_SAFETY_CRITICAL
                    16367   ; if (perr == (INT8U *)0) {
                    16368   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16369   ; return (OS_FALSE);
                    16370   ; }
                    16371   ; #endif
                    16372   ; #if OS_ARG_CHK_EN > 0u
                    16373   ; if (ptmr == (OS_TMR *)0) {
                    16374   ; *perr = OS_ERR_TMR_INVALID;
                    16375   ; return (OS_FALSE);
                    16376   ; }
                    16377   ; #endif
                    16378   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00005610  2043      16379          move.l    D3,A0
00005612  1010      16380          move.b    (A0),D0
00005614  0C00 0064 16381          cmp.b     #100,D0
00005618  670C      16382          beq.s     OSTmrStart_1
                    16383   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000561A  2042      16384          move.l    D2,A0
0000561C  10BC 0089 16385          move.b    #137,(A0)
                    16386   ; return (OS_FALSE);
00005620  4200      16387          clr.b     D0
00005622  6000 0094 16388          bra       OSTmrStart_3
                    16389   OSTmrStart_1:
                    16390   ; }
                    16391   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005626  1039 0800 16392          move.b    _OSIntNesting.L,D0
0000562A  0F06      
0000562C  0C00 0000 16393          cmp.b     #0,D0
00005630  630C      16394          bls.s     OSTmrStart_4
                    16395   ; *perr  = OS_ERR_TMR_ISR;
00005632  2042      16396          move.l    D2,A0
00005634  10BC 008B 16397          move.b    #139,(A0)
                    16398   ; return (OS_FALSE);
00005638  4200      16399          clr.b     D0
0000563A  6000 007C 16400          bra       OSTmrStart_3
                    16401   OSTmrStart_4:
                    16402   ; }
                    16403   ; OSSchedLock();
0000563E  4EB8 1066 16404          jsr       _OSSchedLock
                    16405   ; switch (ptmr->OSTmrState) {
00005642  2043      16406          move.l    D3,A0
00005644  1028 0023 16407          move.b    35(A0),D0
00005648  C0BC 0000 16408          and.l     #255,D0
0000564C  00FF      
0000564E  0C80 0000 16409          cmp.l     #4,D0
00005652  0004      
00005654  6400 0058 16410          bhs       OSTmrStart_6
00005658  E380      16411          asl.l     #1,D0
0000565A  303B 0806 16412          move.w    OSTmrStart_8(PC,D0.L),D0
0000565E  4EFB 0002 16413          jmp       OSTmrStart_8(PC,D0.W)
                    16414   OSTmrStart_8:
00005662  0040      16415          dc.w      OSTmrStart_12-OSTmrStart_8
00005664  002A      16416          dc.w      OSTmrStart_10-OSTmrStart_8
00005666  002A      16417          dc.w      OSTmrStart_10-OSTmrStart_8
00005668  0008      16418          dc.w      OSTmrStart_9-OSTmrStart_8
                    16419   OSTmrStart_9:
                    16420   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16421   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
0000566A  2F03      16422          move.l    D3,-(A7)
0000566C  4EB9 0000 16423          jsr       @ucos_ii_OSTmr_Unlink
00005670  5AF4      
00005672  584F      16424          addq.w    #4,A7
                    16425   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005674  42A7      16426          clr.l     -(A7)
00005676  2F03      16427          move.l    D3,-(A7)
00005678  4EB9 0000 16428          jsr       @ucos_ii_OSTmr_Link
0000567C  5A20      
0000567E  504F      16429          addq.w    #8,A7
                    16430   ; OSSchedUnlock();
00005680  4E92      16431          jsr       (A2)
                    16432   ; *perr = OS_ERR_NONE;
00005682  2042      16433          move.l    D2,A0
00005684  4210      16434          clr.b     (A0)
                    16435   ; return (OS_TRUE);
00005686  7001      16436          moveq     #1,D0
00005688  6000 002E 16437          bra       OSTmrStart_3
                    16438   OSTmrStart_10:
                    16439   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16440   ; case OS_TMR_STATE_COMPLETED:
                    16441   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
0000568C  42A7      16442          clr.l     -(A7)
0000568E  2F03      16443          move.l    D3,-(A7)
00005690  4EB9 0000 16444          jsr       @ucos_ii_OSTmr_Link
00005694  5A20      
00005696  504F      16445          addq.w    #8,A7
                    16446   ; OSSchedUnlock();
00005698  4E92      16447          jsr       (A2)
                    16448   ; *perr = OS_ERR_NONE;
0000569A  2042      16449          move.l    D2,A0
0000569C  4210      16450          clr.b     (A0)
                    16451   ; return (OS_TRUE);
0000569E  7001      16452          moveq     #1,D0
000056A0  6016      16453          bra.s     OSTmrStart_3
                    16454   OSTmrStart_12:
                    16455   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16456   ; OSSchedUnlock();
000056A2  4E92      16457          jsr       (A2)
                    16458   ; *perr = OS_ERR_TMR_INACTIVE;
000056A4  2042      16459          move.l    D2,A0
000056A6  10BC 0087 16460          move.b    #135,(A0)
                    16461   ; return (OS_FALSE);
000056AA  4200      16462          clr.b     D0
000056AC  600A      16463          bra.s     OSTmrStart_3
                    16464   OSTmrStart_6:
                    16465   ; default:
                    16466   ; OSSchedUnlock();
000056AE  4E92      16467          jsr       (A2)
                    16468   ; *perr = OS_ERR_TMR_INVALID_STATE;
000056B0  2042      16469          move.l    D2,A0
000056B2  10BC 008D 16470          move.b    #141,(A0)
                    16471   ; return (OS_FALSE);
000056B6  4200      16472          clr.b     D0
                    16473   OSTmrStart_3:
000056B8  4CDF 040C 16474          movem.l   (A7)+,D2/D3/A2
000056BC  4E5E      16475          unlk      A6
000056BE  4E75      16476          rts
                    16477   ; }
                    16478   ; }
                    16479   ; #endif
                    16480   ; /*$PAGE*/
                    16481   ; /*
                    16482   ; *********************************************************************************************************
                    16483   ; *                                            STOP A TIMER
                    16484   ; *
                    16485   ; * Description: This function is called by your application code to stop a timer.
                    16486   ; *
                    16487   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16488   ; *
                    16489   ; *              opt           Allows you to specify an option to this functions which can be:
                    16490   ; *
                    16491   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16492   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16493   ; *                                                        callback argument specified when the timer 
                    16494   ; *                                                        was created.
                    16495   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16496   ; *                                                        callback argument specified in THIS function call.
                    16497   ; *
                    16498   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16499   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16500   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16501   ; *
                    16502   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16503   ; *                               OS_ERR_NONE
                    16504   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16505   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16506   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16507   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16508   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16509   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16510   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16511   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16512   ; *
                    16513   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16514   ; *              OS_FALSE      If not
                    16515   ; *********************************************************************************************************
                    16516   ; */
                    16517   ; #if OS_TMR_EN > 0u
                    16518   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16519   ; INT8U    opt,
                    16520   ; void    *callback_arg,
                    16521   ; INT8U   *perr)
                    16522   ; {
                    16523   _OSTmrStop:
000056C0  4E56 0000 16524          link      A6,#0
000056C4  48E7 3820 16525          movem.l   D2/D3/D4/A2,-(A7)
000056C8  242E 0014 16526          move.l    20(A6),D2
000056CC  262E 0008 16527          move.l    8(A6),D3
000056D0  45F8 1096 16528          lea       _OSSchedUnlock.L,A2
                    16529   ; OS_TMR_CALLBACK  pfnct;
                    16530   ; #ifdef OS_SAFETY_CRITICAL
                    16531   ; if (perr == (INT8U *)0) {
                    16532   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16533   ; return (OS_FALSE);
                    16534   ; }
                    16535   ; #endif
                    16536   ; #if OS_ARG_CHK_EN > 0u
                    16537   ; if (ptmr == (OS_TMR *)0) {
                    16538   ; *perr = OS_ERR_TMR_INVALID;
                    16539   ; return (OS_FALSE);
                    16540   ; }
                    16541   ; #endif
                    16542   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
000056D4  2043      16543          move.l    D3,A0
000056D6  1010      16544          move.b    (A0),D0
000056D8  0C00 0064 16545          cmp.b     #100,D0
000056DC  670C      16546          beq.s     OSTmrStop_1
                    16547   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000056DE  2042      16548          move.l    D2,A0
000056E0  10BC 0089 16549          move.b    #137,(A0)
                    16550   ; return (OS_FALSE);
000056E4  4200      16551          clr.b     D0
000056E6  6000 00F2 16552          bra       OSTmrStop_3
                    16553   OSTmrStop_1:
                    16554   ; }
                    16555   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
000056EA  1039 0800 16556          move.b    _OSIntNesting.L,D0
000056EE  0F06      
000056F0  0C00 0000 16557          cmp.b     #0,D0
000056F4  630C      16558          bls.s     OSTmrStop_4
                    16559   ; *perr  = OS_ERR_TMR_ISR;
000056F6  2042      16560          move.l    D2,A0
000056F8  10BC 008B 16561          move.b    #139,(A0)
                    16562   ; return (OS_FALSE);
000056FC  4200      16563          clr.b     D0
000056FE  6000 00DA 16564          bra       OSTmrStop_3
                    16565   OSTmrStop_4:
                    16566   ; }
                    16567   ; OSSchedLock();
00005702  4EB8 1066 16568          jsr       _OSSchedLock
                    16569   ; switch (ptmr->OSTmrState) {
00005706  2043      16570          move.l    D3,A0
00005708  1028 0023 16571          move.b    35(A0),D0
0000570C  C0BC 0000 16572          and.l     #255,D0
00005710  00FF      
00005712  0C80 0000 16573          cmp.l     #4,D0
00005716  0004      
00005718  6400 00B6 16574          bhs       OSTmrStop_6
0000571C  E380      16575          asl.l     #1,D0
0000571E  303B 0806 16576          move.w    OSTmrStop_8(PC,D0.L),D0
00005722  4EFB 0002 16577          jmp       OSTmrStop_8(PC,D0.W)
                    16578   OSTmrStop_8:
00005726  009E      16579          dc.w      OSTmrStop_12-OSTmrStop_8
00005728  0092      16580          dc.w      OSTmrStop_10-OSTmrStop_8
0000572A  0092      16581          dc.w      OSTmrStop_10-OSTmrStop_8
0000572C  0008      16582          dc.w      OSTmrStop_9-OSTmrStop_8
                    16583   OSTmrStop_9:
                    16584   ; case OS_TMR_STATE_RUNNING:
                    16585   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
0000572E  2F03      16586          move.l    D3,-(A7)
00005730  4EB9 0000 16587          jsr       @ucos_ii_OSTmr_Unlink
00005734  5AF4      
00005736  584F      16588          addq.w    #4,A7
                    16589   ; *perr = OS_ERR_NONE;
00005738  2042      16590          move.l    D2,A0
0000573A  4210      16591          clr.b     (A0)
                    16592   ; switch (opt) {
0000573C  102E 000F 16593          move.b    15(A6),D0
00005740  C0BC 0000 16594          and.l     #255,D0
00005744  00FF      
00005746  0C80 0000 16595          cmp.l     #3,D0
0000574A  0003      
0000574C  6718      16596          beq.s     OSTmrStop_16
0000574E  620A      16597          bhi.s     OSTmrStop_20
00005750  4A80      16598          tst.l     D0
00005752  6700 0056 16599          beq       OSTmrStop_18
00005756  6000 0054 16600          bra       OSTmrStop_14
                    16601   OSTmrStop_20:
0000575A  0C80 0000 16602          cmp.l     #4,D0
0000575E  0004      
00005760  6728      16603          beq.s     OSTmrStop_17
00005762  6000 0048 16604          bra       OSTmrStop_14
                    16605   OSTmrStop_16:
                    16606   ; case OS_TMR_OPT_CALLBACK:
                    16607   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005766  2043      16608          move.l    D3,A0
00005768  2828 0002 16609          move.l    2(A0),D4
                    16610   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0000576C  4A84      16611          tst.l     D4
0000576E  6710      16612          beq.s     OSTmrStop_21
                    16613   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
00005770  2043      16614          move.l    D3,A0
00005772  2F28 0006 16615          move.l    6(A0),-(A7)
00005776  2F03      16616          move.l    D3,-(A7)
00005778  2044      16617          move.l    D4,A0
0000577A  4E90      16618          jsr       (A0)
0000577C  504F      16619          addq.w    #8,A7
0000577E  6006      16620          bra.s     OSTmrStop_22
                    16621   OSTmrStop_21:
                    16622   ; } else {
                    16623   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005780  2042      16624          move.l    D2,A0
00005782  10BC 008F 16625          move.b    #143,(A0)
                    16626   OSTmrStop_22:
                    16627   ; }
                    16628   ; break;
00005786  6000 002A 16629          bra       OSTmrStop_15
                    16630   OSTmrStop_17:
                    16631   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16632   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000578A  2043      16633          move.l    D3,A0
0000578C  2828 0002 16634          move.l    2(A0),D4
                    16635   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005790  4A84      16636          tst.l     D4
00005792  670E      16637          beq.s     OSTmrStop_23
                    16638   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
00005794  2F2E 0010 16639          move.l    16(A6),-(A7)
00005798  2F03      16640          move.l    D3,-(A7)
0000579A  2044      16641          move.l    D4,A0
0000579C  4E90      16642          jsr       (A0)
0000579E  504F      16643          addq.w    #8,A7
000057A0  6006      16644          bra.s     OSTmrStop_24
                    16645   OSTmrStop_23:
                    16646   ; } else {
                    16647   ; *perr = OS_ERR_TMR_NO_CALLBACK;
000057A2  2042      16648          move.l    D2,A0
000057A4  10BC 008F 16649          move.b    #143,(A0)
                    16650   OSTmrStop_24:
                    16651   ; }
                    16652   ; break;
000057A8  6008      16653          bra.s     OSTmrStop_15
                    16654   OSTmrStop_18:
                    16655   ; case OS_TMR_OPT_NONE:
                    16656   ; break;
000057AA  6006      16657          bra.s     OSTmrStop_15
                    16658   OSTmrStop_14:
                    16659   ; default:
                    16660   ; *perr = OS_ERR_TMR_INVALID_OPT;
000057AC  2042      16661          move.l    D2,A0
000057AE  10BC 0084 16662          move.b    #132,(A0)
                    16663   ; break;
                    16664   OSTmrStop_15:
                    16665   ; }
                    16666   ; OSSchedUnlock();
000057B2  4E92      16667          jsr       (A2)
                    16668   ; return (OS_TRUE);
000057B4  7001      16669          moveq     #1,D0
000057B6  6022      16670          bra.s     OSTmrStop_3
                    16671   OSTmrStop_10:
                    16672   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16673   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16674   ; OSSchedUnlock();
000057B8  4E92      16675          jsr       (A2)
                    16676   ; *perr = OS_ERR_TMR_STOPPED;
000057BA  2042      16677          move.l    D2,A0
000057BC  10BC 008E 16678          move.b    #142,(A0)
                    16679   ; return (OS_TRUE);
000057C0  7001      16680          moveq     #1,D0
000057C2  6016      16681          bra.s     OSTmrStop_3
                    16682   OSTmrStop_12:
                    16683   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16684   ; OSSchedUnlock();
000057C4  4E92      16685          jsr       (A2)
                    16686   ; *perr = OS_ERR_TMR_INACTIVE;
000057C6  2042      16687          move.l    D2,A0
000057C8  10BC 0087 16688          move.b    #135,(A0)
                    16689   ; return (OS_FALSE);
000057CC  4200      16690          clr.b     D0
000057CE  600A      16691          bra.s     OSTmrStop_3
                    16692   OSTmrStop_6:
                    16693   ; default:
                    16694   ; OSSchedUnlock();
000057D0  4E92      16695          jsr       (A2)
                    16696   ; *perr = OS_ERR_TMR_INVALID_STATE;
000057D2  2042      16697          move.l    D2,A0
000057D4  10BC 008D 16698          move.b    #141,(A0)
                    16699   ; return (OS_FALSE);
000057D8  4200      16700          clr.b     D0
                    16701   OSTmrStop_3:
000057DA  4CDF 041C 16702          movem.l   (A7)+,D2/D3/D4/A2
000057DE  4E5E      16703          unlk      A6
000057E0  4E75      16704          rts
                    16705   ; }
                    16706   ; }
                    16707   ; #endif
                    16708   ; /*$PAGE*/
                    16709   ; /*
                    16710   ; *********************************************************************************************************
                    16711   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16712   ; *
                    16713   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16714   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16715   ; *
                    16716   ; * Arguments  : none
                    16717   ; *
                    16718   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16719   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16720   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16721   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16722   ; *                                  signaling is created by uC/OS-II.
                    16723   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16724   ; *                                  used for signaling is created by uC/OS-II.
                    16725   ; *********************************************************************************************************
                    16726   ; */
                    16727   ; #if OS_TMR_EN > 0u
                    16728   ; INT8U  OSTmrSignal (void)
                    16729   ; {
                    16730   _OSTmrSignal:
000057E2  4E56 FFFC 16731          link      A6,#-4
                    16732   ; INT8U  err;
                    16733   ; err = OSSemPost(OSTmrSemSignal);
000057E6  2F39 0800 16734          move.l    _OSTmrSemSignal.L,-(A7)
000057EA  1986      
000057EC  4EB8 4352 16735          jsr       _OSSemPost
000057F0  584F      16736          addq.w    #4,A7
000057F2  1D40 FFFF 16737          move.b    D0,-1(A6)
                    16738   ; return (err);
000057F6  102E FFFF 16739          move.b    -1(A6),D0
000057FA  4E5E      16740          unlk      A6
000057FC  4E75      16741          rts
                    16742   ; }
                    16743   ; #endif
                    16744   ; /*$PAGE*/
                    16745   ; /*
                    16746   ; *********************************************************************************************************
                    16747   ; *                                      ALLOCATE AND FREE A TIMER
                    16748   ; *
                    16749   ; * Description: This function is called to allocate a timer.
                    16750   ; *
                    16751   ; * Arguments  : none
                    16752   ; *
                    16753   ; * Returns    : a pointer to a timer if one is available
                    16754   ; *********************************************************************************************************
                    16755   ; */
                    16756   ; #if OS_TMR_EN > 0u
                    16757   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16758   ; {
                    16759   @ucos_ii_OSTmr_Alloc:
000057FE  48E7 2020 16760          movem.l   D2/A2,-(A7)
00005802  45F9 0800 16761          lea       _OSTmrFreeList.L,A2
00005806  1BCA      
                    16762   ; OS_TMR *ptmr;
                    16763   ; if (OSTmrFreeList == (OS_TMR *)0) {
00005808  2012      16764          move.l    (A2),D0
0000580A  6604      16765          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16766   ; return ((OS_TMR *)0);
0000580C  4280      16767          clr.l     D0
0000580E  6022      16768          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16769   @ucos_ii_OSTmr_Alloc_1:
                    16770   ; }
                    16771   ; ptmr            = (OS_TMR *)OSTmrFreeList;
00005810  2412      16772          move.l    (A2),D2
                    16773   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
00005812  2042      16774          move.l    D2,A0
00005814  24A8 000A 16775          move.l    10(A0),(A2)
                    16776   ; ptmr->OSTmrNext = (OS_TCB *)0;
00005818  2042      16777          move.l    D2,A0
0000581A  42A8 000A 16778          clr.l     10(A0)
                    16779   ; ptmr->OSTmrPrev = (OS_TCB *)0;
0000581E  2042      16780          move.l    D2,A0
00005820  42A8 000E 16781          clr.l     14(A0)
                    16782   ; OSTmrUsed++;
00005824  5279 0800 16783          addq.w    #1,_OSTmrUsed.L
00005828  197C      
                    16784   ; OSTmrFree--;
0000582A  5379 0800 16785          subq.w    #1,_OSTmrFree.L
0000582E  197A      
                    16786   ; return (ptmr);
00005830  2002      16787          move.l    D2,D0
                    16788   @ucos_ii_OSTmr_Alloc_3:
00005832  4CDF 0404 16789          movem.l   (A7)+,D2/A2
00005836  4E75      16790          rts
                    16791   ; }
                    16792   ; #endif
                    16793   ; /*
                    16794   ; *********************************************************************************************************
                    16795   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16796   ; *
                    16797   ; * Description: This function is called to return a timer object to the free list of timers.
                    16798   ; *
                    16799   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16800   ; *
                    16801   ; * Returns    : none
                    16802   ; *********************************************************************************************************
                    16803   ; */
                    16804   ; #if OS_TMR_EN > 0u
                    16805   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16806   ; {
                    16807   @ucos_ii_OSTmr_Free:
00005838  4E56 0000 16808          link      A6,#0
0000583C  2F02      16809          move.l    D2,-(A7)
0000583E  242E 0008 16810          move.l    8(A6),D2
                    16811   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
00005842  2042      16812          move.l    D2,A0
00005844  4228 0023 16813          clr.b     35(A0)
                    16814   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
00005848  2042      16815          move.l    D2,A0
0000584A  4228 0022 16816          clr.b     34(A0)
                    16817   ; ptmr->OSTmrPeriod      = 0u;
0000584E  2042      16818          move.l    D2,A0
00005850  42A8 001A 16819          clr.l     26(A0)
                    16820   ; ptmr->OSTmrMatch       = 0u;
00005854  2042      16821          move.l    D2,A0
00005856  42A8 0012 16822          clr.l     18(A0)
                    16823   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
0000585A  2042      16824          move.l    D2,A0
0000585C  42A8 0002 16825          clr.l     2(A0)
                    16826   ; ptmr->OSTmrCallbackArg = (void *)0;
00005860  2042      16827          move.l    D2,A0
00005862  42A8 0006 16828          clr.l     6(A0)
                    16829   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16830   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
00005866  41F9 0000 16831          lea       @ucos_ii_1.L,A0
0000586A  68A4      
0000586C  2242      16832          move.l    D2,A1
0000586E  2348 001E 16833          move.l    A0,30(A1)
                    16834   ; #endif
                    16835   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00005872  2042      16836          move.l    D2,A0
00005874  42A8 000E 16837          clr.l     14(A0)
                    16838   ; ptmr->OSTmrNext        = OSTmrFreeList;
00005878  2042      16839          move.l    D2,A0
0000587A  2179 0800 16840          move.l    _OSTmrFreeList.L,10(A0)
0000587E  1BCA 000A 
                    16841   ; OSTmrFreeList          = ptmr;
00005882  23C2 0800 16842          move.l    D2,_OSTmrFreeList.L
00005886  1BCA      
                    16843   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
00005888  5379 0800 16844          subq.w    #1,_OSTmrUsed.L
0000588C  197C      
                    16845   ; OSTmrFree++;
0000588E  5279 0800 16846          addq.w    #1,_OSTmrFree.L
00005892  197A      
00005894  241F      16847          move.l    (A7)+,D2
00005896  4E5E      16848          unlk      A6
00005898  4E75      16849          rts
                    16850   ; }
                    16851   ; #endif
                    16852   ; /*$PAGE*/
                    16853   ; /*
                    16854   ; *********************************************************************************************************
                    16855   ; *                                                    INITIALIZATION
                    16856   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16857   ; *
                    16858   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16859   ; *
                    16860   ; * Arguments  : none
                    16861   ; *
                    16862   ; * Returns    : none
                    16863   ; *********************************************************************************************************
                    16864   ; */
                    16865   ; #if OS_TMR_EN > 0u
                    16866   ; void  OSTmr_Init (void)
                    16867   ; {
                    16868   _OSTmr_Init:
0000589A  4E56 FFF8 16869          link      A6,#-8
0000589E  48E7 3020 16870          movem.l   D2/D3/A2,-(A7)
000058A2  45F9 0800 16871          lea       _OSTmrTbl.L,A2
000058A6  198A      
                    16872   ; #if OS_EVENT_NAME_EN > 0u
                    16873   ; INT8U    err;
                    16874   ; #endif
                    16875   ; INT16U   ix;
                    16876   ; INT16U   ix_next;
                    16877   ; OS_TMR  *ptmr1;
                    16878   ; OS_TMR  *ptmr2;
                    16879   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
000058A8  4878 0240 16880          pea       576
000058AC  2F0A      16881          move.l    A2,-(A7)
000058AE  4EB8 17CA 16882          jsr       _OS_MemClr
000058B2  504F      16883          addq.w    #8,A7
                    16884   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
000058B4  4878 0020 16885          pea       32
000058B8  4879 0800 16886          pea       _OSTmrWheelTbl.L
000058BC  1CCE      
000058BE  4EB8 17CA 16887          jsr       _OS_MemClr
000058C2  504F      16888          addq.w    #8,A7
                    16889   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
000058C4  4243      16890          clr.w     D3
                    16891   OSTmr_Init_1:
000058C6  0C43 000F 16892          cmp.w     #15,D3
000058CA  6400 0056 16893          bhs       OSTmr_Init_3
                    16894   ; ix_next = ix + 1u;
000058CE  3003      16895          move.w    D3,D0
000058D0  5240      16896          addq.w    #1,D0
000058D2  3D40 FFFA 16897          move.w    D0,-6(A6)
                    16898   ; ptmr1 = &OSTmrTbl[ix];
000058D6  200A      16899          move.l    A2,D0
000058D8  C6BC 0000 16900          and.l     #65535,D3
000058DC  FFFF      
000058DE  2203      16901          move.l    D3,D1
000058E0  C3FC 0024 16902          muls      #36,D1
000058E4  D081      16903          add.l     D1,D0
000058E6  2400      16904          move.l    D0,D2
                    16905   ; ptmr2 = &OSTmrTbl[ix_next];
000058E8  200A      16906          move.l    A2,D0
000058EA  322E FFFA 16907          move.w    -6(A6),D1
000058EE  C2BC 0000 16908          and.l     #65535,D1
000058F2  FFFF      
000058F4  C3FC 0024 16909          muls      #36,D1
000058F8  D081      16910          add.l     D1,D0
000058FA  2D40 FFFC 16911          move.l    D0,-4(A6)
                    16912   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000058FE  2042      16913          move.l    D2,A0
00005900  10BC 0064 16914          move.b    #100,(A0)
                    16915   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
00005904  2042      16916          move.l    D2,A0
00005906  4228 0023 16917          clr.b     35(A0)
                    16918   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
0000590A  2042      16919          move.l    D2,A0
0000590C  216E FFFC 16920          move.l    -4(A6),10(A0)
00005910  000A      
                    16921   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16922   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005912  41F9 0000 16923          lea       @ucos_ii_1.L,A0
00005916  68A4      
00005918  2242      16924          move.l    D2,A1
0000591A  2348 001E 16925          move.l    A0,30(A1)
0000591E  5243      16926          addq.w    #1,D3
00005920  60A4      16927          bra       OSTmr_Init_1
                    16928   OSTmr_Init_3:
                    16929   ; #endif
                    16930   ; }
                    16931   ; ptmr1               = &OSTmrTbl[ix];
00005922  200A      16932          move.l    A2,D0
00005924  C6BC 0000 16933          and.l     #65535,D3
00005928  FFFF      
0000592A  2203      16934          move.l    D3,D1
0000592C  C3FC 0024 16935          muls      #36,D1
00005930  D081      16936          add.l     D1,D0
00005932  2400      16937          move.l    D0,D2
                    16938   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
00005934  2042      16939          move.l    D2,A0
00005936  10BC 0064 16940          move.b    #100,(A0)
                    16941   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
0000593A  2042      16942          move.l    D2,A0
0000593C  4228 0023 16943          clr.b     35(A0)
                    16944   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005940  2042      16945          move.l    D2,A0
00005942  42A8 000A 16946          clr.l     10(A0)
                    16947   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16948   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005946  41F9 0000 16949          lea       @ucos_ii_1.L,A0
0000594A  68A4      
0000594C  2242      16950          move.l    D2,A1
0000594E  2348 001E 16951          move.l    A0,30(A1)
                    16952   ; #endif
                    16953   ; OSTmrTime           = 0u;
00005952  42B9 0800 16954          clr.l     _OSTmrTime.L
00005956  197E      
                    16955   ; OSTmrUsed           = 0u;
00005958  4279 0800 16956          clr.w     _OSTmrUsed.L
0000595C  197C      
                    16957   ; OSTmrFree           = OS_TMR_CFG_MAX;
0000595E  33FC 0010 16958          move.w    #16,_OSTmrFree.L
00005962  0800 197A 
                    16959   ; OSTmrFreeList       = &OSTmrTbl[0];
00005966  23CA 0800 16960          move.l    A2,_OSTmrFreeList.L
0000596A  1BCA      
                    16961   ; OSTmrSem            = OSSemCreate(1u);
0000596C  4878 0001 16962          pea       1
00005970  4EB8 400A 16963          jsr       _OSSemCreate
00005974  584F      16964          addq.w    #4,A7
00005976  23C0 0800 16965          move.l    D0,_OSTmrSem.L
0000597A  1982      
                    16966   ; OSTmrSemSignal      = OSSemCreate(0u);
0000597C  42A7      16967          clr.l     -(A7)
0000597E  4EB8 400A 16968          jsr       _OSSemCreate
00005982  584F      16969          addq.w    #4,A7
00005984  23C0 0800 16970          move.l    D0,_OSTmrSemSignal.L
00005988  1986      
                    16971   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    16972   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
0000598A  486E FFF9 16973          pea       -7(A6)
0000598E  4879 0000 16974          pea       @ucos_ii_4.L
00005992  68C2      
00005994  2F39 0800 16975          move.l    _OSTmrSem.L,-(A7)
00005998  1982      
0000599A  4EB8 0BD8 16976          jsr       _OSEventNameSet
0000599E  DEFC 000C 16977          add.w     #12,A7
                    16978   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
000059A2  486E FFF9 16979          pea       -7(A6)
000059A6  4879 0000 16980          pea       @ucos_ii_5.L
000059AA  68D4      
000059AC  2F39 0800 16981          move.l    _OSTmrSemSignal.L,-(A7)
000059B0  1986      
000059B2  4EB8 0BD8 16982          jsr       _OSEventNameSet
000059B6  DEFC 000C 16983          add.w     #12,A7
                    16984   ; #endif
                    16985   ; OSTmr_InitTask();
000059BA  4EB9 0000 16986          jsr       @ucos_ii_OSTmr_InitTask
000059BE  59C8      
000059C0  4CDF 040C 16987          movem.l   (A7)+,D2/D3/A2
000059C4  4E5E      16988          unlk      A6
000059C6  4E75      16989          rts
                    16990   ; }
                    16991   ; #endif
                    16992   ; /*$PAGE*/
                    16993   ; /*
                    16994   ; *********************************************************************************************************
                    16995   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    16996   ; *
                    16997   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    16998   ; *                               * Arguments  : none
                    16999   ; *
                    17000   ; * Returns    : none
                    17001   ; *********************************************************************************************************
                    17002   ; */
                    17003   ; #if OS_TMR_EN > 0u
                    17004   ; static  void  OSTmr_InitTask (void)
                    17005   ; {
                    17006   @ucos_ii_OSTmr_InitTask:
000059C8  4E56 FFFC 17007          link      A6,#-4
                    17008   ; #if OS_TASK_NAME_EN > 0u
                    17009   ; INT8U  err;
                    17010   ; #endif
                    17011   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    17012   ; #if OS_STK_GROWTH == 1u
                    17013   ; (void)OSTaskCreateExt(OSTmr_Task,
000059CC  4878 0003 17014          pea       3
000059D0  42A7      17015          clr.l     -(A7)
000059D2  4878 0080 17016          pea       128
000059D6  4879 0800 17017          pea       _OSTmrTaskStk.L
000059DA  1BCE      
000059DC  4878 FFFD 17018          pea       65533
000059E0  4878 0005 17019          pea       5
000059E4  41F9 0800 17020          lea       _OSTmrTaskStk.L,A0
000059E8  1BCE      
000059EA  D0FC 00FE 17021          add.w     #254,A0
000059EE  2F08      17022          move.l    A0,-(A7)
000059F0  42A7      17023          clr.l     -(A7)
000059F2  4879 0000 17024          pea       @ucos_ii_OSTmr_Task.L
000059F6  5B92      
000059F8  4EB8 4780 17025          jsr       _OSTaskCreateExt
000059FC  DEFC 0024 17026          add.w     #36,A7
00005A00  C0BC 0000 17027          and.l     #255,D0
00005A04  00FF      
                    17028   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17029   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    17030   ; OS_TASK_TMR_PRIO,
                    17031   ; OS_TASK_TMR_ID,
                    17032   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    17033   ; OS_TASK_TMR_STK_SIZE,
                    17034   ; (void *)0,                                       /* No TCB extension                        */
                    17035   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17036   ; #else
                    17037   ; (void)OSTaskCreateExt(OSTmr_Task,
                    17038   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17039   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    17040   ; OS_TASK_TMR_PRIO,
                    17041   ; OS_TASK_TMR_ID,
                    17042   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    17043   ; OS_TASK_TMR_STK_SIZE,
                    17044   ; (void *)0,                                       /* No TCB extension                        */
                    17045   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17046   ; #endif
                    17047   ; #else
                    17048   ; #if OS_STK_GROWTH == 1u
                    17049   ; (void)OSTaskCreate(OSTmr_Task,
                    17050   ; (void *)0,
                    17051   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    17052   ; OS_TASK_TMR_PRIO);
                    17053   ; #else
                    17054   ; (void)OSTaskCreate(OSTmr_Task,
                    17055   ; (void *)0,
                    17056   ; &OSTmrTaskStk[0],
                    17057   ; OS_TASK_TMR_PRIO);
                    17058   ; #endif
                    17059   ; #endif
                    17060   ; #if OS_TASK_NAME_EN > 0u
                    17061   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
00005A06  486E FFFF 17062          pea       -1(A6)
00005A0A  4879 0000 17063          pea       @ucos_ii_6.L
00005A0E  68E8      
00005A10  4878 0005 17064          pea       5
00005A14  4EB8 4B8C 17065          jsr       _OSTaskNameSet
00005A18  DEFC 000C 17066          add.w     #12,A7
00005A1C  4E5E      17067          unlk      A6
00005A1E  4E75      17068          rts
                    17069   ; #endif
                    17070   ; }
                    17071   ; #endif
                    17072   ; /*$PAGE*/
                    17073   ; /*
                    17074   ; *********************************************************************************************************
                    17075   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    17076   ; *
                    17077   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    17078   ; *              inserted at the beginning of the list.
                    17079   ; *
                    17080   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    17081   ; *
                    17082   ; *              type          Is either:
                    17083   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    17084   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    17085   ; *
                    17086   ; * Returns    : none
                    17087   ; *********************************************************************************************************
                    17088   ; */
                    17089   ; #if OS_TMR_EN > 0u
                    17090   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    17091   ; INT8U    type)
                    17092   ; {
                    17093   @ucos_ii_OSTmr_Link:
00005A20  4E56 FFFC 17094          link      A6,#-4
00005A24  48E7 3820 17095          movem.l   D2/D3/D4/A2,-(A7)
00005A28  242E 0008 17096          move.l    8(A6),D2
00005A2C  45F9 0800 17097          lea       _OSTmrTime.L,A2
00005A30  197E      
                    17098   ; OS_TMR       *ptmr1;
                    17099   ; OS_TMR_WHEEL *pspoke;
                    17100   ; INT16U        spoke;
                    17101   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
00005A32  2042      17102          move.l    D2,A0
00005A34  117C 0003 17103          move.b    #3,35(A0)
00005A38  0023      
                    17104   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00005A3A  102E 000F 17105          move.b    15(A6),D0
00005A3E  0C00 0001 17106          cmp.b     #1,D0
00005A42  6610      17107          bne.s     @ucos_ii_OSTmr_Link_1
                    17108   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005A44  2042      17109          move.l    D2,A0
00005A46  2028 001A 17110          move.l    26(A0),D0
00005A4A  D092      17111          add.l     (A2),D0
00005A4C  2042      17112          move.l    D2,A0
00005A4E  2140 0012 17113          move.l    D0,18(A0)
00005A52  6026      17114          bra.s     @ucos_ii_OSTmr_Link_4
                    17115   @ucos_ii_OSTmr_Link_1:
                    17116   ; } else {
                    17117   ; if (ptmr->OSTmrDly == 0u) {
00005A54  2042      17118          move.l    D2,A0
00005A56  2028 0016 17119          move.l    22(A0),D0
00005A5A  6610      17120          bne.s     @ucos_ii_OSTmr_Link_3
                    17121   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005A5C  2042      17122          move.l    D2,A0
00005A5E  2028 001A 17123          move.l    26(A0),D0
00005A62  D092      17124          add.l     (A2),D0
00005A64  2042      17125          move.l    D2,A0
00005A66  2140 0012 17126          move.l    D0,18(A0)
00005A6A  600E      17127          bra.s     @ucos_ii_OSTmr_Link_4
                    17128   @ucos_ii_OSTmr_Link_3:
                    17129   ; } else {
                    17130   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00005A6C  2042      17131          move.l    D2,A0
00005A6E  2028 0016 17132          move.l    22(A0),D0
00005A72  D092      17133          add.l     (A2),D0
00005A74  2042      17134          move.l    D2,A0
00005A76  2140 0012 17135          move.l    D0,18(A0)
                    17136   @ucos_ii_OSTmr_Link_4:
                    17137   ; }
                    17138   ; }
                    17139   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005A7A  2002      17140          move.l    D2,D0
00005A7C  0680 0000 17141          add.l     #18,D0
00005A80  0012      
00005A82  2040      17142          move.l    D0,A0
00005A84  2F10      17143          move.l    (A0),-(A7)
00005A86  4878 0008 17144          pea       8
00005A8A  4EB9 0000 17145          jsr       ULDIV
00005A8E  5EDA      
00005A90  202F 0004 17146          move.l    4(A7),D0
00005A94  504F      17147          addq.w    #8,A7
00005A96  3D40 FFFE 17148          move.w    D0,-2(A6)
                    17149   ; pspoke = &OSTmrWheelTbl[spoke];
00005A9A  41F9 0800 17150          lea       _OSTmrWheelTbl.L,A0
00005A9E  1CCE      
00005AA0  302E FFFE 17151          move.w    -2(A6),D0
00005AA4  C0BC 0000 17152          and.l     #65535,D0
00005AA8  FFFF      
00005AAA  E588      17153          lsl.l     #2,D0
00005AAC  D1C0      17154          add.l     D0,A0
00005AAE  2608      17155          move.l    A0,D3
                    17156   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005AB0  2043      17157          move.l    D3,A0
00005AB2  2010      17158          move.l    (A0),D0
00005AB4  6614      17159          bne.s     @ucos_ii_OSTmr_Link_5
                    17160   ; pspoke->OSTmrFirst   = ptmr;
00005AB6  2043      17161          move.l    D3,A0
00005AB8  2082      17162          move.l    D2,(A0)
                    17163   ; ptmr->OSTmrNext      = (OS_TMR *)0;
00005ABA  2042      17164          move.l    D2,A0
00005ABC  42A8 000A 17165          clr.l     10(A0)
                    17166   ; pspoke->OSTmrEntries = 1u;
00005AC0  2043      17167          move.l    D3,A0
00005AC2  317C 0001 17168          move.w    #1,4(A0)
00005AC6  0004      
00005AC8  601C      17169          bra.s     @ucos_ii_OSTmr_Link_6
                    17170   @ucos_ii_OSTmr_Link_5:
                    17171   ; } else {
                    17172   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
00005ACA  2043      17173          move.l    D3,A0
00005ACC  2810      17174          move.l    (A0),D4
                    17175   ; pspoke->OSTmrFirst   = ptmr;
00005ACE  2043      17176          move.l    D3,A0
00005AD0  2082      17177          move.l    D2,(A0)
                    17178   ; ptmr->OSTmrNext      = (void *)ptmr1;
00005AD2  2042      17179          move.l    D2,A0
00005AD4  2144 000A 17180          move.l    D4,10(A0)
                    17181   ; ptmr1->OSTmrPrev     = (void *)ptmr;
00005AD8  2044      17182          move.l    D4,A0
00005ADA  2142 000E 17183          move.l    D2,14(A0)
                    17184   ; pspoke->OSTmrEntries++;
00005ADE  2003      17185          move.l    D3,D0
00005AE0  5880      17186          addq.l    #4,D0
00005AE2  2040      17187          move.l    D0,A0
00005AE4  5250      17188          addq.w    #1,(A0)
                    17189   @ucos_ii_OSTmr_Link_6:
                    17190   ; }
                    17191   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005AE6  2042      17192          move.l    D2,A0
00005AE8  42A8 000E 17193          clr.l     14(A0)
00005AEC  4CDF 041C 17194          movem.l   (A7)+,D2/D3/D4/A2
00005AF0  4E5E      17195          unlk      A6
00005AF2  4E75      17196          rts
                    17197   ; }
                    17198   ; #endif
                    17199   ; /*$PAGE*/
                    17200   ; /*
                    17201   ; *********************************************************************************************************
                    17202   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    17203   ; *
                    17204   ; * Description: This function is called to remove the timer from the timer wheel.
                    17205   ; *
                    17206   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    17207   ; *
                    17208   ; * Returns    : none
                    17209   ; *********************************************************************************************************
                    17210   ; */
                    17211   ; #if OS_TMR_EN > 0u
                    17212   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    17213   ; {
                    17214   @ucos_ii_OSTmr_Unlink:
00005AF4  4E56 FFFC 17215          link      A6,#-4
00005AF8  48E7 3C00 17216          movem.l   D2/D3/D4/D5,-(A7)
00005AFC  242E 0008 17217          move.l    8(A6),D2
                    17218   ; OS_TMR        *ptmr1;
                    17219   ; OS_TMR        *ptmr2;
                    17220   ; OS_TMR_WHEEL  *pspoke;
                    17221   ; INT16U         spoke;
                    17222   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005B00  2002      17223          move.l    D2,D0
00005B02  0680 0000 17224          add.l     #18,D0
00005B06  0012      
00005B08  2040      17225          move.l    D0,A0
00005B0A  2F10      17226          move.l    (A0),-(A7)
00005B0C  4878 0008 17227          pea       8
00005B10  4EB9 0000 17228          jsr       ULDIV
00005B14  5EDA      
00005B16  202F 0004 17229          move.l    4(A7),D0
00005B1A  504F      17230          addq.w    #8,A7
00005B1C  3D40 FFFE 17231          move.w    D0,-2(A6)
                    17232   ; pspoke = &OSTmrWheelTbl[spoke];
00005B20  41F9 0800 17233          lea       _OSTmrWheelTbl.L,A0
00005B24  1CCE      
00005B26  302E FFFE 17234          move.w    -2(A6),D0
00005B2A  C0BC 0000 17235          and.l     #65535,D0
00005B2E  FFFF      
00005B30  E588      17236          lsl.l     #2,D0
00005B32  D1C0      17237          add.l     D0,A0
00005B34  2A08      17238          move.l    A0,D5
                    17239   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00005B36  2045      17240          move.l    D5,A0
00005B38  B490      17241          cmp.l     (A0),D2
00005B3A  6616      17242          bne.s     @ucos_ii_OSTmr_Unlink_1
                    17243   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
00005B3C  2042      17244          move.l    D2,A0
00005B3E  2628 000A 17245          move.l    10(A0),D3
                    17246   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
00005B42  2045      17247          move.l    D5,A0
00005B44  2083      17248          move.l    D3,(A0)
                    17249   ; if (ptmr1 != (OS_TMR *)0) {
00005B46  4A83      17250          tst.l     D3
00005B48  6706      17251          beq.s     @ucos_ii_OSTmr_Unlink_3
                    17252   ; ptmr1->OSTmrPrev = (void *)0;
00005B4A  2043      17253          move.l    D3,A0
00005B4C  42A8 000E 17254          clr.l     14(A0)
                    17255   @ucos_ii_OSTmr_Unlink_3:
00005B50  601C      17256          bra.s     @ucos_ii_OSTmr_Unlink_5
                    17257   @ucos_ii_OSTmr_Unlink_1:
                    17258   ; }
                    17259   ; } else {
                    17260   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00005B52  2042      17261          move.l    D2,A0
00005B54  2628 000E 17262          move.l    14(A0),D3
                    17263   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
00005B58  2042      17264          move.l    D2,A0
00005B5A  2828 000A 17265          move.l    10(A0),D4
                    17266   ; ptmr1->OSTmrNext = ptmr2;
00005B5E  2043      17267          move.l    D3,A0
00005B60  2144 000A 17268          move.l    D4,10(A0)
                    17269   ; if (ptmr2 != (OS_TMR *)0) {
00005B64  4A84      17270          tst.l     D4
00005B66  6706      17271          beq.s     @ucos_ii_OSTmr_Unlink_5
                    17272   ; ptmr2->OSTmrPrev = (void *)ptmr1;
00005B68  2044      17273          move.l    D4,A0
00005B6A  2143 000E 17274          move.l    D3,14(A0)
                    17275   @ucos_ii_OSTmr_Unlink_5:
                    17276   ; }
                    17277   ; }
                    17278   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005B6E  2042      17279          move.l    D2,A0
00005B70  117C 0001 17280          move.b    #1,35(A0)
00005B74  0023      
                    17281   ; ptmr->OSTmrNext  = (void *)0;
00005B76  2042      17282          move.l    D2,A0
00005B78  42A8 000A 17283          clr.l     10(A0)
                    17284   ; ptmr->OSTmrPrev  = (void *)0;
00005B7C  2042      17285          move.l    D2,A0
00005B7E  42A8 000E 17286          clr.l     14(A0)
                    17287   ; pspoke->OSTmrEntries--;
00005B82  2005      17288          move.l    D5,D0
00005B84  5880      17289          addq.l    #4,D0
00005B86  2040      17290          move.l    D0,A0
00005B88  5350      17291          subq.w    #1,(A0)
00005B8A  4CDF 003C 17292          movem.l   (A7)+,D2/D3/D4/D5
00005B8E  4E5E      17293          unlk      A6
00005B90  4E75      17294          rts
                    17295   ; }
                    17296   ; #endif
                    17297   ; /*$PAGE*/
                    17298   ; /*
                    17299   ; *********************************************************************************************************
                    17300   ; *                                        TIMER MANAGEMENT TASK
                    17301   ; *
                    17302   ; * Description: This task is created by OSTmrInit().
                    17303   ; *
                    17304   ; * Arguments  : none
                    17305   ; *
                    17306   ; * Returns    : none
                    17307   ; *********************************************************************************************************
                    17308   ; */
                    17309   ; #if OS_TMR_EN > 0u
                    17310   ; static  void  OSTmr_Task (void *p_arg)
                    17311   ; {
                    17312   @ucos_ii_OSTmr_Task:
00005B92  4E56 FFF4 17313          link      A6,#-12
00005B96  48E7 3020 17314          movem.l   D2/D3/A2,-(A7)
00005B9A  45F9 0800 17315          lea       _OSTmrTime.L,A2
00005B9E  197E      
                    17316   ; INT8U            err;
                    17317   ; OS_TMR          *ptmr;
                    17318   ; OS_TMR          *ptmr_next;
                    17319   ; OS_TMR_CALLBACK  pfnct;
                    17320   ; OS_TMR_WHEEL    *pspoke;
                    17321   ; INT16U           spoke;
                    17322   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17323   ; for (;;) {
                    17324   @ucos_ii_OSTmr_Task_1:
                    17325   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005BA0  486E FFF5 17326          pea       -11(A6)
00005BA4  42A7      17327          clr.l     -(A7)
00005BA6  2F39 0800 17328          move.l    _OSTmrSemSignal.L,-(A7)
00005BAA  1986      
00005BAC  4EB8 4190 17329          jsr       _OSSemPend
00005BB0  DEFC 000C 17330          add.w     #12,A7
                    17331   ; OSSchedLock();
00005BB4  4EB8 1066 17332          jsr       _OSSchedLock
                    17333   ; OSTmrTime++;                                             /* Increment the current time                        */
00005BB8  5292      17334          addq.l    #1,(A2)
                    17335   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
00005BBA  2F12      17336          move.l    (A2),-(A7)
00005BBC  4878 0008 17337          pea       8
00005BC0  4EB9 0000 17338          jsr       ULDIV
00005BC4  5EDA      
00005BC6  202F 0004 17339          move.l    4(A7),D0
00005BCA  504F      17340          addq.w    #8,A7
00005BCC  3D40 FFFE 17341          move.w    D0,-2(A6)
                    17342   ; pspoke = &OSTmrWheelTbl[spoke];
00005BD0  41F9 0800 17343          lea       _OSTmrWheelTbl.L,A0
00005BD4  1CCE      
00005BD6  302E FFFE 17344          move.w    -2(A6),D0
00005BDA  C0BC 0000 17345          and.l     #65535,D0
00005BDE  FFFF      
00005BE0  E588      17346          lsl.l     #2,D0
00005BE2  D1C0      17347          add.l     D0,A0
00005BE4  2D48 FFFA 17348          move.l    A0,-6(A6)
                    17349   ; ptmr   = pspoke->OSTmrFirst;
00005BE8  206E FFFA 17350          move.l    -6(A6),A0
00005BEC  2410      17351          move.l    (A0),D2
                    17352   ; while (ptmr != (OS_TMR *)0) {
                    17353   @ucos_ii_OSTmr_Task_4:
00005BEE  4A82      17354          tst.l     D2
00005BF0  6700 005E 17355          beq       @ucos_ii_OSTmr_Task_6
                    17356   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
00005BF4  2042      17357          move.l    D2,A0
00005BF6  2D68 000A 17358          move.l    10(A0),-10(A6)
00005BFA  FFF6      
                    17359   ; /* ... timer could get unlinked from the wheel.      */
                    17360   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
00005BFC  2042      17361          move.l    D2,A0
00005BFE  2012      17362          move.l    (A2),D0
00005C00  B0A8 0012 17363          cmp.l     18(A0),D0
00005C04  6600 0044 17364          bne       @ucos_ii_OSTmr_Task_11
                    17365   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
00005C08  2F02      17366          move.l    D2,-(A7)
00005C0A  4EB8 5AF4 17367          jsr       @ucos_ii_OSTmr_Unlink
00005C0E  584F      17368          addq.w    #4,A7
                    17369   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
00005C10  2042      17370          move.l    D2,A0
00005C12  1028 0022 17371          move.b    34(A0),D0
00005C16  0C00 0002 17372          cmp.b     #2,D0
00005C1A  660E      17373          bne.s     @ucos_ii_OSTmr_Task_9
                    17374   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
00005C1C  4878 0001 17375          pea       1
00005C20  2F02      17376          move.l    D2,-(A7)
00005C22  4EB8 5A20 17377          jsr       @ucos_ii_OSTmr_Link
00005C26  504F      17378          addq.w    #8,A7
00005C28  6008      17379          bra.s     @ucos_ii_OSTmr_Task_10
                    17380   @ucos_ii_OSTmr_Task_9:
                    17381   ; } else {
                    17382   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00005C2A  2042      17383          move.l    D2,A0
00005C2C  117C 0002 17384          move.b    #2,35(A0)
00005C30  0023      
                    17385   @ucos_ii_OSTmr_Task_10:
                    17386   ; }
                    17387   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005C32  2042      17388          move.l    D2,A0
00005C34  2628 0002 17389          move.l    2(A0),D3
                    17390   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005C38  4A83      17391          tst.l     D3
00005C3A  670E      17392          beq.s     @ucos_ii_OSTmr_Task_11
                    17393   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
00005C3C  2042      17394          move.l    D2,A0
00005C3E  2F28 0006 17395          move.l    6(A0),-(A7)
00005C42  2F02      17396          move.l    D2,-(A7)
00005C44  2043      17397          move.l    D3,A0
00005C46  4E90      17398          jsr       (A0)
00005C48  504F      17399          addq.w    #8,A7
                    17400   @ucos_ii_OSTmr_Task_11:
                    17401   ; }
                    17402   ; }
                    17403   ; ptmr = ptmr_next;
00005C4A  242E FFF6 17404          move.l    -10(A6),D2
00005C4E  609E      17405          bra       @ucos_ii_OSTmr_Task_4
                    17406   @ucos_ii_OSTmr_Task_6:
                    17407   ; }
                    17408   ; OSSchedUnlock();
00005C50  4EB8 1096 17409          jsr       _OSSchedUnlock
00005C54  6000 FF4A 17410          bra       @ucos_ii_OSTmr_Task_1
                    17411   ; /*
                    17412   ; *********************************************************************************************************
                    17413   ; *                                                uC/OS-II
                    17414   ; *                                          The Real-Time Kernel
                    17415   ; *
                    17416   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17417   ; *                                           All Rights Reserved
                    17418   ; *
                    17419   ; * File    : uCOS_II.C
                    17420   ; * By      : Jean J. Labrosse
                    17421   ; * Version : V2.91
                    17422   ; *
                    17423   ; * LICENSING TERMS:
                    17424   ; * ---------------
                    17425   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17426   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license 
                    17427   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17428   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17429   ; * licensing fee.
                    17430   ; *********************************************************************************************************
                    17431   ; */
                    17432   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17433   ; #include "ucos_ii.h"
                    17434   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17435   ; #include "os_core.c"
                    17436   ; #include "os_flag.c"
                    17437   ; #include "os_mbox.c"
                    17438   ; #include "os_mem.c"
                    17439   ; #include "os_mutex.c"
                    17440   ; #include "os_q.c"
                    17441   ; #include "os_sem.c"
                    17442   ; #include "os_task.c"
                    17443   ; #include "os_time.c"
                    17444   ; #include "os_tmr.c"
                    17445   ; C:\IDE68K\UCOSII\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17446   ; #include "Bios.h"
                    17447   ; /*
                    17448   ; **  These basic IO routines are designed to handle input and output of characters
                    17449   ; **  via the serial port to the console of hyperternal
                    17450   ; **
                    17451   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17452   ; */
                    17453   ; // things that need to be done at initialisation/boot include
                    17454   ; // 1) initialise serial port and LCD display
                    17455   ; // 2) initialise the LCD display
                    17456   ; // 3) install the trap handler for a context switch (trap0)
                    17457   ; // 4) install the TickISR for level 3 IRQ
                    17458   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17459   ; /*********************************************************************************************
                    17460   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17461   ; *********************************************************************************************/
                    17462   ; void Init_RS232(void)
                    17463   ; {
                    17464   _Init_RS232:
                    17465   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00005C58  13FC 0015 17466          move.b    #21,4194368
00005C5C  0040 0040 
                    17467   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00005C60  13FC 0001 17468          move.b    #1,4194372
00005C64  0040 0044 
00005C68  4E75      17469          rts
                    17470   ; }
                    17471   ; int kbhit(void)
                    17472   ; {
                    17473   _kbhit:
                    17474   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
00005C6A  1039 0040 17475          move.b    4194368,D0
00005C6E  0040      
00005C70  C03C 0002 17476          and.b     #2,D0
00005C74  0C00 0002 17477          cmp.b     #2,D0
00005C78  6604      17478          bne.s     kbhit_1
                    17479   ; return 1 ;
00005C7A  7001      17480          moveq     #1,D0
00005C7C  6002      17481          bra.s     kbhit_3
                    17482   kbhit_1:
                    17483   ; else
                    17484   ; return 0 ;
00005C7E  4280      17485          clr.l     D0
                    17486   kbhit_3:
00005C80  4E75      17487          rts
                    17488   ; }
                    17489   ; /*********************************************************************************************************
                    17490   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17491   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17492   ; **  to allow the board to communicate with HyperTerminal Program
                    17493   ; **
                    17494   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17495   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17496   ; **  call _putch() also
                    17497   ; *********************************************************************************************************/
                    17498   ; int _putch( int c)
                    17499   ; {
                    17500   __putch:
00005C82  4E56 0000 17501          link      A6,#0
                    17502   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17503   _putch_1:
00005C86  1039 0040 17504          move.b    4194368,D0
00005C8A  0040      
00005C8C  C03C 0002 17505          and.b     #2,D0
00005C90  0C00 0002 17506          cmp.b     #2,D0
00005C94  6702      17507          beq.s     _putch_3
00005C96  60EE      17508          bra       _putch_1
                    17509   _putch_3:
                    17510   ; ;
                    17511   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00005C98  202E 0008 17512          move.l    8(A6),D0
00005C9C  C03C 007F 17513          and.b     #127,D0
00005CA0  13C0 0040 17514          move.b    D0,4194370
00005CA4  0042      
                    17515   ; return c ;                                              // putchar() expects the character to be returned
00005CA6  202E 0008 17516          move.l    8(A6),D0
00005CAA  4E5E      17517          unlk      A6
00005CAC  4E75      17518          rts
                    17519   ; }
                    17520   ; /*********************************************************************************************************
                    17521   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17522   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17523   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17524   ; **
                    17525   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17526   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17527   ; **  call _getch() also
                    17528   ; *********************************************************************************************************/
                    17529   ; int _getch( void )
                    17530   ; {
                    17531   __getch:
00005CAE  2F02      17532          move.l    D2,-(A7)
                    17533   ; int c ;
                    17534   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17535   _getch_1:
00005CB0  1039 0040 17536          move.b    4194368,D0
00005CB4  0040      
00005CB6  C03C 0001 17537          and.b     #1,D0
00005CBA  0C00 0001 17538          cmp.b     #1,D0
00005CBE  6702      17539          beq.s     _getch_3
00005CC0  60EE      17540          bra       _getch_1
                    17541   _getch_3:
                    17542   ; ;
                    17543   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00005CC2  1039 0040 17544          move.b    4194370,D0
00005CC6  0042      
00005CC8  C0BC 0000 17545          and.l     #255,D0
00005CCC  00FF      
00005CCE  C0BC 0000 17546          and.l     #127,D0
00005CD2  007F      
00005CD4  2400      17547          move.l    D0,D2
                    17548   ; _putch(c);
00005CD6  2F02      17549          move.l    D2,-(A7)
00005CD8  4EB8 5C82 17550          jsr       __putch
00005CDC  584F      17551          addq.w    #4,A7
                    17552   ; return c ;
00005CDE  2002      17553          move.l    D2,D0
00005CE0  241F      17554          move.l    (A7)+,D2
00005CE2  4E75      17555          rts
                    17556   ; }
                    17557   ; /************************************************************************************
                    17558   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17559   ; ************************************************************************************/
                    17560   ; void Wait1ms(void)
                    17561   ; {
                    17562   _Wait1ms:
00005CE4  2F02      17563          move.l    D2,-(A7)
                    17564   ; long int  i ;
                    17565   ; for(i = 0; i < 1000; i ++)
00005CE6  4282      17566          clr.l     D2
                    17567   Wait1ms_1:
00005CE8  0C82 0000 17568          cmp.l     #1000,D2
00005CEC  03E8      
00005CEE  6C04      17569          bge.s     Wait1ms_3
00005CF0  5282      17570          addq.l    #1,D2
00005CF2  60F4      17571          bra       Wait1ms_1
                    17572   Wait1ms_3:
00005CF4  241F      17573          move.l    (A7)+,D2
00005CF6  4E75      17574          rts
                    17575   ; ;
                    17576   ; }
                    17577   ; /************************************************************************************
                    17578   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17579   ; **************************************************************************************/
                    17580   ; void Wait3ms(void)
                    17581   ; {
                    17582   _Wait3ms:
00005CF8  2F02      17583          move.l    D2,-(A7)
                    17584   ; int i ;
                    17585   ; for(i = 0; i < 3; i++)
00005CFA  4282      17586          clr.l     D2
                    17587   Wait3ms_1:
00005CFC  0C82 0000 17588          cmp.l     #3,D2
00005D00  0003      
00005D02  6C08      17589          bge.s     Wait3ms_3
                    17590   ; Wait1ms() ;
00005D04  4EB8 5CE4 17591          jsr       _Wait1ms
00005D08  5282      17592          addq.l    #1,D2
00005D0A  60F0      17593          bra       Wait3ms_1
                    17594   Wait3ms_3:
00005D0C  241F      17595          move.l    (A7)+,D2
00005D0E  4E75      17596          rts
                    17597   ; }
                    17598   ; /*********************************************************************************************
                    17599   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17600   ; *********************************************************************************************/
                    17601   ; void Init_LCD(void)
                    17602   ; {
                    17603   _Init_LCD:
                    17604   ; LCDcommand = (char)(0x0c) ;
00005D10  13FC 000C 17605          move.b    #12,4194336
00005D14  0040 0020 
                    17606   ; Wait3ms() ;
00005D18  4EB8 5CF8 17607          jsr       _Wait3ms
                    17608   ; LCDcommand = (char)(0x38) ;
00005D1C  13FC 0038 17609          move.b    #56,4194336
00005D20  0040 0020 
                    17610   ; Wait3ms() ;
00005D24  4EB8 5CF8 17611          jsr       _Wait3ms
00005D28  4E75      17612          rts
                    17613   ; }
                    17614   ; /******************************************************************************
                    17615   ; *subroutine to output a single character held in d1 to the LCD display
                    17616   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17617   ; *current cursor position
                    17618   ; *******************************************************************************/
                    17619   ; void Outchar(int c)
                    17620   ; {
                    17621   _Outchar:
00005D2A  4E56 0000 17622          link      A6,#0
                    17623   ; LCDdata = (char)(c);
00005D2E  202E 0008 17624          move.l    8(A6),D0
00005D32  13C0 0040 17625          move.b    D0,4194338
00005D36  0022      
                    17626   ; Wait1ms() ;
00005D38  4EB8 5CE4 17627          jsr       _Wait1ms
00005D3C  4E5E      17628          unlk      A6
00005D3E  4E75      17629          rts
                    17630   ; }
                    17631   ; /**********************************************************************************
                    17632   ; *subroutine to output a message at the current cursor position of the LCD display
                    17633   ; ************************************************************************************/
                    17634   ; void OutMess(char *theMessage)
                    17635   ; {
                    17636   _OutMess:
00005D40  4E56 FFFC 17637          link      A6,#-4
                    17638   ; char c ;
                    17639   ; while((c = *theMessage++) != (char)(0))
                    17640   OutMess_1:
00005D44  206E 0008 17641          move.l    8(A6),A0
00005D48  52AE 0008 17642          addq.l    #1,8(A6)
00005D4C  1D50 FFFF 17643          move.b    (A0),-1(A6)
00005D50  1010      17644          move.b    (A0),D0
00005D52  6712      17645          beq.s     OutMess_3
                    17646   ; Outchar(c) ;
00005D54  122E FFFF 17647          move.b    -1(A6),D1
00005D58  4881      17648          ext.w     D1
00005D5A  48C1      17649          ext.l     D1
00005D5C  2F01      17650          move.l    D1,-(A7)
00005D5E  4EB8 5D2A 17651          jsr       _Outchar
00005D62  584F      17652          addq.w    #4,A7
00005D64  60DE      17653          bra       OutMess_1
                    17654   OutMess_3:
00005D66  4E5E      17655          unlk      A6
00005D68  4E75      17656          rts
                    17657   ; }
                    17658   ; /******************************************************************************
                    17659   ; *subroutine to clear the line by issuing 24 space characters
                    17660   ; *******************************************************************************/
                    17661   ; void Clearln(void)
                    17662   ; {
                    17663   _Clearln:
00005D6A  2F02      17664          move.l    D2,-(A7)
                    17665   ; unsigned char i ;
                    17666   ; for(i = 0; i < 24; i ++)
00005D6C  4202      17667          clr.b     D2
                    17668   Clearln_1:
00005D6E  0C02 0018 17669          cmp.b     #24,D2
00005D72  640E      17670          bhs.s     Clearln_3
                    17671   ; Outchar(' ') ;  /* write a space char to the LCD display */
00005D74  4878 0020 17672          pea       32
00005D78  4EB8 5D2A 17673          jsr       _Outchar
00005D7C  584F      17674          addq.w    #4,A7
00005D7E  5202      17675          addq.b    #1,D2
00005D80  60EC      17676          bra       Clearln_1
                    17677   Clearln_3:
00005D82  241F      17678          move.l    (A7)+,D2
00005D84  4E75      17679          rts
                    17680   ; }
                    17681   ; /******************************************************************************
                    17682   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    17683   ; *******************************************************************************/
                    17684   ; void Oline0(char *theMessage)
                    17685   ; {
                    17686   _Oline0:
00005D86  4E56 0000 17687          link      A6,#0
                    17688   ; LCDcommand = (char)(0x80) ;
00005D8A  13FC 0080 17689          move.b    #128,4194336
00005D8E  0040 0020 
                    17690   ; Wait3ms();
00005D92  4EB8 5CF8 17691          jsr       _Wait3ms
                    17692   ; Clearln() ;
00005D96  4EB8 5D6A 17693          jsr       _Clearln
                    17694   ; LCDcommand = (char)(0x80) ;
00005D9A  13FC 0080 17695          move.b    #128,4194336
00005D9E  0040 0020 
                    17696   ; Wait3ms() ;
00005DA2  4EB8 5CF8 17697          jsr       _Wait3ms
                    17698   ; OutMess(theMessage) ;
00005DA6  2F2E 0008 17699          move.l    8(A6),-(A7)
00005DAA  4EB8 5D40 17700          jsr       _OutMess
00005DAE  584F      17701          addq.w    #4,A7
00005DB0  4E5E      17702          unlk      A6
00005DB2  4E75      17703          rts
                    17704   ; }
                    17705   ; /******************************************************************************
                    17706   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    17707   ; *******************************************************************************/
                    17708   ; void Oline1(char *theMessage)
                    17709   ; {
                    17710   _Oline1:
00005DB4  4E56 0000 17711          link      A6,#0
                    17712   ; LCDcommand = (char)(0xC0) ;
00005DB8  13FC 00C0 17713          move.b    #192,4194336
00005DBC  0040 0020 
                    17714   ; Wait3ms();
00005DC0  4EB8 5CF8 17715          jsr       _Wait3ms
                    17716   ; Clearln() ;
00005DC4  4EB8 5D6A 17717          jsr       _Clearln
                    17718   ; LCDcommand = (char)(0xC0) ;
00005DC8  13FC 00C0 17719          move.b    #192,4194336
00005DCC  0040 0020 
                    17720   ; Wait3ms() ;
00005DD0  4EB8 5CF8 17721          jsr       _Wait3ms
                    17722   ; OutMess(theMessage) ;
00005DD4  2F2E 0008 17723          move.l    8(A6),-(A7)
00005DD8  4EB8 5D40 17724          jsr       _OutMess
00005DDC  584F      17725          addq.w    #4,A7
00005DDE  4E5E      17726          unlk      A6
00005DE0  4E75      17727          rts
                    17728   ; }
                    17729   ; /*********************************************************************************
                    17730   ; ** Timer ISR
                    17731   ; **********************************************************************************/
                    17732   ; void Timer_ISR(void)
                    17733   ; {
                    17734   _Timer_ISR:
                    17735   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
00005DE2  1039 0040 17736          move.b    4194354,D0
00005DE6  0032      
00005DE8  0C00 0001 17737          cmp.b     #1,D0
00005DEC  6608      17738          bne.s     Timer_ISR_1
                    17739   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
00005DEE  13FC 0003 17740          move.b    #3,4194354
00005DF2  0040 0032 
                    17741   Timer_ISR_1:
00005DF6  4E75      17742          rts
                    17743   ; }
                    17744   ; }
                    17745   ; /**********************************************************************************
                    17746   ; ** Timer Initialisation Routine
                    17747   ; **********************************************************************************/
                    17748   ; void Timer1_Init(void)
                    17749   ; {
                    17750   _Timer1_Init:
                    17751   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
00005DF8  13FC 0003 17752          move.b    #3,4194352
00005DFC  0040 0030 
                    17753   ; /*
                    17754   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    17755   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    17756   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    17757   ; **
                    17758   ; **
                    17759   ; ** Now write binary 00000011 to timer control register:
                    17760   ; **	Bit0 = 1 (enable interrupt from that timer)
                    17761   ; **	Bit 1 = 1 enable counting
                    17762   ; */
                    17763   ; Timer1Control = 3;
00005E00  13FC 0003 17764          move.b    #3,4194354
00005E04  0040 0032 
00005E08  4E75      17765          rts
                    17766   ; }
                    17767   ; /*********************************************************************************************************************************
                    17768   ; **  IMPORTANT FUNCTION
                    17769   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    17770   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    17771   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    17772   ; **  Calling this function allows you to deal with Interrupts for example
                    17773   ; **
                    17774   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    17775   ; **
                    17776   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    17777   ; **
                    17778   ; **	see main below for other examples
                    17779   ; ***********************************************************************************************************************************/
                    17780   ; /*
                    17781   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    17782   ; {
                    17783   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    17784   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    17785   ; }
                    17786   ; */
                    17787   _printf:
00005E0A  4E56 FFFC 17788          link      A6,#-4
00005E0E  2F02      17789          move.l    D2,-(A7)
00005E10  41EE 0008 17790          lea       8(A6),A0
00005E14  5848      17791          addq.w    #4,A0
00005E16  2408      17792          move.l    A0,D2
00005E18  2F02      17793          move.l    D2,-(A7)
00005E1A  2F2E 0008 17794          move.l    8(A6),-(A7)
00005E1E  42A7      17795          clr.l     -(A7)
00005E20  4EB9 0000 17796          jsr       _doprint
00005E24  605E      
00005E26  DEFC 000C 17797          add.w     #12,A7
00005E2A  2D40 FFFC 17798          move.l    D0,-4(A6)
00005E2E  4282      17799          clr.l     D2
00005E30  202E FFFC 17800          move.l    -4(A6),D0
00005E34  241F      17801          move.l    (A7)+,D2
00005E36  4E5E      17802          unlk      A6
00005E38  4E75      17803          rts
                    17804   ULMUL:
00005E3A  4E56 0000 17805          link    A6,#0
00005E3E  48E7 C000 17806          movem.l D0/D1,-(A7)
00005E42  222E 0008 17807          move.l  8(A6),D1
00005E46  202E 000C 17808          move.l  12(A6),D0
00005E4A  602C      17809          bra.s   lmul_3
                    17810   LMUL:
00005E4C  4E56 0000 17811          link    A6,#0
00005E50  48E7 C000 17812          movem.l D0/D1,-(A7)
00005E54  222E 0008 17813          move.l  8(A6),D1
00005E58  202E 000C 17814          move.l  12(A6),D0
00005E5C  4A80      17815          tst.l   D0
00005E5E  6A0A      17816          bpl.s   lmul_1
00005E60  4480      17817          neg.l   D0
00005E62  4A81      17818          tst.l   D1
00005E64  6A0A      17819          bpl.s   lmul_2
00005E66  4481      17820          neg.l   D1
00005E68  600E      17821          bra.s   lmul_3
                    17822   lmul_1:
00005E6A  4A81      17823          tst.l   D1
00005E6C  6A0A      17824          bpl.s   lmul_3
00005E6E  4481      17825          neg.l   D1
                    17826   lmul_2:
00005E70  6114      17827          bsr.s   domul
00005E72  4481      17828          neg.l   D1
00005E74  4080      17829          negx.l  D0
00005E76  6002      17830          bra.s   lmul_4
                    17831   lmul_3:
00005E78  610C      17832          bsr.s   domul
                    17833   lmul_4:
00005E7A  2D41 0008 17834          move.l  D1,8(A6)
00005E7E  4CDF 0003 17835          movem.l (A7)+,D0/D1
00005E82  4E5E      17836          unlk    A6
00005E84  4E75      17837          rts
                    17838   domul:
00005E86  0C81 0000 17839          cmpi.l  #$FFFF,D1
00005E8A  FFFF      
00005E8C  620C      17840          bhi.s   domul_1
00005E8E  0C80 0000 17841          cmpi.l  #$FFFF,D0
00005E92  FFFF      
00005E94  620E      17842          bhi.s   domul_2
00005E96  C2C0      17843          mulu    D0,D1
00005E98  4E75      17844          rts
                    17845   domul_1:
00005E9A  0C80 0000 17846          cmpi.l  #$FFFF,D0
00005E9E  FFFF      
00005EA0  6218      17847          bhi.s   domul_4
00005EA2  6002      17848          bra.s   domul_3
                    17849   domul_2
00005EA4  C141      17850          exg     D0,D1
                    17851   domul_3:
00005EA6  2F02      17852          move.l  D2,-(A7)
00005EA8  2401      17853          move.l  D1,D2
00005EAA  4842      17854          swap    D2
00005EAC  C2C0      17855          mulu    D0,D1
00005EAE  C4C0      17856          mulu    D0,D2
00005EB0  4842      17857          swap    D2
00005EB2  4242      17858          clr.w   D2
00005EB4  D282      17859          add.l   D2,D1
00005EB6  241F      17860          move.l  (A7)+,D2
00005EB8  4E75      17861          rts
                    17862   domul_4:
00005EBA  48E7 3000 17863          movem.l D2/D3,-(A7)
00005EBE  2401      17864          move.l  D1,D2
00005EC0  2601      17865          move.l  D1,D3
00005EC2  C2C0      17866          mulu    D0,D1
00005EC4  4842      17867          swap    D2
00005EC6  C4C0      17868          mulu    D0,D2
00005EC8  4840      17869          swap    D0
00005ECA  C6C0      17870          mulu    D0,D3
00005ECC  D483      17871          add.l   D3,D2
00005ECE  4842      17872          swap    D2
00005ED0  4242      17873          clr.w   D2
00005ED2  D282      17874          add.l   D2,D1
00005ED4  4CDF 000C 17875          movem.l (A7)+,D2/D3
00005ED8  4E75      17876          rts
                    17877   ULDIV:
00005EDA  4E56 0000 17878          link    A6,#0
00005EDE  48E7 C000 17879          movem.l D0/D1,-(A7)
00005EE2  222E 0008 17880          move.l  8(A6),D1
00005EE6  202E 000C 17881          move.l  12(A6),D0
00005EEA  6036      17882          bra.s   ldiv_3
                    17883   LDIV:
00005EEC  4E56 0000 17884          link    A6,#0
00005EF0  48E7 C000 17885          movem.l D0/D1,-(A7)
00005EF4  222E 0008 17886          move.l  8(A6),D1
00005EF8  202E 000C 17887          move.l  12(A6),D0
00005EFC  4A80      17888          tst.l   D0
00005EFE  6A0E      17889          bpl.s   ldiv_1
00005F00  4480      17890          neg.l   D0
00005F02  4A81      17891          tst.l   D1
00005F04  6A14      17892          bpl.s   ldiv_2
00005F06  4481      17893          neg.l   D1
00005F08  612A      17894          bsr.s   dodiv
00005F0A  4481      17895          neg.l   D1
00005F0C  6016      17896          bra.s   ldiv_4
                    17897   ldiv_1:
00005F0E  4A81      17898          tst.l   D1
00005F10  6A10      17899          bpl.s   ldiv_3
00005F12  4481      17900          neg.l   D1
00005F14  611E      17901          bsr.s   dodiv
00005F16  4480      17902          neg.l   D0
00005F18  600A      17903          bra.s   ldiv_4
                    17904   ldiv_2:
00005F1A  6118      17905          bsr.s   dodiv
00005F1C  4480      17906          neg.l   D0
00005F1E  4481      17907          neg.l   D1
00005F20  6002      17908          bra.s   ldiv_4
                    17909   ldiv_3:
00005F22  6110      17910          bsr.s   dodiv
                    17911   ldiv_4:
00005F24  2D40 0008 17912          move.l  D0,8(A6)
00005F28  2D41 000C 17913          move.l  D1,12(A6)
00005F2C  4CDF 0003 17914          movem.l (A7)+,D0/D1
00005F30  4E5E      17915          unlk    A6
00005F32  4E75      17916          rts
                    17917   dodiv:
00005F34  0C81 0000 17918          cmpi.l  #$FFFF,D1
00005F38  FFFF      
00005F3A  6236      17919          bhi.s   dodiv_2
00005F3C  0C80 0000 17920          cmpi.l  #$FFFF,D0
00005F40  FFFF      
00005F42  6210      17921          bhi.s   dodiv_1
00005F44  80C1      17922          divu    D1,D0
00005F46  2200      17923          move.l  D0,D1
00005F48  4241      17924          clr.w   D1
00005F4A  4841      17925          swap    D1
00005F4C  0280 0000 17926          andi.l  #$FFFF,D0
00005F50  FFFF      
00005F52  4E75      17927          rts
                    17928   dodiv_1:
00005F54  48A7 A000 17929          movem.w D0/D2,-(A7)
00005F58  4240      17930          clr.w   D0
00005F5A  4840      17931          swap    D0
00005F5C  80C1      17932          divu    D1,D0
00005F5E  3400      17933          move.w  D0,D2
00005F60  301F      17934          move.w  (A7)+,D0
00005F62  80C1      17935          divu    D1,D0
00005F64  4840      17936          swap    D0
00005F66  4281      17937          clr.l   D1
00005F68  3200      17938          move.w  D0,D1
00005F6A  3002      17939          move.w  D2,D0
00005F6C  4840      17940          swap    D0
00005F6E  341F      17941          move.w  (A7)+,D2
00005F70  4E75      17942          rts
                    17943   dodiv_2:
00005F72  48E7 3800 17944          movem.l D2/D3/D4,-(A7)
00005F76  2401      17945          move.l  D1,D2
00005F78  4242      17946          clr.w   D2
00005F7A  4842      17947          swap    D2
00005F7C  5282      17948          addq.l  #1,D2
00005F7E  2600      17949          move.l  D0,D3
00005F80  2801      17950          move.l  D1,D4
00005F82  2202      17951          move.l  D2,D1
00005F84  61CE      17952          bsr.s   dodiv_1
00005F86  2204      17953          move.l  D4,D1
00005F88  82C2      17954          divu    D2,D1
00005F8A  80C1      17955          divu    D1,D0
00005F8C  0280 0000 17956          andi.l  #$FFFF,D0
00005F90  FFFF      
                    17957   dodiv_3:
00005F92  2204      17958          move.l  D4,D1
00005F94  2404      17959          move.l  D4,D2
00005F96  4842      17960          swap    D2
00005F98  C2C0      17961          mulu    D0,D1
00005F9A  C4C0      17962          mulu    D0,D2
00005F9C  4842      17963          swap    D2
00005F9E  D282      17964          add.l   D2,D1
00005FA0  9283      17965          sub.l   D3,D1
00005FA2  620A      17966          bhi.s   dodiv_4
00005FA4  4481      17967          neg.l   D1
00005FA6  B881      17968          cmp.l   D1,D4
00005FA8  6208      17969          bhi.s   dodiv_5
00005FAA  5280      17970          addq.l  #1,D0
00005FAC  60E4      17971          bra.s   dodiv_3
                    17972   dodiv_4:
00005FAE  5380      17973          subq.l  #1,D0
00005FB0  60E0      17974          bra.s   dodiv_3
                    17975   dodiv_5:
00005FB2  4CDF 001C 17976          movem.l (A7)+,D2/D3/D4
00005FB6  4E75      17977          rts
                    17978   @doprint_copy:
00005FB8  4E56 0000 17979          link      A6,#0
00005FBC  206E 0008 17980          move.l    8(A6),A0
00005FC0  4A90      17981          tst.l     (A0)
00005FC2  6710      17982          beq.s     @doprint_copy_1
00005FC4  202E 000C 17983          move.l    12(A6),D0
00005FC8  206E 0008 17984          move.l    8(A6),A0
00005FCC  2250      17985          move.l    (A0),A1
00005FCE  5290      17986          addq.l    #1,(A0)
00005FD0  1280      17987          move.b    D0,(A1)
00005FD2  600C      17988          bra.s     @doprint_copy_2
                    17989   @doprint_copy_1:
00005FD4  2F2E 000C 17990          move.l    12(A6),-(A7)
00005FD8  4EB9 0000 17991          jsr       _putch
00005FDC  67FE      
00005FDE  584F      17992          addq.w    #4,A7
                    17993   @doprint_copy_2:
00005FE0  4E5E      17994          unlk      A6
00005FE2  4E75      17995          rts
                    17996   @doprint_getval:
00005FE4  4E56 0000 17997          link      A6,#0
00005FE8  48E7 3000 17998          movem.l   D2/D3,-(A7)
00005FEC  262E 0008 17999          move.l    8(A6),D3
00005FF0  4282      18000          clr.l     D2
00005FF2  2043      18001          move.l    D3,A0
00005FF4  2050      18002          move.l    (A0),A0
00005FF6  1010      18003          move.b    (A0),D0
00005FF8  0C00 002A 18004          cmp.b     #42,D0
00005FFC  6612      18005          bne.s     @doprint_getval_1
00005FFE  206E 000C 18006          move.l    12(A6),A0
00006002  2250      18007          move.l    (A0),A1
00006004  5890      18008          addq.l    #4,(A0)
00006006  2411      18009          move.l    (A1),D2
00006008  2043      18010          move.l    D3,A0
0000600A  5290      18011          addq.l    #1,(A0)
0000600C  6000 0046 18012          bra       @doprint_getval_5
                    18013   @doprint_getval_1:
00006010  7001      18014          moveq     #1,D0
00006012  2043      18015          move.l    D3,A0
00006014  2050      18016          move.l    (A0),A0
00006016  1210      18017          move.b    (A0),D1
00006018  4881      18018          ext.w     D1
0000601A  48C1      18019          ext.l     D1
0000601C  D081      18020          add.l     D1,D0
0000601E  41F9 0000 18021          lea       __ctype.L,A0
00006022  6A02      
00006024  1030 0800 18022          move.b    0(A0,D0.L),D0
00006028  C03C 0004 18023          and.b     #4,D0
0000602C  6726      18024          beq.s     @doprint_getval_5
0000602E  2F02      18025          move.l    D2,-(A7)
00006030  4878 000A 18026          pea       10
00006034  4EB8 5E4C 18027          jsr       LMUL
00006038  2017      18028          move.l    (A7),D0
0000603A  504F      18029          addq.w    #8,A7
0000603C  2043      18030          move.l    D3,A0
0000603E  2250      18031          move.l    (A0),A1
00006040  5290      18032          addq.l    #1,(A0)
00006042  1211      18033          move.b    (A1),D1
00006044  4881      18034          ext.w     D1
00006046  48C1      18035          ext.l     D1
00006048  D081      18036          add.l     D1,D0
0000604A  0480 0000 18037          sub.l     #48,D0
0000604E  0030      
00006050  2400      18038          move.l    D0,D2
00006052  60BC      18039          bra       @doprint_getval_1
                    18040   @doprint_getval_5:
00006054  2002      18041          move.l    D2,D0
00006056  4CDF 000C 18042          movem.l   (A7)+,D2/D3
0000605A  4E5E      18043          unlk      A6
0000605C  4E75      18044          rts
                    18045   _doprint:
0000605E  4E56 FFCC 18046          link      A6,#-52
00006062  48E7 3F3C 18047          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00006066  45EE 0008 18048          lea       8(A6),A2
0000606A  47F8 5FB8 18049          lea       @doprint_copy.L,A3
0000606E  49F9 0000 18050          lea       _ultoa.L,A4
00006072  678A      
00006074  4286      18051          clr.l     D6
                    18052   doprint_1:
00006076  206E 000C 18053          move.l    12(A6),A0
0000607A  4A10      18054          tst.b     (A0)
0000607C  6700 05EC 18055          beq       doprint_3
00006080  206E 000C 18056          move.l    12(A6),A0
00006084  1010      18057          move.b    (A0),D0
00006086  0C00 0025 18058          cmp.b     #37,D0
0000608A  671C      18059          beq.s     doprint_4
0000608C  206E 000C 18060          move.l    12(A6),A0
00006090  52AE 000C 18061          addq.l    #1,12(A6)
00006094  1210      18062          move.b    (A0),D1
00006096  4881      18063          ext.w     D1
00006098  48C1      18064          ext.l     D1
0000609A  2F01      18065          move.l    D1,-(A7)
0000609C  2F0A      18066          move.l    A2,-(A7)
0000609E  4E93      18067          jsr       (A3)
000060A0  504F      18068          addq.w    #8,A7
000060A2  5286      18069          addq.l    #1,D6
000060A4  6000 05C0 18070          bra       doprint_2
                    18071   doprint_4:
000060A8  52AE 000C 18072          addq.l    #1,12(A6)
000060AC  422E FFD3 18073          clr.b     -45(A6)
000060B0  422E FFD2 18074          clr.b     -46(A6)
000060B4  422E FFD0 18075          clr.b     -48(A6)
000060B8  422E FFCF 18076          clr.b     -49(A6)
000060BC  422E FFCE 18077          clr.b     -50(A6)
000060C0  422E FFCD 18078          clr.b     -51(A6)
000060C4  42AE FFFC 18079          clr.l     -4(A6)
000060C8  7AFF      18080          moveq     #-1,D5
000060CA  41EE FFDC 18081          lea       -36(A6),A0
000060CE  2608      18082          move.l    A0,D3
000060D0  2408      18083          move.l    A0,D2
                    18084   doprint_6:
000060D2  206E 000C 18085          move.l    12(A6),A0
000060D6  1010      18086          move.b    (A0),D0
000060D8  4880      18087          ext.w     D0
000060DA  48C0      18088          ext.l     D0
000060DC  0C80 0000 18089          cmp.l     #43,D0
000060E0  002B      
000060E2  6730      18090          beq.s     doprint_12
000060E4  6E18      18091          bgt.s     doprint_15
000060E6  0C80 0000 18092          cmp.l     #35,D0
000060EA  0023      
000060EC  6700 003E 18093          beq       doprint_14
000060F0  6E00 0046 18094          bgt       doprint_9
000060F4  0C80 0000 18095          cmp.l     #32,D0
000060F8  0020      
000060FA  6724      18096          beq.s     doprint_13
000060FC  603A      18097          bra.s     doprint_9
                    18098   doprint_15:
000060FE  0C80 0000 18099          cmp.l     #45,D0
00006102  002D      
00006104  6702      18100          beq.s     doprint_11
00006106  6030      18101          bra.s     doprint_9
                    18102   doprint_11:
00006108  1D7C 0001 18103          move.b    #1,-51(A6)
0000610C  FFCD      
0000610E  52AE 000C 18104          addq.l    #1,12(A6)
00006112  6026      18105          bra.s     doprint_7
                    18106   doprint_12:
00006114  1D7C 0001 18107          move.b    #1,-50(A6)
00006118  FFCE      
0000611A  52AE 000C 18108          addq.l    #1,12(A6)
0000611E  601A      18109          bra.s     doprint_7
                    18110   doprint_13:
00006120  1D7C 0001 18111          move.b    #1,-49(A6)
00006124  FFCF      
00006126  52AE 000C 18112          addq.l    #1,12(A6)
0000612A  600E      18113          bra.s     doprint_7
                    18114   doprint_14:
0000612C  1D7C 0001 18115          move.b    #1,-48(A6)
00006130  FFD0      
00006132  52AE 000C 18116          addq.l    #1,12(A6)
00006136  6002      18117          bra.s     doprint_7
                    18118   doprint_9:
00006138  6002      18119          bra.s     doprint_8
                    18120   doprint_7:
0000613A  6096      18121          bra       doprint_6
                    18122   doprint_8:
0000613C  206E 000C 18123          move.l    12(A6),A0
00006140  1010      18124          move.b    (A0),D0
00006142  0C00 0030 18125          cmp.b     #48,D0
00006146  660A      18126          bne.s     doprint_16
00006148  52AE 000C 18127          addq.l    #1,12(A6)
0000614C  1D7C 0001 18128          move.b    #1,-46(A6)
00006150  FFD2      
                    18129   doprint_16:
00006152  486E 0010 18130          pea       16(A6)
00006156  486E 000C 18131          pea       12(A6)
0000615A  4EB8 5FE4 18132          jsr       @doprint_getval
0000615E  504F      18133          addq.w    #8,A7
00006160  2A40      18134          move.l    D0,A5
00006162  206E 000C 18135          move.l    12(A6),A0
00006166  1010      18136          move.b    (A0),D0
00006168  0C00 002E 18137          cmp.b     #46,D0
0000616C  6614      18138          bne.s     doprint_18
0000616E  52AE 000C 18139          addq.l    #1,12(A6)
00006172  486E 0010 18140          pea       16(A6)
00006176  486E 000C 18141          pea       12(A6)
0000617A  4EB8 5FE4 18142          jsr       @doprint_getval
0000617E  504F      18143          addq.w    #8,A7
00006180  2A00      18144          move.l    D0,D5
                    18145   doprint_18:
00006182  206E 000C 18146          move.l    12(A6),A0
00006186  1010      18147          move.b    (A0),D0
00006188  0C00 006C 18148          cmp.b     #108,D0
0000618C  660A      18149          bne.s     doprint_20
0000618E  52AE 000C 18150          addq.l    #1,12(A6)
00006192  1D7C 0001 18151          move.b    #1,-45(A6)
00006196  FFD3      
                    18152   doprint_20:
00006198  206E 000C 18153          move.l    12(A6),A0
0000619C  1010      18154          move.b    (A0),D0
0000619E  4880      18155          ext.w     D0
000061A0  48C0      18156          ext.l     D0
000061A2  0C80 0000 18157          cmp.l     #111,D0
000061A6  006F      
000061A8  6700 00D8 18158          beq       doprint_27
000061AC  6E34      18159          bgt.s     doprint_33
000061AE  0C80 0000 18160          cmp.l     #100,D0
000061B2  0064      
000061B4  6700 0054 18161          beq       doprint_24
000061B8  6E1C      18162          bgt.s     doprint_34
000061BA  0C80 0000 18163          cmp.l     #99,D0
000061BE  0063      
000061C0  6700 0130 18164          beq       doprint_30
000061C4  6E00 0174 18165          bgt       doprint_22
000061C8  0C80 0000 18166          cmp.l     #88,D0
000061CC  0058      
000061CE  6700 00EA 18167          beq       doprint_28
000061D2  6000 0166 18168          bra       doprint_22
                    18169   doprint_34:
000061D6  0C80 0000 18170          cmp.l     #105,D0
000061DA  0069      
000061DC  672C      18171          beq.s     doprint_24
000061DE  6000 015A 18172          bra       doprint_22
                    18173   doprint_33:
000061E2  0C80 0000 18174          cmp.l     #117,D0
000061E6  0075      
000061E8  6700 0060 18175          beq       doprint_26
000061EC  6E0E      18176          bgt.s     doprint_35
000061EE  0C80 0000 18177          cmp.l     #115,D0
000061F2  0073      
000061F4  6700 0124 18178          beq       doprint_31
000061F8  6000 0140 18179          bra       doprint_22
                    18180   doprint_35:
000061FC  0C80 0000 18181          cmp.l     #120,D0
00006200  0078      
00006202  6700 00B6 18182          beq       doprint_28
00006206  6000 0132 18183          bra       doprint_22
                    18184   doprint_24:
0000620A  4A2E FFD3 18185          tst.b     -45(A6)
0000620E  671C      18186          beq.s     doprint_36
00006210  4878 000A 18187          pea       10
00006214  2F03      18188          move.l    D3,-(A7)
00006216  206E 0010 18189          move.l    16(A6),A0
0000621A  58AE 0010 18190          addq.l    #4,16(A6)
0000621E  2F10      18191          move.l    (A0),-(A7)
00006220  4EB9 0000 18192          jsr       _ltoa
00006224  6704      
00006226  DEFC 000C 18193          add.w     #12,A7
0000622A  601A      18194          bra.s     doprint_37
                    18195   doprint_36:
0000622C  4878 000A 18196          pea       10
00006230  2F03      18197          move.l    D3,-(A7)
00006232  206E 0010 18198          move.l    16(A6),A0
00006236  58AE 0010 18199          addq.l    #4,16(A6)
0000623A  2F10      18200          move.l    (A0),-(A7)
0000623C  4EB9 0000 18201          jsr       _ltoa
00006240  6704      
00006242  DEFC 000C 18202          add.w     #12,A7
                    18203   doprint_37:
00006246  6000 0100 18204          bra       doprint_23
                    18205   doprint_26:
0000624A  4A2E FFD3 18206          tst.b     -45(A6)
0000624E  6718      18207          beq.s     doprint_38
00006250  4878 000A 18208          pea       10
00006254  2F03      18209          move.l    D3,-(A7)
00006256  206E 0010 18210          move.l    16(A6),A0
0000625A  58AE 0010 18211          addq.l    #4,16(A6)
0000625E  2F10      18212          move.l    (A0),-(A7)
00006260  4E94      18213          jsr       (A4)
00006262  DEFC 000C 18214          add.w     #12,A7
00006266  6016      18215          bra.s     doprint_39
                    18216   doprint_38:
00006268  4878 000A 18217          pea       10
0000626C  2F03      18218          move.l    D3,-(A7)
0000626E  206E 0010 18219          move.l    16(A6),A0
00006272  58AE 0010 18220          addq.l    #4,16(A6)
00006276  2F10      18221          move.l    (A0),-(A7)
00006278  4E94      18222          jsr       (A4)
0000627A  DEFC 000C 18223          add.w     #12,A7
                    18224   doprint_39:
0000627E  6000 00C8 18225          bra       doprint_23
                    18226   doprint_27:
00006282  4A2E FFD3 18227          tst.b     -45(A6)
00006286  6718      18228          beq.s     doprint_40
00006288  4878 0008 18229          pea       8
0000628C  2F03      18230          move.l    D3,-(A7)
0000628E  206E 0010 18231          move.l    16(A6),A0
00006292  58AE 0010 18232          addq.l    #4,16(A6)
00006296  2F10      18233          move.l    (A0),-(A7)
00006298  4E94      18234          jsr       (A4)
0000629A  DEFC 000C 18235          add.w     #12,A7
0000629E  6016      18236          bra.s     doprint_41
                    18237   doprint_40:
000062A0  4878 0008 18238          pea       8
000062A4  2F03      18239          move.l    D3,-(A7)
000062A6  206E 0010 18240          move.l    16(A6),A0
000062AA  58AE 0010 18241          addq.l    #4,16(A6)
000062AE  2F10      18242          move.l    (A0),-(A7)
000062B0  4E94      18243          jsr       (A4)
000062B2  DEFC 000C 18244          add.w     #12,A7
                    18245   doprint_41:
000062B6  6000 0090 18246          bra       doprint_23
                    18247   doprint_28:
000062BA  4A2E FFD3 18248          tst.b     -45(A6)
000062BE  6718      18249          beq.s     doprint_42
000062C0  4878 0010 18250          pea       16
000062C4  2F03      18251          move.l    D3,-(A7)
000062C6  206E 0010 18252          move.l    16(A6),A0
000062CA  58AE 0010 18253          addq.l    #4,16(A6)
000062CE  2F10      18254          move.l    (A0),-(A7)
000062D0  4E94      18255          jsr       (A4)
000062D2  DEFC 000C 18256          add.w     #12,A7
000062D6  6016      18257          bra.s     doprint_43
                    18258   doprint_42:
000062D8  4878 0010 18259          pea       16
000062DC  2F03      18260          move.l    D3,-(A7)
000062DE  206E 0010 18261          move.l    16(A6),A0
000062E2  58AE 0010 18262          addq.l    #4,16(A6)
000062E6  2F10      18263          move.l    (A0),-(A7)
000062E8  4E94      18264          jsr       (A4)
000062EA  DEFC 000C 18265          add.w     #12,A7
                    18266   doprint_43:
000062EE  6000 0058 18267          bra       doprint_23
                    18268   doprint_30:
000062F2  206E 0010 18269          move.l    16(A6),A0
000062F6  58AE 0010 18270          addq.l    #4,16(A6)
000062FA  2010      18271          move.l    (A0),D0
000062FC  2042      18272          move.l    D2,A0
000062FE  5282      18273          addq.l    #1,D2
00006300  1080      18274          move.b    D0,(A0)
00006302  2042      18275          move.l    D2,A0
00006304  4210      18276          clr.b     (A0)
00006306  200D      18277          move.l    A5,D0
00006308  6704      18278          beq.s     doprint_44
0000630A  200D      18279          move.l    A5,D0
0000630C  6006      18280          bra.s     doprint_45
                    18281   doprint_44:
0000630E  7001      18282          moveq     #1,D0
00006310  4880      18283          ext.w     D0
00006312  48C0      18284          ext.l     D0
                    18285   doprint_45:
00006314  2A00      18286          move.l    D0,D5
00006316  6000 0030 18287          bra       doprint_23
                    18288   doprint_31:
0000631A  206E 0010 18289          move.l    16(A6),A0
0000631E  58AE 0010 18290          addq.l    #4,16(A6)
00006322  2610      18291          move.l    (A0),D3
00006324  0C85 FFFF 18292          cmp.l     #-1,D5
00006328  FFFF      
0000632A  660C      18293          bne.s     doprint_46
0000632C  2F03      18294          move.l    D3,-(A7)
0000632E  4EB9 0000 18295          jsr       _strlen
00006332  67EC      
00006334  584F      18296          addq.w    #4,A7
00006336  2A00      18297          move.l    D0,D5
                    18298   doprint_46:
00006338  600E      18299          bra.s     doprint_23
                    18300   doprint_22:
0000633A  206E 000C 18301          move.l    12(A6),A0
0000633E  2242      18302          move.l    D2,A1
00006340  5282      18303          addq.l    #1,D2
00006342  1290      18304          move.b    (A0),(A1)
00006344  2042      18305          move.l    D2,A0
00006346  4210      18306          clr.b     (A0)
                    18307   doprint_23:
00006348  2F03      18308          move.l    D3,-(A7)
0000634A  4EB9 0000 18309          jsr       _strlen
0000634E  67EC      
00006350  584F      18310          addq.w    #4,A7
00006352  1800      18311          move.b    D0,D4
00006354  206E 000C 18312          move.l    12(A6),A0
00006358  1010      18313          move.b    (A0),D0
0000635A  0C00 0073 18314          cmp.b     #115,D0
0000635E  661C      18315          bne.s     doprint_48
00006360  0C85 0000 18316          cmp.l     #0,D5
00006364  0000      
00006366  6D14      18317          blt.s     doprint_48
00006368  4884      18318          ext.w     D4
0000636A  48C4      18319          ext.l     D4
0000636C  B885      18320          cmp.l     D5,D4
0000636E  6F04      18321          ble.s     doprint_50
00006370  2005      18322          move.l    D5,D0
00006372  6006      18323          bra.s     doprint_51
                    18324   doprint_50:
00006374  1004      18325          move.b    D4,D0
00006376  4880      18326          ext.w     D0
00006378  48C0      18327          ext.l     D0
                    18328   doprint_51:
0000637A  1800      18329          move.b    D0,D4
                    18330   doprint_48:
0000637C  206E 000C 18331          move.l    12(A6),A0
00006380  1010      18332          move.b    (A0),D0
00006382  0C00 0058 18333          cmp.b     #88,D0
00006386  6600 0028 18334          bne       doprint_56
0000638A  41EE FFDC 18335          lea       -36(A6),A0
0000638E  2408      18336          move.l    A0,D2
                    18337   doprint_54:
00006390  2042      18338          move.l    D2,A0
00006392  4A10      18339          tst.b     (A0)
00006394  671A      18340          beq.s     doprint_56
00006396  2042      18341          move.l    D2,A0
00006398  1210      18342          move.b    (A0),D1
0000639A  4881      18343          ext.w     D1
0000639C  48C1      18344          ext.l     D1
0000639E  2F01      18345          move.l    D1,-(A7)
000063A0  4EB9 0000 18346          jsr       _toupper
000063A4  682A      
000063A6  584F      18347          addq.w    #4,A7
000063A8  2042      18348          move.l    D2,A0
000063AA  1080      18349          move.b    D0,(A0)
000063AC  5282      18350          addq.l    #1,D2
000063AE  60E0      18351          bra       doprint_54
                    18352   doprint_56:
000063B0  7E00      18353          moveq     #0,D7
000063B2  41EE FFD4 18354          lea       -44(A6),A0
000063B6  2408      18355          move.l    A0,D2
000063B8  206E 000C 18356          move.l    12(A6),A0
000063BC  1010      18357          move.b    (A0),D0
000063BE  0C00 0064 18358          cmp.b     #100,D0
000063C2  670E      18359          beq.s     doprint_59
000063C4  206E 000C 18360          move.l    12(A6),A0
000063C8  1010      18361          move.b    (A0),D0
000063CA  0C00 0069 18362          cmp.b     #105,D0
000063CE  6600 0068 18363          bne       doprint_65
                    18364   doprint_59:
000063D2  102E FFCE 18365          move.b    -50(A6),D0
000063D6  4880      18366          ext.w     D0
000063D8  48C0      18367          ext.l     D0
000063DA  4A80      18368          tst.l     D0
000063DC  660C      18369          bne.s     doprint_62
000063DE  2043      18370          move.l    D3,A0
000063E0  1010      18371          move.b    (A0),D0
000063E2  0C00 002D 18372          cmp.b     #45,D0
000063E6  6600 0028 18373          bne       doprint_60
                    18374   doprint_62:
000063EA  2043      18375          move.l    D3,A0
000063EC  1010      18376          move.b    (A0),D0
000063EE  0C00 002D 18377          cmp.b     #45,D0
000063F2  660E      18378          bne.s     doprint_63
000063F4  2043      18379          move.l    D3,A0
000063F6  5283      18380          addq.l    #1,D3
000063F8  2242      18381          move.l    D2,A1
000063FA  5282      18382          addq.l    #1,D2
000063FC  1290      18383          move.b    (A0),(A1)
000063FE  5304      18384          subq.b    #1,D4
00006400  6008      18385          bra.s     doprint_64
                    18386   doprint_63:
00006402  2042      18387          move.l    D2,A0
00006404  5282      18388          addq.l    #1,D2
00006406  10BC 002B 18389          move.b    #43,(A0)
                    18390   doprint_64:
0000640A  5287      18391          addq.l    #1,D7
0000640C  6000 002A 18392          bra       doprint_65
                    18393   doprint_60:
00006410  4A2E FFCF 18394          tst.b     -49(A6)
00006414  6722      18395          beq.s     doprint_65
00006416  2043      18396          move.l    D3,A0
00006418  1010      18397          move.b    (A0),D0
0000641A  0C00 002D 18398          cmp.b     #45,D0
0000641E  660E      18399          bne.s     doprint_67
00006420  2043      18400          move.l    D3,A0
00006422  5283      18401          addq.l    #1,D3
00006424  2242      18402          move.l    D2,A1
00006426  5282      18403          addq.l    #1,D2
00006428  1290      18404          move.b    (A0),(A1)
0000642A  5304      18405          subq.b    #1,D4
0000642C  6008      18406          bra.s     doprint_68
                    18407   doprint_67:
0000642E  2042      18408          move.l    D2,A0
00006430  5282      18409          addq.l    #1,D2
00006432  10BC 0020 18410          move.b    #32,(A0)
                    18411   doprint_68:
00006436  5287      18412          addq.l    #1,D7
                    18413   doprint_65:
00006438  4A2E FFD0 18414          tst.b     -48(A6)
0000643C  6700 005A 18415          beq       doprint_77
00006440  206E 000C 18416          move.l    12(A6),A0
00006444  1010      18417          move.b    (A0),D0
00006446  4880      18418          ext.w     D0
00006448  48C0      18419          ext.l     D0
0000644A  0C80 0000 18420          cmp.l     #111,D0
0000644E  006F      
00006450  671A      18421          beq.s     doprint_73
00006452  6E0C      18422          bgt.s     doprint_76
00006454  0C80 0000 18423          cmp.l     #88,D0
00006458  0058      
0000645A  6710      18424          beq.s     doprint_73
0000645C  6000 003A 18425          bra       doprint_77
                    18426   doprint_76:
00006460  0C80 0000 18427          cmp.l     #120,D0
00006464  0078      
00006466  6704      18428          beq.s     doprint_73
00006468  6000 002E 18429          bra       doprint_77
                    18430   doprint_73:
0000646C  2042      18431          move.l    D2,A0
0000646E  5282      18432          addq.l    #1,D2
00006470  10BC 0030 18433          move.b    #48,(A0)
00006474  5287      18434          addq.l    #1,D7
00006476  206E 000C 18435          move.l    12(A6),A0
0000647A  1010      18436          move.b    (A0),D0
0000647C  0C00 0078 18437          cmp.b     #120,D0
00006480  670C      18438          beq.s     doprint_79
00006482  206E 000C 18439          move.l    12(A6),A0
00006486  1010      18440          move.b    (A0),D0
00006488  0C00 0058 18441          cmp.b     #88,D0
0000648C  660A      18442          bne.s     doprint_77
                    18443   doprint_79:
0000648E  2042      18444          move.l    D2,A0
00006490  5282      18445          addq.l    #1,D2
00006492  10BC 0078 18446          move.b    #120,(A0)
00006496  5287      18447          addq.l    #1,D7
                    18448   doprint_77:
00006498  2042      18449          move.l    D2,A0
0000649A  4210      18450          clr.b     (A0)
0000649C  206E 000C 18451          move.l    12(A6),A0
000064A0  1010      18452          move.b    (A0),D0
000064A2  4880      18453          ext.w     D0
000064A4  48C0      18454          ext.l     D0
000064A6  0C80 0000 18455          cmp.l     #105,D0
000064AA  0069      
000064AC  6700 0076 18456          beq       doprint_82
000064B0  6E42      18457          bgt.s     doprint_93
000064B2  0C80 0000 18458          cmp.l     #99,D0
000064B6  0063      
000064B8  6700 0084 18459          beq       doprint_96
000064BC  6E1C      18460          bgt.s     doprint_94
000064BE  0C80 0000 18461          cmp.l     #88,D0
000064C2  0058      
000064C4  6700 005E 18462          beq       doprint_82
000064C8  6E00 0184 18463          bgt       doprint_80
000064CC  0C80 0000 18464          cmp.l     #69,D0
000064D0  0045      
000064D2  6700 0050 18465          beq       doprint_82
000064D6  6000 0176 18466          bra       doprint_80
                    18467   doprint_94:
000064DA  0C80 0000 18468          cmp.l     #101,D0
000064DE  0065      
000064E0  6700 0042 18469          beq       doprint_82
000064E4  6E00 0168 18470          bgt       doprint_80
000064E8  0C80 0000 18471          cmp.l     #100,D0
000064EC  0064      
000064EE  6734      18472          beq.s     doprint_82
000064F0  6000 015C 18473          bra       doprint_80
                    18474   doprint_93:
000064F4  0C80 0000 18475          cmp.l     #117,D0
000064F8  0075      
000064FA  6728      18476          beq.s     doprint_82
000064FC  6E1A      18477          bgt.s     doprint_95
000064FE  0C80 0000 18478          cmp.l     #115,D0
00006502  0073      
00006504  6700 0038 18479          beq       doprint_96
00006508  6E00 0144 18480          bgt       doprint_80
0000650C  0C80 0000 18481          cmp.l     #111,D0
00006510  006F      
00006512  6710      18482          beq.s     doprint_82
00006514  6000 0138 18483          bra       doprint_80
                    18484   doprint_95:
00006518  0C80 0000 18485          cmp.l     #120,D0
0000651C  0078      
0000651E  6704      18486          beq.s     doprint_82
00006520  6000 012C 18487          bra       doprint_80
                    18488   doprint_82:
00006524  4A2E FFD2 18489          tst.b     -46(A6)
00006528  6714      18490          beq.s     doprint_96
0000652A  4A2E FFCD 18491          tst.b     -51(A6)
0000652E  660E      18492          bne.s     doprint_96
00006530  200D      18493          move.l    A5,D0
00006532  9087      18494          sub.l     D7,D0
00006534  4884      18495          ext.w     D4
00006536  48C4      18496          ext.l     D4
00006538  9084      18497          sub.l     D4,D0
0000653A  2D40 FFFC 18498          move.l    D0,-4(A6)
                    18499   doprint_96:
0000653E  202E FFFC 18500          move.l    -4(A6),D0
00006542  0C80 0000 18501          cmp.l     #0,D0
00006546  0000      
00006548  6C04      18502          bge.s     doprint_98
0000654A  42AE FFFC 18503          clr.l     -4(A6)
                    18504   doprint_98:
0000654E  4A2E FFCD 18505          tst.b     -51(A6)
00006552  6600 0030 18506          bne       doprint_104
00006556  1004      18507          move.b    D4,D0
00006558  4880      18508          ext.w     D0
0000655A  48C0      18509          ext.l     D0
0000655C  D0AE FFFC 18510          add.l     -4(A6),D0
00006560  D087      18511          add.l     D7,D0
00006562  1D40 FFD1 18512          move.b    D0,-47(A6)
                    18513   doprint_102:
00006566  102E FFD1 18514          move.b    -47(A6),D0
0000656A  4880      18515          ext.w     D0
0000656C  48C0      18516          ext.l     D0
0000656E  220D      18517          move.l    A5,D1
00006570  534D      18518          subq.w    #1,A5
00006572  B081      18519          cmp.l     D1,D0
00006574  6C0E      18520          bge.s     doprint_104
00006576  4878 0020 18521          pea       32
0000657A  2F0A      18522          move.l    A2,-(A7)
0000657C  4E93      18523          jsr       (A3)
0000657E  504F      18524          addq.w    #8,A7
00006580  5286      18525          addq.l    #1,D6
00006582  60E2      18526          bra       doprint_102
                    18527   doprint_104:
00006584  41EE FFD4 18528          lea       -44(A6),A0
00006588  2408      18529          move.l    A0,D2
                    18530   doprint_105:
0000658A  2042      18531          move.l    D2,A0
0000658C  4A10      18532          tst.b     (A0)
0000658E  6716      18533          beq.s     doprint_107
00006590  2042      18534          move.l    D2,A0
00006592  5282      18535          addq.l    #1,D2
00006594  1210      18536          move.b    (A0),D1
00006596  4881      18537          ext.w     D1
00006598  48C1      18538          ext.l     D1
0000659A  2F01      18539          move.l    D1,-(A7)
0000659C  2F0A      18540          move.l    A2,-(A7)
0000659E  4E93      18541          jsr       (A3)
000065A0  504F      18542          addq.w    #8,A7
000065A2  5286      18543          addq.l    #1,D6
000065A4  60E4      18544          bra       doprint_105
                    18545   doprint_107:
000065A6  202E FFFC 18546          move.l    -4(A6),D0
000065AA  1D40 FFD1 18547          move.b    D0,-47(A6)
                    18548   doprint_108:
000065AE  102E FFD1 18549          move.b    -47(A6),D0
000065B2  532E FFD1 18550          subq.b    #1,-47(A6)
000065B6  4A00      18551          tst.b     D0
000065B8  670E      18552          beq.s     doprint_110
000065BA  4878 0030 18553          pea       48
000065BE  2F0A      18554          move.l    A2,-(A7)
000065C0  4E93      18555          jsr       (A3)
000065C2  504F      18556          addq.w    #8,A7
000065C4  5286      18557          addq.l    #1,D6
000065C6  60E6      18558          bra       doprint_108
                    18559   doprint_110:
000065C8  2043      18560          move.l    D3,A0
000065CA  4A10      18561          tst.b     (A0)
000065CC  6700 0048 18562          beq       doprint_113
000065D0  206E 000C 18563          move.l    12(A6),A0
000065D4  1010      18564          move.b    (A0),D0
000065D6  4880      18565          ext.w     D0
000065D8  48C0      18566          ext.l     D0
000065DA  0C80 0000 18567          cmp.l     #115,D0
000065DE  0073      
000065E0  670C      18568          beq.s     doprint_116
000065E2  6E18      18569          bgt.s     doprint_119
000065E4  0C80 0000 18570          cmp.l     #99,D0
000065E8  0063      
000065EA  6702      18571          beq.s     doprint_116
000065EC  600E      18572          bra.s     doprint_119
                    18573   doprint_116:
000065EE  2005      18574          move.l    D5,D0
000065F0  5385      18575          subq.l    #1,D5
000065F2  0C80 0000 18576          cmp.l     #0,D0
000065F6  0000      
000065F8  6E02      18577          bgt.s     doprint_119
000065FA  6016      18578          bra.s     doprint_115
                    18579   doprint_119:
000065FC  2043      18580          move.l    D3,A0
000065FE  5283      18581          addq.l    #1,D3
00006600  1210      18582          move.b    (A0),D1
00006602  4881      18583          ext.w     D1
00006604  48C1      18584          ext.l     D1
00006606  2F01      18585          move.l    D1,-(A7)
00006608  2F0A      18586          move.l    A2,-(A7)
0000660A  4E93      18587          jsr       (A3)
0000660C  504F      18588          addq.w    #8,A7
0000660E  5286      18589          addq.l    #1,D6
00006610  6002      18590          bra.s     doprint_112
                    18591   doprint_115:
00006612  6002      18592          bra.s     doprint_113
                    18593   doprint_112:
00006614  60B2      18594          bra       doprint_110
                    18595   doprint_113:
00006616  4A2E FFCD 18596          tst.b     -51(A6)
0000661A  6700 0030 18597          beq       doprint_125
0000661E  1004      18598          move.b    D4,D0
00006620  4880      18599          ext.w     D0
00006622  48C0      18600          ext.l     D0
00006624  D0AE FFFC 18601          add.l     -4(A6),D0
00006628  D087      18602          add.l     D7,D0
0000662A  1D40 FFD1 18603          move.b    D0,-47(A6)
                    18604   doprint_123:
0000662E  102E FFD1 18605          move.b    -47(A6),D0
00006632  4880      18606          ext.w     D0
00006634  48C0      18607          ext.l     D0
00006636  220D      18608          move.l    A5,D1
00006638  534D      18609          subq.w    #1,A5
0000663A  B081      18610          cmp.l     D1,D0
0000663C  6C0E      18611          bge.s     doprint_125
0000663E  4878 0020 18612          pea       32
00006642  2F0A      18613          move.l    A2,-(A7)
00006644  4E93      18614          jsr       (A3)
00006646  504F      18615          addq.w    #8,A7
00006648  5386      18616          subq.l    #1,D6
0000664A  60E2      18617          bra       doprint_123
                    18618   doprint_125:
0000664C  6014      18619          bra.s     doprint_81
                    18620   doprint_80:
0000664E  206E 000C 18621          move.l    12(A6),A0
00006652  1210      18622          move.b    (A0),D1
00006654  4881      18623          ext.w     D1
00006656  48C1      18624          ext.l     D1
00006658  2F01      18625          move.l    D1,-(A7)
0000665A  2F0A      18626          move.l    A2,-(A7)
0000665C  4E93      18627          jsr       (A3)
0000665E  504F      18628          addq.w    #8,A7
00006660  5286      18629          addq.l    #1,D6
                    18630   doprint_81:
00006662  52AE 000C 18631          addq.l    #1,12(A6)
                    18632   doprint_2:
00006666  6000 FA0E 18633          bra       doprint_1
                    18634   doprint_3:
0000666A  4A92      18635          tst.l     (A2)
0000666C  6710      18636          beq.s     doprint_126
0000666E  4201      18637          clr.b     D1
00006670  C2BC 0000 18638          and.l     #255,D1
00006674  00FF      
00006676  2F01      18639          move.l    D1,-(A7)
00006678  2F0A      18640          move.l    A2,-(A7)
0000667A  4E93      18641          jsr       (A3)
0000667C  504F      18642          addq.w    #8,A7
                    18643   doprint_126:
0000667E  2006      18644          move.l    D6,D0
00006680  4CDF 3CFC 18645          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00006684  4E5E      18646          unlk      A6
00006686  4E75      18647          rts
                    18648   @itoa_convert:
00006688  4E56 0000 18649          link      A6,#0
0000668C  48E7 3C00 18650          movem.l   D2/D3/D4/D5,-(A7)
00006690  242E 0008 18651          move.l    8(A6),D2
00006694  262E 0010 18652          move.l    16(A6),D3
00006698  2A2E 000C 18653          move.l    12(A6),D5
0000669C  2F05      18654          move.l    D5,-(A7)
0000669E  2F03      18655          move.l    D3,-(A7)
000066A0  4EB8 5EDA 18656          jsr       ULDIV
000066A4  202F 0004 18657          move.l    4(A7),D0
000066A8  504F      18658          addq.w    #8,A7
000066AA  2800      18659          move.l    D0,D4
000066AC  BA83      18660          cmp.l     D3,D5
000066AE  651C      18661          blo.s     @itoa_convert_1
000066B0  2F03      18662          move.l    D3,-(A7)
000066B2  2F05      18663          move.l    D5,-(A7)
000066B4  2F03      18664          move.l    D3,-(A7)
000066B6  4EB8 5EDA 18665          jsr       ULDIV
000066BA  2217      18666          move.l    (A7),D1
000066BC  504F      18667          addq.w    #8,A7
000066BE  2F01      18668          move.l    D1,-(A7)
000066C0  2F02      18669          move.l    D2,-(A7)
000066C2  4EB8 6688 18670          jsr       @itoa_convert
000066C6  DEFC 000C 18671          add.w     #12,A7
000066CA  2400      18672          move.l    D0,D2
                    18673   @itoa_convert_1:
000066CC  0C84 0000 18674          cmp.l     #9,D4
000066D0  0009      
000066D2  6E0E      18675          bgt.s     @itoa_convert_3
000066D4  2004      18676          move.l    D4,D0
000066D6  7230      18677          moveq     #48,D1
000066D8  C2BC 0000 18678          and.l     #255,D1
000066DC  00FF      
000066DE  D081      18679          add.l     D1,D0
000066E0  6012      18680          bra.s     @itoa_convert_4
                    18681   @itoa_convert_3:
000066E2  2004      18682          move.l    D4,D0
000066E4  7261      18683          moveq     #97,D1
000066E6  C2BC 0000 18684          and.l     #255,D1
000066EA  00FF      
000066EC  D081      18685          add.l     D1,D0
000066EE  0480 0000 18686          sub.l     #10,D0
000066F2  000A      
                    18687   @itoa_convert_4:
000066F4  2042      18688          move.l    D2,A0
000066F6  1080      18689          move.b    D0,(A0)
000066F8  2002      18690          move.l    D2,D0
000066FA  5280      18691          addq.l    #1,D0
000066FC  4CDF 003C 18692          movem.l   (A7)+,D2/D3/D4/D5
00006700  4E5E      18693          unlk      A6
00006702  4E75      18694          rts
                    18695   _ltoa:
00006704  4E56 0000 18696          link      A6,#0
00006708  48E7 3C00 18697          movem.l   D2/D3/D4/D5,-(A7)
0000670C  242E 0008 18698          move.l    8(A6),D2
00006710  262E 000C 18699          move.l    12(A6),D3
00006714  2A2E 0010 18700          move.l    16(A6),D5
00006718  2803      18701          move.l    D3,D4
0000671A  0C85 0000 18702          cmp.l     #2,D5
0000671E  0002      
00006720  6D08      18703          blt.s     ltoa_3
00006722  0C85 0000 18704          cmp.l     #36,D5
00006726  0024      
00006728  6F06      18705          ble.s     ltoa_1
                    18706   ltoa_3:
0000672A  2003      18707          move.l    D3,D0
0000672C  6000 0054 18708          bra       ltoa_4
                    18709   ltoa_1:
00006730  0C85 0000 18710          cmp.l     #10,D5
00006734  000A      
00006736  6600 0034 18711          bne       ltoa_5
0000673A  0C82 0000 18712          cmp.l     #0,D2
0000673E  0000      
00006740  6C2A      18713          bge.s     ltoa_5
00006742  2002      18714          move.l    D2,D0
00006744  4480      18715          neg.l     D0
00006746  2400      18716          move.l    D0,D2
00006748  0C82 0000 18717          cmp.l     #0,D2
0000674C  0000      
0000674E  6C14      18718          bge.s     ltoa_7
00006750  4879 0000 18719          pea       @itoa_1.L
00006754  69F6      
00006756  2F03      18720          move.l    D3,-(A7)
00006758  4EB9 0000 18721          jsr       _strcpy
0000675C  6846      
0000675E  504F      18722          addq.w    #8,A7
00006760  2003      18723          move.l    D3,D0
00006762  601E      18724          bra.s     ltoa_4
                    18725   ltoa_7:
00006764  2044      18726          move.l    D4,A0
00006766  5284      18727          addq.l    #1,D4
00006768  10BC 002D 18728          move.b    #45,(A0)
                    18729   ltoa_5:
0000676C  2F05      18730          move.l    D5,-(A7)
0000676E  2F02      18731          move.l    D2,-(A7)
00006770  2F04      18732          move.l    D4,-(A7)
00006772  4EB8 6688 18733          jsr       @itoa_convert
00006776  DEFC 000C 18734          add.w     #12,A7
0000677A  2800      18735          move.l    D0,D4
0000677C  2044      18736          move.l    D4,A0
0000677E  4210      18737          clr.b     (A0)
00006780  2003      18738          move.l    D3,D0
                    18739   ltoa_4:
00006782  4CDF 003C 18740          movem.l   (A7)+,D2/D3/D4/D5
00006786  4E5E      18741          unlk      A6
00006788  4E75      18742          rts
                    18743   _ultoa:
0000678A  4E56 0000 18744          link      A6,#0
0000678E  48E7 3800 18745          movem.l   D2/D3/D4,-(A7)
00006792  262E 0010 18746          move.l    16(A6),D3
00006796  282E 000C 18747          move.l    12(A6),D4
0000679A  2404      18748          move.l    D4,D2
0000679C  0C83 0000 18749          cmp.l     #2,D3
000067A0  0002      
000067A2  6D08      18750          blt.s     ultoa_3
000067A4  0C83 0000 18751          cmp.l     #36,D3
000067A8  0024      
000067AA  6F04      18752          ble.s     ultoa_1
                    18753   ultoa_3:
000067AC  2004      18754          move.l    D4,D0
000067AE  6018      18755          bra.s     ultoa_4
                    18756   ultoa_1:
000067B0  2F03      18757          move.l    D3,-(A7)
000067B2  2F2E 0008 18758          move.l    8(A6),-(A7)
000067B6  2F02      18759          move.l    D2,-(A7)
000067B8  4EB8 6688 18760          jsr       @itoa_convert
000067BC  DEFC 000C 18761          add.w     #12,A7
000067C0  2400      18762          move.l    D0,D2
000067C2  2042      18763          move.l    D2,A0
000067C4  4210      18764          clr.b     (A0)
000067C6  2004      18765          move.l    D4,D0
                    18766   ultoa_4:
000067C8  4CDF 001C 18767          movem.l   (A7)+,D2/D3/D4
000067CC  4E5E      18768          unlk      A6
000067CE  4E75      18769          rts
                    18770   _itoa:
000067D0  4E56 0000 18771          link      A6,#0
000067D4  2F2E 0010 18772          move.l    16(A6),-(A7)
000067D8  2F2E 000C 18773          move.l    12(A6),-(A7)
000067DC  2F2E 0008 18774          move.l    8(A6),-(A7)
000067E0  4EB8 6704 18775          jsr       _ltoa
000067E4  DEFC 000C 18776          add.w     #12,A7
000067E8  4E5E      18777          unlk      A6
000067EA  4E75      18778          rts
                    18779   _strlen:
000067EC  206F 0004 18780          move.l    (4,A7),A0
000067F0  2248      18781          move.l    A0,A1
                    18782   strlen_1:
000067F2  4A19      18783          tst.b     (A1)+
000067F4  66FC      18784          bne       strlen_1
000067F6  2009      18785          move.l    A1,D0
000067F8  9088      18786          sub.l     A0,D0
000067FA  5380      18787          subq.l    #1,D0
000067FC  4E75      18788          rts
                    18789   _putch:
000067FE  4E56 0000 18790          link      A6,#0
00006802  2F02      18791          move.l    D2,-(A7)
00006804  242E 0008 18792          move.l    8(A6),D2
00006808  0C82 0000 18793          cmp.l     #10,D2
0000680C  000A      
0000680E  660A      18794          bne.s     putch_1
00006810  4878 000D 18795          pea       13
00006814  4EB8 5C82 18796          jsr       __putch
00006818  584F      18797          addq.w    #4,A7
                    18798   putch_1:
0000681A  2F02      18799          move.l    D2,-(A7)
0000681C  4EB8 5C82 18800          jsr       __putch
00006820  584F      18801          addq.w    #4,A7
00006822  2002      18802          move.l    D2,D0
00006824  241F      18803          move.l    (A7)+,D2
00006826  4E5E      18804          unlk      A6
00006828  4E75      18805          rts
                    18806   _toupper:
0000682A  202F 0004 18807          move.l    4(A7),D0
0000682E  0C80 0000 18808          cmp.l     #'a',D0
00006832  0061      
00006834  6D0E      18809          blt.s     toupper_1
00006836  0C80 0000 18810          cmp.l     #'z',D0
0000683A  007A      
0000683C  6E06      18811          bgt.s     toupper_1
0000683E  0480 0000 18812          sub.l     #$20,D0
00006842  0020      
                    18813   toupper_1:
00006844  4E75      18814          rts
                    18815   _strcpy:
00006846  206F 0004 18816          move.l    (4,A7),A0
0000684A  226F 0008 18817          move.l    (8,A7),A1
0000684E  2008      18818          move.l    A0,D0
                    18819   strcpy_1:
00006850  10D9      18820          move.b    (A1)+,(A0)+
00006852  66FC      18821          bne.s     strcpy_1
00006854  4E75      18822          rts
                    18823          section   const
          0000 6856 18824   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    18825   
                    18826   @asn6_a~1_1:
00006856  416C 7465 18827          dc.b      65,108,116,101,114,97,32,68,69,49,47,54,56,75
0000685A  7261 2044 
0000685E  4531 2F36 
00006862  384B      
00006864  00        18828          dc.b      0
                    18829   @asn6_a~1_2:
00006866  4D69 6372 18830          dc.b      77,105,99,114,105,117,109,32,117,67,47,79,83
0000686A  6975 6D20 
0000686E  7543 2F4F 
00006872  53        
00006873  2D49 4920 18831          dc.b      45,73,73,32,82,84,79,83,0
00006877  5254 4F53 
0000687B  00        
                    18832   @asn6_a~1_3:
0000687C  5241 4E44 18833          dc.b      82,65,78,68,79,77,32,72,69,88,32,68,73,83,80
00006880  4F4D 2048 
00006884  4558 2044 
00006888  4953 50   
0000688B  4C41 590A 18834          dc.b      76,65,89,10,0
0000688F  00        
                    18835   @asn6_a~1_4:
00006890  5241 4E44 18836          dc.b      82,65,78,68,79,77,32,76,69,68,32,68,73,83,80
00006894  4F4D 204C 
00006898  4544 2044 
0000689C  4953 50   
0000689F  4C41 590A 18837          dc.b      76,65,89,10,0
000068A3  00        
                    18838   @ucos_ii_1:
000068A4  3F00      18839          dc.b      63,0
                    18840   @ucos_ii_2:
000068A6  7543 2F4F 18841          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
000068AA  532D 4949 
000068AE  2049 646C 
000068B2  6500      
                    18842   @ucos_ii_3:
000068B4  7543 2F4F 18843          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
000068B8  532D 4949 
000068BC  2053 7461 
000068C0  7400      
                    18844   @ucos_ii_4:
000068C2  7543 2F4F 18845          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
000068C6  532D 4949 
000068CA  2054 6D72 
000068CE  4C6F      
000068D0  636B 00   18846          dc.b      99,107,0
                    18847   @ucos_ii_5:
000068D4  7543 2F4F 18848          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
000068D8  532D 4949 
000068DC  2054 6D72 
000068E0  5369      
000068E2  676E 616C 18849          dc.b      103,110,97,108,0
000068E6  00        
                    18850   @ucos_ii_6:
000068E8  7543 2F4F 18851          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
000068EC  532D 4949 
000068F0  2054 6D72 
000068F4  00        
                    18852   _OSUnMapTbl:
000068F6  0000 0100 18853          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
000068FA  0200 0100 
000068FE  0300 0100 
00006902  0200 0100 
00006906  0400 0100 
0000690A  0200      
0000690C  0100 0300 18854          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
00006910  0100 0200 
00006914  0100 0500 
00006918  0100 0200 
0000691C  0100 0300 
00006920  0100      
00006922  0200 0100 18855          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
00006926  0400 0100 
0000692A  0200 0100 
0000692E  0300 0100 
00006932  0200 0100 
00006936  0600      
00006938  0100 0200 18856          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
0000693C  0100 0300 
00006940  0100 0200 
00006944  0100 0400 
00006948  0100 0200 
0000694C  0100      
0000694E  0300 0100 18857          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
00006952  0200 0100 
00006956  0500 0100 
0000695A  0200 0100 
0000695E  0300 0100 
00006962  0200      
00006964  0100 0400 18858          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
00006968  0100 0200 
0000696C  0100 0300 
00006970  0100 0200 
00006974  0100 0700 
00006978  0100      
0000697A  0200 0100 18859          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
0000697E  0300 0100 
00006982  0200 0100 
00006986  0400 0100 
0000698A  0200 0100 
0000698E  0300      
00006990  0100 0200 18860          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
00006994  0100 0500 
00006998  0100 0200 
0000699C  0100 0300 
000069A0  0100 0200 
000069A4  0100      
000069A6  0400 0100 18861          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
000069AA  0200 0100 
000069AE  0300 0100 
000069B2  0200 0100 
000069B6  0600 0100 
000069BA  0200      
000069BC  0100 0300 18862          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
000069C0  0100 0200 
000069C4  0100 0400 
000069C8  0100 0200 
000069CC  0100 0300 
000069D0  0100      
000069D2  0200 0100 18863          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
000069D6  0500 0100 
000069DA  0200 0100 
000069DE  0300 0100 
000069E2  0200 0100 
000069E6  0400      
000069E8  0100 0200 18864          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
000069EC  0100 0300 
000069F0  0100 0200 
000069F4  0100      
                    18865   @itoa_1:
000069F6  2D32 3134 18866          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
000069FA  3734 3833 
000069FE  3634 3800 
                    18867   __ctype:
00006A02  0040 4040 18868          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
00006A06  4040 4040 
00006A0A  4040 5050 
00006A0E  5050 50   
00006A11  4040 4040 18869          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
00006A15  4040 4040 
00006A19  4040 4040 
00006A1D  4040 40   
00006A20  4040 40D0 18870          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
00006A24  A0A0 A0A0 
00006A28  A0A0 A0A0 
00006A2C  A0A0 A0A0 18871          dc.b      160,160,160,160,160,160,160,140,140,140,140
00006A30  A0A0 A08C 
00006A34  8C8C 8C   
00006A37  8C8C 8C8C 18872          dc.b      140,140,140,140,140,140,160,160,160,160,160
00006A3B  8C8C A0A0 
00006A3F  A0A0 A0   
00006A42  A0A0 8A8A 18873          dc.b      160,160,138,138,138,138,138,138,130,130,130
00006A46  8A8A 8A8A 
00006A4A  8282 82   
00006A4D  8282 8282 18874          dc.b      130,130,130,130,130,130,130,130,130,130,130
00006A51  8282 8282 
00006A55  8282 82   
00006A58  8282 8282 18875          dc.b      130,130,130,130,130,130,160,160,160,160,160
00006A5C  8282 A0A0 
00006A60  A0A0 A0   
00006A63  A089 8989 18876          dc.b      160,137,137,137,137,137,137,129,129,129,129
00006A67  8989 8981 
00006A6B  8181 81   
00006A6E  8181 8181 18877          dc.b      129,129,129,129,129,129,129,129,129,129,129
00006A72  8181 8181 
00006A76  8181 81   
00006A79  8181 8181 18878          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
00006A7D  81A0 A0A0 
00006A81  A040 0000 
00006A85  00        
00006A86  0000 0000 18879          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006A8A  0000 0000 
00006A8E  0000 0000 
00006A92  0000 0000 
00006A96  0000 0000 
00006A9A  0000      
00006A9C  0000 0000 18880          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006AA0  0000 0000 
00006AA4  0000 0000 
00006AA8  0000 0000 
00006AAC  0000 0000 
00006AB0  0000      
00006AB2  0000 0000 18881          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006AB6  0000 0000 
00006ABA  0000 0000 
00006ABE  0000 0000 
00006AC2  0000 0000 
00006AC6  0000      
00006AC8  0000 0000 18882          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006ACC  0000 0000 
00006AD0  0000 0000 
00006AD4  0000 0000 
00006AD8  0000 0000 
00006ADC  0000      
00006ADE  0000 0000 18883          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006AE2  0000 0000 
00006AE6  0000 0000 
00006AEA  0000 0000 
00006AEE  0000 0000 
00006AF2  0000      
00006AF4  0000 0000 18884          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006AF8  0000 0000 
00006AFC  0000 0000 
00006B00  0000 00   
                    18885          section   data
          0000 6B04 18886   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    18887   
08000000            18888              org         RAM				; starting at address $08000000
          0800 0000 18889   begin_RAM  equ         *				; begin ram starts here
          0800 0000 18890   data       equ         *				; data starts here also
                    18891   
                    18892          section   bss
          0800 0000 18893   bss        equ         *
                    18894   
                    18895   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    18896   
                    18897   *********************************************************************************************************
                    18898   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    18899   * install the exception handler using the C function InstallExceptionHandler()
                    18900   *********************************************************************************************************
                    18901   
08000000            18902   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08000004            18903   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08000008            18904   VBusError        ds.l    1      storage for address of Bus Error Handler
0800000C            18905   VAddressError    ds.l    1      storage for address of Address Error Handler
08000010            18906   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08000014            18907   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08000018            18908   VCheck           ds.l    1      ditto
0800001C            18909   VTrapV           ds.l    1      ditto
08000020            18910   VPrivilege       ds.l    1      ditto
08000024            18911   VTrace           ds.l    1
08000028            18912   VLine1010emul    ds.l    1
0800002C            18913   VLine1111emul    ds.l    1
08000030            18914   VUnassigned1     ds.l    1
08000034            18915   VUnassigned2     ds.l    1
08000038            18916   VUnassigned3     ds.l    1
0800003C            18917   VUninit_IRQ      ds.l    1
08000040            18918   VUnassigned4     ds.l    1
08000044            18919   VUnassigned5     ds.l    1
08000048            18920   VUnassigned6     ds.l    1
0800004C            18921   VUnassigned7     ds.l    1
08000050            18922   VUnassigned8     ds.l    1
08000054            18923   VUnassigned9     ds.l    1
08000058            18924   VUnassigned10    ds.l    1
0800005C            18925   VUnassigned11    ds.l    1
08000060            18926   VSpuriousIRQ     ds.l    1
                    18927   
                    18928   * Interrupt handlers Vector 25-31
08000064            18929   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000068            18930   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800006C            18931   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000070            18932   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000074            18933   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000078            18934   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800007C            18935   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    18936   
                    18937   * Trap Handler vectors 32-47
08000080            18938   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000084            18939   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000088            18940   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800008C            18941   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000090            18942   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000094            18943   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000098            18944   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800009C            18945   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A0            18946   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A4            18947   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A8            18948   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000AC            18949   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B0            18950   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B4            18951   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B8            18952   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000BC            18953   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    18954   
                    18955   __ungetbuf:                            ; ungetbuffer for stdio functions
080000C0            18956              ds.l        1
                    18957   __timezone:                            ; difference, in seconds, between local time and UTC
080000C4            18958              ds.l        1
                    18959   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080000C8            18960              ds.l        1
                    18961   __romsize:                             ; size of ROM used by program
080000CC            18962              ds.l        1
                    18963   __ramsize:                             ; size of RAM used by program
080000D0            18964              ds.l        1
                    18965   
                    18966   _Task1Stk:
080000D4            18967          ds.b      512
                    18968   _Task2Stk:
080002D4            18969          ds.b      512
                    18970   _Task3Stk:
080004D4            18971          ds.b      512
                    18972   _Task4Stk:
080006D4            18973          ds.b      512
                    18974   _Task5Stk:
080008D4            18975          ds.b      512
                    18976   _Task6Stk:
08000AD4            18977          ds.b      512
                    18978   _OSTmrTickCtr:
08000CD4            18979          ds.b      1
                    18980   _OSCtxSwCtr:
08000CD6            18981          ds.b      4
                    18982   _OSEventFreeList:
08000CDA            18983          ds.b      4
                    18984   _OSEventTbl:
08000CDE            18985          ds.b      220
                    18986   _OSFlagTbl:
08000DBA            18987          ds.b      60
                    18988   _OSFlagFreeList:
08000DF6            18989          ds.b      4
                    18990   _OSCPUUsage:
08000DFA            18991          ds.b      1
                    18992   _OSIdleCtrMax:
08000DFC            18993          ds.b      4
                    18994   _OSIdleCtrRun:
08000E00            18995          ds.b      4
                    18996   _OSStatRdy:
08000E04            18997          ds.b      1
                    18998   _OSTaskStatStk:
08000E06            18999          ds.b      256
                    19000   _OSIntNesting:
08000F06            19001          ds.b      1
                    19002   _OSLockNesting:
08000F08            19003          ds.b      1
                    19004   _OSPrioCur:
08000F0A            19005          ds.b      1
                    19006   _OSPrioHighRdy:
08000F0C            19007          ds.b      1
                    19008   _OSRdyGrp:
08000F0E            19009          ds.b      1
                    19010   _OSRdyTbl:
08000F10            19011          ds.b      8
                    19012   _OSRunning:
08000F18            19013          ds.b      1
                    19014   _OSTaskCtr:
08000F1A            19015          ds.b      1
                    19016   _OSIdleCtr:
08000F1C            19017          ds.b      4
                    19018   _OSTaskIdleStk:
08000F20            19019          ds.b      256
                    19020   _OSTCBCur:
08001020            19021          ds.b      4
                    19022   _OSTCBFreeList:
08001024            19023          ds.b      4
                    19024   _OSTCBHighRdy:
08001028            19025          ds.b      4
                    19026   _OSTCBList:
0800102C            19027          ds.b      4
                    19028   _OSTCBPrioTbl:
08001030            19029          ds.b      256
                    19030   _OSTCBTbl:
08001130            19031          ds.b      1892
                    19032   _OSMemFreeList:
08001894            19033          ds.b      4
                    19034   _OSMemTbl:
08001898            19035          ds.b      120
                    19036   _OSQFreeList:
08001910            19037          ds.b      4
                    19038   _OSQTbl:
08001914            19039          ds.b      96
                    19040   _OSTaskRegNextAvailID:
08001974            19041          ds.b      1
                    19042   _OSTime:
08001976            19043          ds.b      4
                    19044   _OSTmrFree:
0800197A            19045          ds.b      2
                    19046   _OSTmrUsed:
0800197C            19047          ds.b      2
                    19048   _OSTmrTime:
0800197E            19049          ds.b      4
                    19050   _OSTmrSem:
08001982            19051          ds.b      4
                    19052   _OSTmrSemSignal:
08001986            19053          ds.b      4
                    19054   _OSTmrTbl:
0800198A            19055          ds.b      576
                    19056   _OSTmrFreeList:
08001BCA            19057          ds.b      4
                    19058   _OSTmrTaskStk:
08001BCE            19059          ds.b      256
                    19060   _OSTmrWheelTbl:
08001CCE            19061          ds.b      32
                    19062          section   heap
          0800 1CEE 19063   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 1CEE 19064   heap       equ         *
                    19065   
          0801 0000 19066   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
