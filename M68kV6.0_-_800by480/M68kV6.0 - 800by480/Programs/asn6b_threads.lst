680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 13 Apr 2023      Time: 11:47:37          Source: C:\M68KV6.0 - 800BY480\PROGRAMS\ASN6B_THREADS.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : PJ Davies to suit DE1 board
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the DE1 board  It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0800 0000   33   RAM        equ         $08000000       ; RAM starts at $08000000
          0001 0000   34   RAMsize    equ         $00010000       ; Size of RAM 64kbytes
                      35   
                      36   ;           option      S0              ; Generate S0 record in .hex file since Rom is at location 0
                      37   
00000000              38              org         ROM				; starting at location 0, generate the following constants
          0000 0000   39   begin_ROM  equ         *				; beginning of rom constant is 0
          0000 0000   40   code       equ         *				; code starts at 0
                      41   
                      42   
                      43   ;*******************************************************************************************************************
                      44   ; start of 68000 vector table (256 long word entries covering reset, interrupts, initial stack pointer etc)
                      45   ;*******************************************************************************************************************
                      46   
00000000  0801 0000   47   InitialSP       dc.l __stack          ;initial supervisor state stack pointer(stack decrements first before being used
00000004  0000 0400   48   InitialPC       dc.l startup             ;address of 1st instruction of program after a reset
00000008  0000 05D2   49   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 05E4   50   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 05F6   51   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0608   52   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 061A   53   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 062C   54   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 063E   55   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0650   56   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0662   57   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 0674   58   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 0686   59   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 0686   60   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 0686   61   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 0686   62   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 0686   63   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 0686   64   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 0686   65   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 0686   66   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 0686   67   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 0686   68   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 0686   69   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 0686   70   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 0686   71   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      72   *
                      73   *
00000064  0000 0434   74   Level1IRQ       dc.l Level1RamISR
00000068  0000 0446   75   Level2IRQ       dc.l Level2RamISR
0000006C  0000 07BE   76   Level3IRQ       dc.l _OSTickISR        ;Level3RamISR (Timer Tick) - ISR needs to be installed at run time for DE1 timer
00000070  0000 046A   77   Level4IRQ       dc.l Level4RamISR
00000074  0000 047C   78   Level5IRQ       dc.l Level5RamISR
00000078  0000 048E   79   Level6IRQ       dc.l Level6RamISR
0000007C  0000 04A0   80   Level7IRQ       dc.l Level7RamISR
                      81   *
                      82   *
00000080  0000 06B2   83   Trap0           dc.l _OSCtxSw           ; User installed trap handler (Context Switch) - invoked by a trap0 instruction contained in os_cpu.h file
00000084  0000 04C4   84   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 04D6   85   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 04E8   86   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 04FA   87   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 050C   88   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 051E   89   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 0530   90   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 0542   91   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 0554   92   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 0566   93   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 0578   94   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 058A   95   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 059C   96   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 05AE   97   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 05C0   98   Trap15          dc.l Trap15RamISR       ; User installed trap handler (System call - but a legacy from running on IDE68k simulator)
                      99   
                     100   
                     101   *
                     102   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                     103   *
                     104   
00000400             105                   org       $00000400    ; end of vector table/start of code
                     106   
                     107              ; this is where the program code initially begins (see table avove vector #1 - initial Program counter value is defined as "startup"
                     108              ; here we can write some boot code and carry out some memory/constant initialisation
                     109              ; add your own code here or you can do it later in C (try to keep assembler code to a minimum)
                     110   startup:
00000400  41F9 0800  111              lea         bss,A0			; put start address of unitialised variables into register A0
00000404  000C      
00000406  4218       112              clr.b       (A0)+           ; set bss section (unitialised variables) to zero (clear the byte pointed to by A0 and then increment A0)
00000408  B1FC 0800  113              cmp.l       #heap,A0			; compare A0 with immediate value defined by heap
0000040C  1B08      
0000040E  65F6       114              bcs.s       *-8				; if not there yet go back 8 bytes to clr.b instruction
00000410  23FC FFFF  115              move.l      #-1,__ungetbuf  ; initialose ungetbuffer for keyboard input (don't remove this otherwise scanf() etc will not work)
00000414  FFFF 0800 
00000418  00CC      
                     116              ;
0000041A  23FC 0000  117              move.l      #(end_ROM-begin_ROM),__romsize	; initialise some values related to rom and ram limits (needed by OS)
0000041E  71AC 0800 
00000422  00D8      
00000424  23FC 0000  118              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  1B08 0800 
0000042C  00DC      
0000042E  4EB9 0000  119              jsr         _main							; now call main() from our C program (yeah!!!!)
00000432  07DC      
                     120   
                     121   *********************************************************************************************************
                     122   * Code to call Ram Based Interrupt handler and other exeception handler code
                     123   *********************************************************************************************************
00000434  48E7 FFFE  124   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000438  2079 0800  125                   move.l    VL1IRQ,a0               get ram based address into a0
0000043C  0070      
0000043E  4E90       126                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000440  4CDF 7FFF  127                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000444  4E73       128                   rte
00000446  48E7 FFFE  129   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000044A  2079 0800  130                   move.l    VL2IRQ,a0               get ram based address into a0
0000044E  0074      
00000450  4E90       131                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000452  4CDF 7FFF  132                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000456  4E73       133                   rte
00000458  48E7 FFFE  134   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000045C  2079 0800  135                   move.l    VL3IRQ,a0               get ram based address into a0
00000460  0078      
00000462  4E90       136                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000464  4CDF 7FFF  137                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000468  4E73       138                   rte
0000046A  48E7 FFFE  139   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000046E  2079 0800  140                   move.l    VL4IRQ,a0               get ram based address into a0
00000472  007C      
00000474  4E90       141                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000476  4CDF 7FFF  142                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000047A  4E73       143                   rte
                     144   
0000047C  48E7 FFFE  145   Level5RamISR    movem.l   d0-d7/a0-a6,-(SP)        save everything not automatically saved
00000480  2079 0800  146                   move.l    VL5IRQ,a0               get ram based address into a0
00000484  0080      
00000486  4E90       147                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
00000488  4CDF 7FFF  148                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000048C  4E73       149                   rte
                     150   
0000048E  48E7 FFFE  151   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000492  2079 0800  152                   move.l    VL6IRQ,a0               get ram based address into a0
00000496  0084      
00000498  4E90       153                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000049A  4CDF 7FFF  154                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000049E  4E73       155                   rte
                     156   
000004A0  48E7 FFFE  157   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004A4  2079 0800  158                   move.l    VL7IRQ,a0               get ram based address into a0
000004A8  0088      
000004AA  4E90       159                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004AC  4CDF 7FFF  160                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004B0  4E73       161                   rte
                     162   
                     163   
                     164   ********************************************************************************************************
                     165   * Ram based Trap handler and other exeception handler code
                     166   *********************************************************************************************************
                     167   
000004B2  48E7 FFFE  168   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B6  2079 0800  169                   move.l    VTrap0,a0                get ram based address into a0
000004BA  008C      
000004BC  4E90       170                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004BE  4CDF 7FFF  171                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004C2  4E73       172                   rte
                     173   
000004C4  48E7 FFFE  174   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C8  2079 0800  175                   move.l    VTrap1,a0                get ram based address into a0
000004CC  0090      
000004CE  4E90       176                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004D0  4CDF 7FFF  177                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004D4  4E73       178                   rte
                     179   
000004D6  48E7 FFFE  180   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004DA  2079 0800  181                   move.l    VTrap2,a0                get ram based address into a0
000004DE  0094      
000004E0  4E90       182                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004E2  4CDF 7FFF  183                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E6  4E73       184                   rte
                     185   
000004E8  48E7 FFFE  186   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004EC  2079 0800  187                   move.l    VTrap3,a0                get ram based address into a0
000004F0  0098      
000004F2  4E90       188                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000004F4  4CDF 7FFF  189                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004F8  4E73       190                   rte
                     191   
000004FA  48E7 FFFE  192   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004FE  2079 0800  193                   move.l    VTrap4,a0                get ram based address into a0
00000502  009C      
00000504  4E90       194                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000506  4CDF 7FFF  195                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000050A  4E73       196                   rte
                     197   
0000050C  48E7 FFFE  198   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000510  2079 0800  199                   move.l    VTrap5,a0                get ram based address into a0
00000514  00A0      
00000516  4E90       200                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000518  4CDF 7FFF  201                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000051C  4E73       202                   rte
                     203   
0000051E  48E7 FFFE  204   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000522  2079 0800  205                   move.l    VTrap6,a0                get ram based address into a0
00000526  00A4      
00000528  4E90       206                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000052A  4CDF 7FFF  207                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000052E  4E73       208                   rte
                     209   
00000530  48E7 FFFE  210   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000534  2079 0800  211                   move.l    VTrap7,a0                get ram based address into a0
00000538  00A8      
0000053A  4E90       212                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000053C  4CDF 7FFF  213                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000540  4E73       214                   rte
                     215   
00000542  48E7 FFFE  216   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000546  2079 0800  217                   move.l    VTrap8,a0                get ram based address into a0
0000054A  00AC      
0000054C  4E90       218                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000054E  4CDF 7FFF  219                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000552  4E73       220                   rte
                     221   
00000554  48E7 FFFE  222   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000558  2079 0800  223                   move.l    VTrap9,a0                get ram based address into a0
0000055C  00B0      
0000055E  4E90       224                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000560  4CDF 7FFF  225                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000564  4E73       226                   rte
                     227   
00000566  48E7 FFFE  228   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000056A  2079 0800  229                   move.l    VTrap10,a0                get ram based address into a0
0000056E  00B4      
00000570  4E90       230                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000572  4CDF 7FFF  231                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000576  4E73       232                   rte
                     233   
00000578  48E7 FFFE  234   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000057C  2079 0800  235                   move.l    VTrap11,a0                get ram based address into a0
00000580  00B8      
00000582  4E90       236                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000584  4CDF 7FFF  237                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000588  4E73       238                   rte
                     239   
0000058A  48E7 FFFE  240   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000058E  2079 0800  241                   move.l    VTrap12,a0                get ram based address into a0
00000592  00BC      
00000594  4E90       242                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000596  4CDF 7FFF  243                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000059A  4E73       244                   rte
                     245   
0000059C  48E7 FFFE  246   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005A0  2079 0800  247                   move.l    VTrap13,a0                get ram based address into a0
000005A4  00C0      
000005A6  4E90       248                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005A8  4CDF 7FFF  249                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005AC  4E73       250                   rte
                     251   
000005AE  48E7 FFFE  252   Trap14RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005B2  2079 0800  253                   move.l    VTrap14,a0              get ram based address into a0
000005B6  00C4      
000005B8  4E90       254                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005BA  4CDF 7FFF  255                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005BE  4E73       256                   rte
                     257   
000005C0  48E7 FFFE  258   Trap15RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005C4  2079 0800  259                   move.l    VTrap15,a0              get ram based address into a0
000005C8  00C8      
000005CA  4E90       260                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005CC  4CDF 7FFF  261                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005D0  4E73       262                   rte
                     263   
                     264   *********************************************************************************************************
                     265   *Default exception handler for everything without a specific handler
                     266   *********************************************************************************************************
                     267   
000005D2  48E7 FFFE  268   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005D6  2079 0800  269                   move.l    VBusError,a0            get ram based address into a0
000005DA  0014      
000005DC  4E90       270                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005DE  4CDF 7FFF  271                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005E2  4E73       272                   rte
000005E4  48E7 FFFE  273   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005E8  2079 0800  274                   move.l    VAddressError,a0        get ram based address into a0
000005EC  0018      
000005EE  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000005F0  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005F4  4E73       277                   rte
000005F6  48E7 FFFE  278   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005FA  2079 0800  279                   move.l    VIllegalInstr,a0        get ram based address into a0
000005FE  001C      
00000600  4E90       280                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000602  4CDF 7FFF  281                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000606  4E73       282                   rte
00000608  48E7 FFFE  283   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000060C  2079 0800  284                   move.l    VDividebyZero,a0        get ram based address into a0
00000610  0020      
00000612  4E90       285                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000614  4CDF 7FFF  286                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000618  4E73       287                   rte
0000061A  48E7 FFFE  288   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000061E  2079 0800  289                   move.l    VCheck,a0               get ram based address into a0
00000622  0024      
00000624  4E90       290                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000626  4CDF 7FFF  291                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000062A  4E73       292                   rte
0000062C  48E7 FFFE  293   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000630  2079 0800  294                   move.l    VTrapV,a0               get ram based address into a0
00000634  0028      
00000636  4E90       295                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000638  4CDF 7FFF  296                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000063C  4E73       297                   rte
0000063E  48E7 FFFE  298   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000642  2079 0800  299                   move.l    VPrivilege,a0           get ram based address into a0
00000646  002C      
00000648  4E90       300                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000064A  4CDF 7FFF  301                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000064E  4E73       302                   rte
00000650  48E7 FFFE  303   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000654  2079 0800  304                   move.l    VTrace,a0               get ram based address into a0
00000658  0030      
0000065A  4E90       305                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000065C  4CDF 7FFF  306                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000660  4E73       307                   rte
00000662  48E7 FFFE  308   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000666  2079 0800  309                   move.l    VLine1010emul,a0        get ram based address into a0
0000066A  0034      
0000066C  4E90       310                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000066E  4CDF 7FFF  311                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000672  4E73       312                   rte
00000674  48E7 FFFE  313   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000678  2079 0800  314                   move.l    VLine1111emul,a0        get ram based address into a0
0000067C  0038      
0000067E  4E90       315                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000680  4CDF 7FFF  316                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000684  4E73       317                   rte
                     318   
                     319   ; at the moment all these exceptions cause the processor to stop (or at least loop) with no further application processing
                     320   E_Unnas1
                     321   E_Unnas2
                     322   E_Unnas3
                     323   E_UnitI
                     324   E_Unnas4
                     325   E_Unnas5
                     326   E_Unnas6
                     327   E_Unnas7
                     328   E_Unnas8
                     329   E_Unnas9
                     330   E_Unnas10
                     331   E_Unnas11
                     332   E_Spuri
00000686  60FE       333   _stop            bra _stop             ; stop
                     334   
                     335   __exit:                                ; exit() and _exit()functions
                     336   
00000688  6000 FD76  337              bra         startup         ; restart program if exit() called
                     338   
                     339   ; I don't think these two time related functions are relevant anymore and neither is Trap 15 handler
                     340   ; but they are left in for the moment until I am certain they can be removed
                     341   __time:
0000068C  4E4F       342              trap        #15             ; IDE68K system call 40 -> GETTIME
0000068E  0028       343              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
00000690  4E75       344              rts
                     345   
                     346   __localoffset:
00000692  4E4F       347              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
00000694  0029       348              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000696  4E75       349              rts
                     350   
                     351   ;********************************************************************************************************
                     352   ;                                               uC/OS-II
                     353   ;                                         The Real-Time Kernel
                     354   ;
                     355   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     356   ;                                          All Rights Reserved
                     357   ;
                     358   ;
                     359   ;                                     68000 Specific assembly code
                     360   ;                                               IDE68K
                     361   ;
                     362   ; File         : OS_CPU_A.ASM
                     363   ; By           : Jean J. Labrosse, Peter J. Fondse
                     364   ;********************************************************************************************************
                     365   
                     366   
                     367   ;********************************************************************************************************
                     368   ;                                            REVISION HISTORY
                     369   ;
                     370   ; $Log$
                     371   ;
                     372   ;********************************************************************************************************
                     373   
                     374   
                     375   ;********************************************************************************************************
                     376   ;                                          PUBLIC DECLARATIONS
                     377   ;********************************************************************************************************
                     378   
                     379   
                     380   ;********************************************************************************************************
                     381   ;                                         EXTERNAL DECLARATIONS
                     382   ;********************************************************************************************************
                     383   
                     384   
                     385   ;********************************************************************************************************
                     386   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     387   ;
                     388   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     389   ;               by your application before calling OSStart().
                     390   ;
                     391   ; Arguments   : none
                     392   ;
                     393   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     394   ;
                     395   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     396   ;                                            +  2         D0    (L)
                     397   ;                                            +  4         D1    (H)
                     398   ;                                            +  6         D1    (L)
                     399   ;                                            +  8         D2    (H)
                     400   ;                                            + 10         D2    (L)
                     401   ;                                            + 12         D3    (H)
                     402   ;                                            + 14         D3    (L)
                     403   ;                                            + 16         D4    (H)
                     404   ;                                            + 18         D4    (L)
                     405   ;                                            + 20         D5    (H)
                     406   ;                                            + 22         D5    (L)
                     407   ;                                            + 24         D6    (H)
                     408   ;                                            + 26         D6    (L)
                     409   ;                                            + 28         D7    (H)
                     410   ;                                            + 30         D7    (L)
                     411   ;                                            + 32         A0    (H)
                     412   ;                                            + 34         A0    (L)
                     413   ;                                            + 36         A1    (H)
                     414   ;                                            + 38         A1    (L)
                     415   ;                                            + 40         A2    (H)
                     416   ;                                            + 42         A2    (L)
                     417   ;                                            + 44         A3    (H)
                     418   ;                                            + 46         A3    (L)
                     419   ;                                            + 48         A4    (H)
                     420   ;                                            + 50         A4    (L)
                     421   ;                                            + 52         A5    (H)
                     422   ;                                            + 54         A5    (L)
                     423   ;                                            + 56         A6    (H)
                     424   ;                                            + 58         A6    (L)
                     425   ;                                            + 60         OS_INITIAL_SR
                     426   ;                                            + 62         task  (H)
                     427   ;                                            + 64         task  (L)
                     428   ;                                            + 66         task  (H)
                     429   ;                                            + 68         task  (L)
                     430   ;                                            + 70         pdata (H)
                     431   ;                                            + 72         pdata (L)        High Memory
                     432   ;
                     433   ;               2) OSStartHighRdy() MUST:
                     434   ;                      a) Call OSTaskSwHook() then,
                     435   ;                      b) Set OSRunning to TRUE,
                     436   ;                      c) Switch to the highest priority task.
                     437   ;********************************************************************************************************
                     438   
                     439   ; Pseudocode for OSStartHighRdy:
                     440   ;          Call OSTaskSwHook();
                     441   ;          Set OSRunning to 1;
                     442   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     443   ;          POP all the processor registers from the stack;
                     444   ;          Execute a Return from Interrupt instruction;
                     445   
                     446   
                     447   _OSStartHighRdy:
00000698  4EB9 0000  448           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
0000069C  0C02      
0000069E  5239 0800  449           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
000006A2  0D32      
000006A4  2079 0800  450           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
000006A8  0E42      
000006AA  2E50       451           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
000006AC  4CDF 7FFF  452           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
000006B0  4E73       453           rte                                ; Run task
                     454   
                     455   ;********************************************************************************************************
                     456   ;                                       TASK LEVEL CONTEXT SWITCH
                     457   ;
                     458   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     459   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     460   ;
                     461   ; Arguments   : none
                     462   ;
                     463   ; Note(s)     : 1) Upon entry,
                     464   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     465   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     466   ;
                     467   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     468   ;                  task to suspend need to be saved):
                     469   ;
                     470   ;                                         SP +  0  ---->  SR                   Low Memory
                     471   ;                                            +  2         PC of task  (H)
                     472   ;                                            +  4         PC of task  (L)      High Memory
                     473   ;
                     474   ;               3) The stack frame of the task to resume looks as follows:
                     475   ;
                     476   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     477   ;                                            +  2         D0    (L)
                     478   ;                                            +  4         D1    (H)
                     479   ;                                            +  6         D1    (L)
                     480   ;                                            +  8         D2    (H)
                     481   ;                                            + 10         D2    (L)
                     482   ;                                            + 12         D3    (H)
                     483   ;                                            + 14         D3    (L)
                     484   ;                                            + 16         D4    (H)
                     485   ;                                            + 18         D4    (L)
                     486   ;                                            + 20         D5    (H)
                     487   ;                                            + 22         D5    (L)
                     488   ;                                            + 24         D6    (H)
                     489   ;                                            + 26         D6    (L)
                     490   ;                                            + 28         D7    (H)
                     491   ;                                            + 30         D7    (L)
                     492   ;                                            + 32         A0    (H)
                     493   ;                                            + 34         A0    (L)
                     494   ;                                            + 36         A1    (H)
                     495   ;                                            + 38         A1    (L)
                     496   ;                                            + 40         A2    (H)
                     497   ;                                            + 42         A2    (L)
                     498   ;                                            + 44         A3    (H)
                     499   ;                                            + 46         A3    (L)
                     500   ;                                            + 48         A4    (H)
                     501   ;                                            + 50         A4    (L)
                     502   ;                                            + 52         A5    (H)
                     503   ;                                            + 54         A5    (L)
                     504   ;                                            + 56         A6    (H)
                     505   ;                                            + 58         A6    (L)
                     506   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     507   ;                                            + 62         PC of task  (H)
                     508   ;                                            + 64         PC of task  (L)     High Memory
                     509   ;********************************************************************************************************
                     510   
                     511   ; Pseudocode for OSCtxSw:
                     512   ; OSCtxSw:
                     513   ; PUSH processor registers onto the current task’s stack;
                     514   ; Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     515   ; Call OSTaskSwHook(); (1)
                     516   ; OSTCBCur = OSTCBHighRdy;
                     517   ; OSPrioCur = OSPrioHighRdy; (2)
                     518   ; Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     519   ; POP all the processor registers from the stack;
                     520   ; Execute a Return from Interrupt instruction;
                     521   
                     522   _OSCtxSw:
000006B2  48E7 FFFE  523           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
000006B6  2079 0800  524           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
000006BA  0E3A      
000006BC  208F       525           move.l    A7,(A0)
000006BE  4EB9 0000  526           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006C2  0C02      
000006C4  13F9 0800  527           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
000006C8  0D26 0800 
000006CC  0D24      
000006CE  2079 0800  528           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
000006D2  0E42      
000006D4  23C8 0800  529           move.l    A0,_OSTCBCur
000006D8  0E3A      
000006DA  2E50       530           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
000006DC  4CDF 7FFF  531           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
000006E0  4E73       532           rte                                      ; Run task
                     533   
                     534   ;********************************************************************************************************
                     535   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     536   ;
                     537   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     538   ;               Provided for backward compatibility.
                     539   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     540   ;********************************************************************************************************
                     541   
                     542   ; Pseudocode for OSIntCtxSw
                     543   ; OSIntCtxSw
                     544   ;          Save the stack pointer at OSTCBCur->OSTCBStkPtr;
                     545   ;          Call OSTaskSwHook(); (1)
                     546   ;          OSTCBCur = OSTCBHighRdy;
                     547   ;          OSPrioCur = OSPrioHighRdy; (2)
                     548   ;          Load the processor stack pointer with OSTCBHighRdy->OSTCBStkPtr;
                     549   ;          POP all the processor registers from the stack;
                     550   ;          Execute a Return from Interrupt instruction;
                     551   
                     552   _OSIntCtxSw:
000006E2  DFFC 0000  553           adda.l    #10,A7                         ; Adjust the stack (note this code is called as a subroutine by OS so extra copy of PC stored on stack - along with PC and SR - so adjust by 10 bytes to point to A6)
000006E6  000A      
000006E8  2279 0800  554           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
000006EC  0E3A      
000006EE  228F       555           move.l    A7,(A1)
                     556   ;
000006F0  4EB9 0000  557           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000006F4  0C02      
                     558   ;
000006F6  2279 0800  559           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
000006FA  0E42      
000006FC  23C9 0800  560           move.l    A1,_OSTCBCur
00000700  0E3A      
00000702  2E51       561           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
                     562   ;
00000704  13F9 0800  563           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000708  0D26 0800 
0000070C  0D24      
0000070E  4CDF 7FFF  564           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
00000712  4E73       565           rte                                      ; Run task
                     566   
                     567   ;********************************************************************************************************
                     568   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     569   ;
                     570   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     571   ;
                     572   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     573   ;
                     574   ; Stack frame upon entry:
                     575   ;
                     576   ;                  SP +  0  ---->  D0    (H)
                     577   ;                     +  2         D0    (L)
                     578   ;                     +  4         D1    (H)
                     579   ;                     +  6         D1    (L)
                     580   ;                     +  8         D2    (H)
                     581   ;                     + 10         D2    (L)
                     582   ;                     + 12         D3    (H)
                     583   ;                     + 14         D3    (L)
                     584   ;                     + 16         D4    (H)
                     585   ;                     + 18         D4    (L)
                     586   ;                     + 20         D5    (H)
                     587   ;                     + 22         D5    (L)
                     588   ;                     + 24         D6    (H)
                     589   ;                     + 26         D6    (L)
                     590   ;                     + 28         D7    (H)
                     591   ;                     + 30         D7    (L)
                     592   ;                     + 32         A0    (H)
                     593   ;                     + 34         A0    (L)
                     594   ;                     + 36         A1    (H)
                     595   ;                     + 38         A1    (L)
                     596   ;                     + 40         A2    (H)
                     597   ;                     + 42         A2    (L)
                     598   ;                     + 44         A3    (H)
                     599   ;                     + 46         A3    (L)
                     600   ;                     + 48         A4    (H)
                     601   ;                     + 50         A4    (L)
                     602   ;                     + 52         A5    (H)
                     603   ;                     + 54         A5    (L)
                     604   ;                     + 56         A6    (H)
                     605   ;                     + 58         A6    (L)
                     606   ;                     + 60         Task or ISR's SR
                     607   ;                     + 62         PC of task  (H)
                     608   ;                     + 64         PC of task  (L)                   High Memory
                     609   ;********************************************************************************************************
                     610   
                     611   ; C Code for OSInterrupt exit taken from test book on OS example program 3.16 page 96/305
                     612   
                     613   ; void OSIntExit (void)
                     614   ; {
                     615   ;           OS_ENTER_CRITICAL();
                     616   ;           if ((--OSIntNesting | OSLockNesting) == 0) {
                     617   ;                       OSIntExitY = OSUnMapTbl[OSRdyGrp];
                     618   ;                       OSPrioHighRdy = (INT8U)((OSIntExitY << 3) + OSUnMapTbl[OSRdyTbl[OSIntExitY]]);
                     619   ;                       if (OSPrioHighRdy != OSPrioCur) {
                     620   ;                                       OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                     621   ;                                       OSCtxSwCtr++;
                     622   ;                                       OSIntCtxSw();
                     623   ;                       }
                     624   ;           }
                     625   ;           OS_EXIT_CRITICAL();
                     626   ; }
                     627   
                     628   OSIntExit68K:
00000714  5339 0800  629           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
00000718  0D20      
0000071A  6600 009C  630           bne       OSIntExit68K_1
0000071E  4A39 0800  631           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
00000722  0D22      
00000724  6600 0092  632           bne       OSIntExit68K_1
                     633   
                     634   ;       re-enabling interrupts
00000728  302F 003C  635           move.w    (60,A7),D0                    ; must be LAST nested ISR
0000072C  C07C 0700  636           and.w     #$0700,D0                     ; do we want to change S bit in SR
                     637   ;
00000730  6600 0086  638           bne       OSIntExit68K_1
00000734  41F9 0000  639           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000738  6F7C      
0000073A  4280       640           clr.l     D0
0000073C  1039 0800  641           move.b    _OSRdyGrp,D0
00000740  0D28      
00000742  1230 0800  642           move.b    0(A0,D0.L),D1                 ;  y in D1
                     643   ;
00000746  41F9 0800  644           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
0000074A  0D2A      
0000074C  4280       645           clr.l     D0
0000074E  1001       646           move.b    D1,D0
00000750  41F0 0800  647           lea       0(A0,D0.L),A0
00000754  4280       648           clr.l     D0
00000756  1010       649           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000758  41F9 0000  650           lea       _OSUnMapTbl,A0
0000075C  6F7C      
0000075E  41F0 0800  651           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
00000762  1001       652           move.b    D1,D0
00000764  E708       653           lsl.b     #3,D0                         ;  (y << 3) in D0
00000766  D010       654           add.b     (A0),D0
00000768  13C0 0800  655           move.b    D0,_OSPrioHighRdy
0000076C  0D26      
                     656   ;
0000076E  B039 0800  657           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
00000772  0D24      
00000774  6742       658           beq.s     OSIntExit68K_1
                     659   ;
00000776  41F9 0800  660           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
0000077A  0E4A      
0000077C  4281       661           clr.l     D1
0000077E  1200       662           move.b    D0,D1
00000780  E589       663           lsl.l     #2,D1
00000782  41F0 1800  664           lea       0(A0,D1.L),A0
00000786  23D0 0800  665           move.l    (A0),_OSTCBHighRdy
0000078A  0E42      
                     666   ;
0000078C  52B9 0800  667           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
00000790  0AF0      
                     668   ;
00000792  2079 0800  669           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
00000796  0E3A      
00000798  208F       670           move.l    A7,(A0)
0000079A  4EB9 0000  671           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
0000079E  0C02      
000007A0  2079 0800  672           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
000007A4  0E42      
000007A6  23C8 0800  673           move.l    A0,_OSTCBCur
000007AA  0E3A      
000007AC  13F9 0800  674           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
000007B0  0D26 0800 
000007B4  0D24      
000007B6  2E50       675           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     676   OSIntExit68K_1:
000007B8  4CDF 7FFF  677           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
000007BC  4E73       678           rte                                     ;  Return to task or nested ISR
                     679   
                     680   ;********************************************************************************************************
                     681   ;                                           SYSTEM TICK ISR
                     682   ;
                     683   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     684   ;
                     685   ; Arguments   : none
                     686   ;
                     687   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     688   ;               2) You MUST save ALL the CPU registers as shown below
                     689   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     690   ;********************************************************************************************************
                     691   
                     692   ; C Code for OSInterrupt exit taken from text book on OS example program
                     693   
                     694   ; void OSTickISR(void)
                     695   ; {
                     696   ;          Save processor registers;
                     697   ;          Call OSIntEnter() or increment OSIntNesting;
                     698   ;          Call OSTimeTick();
                     699   ;          Call OSIntExit();
                     700   ;          Restore processor registers;
                     701   ;          Execute a return from interrupt instruction;
                     702   ; }
                     703   
                     704   
                     705   _OSTickISR:
000007BE  007C 0700  706           or.w      #$0700,SR                     ; Disable ALL interrupts
000007C2  5239 0800  707           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
000007C6  0D20      
000007C8  48E7 FFFE  708           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
                     709           ; call your ISR here to clear the tick interrupt
000007CC  4EB9 0000  710           jsr       _Timer_ISR
000007D0  5EDA      
                     711           ;
000007D2  4EB9 0000  712           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
000007D6  1260      
000007D8  6000 FF3A  713           bra       OSIntExit68K                  ; Exit ISR
                     714   ; C:\CPEN412\ASN6\ASN6B_THREADS\ASN6B_APPLICATION.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     715   ; /*
                     716   ; * EXAMPLE_1.C
                     717   ; *
                     718   ; * This is a minimal program to verify multitasking.
                     719   ; *
                     720   ; */
                     721   ; #include <stdio.h>
                     722   ; #include "Bios.h"
                     723   ; #include "ucos_ii.h"
                     724   ; #include "Canbus-Controller.h"
                     725   ; #define STACKSIZE 256
                     726   ; /*******************************************************************************************
                     727   ; ** ADC Types
                     728   ; *******************************************************************************************/
                     729   ; #define TEMP        0
                     730   ; #define POTENTIAL   1
                     731   ; #define LIGHT       2
                     732   ; #define SWITCHES    3
                     733   ; /*******************************************************************************************
                     734   ; ** Task Priority for Mutex
                     735   ; Ref: https://www.intel.com/content/www/us/en/support/programmable/support-resources/design-examples/horizontal/exm-micro-mutex.html?fbclid=IwAR2KdOFtTFDJYERh3MYIPLRbH80BVaIo9fdZTChviTEgzZ-bAJwRikO9maE
                     736   ; *******************************************************************************************/
                     737   ; #define MUTEX_PRIORITY 5
                     738   ; /*
                     739   ; ** Stacks for each task are allocated here in the application in this case = 256 bytes
                     740   ; ** but you can change size if required
                     741   ; */
                     742   ; OS_STK Task1Stk[STACKSIZE];
                     743   ; OS_STK Task2Stk[STACKSIZE];
                     744   ; OS_STK Task3Stk[STACKSIZE];
                     745   ; OS_STK Task4Stk[STACKSIZE];
                     746   ; OS_STK Task5Stk[STACKSIZE];
                     747   ; /* Declaration of the mutex*/
                     748   ; OS_EVENT  *mutex;
                     749   ; /* Prototypes for our tasks/threads*/
                     750   ; void Task1(void *); /* (void *) means the child task expects no data from parent*/
                     751   ; void Task2(void *);
                     752   ; void Task3(void *);
                     753   ; void Task4(void *);
                     754   ; void Task5(void *);
                     755   ; /*******************************************************************************************
                     756   ; ** Global Variables
                     757   ; *******************************************************************************************/
                     758   ; unsigned char temp, potential, light;
                     759   ; int switches;
                     760   ; /*
                     761   ; ** Our main application which has to
                     762   ; ** 1) Initialise any peripherals on the board, e.g. RS232 for hyperterminal + LCD
                     763   ; ** 2) Call OSInit() to initialise the OS
                     764   ; ** 3) Create our application task/threads
                     765   ; ** 4) Call OSStart()
                     766   ; */
                     767   ; void main(void)
                     768   ; {
                     769   _main:
000007DC  2F0A       770          move.l    A2,-(A7)
000007DE  45F9 0000  771          lea       _OSTaskCreate.L,A2
000007E2  47AA      
                     772   ; // initialise board hardware by calling our routines from the BIOS.C source file
                     773   ; Init_RS232();
000007E4  4EB9 0000  774          jsr       _Init_RS232
000007E8  5D50      
                     775   ; Init_LCD();
000007EA  4EB9 0000  776          jsr       _Init_LCD
000007EE  5E08      
                     777   ; // initialise CanBus controllers
                     778   ; Init_CanBus_Controller0();
000007F0  4EB9 0000  779          jsr       _Init_CanBus_Controller0
000007F4  5F02      
                     780   ; Init_CanBus_Controller1();
000007F6  4EB9 0000  781          jsr       _Init_CanBus_Controller1
000007FA  5F92      
                     782   ; /* display welcome message on LCD display */
                     783   ; Oline0("Altera DE1/68K");
000007FC  4879 0000  784          pea       @asn6b_~1_1.L
00000800  6EC4      
00000802  4EB9 0000  785          jsr       _Oline0
00000806  5E7E      
00000808  584F       786          addq.w    #4,A7
                     787   ; Oline1("Micrium uC/OS-II RTOS");
0000080A  4879 0000  788          pea       @asn6b_~1_2.L
0000080E  6ED4      
00000810  4EB9 0000  789          jsr       _Oline1
00000814  5EAC      
00000816  584F       790          addq.w    #4,A7
                     791   ; OSInit(); // call to initialise the OS
00000818  4EB9 0000  792          jsr       _OSInit
0000081C  1072      
                     793   ; //initialise mutex
                     794   ; initOSDataStructs();
0000081E  4EB9 0000  795          jsr       _initOSDataStructs
00000822  0AEE      
                     796   ; /*
                     797   ; ** Now create the 4 child tasks and pass them no data.
                     798   ; ** the smaller the numerical priority value, the higher the task priority
                     799   ; */
                     800   ; OSTaskCreate(Task1, OS_NULL, &Task1Stk[STACKSIZE], 11); // highest priority task
00000824  4878 000B  801          pea       11
00000828  41F9 0800  802          lea       _Task1Stk.L,A0
0000082C  00E0      
0000082E  D0FC 0200  803          add.w     #512,A0
00000832  2F08       804          move.l    A0,-(A7)
00000834  42A7       805          clr.l     -(A7)
00000836  4879 0000  806          pea       _Task1.L
0000083A  08C4      
0000083C  4E92       807          jsr       (A2)
0000083E  DEFC 0010  808          add.w     #16,A7
                     809   ; OSTaskCreate(Task2, OS_NULL, &Task2Stk[STACKSIZE], 12); 
00000842  4878 000C  810          pea       12
00000846  41F9 0800  811          lea       _Task2Stk.L,A0
0000084A  02E0      
0000084C  D0FC 0200  812          add.w     #512,A0
00000850  2F08       813          move.l    A0,-(A7)
00000852  42A7       814          clr.l     -(A7)
00000854  4879 0000  815          pea       _Task2.L
00000858  099C      
0000085A  4E92       816          jsr       (A2)
0000085C  DEFC 0010  817          add.w     #16,A7
                     818   ; OSTaskCreate(Task3, OS_NULL, &Task3Stk[STACKSIZE], 13);
00000860  4878 000D  819          pea       13
00000864  41F9 0800  820          lea       _Task3Stk.L,A0
00000868  04E0      
0000086A  D0FC 0200  821          add.w     #512,A0
0000086E  2F08       822          move.l    A0,-(A7)
00000870  42A7       823          clr.l     -(A7)
00000872  4879 0000  824          pea       _Task3.L
00000876  0A00      
00000878  4E92       825          jsr       (A2)
0000087A  DEFC 0010  826          add.w     #16,A7
                     827   ; OSTaskCreate(Task4, OS_NULL, &Task4Stk[STACKSIZE], 14); 
0000087E  4878 000E  828          pea       14
00000882  41F9 0800  829          lea       _Task4Stk.L,A0
00000886  06E0      
00000888  D0FC 0200  830          add.w     #512,A0
0000088C  2F08       831          move.l    A0,-(A7)
0000088E  42A7       832          clr.l     -(A7)
00000890  4879 0000  833          pea       _Task4.L
00000894  0A50      
00000896  4E92       834          jsr       (A2)
00000898  DEFC 0010  835          add.w     #16,A7
                     836   ; OSTaskCreate(Task5, OS_NULL, &Task5Stk[STACKSIZE], 15); // lowest priority task
0000089C  4878 000F  837          pea       15
000008A0  41F9 0800  838          lea       _Task5Stk.L,A0
000008A4  08E0      
000008A6  D0FC 0200  839          add.w     #512,A0
000008AA  2F08       840          move.l    A0,-(A7)
000008AC  42A7       841          clr.l     -(A7)
000008AE  4879 0000  842          pea       _Task5.L
000008B2  0AA0      
000008B4  4E92       843          jsr       (A2)
000008B6  DEFC 0010  844          add.w     #16,A7
                     845   ; OSStart(); // call to start the OS scheduler, (never returns from this function)
000008BA  4EB9 0000  846          jsr       _OSStart
000008BE  11DA      
000008C0  245F       847          move.l    (A7)+,A2
000008C2  4E75       848          rts
                     849   ; }
                     850   ; /*
                     851   ; ** IMPORTANT : Timer 1 interrupts must be started by the highest priority task
                     852   ; ** that runs first which is Task2
                     853   ; */
                     854   ; void Task1(void *pdata)
                     855   ; {
                     856   _Task1:
000008C4  4E56 FFFC  857          link      A6,#-4
000008C8  48E7 0030  858          movem.l   A2/A3,-(A7)
000008CC  45F9 0000  859          lea       _CanBus1_Receive.L,A2
000008D0  6176      
000008D2  47F9 0000  860          lea       _CanBus0_Transmit.L,A3
000008D6  6022      
                     861   ; INT8U  return_code = OS_ERR_NONE;
000008D8  422E FFFF  862          clr.b     -1(A6)
                     863   ; // must start timer ticker here
                     864   ; Timer1_Init() ; // this function is in BIOS.C and written by us to start timer
000008DC  4EB9 0000  865          jsr       _Timer1_Init
000008E0  5EF0      
                     866   ; for (;;) {
                     867   Task1_1:
                     868   ; printf("|=========MEASURING==========|\n");
000008E2  4879 0000  869          pea       @asn6b_~1_3.L
000008E6  6EEA      
000008E8  4EB9 0000  870          jsr       _printf
000008EC  642A      
000008EE  584F       871          addq.w    #4,A7
                     872   ; /*Acquire Mutex*/
                     873   ; OSMutexPend(mutex, 0, &return_code);
000008F0  486E FFFF  874          pea       -1(A6)
000008F4  42A7       875          clr.l     -(A7)
000008F6  2F39 0800  876          move.l    _mutex.L,-(A7)
000008FA  0AE0      
000008FC  4EB9 0000  877          jsr       _OSMutexPend
00000900  32AE      
00000902  DEFC 000C  878          add.w     #12,A7
                     879   ; CanBus0_Transmit(temp) ;       // transmit a message via Controller 0
00000906  1239 0800  880          move.b    _temp.L,D1
0000090A  0AE4      
0000090C  C2BC 0000  881          and.l     #255,D1
00000910  00FF      
00000912  2F01       882          move.l    D1,-(A7)
00000914  4E93       883          jsr       (A3)
00000916  584F       884          addq.w    #4,A7
                     885   ; CanBus1_Receive(TEMP) ;        // receive a message via Controller 1 (and display it)
00000918  42A7       886          clr.l     -(A7)
0000091A  4E92       887          jsr       (A2)
0000091C  584F       888          addq.w    #4,A7
                     889   ; CanBus0_Transmit(potential) ;       // transmit a message via Controller 0
0000091E  1239 0800  890          move.b    _potential.L,D1
00000922  0AE6      
00000924  C2BC 0000  891          and.l     #255,D1
00000928  00FF      
0000092A  2F01       892          move.l    D1,-(A7)
0000092C  4E93       893          jsr       (A3)
0000092E  584F       894          addq.w    #4,A7
                     895   ; CanBus1_Receive(POTENTIAL) ;        // receive a message via Controller 1 (and display it)
00000930  4878 0001  896          pea       1
00000934  4E92       897          jsr       (A2)
00000936  584F       898          addq.w    #4,A7
                     899   ; CanBus0_Transmit(light) ;       // transmit a message via Controller 0
00000938  1239 0800  900          move.b    _light.L,D1
0000093C  0AE8      
0000093E  C2BC 0000  901          and.l     #255,D1
00000942  00FF      
00000944  2F01       902          move.l    D1,-(A7)
00000946  4E93       903          jsr       (A3)
00000948  584F       904          addq.w    #4,A7
                     905   ; CanBus1_Receive(LIGHT) ;        // receive a message via Controller 1 (and display it)
0000094A  4878 0002  906          pea       2
0000094E  4E92       907          jsr       (A2)
00000950  584F       908          addq.w    #4,A7
                     909   ; CanBus0_Transmit(switches) ;       // transmit a message via Controller 0
00000952  2239 0800  910          move.l    _switches.L,D1
00000956  0AEA      
00000958  C2BC 0000  911          and.l     #255,D1
0000095C  00FF      
0000095E  2F01       912          move.l    D1,-(A7)
00000960  4E93       913          jsr       (A3)
00000962  584F       914          addq.w    #4,A7
                     915   ; CanBus1_Receive(SWITCHES) ;        // receive a message via Controller 1 (and display it)
00000964  4878 0003  916          pea       3
00000968  4E92       917          jsr       (A2)
0000096A  584F       918          addq.w    #4,A7
                     919   ; /*Release Mutex*/
                     920   ; return_code = OSMutexPost(mutex);
0000096C  2F39 0800  921          move.l    _mutex.L,-(A7)
00000970  0AE0      
00000972  4EB9 0000  922          jsr       _OSMutexPost
00000976  3590      
00000978  584F       923          addq.w    #4,A7
0000097A  1D40 FFFF  924          move.b    D0,-1(A6)
                     925   ; printf("|===========================|\n");
0000097E  4879 0000  926          pea       @asn6b_~1_4.L
00000982  6F0A      
00000984  4EB9 0000  927          jsr       _printf
00000988  642A      
0000098A  584F       928          addq.w    #4,A7
                     929   ; OSTimeDly(100); //OS Delay for half a second = 500ms 
0000098C  4878 0064  930          pea       100
00000990  4EB9 0000  931          jsr       _OSTimeDly
00000994  510A      
00000996  584F       932          addq.w    #4,A7
00000998  6000 FF48  933          bra       Task1_1
                     934   ; }
                     935   ; }
                     936   ; /*
                     937   ; ** Task 2 below was created with the highest priority so it must start timer1
                     938   ; ** so that it produces interrupts for the 100hz context switches
                     939   ; */
                     940   ; void Task2(void *pdata)
                     941   ; {
                     942   _Task2:
0000099C  4E56 FFF8  943          link      A6,#-8
                     944   ; unsigned int i = 0;
000009A0  42AE FFFA  945          clr.l     -6(A6)
                     946   ; INT8U  return_code = OS_ERR_NONE;
000009A4  422E FFFF  947          clr.b     -1(A6)
                     948   ; for (;;) {
                     949   Task2_1:
                     950   ; /*Acquire Mutex*/
                     951   ; OSMutexPend(mutex, 0, &return_code);
000009A8  486E FFFF  952          pea       -1(A6)
000009AC  42A7       953          clr.l     -(A7)
000009AE  2F39 0800  954          move.l    _mutex.L,-(A7)
000009B2  0AE0      
000009B4  4EB9 0000  955          jsr       _OSMutexPend
000009B8  32AE      
000009BA  DEFC 000C  956          add.w     #12,A7
                     957   ; switches = (PortB << 8) | (PortA);
000009BE  1039 0040  958          move.b    4194306,D0
000009C2  0002      
000009C4  C0BC 0000  959          and.l     #255,D0
000009C8  00FF      
000009CA  E188       960          lsl.l     #8,D0
000009CC  1239 0040  961          move.b    4194304,D1
000009D0  0000      
000009D2  C2BC 0000  962          and.l     #255,D1
000009D6  00FF      
000009D8  8081       963          or.l      D1,D0
000009DA  23C0 0800  964          move.l    D0,_switches.L
000009DE  0AEA      
                     965   ; /*Release Mutex*/
                     966   ; return_code = OSMutexPost(mutex);    
000009E0  2F39 0800  967          move.l    _mutex.L,-(A7)
000009E4  0AE0      
000009E6  4EB9 0000  968          jsr       _OSMutexPost
000009EA  3590      
000009EC  584F       969          addq.w    #4,A7
000009EE  1D40 FFFF  970          move.b    D0,-1(A6)
                     971   ; OSTimeDly(10);
000009F2  4878 000A  972          pea       10
000009F6  4EB9 0000  973          jsr       _OSTimeDly
000009FA  510A      
000009FC  584F       974          addq.w    #4,A7
000009FE  60A8       975          bra       Task2_1
                     976   ; }
                     977   ; }
                     978   ; void Task3(void *pdata)
                     979   ; {
                     980   _Task3:
00000A00  4E56 FFFC  981          link      A6,#-4
                     982   ; INT8U  return_code = OS_ERR_NONE;
00000A04  422E FFFF  983          clr.b     -1(A6)
                     984   ; for (;;) {
                     985   Task3_1:
                     986   ; /*Acquire Mutex*/
                     987   ; OSMutexPend(mutex, 0, &return_code);
00000A08  486E FFFF  988          pea       -1(A6)
00000A0C  42A7       989          clr.l     -(A7)
00000A0E  2F39 0800  990          move.l    _mutex.L,-(A7)
00000A12  0AE0      
00000A14  4EB9 0000  991          jsr       _OSMutexPend
00000A18  32AE      
00000A1A  DEFC 000C  992          add.w     #12,A7
                     993   ; potential = ADCWrite(POTENTIAL);
00000A1E  4878 0001  994          pea       1
00000A22  4EB9 0000  995          jsr       _ADCWrite
00000A26  6356      
00000A28  584F       996          addq.w    #4,A7
00000A2A  13C0 0800  997          move.b    D0,_potential.L
00000A2E  0AE6      
                     998   ; /*Release Mutex*/
                     999   ; return_code = OSMutexPost(mutex);
00000A30  2F39 0800 1000          move.l    _mutex.L,-(A7)
00000A34  0AE0      
00000A36  4EB9 0000 1001          jsr       _OSMutexPost
00000A3A  3590      
00000A3C  584F      1002          addq.w    #4,A7
00000A3E  1D40 FFFF 1003          move.b    D0,-1(A6)
                    1004   ; OSTimeDly(20);
00000A42  4878 0014 1005          pea       20
00000A46  4EB9 0000 1006          jsr       _OSTimeDly
00000A4A  510A      
00000A4C  584F      1007          addq.w    #4,A7
00000A4E  60B8      1008          bra       Task3_1
                    1009   ; }
                    1010   ; }
                    1011   ; void Task4(void *pdata)
                    1012   ; {
                    1013   _Task4:
00000A50  4E56 FFFC 1014          link      A6,#-4
                    1015   ; INT8U  return_code = OS_ERR_NONE;
00000A54  422E FFFF 1016          clr.b     -1(A6)
                    1017   ; for (;;) {
                    1018   Task4_1:
                    1019   ; /*Acquire Mutex*/
                    1020   ; OSMutexPend(mutex, 0, &return_code);
00000A58  486E FFFF 1021          pea       -1(A6)
00000A5C  42A7      1022          clr.l     -(A7)
00000A5E  2F39 0800 1023          move.l    _mutex.L,-(A7)
00000A62  0AE0      
00000A64  4EB9 0000 1024          jsr       _OSMutexPend
00000A68  32AE      
00000A6A  DEFC 000C 1025          add.w     #12,A7
                    1026   ; light = ADCWrite(LIGHT);
00000A6E  4878 0002 1027          pea       2
00000A72  4EB9 0000 1028          jsr       _ADCWrite
00000A76  6356      
00000A78  584F      1029          addq.w    #4,A7
00000A7A  13C0 0800 1030          move.b    D0,_light.L
00000A7E  0AE8      
                    1031   ; /*Release Mutex*/
                    1032   ; return_code = OSMutexPost(mutex);
00000A80  2F39 0800 1033          move.l    _mutex.L,-(A7)
00000A84  0AE0      
00000A86  4EB9 0000 1034          jsr       _OSMutexPost
00000A8A  3590      
00000A8C  584F      1035          addq.w    #4,A7
00000A8E  1D40 FFFF 1036          move.b    D0,-1(A6)
                    1037   ; OSTimeDly(50);
00000A92  4878 0032 1038          pea       50
00000A96  4EB9 0000 1039          jsr       _OSTimeDly
00000A9A  510A      
00000A9C  584F      1040          addq.w    #4,A7
00000A9E  60B8      1041          bra       Task4_1
                    1042   ; }
                    1043   ; }
                    1044   ; void Task5(void *pdata)
                    1045   ; {
                    1046   _Task5:
00000AA0  4E56 FFFC 1047          link      A6,#-4
                    1048   ; INT8U  return_code = OS_ERR_NONE;
00000AA4  422E FFFF 1049          clr.b     -1(A6)
                    1050   ; for (;;) {
                    1051   Task5_1:
                    1052   ; /*Acquire Mutex*/
                    1053   ; OSMutexPend(mutex, 0, &return_code);
00000AA8  486E FFFF 1054          pea       -1(A6)
00000AAC  42A7      1055          clr.l     -(A7)
00000AAE  2F39 0800 1056          move.l    _mutex.L,-(A7)
00000AB2  0AE0      
00000AB4  4EB9 0000 1057          jsr       _OSMutexPend
00000AB8  32AE      
00000ABA  DEFC 000C 1058          add.w     #12,A7
                    1059   ; temp = ADCWrite(TEMP);
00000ABE  42A7      1060          clr.l     -(A7)
00000AC0  4EB9 0000 1061          jsr       _ADCWrite
00000AC4  6356      
00000AC6  584F      1062          addq.w    #4,A7
00000AC8  13C0 0800 1063          move.b    D0,_temp.L
00000ACC  0AE4      
                    1064   ; /*Release Mutex*/
                    1065   ; return_code = OSMutexPost(mutex);
00000ACE  2F39 0800 1066          move.l    _mutex.L,-(A7)
00000AD2  0AE0      
00000AD4  4EB9 0000 1067          jsr       _OSMutexPost
00000AD8  3590      
00000ADA  584F      1068          addq.w    #4,A7
00000ADC  1D40 FFFF 1069          move.b    D0,-1(A6)
                    1070   ; OSTimeDly(200);
00000AE0  4878 00C8 1071          pea       200
00000AE4  4EB9 0000 1072          jsr       _OSTimeDly
00000AE8  510A      
00000AEA  584F      1073          addq.w    #4,A7
00000AEC  60BA      1074          bra       Task5_1
                    1075   ; }
                    1076   ; }
                    1077   ; /* This function simply creates the Mutex*/
                    1078   ; void initOSDataStructs(void)
                    1079   ; {
                    1080   _initOSDataStructs:
00000AEE  4E56 FFFC 1081          link      A6,#-4
                    1082   ; INT8U return_code = OS_ERR_NONE;
00000AF2  422E FFFF 1083          clr.b     -1(A6)
                    1084   ; mutex = OSMutexCreate(MUTEX_PRIORITY, &return_code);
00000AF6  486E FFFF 1085          pea       -1(A6)
00000AFA  4878 0005 1086          pea       5
00000AFE  4EB9 0000 1087          jsr       _OSMutexCreate
00000B02  301A      
00000B04  504F      1088          addq.w    #8,A7
00000B06  23C0 0800 1089          move.l    D0,_mutex.L
00000B0A  0AE0      
                    1090   ; return;
00000B0C  4E5E      1091          unlk      A6
00000B0E  4E75      1092          rts
                    1093   ; }
                    1094   ; C:\CPEN412\ASN6\ASN6B_THREADS\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1095   ; /*
                    1096   ; *********************************************************************************************************
                    1097   ; *                                               uC/OS-II
                    1098   ; *                                         The Real-Time Kernel
                    1099   ; *
                    1100   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                    1101   ; *                                          All Rights Reserved
                    1102   ; *
                    1103   ; *
                    1104   ; *                                         68000 Specific C code
                    1105   ; *                                                IDE68K
                    1106   ; *
                    1107   ; * File         : OS_CPU_C.C
                    1108   ; * By           : Jean J. Labrosse
                    1109   ; *********************************************************************************************************
                    1110   ; */
                    1111   ; #ifndef  OS_MASTER_FILE
                    1112   ; #include "ucos_ii.h"
                    1113   ; #endif
                    1114   ; #include "Bios.h"
                    1115   ; /*
                    1116   ; *********************************************************************************************************
                    1117   ; *                                           REVISION HISTORY
                    1118   ; *
                    1119   ; * $Log$
                    1120   ; *
                    1121   ; *********************************************************************************************************
                    1122   ; */
                    1123   ; #if OS_TMR_EN > 0
                    1124   ; INT8U OSTmrTickCtr;
                    1125   ; #endif
                    1126   ; /*$PAGE*/
                    1127   ; /*
                    1128   ; *********************************************************************************************************
                    1129   ; *                                        INITIALIZE A TASK'S STACK
                    1130   ; *
                    1131   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                    1132   ; *              stack frame of the task being created.  This function is highly processor specific.
                    1133   ; *
                    1134   ; * Arguments  : task          is a pointer to the task code
                    1135   ; *
                    1136   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                    1137   ; *                            when the task first executes.
                    1138   ; *
                    1139   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                    1140   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                    1141   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                    1142   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                    1143   ; *                            of the stack.
                    1144   ; *
                    1145   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                    1146   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                    1147   ; *
                    1148   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                    1149   ; *              been placed on the stack in the proper order.
                    1150   ; *
                    1151   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 68xxx processor
                    1152   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                    1153   ; *                 mode.
                    1154   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                    1155   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                    1156   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                    1157   ; *                 OSTaskIdle() and OSTaskStat().
                    1158   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                    1159   ; *********************************************************************************************************
                    1160   ; */
                    1161   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                    1162   ; {
                    1163   _OSTaskStkInit:
00000B10  4E56 0000 1164          link      A6,#0
00000B14  48E7 3000 1165          movem.l   D2/D3,-(A7)
                    1166   ; INT32U  *pstk32;
                    1167   ; INT16U  *pstk16;
                    1168   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                    1169   ; /* Load stack pointer and align on 32-bit bound  */
                    1170   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
00000B18  202E 0010 1171          move.l    16(A6),D0
00000B1C  C0BC 7FFF 1172          and.l     #2147483647,D0
00000B20  FFFF      
00000B22  2400      1173          move.l    D0,D2
                    1174   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                    1175   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
00000B24  5982      1176          subq.l    #4,D2
00000B26  2042      1177          move.l    D2,A0
00000B28  20AE 000C 1178          move.l    12(A6),(A0)
                    1179   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000B2C  5982      1180          subq.l    #4,D2
00000B2E  2042      1181          move.l    D2,A0
00000B30  20AE 0008 1182          move.l    8(A6),(A0)
                    1183   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                    1184   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
00000B34  5982      1185          subq.l    #4,D2
00000B36  2042      1186          move.l    D2,A0
00000B38  20AE 0008 1187          move.l    8(A6),(A0)
                    1188   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
00000B3C  2602      1189          move.l    D2,D3
                    1190   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
00000B3E  5583      1191          subq.l    #2,D3
00000B40  2043      1192          move.l    D3,A0
00000B42  30BC 2000 1193          move.w    #8192,(A0)
                    1194   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
00000B46  2403      1195          move.l    D3,D2
                    1196   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                    1197   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
00000B48  5982      1198          subq.l    #4,D2
00000B4A  2042      1199          move.l    D2,A0
00000B4C  20BC 00A6 1200          move.l    #10879142,(A0)
00000B50  00A6      
                    1201   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
00000B52  5982      1202          subq.l    #4,D2
00000B54  2042      1203          move.l    D2,A0
00000B56  20BC 00A5 1204          move.l    #10813605,(A0)
00000B5A  00A5      
                    1205   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
00000B5C  5982      1206          subq.l    #4,D2
00000B5E  2042      1207          move.l    D2,A0
00000B60  20BC 00A4 1208          move.l    #10748068,(A0)
00000B64  00A4      
                    1209   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
00000B66  5982      1210          subq.l    #4,D2
00000B68  2042      1211          move.l    D2,A0
00000B6A  20BC 00A3 1212          move.l    #10682531,(A0)
00000B6E  00A3      
                    1213   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
00000B70  5982      1214          subq.l    #4,D2
00000B72  2042      1215          move.l    D2,A0
00000B74  20BC 00A2 1216          move.l    #10616994,(A0)
00000B78  00A2      
                    1217   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
00000B7A  5982      1218          subq.l    #4,D2
00000B7C  2042      1219          move.l    D2,A0
00000B7E  20BC 00A1 1220          move.l    #10551457,(A0)
00000B82  00A1      
                    1221   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
00000B84  5982      1222          subq.l    #4,D2
00000B86  2042      1223          move.l    D2,A0
00000B88  20BC 00A0 1224          move.l    #10485920,(A0)
00000B8C  00A0      
                    1225   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
00000B8E  5982      1226          subq.l    #4,D2
00000B90  2042      1227          move.l    D2,A0
00000B92  20BC 00D7 1228          move.l    #14090455,(A0)
00000B96  00D7      
                    1229   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000B98  5982      1230          subq.l    #4,D2
00000B9A  2042      1231          move.l    D2,A0
00000B9C  20BC 00D6 1232          move.l    #14024918,(A0)
00000BA0  00D6      
                    1233   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
00000BA2  5982      1234          subq.l    #4,D2
00000BA4  2042      1235          move.l    D2,A0
00000BA6  20BC 00D5 1236          move.l    #13959381,(A0)
00000BAA  00D5      
                    1237   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
00000BAC  5982      1238          subq.l    #4,D2
00000BAE  2042      1239          move.l    D2,A0
00000BB0  20BC 00D4 1240          move.l    #13893844,(A0)
00000BB4  00D4      
                    1241   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000BB6  5982      1242          subq.l    #4,D2
00000BB8  2042      1243          move.l    D2,A0
00000BBA  20BC 00D3 1244          move.l    #13828307,(A0)
00000BBE  00D3      
                    1245   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
00000BC0  5982      1246          subq.l    #4,D2
00000BC2  2042      1247          move.l    D2,A0
00000BC4  20BC 00D2 1248          move.l    #13762770,(A0)
00000BC8  00D2      
                    1249   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
00000BCA  5982      1250          subq.l    #4,D2
00000BCC  2042      1251          move.l    D2,A0
00000BCE  20BC 00D1 1252          move.l    #13697233,(A0)
00000BD2  00D1      
                    1253   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
00000BD4  5982      1254          subq.l    #4,D2
00000BD6  2042      1255          move.l    D2,A0
00000BD8  20BC 00D0 1256          move.l    #13631696,(A0)
00000BDC  00D0      
                    1257   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
00000BDE  2002      1258          move.l    D2,D0
00000BE0  4CDF 000C 1259          movem.l   (A7)+,D2/D3
00000BE4  4E5E      1260          unlk      A6
00000BE6  4E75      1261          rts
                    1262   ; }
                    1263   ; /*$PAGE*/
                    1264   ; /*
                    1265   ; *********************************************************************************************************
                    1266   ; *                                             GET ISR VECTOR
                    1267   ; *
                    1268   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                    1269   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000 (Not an issue with 68000 as VBR is always fixed at 0, but other 68k derivaties allowed VBR to be relocated - e.g. 68020).
                    1270   ; *
                    1271   ; * Arguments  : vect     is the vector number
                    1272   ; *
                    1273   ; * Note(s)    : 1) Interrupts are disabled during this call
                    1274   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                    1275   ; *********************************************************************************************************
                    1276   ; */
                    1277   ; /*$PAGE*/
                    1278   ; #if OS_CPU_HOOKS_EN
                    1279   ; /*
                    1280   ; *********************************************************************************************************
                    1281   ; *                                       OS INITIALIZATION HOOK
                    1282   ; *                                            (BEGINNING)
                    1283   ; *
                    1284   ; * Description: This function is called by OSInit() at the beginning of OSInit(). Uou can use it to initialise
                    1285   ; *              Your board hardware (it could be done somewhere else too, but this is a convenient place)
                    1286   ; *
                    1287   ; * Arguments  : none
                    1288   ; *
                    1289   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1290   ; *********************************************************************************************************
                    1291   ; */
                    1292   ; void OSInitHookBegin(void)
                    1293   ; {
                    1294   _OSInitHookBegin:
00000BE8  4E75      1295          rts
                    1296   ; }
                    1297   ; /*
                    1298   ; *********************************************************************************************************
                    1299   ; *                                       OS INITIALIZATION HOOK
                    1300   ; *                                               (END)
                    1301   ; *
                    1302   ; * Description: This function is called by OSInit() at the end of OSInit().
                    1303   ; *
                    1304   ; * Arguments  : none
                    1305   ; *
                    1306   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                    1307   ; *********************************************************************************************************
                    1308   ; */
                    1309   ; void OSInitHookEnd(void)
                    1310   ; {
                    1311   _OSInitHookEnd:
                    1312   ; #if OS_TMR_EN > 0
                    1313   ; OSTmrTickCtr = 0;
00000BEA  4239 0800 1314          clr.b     _OSTmrTickCtr.L
00000BEE  0AEE      
00000BF0  4E75      1315          rts
                    1316   ; #endif
                    1317   ; }
                    1318   ; /*
                    1319   ; *********************************************************************************************************
                    1320   ; *                                          TASK CREATION HOOK
                    1321   ; *
                    1322   ; * Description: This function is called when a task is created.
                    1323   ; *
                    1324   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                    1325   ; *
                    1326   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1327   ; *********************************************************************************************************
                    1328   ; */
                    1329   ; void OSTaskCreateHook(OS_TCB *ptcb)
                    1330   ; {
                    1331   _OSTaskCreateHook:
00000BF2  4E56 0000 1332          link      A6,#0
00000BF6  4E5E      1333          unlk      A6
00000BF8  4E75      1334          rts
                    1335   ; }
                    1336   ; /*
                    1337   ; *********************************************************************************************************
                    1338   ; *                                           TASK DELETION HOOK
                    1339   ; *
                    1340   ; * Description: This function is called when a task is deleted.
                    1341   ; *
                    1342   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                    1343   ; *
                    1344   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1345   ; *********************************************************************************************************
                    1346   ; */
                    1347   ; void OSTaskDelHook(OS_TCB *ptcb)
                    1348   ; {
                    1349   _OSTaskDelHook:
00000BFA  4E56 0000 1350          link      A6,#0
00000BFE  4E5E      1351          unlk      A6
00000C00  4E75      1352          rts
                    1353   ; }
                    1354   ; /*
                    1355   ; *********************************************************************************************************
                    1356   ; *                                           TASK SWITCH HOOK
                    1357   ; *
                    1358   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                    1359   ; *              operations during a context switch.
                    1360   ; *
                    1361   ; * Arguments  : none
                    1362   ; *
                    1363   ; * Note(s)    : 1) Interrupts are disabled during this call.
                    1364   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                    1365   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                    1366   ; *                 task being switched out (i.e. the preempted task).
                    1367   ; *********************************************************************************************************
                    1368   ; */
                    1369   ; void OSTaskSwHook(void)
                    1370   ; {
                    1371   _OSTaskSwHook:
00000C02  4E75      1372          rts
                    1373   ; }
                    1374   ; /*
                    1375   ; *********************************************************************************************************
                    1376   ; *                                           TASK IDLE HOOK
                    1377   ; *
                    1378   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                    1379   ; *              operations during the idle task.
                    1380   ; *
                    1381   ; * Arguments  : none
                    1382   ; *
                    1383   ; * Note(s)    : none
                    1384   ; *********************************************************************************************************
                    1385   ; */
                    1386   ; void OSTaskIdleHook(void)
                    1387   ; {
                    1388   _OSTaskIdleHook:
00000C04  4E75      1389          rts
                    1390   ; }
                    1391   ; /*
                    1392   ; *********************************************************************************************************
                    1393   ; *                                           TASK RETURN HOOK
                    1394   ; *
                    1395   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    1396   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    1397   ; *
                    1398   ; * Arguments  : Pointer to currently running TCB
                    1399   ; *
                    1400   ; * Note(s)    : none
                    1401   ; *********************************************************************************************************
                    1402   ; */
                    1403   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1404   ; {
                    1405   _OSTaskReturnHook:
00000C06  4E56 0000 1406          link      A6,#0
00000C0A  4E5E      1407          unlk      A6
00000C0C  4E75      1408          rts
                    1409   ; }
                    1410   ; /*
                    1411   ; *********************************************************************************************************
                    1412   ; *                                           STATISTIC TASK HOOK
                    1413   ; *
                    1414   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1415   ; *              application to add functionality to the statistics task.
                    1416   ; *
                    1417   ; * Arguments  : none
                    1418   ; *********************************************************************************************************
                    1419   ; */
                    1420   ; void OSTaskStatHook(void)
                    1421   ; {
                    1422   _OSTaskStatHook:
00000C0E  4E75      1423          rts
                    1424   ; }
                    1425   ; /*
                    1426   ; *********************************************************************************************************
                    1427   ; *                                               TICK HOOK
                    1428   ; *
                    1429   ; * Description: This function is called every tick.
                    1430   ; *
                    1431   ; * Arguments  : none
                    1432   ; *
                    1433   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1434   ; *********************************************************************************************************
                    1435   ; */
                    1436   ; void OSTimeTickHook(void)
                    1437   ; {
                    1438   _OSTimeTickHook:
                    1439   ; #if OS_TMR_EN > 0
                    1440   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
00000C10  3039 0800 1441          move.w    _OSTmrUsed.L,D0
00000C14  1796      
00000C16  0C40 0000 1442          cmp.w     #0,D0
00000C1A  631E      1443          bls.s     OSTimeTickHook_1
00000C1C  5239 0800 1444          addq.b    #1,_OSTmrTickCtr.L
00000C20  0AEE      
00000C22  1039 0800 1445          move.b    _OSTmrTickCtr.L,D0
00000C26  0AEE      
00000C28  0C00 000A 1446          cmp.b     #10,D0
00000C2C  650C      1447          blo.s     OSTimeTickHook_1
                    1448   ; OSTmrTickCtr = 0;
00000C2E  4239 0800 1449          clr.b     _OSTmrTickCtr.L
00000C32  0AEE      
                    1450   ; OSTmrSignal();
00000C34  4EB9 0000 1451          jsr       _OSTmrSignal
00000C38  58DA      
                    1452   OSTimeTickHook_1:
00000C3A  4E75      1453          rts
                    1454   ; }
                    1455   ; #endif
                    1456   ; }
                    1457   ; /*
                    1458   ; *********************************************************************************************************
                    1459   ; *                                           OSTCBInit() HOOK
                    1460   ; *
                    1461   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1462   ; *
                    1463   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1464   ; *
                    1465   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1466   ; *********************************************************************************************************
                    1467   ; */
                    1468   ; #if OS_VERSION > 203
                    1469   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1470   ; {
                    1471   _OSTCBInitHook:
00000C3C  4E56 0000 1472          link      A6,#0
00000C40  4E5E      1473          unlk      A6
00000C42  4E75      1474          rts
                    1475   ; }
                    1476   ; #endif
                    1477   ; #endif // OS_CPU_HOOKS_EN
                    1478   ; C:\CPEN412\ASN6\ASN6B_THREADS\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1479   ; /*
                    1480   ; *********************************************************************************************************
                    1481   ; *                                                uC/OS-II
                    1482   ; *                                          The Real-Time Kernel
                    1483   ; *                                             CORE FUNCTIONS
                    1484   ; *
                    1485   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1486   ; *                                           All Rights Reserved
                    1487   ; *
                    1488   ; * File    : OS_CORE.C
                    1489   ; * By      : Jean J. Labrosse
                    1490   ; * Version : V2.92.07
                    1491   ; *
                    1492   ; * LICENSING TERMS:
                    1493   ; * ---------------
                    1494   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1495   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1496   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1497   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1498   ; * licensing fee.
                    1499   ; *********************************************************************************************************
                    1500   ; */
                    1501   ; #define  MICRIUM_SOURCE
                    1502   ; #ifndef  OS_MASTER_FILE
                    1503   ; #define  OS_GLOBALS
                    1504   ; #include <ucos_ii.h>
                    1505   ; #endif
                    1506   ; /*
                    1507   ; *********************************************************************************************************
                    1508   ; *                                      PRIORITY RESOLUTION TABLE
                    1509   ; *
                    1510   ; * Note: Index into table is bit pattern to resolve highest priority
                    1511   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1512   ; *********************************************************************************************************
                    1513   ; */
                    1514   ; INT8U  const  OSUnMapTbl[256] = {
                    1515   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1516   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1517   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1518   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1519   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1520   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1521   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1522   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1523   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1524   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1525   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1526   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1527   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1528   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1529   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1530   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1531   ; };
                    1532   ; /*$PAGE*/
                    1533   ; /*
                    1534   ; *********************************************************************************************************
                    1535   ; *                                         FUNCTION PROTOTYPES
                    1536   ; *********************************************************************************************************
                    1537   ; */
                    1538   ; static  void  OS_InitEventList(void);
                    1539   ; static  void  OS_InitMisc(void);
                    1540   ; static  void  OS_InitRdyList(void);
                    1541   ; static  void  OS_InitTaskIdle(void);
                    1542   ; #if OS_TASK_STAT_EN > 0u
                    1543   ; static  void  OS_InitTaskStat(void);
                    1544   ; #endif
                    1545   ; static  void  OS_InitTCBList(void);
                    1546   ; static  void  OS_SchedNew(void);
                    1547   ; /*$PAGE*/
                    1548   ; /*
                    1549   ; *********************************************************************************************************
                    1550   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1551   ; *
                    1552   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1553   ; *
                    1554   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1555   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1556   ; *                        type is irrelevant.
                    1557   ; *
                    1558   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1559   ; *                        mutex, mailbox or queue.
                    1560   ; *
                    1561   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1562   ; *
                    1563   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1564   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1565   ; *                                                   control block type.
                    1566   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1567   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1568   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1569   ; *
                    1570   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1571   ; *********************************************************************************************************
                    1572   ; */
                    1573   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1574   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1575   ; INT8U     **pname,
                    1576   ; INT8U      *perr)
                    1577   ; {
                    1578   _OSEventNameGet:
00000C44  4E56 FFFC 1579          link      A6,#-4
00000C48  2F02      1580          move.l    D2,-(A7)
00000C4A  242E 0010 1581          move.l    16(A6),D2
                    1582   ; INT8U      len;
                    1583   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1584   ; OS_CPU_SR  cpu_sr = 0u;
                    1585   ; #endif
                    1586   ; #ifdef OS_SAFETY_CRITICAL
                    1587   ; if (perr == (INT8U *)0) {
                    1588   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1589   ; return (0u);
                    1590   ; }
                    1591   ; #endif
                    1592   ; #if OS_ARG_CHK_EN > 0u
                    1593   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1594   ; *perr = OS_ERR_PEVENT_NULL;
                    1595   ; return (0u);
                    1596   ; }
                    1597   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1598   ; *perr = OS_ERR_PNAME_NULL;
                    1599   ; return (0u);
                    1600   ; }
                    1601   ; #endif
                    1602   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000C4E  1039 0800 1603          move.b    _OSIntNesting.L,D0
00000C52  0D20      
00000C54  0C00 0000 1604          cmp.b     #0,D0
00000C58  630C      1605          bls.s     OSEventNameGet_1
                    1606   ; *perr  = OS_ERR_NAME_GET_ISR;
00000C5A  2042      1607          move.l    D2,A0
00000C5C  10BC 0011 1608          move.b    #17,(A0)
                    1609   ; return (0u);
00000C60  4200      1610          clr.b     D0
00000C62  6000 0066 1611          bra       OSEventNameGet_3
                    1612   OSEventNameGet_1:
                    1613   ; }
                    1614   ; switch (pevent->OSEventType) {
00000C66  206E 0008 1615          move.l    8(A6),A0
00000C6A  1010      1616          move.b    (A0),D0
00000C6C  C0BC 0000 1617          and.l     #255,D0
00000C70  00FF      
00000C72  5380      1618          subq.l    #1,D0
00000C74  651C      1619          blo.s     OSEventNameGet_4
00000C76  0C80 0000 1620          cmp.l     #4,D0
00000C7A  0004      
00000C7C  6414      1621          bhs.s     OSEventNameGet_4
00000C7E  E380      1622          asl.l     #1,D0
00000C80  303B 0806 1623          move.w    OSEventNameGet_6(PC,D0.L),D0
00000C84  4EFB 0002 1624          jmp       OSEventNameGet_6(PC,D0.W)
                    1625   OSEventNameGet_6:
00000C88  0008      1626          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000C8A  0008      1627          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000C8C  0008      1628          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000C8E  0008      1629          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1630   OSEventNameGet_7:
                    1631   ; case OS_EVENT_TYPE_SEM:
                    1632   ; case OS_EVENT_TYPE_MUTEX:
                    1633   ; case OS_EVENT_TYPE_MBOX:
                    1634   ; case OS_EVENT_TYPE_Q:
                    1635   ; break;
00000C90  600A      1636          bra.s     OSEventNameGet_5
                    1637   OSEventNameGet_4:
                    1638   ; default:
                    1639   ; *perr = OS_ERR_EVENT_TYPE;
00000C92  2042      1640          move.l    D2,A0
00000C94  10BC 0001 1641          move.b    #1,(A0)
                    1642   ; return (0u);
00000C98  4200      1643          clr.b     D0
00000C9A  602E      1644          bra.s     OSEventNameGet_3
                    1645   OSEventNameGet_5:
                    1646   ; }
                    1647   ; OS_ENTER_CRITICAL();
00000C9C  40E7      1648          dc.w      16615
00000C9E  007C      1649          dc.w      124
00000CA0  0700      1650          dc.w      1792
                    1651   ; *pname = pevent->OSEventName;
00000CA2  206E 0008 1652          move.l    8(A6),A0
00000CA6  226E 000C 1653          move.l    12(A6),A1
00000CAA  22A8 0012 1654          move.l    18(A0),(A1)
                    1655   ; len    = OS_StrLen(*pname);
00000CAE  206E 000C 1656          move.l    12(A6),A0
00000CB2  2F10      1657          move.l    (A0),-(A7)
00000CB4  4EB9 0000 1658          jsr       _OS_StrLen
00000CB8  19B8      
00000CBA  584F      1659          addq.w    #4,A7
00000CBC  1D40 FFFF 1660          move.b    D0,-1(A6)
                    1661   ; OS_EXIT_CRITICAL();
00000CC0  46DF      1662          dc.w      18143
                    1663   ; *perr  = OS_ERR_NONE;
00000CC2  2042      1664          move.l    D2,A0
00000CC4  4210      1665          clr.b     (A0)
                    1666   ; return (len);
00000CC6  102E FFFF 1667          move.b    -1(A6),D0
                    1668   OSEventNameGet_3:
00000CCA  241F      1669          move.l    (A7)+,D2
00000CCC  4E5E      1670          unlk      A6
00000CCE  4E75      1671          rts
                    1672   ; }
                    1673   ; #endif
                    1674   ; /*$PAGE*/
                    1675   ; /*
                    1676   ; *********************************************************************************************************
                    1677   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1678   ; *
                    1679   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1680   ; *
                    1681   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1682   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1683   ; *                        matter the actual type.
                    1684   ; *
                    1685   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1686   ; *                        mutex, mailbox or queue.
                    1687   ; *
                    1688   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1689   ; *
                    1690   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1691   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1692   ; *                                                   control block type.
                    1693   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1694   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1695   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1696   ; *
                    1697   ; * Returns    : None
                    1698   ; *********************************************************************************************************
                    1699   ; */
                    1700   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1701   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1702   ; INT8U     *pname,
                    1703   ; INT8U     *perr)
                    1704   ; {
                    1705   _OSEventNameSet:
00000CD0  4E56 0000 1706          link      A6,#0
00000CD4  2F02      1707          move.l    D2,-(A7)
00000CD6  242E 0010 1708          move.l    16(A6),D2
                    1709   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1710   ; OS_CPU_SR  cpu_sr = 0u;
                    1711   ; #endif
                    1712   ; #ifdef OS_SAFETY_CRITICAL
                    1713   ; if (perr == (INT8U *)0) {
                    1714   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1715   ; return;
                    1716   ; }
                    1717   ; #endif
                    1718   ; #if OS_ARG_CHK_EN > 0u
                    1719   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1720   ; *perr = OS_ERR_PEVENT_NULL;
                    1721   ; return;
                    1722   ; }
                    1723   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1724   ; *perr = OS_ERR_PNAME_NULL;
                    1725   ; return;
                    1726   ; }
                    1727   ; #endif
                    1728   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000CDA  1039 0800 1729          move.b    _OSIntNesting.L,D0
00000CDE  0D20      
00000CE0  0C00 0000 1730          cmp.b     #0,D0
00000CE4  630A      1731          bls.s     OSEventNameSet_1
                    1732   ; *perr = OS_ERR_NAME_SET_ISR;
00000CE6  2042      1733          move.l    D2,A0
00000CE8  10BC 0012 1734          move.b    #18,(A0)
                    1735   ; return;
00000CEC  6000 004C 1736          bra       OSEventNameSet_3
                    1737   OSEventNameSet_1:
                    1738   ; }
                    1739   ; switch (pevent->OSEventType) {
00000CF0  206E 0008 1740          move.l    8(A6),A0
00000CF4  1010      1741          move.b    (A0),D0
00000CF6  C0BC 0000 1742          and.l     #255,D0
00000CFA  00FF      
00000CFC  5380      1743          subq.l    #1,D0
00000CFE  651C      1744          blo.s     OSEventNameSet_4
00000D00  0C80 0000 1745          cmp.l     #4,D0
00000D04  0004      
00000D06  6414      1746          bhs.s     OSEventNameSet_4
00000D08  E380      1747          asl.l     #1,D0
00000D0A  303B 0806 1748          move.w    OSEventNameSet_6(PC,D0.L),D0
00000D0E  4EFB 0002 1749          jmp       OSEventNameSet_6(PC,D0.W)
                    1750   OSEventNameSet_6:
00000D12  0008      1751          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000D14  0008      1752          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000D16  0008      1753          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000D18  0008      1754          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1755   OSEventNameSet_7:
                    1756   ; case OS_EVENT_TYPE_SEM:
                    1757   ; case OS_EVENT_TYPE_MUTEX:
                    1758   ; case OS_EVENT_TYPE_MBOX:
                    1759   ; case OS_EVENT_TYPE_Q:
                    1760   ; break;
00000D1A  6008      1761          bra.s     OSEventNameSet_5
                    1762   OSEventNameSet_4:
                    1763   ; default:
                    1764   ; *perr = OS_ERR_EVENT_TYPE;
00000D1C  2042      1765          move.l    D2,A0
00000D1E  10BC 0001 1766          move.b    #1,(A0)
                    1767   ; return;
00000D22  6016      1768          bra.s     OSEventNameSet_3
                    1769   OSEventNameSet_5:
                    1770   ; }
                    1771   ; OS_ENTER_CRITICAL();
00000D24  40E7      1772          dc.w      16615
00000D26  007C      1773          dc.w      124
00000D28  0700      1774          dc.w      1792
                    1775   ; pevent->OSEventName = pname;
00000D2A  206E 0008 1776          move.l    8(A6),A0
00000D2E  216E 000C 1777          move.l    12(A6),18(A0)
00000D32  0012      
                    1778   ; OS_EXIT_CRITICAL();
00000D34  46DF      1779          dc.w      18143
                    1780   ; *perr = OS_ERR_NONE;
00000D36  2042      1781          move.l    D2,A0
00000D38  4210      1782          clr.b     (A0)
                    1783   OSEventNameSet_3:
00000D3A  241F      1784          move.l    (A7)+,D2
00000D3C  4E5E      1785          unlk      A6
00000D3E  4E75      1786          rts
                    1787   ; }
                    1788   ; #endif
                    1789   ; /*$PAGE*/
                    1790   ; /*
                    1791   ; *********************************************************************************************************
                    1792   ; *                                       PEND ON MULTIPLE EVENTS
                    1793   ; *
                    1794   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1795   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1796   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1797   ; *
                    1798   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1799   ; *
                    1800   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1801   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1802   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1803   ; *
                    1804   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1805   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1806   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1807   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1808   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1809   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1810   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1811   ; *
                    1812   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1813   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1814   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1815   ; *                            events or, until the resources becomes available (or the events occur).
                    1816   ; *
                    1817   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1818   ; *                            messages are:
                    1819   ; *
                    1820   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1821   ; *                                                or, the events you are waiting for occurred; check the
                    1822   ; *                                                'pevents_rdy' array for which events are available.
                    1823   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1824   ; *                                                'pevents_rdy' array for which events were aborted.
                    1825   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1826   ; *                                                'timeout'.
                    1827   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1828   ; *                                                NULL pointer.
                    1829   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1830   ; *                                                mailboxes, and/or queues.
                    1831   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1832   ; *                                                would lead to a suspension.
                    1833   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1834   ; *
                    1835   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1836   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1837   ; *
                    1838   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1839   ; *
                    1840   ; *                        semaphores, mailboxes, queues
                    1841   ; *
                    1842   ; *                 b. Return ALL available events and messages, if any
                    1843   ; *
                    1844   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1845   ; *                      Performed in OS_EventTaskWaitMulti()
                    1846   ; *
                    1847   ; *                 d. Wait on any of multiple events
                    1848   ; *
                    1849   ; *                 e. Remove current task priority as pending from each events's wait list
                    1850   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1851   ; *
                    1852   ; *                 f. Return any event posted or aborted, if any
                    1853   ; *                      else
                    1854   ; *                    Return timeout
                    1855   ; *
                    1856   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1857   ; *                 case of any error(s).
                    1858   ; *********************************************************************************************************
                    1859   ; */
                    1860   ; /*$PAGE*/
                    1861   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1862   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1863   ; OS_EVENT  **pevents_rdy,
                    1864   ; void      **pmsgs_rdy,
                    1865   ; INT32U      timeout,
                    1866   ; INT8U      *perr)
                    1867   ; {
                    1868   _OSEventPendMulti:
00000D40  4E56 FFFC 1869          link      A6,#-4
00000D44  48E7 3F38 1870          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000D48  45F9 0800 1871          lea       _OSTCBCur.L,A2
00000D4C  0E3A      
00000D4E  282E 0018 1872          move.l    24(A6),D4
00000D52  2A2E 000C 1873          move.l    12(A6),D5
00000D56  266E 0010 1874          move.l    16(A6),A3
00000D5A  286E 0008 1875          move.l    8(A6),A4
                    1876   ; OS_EVENT  **pevents;
                    1877   ; OS_EVENT   *pevent;
                    1878   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1879   ; OS_Q       *pq;
                    1880   ; #endif
                    1881   ; BOOLEAN     events_rdy;
                    1882   ; INT16U      events_rdy_nbr;
                    1883   ; INT8U       events_stat;
                    1884   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1885   ; OS_CPU_SR   cpu_sr = 0u;
                    1886   ; #endif
                    1887   ; #ifdef OS_SAFETY_CRITICAL
                    1888   ; if (perr == (INT8U *)0) {
                    1889   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1890   ; return (0u);
                    1891   ; }
                    1892   ; #endif
                    1893   ; #if (OS_ARG_CHK_EN > 0u)
                    1894   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1895   ; *perr =  OS_ERR_PEVENT_NULL;
                    1896   ; return (0u);
                    1897   ; }
                    1898   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1899   ; *perr =  OS_ERR_PEVENT_NULL;
                    1900   ; return (0u);
                    1901   ; }
                    1902   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1903   ; *perr =  OS_ERR_PEVENT_NULL;
                    1904   ; return (0u);
                    1905   ; }
                    1906   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1907   ; *perr =  OS_ERR_PEVENT_NULL;
                    1908   ; return (0u);
                    1909   ; }
                    1910   ; #endif
                    1911   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000D5E  2045      1912          move.l    D5,A0
00000D60  4290      1913          clr.l     (A0)
                    1914   ; pevents     =  pevents_pend;
00000D62  2E0C      1915          move.l    A4,D7
                    1916   ; pevent      = *pevents;
00000D64  2047      1917          move.l    D7,A0
00000D66  2410      1918          move.l    (A0),D2
                    1919   ; while  (pevent != (OS_EVENT *)0) {
                    1920   OSEventPendMulti_1:
00000D68  4A82      1921          tst.l     D2
00000D6A  6700 0046 1922          beq       OSEventPendMulti_3
                    1923   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000D6E  2042      1924          move.l    D2,A0
00000D70  1010      1925          move.b    (A0),D0
00000D72  C0BC 0000 1926          and.l     #255,D0
00000D76  00FF      
00000D78  5380      1927          subq.l    #1,D0
00000D7A  6522      1928          blo.s     OSEventPendMulti_10
00000D7C  0C80 0000 1929          cmp.l     #5,D0
00000D80  0005      
00000D82  641A      1930          bhs.s     OSEventPendMulti_10
00000D84  E380      1931          asl.l     #1,D0
00000D86  303B 0806 1932          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000D8A  4EFB 0002 1933          jmp       OSEventPendMulti_6(PC,D0.W)
                    1934   OSEventPendMulti_6:
00000D8E  000C      1935          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
00000D90  000E      1936          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
00000D92  000A      1937          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
00000D94  0010      1938          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000D96  0010      1939          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1940   OSEventPendMulti_7:
                    1941   ; #if (OS_SEM_EN  > 0u)
                    1942   ; case OS_EVENT_TYPE_SEM:
                    1943   ; break;
00000D98  6010      1944          bra.s     OSEventPendMulti_5
                    1945   OSEventPendMulti_8:
                    1946   ; #endif
                    1947   ; #if (OS_MBOX_EN > 0u)
                    1948   ; case OS_EVENT_TYPE_MBOX:
                    1949   ; break;
00000D9A  600E      1950          bra.s     OSEventPendMulti_5
                    1951   OSEventPendMulti_9:
                    1952   ; #endif
                    1953   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1954   ; case OS_EVENT_TYPE_Q:
                    1955   ; break;
00000D9C  600C      1956          bra.s     OSEventPendMulti_5
                    1957   OSEventPendMulti_10:
                    1958   ; #endif
                    1959   ; case OS_EVENT_TYPE_MUTEX:
                    1960   ; case OS_EVENT_TYPE_FLAG:
                    1961   ; default:
                    1962   ; *perr = OS_ERR_EVENT_TYPE;
00000D9E  2044      1963          move.l    D4,A0
00000DA0  10BC 0001 1964          move.b    #1,(A0)
                    1965   ; return (0u);
00000DA4  4240      1966          clr.w     D0
00000DA6  6000 02C2 1967          bra       OSEventPendMulti_13
                    1968   OSEventPendMulti_5:
                    1969   ; }
                    1970   ; pevents++;
00000DAA  5887      1971          addq.l    #4,D7
                    1972   ; pevent = *pevents;
00000DAC  2047      1973          move.l    D7,A0
00000DAE  2410      1974          move.l    (A0),D2
00000DB0  60B6      1975          bra       OSEventPendMulti_1
                    1976   OSEventPendMulti_3:
                    1977   ; }
                    1978   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00000DB2  1039 0800 1979          move.b    _OSIntNesting.L,D0
00000DB6  0D20      
00000DB8  0C00 0000 1980          cmp.b     #0,D0
00000DBC  630C      1981          bls.s     OSEventPendMulti_14
                    1982   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00000DBE  2044      1983          move.l    D4,A0
00000DC0  10BC 0002 1984          move.b    #2,(A0)
                    1985   ; return (0u);
00000DC4  4240      1986          clr.w     D0
00000DC6  6000 02A2 1987          bra       OSEventPendMulti_13
                    1988   OSEventPendMulti_14:
                    1989   ; }
                    1990   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00000DCA  1039 0800 1991          move.b    _OSLockNesting.L,D0
00000DCE  0D22      
00000DD0  0C00 0000 1992          cmp.b     #0,D0
00000DD4  630C      1993          bls.s     OSEventPendMulti_16
                    1994   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
00000DD6  2044      1995          move.l    D4,A0
00000DD8  10BC 000D 1996          move.b    #13,(A0)
                    1997   ; return (0u);
00000DDC  4240      1998          clr.w     D0
00000DDE  6000 028A 1999          bra       OSEventPendMulti_13
                    2000   OSEventPendMulti_16:
                    2001   ; }
                    2002   ; /*$PAGE*/
                    2003   ; events_rdy     =  OS_FALSE;
00000DE2  422E FFFE 2004          clr.b     -2(A6)
                    2005   ; events_rdy_nbr =  0u;
00000DE6  4243      2006          clr.w     D3
                    2007   ; events_stat    =  OS_STAT_RDY;
00000DE8  422E FFFF 2008          clr.b     -1(A6)
                    2009   ; pevents        =  pevents_pend;
00000DEC  2E0C      2010          move.l    A4,D7
                    2011   ; pevent         = *pevents;
00000DEE  2047      2012          move.l    D7,A0
00000DF0  2410      2013          move.l    (A0),D2
                    2014   ; OS_ENTER_CRITICAL();
00000DF2  40E7      2015          dc.w      16615
00000DF4  007C      2016          dc.w      124
00000DF6  0700      2017          dc.w      1792
                    2018   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    2019   OSEventPendMulti_18:
00000DF8  4A82      2020          tst.l     D2
00000DFA  6700 010A 2021          beq       OSEventPendMulti_20
                    2022   ; switch (pevent->OSEventType) {
00000DFE  2042      2023          move.l    D2,A0
00000E00  1010      2024          move.b    (A0),D0
00000E02  C0BC 0000 2025          and.l     #255,D0
00000E06  00FF      
00000E08  5380      2026          subq.l    #1,D0
00000E0A  6500 00DE 2027          blo       OSEventPendMulti_27
00000E0E  0C80 0000 2028          cmp.l     #5,D0
00000E12  0005      
00000E14  6400 00D4 2029          bhs       OSEventPendMulti_27
00000E18  E380      2030          asl.l     #1,D0
00000E1A  303B 0806 2031          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000E1E  4EFB 0002 2032          jmp       OSEventPendMulti_23(PC,D0.W)
                    2033   OSEventPendMulti_23:
00000E22  003A      2034          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
00000E24  0068      2035          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000E26  000A      2036          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000E28  00C8      2037          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000E2A  00C8      2038          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    2039   OSEventPendMulti_24:
                    2040   ; #if (OS_SEM_EN > 0u)
                    2041   ; case OS_EVENT_TYPE_SEM:
                    2042   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000E2C  2042      2043          move.l    D2,A0
00000E2E  3028 0006 2044          move.w    6(A0),D0
00000E32  0C40 0000 2045          cmp.w     #0,D0
00000E36  631A      2046          bls.s     OSEventPendMulti_30
                    2047   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000E38  2002      2048          move.l    D2,D0
00000E3A  5C80      2049          addq.l    #6,D0
00000E3C  2040      2050          move.l    D0,A0
00000E3E  5350      2051          subq.w    #1,(A0)
                    2052   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00000E40  2045      2053          move.l    D5,A0
00000E42  5885      2054          addq.l    #4,D5
00000E44  2082      2055          move.l    D2,(A0)
                    2056   ; events_rdy   =  OS_TRUE;
00000E46  1D7C 0001 2057          move.b    #1,-2(A6)
00000E4A  FFFE      
                    2058   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000E4C  429B      2059          clr.l     (A3)+
                    2060   ; events_rdy_nbr++;
00000E4E  5243      2061          addq.w    #1,D3
00000E50  6006      2062          bra.s     OSEventPendMulti_31
                    2063   OSEventPendMulti_30:
                    2064   ; } else {
                    2065   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
00000E52  002E 0001 2066          or.b      #1,-1(A6)
00000E56  FFFF      
                    2067   OSEventPendMulti_31:
                    2068   ; }
                    2069   ; break;
00000E58  6000 00A2 2070          bra       OSEventPendMulti_22
                    2071   OSEventPendMulti_25:
                    2072   ; #endif
                    2073   ; #if (OS_MBOX_EN > 0u)
                    2074   ; case OS_EVENT_TYPE_MBOX:
                    2075   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000E5C  2042      2076          move.l    D2,A0
00000E5E  2028 0002 2077          move.l    2(A0),D0
00000E62  671C      2078          beq.s     OSEventPendMulti_32
                    2079   ; /* ... return available message,           ... */
                    2080   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
00000E64  2042      2081          move.l    D2,A0
00000E66  26E8 0002 2082          move.l    2(A0),(A3)+
                    2083   ; pevent->OSEventPtr  = (void *)0;
00000E6A  2042      2084          move.l    D2,A0
00000E6C  42A8 0002 2085          clr.l     2(A0)
                    2086   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
00000E70  2045      2087          move.l    D5,A0
00000E72  5885      2088          addq.l    #4,D5
00000E74  2082      2089          move.l    D2,(A0)
                    2090   ; events_rdy         =  OS_TRUE;
00000E76  1D7C 0001 2091          move.b    #1,-2(A6)
00000E7A  FFFE      
                    2092   ; events_rdy_nbr++;
00000E7C  5243      2093          addq.w    #1,D3
00000E7E  6006      2094          bra.s     OSEventPendMulti_33
                    2095   OSEventPendMulti_32:
                    2096   ; } else {
                    2097   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
00000E80  002E 0002 2098          or.b      #2,-1(A6)
00000E84  FFFF      
                    2099   OSEventPendMulti_33:
                    2100   ; }
                    2101   ; break;
00000E86  6000 0074 2102          bra       OSEventPendMulti_22
                    2103   OSEventPendMulti_26:
                    2104   ; #endif
                    2105   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    2106   ; case OS_EVENT_TYPE_Q:
                    2107   ; pq = (OS_Q *)pevent->OSEventPtr;
00000E8A  2042      2108          move.l    D2,A0
00000E8C  2C28 0002 2109          move.l    2(A0),D6
                    2110   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
00000E90  2046      2111          move.l    D6,A0
00000E92  3028 0016 2112          move.w    22(A0),D0
00000E96  0C40 0000 2113          cmp.w     #0,D0
00000E9A  6300 0046 2114          bls       OSEventPendMulti_34
                    2115   ; /* ... return available message,           ... */
                    2116   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000E9E  2006      2117          move.l    D6,D0
00000EA0  0680 0000 2118          add.l     #16,D0
00000EA4  0010      
00000EA6  2040      2119          move.l    D0,A0
00000EA8  2250      2120          move.l    (A0),A1
00000EAA  5890      2121          addq.l    #4,(A0)
00000EAC  26D1      2122          move.l    (A1),(A3)+
                    2123   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000EAE  2046      2124          move.l    D6,A0
00000EB0  2246      2125          move.l    D6,A1
00000EB2  2028 0010 2126          move.l    16(A0),D0
00000EB6  B0A9 0008 2127          cmp.l     8(A1),D0
00000EBA  660A      2128          bne.s     OSEventPendMulti_36
                    2129   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
00000EBC  2046      2130          move.l    D6,A0
00000EBE  2246      2131          move.l    D6,A1
00000EC0  2368 0004 2132          move.l    4(A0),16(A1)
00000EC4  0010      
                    2133   OSEventPendMulti_36:
                    2134   ; }
                    2135   ; pq->OSQEntries--;                  /* Update number of queue entries              */
00000EC6  2006      2136          move.l    D6,D0
00000EC8  0680 0000 2137          add.l     #22,D0
00000ECC  0016      
00000ECE  2040      2138          move.l    D0,A0
00000ED0  5350      2139          subq.w    #1,(A0)
                    2140   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
00000ED2  2045      2141          move.l    D5,A0
00000ED4  5885      2142          addq.l    #4,D5
00000ED6  2082      2143          move.l    D2,(A0)
                    2144   ; events_rdy   = OS_TRUE;
00000ED8  1D7C 0001 2145          move.b    #1,-2(A6)
00000EDC  FFFE      
                    2146   ; events_rdy_nbr++;
00000EDE  5243      2147          addq.w    #1,D3
00000EE0  6006      2148          bra.s     OSEventPendMulti_35
                    2149   OSEventPendMulti_34:
                    2150   ; } else {
                    2151   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
00000EE2  002E 0004 2152          or.b      #4,-1(A6)
00000EE6  FFFF      
                    2153   OSEventPendMulti_35:
                    2154   ; }
                    2155   ; break;
00000EE8  6012      2156          bra.s     OSEventPendMulti_22
                    2157   OSEventPendMulti_27:
                    2158   ; #endif
                    2159   ; case OS_EVENT_TYPE_MUTEX:
                    2160   ; case OS_EVENT_TYPE_FLAG:
                    2161   ; default:
                    2162   ; OS_EXIT_CRITICAL();
00000EEA  46DF      2163          dc.w      18143
                    2164   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
00000EEC  2045      2165          move.l    D5,A0
00000EEE  4290      2166          clr.l     (A0)
                    2167   ; *perr        =  OS_ERR_EVENT_TYPE;
00000EF0  2044      2168          move.l    D4,A0
00000EF2  10BC 0001 2169          move.b    #1,(A0)
                    2170   ; return (events_rdy_nbr);
00000EF6  3003      2171          move.w    D3,D0
00000EF8  6000 0170 2172          bra       OSEventPendMulti_13
                    2173   OSEventPendMulti_22:
                    2174   ; }
                    2175   ; pevents++;
00000EFC  5887      2176          addq.l    #4,D7
                    2177   ; pevent = *pevents;
00000EFE  2047      2178          move.l    D7,A0
00000F00  2410      2179          move.l    (A0),D2
00000F02  6000 FEF4 2180          bra       OSEventPendMulti_18
                    2181   OSEventPendMulti_20:
                    2182   ; }
                    2183   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
00000F06  102E FFFE 2184          move.b    -2(A6),D0
00000F0A  0C00 0001 2185          cmp.b     #1,D0
00000F0E  6610      2186          bne.s     OSEventPendMulti_38
                    2187   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
00000F10  2045      2188          move.l    D5,A0
00000F12  4290      2189          clr.l     (A0)
                    2190   ; OS_EXIT_CRITICAL();
00000F14  46DF      2191          dc.w      18143
                    2192   ; *perr        =  OS_ERR_NONE;
00000F16  2044      2193          move.l    D4,A0
00000F18  4210      2194          clr.b     (A0)
                    2195   ; return (events_rdy_nbr);
00000F1A  3003      2196          move.w    D3,D0
00000F1C  6000 014C 2197          bra       OSEventPendMulti_13
                    2198   OSEventPendMulti_38:
                    2199   ; }
                    2200   ; /*$PAGE*/
                    2201   ; /* Otherwise, must wait until any event occurs */
                    2202   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00000F20  2052      2203          move.l    (A2),A0
00000F22  102E FFFF 2204          move.b    -1(A6),D0
00000F26  803C 0080 2205          or.b      #128,D0
00000F2A  8128 0032 2206          or.b      D0,50(A0)
                    2207   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    2208   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00000F2E  2052      2209          move.l    (A2),A0
00000F30  4228 0033 2210          clr.b     51(A0)
                    2211   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00000F34  2052      2212          move.l    (A2),A0
00000F36  216E 0014 2213          move.l    20(A6),46(A0)
00000F3A  002E      
                    2214   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00000F3C  2F0C      2215          move.l    A4,-(A7)
00000F3E  4EB9 0000 2216          jsr       _OS_EventTaskWaitMulti
00000F42  1496      
00000F44  584F      2217          addq.w    #4,A7
                    2218   ; OS_EXIT_CRITICAL();
00000F46  46DF      2219          dc.w      18143
                    2220   ; OS_Sched();                                         /* Find next highest priority task ready       */
00000F48  4EB9 0000 2221          jsr       _OS_Sched
00000F4C  190E      
                    2222   ; OS_ENTER_CRITICAL();
00000F4E  40E7      2223          dc.w      16615
00000F50  007C      2224          dc.w      124
00000F52  0700      2225          dc.w      1792
                    2226   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00000F54  2052      2227          move.l    (A2),A0
00000F56  1028 0033 2228          move.b    51(A0),D0
00000F5A  C0BC 0000 2229          and.l     #255,D0
00000F5E  00FF      
00000F60  0C80 0000 2230          cmp.l     #1,D0
00000F64  0001      
00000F66  6700 0046 2231          beq       OSEventPendMulti_44
00000F6A  6208      2232          bhi.s     OSEventPendMulti_46
00000F6C  4A80      2233          tst.l     D0
00000F6E  6710      2234          beq.s     OSEventPendMulti_42
00000F70  6000 003C 2235          bra       OSEventPendMulti_44
                    2236   OSEventPendMulti_46:
00000F74  0C80 0000 2237          cmp.l     #2,D0
00000F78  0002      
00000F7A  6704      2238          beq.s     OSEventPendMulti_42
00000F7C  6000 0030 2239          bra       OSEventPendMulti_44
                    2240   OSEventPendMulti_42:
                    2241   ; case OS_STAT_PEND_OK:
                    2242   ; case OS_STAT_PEND_ABORT:
                    2243   ; pevent = OSTCBCur->OSTCBEventPtr;
00000F80  2052      2244          move.l    (A2),A0
00000F82  2428 001C 2245          move.l    28(A0),D2
                    2246   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
00000F86  4A82      2247          tst.l     D2
00000F88  670E      2248          beq.s     OSEventPendMulti_47
                    2249   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
00000F8A  2045      2250          move.l    D5,A0
00000F8C  5885      2251          addq.l    #4,D5
00000F8E  2082      2252          move.l    D2,(A0)
                    2253   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
00000F90  2045      2254          move.l    D5,A0
00000F92  4290      2255          clr.l     (A0)
                    2256   ; events_rdy_nbr =  1;
00000F94  7601      2257          moveq     #1,D3
00000F96  6014      2258          bra.s     OSEventPendMulti_48
                    2259   OSEventPendMulti_47:
                    2260   ; } else {                                   /* Else NO event available, handle as timeout  */
                    2261   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00000F98  2052      2262          move.l    (A2),A0
00000F9A  117C 0001 2263          move.b    #1,51(A0)
00000F9E  0033      
                    2264   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000FA0  2F0C      2265          move.l    A4,-(A7)
00000FA2  2F12      2266          move.l    (A2),-(A7)
00000FA4  4EB9 0000 2267          jsr       _OS_EventTaskRemoveMulti
00000FA8  1586      
00000FAA  504F      2268          addq.w    #8,A7
                    2269   OSEventPendMulti_48:
                    2270   ; }
                    2271   ; break;
00000FAC  600C      2272          bra.s     OSEventPendMulti_41
                    2273   OSEventPendMulti_44:
                    2274   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    2275   ; default:                                        /* ... remove task from events' wait lists     */
                    2276   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000FAE  2F0C      2277          move.l    A4,-(A7)
00000FB0  2F12      2278          move.l    (A2),-(A7)
00000FB2  4EB9 0000 2279          jsr       _OS_EventTaskRemoveMulti
00000FB6  1586      
00000FB8  504F      2280          addq.w    #8,A7
                    2281   ; break;
                    2282   OSEventPendMulti_41:
                    2283   ; }
                    2284   ; switch (OSTCBCur->OSTCBStatPend) {
00000FBA  2052      2285          move.l    (A2),A0
00000FBC  1028 0033 2286          move.b    51(A0),D0
00000FC0  C0BC 0000 2287          and.l     #255,D0
00000FC4  00FF      
00000FC6  0C80 0000 2288          cmp.l     #1,D0
00000FCA  0001      
00000FCC  6700 0072 2289          beq       OSEventPendMulti_53
00000FD0  6208      2290          bhi.s     OSEventPendMulti_55
00000FD2  4A80      2291          tst.l     D0
00000FD4  6712      2292          beq.s     OSEventPendMulti_51
00000FD6  6000 0068 2293          bra       OSEventPendMulti_53
                    2294   OSEventPendMulti_55:
00000FDA  0C80 0000 2295          cmp.l     #2,D0
00000FDE  0002      
00000FE0  6700 0054 2296          beq       OSEventPendMulti_52
00000FE4  6000 005A 2297          bra       OSEventPendMulti_53
                    2298   OSEventPendMulti_51:
                    2299   ; case OS_STAT_PEND_OK:
                    2300   ; switch (pevent->OSEventType) {             /* Return event's message                      */
00000FE8  2042      2301          move.l    D2,A0
00000FEA  1010      2302          move.b    (A0),D0
00000FEC  C0BC 0000 2303          and.l     #255,D0
00000FF0  00FF      
00000FF2  5380      2304          subq.l    #1,D0
00000FF4  6528      2305          blo.s     OSEventPendMulti_62
00000FF6  0C80 0000 2306          cmp.l     #5,D0
00000FFA  0005      
00000FFC  6420      2307          bhs.s     OSEventPendMulti_62
00000FFE  E380      2308          asl.l     #1,D0
00001000  303B 0806 2309          move.w    OSEventPendMulti_58(PC,D0.L),D0
00001004  4EFB 0002 2310          jmp       OSEventPendMulti_58(PC,D0.W)
                    2311   OSEventPendMulti_58:
00001008  000E      2312          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
0000100A  000E      2313          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
0000100C  000A      2314          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
0000100E  0016      2315          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00001010  0016      2316          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    2317   OSEventPendMulti_59:
                    2318   ; #if (OS_SEM_EN > 0u)
                    2319   ; case OS_EVENT_TYPE_SEM:
                    2320   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00001012  429B      2321          clr.l     (A3)+
                    2322   ; break;
00001014  601A      2323          bra.s     OSEventPendMulti_57
                    2324   OSEventPendMulti_60:
                    2325   ; #endif
                    2326   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2327   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2328   ; case OS_EVENT_TYPE_MBOX:
                    2329   ; case OS_EVENT_TYPE_Q:
                    2330   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
00001016  2052      2331          move.l    (A2),A0
00001018  26E8 0024 2332          move.l    36(A0),(A3)+
                    2333   ; break;
0000101C  6012      2334          bra.s     OSEventPendMulti_57
                    2335   OSEventPendMulti_62:
                    2336   ; #endif
                    2337   ; case OS_EVENT_TYPE_MUTEX:
                    2338   ; case OS_EVENT_TYPE_FLAG:
                    2339   ; default:
                    2340   ; OS_EXIT_CRITICAL();
0000101E  46DF      2341          dc.w      18143
                    2342   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00001020  2045      2343          move.l    D5,A0
00001022  4290      2344          clr.l     (A0)
                    2345   ; *perr        =  OS_ERR_EVENT_TYPE;
00001024  2044      2346          move.l    D4,A0
00001026  10BC 0001 2347          move.b    #1,(A0)
                    2348   ; return (events_rdy_nbr);
0000102A  3003      2349          move.w    D3,D0
0000102C  6000 003C 2350          bra       OSEventPendMulti_13
                    2351   OSEventPendMulti_57:
                    2352   ; }
                    2353   ; *perr = OS_ERR_NONE;
00001030  2044      2354          move.l    D4,A0
00001032  4210      2355          clr.b     (A0)
                    2356   ; break;
00001034  6012      2357          bra.s     OSEventPendMulti_50
                    2358   OSEventPendMulti_52:
                    2359   ; case OS_STAT_PEND_ABORT:
                    2360   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
00001036  429B      2361          clr.l     (A3)+
                    2362   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
00001038  2044      2363          move.l    D4,A0
0000103A  10BC 000E 2364          move.b    #14,(A0)
                    2365   ; break;
0000103E  6008      2366          bra.s     OSEventPendMulti_50
                    2367   OSEventPendMulti_53:
                    2368   ; case OS_STAT_PEND_TO:
                    2369   ; default:
                    2370   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00001040  429B      2371          clr.l     (A3)+
                    2372   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00001042  2044      2373          move.l    D4,A0
00001044  10BC 000A 2374          move.b    #10,(A0)
                    2375   ; break;
                    2376   OSEventPendMulti_50:
                    2377   ; }
                    2378   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00001048  2052      2379          move.l    (A2),A0
0000104A  4228 0032 2380          clr.b     50(A0)
                    2381   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
0000104E  2052      2382          move.l    (A2),A0
00001050  4228 0033 2383          clr.b     51(A0)
                    2384   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00001054  2052      2385          move.l    (A2),A0
00001056  42A8 001C 2386          clr.l     28(A0)
                    2387   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000105A  2052      2388          move.l    (A2),A0
0000105C  42A8 0020 2389          clr.l     32(A0)
                    2390   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    2391   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    2392   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00001060  2052      2393          move.l    (A2),A0
00001062  42A8 0024 2394          clr.l     36(A0)
                    2395   ; #endif
                    2396   ; OS_EXIT_CRITICAL();
00001066  46DF      2397          dc.w      18143
                    2398   ; return (events_rdy_nbr);
00001068  3003      2399          move.w    D3,D0
                    2400   OSEventPendMulti_13:
0000106A  4CDF 1CFC 2401          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
0000106E  4E5E      2402          unlk      A6
00001070  4E75      2403          rts
                    2404   ; }
                    2405   ; #endif
                    2406   ; /*$PAGE*/
                    2407   ; /*
                    2408   ; *********************************************************************************************************
                    2409   ; *                                           INITIALIZATION
                    2410   ; *
                    2411   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2412   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2413   ; *
                    2414   ; * Arguments  : none
                    2415   ; *
                    2416   ; * Returns    : none
                    2417   ; *********************************************************************************************************
                    2418   ; */
                    2419   ; void  OSInit (void)
                    2420   ; {
                    2421   _OSInit:
                    2422   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00001072  4EB8 0BE8 2423          jsr       _OSInitHookBegin
                    2424   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00001076  4EB9 0000 2425          jsr       @ucos_ii_OS_InitMisc
0000107A  16CE      
                    2426   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
0000107C  4EB9 0000 2427          jsr       @ucos_ii_OS_InitRdyList
00001080  1712      
                    2428   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00001082  4EB9 0000 2429          jsr       @ucos_ii_OS_InitTCBList
00001086  180A      
                    2430   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00001088  4EB9 0000 2431          jsr       @ucos_ii_OS_InitEventList
0000108C  1626      
                    2432   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2433   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
0000108E  4EB9 0000 2434          jsr       _OS_FlagInit
00001092  261C      
                    2435   ; #endif
                    2436   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2437   ; OS_MemInit();                                                /* Initialize the memory manager            */
00001094  4EB9 0000 2438          jsr       _OS_MemInit
00001098  2EDA      
                    2439   ; #endif
                    2440   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2441   ; OS_QInit();                                                  /* Initialize the message queue structures  */
0000109A  4EB9 0000 2442          jsr       _OS_QInit
0000109E  4040      
                    2443   ; #endif
                    2444   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000010A0  4EB9 0000 2445          jsr       @ucos_ii_OS_InitTaskIdle
000010A4  1752      
                    2446   ; #if OS_TASK_STAT_EN > 0u
                    2447   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
000010A6  4EB9 0000 2448          jsr       @ucos_ii_OS_InitTaskStat
000010AA  17AE      
                    2449   ; #endif
                    2450   ; #if OS_TMR_EN > 0u
                    2451   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
000010AC  4EB9 0000 2452          jsr       _OSTmr_Init
000010B0  5992      
                    2453   ; #endif
                    2454   ; OSInitHookEnd();                                             /* Call port specific init. code            */
000010B2  4EB8 0BEA 2455          jsr       _OSInitHookEnd
000010B6  4E75      2456          rts
                    2457   ; #if OS_DEBUG_EN > 0u
                    2458   ; OSDebugInit();
                    2459   ; #endif
                    2460   ; }
                    2461   ; /*$PAGE*/
                    2462   ; /*
                    2463   ; *********************************************************************************************************
                    2464   ; *                                              ENTER ISR
                    2465   ; *
                    2466   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2467   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2468   ; *              only perform rescheduling at the last nested ISR.
                    2469   ; *
                    2470   ; * Arguments  : none
                    2471   ; *
                    2472   ; * Returns    : none
                    2473   ; *
                    2474   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2475   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2476   ; *                 OSIntNesting has been declared 'global'.
                    2477   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2478   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2479   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2480   ; *                 end of the ISR.
                    2481   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2482   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2483   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2484   ; *********************************************************************************************************
                    2485   ; */
                    2486   ; void  OSIntEnter (void)
                    2487   ; {
                    2488   _OSIntEnter:
                    2489   ; if (OSRunning == OS_TRUE) {
000010B8  1039 0800 2490          move.b    _OSRunning.L,D0
000010BC  0D32      
000010BE  0C00 0001 2491          cmp.b     #1,D0
000010C2  6612      2492          bne.s     OSIntEnter_3
                    2493   ; if (OSIntNesting < 255u) {
000010C4  1039 0800 2494          move.b    _OSIntNesting.L,D0
000010C8  0D20      
000010CA  0C00 00FF 2495          cmp.b     #255,D0
000010CE  6406      2496          bhs.s     OSIntEnter_3
                    2497   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
000010D0  5239 0800 2498          addq.b    #1,_OSIntNesting.L
000010D4  0D20      
                    2499   OSIntEnter_3:
000010D6  4E75      2500          rts
                    2501   ; }
                    2502   ; }
                    2503   ; }
                    2504   ; /*$PAGE*/
                    2505   ; /*
                    2506   ; *********************************************************************************************************
                    2507   ; *                                              EXIT ISR
                    2508   ; *
                    2509   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2510   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2511   ; *              a new, high-priority task, is ready to run.
                    2512   ; *
                    2513   ; * Arguments  : none
                    2514   ; *
                    2515   ; * Returns    : none
                    2516   ; *
                    2517   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2518   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2519   ; *                 end of the ISR.
                    2520   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2521   ; *********************************************************************************************************
                    2522   ; */
                    2523   ; void  OSIntExit (void)
                    2524   ; {
                    2525   _OSIntExit:
                    2526   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2527   ; OS_CPU_SR  cpu_sr = 0u;
                    2528   ; #endif
                    2529   ; if (OSRunning == OS_TRUE) {
000010D8  1039 0800 2530          move.b    _OSRunning.L,D0
000010DC  0D32      
000010DE  0C00 0001 2531          cmp.b     #1,D0
000010E2  6600 0078 2532          bne       OSIntExit_1
                    2533   ; OS_ENTER_CRITICAL();
000010E6  40E7      2534          dc.w      16615
000010E8  007C      2535          dc.w      124
000010EA  0700      2536          dc.w      1792
                    2537   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000010EC  1039 0800 2538          move.b    _OSIntNesting.L,D0
000010F0  0D20      
000010F2  0C00 0000 2539          cmp.b     #0,D0
000010F6  6306      2540          bls.s     OSIntExit_3
                    2541   ; OSIntNesting--;
000010F8  5339 0800 2542          subq.b    #1,_OSIntNesting.L
000010FC  0D20      
                    2543   OSIntExit_3:
                    2544   ; }
                    2545   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000010FE  1039 0800 2546          move.b    _OSIntNesting.L,D0
00001102  0D20      
00001104  6600 0054 2547          bne       OSIntExit_9
                    2548   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00001108  1039 0800 2549          move.b    _OSLockNesting.L,D0
0000110C  0D22      
0000110E  664A      2550          bne.s     OSIntExit_9
                    2551   ; OS_SchedNew();
00001110  4EB9 0000 2552          jsr       @ucos_ii_OS_SchedNew
00001114  1972      
                    2553   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001116  1039 0800 2554          move.b    _OSPrioHighRdy.L,D0
0000111A  0D26      
0000111C  C0BC 0000 2555          and.l     #255,D0
00001120  00FF      
00001122  E588      2556          lsl.l     #2,D0
00001124  41F9 0800 2557          lea       _OSTCBPrioTbl.L,A0
00001128  0E4A      
0000112A  23F0 0800 2558          move.l    0(A0,D0.L),_OSTCBHighRdy.L
0000112E  0800 0E42 
                    2559   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00001132  1039 0800 2560          move.b    _OSPrioHighRdy.L,D0
00001136  0D26      
00001138  B039 0800 2561          cmp.b     _OSPrioCur.L,D0
0000113C  0D24      
0000113E  671A      2562          beq.s     OSIntExit_9
                    2563   ; #if OS_TASK_PROFILE_EN > 0u
                    2564   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00001140  2039 0800 2565          move.l    _OSTCBHighRdy.L,D0
00001144  0E42      
00001146  0680 0000 2566          add.l     #58,D0
0000114A  003A      
0000114C  2040      2567          move.l    D0,A0
0000114E  5290      2568          addq.l    #1,(A0)
                    2569   ; #endif
                    2570   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00001150  52B9 0800 2571          addq.l    #1,_OSCtxSwCtr.L
00001154  0AF0      
                    2572   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00001156  4EB8 06E2 2573          jsr       _OSIntCtxSw
                    2574   OSIntExit_9:
                    2575   ; }
                    2576   ; }
                    2577   ; }
                    2578   ; OS_EXIT_CRITICAL();
0000115A  46DF      2579          dc.w      18143
                    2580   OSIntExit_1:
0000115C  4E75      2581          rts
                    2582   ; }
                    2583   ; }
                    2584   ; /*$PAGE*/
                    2585   ; /*
                    2586   ; *********************************************************************************************************
                    2587   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2588   ; *
                    2589   ; * Description: This function is called by the application code to indicate that all initialization has
                    2590   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2591   ; *
                    2592   ; * Arguments  : none
                    2593   ; *
                    2594   ; * Returns    : none
                    2595   ; *
                    2596   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2597   ; *                 create kernel objects.
                    2598   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2599   ; *********************************************************************************************************
                    2600   ; */
                    2601   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2602   ; void  OSSafetyCriticalStart (void)
                    2603   ; {
                    2604   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2605   ; }
                    2606   ; #endif
                    2607   ; /*$PAGE*/
                    2608   ; /*
                    2609   ; *********************************************************************************************************
                    2610   ; *                                         PREVENT SCHEDULING
                    2611   ; *
                    2612   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2613   ; *              to prevent context switches until you are ready to permit context switching.
                    2614   ; *
                    2615   ; * Arguments  : none
                    2616   ; *
                    2617   ; * Returns    : none
                    2618   ; *
                    2619   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2620   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2621   ; *********************************************************************************************************
                    2622   ; */
                    2623   ; #if OS_SCHED_LOCK_EN > 0u
                    2624   ; void  OSSchedLock (void)
                    2625   ; {
                    2626   _OSSchedLock:
                    2627   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2628   ; OS_CPU_SR  cpu_sr = 0u;
                    2629   ; #endif
                    2630   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0000115E  1039 0800 2631          move.b    _OSRunning.L,D0
00001162  0D32      
00001164  0C00 0001 2632          cmp.b     #1,D0
00001168  6622      2633          bne.s     OSSchedLock_1
                    2634   ; OS_ENTER_CRITICAL();
0000116A  40E7      2635          dc.w      16615
0000116C  007C      2636          dc.w      124
0000116E  0700      2637          dc.w      1792
                    2638   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00001170  1039 0800 2639          move.b    _OSIntNesting.L,D0
00001174  0D20      
00001176  6612      2640          bne.s     OSSchedLock_5
                    2641   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
00001178  1039 0800 2642          move.b    _OSLockNesting.L,D0
0000117C  0D22      
0000117E  0C00 00FF 2643          cmp.b     #255,D0
00001182  6406      2644          bhs.s     OSSchedLock_5
                    2645   ; OSLockNesting++;                 /* Increment lock nesting level                       */
00001184  5239 0800 2646          addq.b    #1,_OSLockNesting.L
00001188  0D22      
                    2647   OSSchedLock_5:
                    2648   ; }
                    2649   ; }
                    2650   ; OS_EXIT_CRITICAL();
0000118A  46DF      2651          dc.w      18143
                    2652   OSSchedLock_1:
0000118C  4E75      2653          rts
                    2654   ; }
                    2655   ; }
                    2656   ; #endif
                    2657   ; /*$PAGE*/
                    2658   ; /*
                    2659   ; *********************************************************************************************************
                    2660   ; *                                          ENABLE SCHEDULING
                    2661   ; *
                    2662   ; * Description: This function is used to re-allow rescheduling.
                    2663   ; *
                    2664   ; * Arguments  : none
                    2665   ; *
                    2666   ; * Returns    : none
                    2667   ; *
                    2668   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2669   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2670   ; *********************************************************************************************************
                    2671   ; */
                    2672   ; #if OS_SCHED_LOCK_EN > 0u
                    2673   ; void  OSSchedUnlock (void)
                    2674   ; {
                    2675   _OSSchedUnlock:
                    2676   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2677   ; OS_CPU_SR  cpu_sr = 0u;
                    2678   ; #endif
                    2679   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
0000118E  1039 0800 2680          move.b    _OSRunning.L,D0
00001192  0D32      
00001194  0C00 0001 2681          cmp.b     #1,D0
00001198  6600 003E 2682          bne       OSSchedUnlock_4
                    2683   ; OS_ENTER_CRITICAL();
0000119C  40E7      2684          dc.w      16615
0000119E  007C      2685          dc.w      124
000011A0  0700      2686          dc.w      1792
                    2687   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000011A2  1039 0800 2688          move.b    _OSIntNesting.L,D0
000011A6  0D20      
000011A8  662C      2689          bne.s     OSSchedUnlock_3
                    2690   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000011AA  1039 0800 2691          move.b    _OSLockNesting.L,D0
000011AE  0D22      
000011B0  0C00 0000 2692          cmp.b     #0,D0
000011B4  631C      2693          bls.s     OSSchedUnlock_5
                    2694   ; OSLockNesting--;                           /* Decrement lock nesting level             */
000011B6  5339 0800 2695          subq.b    #1,_OSLockNesting.L
000011BA  0D22      
                    2696   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000011BC  1039 0800 2697          move.b    _OSLockNesting.L,D0
000011C0  0D22      
000011C2  660A      2698          bne.s     OSSchedUnlock_7
                    2699   ; OS_EXIT_CRITICAL();
000011C4  46DF      2700          dc.w      18143
                    2701   ; OS_Sched();                            /* See if a HPT is ready                    */
000011C6  4EB9 0000 2702          jsr       _OS_Sched
000011CA  190E      
000011CC  6002      2703          bra.s     OSSchedUnlock_8
                    2704   OSSchedUnlock_7:
                    2705   ; } else {
                    2706   ; OS_EXIT_CRITICAL();
000011CE  46DF      2707          dc.w      18143
                    2708   OSSchedUnlock_8:
000011D0  6002      2709          bra.s     OSSchedUnlock_6
                    2710   OSSchedUnlock_5:
                    2711   ; }
                    2712   ; } else {
                    2713   ; OS_EXIT_CRITICAL();
000011D2  46DF      2714          dc.w      18143
                    2715   OSSchedUnlock_6:
000011D4  6002      2716          bra.s     OSSchedUnlock_4
                    2717   OSSchedUnlock_3:
                    2718   ; }
                    2719   ; } else {
                    2720   ; OS_EXIT_CRITICAL();
000011D6  46DF      2721          dc.w      18143
                    2722   OSSchedUnlock_4:
000011D8  4E75      2723          rts
                    2724   ; }
                    2725   ; }
                    2726   ; }
                    2727   ; #endif
                    2728   ; /*$PAGE*/
                    2729   ; /*
                    2730   ; *********************************************************************************************************
                    2731   ; *                                         START MULTITASKING
                    2732   ; *
                    2733   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2734   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2735   ; *              and you MUST have created at least one task.
                    2736   ; *
                    2737   ; * Arguments  : none
                    2738   ; *
                    2739   ; * Returns    : none
                    2740   ; *
                    2741   ; * Note       : OSStartHighRdy() MUST:
                    2742   ; *                 a) Call OSTaskSwHook() then,
                    2743   ; *                 b) Set OSRunning to OS_TRUE.
                    2744   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2745   ; *                 d_ Execute the task.
                    2746   ; *********************************************************************************************************
                    2747   ; */
                    2748   ; void  OSStart (void)
                    2749   ; {
                    2750   _OSStart:
                    2751   ; if (OSRunning == OS_FALSE) {
000011DA  1039 0800 2752          move.b    _OSRunning.L,D0
000011DE  0D32      
000011E0  663A      2753          bne.s     OSStart_1
                    2754   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
000011E2  4EB9 0000 2755          jsr       @ucos_ii_OS_SchedNew
000011E6  1972      
                    2756   ; OSPrioCur     = OSPrioHighRdy;
000011E8  13F9 0800 2757          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
000011EC  0D26 0800 
000011F0  0D24      
                    2758   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000011F2  1039 0800 2759          move.b    _OSPrioHighRdy.L,D0
000011F6  0D26      
000011F8  C0BC 0000 2760          and.l     #255,D0
000011FC  00FF      
000011FE  E588      2761          lsl.l     #2,D0
00001200  41F9 0800 2762          lea       _OSTCBPrioTbl.L,A0
00001204  0E4A      
00001206  23F0 0800 2763          move.l    0(A0,D0.L),_OSTCBHighRdy.L
0000120A  0800 0E42 
                    2764   ; OSTCBCur      = OSTCBHighRdy;
0000120E  23F9 0800 2765          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
00001212  0E42 0800 
00001216  0E3A      
                    2766   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
00001218  4EB8 0698 2767          jsr       _OSStartHighRdy
                    2768   OSStart_1:
0000121C  4E75      2769          rts
                    2770   ; }
                    2771   ; }
                    2772   ; /*$PAGE*/
                    2773   ; /*
                    2774   ; *********************************************************************************************************
                    2775   ; *                                      STATISTICS INITIALIZATION
                    2776   ; *
                    2777   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2778   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2779   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2780   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2781   ; *              determined by:
                    2782   ; *
                    2783   ; *                                             OSIdleCtr
                    2784   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2785   ; *                                            OSIdleCtrMax
                    2786   ; *
                    2787   ; * Arguments  : none
                    2788   ; *
                    2789   ; * Returns    : none
                    2790   ; *********************************************************************************************************
                    2791   ; */
                    2792   ; #if OS_TASK_STAT_EN > 0u
                    2793   ; void  OSStatInit (void)
                    2794   ; {
                    2795   _OSStatInit:
                    2796   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2797   ; OS_CPU_SR  cpu_sr = 0u;
                    2798   ; #endif
                    2799   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
0000121E  4878 0002 2800          pea       2
00001222  4EB9 0000 2801          jsr       _OSTimeDly
00001226  510A      
00001228  584F      2802          addq.w    #4,A7
                    2803   ; OS_ENTER_CRITICAL();
0000122A  40E7      2804          dc.w      16615
0000122C  007C      2805          dc.w      124
0000122E  0700      2806          dc.w      1792
                    2807   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00001230  42B9 0800 2808          clr.l     _OSIdleCtr.L
00001234  0D36      
                    2809   ; OS_EXIT_CRITICAL();
00001236  46DF      2810          dc.w      18143
                    2811   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001238  4878 000A 2812          pea       10
0000123C  4EB9 0000 2813          jsr       _OSTimeDly
00001240  510A      
00001242  584F      2814          addq.w    #4,A7
                    2815   ; OS_ENTER_CRITICAL();
00001244  40E7      2816          dc.w      16615
00001246  007C      2817          dc.w      124
00001248  0700      2818          dc.w      1792
                    2819   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0000124A  23F9 0800 2820          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
0000124E  0D36 0800 
00001252  0C16      
                    2821   ; OSStatRdy    = OS_TRUE;
00001254  13FC 0001 2822          move.b    #1,_OSStatRdy.L
00001258  0800 0C1E 
                    2823   ; OS_EXIT_CRITICAL();
0000125C  46DF      2824          dc.w      18143
0000125E  4E75      2825          rts
                    2826   ; }
                    2827   ; #endif
                    2828   ; /*$PAGE*/
                    2829   ; /*
                    2830   ; *********************************************************************************************************
                    2831   ; *                                         PROCESS SYSTEM TICK
                    2832   ; *
                    2833   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2834   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2835   ; *              called by a high priority task.
                    2836   ; *
                    2837   ; * Arguments  : none
                    2838   ; *
                    2839   ; * Returns    : none
                    2840   ; *********************************************************************************************************
                    2841   ; */
                    2842   ; void  OSTimeTick (void)
                    2843   ; {
                    2844   _OSTimeTick:
00001260  2F02      2845          move.l    D2,-(A7)
                    2846   ; OS_TCB    *ptcb;
                    2847   ; #if OS_TICK_STEP_EN > 0u
                    2848   ; BOOLEAN    step;
                    2849   ; #endif
                    2850   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2851   ; OS_CPU_SR  cpu_sr = 0u;
                    2852   ; #endif
                    2853   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2854   ; OSTimeTickHook();                                      /* Call user definable hook                     */
00001262  4EB8 0C10 2855          jsr       _OSTimeTickHook
                    2856   ; #endif
                    2857   ; #if OS_TIME_GET_SET_EN > 0u
                    2858   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
00001266  40E7      2859          dc.w      16615
00001268  007C      2860          dc.w      124
0000126A  0700      2861          dc.w      1792
                    2862   ; OSTime++;
0000126C  52B9 0800 2863          addq.l    #1,_OSTime.L
00001270  1790      
                    2864   ; OS_EXIT_CRITICAL();
00001272  46DF      2865          dc.w      18143
                    2866   ; #endif
                    2867   ; if (OSRunning == OS_TRUE) {
00001274  1039 0800 2868          move.b    _OSRunning.L,D0
00001278  0D32      
0000127A  0C00 0001 2869          cmp.b     #1,D0
0000127E  6600 00A2 2870          bne       OSTimeTick_5
                    2871   ; #if OS_TICK_STEP_EN > 0u
                    2872   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2873   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2874   ; step = OS_TRUE;
                    2875   ; break;
                    2876   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2877   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2878   ; break;
                    2879   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2880   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2881   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2882   ; break;
                    2883   ; default:                                       /* Invalid case, correct situation              */
                    2884   ; step            = OS_TRUE;
                    2885   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2886   ; break;
                    2887   ; }
                    2888   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2889   ; return;
                    2890   ; }
                    2891   ; #endif
                    2892   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
00001282  2439 0800 2893          move.l    _OSTCBList.L,D2
00001286  0E46      
                    2894   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2895   OSTimeTick_3:
00001288  2042      2896          move.l    D2,A0
0000128A  1028 0034 2897          move.b    52(A0),D0
0000128E  0C00 003F 2898          cmp.b     #63,D0
00001292  6700 008E 2899          beq       OSTimeTick_5
                    2900   ; OS_ENTER_CRITICAL();
00001296  40E7      2901          dc.w      16615
00001298  007C      2902          dc.w      124
0000129A  0700      2903          dc.w      1792
                    2904   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
0000129C  2042      2905          move.l    D2,A0
0000129E  2028 002E 2906          move.l    46(A0),D0
000012A2  6700 0072 2907          beq       OSTimeTick_12
                    2908   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
000012A6  2002      2909          move.l    D2,D0
000012A8  0680 0000 2910          add.l     #46,D0
000012AC  002E      
000012AE  2040      2911          move.l    D0,A0
000012B0  5390      2912          subq.l    #1,(A0)
                    2913   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
000012B2  2042      2914          move.l    D2,A0
000012B4  2028 002E 2915          move.l    46(A0),D0
000012B8  6600 005C 2916          bne       OSTimeTick_12
                    2917   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000012BC  2042      2918          move.l    D2,A0
000012BE  1028 0032 2919          move.b    50(A0),D0
000012C2  C03C 0037 2920          and.b     #55,D0
000012C6  6714      2921          beq.s     OSTimeTick_10
                    2922   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000012C8  2042      2923          move.l    D2,A0
000012CA  7037      2924          moveq     #55,D0
000012CC  4600      2925          not.b     D0
000012CE  C128 0032 2926          and.b     D0,50(A0)
                    2927   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
000012D2  2042      2928          move.l    D2,A0
000012D4  117C 0001 2929          move.b    #1,51(A0)
000012D8  0033      
000012DA  6006      2930          bra.s     OSTimeTick_11
                    2931   OSTimeTick_10:
                    2932   ; } else {
                    2933   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000012DC  2042      2934          move.l    D2,A0
000012DE  4228 0033 2935          clr.b     51(A0)
                    2936   OSTimeTick_11:
                    2937   ; }
                    2938   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
000012E2  2042      2939          move.l    D2,A0
000012E4  1028 0032 2940          move.b    50(A0),D0
000012E8  C03C 0008 2941          and.b     #8,D0
000012EC  6628      2942          bne.s     OSTimeTick_12
                    2943   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
000012EE  2042      2944          move.l    D2,A0
000012F0  1028 0038 2945          move.b    56(A0),D0
000012F4  8139 0800 2946          or.b      D0,_OSRdyGrp.L
000012F8  0D28      
                    2947   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000012FA  2042      2948          move.l    D2,A0
000012FC  1028 0036 2949          move.b    54(A0),D0
00001300  C0BC 0000 2950          and.l     #255,D0
00001304  00FF      
00001306  41F9 0800 2951          lea       _OSRdyTbl.L,A0
0000130A  0D2A      
0000130C  2242      2952          move.l    D2,A1
0000130E  1229 0037 2953          move.b    55(A1),D1
00001312  8330 0800 2954          or.b      D1,0(A0,D0.L)
                    2955   OSTimeTick_12:
                    2956   ; }
                    2957   ; }
                    2958   ; }
                    2959   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
00001316  2042      2960          move.l    D2,A0
00001318  2428 0014 2961          move.l    20(A0),D2
                    2962   ; OS_EXIT_CRITICAL();
0000131C  46DF      2963          dc.w      18143
0000131E  6000 FF68 2964          bra       OSTimeTick_3
                    2965   OSTimeTick_5:
00001322  241F      2966          move.l    (A7)+,D2
00001324  4E75      2967          rts
                    2968   ; }
                    2969   ; }
                    2970   ; }
                    2971   ; /*$PAGE*/
                    2972   ; /*
                    2973   ; *********************************************************************************************************
                    2974   ; *                                             GET VERSION
                    2975   ; *
                    2976   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2977   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2978   ; *              2.01.00 would be returned as 20100.
                    2979   ; *
                    2980   ; * Arguments  : none
                    2981   ; *
                    2982   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2983   ; *********************************************************************************************************
                    2984   ; */
                    2985   ; INT16U  OSVersion (void)
                    2986   ; {
                    2987   _OSVersion:
                    2988   ; return (OS_VERSION);
00001326  303C 7217 2989          move.w    #29207,D0
0000132A  4E75      2990          rts
                    2991   ; }
                    2992   ; /*$PAGE*/
                    2993   ; /*
                    2994   ; *********************************************************************************************************
                    2995   ; *                                           DUMMY FUNCTION
                    2996   ; *
                    2997   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2998   ; *
                    2999   ; * Arguments  : none
                    3000   ; *
                    3001   ; * Returns    : none
                    3002   ; *********************************************************************************************************
                    3003   ; */
                    3004   ; #if OS_TASK_DEL_EN > 0u
                    3005   ; void  OS_Dummy (void)
                    3006   ; {
                    3007   _OS_Dummy:
0000132C  4E75      3008          rts
                    3009   ; }
                    3010   ; #endif
                    3011   ; /*$PAGE*/
                    3012   ; /*
                    3013   ; *********************************************************************************************************
                    3014   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    3015   ; *
                    3016   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    3017   ; *              waiting for an event to occur.
                    3018   ; *
                    3019   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    3020   ; *
                    3021   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    3022   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    3023   ; *                          service functions.
                    3024   ; *
                    3025   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    3026   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    3027   ; *
                    3028   ; *              pend_stat   is used to indicate the readied task's pending status:
                    3029   ; *
                    3030   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    3031   ; *                                               an abort.
                    3032   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    3033   ; *
                    3034   ; * Returns    : none
                    3035   ; *
                    3036   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3037   ; *********************************************************************************************************
                    3038   ; */
                    3039   ; #if (OS_EVENT_EN)
                    3040   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    3041   ; void      *pmsg,
                    3042   ; INT8U      msk,
                    3043   ; INT8U      pend_stat)
                    3044   ; {
                    3045   _OS_EventTaskRdy:
0000132E  4E56 FFFC 3046          link      A6,#-4
00001332  48E7 3C00 3047          movem.l   D2/D3/D4/D5,-(A7)
00001336  262E 0008 3048          move.l    8(A6),D3
                    3049   ; OS_TCB   *ptcb;
                    3050   ; INT8U     y;
                    3051   ; INT8U     x;
                    3052   ; INT8U     prio;
                    3053   ; #if OS_LOWEST_PRIO > 63u
                    3054   ; OS_PRIO  *ptbl;
                    3055   ; #endif
                    3056   ; #if OS_LOWEST_PRIO <= 63u
                    3057   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
0000133A  2043      3058          move.l    D3,A0
0000133C  1028 0008 3059          move.b    8(A0),D0
00001340  C0BC 0000 3060          and.l     #255,D0
00001344  00FF      
00001346  41F9 0000 3061          lea       _OSUnMapTbl.L,A0
0000134A  6F7C      
0000134C  1830 0800 3062          move.b    0(A0,D0.L),D4
                    3063   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00001350  2043      3064          move.l    D3,A0
00001352  C8BC 0000 3065          and.l     #255,D4
00001356  00FF      
00001358  D1C4      3066          add.l     D4,A0
0000135A  1028 000A 3067          move.b    10(A0),D0
0000135E  C0BC 0000 3068          and.l     #255,D0
00001362  00FF      
00001364  41F9 0000 3069          lea       _OSUnMapTbl.L,A0
00001368  6F7C      
0000136A  1D70 0800 3070          move.b    0(A0,D0.L),-1(A6)
0000136E  FFFF      
                    3071   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001370  1004      3072          move.b    D4,D0
00001372  E708      3073          lsl.b     #3,D0
00001374  D02E FFFF 3074          add.b     -1(A6),D0
00001378  1A00      3075          move.b    D0,D5
                    3076   ; #else
                    3077   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    3078   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    3079   ; } else {
                    3080   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    3081   ; }
                    3082   ; ptbl = &pevent->OSEventTbl[y];
                    3083   ; if ((*ptbl & 0xFFu) != 0u) {
                    3084   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    3085   ; } else {
                    3086   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    3087   ; }
                    3088   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    3089   ; #endif
                    3090   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0000137A  CABC 0000 3091          and.l     #255,D5
0000137E  00FF      
00001380  2005      3092          move.l    D5,D0
00001382  E588      3093          lsl.l     #2,D0
00001384  41F9 0800 3094          lea       _OSTCBPrioTbl.L,A0
00001388  0E4A      
0000138A  2430 0800 3095          move.l    0(A0,D0.L),D2
                    3096   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
0000138E  2042      3097          move.l    D2,A0
00001390  42A8 002E 3098          clr.l     46(A0)
                    3099   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    3100   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
00001394  2042      3101          move.l    D2,A0
00001396  216E 000C 3102          move.l    12(A6),36(A0)
0000139A  0024      
                    3103   ; #else
                    3104   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    3105   ; #endif
                    3106   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
0000139C  2042      3107          move.l    D2,A0
0000139E  102E 0013 3108          move.b    19(A6),D0
000013A2  4600      3109          not.b     D0
000013A4  C128 0032 3110          and.b     D0,50(A0)
                    3111   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000013A8  2042      3112          move.l    D2,A0
000013AA  116E 0017 3113          move.b    23(A6),51(A0)
000013AE  0033      
                    3114   ; /* See if task is ready (could be susp'd)      */
                    3115   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000013B0  2042      3116          move.l    D2,A0
000013B2  1028 0032 3117          move.b    50(A0),D0
000013B6  C03C 0008 3118          and.b     #8,D0
000013BA  6622      3119          bne.s     OS_EventTaskRdy_1
                    3120   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000013BC  2042      3121          move.l    D2,A0
000013BE  1028 0038 3122          move.b    56(A0),D0
000013C2  8139 0800 3123          or.b      D0,_OSRdyGrp.L
000013C6  0D28      
                    3124   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000013C8  C8BC 0000 3125          and.l     #255,D4
000013CC  00FF      
000013CE  41F9 0800 3126          lea       _OSRdyTbl.L,A0
000013D2  0D2A      
000013D4  2242      3127          move.l    D2,A1
000013D6  1029 0037 3128          move.b    55(A1),D0
000013DA  8130 4800 3129          or.b      D0,0(A0,D4.L)
                    3130   OS_EventTaskRdy_1:
                    3131   ; }
                    3132   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000013DE  2F03      3133          move.l    D3,-(A7)
000013E0  2F02      3134          move.l    D2,-(A7)
000013E2  4EB9 0000 3135          jsr       _OS_EventTaskRemove
000013E6  1534      
000013E8  504F      3136          addq.w    #8,A7
                    3137   ; #if (OS_EVENT_MULTI_EN > 0u)
                    3138   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000013EA  2042      3139          move.l    D2,A0
000013EC  2028 0020 3140          move.l    32(A0),D0
000013F0  6716      3141          beq.s     OS_EventTaskRdy_3
                    3142   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000013F2  2042      3143          move.l    D2,A0
000013F4  2F28 0020 3144          move.l    32(A0),-(A7)
000013F8  2F02      3145          move.l    D2,-(A7)
000013FA  4EB9 0000 3146          jsr       _OS_EventTaskRemoveMulti
000013FE  1586      
00001400  504F      3147          addq.w    #8,A7
                    3148   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
00001402  2042      3149          move.l    D2,A0
00001404  2143 001C 3150          move.l    D3,28(A0)
                    3151   OS_EventTaskRdy_3:
                    3152   ; }
                    3153   ; #endif
                    3154   ; return (prio);
00001408  1005      3155          move.b    D5,D0
0000140A  4CDF 003C 3156          movem.l   (A7)+,D2/D3/D4/D5
0000140E  4E5E      3157          unlk      A6
00001410  4E75      3158          rts
                    3159   ; }
                    3160   ; #endif
                    3161   ; /*$PAGE*/
                    3162   ; /*
                    3163   ; *********************************************************************************************************
                    3164   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    3165   ; *
                    3166   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    3167   ; *              not occurred.
                    3168   ; *
                    3169   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    3170   ; *
                    3171   ; * Returns    : none
                    3172   ; *
                    3173   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3174   ; *********************************************************************************************************
                    3175   ; */
                    3176   ; #if (OS_EVENT_EN)
                    3177   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    3178   ; {
                    3179   _OS_EventTaskWait:
00001412  4E56 0000 3180          link      A6,#0
00001416  48E7 3020 3181          movem.l   D2/D3/A2,-(A7)
0000141A  45F9 0800 3182          lea       _OSTCBCur.L,A2
0000141E  0E3A      
00001420  262E 0008 3183          move.l    8(A6),D3
                    3184   ; INT8U  y;
                    3185   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
00001424  2052      3186          move.l    (A2),A0
00001426  2143 001C 3187          move.l    D3,28(A0)
                    3188   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0000142A  2043      3189          move.l    D3,A0
0000142C  2252      3190          move.l    (A2),A1
0000142E  1029 0036 3191          move.b    54(A1),D0
00001432  C0BC 0000 3192          and.l     #255,D0
00001436  00FF      
00001438  D1C0      3193          add.l     D0,A0
0000143A  2252      3194          move.l    (A2),A1
0000143C  1029 0037 3195          move.b    55(A1),D0
00001440  8128 000A 3196          or.b      D0,10(A0)
                    3197   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00001444  2043      3198          move.l    D3,A0
00001446  2252      3199          move.l    (A2),A1
00001448  1029 0038 3200          move.b    56(A1),D0
0000144C  8128 0008 3201          or.b      D0,8(A0)
                    3202   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00001450  2052      3203          move.l    (A2),A0
00001452  1428 0036 3204          move.b    54(A0),D2
                    3205   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00001456  C4BC 0000 3206          and.l     #255,D2
0000145A  00FF      
0000145C  41F9 0800 3207          lea       _OSRdyTbl.L,A0
00001460  0D2A      
00001462  2252      3208          move.l    (A2),A1
00001464  1029 0037 3209          move.b    55(A1),D0
00001468  4600      3210          not.b     D0
0000146A  C130 2800 3211          and.b     D0,0(A0,D2.L)
                    3212   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
0000146E  C4BC 0000 3213          and.l     #255,D2
00001472  00FF      
00001474  41F9 0800 3214          lea       _OSRdyTbl.L,A0
00001478  0D2A      
0000147A  1030 2800 3215          move.b    0(A0,D2.L),D0
0000147E  660E      3216          bne.s     OS_EventTaskWait_1
                    3217   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001480  2052      3218          move.l    (A2),A0
00001482  1028 0038 3219          move.b    56(A0),D0
00001486  4600      3220          not.b     D0
00001488  C139 0800 3221          and.b     D0,_OSRdyGrp.L
0000148C  0D28      
                    3222   OS_EventTaskWait_1:
0000148E  4CDF 040C 3223          movem.l   (A7)+,D2/D3/A2
00001492  4E5E      3224          unlk      A6
00001494  4E75      3225          rts
                    3226   ; }
                    3227   ; }
                    3228   ; #endif
                    3229   ; /*$PAGE*/
                    3230   ; /*
                    3231   ; *********************************************************************************************************
                    3232   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    3233   ; *
                    3234   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    3235   ; *              multiple events has not occurred.
                    3236   ; *
                    3237   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    3238   ; *                               which the task will be waiting for.
                    3239   ; *
                    3240   ; * Returns    : none.
                    3241   ; *
                    3242   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3243   ; *********************************************************************************************************
                    3244   ; */
                    3245   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3246   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    3247   ; {
                    3248   _OS_EventTaskWaitMulti:
00001496  4E56 0000 3249          link      A6,#0
0000149A  48E7 3820 3250          movem.l   D2/D3/D4/A2,-(A7)
0000149E  45F9 0800 3251          lea       _OSTCBCur.L,A2
000014A2  0E3A      
                    3252   ; OS_EVENT **pevents;
                    3253   ; OS_EVENT  *pevent;
                    3254   ; INT8U      y;
                    3255   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000014A4  2052      3256          move.l    (A2),A0
000014A6  42A8 001C 3257          clr.l     28(A0)
                    3258   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
000014AA  2052      3259          move.l    (A2),A0
000014AC  216E 0008 3260          move.l    8(A6),32(A0)
000014B0  0020      
                    3261   ; pevents =  pevents_wait;
000014B2  262E 0008 3262          move.l    8(A6),D3
                    3263   ; pevent  = *pevents;
000014B6  2043      3264          move.l    D3,A0
000014B8  2410      3265          move.l    (A0),D2
                    3266   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    3267   OS_EventTaskWaitMulti_1:
000014BA  4A82      3268          tst.l     D2
000014BC  6700 0030 3269          beq       OS_EventTaskWaitMulti_3
                    3270   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000014C0  2042      3271          move.l    D2,A0
000014C2  2252      3272          move.l    (A2),A1
000014C4  1029 0036 3273          move.b    54(A1),D0
000014C8  C0BC 0000 3274          and.l     #255,D0
000014CC  00FF      
000014CE  D1C0      3275          add.l     D0,A0
000014D0  2252      3276          move.l    (A2),A1
000014D2  1029 0037 3277          move.b    55(A1),D0
000014D6  8128 000A 3278          or.b      D0,10(A0)
                    3279   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000014DA  2042      3280          move.l    D2,A0
000014DC  2252      3281          move.l    (A2),A1
000014DE  1029 0038 3282          move.b    56(A1),D0
000014E2  8128 0008 3283          or.b      D0,8(A0)
                    3284   ; pevents++;
000014E6  5883      3285          addq.l    #4,D3
                    3286   ; pevent = *pevents;
000014E8  2043      3287          move.l    D3,A0
000014EA  2410      3288          move.l    (A0),D2
000014EC  60CC      3289          bra       OS_EventTaskWaitMulti_1
                    3290   OS_EventTaskWaitMulti_3:
                    3291   ; }
                    3292   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000014EE  2052      3293          move.l    (A2),A0
000014F0  1828 0036 3294          move.b    54(A0),D4
                    3295   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000014F4  C8BC 0000 3296          and.l     #255,D4
000014F8  00FF      
000014FA  41F9 0800 3297          lea       _OSRdyTbl.L,A0
000014FE  0D2A      
00001500  2252      3298          move.l    (A2),A1
00001502  1029 0037 3299          move.b    55(A1),D0
00001506  4600      3300          not.b     D0
00001508  C130 4800 3301          and.b     D0,0(A0,D4.L)
                    3302   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
0000150C  C8BC 0000 3303          and.l     #255,D4
00001510  00FF      
00001512  41F9 0800 3304          lea       _OSRdyTbl.L,A0
00001516  0D2A      
00001518  1030 4800 3305          move.b    0(A0,D4.L),D0
0000151C  660E      3306          bne.s     OS_EventTaskWaitMulti_4
                    3307   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000151E  2052      3308          move.l    (A2),A0
00001520  1028 0038 3309          move.b    56(A0),D0
00001524  4600      3310          not.b     D0
00001526  C139 0800 3311          and.b     D0,_OSRdyGrp.L
0000152A  0D28      
                    3312   OS_EventTaskWaitMulti_4:
0000152C  4CDF 041C 3313          movem.l   (A7)+,D2/D3/D4/A2
00001530  4E5E      3314          unlk      A6
00001532  4E75      3315          rts
                    3316   ; }
                    3317   ; }
                    3318   ; #endif
                    3319   ; /*$PAGE*/
                    3320   ; /*
                    3321   ; *********************************************************************************************************
                    3322   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    3323   ; *
                    3324   ; * Description: Remove a task from an event's wait list.
                    3325   ; *
                    3326   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    3327   ; *
                    3328   ; *              pevent   is a pointer to the event control block.
                    3329   ; *
                    3330   ; * Returns    : none
                    3331   ; *
                    3332   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3333   ; *********************************************************************************************************
                    3334   ; */
                    3335   ; #if (OS_EVENT_EN)
                    3336   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    3337   ; OS_EVENT *pevent)
                    3338   ; {
                    3339   _OS_EventTaskRemove:
00001534  4E56 0000 3340          link      A6,#0
00001538  48E7 3800 3341          movem.l   D2/D3/D4,-(A7)
0000153C  242E 000C 3342          move.l    12(A6),D2
00001540  262E 0008 3343          move.l    8(A6),D3
                    3344   ; INT8U  y;
                    3345   ; y                       =  ptcb->OSTCBY;
00001544  2043      3346          move.l    D3,A0
00001546  1828 0036 3347          move.b    54(A0),D4
                    3348   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
0000154A  2042      3349          move.l    D2,A0
0000154C  C8BC 0000 3350          and.l     #255,D4
00001550  00FF      
00001552  D1C4      3351          add.l     D4,A0
00001554  2243      3352          move.l    D3,A1
00001556  1029 0037 3353          move.b    55(A1),D0
0000155A  4600      3354          not.b     D0
0000155C  C128 000A 3355          and.b     D0,10(A0)
                    3356   ; if (pevent->OSEventTbl[y] == 0u) {
00001560  2042      3357          move.l    D2,A0
00001562  C8BC 0000 3358          and.l     #255,D4
00001566  00FF      
00001568  D1C4      3359          add.l     D4,A0
0000156A  1028 000A 3360          move.b    10(A0),D0
0000156E  660E      3361          bne.s     OS_EventTaskRemove_1
                    3362   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001570  2042      3363          move.l    D2,A0
00001572  2243      3364          move.l    D3,A1
00001574  1029 0038 3365          move.b    56(A1),D0
00001578  4600      3366          not.b     D0
0000157A  C128 0008 3367          and.b     D0,8(A0)
                    3368   OS_EventTaskRemove_1:
0000157E  4CDF 001C 3369          movem.l   (A7)+,D2/D3/D4
00001582  4E5E      3370          unlk      A6
00001584  4E75      3371          rts
                    3372   ; }
                    3373   ; }
                    3374   ; #endif
                    3375   ; /*$PAGE*/
                    3376   ; /*
                    3377   ; *********************************************************************************************************
                    3378   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    3379   ; *
                    3380   ; * Description: Remove a task from multiple events' wait lists.
                    3381   ; *
                    3382   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    3383   ; *
                    3384   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    3385   ; *
                    3386   ; * Returns    : none
                    3387   ; *
                    3388   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3389   ; *********************************************************************************************************
                    3390   ; */
                    3391   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    3392   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    3393   ; OS_EVENT **pevents_multi)
                    3394   ; {
                    3395   _OS_EventTaskRemoveMulti:
00001586  4E56 FFFC 3396          link      A6,#-4
0000158A  48E7 3C00 3397          movem.l   D2/D3/D4/D5,-(A7)
0000158E  282E 0008 3398          move.l    8(A6),D4
                    3399   ; OS_EVENT **pevents;
                    3400   ; OS_EVENT  *pevent;
                    3401   ; INT8U      y;
                    3402   ; OS_PRIO    bity;
                    3403   ; OS_PRIO    bitx;
                    3404   ; y       =  ptcb->OSTCBY;
00001592  2044      3405          move.l    D4,A0
00001594  1A28 0036 3406          move.b    54(A0),D5
                    3407   ; bity    =  ptcb->OSTCBBitY;
00001598  2044      3408          move.l    D4,A0
0000159A  1D68 0038 3409          move.b    56(A0),-2(A6)
0000159E  FFFE      
                    3410   ; bitx    =  ptcb->OSTCBBitX;
000015A0  2044      3411          move.l    D4,A0
000015A2  1D68 0037 3412          move.b    55(A0),-1(A6)
000015A6  FFFF      
                    3413   ; pevents =  pevents_multi;
000015A8  262E 000C 3414          move.l    12(A6),D3
                    3415   ; pevent  = *pevents;
000015AC  2043      3416          move.l    D3,A0
000015AE  2410      3417          move.l    (A0),D2
                    3418   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3419   OS_EventTaskRemoveMulti_1:
000015B0  4A82      3420          tst.l     D2
000015B2  6700 003A 3421          beq       OS_EventTaskRemoveMulti_3
                    3422   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
000015B6  2042      3423          move.l    D2,A0
000015B8  CABC 0000 3424          and.l     #255,D5
000015BC  00FF      
000015BE  D1C5      3425          add.l     D5,A0
000015C0  102E FFFF 3426          move.b    -1(A6),D0
000015C4  4600      3427          not.b     D0
000015C6  C128 000A 3428          and.b     D0,10(A0)
                    3429   ; if (pevent->OSEventTbl[y] == 0u) {
000015CA  2042      3430          move.l    D2,A0
000015CC  CABC 0000 3431          and.l     #255,D5
000015D0  00FF      
000015D2  D1C5      3432          add.l     D5,A0
000015D4  1028 000A 3433          move.b    10(A0),D0
000015D8  660C      3434          bne.s     OS_EventTaskRemoveMulti_4
                    3435   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
000015DA  2042      3436          move.l    D2,A0
000015DC  102E FFFE 3437          move.b    -2(A6),D0
000015E0  4600      3438          not.b     D0
000015E2  C128 0008 3439          and.b     D0,8(A0)
                    3440   OS_EventTaskRemoveMulti_4:
                    3441   ; }
                    3442   ; pevents++;
000015E6  5883      3443          addq.l    #4,D3
                    3444   ; pevent = *pevents;
000015E8  2043      3445          move.l    D3,A0
000015EA  2410      3446          move.l    (A0),D2
000015EC  60C2      3447          bra       OS_EventTaskRemoveMulti_1
                    3448   OS_EventTaskRemoveMulti_3:
000015EE  4CDF 003C 3449          movem.l   (A7)+,D2/D3/D4/D5
000015F2  4E5E      3450          unlk      A6
000015F4  4E75      3451          rts
                    3452   ; }
                    3453   ; }
                    3454   ; #endif
                    3455   ; /*$PAGE*/
                    3456   ; /*
                    3457   ; *********************************************************************************************************
                    3458   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3459   ; *
                    3460   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3461   ; *
                    3462   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3463   ; *
                    3464   ; * Returns    : none
                    3465   ; *
                    3466   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3467   ; *********************************************************************************************************
                    3468   ; */
                    3469   ; #if (OS_EVENT_EN)
                    3470   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3471   ; {
                    3472   _OS_EventWaitListInit:
000015F6  4E56 0000 3473          link      A6,#0
000015FA  2F02      3474          move.l    D2,-(A7)
                    3475   ; INT8U  i;
                    3476   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000015FC  206E 0008 3477          move.l    8(A6),A0
00001600  4228 0008 3478          clr.b     8(A0)
                    3479   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00001604  4202      3480          clr.b     D2
                    3481   OS_EventWaitListInit_1:
00001606  0C02 0008 3482          cmp.b     #8,D2
0000160A  6414      3483          bhs.s     OS_EventWaitListInit_3
                    3484   ; pevent->OSEventTbl[i] = 0u;
0000160C  206E 0008 3485          move.l    8(A6),A0
00001610  C4BC 0000 3486          and.l     #255,D2
00001614  00FF      
00001616  D1C2      3487          add.l     D2,A0
00001618  4228 000A 3488          clr.b     10(A0)
0000161C  5202      3489          addq.b    #1,D2
0000161E  60E6      3490          bra       OS_EventWaitListInit_1
                    3491   OS_EventWaitListInit_3:
00001620  241F      3492          move.l    (A7)+,D2
00001622  4E5E      3493          unlk      A6
00001624  4E75      3494          rts
                    3495   ; }
                    3496   ; }
                    3497   ; #endif
                    3498   ; /*$PAGE*/
                    3499   ; /*
                    3500   ; *********************************************************************************************************
                    3501   ; *                                             INITIALIZATION
                    3502   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3503   ; *
                    3504   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3505   ; *
                    3506   ; * Arguments  : none
                    3507   ; *
                    3508   ; * Returns    : none
                    3509   ; *********************************************************************************************************
                    3510   ; */
                    3511   ; static  void  OS_InitEventList (void)
                    3512   ; {
                    3513   @ucos_ii_OS_InitEventList:
00001626  4E56 FFF8 3514          link      A6,#-8
0000162A  48E7 3020 3515          movem.l   D2/D3/A2,-(A7)
0000162E  45F9 0800 3516          lea       _OSEventTbl.L,A2
00001632  0AF8      
                    3517   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3518   ; #if (OS_MAX_EVENTS > 1u)
                    3519   ; INT16U     ix;
                    3520   ; INT16U     ix_next;
                    3521   ; OS_EVENT  *pevent1;
                    3522   ; OS_EVENT  *pevent2;
                    3523   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00001634  4878 00DC 3524          pea       220
00001638  2F0A      3525          move.l    A2,-(A7)
0000163A  4EB9 0000 3526          jsr       _OS_MemClr
0000163E  18C2      
00001640  504F      3527          addq.w    #8,A7
                    3528   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00001642  4243      3529          clr.w     D3
                    3530   @ucos_ii_OS_InitEventList_1:
00001644  0C43 0009 3531          cmp.w     #9,D3
00001648  6400 004E 3532          bhs       @ucos_ii_OS_InitEventList_3
                    3533   ; ix_next = ix + 1u;
0000164C  3003      3534          move.w    D3,D0
0000164E  5240      3535          addq.w    #1,D0
00001650  3D40 FFFA 3536          move.w    D0,-6(A6)
                    3537   ; pevent1 = &OSEventTbl[ix];
00001654  200A      3538          move.l    A2,D0
00001656  C6BC 0000 3539          and.l     #65535,D3
0000165A  FFFF      
0000165C  2203      3540          move.l    D3,D1
0000165E  C3FC 0016 3541          muls      #22,D1
00001662  D081      3542          add.l     D1,D0
00001664  2400      3543          move.l    D0,D2
                    3544   ; pevent2 = &OSEventTbl[ix_next];
00001666  200A      3545          move.l    A2,D0
00001668  322E FFFA 3546          move.w    -6(A6),D1
0000166C  C2BC 0000 3547          and.l     #65535,D1
00001670  FFFF      
00001672  C3FC 0016 3548          muls      #22,D1
00001676  D081      3549          add.l     D1,D0
00001678  2D40 FFFC 3550          move.l    D0,-4(A6)
                    3551   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0000167C  2042      3552          move.l    D2,A0
0000167E  4210      3553          clr.b     (A0)
                    3554   ; pevent1->OSEventPtr     = pevent2;
00001680  2042      3555          move.l    D2,A0
00001682  216E FFFC 3556          move.l    -4(A6),2(A0)
00001686  0002      
                    3557   ; #if OS_EVENT_NAME_EN > 0u
                    3558   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00001688  41F9 0000 3559          lea       @ucos_ii_1.L,A0
0000168C  6F2A      
0000168E  2242      3560          move.l    D2,A1
00001690  2348 0012 3561          move.l    A0,18(A1)
00001694  5243      3562          addq.w    #1,D3
00001696  60AC      3563          bra       @ucos_ii_OS_InitEventList_1
                    3564   @ucos_ii_OS_InitEventList_3:
                    3565   ; #endif
                    3566   ; }
                    3567   ; pevent1                         = &OSEventTbl[ix];
00001698  200A      3568          move.l    A2,D0
0000169A  C6BC 0000 3569          and.l     #65535,D3
0000169E  FFFF      
000016A0  2203      3570          move.l    D3,D1
000016A2  C3FC 0016 3571          muls      #22,D1
000016A6  D081      3572          add.l     D1,D0
000016A8  2400      3573          move.l    D0,D2
                    3574   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000016AA  2042      3575          move.l    D2,A0
000016AC  4210      3576          clr.b     (A0)
                    3577   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
000016AE  2042      3578          move.l    D2,A0
000016B0  42A8 0002 3579          clr.l     2(A0)
                    3580   ; #if OS_EVENT_NAME_EN > 0u
                    3581   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
000016B4  41F9 0000 3582          lea       @ucos_ii_1.L,A0
000016B8  6F2A      
000016BA  2242      3583          move.l    D2,A1
000016BC  2348 0012 3584          move.l    A0,18(A1)
                    3585   ; #endif
                    3586   ; OSEventFreeList                 = &OSEventTbl[0];
000016C0  23CA 0800 3587          move.l    A2,_OSEventFreeList.L
000016C4  0AF4      
000016C6  4CDF 040C 3588          movem.l   (A7)+,D2/D3/A2
000016CA  4E5E      3589          unlk      A6
000016CC  4E75      3590          rts
                    3591   ; #else
                    3592   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3593   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3594   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3595   ; #if OS_EVENT_NAME_EN > 0u
                    3596   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3597   ; #endif
                    3598   ; #endif
                    3599   ; #endif
                    3600   ; }
                    3601   ; /*$PAGE*/
                    3602   ; /*
                    3603   ; *********************************************************************************************************
                    3604   ; *                                             INITIALIZATION
                    3605   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3606   ; *
                    3607   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3608   ; *
                    3609   ; * Arguments  : none
                    3610   ; *
                    3611   ; * Returns    : none
                    3612   ; *********************************************************************************************************
                    3613   ; */
                    3614   ; static  void  OS_InitMisc (void)
                    3615   ; {
                    3616   @ucos_ii_OS_InitMisc:
                    3617   ; #if OS_TIME_GET_SET_EN > 0u
                    3618   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000016CE  42B9 0800 3619          clr.l     _OSTime.L
000016D2  1790      
                    3620   ; #endif
                    3621   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000016D4  4239 0800 3622          clr.b     _OSIntNesting.L
000016D8  0D20      
                    3623   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
000016DA  4239 0800 3624          clr.b     _OSLockNesting.L
000016DE  0D22      
                    3625   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
000016E0  4239 0800 3626          clr.b     _OSTaskCtr.L
000016E4  0D34      
                    3627   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000016E6  4239 0800 3628          clr.b     _OSRunning.L
000016EA  0D32      
                    3629   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000016EC  42B9 0800 3630          clr.l     _OSCtxSwCtr.L
000016F0  0AF0      
                    3631   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
000016F2  42B9 0800 3632          clr.l     _OSIdleCtr.L
000016F6  0D36      
                    3633   ; #if OS_TASK_STAT_EN > 0u
                    3634   ; OSIdleCtrRun              = 0uL;
000016F8  42B9 0800 3635          clr.l     _OSIdleCtrRun.L
000016FC  0C1A      
                    3636   ; OSIdleCtrMax              = 0uL;
000016FE  42B9 0800 3637          clr.l     _OSIdleCtrMax.L
00001702  0C16      
                    3638   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
00001704  4239 0800 3639          clr.b     _OSStatRdy.L
00001708  0C1E      
                    3640   ; #endif
                    3641   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3642   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3643   ; #endif
                    3644   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3645   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
0000170A  4239 0800 3646          clr.b     _OSTaskRegNextAvailID.L
0000170E  178E      
00001710  4E75      3647          rts
                    3648   ; #endif
                    3649   ; }
                    3650   ; /*$PAGE*/
                    3651   ; /*
                    3652   ; *********************************************************************************************************
                    3653   ; *                                             INITIALIZATION
                    3654   ; *                                       INITIALIZE THE READY LIST
                    3655   ; *
                    3656   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3657   ; *
                    3658   ; * Arguments  : none
                    3659   ; *
                    3660   ; * Returns    : none
                    3661   ; *********************************************************************************************************
                    3662   ; */
                    3663   ; static  void  OS_InitRdyList (void)
                    3664   ; {
                    3665   @ucos_ii_OS_InitRdyList:
00001712  2F02      3666          move.l    D2,-(A7)
                    3667   ; INT8U  i;
                    3668   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
00001714  4239 0800 3669          clr.b     _OSRdyGrp.L
00001718  0D28      
                    3670   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
0000171A  4202      3671          clr.b     D2
                    3672   @ucos_ii_OS_InitRdyList_1:
0000171C  0C02 0008 3673          cmp.b     #8,D2
00001720  6414      3674          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3675   ; OSRdyTbl[i] = 0u;
00001722  C4BC 0000 3676          and.l     #255,D2
00001726  00FF      
00001728  41F9 0800 3677          lea       _OSRdyTbl.L,A0
0000172C  0D2A      
0000172E  4230 2800 3678          clr.b     0(A0,D2.L)
00001732  5202      3679          addq.b    #1,D2
00001734  60E6      3680          bra       @ucos_ii_OS_InitRdyList_1
                    3681   @ucos_ii_OS_InitRdyList_3:
                    3682   ; }
                    3683   ; OSPrioCur     = 0u;
00001736  4239 0800 3684          clr.b     _OSPrioCur.L
0000173A  0D24      
                    3685   ; OSPrioHighRdy = 0u;
0000173C  4239 0800 3686          clr.b     _OSPrioHighRdy.L
00001740  0D26      
                    3687   ; OSTCBHighRdy  = (OS_TCB *)0;
00001742  42B9 0800 3688          clr.l     _OSTCBHighRdy.L
00001746  0E42      
                    3689   ; OSTCBCur      = (OS_TCB *)0;
00001748  42B9 0800 3690          clr.l     _OSTCBCur.L
0000174C  0E3A      
0000174E  241F      3691          move.l    (A7)+,D2
00001750  4E75      3692          rts
                    3693   ; }
                    3694   ; /*$PAGE*/
                    3695   ; /*
                    3696   ; *********************************************************************************************************
                    3697   ; *                                             INITIALIZATION
                    3698   ; *                                         CREATING THE IDLE TASK
                    3699   ; *
                    3700   ; * Description: This function creates the Idle Task.
                    3701   ; *
                    3702   ; * Arguments  : none
                    3703   ; *
                    3704   ; * Returns    : none
                    3705   ; *********************************************************************************************************
                    3706   ; */
                    3707   ; static  void  OS_InitTaskIdle (void)
                    3708   ; {
                    3709   @ucos_ii_OS_InitTaskIdle:
00001752  4E56 FFFC 3710          link      A6,#-4
                    3711   ; #if OS_TASK_NAME_EN > 0u
                    3712   ; INT8U  err;
                    3713   ; #endif
                    3714   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3715   ; #if OS_STK_GROWTH == 1u
                    3716   ; (void)OSTaskCreateExt(OS_TaskIdle,
00001756  4878 0003 3717          pea       3
0000175A  42A7      3718          clr.l     -(A7)
0000175C  4878 0080 3719          pea       128
00001760  4879 0800 3720          pea       _OSTaskIdleStk.L
00001764  0D3A      
00001766  4878 FFFF 3721          pea       65535
0000176A  4878 003F 3722          pea       63
0000176E  41F9 0800 3723          lea       _OSTaskIdleStk.L,A0
00001772  0D3A      
00001774  D0FC 00FE 3724          add.w     #254,A0
00001778  2F08      3725          move.l    A0,-(A7)
0000177A  42A7      3726          clr.l     -(A7)
0000177C  4879 0000 3727          pea       _OS_TaskIdle.L
00001780  19D8      
00001782  4EB9 0000 3728          jsr       _OSTaskCreateExt
00001786  4878      
00001788  DEFC 0024 3729          add.w     #36,A7
0000178C  C0BC 0000 3730          and.l     #255,D0
00001790  00FF      
                    3731   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3732   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3733   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3734   ; OS_TASK_IDLE_ID,
                    3735   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3736   ; OS_TASK_IDLE_STK_SIZE,
                    3737   ; (void *)0,                                 /* No TCB extension                     */
                    3738   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3739   ; #else
                    3740   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3741   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3742   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3743   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3744   ; OS_TASK_IDLE_ID,
                    3745   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3746   ; OS_TASK_IDLE_STK_SIZE,
                    3747   ; (void *)0,                                 /* No TCB extension                     */
                    3748   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3749   ; #endif
                    3750   ; #else
                    3751   ; #if OS_STK_GROWTH == 1u
                    3752   ; (void)OSTaskCreate(OS_TaskIdle,
                    3753   ; (void *)0,
                    3754   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3755   ; OS_TASK_IDLE_PRIO);
                    3756   ; #else
                    3757   ; (void)OSTaskCreate(OS_TaskIdle,
                    3758   ; (void *)0,
                    3759   ; &OSTaskIdleStk[0],
                    3760   ; OS_TASK_IDLE_PRIO);
                    3761   ; #endif
                    3762   ; #endif
                    3763   ; #if OS_TASK_NAME_EN > 0u
                    3764   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
00001792  486E FFFF 3765          pea       -1(A6)
00001796  4879 0000 3766          pea       @ucos_ii_2.L
0000179A  6F2C      
0000179C  4878 003F 3767          pea       63
000017A0  4EB9 0000 3768          jsr       _OSTaskNameSet
000017A4  4C84      
000017A6  DEFC 000C 3769          add.w     #12,A7
000017AA  4E5E      3770          unlk      A6
000017AC  4E75      3771          rts
                    3772   ; #endif
                    3773   ; }
                    3774   ; /*$PAGE*/
                    3775   ; /*
                    3776   ; *********************************************************************************************************
                    3777   ; *                                             INITIALIZATION
                    3778   ; *                                      CREATING THE STATISTIC TASK
                    3779   ; *
                    3780   ; * Description: This function creates the Statistic Task.
                    3781   ; *
                    3782   ; * Arguments  : none
                    3783   ; *
                    3784   ; * Returns    : none
                    3785   ; *********************************************************************************************************
                    3786   ; */
                    3787   ; #if OS_TASK_STAT_EN > 0u
                    3788   ; static  void  OS_InitTaskStat (void)
                    3789   ; {
                    3790   @ucos_ii_OS_InitTaskStat:
000017AE  4E56 FFFC 3791          link      A6,#-4
                    3792   ; #if OS_TASK_NAME_EN > 0u
                    3793   ; INT8U  err;
                    3794   ; #endif
                    3795   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3796   ; #if OS_STK_GROWTH == 1u
                    3797   ; (void)OSTaskCreateExt(OS_TaskStat,
000017B2  4878 0003 3798          pea       3
000017B6  42A7      3799          clr.l     -(A7)
000017B8  4878 0080 3800          pea       128
000017BC  4879 0800 3801          pea       _OSTaskStatStk.L
000017C0  0C20      
000017C2  4878 FFFE 3802          pea       65534
000017C6  4878 003E 3803          pea       62
000017CA  41F9 0800 3804          lea       _OSTaskStatStk.L,A0
000017CE  0C20      
000017D0  D0FC 00FE 3805          add.w     #254,A0
000017D4  2F08      3806          move.l    A0,-(A7)
000017D6  42A7      3807          clr.l     -(A7)
000017D8  4879 0000 3808          pea       _OS_TaskStat.L
000017DC  19F0      
000017DE  4EB9 0000 3809          jsr       _OSTaskCreateExt
000017E2  4878      
000017E4  DEFC 0024 3810          add.w     #36,A7
000017E8  C0BC 0000 3811          and.l     #255,D0
000017EC  00FF      
                    3812   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3813   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3814   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3815   ; OS_TASK_STAT_ID,
                    3816   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3817   ; OS_TASK_STAT_STK_SIZE,
                    3818   ; (void *)0,                                   /* No TCB extension               */
                    3819   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3820   ; #else
                    3821   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3822   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3823   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3824   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3825   ; OS_TASK_STAT_ID,
                    3826   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3827   ; OS_TASK_STAT_STK_SIZE,
                    3828   ; (void *)0,                                   /* No TCB extension               */
                    3829   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3830   ; #endif
                    3831   ; #else
                    3832   ; #if OS_STK_GROWTH == 1u
                    3833   ; (void)OSTaskCreate(OS_TaskStat,
                    3834   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3835   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3836   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3837   ; #else
                    3838   ; (void)OSTaskCreate(OS_TaskStat,
                    3839   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3840   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3841   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3842   ; #endif
                    3843   ; #endif
                    3844   ; #if OS_TASK_NAME_EN > 0u
                    3845   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000017EE  486E FFFF 3846          pea       -1(A6)
000017F2  4879 0000 3847          pea       @ucos_ii_3.L
000017F6  6F3A      
000017F8  4878 003E 3848          pea       62
000017FC  4EB9 0000 3849          jsr       _OSTaskNameSet
00001800  4C84      
00001802  DEFC 000C 3850          add.w     #12,A7
00001806  4E5E      3851          unlk      A6
00001808  4E75      3852          rts
                    3853   ; #endif
                    3854   ; }
                    3855   ; #endif
                    3856   ; /*$PAGE*/
                    3857   ; /*
                    3858   ; *********************************************************************************************************
                    3859   ; *                                             INITIALIZATION
                    3860   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3861   ; *
                    3862   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3863   ; *
                    3864   ; * Arguments  : none
                    3865   ; *
                    3866   ; * Returns    : none
                    3867   ; *********************************************************************************************************
                    3868   ; */
                    3869   ; static  void  OS_InitTCBList (void)
                    3870   ; {
                    3871   @ucos_ii_OS_InitTCBList:
0000180A  4E56 FFF8 3872          link      A6,#-8
0000180E  48E7 3020 3873          movem.l   D2/D3/A2,-(A7)
00001812  45F9 0800 3874          lea       _OSTCBTbl.L,A2
00001816  0F4A      
                    3875   ; INT8U    ix;
                    3876   ; INT8U    ix_next;
                    3877   ; OS_TCB  *ptcb1;
                    3878   ; OS_TCB  *ptcb2;
                    3879   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
00001818  4878 0764 3880          pea       1892
0000181C  2F0A      3881          move.l    A2,-(A7)
0000181E  4EB9 0000 3882          jsr       _OS_MemClr
00001822  18C2      
00001824  504F      3883          addq.w    #8,A7
                    3884   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00001826  4878 0100 3885          pea       256
0000182A  4879 0800 3886          pea       _OSTCBPrioTbl.L
0000182E  0E4A      
00001830  4EB9 0000 3887          jsr       _OS_MemClr
00001834  18C2      
00001836  504F      3888          addq.w    #8,A7
                    3889   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
00001838  4203      3890          clr.b     D3
                    3891   @ucos_ii_OS_InitTCBList_1:
0000183A  0C03 0015 3892          cmp.b     #21,D3
0000183E  6400 004A 3893          bhs       @ucos_ii_OS_InitTCBList_3
                    3894   ; ix_next =  ix + 1u;
00001842  7001      3895          moveq     #1,D0
00001844  D003      3896          add.b     D3,D0
00001846  1D40 FFFB 3897          move.b    D0,-5(A6)
                    3898   ; ptcb1   = &OSTCBTbl[ix];
0000184A  200A      3899          move.l    A2,D0
0000184C  C6BC 0000 3900          and.l     #255,D3
00001850  00FF      
00001852  2203      3901          move.l    D3,D1
00001854  C3FC 0056 3902          muls      #86,D1
00001858  D081      3903          add.l     D1,D0
0000185A  2400      3904          move.l    D0,D2
                    3905   ; ptcb2   = &OSTCBTbl[ix_next];
0000185C  200A      3906          move.l    A2,D0
0000185E  122E FFFB 3907          move.b    -5(A6),D1
00001862  C2BC 0000 3908          and.l     #255,D1
00001866  00FF      
00001868  C3FC 0056 3909          muls      #86,D1
0000186C  D081      3910          add.l     D1,D0
0000186E  2D40 FFFC 3911          move.l    D0,-4(A6)
                    3912   ; ptcb1->OSTCBNext = ptcb2;
00001872  2042      3913          move.l    D2,A0
00001874  216E FFFC 3914          move.l    -4(A6),20(A0)
00001878  0014      
                    3915   ; #if OS_TASK_NAME_EN > 0u
                    3916   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
0000187A  41F9 0000 3917          lea       @ucos_ii_1.L,A0
0000187E  6F2A      
00001880  2242      3918          move.l    D2,A1
00001882  2348 004E 3919          move.l    A0,78(A1)
00001886  5203      3920          addq.b    #1,D3
00001888  60B0      3921          bra       @ucos_ii_OS_InitTCBList_1
                    3922   @ucos_ii_OS_InitTCBList_3:
                    3923   ; #endif
                    3924   ; }
                    3925   ; ptcb1                   = &OSTCBTbl[ix];
0000188A  200A      3926          move.l    A2,D0
0000188C  C6BC 0000 3927          and.l     #255,D3
00001890  00FF      
00001892  2203      3928          move.l    D3,D1
00001894  C3FC 0056 3929          muls      #86,D1
00001898  D081      3930          add.l     D1,D0
0000189A  2400      3931          move.l    D0,D2
                    3932   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
0000189C  2042      3933          move.l    D2,A0
0000189E  42A8 0014 3934          clr.l     20(A0)
                    3935   ; #if OS_TASK_NAME_EN > 0u
                    3936   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000018A2  41F9 0000 3937          lea       @ucos_ii_1.L,A0
000018A6  6F2A      
000018A8  2242      3938          move.l    D2,A1
000018AA  2348 004E 3939          move.l    A0,78(A1)
                    3940   ; #endif
                    3941   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000018AE  42B9 0800 3942          clr.l     _OSTCBList.L
000018B2  0E46      
                    3943   ; OSTCBFreeList           = &OSTCBTbl[0];
000018B4  23CA 0800 3944          move.l    A2,_OSTCBFreeList.L
000018B8  0E3E      
000018BA  4CDF 040C 3945          movem.l   (A7)+,D2/D3/A2
000018BE  4E5E      3946          unlk      A6
000018C0  4E75      3947          rts
                    3948   ; }
                    3949   ; /*$PAGE*/
                    3950   ; /*
                    3951   ; *********************************************************************************************************
                    3952   ; *                                      CLEAR A SECTION OF MEMORY
                    3953   ; *
                    3954   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3955   ; *
                    3956   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3957   ; *
                    3958   ; *              size     is the number of bytes to clear.
                    3959   ; *
                    3960   ; * Returns    : none
                    3961   ; *
                    3962   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3963   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3964   ; *                 of the uses of this function gets close to this limit.
                    3965   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3966   ; *                 of the alignment of the destination.
                    3967   ; *********************************************************************************************************
                    3968   ; */
                    3969   ; void  OS_MemClr (INT8U  *pdest,
                    3970   ; INT16U  size)
                    3971   ; {
                    3972   _OS_MemClr:
000018C2  4E56 0000 3973          link      A6,#0
                    3974   ; while (size > 0u) {
                    3975   OS_MemClr_1:
000018C6  302E 000E 3976          move.w    14(A6),D0
000018CA  0C40 0000 3977          cmp.w     #0,D0
000018CE  6310      3978          bls.s     OS_MemClr_3
                    3979   ; *pdest++ = (INT8U)0;
000018D0  206E 0008 3980          move.l    8(A6),A0
000018D4  52AE 0008 3981          addq.l    #1,8(A6)
000018D8  4210      3982          clr.b     (A0)
                    3983   ; size--;
000018DA  536E 000E 3984          subq.w    #1,14(A6)
000018DE  60E6      3985          bra       OS_MemClr_1
                    3986   OS_MemClr_3:
000018E0  4E5E      3987          unlk      A6
000018E2  4E75      3988          rts
                    3989   ; }
                    3990   ; }
                    3991   ; /*$PAGE*/
                    3992   ; /*
                    3993   ; *********************************************************************************************************
                    3994   ; *                                       COPY A BLOCK OF MEMORY
                    3995   ; *
                    3996   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3997   ; *              location to another.
                    3998   ; *
                    3999   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    4000   ; *
                    4001   ; *              psrc     is a pointer to the 'source'      memory block
                    4002   ; *
                    4003   ; *              size     is the number of bytes to copy.
                    4004   ; *
                    4005   ; * Returns    : none
                    4006   ; *
                    4007   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    4008   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    4009   ; *                 is not a situation that will happen.
                    4010   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    4011   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    4012   ; *                 of the alignment of the source and destination.
                    4013   ; *********************************************************************************************************
                    4014   ; */
                    4015   ; void  OS_MemCopy (INT8U  *pdest,
                    4016   ; INT8U  *psrc,
                    4017   ; INT16U  size)
                    4018   ; {
                    4019   _OS_MemCopy:
000018E4  4E56 0000 4020          link      A6,#0
                    4021   ; while (size > 0u) {
                    4022   OS_MemCopy_1:
000018E8  302E 0012 4023          move.w    18(A6),D0
000018EC  0C40 0000 4024          cmp.w     #0,D0
000018F0  6318      4025          bls.s     OS_MemCopy_3
                    4026   ; *pdest++ = *psrc++;
000018F2  206E 000C 4027          move.l    12(A6),A0
000018F6  52AE 000C 4028          addq.l    #1,12(A6)
000018FA  226E 0008 4029          move.l    8(A6),A1
000018FE  52AE 0008 4030          addq.l    #1,8(A6)
00001902  1290      4031          move.b    (A0),(A1)
                    4032   ; size--;
00001904  536E 0012 4033          subq.w    #1,18(A6)
00001908  60DE      4034          bra       OS_MemCopy_1
                    4035   OS_MemCopy_3:
0000190A  4E5E      4036          unlk      A6
0000190C  4E75      4037          rts
                    4038   ; }
                    4039   ; }
                    4040   ; /*$PAGE*/
                    4041   ; /*
                    4042   ; *********************************************************************************************************
                    4043   ; *                                              SCHEDULER
                    4044   ; *
                    4045   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    4046   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    4047   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    4048   ; *
                    4049   ; * Arguments  : none
                    4050   ; *
                    4051   ; * Returns    : none
                    4052   ; *
                    4053   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4054   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    4055   ; *********************************************************************************************************
                    4056   ; */
                    4057   ; void  OS_Sched (void)
                    4058   ; {
                    4059   _OS_Sched:
                    4060   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    4061   ; OS_CPU_SR  cpu_sr = 0u;
                    4062   ; #endif
                    4063   ; OS_ENTER_CRITICAL();
0000190E  40E7      4064          dc.w      16615
00001910  007C      4065          dc.w      124
00001912  0700      4066          dc.w      1792
                    4067   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00001914  1039 0800 4068          move.b    _OSIntNesting.L,D0
00001918  0D20      
0000191A  6600 0052 4069          bne       OS_Sched_5
                    4070   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
0000191E  1039 0800 4071          move.b    _OSLockNesting.L,D0
00001922  0D22      
00001924  6648      4072          bne.s     OS_Sched_5
                    4073   ; OS_SchedNew();
00001926  4EB9 0000 4074          jsr       @ucos_ii_OS_SchedNew
0000192A  1972      
                    4075   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0000192C  1039 0800 4076          move.b    _OSPrioHighRdy.L,D0
00001930  0D26      
00001932  C0BC 0000 4077          and.l     #255,D0
00001936  00FF      
00001938  E588      4078          lsl.l     #2,D0
0000193A  41F9 0800 4079          lea       _OSTCBPrioTbl.L,A0
0000193E  0E4A      
00001940  23F0 0800 4080          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00001944  0800 0E42 
                    4081   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001948  1039 0800 4082          move.b    _OSPrioHighRdy.L,D0
0000194C  0D26      
0000194E  B039 0800 4083          cmp.b     _OSPrioCur.L,D0
00001952  0D24      
00001954  6718      4084          beq.s     OS_Sched_5
                    4085   ; #if OS_TASK_PROFILE_EN > 0u
                    4086   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00001956  2039 0800 4087          move.l    _OSTCBHighRdy.L,D0
0000195A  0E42      
0000195C  0680 0000 4088          add.l     #58,D0
00001960  003A      
00001962  2040      4089          move.l    D0,A0
00001964  5290      4090          addq.l    #1,(A0)
                    4091   ; #endif
                    4092   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
00001966  52B9 0800 4093          addq.l    #1,_OSCtxSwCtr.L
0000196A  0AF0      
                    4094   ; OS_TASK_SW();                          /* Perform a context switch                     */
0000196C  4E40      4095          trap      #0
                    4096   OS_Sched_5:
                    4097   ; }
                    4098   ; }
                    4099   ; }
                    4100   ; OS_EXIT_CRITICAL();
0000196E  46DF      4101          dc.w      18143
00001970  4E75      4102          rts
                    4103   ; }
                    4104   ; /*
                    4105   ; *********************************************************************************************************
                    4106   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    4107   ; *
                    4108   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    4109   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    4110   ; *
                    4111   ; * Arguments  : none
                    4112   ; *
                    4113   ; * Returns    : none
                    4114   ; *
                    4115   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4116   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    4117   ; *********************************************************************************************************
                    4118   ; */
                    4119   ; static  void  OS_SchedNew (void)
                    4120   ; {
                    4121   @ucos_ii_OS_SchedNew:
00001972  2F02      4122          move.l    D2,-(A7)
                    4123   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    4124   ; INT8U   y;
                    4125   ; y             = OSUnMapTbl[OSRdyGrp];
00001974  1039 0800 4126          move.b    _OSRdyGrp.L,D0
00001978  0D28      
0000197A  C0BC 0000 4127          and.l     #255,D0
0000197E  00FF      
00001980  41F9 0000 4128          lea       _OSUnMapTbl.L,A0
00001984  6F7C      
00001986  1430 0800 4129          move.b    0(A0,D0.L),D2
                    4130   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
0000198A  1002      4131          move.b    D2,D0
0000198C  E708      4132          lsl.b     #3,D0
0000198E  C4BC 0000 4133          and.l     #255,D2
00001992  00FF      
00001994  41F9 0800 4134          lea       _OSRdyTbl.L,A0
00001998  0D2A      
0000199A  1230 2800 4135          move.b    0(A0,D2.L),D1
0000199E  C2BC 0000 4136          and.l     #255,D1
000019A2  00FF      
000019A4  41F9 0000 4137          lea       _OSUnMapTbl.L,A0
000019A8  6F7C      
000019AA  D030 1800 4138          add.b     0(A0,D1.L),D0
000019AE  13C0 0800 4139          move.b    D0,_OSPrioHighRdy.L
000019B2  0D26      
000019B4  241F      4140          move.l    (A7)+,D2
000019B6  4E75      4141          rts
                    4142   ; #else                                            /* We support up to 256 tasks                         */
                    4143   ; INT8U     y;
                    4144   ; OS_PRIO  *ptbl;
                    4145   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    4146   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    4147   ; } else {
                    4148   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    4149   ; }
                    4150   ; ptbl = &OSRdyTbl[y];
                    4151   ; if ((*ptbl & 0xFFu) != 0u) {
                    4152   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    4153   ; } else {
                    4154   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    4155   ; }
                    4156   ; #endif
                    4157   ; }
                    4158   ; /*$PAGE*/
                    4159   ; /*
                    4160   ; *********************************************************************************************************
                    4161   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    4162   ; *
                    4163   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    4164   ; *              (excluding the NUL character).
                    4165   ; *
                    4166   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    4167   ; *
                    4168   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    4169   ; *
                    4170   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    4171   ; *              2) The string to check must be less than 255 characters long.
                    4172   ; *********************************************************************************************************
                    4173   ; */
                    4174   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    4175   ; INT8U  OS_StrLen (INT8U *psrc)
                    4176   ; {
                    4177   _OS_StrLen:
000019B8  4E56 0000 4178          link      A6,#0
000019BC  2F02      4179          move.l    D2,-(A7)
                    4180   ; INT8U  len;
                    4181   ; #if OS_ARG_CHK_EN > 0u
                    4182   ; if (psrc == (INT8U *)0) {
                    4183   ; return (0u);
                    4184   ; }
                    4185   ; #endif
                    4186   ; len = 0u;
000019BE  4202      4187          clr.b     D2
                    4188   ; while (*psrc != OS_ASCII_NUL) {
                    4189   OS_StrLen_1:
000019C0  206E 0008 4190          move.l    8(A6),A0
000019C4  1010      4191          move.b    (A0),D0
000019C6  6708      4192          beq.s     OS_StrLen_3
                    4193   ; psrc++;
000019C8  52AE 0008 4194          addq.l    #1,8(A6)
                    4195   ; len++;
000019CC  5202      4196          addq.b    #1,D2
000019CE  60F0      4197          bra       OS_StrLen_1
                    4198   OS_StrLen_3:
                    4199   ; }
                    4200   ; return (len);
000019D0  1002      4201          move.b    D2,D0
000019D2  241F      4202          move.l    (A7)+,D2
000019D4  4E5E      4203          unlk      A6
000019D6  4E75      4204          rts
                    4205   ; }
                    4206   ; #endif
                    4207   ; /*$PAGE*/
                    4208   ; /*
                    4209   ; *********************************************************************************************************
                    4210   ; *                                              IDLE TASK
                    4211   ; *
                    4212   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    4213   ; *              executes because they are ALL waiting for event(s) to occur.
                    4214   ; *
                    4215   ; * Arguments  : none
                    4216   ; *
                    4217   ; * Returns    : none
                    4218   ; *
                    4219   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    4220   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    4221   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    4222   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    4223   ; *                 interrupts.
                    4224   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    4225   ; *                 power.
                    4226   ; *********************************************************************************************************
                    4227   ; */
                    4228   ; void  OS_TaskIdle (void *p_arg)
                    4229   ; {
                    4230   _OS_TaskIdle:
000019D8  4E56 0000 4231          link      A6,#0
                    4232   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4233   ; OS_CPU_SR  cpu_sr = 0u;
                    4234   ; #endif
                    4235   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4236   ; for (;;) {
                    4237   OS_TaskIdle_1:
                    4238   ; OS_ENTER_CRITICAL();
000019DC  40E7      4239          dc.w      16615
000019DE  007C      4240          dc.w      124
000019E0  0700      4241          dc.w      1792
                    4242   ; OSIdleCtr++;
000019E2  52B9 0800 4243          addq.l    #1,_OSIdleCtr.L
000019E6  0D36      
                    4244   ; OS_EXIT_CRITICAL();
000019E8  46DF      4245          dc.w      18143
                    4246   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
000019EA  4EB8 0C04 4247          jsr       _OSTaskIdleHook
000019EE  60EC      4248          bra       OS_TaskIdle_1
                    4249   ; }
                    4250   ; }
                    4251   ; /*$PAGE*/
                    4252   ; /*
                    4253   ; *********************************************************************************************************
                    4254   ; *                                           STATISTICS TASK
                    4255   ; *
                    4256   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    4257   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    4258   ; *              CPU usage is determined by:
                    4259   ; *
                    4260   ; *                                          OSIdleCtr
                    4261   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    4262   ; *                                         OSIdleCtrMax
                    4263   ; *
                    4264   ; * Arguments  : parg     this pointer is not used at this time.
                    4265   ; *
                    4266   ; * Returns    : none
                    4267   ; *
                    4268   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    4269   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    4270   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    4271   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    4272   ; *                 maximum value for the idle counter.
                    4273   ; *********************************************************************************************************
                    4274   ; */
                    4275   ; #if OS_TASK_STAT_EN > 0u
                    4276   ; void  OS_TaskStat (void *p_arg)
                    4277   ; {
                    4278   _OS_TaskStat:
000019F0  4E56 0000 4279          link      A6,#0
000019F4  2F0A      4280          move.l    A2,-(A7)
000019F6  45F9 0800 4281          lea       _OSIdleCtrMax.L,A2
000019FA  0C16      
                    4282   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    4283   ; OS_CPU_SR  cpu_sr = 0u;
                    4284   ; #endif
                    4285   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    4286   ; while (OSStatRdy == OS_FALSE) {
                    4287   OS_TaskStat_1:
000019FC  1039 0800 4288          move.b    _OSStatRdy.L,D0
00001A00  0C1E      
00001A02  660E      4289          bne.s     OS_TaskStat_3
                    4290   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
00001A04  4878 0014 4291          pea       20
00001A08  4EB9 0000 4292          jsr       _OSTimeDly
00001A0C  510A      
00001A0E  584F      4293          addq.w    #4,A7
00001A10  60EA      4294          bra       OS_TaskStat_1
                    4295   OS_TaskStat_3:
                    4296   ; }
                    4297   ; OSIdleCtrMax /= 100uL;
00001A12  2F12      4298          move.l    (A2),-(A7)
00001A14  4878 0064 4299          pea       100
00001A18  4EB9 0000 4300          jsr       ULDIV
00001A1C  64FC      
00001A1E  2497      4301          move.l    (A7),(A2)
00001A20  504F      4302          addq.w    #8,A7
                    4303   ; if (OSIdleCtrMax == 0uL) {
00001A22  2012      4304          move.l    (A2),D0
00001A24  6618      4305          bne.s     OS_TaskStat_4
                    4306   ; OSCPUUsage = 0u;
00001A26  4239 0800 4307          clr.b     _OSCPUUsage.L
00001A2A  0C14      
                    4308   ; #if OS_TASK_SUSPEND_EN > 0u
                    4309   ; (void)OSTaskSuspend(OS_PRIO_SELF);
00001A2C  4878 00FF 4310          pea       255
00001A30  4EB9 0000 4311          jsr       _OSTaskSuspend
00001A34  4E82      
00001A36  584F      4312          addq.w    #4,A7
00001A38  C0BC 0000 4313          and.l     #255,D0
00001A3C  00FF      
                    4314   OS_TaskStat_4:
                    4315   ; #else
                    4316   ; for (;;) {
                    4317   ; OSTimeDly(OS_TICKS_PER_SEC);
                    4318   ; }
                    4319   ; #endif
                    4320   ; }
                    4321   ; OS_ENTER_CRITICAL();
00001A3E  40E7      4322          dc.w      16615
00001A40  007C      4323          dc.w      124
00001A42  0700      4324          dc.w      1792
                    4325   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
00001A44  2F12      4326          move.l    (A2),-(A7)
00001A46  4878 0064 4327          pea       100
00001A4A  4EB9 0000 4328          jsr       ULMUL
00001A4E  645C      
00001A50  2017      4329          move.l    (A7),D0
00001A52  504F      4330          addq.w    #8,A7
00001A54  23C0 0800 4331          move.l    D0,_OSIdleCtr.L
00001A58  0D36      
                    4332   ; OS_EXIT_CRITICAL();
00001A5A  46DF      4333          dc.w      18143
                    4334   ; for (;;) {
                    4335   OS_TaskStat_6:
                    4336   ; OS_ENTER_CRITICAL();
00001A5C  40E7      4337          dc.w      16615
00001A5E  007C      4338          dc.w      124
00001A60  0700      4339          dc.w      1792
                    4340   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00001A62  23F9 0800 4341          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
00001A66  0D36 0800 
00001A6A  0C1A      
                    4342   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001A6C  42B9 0800 4343          clr.l     _OSIdleCtr.L
00001A70  0D36      
                    4344   ; OS_EXIT_CRITICAL();
00001A72  46DF      4345          dc.w      18143
                    4346   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
00001A74  7064      4347          moveq     #100,D0
00001A76  2F39 0800 4348          move.l    _OSIdleCtrRun.L,-(A7)
00001A7A  0C1A      
00001A7C  2F12      4349          move.l    (A2),-(A7)
00001A7E  4EB9 0000 4350          jsr       ULDIV
00001A82  64FC      
00001A84  2217      4351          move.l    (A7),D1
00001A86  504F      4352          addq.w    #8,A7
00001A88  9081      4353          sub.l     D1,D0
00001A8A  13C0 0800 4354          move.b    D0,_OSCPUUsage.L
00001A8E  0C14      
                    4355   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
00001A90  4EB8 0C0E 4356          jsr       _OSTaskStatHook
                    4357   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4358   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
00001A94  4EB9 0000 4359          jsr       _OS_TaskStatStkChk
00001A98  1AA8      
                    4360   ; #endif
                    4361   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00001A9A  4878 000A 4362          pea       10
00001A9E  4EB9 0000 4363          jsr       _OSTimeDly
00001AA2  510A      
00001AA4  584F      4364          addq.w    #4,A7
00001AA6  60B4      4365          bra       OS_TaskStat_6
                    4366   ; }
                    4367   ; }
                    4368   ; #endif
                    4369   ; /*$PAGE*/
                    4370   ; /*
                    4371   ; *********************************************************************************************************
                    4372   ; *                                        CHECK ALL TASK STACKS
                    4373   ; *
                    4374   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    4375   ; *
                    4376   ; * Arguments  : none
                    4377   ; *
                    4378   ; * Returns    : none
                    4379   ; *********************************************************************************************************
                    4380   ; */
                    4381   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    4382   ; void  OS_TaskStatStkChk (void)
                    4383   ; {
                    4384   _OS_TaskStatStkChk:
00001AA8  4E56 FFF4 4385          link      A6,#-12
00001AAC  48E7 3000 4386          movem.l   D2/D3,-(A7)
                    4387   ; OS_TCB      *ptcb;
                    4388   ; OS_STK_DATA  stk_data;
                    4389   ; INT8U        err;
                    4390   ; INT8U        prio;
                    4391   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
00001AB0  4203      4392          clr.b     D3
                    4393   OS_TaskStatStkChk_1:
00001AB2  0C03 003F 4394          cmp.b     #63,D3
00001AB6  6200 0068 4395          bhi       OS_TaskStatStkChk_3
                    4396   ; err = OSTaskStkChk(prio, &stk_data);
00001ABA  486E FFF6 4397          pea       -10(A6)
00001ABE  C6BC 0000 4398          and.l     #255,D3
00001AC2  00FF      
00001AC4  2F03      4399          move.l    D3,-(A7)
00001AC6  4EB9 0000 4400          jsr       _OSTaskStkChk
00001ACA  4DCA      
00001ACC  504F      4401          addq.w    #8,A7
00001ACE  1D40 FFFF 4402          move.b    D0,-1(A6)
                    4403   ; if (err == OS_ERR_NONE) {
00001AD2  102E FFFF 4404          move.b    -1(A6),D0
00001AD6  6600 0044 4405          bne       OS_TaskStatStkChk_8
                    4406   ; ptcb = OSTCBPrioTbl[prio];
00001ADA  C6BC 0000 4407          and.l     #255,D3
00001ADE  00FF      
00001AE0  2003      4408          move.l    D3,D0
00001AE2  E588      4409          lsl.l     #2,D0
00001AE4  41F9 0800 4410          lea       _OSTCBPrioTbl.L,A0
00001AE8  0E4A      
00001AEA  2430 0800 4411          move.l    0(A0,D0.L),D2
                    4412   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
00001AEE  4A82      4413          tst.l     D2
00001AF0  672A      4414          beq.s     OS_TaskStatStkChk_8
                    4415   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001AF2  0C82 0000 4416          cmp.l     #1,D2
00001AF6  0001      
00001AF8  6722      4417          beq.s     OS_TaskStatStkChk_8
                    4418   ; #if OS_TASK_PROFILE_EN > 0u
                    4419   ; #if OS_STK_GROWTH == 1u
                    4420   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001AFA  2042      4421          move.l    D2,A0
00001AFC  2028 0008 4422          move.l    8(A0),D0
00001B00  2042      4423          move.l    D2,A0
00001B02  2228 000C 4424          move.l    12(A0),D1
00001B06  E389      4425          lsl.l     #1,D1
00001B08  D081      4426          add.l     D1,D0
00001B0A  2042      4427          move.l    D2,A0
00001B0C  2140 0046 4428          move.l    D0,70(A0)
                    4429   ; #else
                    4430   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4431   ; #endif
                    4432   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
00001B10  41EE FFF6 4433          lea       -10(A6),A0
00001B14  2242      4434          move.l    D2,A1
00001B16  2368 0004 4435          move.l    4(A0),74(A1)
00001B1A  004A      
                    4436   OS_TaskStatStkChk_8:
00001B1C  5203      4437          addq.b    #1,D3
00001B1E  6092      4438          bra       OS_TaskStatStkChk_1
                    4439   OS_TaskStatStkChk_3:
00001B20  4CDF 000C 4440          movem.l   (A7)+,D2/D3
00001B24  4E5E      4441          unlk      A6
00001B26  4E75      4442          rts
                    4443   ; #endif
                    4444   ; }
                    4445   ; }
                    4446   ; }
                    4447   ; }
                    4448   ; }
                    4449   ; #endif
                    4450   ; /*$PAGE*/
                    4451   ; /*
                    4452   ; *********************************************************************************************************
                    4453   ; *                                           INITIALIZE TCB
                    4454   ; *
                    4455   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4456   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4457   ; *
                    4458   ; * Arguments  : prio          is the priority of the task being created
                    4459   ; *
                    4460   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4461   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4462   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4463   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4464   ; *                            specific.
                    4465   ; *
                    4466   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4467   ; *                            'OSTaskCreate()'.
                    4468   ; *
                    4469   ; *              id            is the task's ID (0..65535)
                    4470   ; *
                    4471   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4472   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4473   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4474   ; *                            units are established by the #define constant OS_STK which is CPU
                    4475   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4476   ; *
                    4477   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4478   ; *                            control block.  This allows you to store the contents of floating-point
                    4479   ; *                            registers, MMU registers or anything else you could find useful during a
                    4480   ; *                            context switch.  You can even assign a name to each task and store this name
                    4481   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4482   ; *
                    4483   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4484   ; *                            0 if called from 'OSTaskCreate()'.
                    4485   ; *
                    4486   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4487   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4488   ; *                                  be created.
                    4489   ; *
                    4490   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4491   ; *********************************************************************************************************
                    4492   ; */
                    4493   ; INT8U  OS_TCBInit (INT8U    prio,
                    4494   ; OS_STK  *ptos,
                    4495   ; OS_STK  *pbos,
                    4496   ; INT16U   id,
                    4497   ; INT32U   stk_size,
                    4498   ; void    *pext,
                    4499   ; INT16U   opt)
                    4500   ; {
                    4501   _OS_TCBInit:
00001B28  4E56 0000 4502          link      A6,#0
00001B2C  48E7 3820 4503          movem.l   D2/D3/D4/A2,-(A7)
00001B30  45F9 0800 4504          lea       _OSTCBList.L,A2
00001B34  0E46      
00001B36  182E 000B 4505          move.b    11(A6),D4
00001B3A  C8BC 0000 4506          and.l     #255,D4
00001B3E  00FF      
                    4507   ; OS_TCB    *ptcb;
                    4508   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4509   ; OS_CPU_SR  cpu_sr = 0u;
                    4510   ; #endif
                    4511   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4512   ; INT8U      i;
                    4513   ; #endif
                    4514   ; OS_ENTER_CRITICAL();
00001B40  40E7      4515          dc.w      16615
00001B42  007C      4516          dc.w      124
00001B44  0700      4517          dc.w      1792
                    4518   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001B46  2439 0800 4519          move.l    _OSTCBFreeList.L,D2
00001B4A  0E3E      
                    4520   ; if (ptcb != (OS_TCB *)0) {
00001B4C  4A82      4521          tst.l     D2
00001B4E  6700 017A 4522          beq       OS_TCBInit_1
                    4523   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00001B52  2042      4524          move.l    D2,A0
00001B54  23E8 0014 4525          move.l    20(A0),_OSTCBFreeList.L
00001B58  0800 0E3E 
                    4526   ; OS_EXIT_CRITICAL();
00001B5C  46DF      4527          dc.w      18143
                    4528   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00001B5E  2042      4529          move.l    D2,A0
00001B60  20AE 000C 4530          move.l    12(A6),(A0)
                    4531   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00001B64  2042      4532          move.l    D2,A0
00001B66  1144 0034 4533          move.b    D4,52(A0)
                    4534   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001B6A  2042      4535          move.l    D2,A0
00001B6C  4228 0032 4536          clr.b     50(A0)
                    4537   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00001B70  2042      4538          move.l    D2,A0
00001B72  4228 0033 4539          clr.b     51(A0)
                    4540   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001B76  2042      4541          move.l    D2,A0
00001B78  42A8 002E 4542          clr.l     46(A0)
                    4543   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4544   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001B7C  2042      4545          move.l    D2,A0
00001B7E  216E 001C 4546          move.l    28(A6),4(A0)
00001B82  0004      
                    4547   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00001B84  2042      4548          move.l    D2,A0
00001B86  216E 0018 4549          move.l    24(A6),12(A0)
00001B8A  000C      
                    4550   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001B8C  2042      4551          move.l    D2,A0
00001B8E  216E 0010 4552          move.l    16(A6),8(A0)
00001B92  0008      
                    4553   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00001B94  2042      4554          move.l    D2,A0
00001B96  316E 0022 4555          move.w    34(A6),16(A0)
00001B9A  0010      
                    4556   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001B9C  2042      4557          move.l    D2,A0
00001B9E  316E 0016 4558          move.w    22(A6),18(A0)
00001BA2  0012      
                    4559   ; #else
                    4560   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4561   ; stk_size                 = stk_size;
                    4562   ; pbos                     = pbos;
                    4563   ; opt                      = opt;
                    4564   ; id                       = id;
                    4565   ; #endif
                    4566   ; #if OS_TASK_DEL_EN > 0u
                    4567   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
00001BA4  2042      4568          move.l    D2,A0
00001BA6  4228 0039 4569          clr.b     57(A0)
                    4570   ; #endif
                    4571   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4572   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001BAA  1004      4573          move.b    D4,D0
00001BAC  E608      4574          lsr.b     #3,D0
00001BAE  2042      4575          move.l    D2,A0
00001BB0  1140 0036 4576          move.b    D0,54(A0)
                    4577   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00001BB4  1004      4578          move.b    D4,D0
00001BB6  C03C 0007 4579          and.b     #7,D0
00001BBA  2042      4580          move.l    D2,A0
00001BBC  1140 0035 4581          move.b    D0,53(A0)
                    4582   ; #else                                                             /* Pre-compute X, Y                  */
                    4583   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4584   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4585   ; #endif
                    4586   ; /* Pre-compute BitX and BitY         */
                    4587   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
00001BC0  7001      4588          moveq     #1,D0
00001BC2  2042      4589          move.l    D2,A0
00001BC4  1228 0036 4590          move.b    54(A0),D1
00001BC8  C2BC 0000 4591          and.l     #255,D1
00001BCC  00FF      
00001BCE  E3A8      4592          lsl.l     D1,D0
00001BD0  2042      4593          move.l    D2,A0
00001BD2  1140 0038 4594          move.b    D0,56(A0)
                    4595   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00001BD6  7001      4596          moveq     #1,D0
00001BD8  2042      4597          move.l    D2,A0
00001BDA  1228 0035 4598          move.b    53(A0),D1
00001BDE  C2BC 0000 4599          and.l     #255,D1
00001BE2  00FF      
00001BE4  E3A8      4600          lsl.l     D1,D0
00001BE6  2042      4601          move.l    D2,A0
00001BE8  1140 0037 4602          move.b    D0,55(A0)
                    4603   ; #if (OS_EVENT_EN)
                    4604   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
00001BEC  2042      4605          move.l    D2,A0
00001BEE  42A8 001C 4606          clr.l     28(A0)
                    4607   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4608   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
00001BF2  2042      4609          move.l    D2,A0
00001BF4  42A8 0020 4610          clr.l     32(A0)
                    4611   ; #endif
                    4612   ; #endif
                    4613   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4614   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00001BF8  2042      4615          move.l    D2,A0
00001BFA  42A8 0028 4616          clr.l     40(A0)
                    4617   ; #endif
                    4618   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4619   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00001BFE  2042      4620          move.l    D2,A0
00001C00  42A8 0024 4621          clr.l     36(A0)
                    4622   ; #endif
                    4623   ; #if OS_TASK_PROFILE_EN > 0u
                    4624   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00001C04  2042      4625          move.l    D2,A0
00001C06  42A8 003A 4626          clr.l     58(A0)
                    4627   ; ptcb->OSTCBCyclesStart = 0uL;
00001C0A  2042      4628          move.l    D2,A0
00001C0C  42A8 0042 4629          clr.l     66(A0)
                    4630   ; ptcb->OSTCBCyclesTot   = 0uL;
00001C10  2042      4631          move.l    D2,A0
00001C12  42A8 003E 4632          clr.l     62(A0)
                    4633   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
00001C16  2042      4634          move.l    D2,A0
00001C18  42A8 0046 4635          clr.l     70(A0)
                    4636   ; ptcb->OSTCBStkUsed     = 0uL;
00001C1C  2042      4637          move.l    D2,A0
00001C1E  42A8 004A 4638          clr.l     74(A0)
                    4639   ; #endif
                    4640   ; #if OS_TASK_NAME_EN > 0u
                    4641   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
00001C22  41F9 0000 4642          lea       @ucos_ii_1.L,A0
00001C26  6F2A      
00001C28  2242      4643          move.l    D2,A1
00001C2A  2348 004E 4644          move.l    A0,78(A1)
                    4645   ; #endif
                    4646   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4647   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00001C2E  4203      4648          clr.b     D3
                    4649   OS_TCBInit_3:
00001C30  0C03 0001 4650          cmp.b     #1,D3
00001C34  6416      4651          bhs.s     OS_TCBInit_5
                    4652   ; ptcb->OSTCBRegTbl[i] = 0u;
00001C36  2042      4653          move.l    D2,A0
00001C38  C6BC 0000 4654          and.l     #255,D3
00001C3C  00FF      
00001C3E  2003      4655          move.l    D3,D0
00001C40  E588      4656          lsl.l     #2,D0
00001C42  D1C0      4657          add.l     D0,A0
00001C44  42A8 0052 4658          clr.l     82(A0)
00001C48  5203      4659          addq.b    #1,D3
00001C4A  60E4      4660          bra       OS_TCBInit_3
                    4661   OS_TCBInit_5:
                    4662   ; }
                    4663   ; #endif
                    4664   ; OSTCBInitHook(ptcb);
00001C4C  2F02      4665          move.l    D2,-(A7)
00001C4E  4EB8 0C3C 4666          jsr       _OSTCBInitHook
00001C52  584F      4667          addq.w    #4,A7
                    4668   ; OS_ENTER_CRITICAL();
00001C54  40E7      4669          dc.w      16615
00001C56  007C      4670          dc.w      124
00001C58  0700      4671          dc.w      1792
                    4672   ; OSTCBPrioTbl[prio] = ptcb;
00001C5A  C8BC 0000 4673          and.l     #255,D4
00001C5E  00FF      
00001C60  2004      4674          move.l    D4,D0
00001C62  E588      4675          lsl.l     #2,D0
00001C64  41F9 0800 4676          lea       _OSTCBPrioTbl.L,A0
00001C68  0E4A      
00001C6A  2182 0800 4677          move.l    D2,0(A0,D0.L)
                    4678   ; OS_EXIT_CRITICAL();
00001C6E  46DF      4679          dc.w      18143
                    4680   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00001C70  2F02      4681          move.l    D2,-(A7)
00001C72  4EB8 0BF2 4682          jsr       _OSTaskCreateHook
00001C76  584F      4683          addq.w    #4,A7
                    4684   ; OS_ENTER_CRITICAL();
00001C78  40E7      4685          dc.w      16615
00001C7A  007C      4686          dc.w      124
00001C7C  0700      4687          dc.w      1792
                    4688   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00001C7E  2042      4689          move.l    D2,A0
00001C80  2152 0014 4690          move.l    (A2),20(A0)
                    4691   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
00001C84  2042      4692          move.l    D2,A0
00001C86  42A8 0018 4693          clr.l     24(A0)
                    4694   ; if (OSTCBList != (OS_TCB *)0) {
00001C8A  2012      4695          move.l    (A2),D0
00001C8C  6706      4696          beq.s     OS_TCBInit_6
                    4697   ; OSTCBList->OSTCBPrev = ptcb;
00001C8E  2052      4698          move.l    (A2),A0
00001C90  2142 0018 4699          move.l    D2,24(A0)
                    4700   OS_TCBInit_6:
                    4701   ; }
                    4702   ; OSTCBList               = ptcb;
00001C94  2482      4703          move.l    D2,(A2)
                    4704   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001C96  2042      4705          move.l    D2,A0
00001C98  1028 0038 4706          move.b    56(A0),D0
00001C9C  8139 0800 4707          or.b      D0,_OSRdyGrp.L
00001CA0  0D28      
                    4708   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00001CA2  2042      4709          move.l    D2,A0
00001CA4  1028 0036 4710          move.b    54(A0),D0
00001CA8  C0BC 0000 4711          and.l     #255,D0
00001CAC  00FF      
00001CAE  41F9 0800 4712          lea       _OSRdyTbl.L,A0
00001CB2  0D2A      
00001CB4  2242      4713          move.l    D2,A1
00001CB6  1229 0037 4714          move.b    55(A1),D1
00001CBA  8330 0800 4715          or.b      D1,0(A0,D0.L)
                    4716   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
00001CBE  5239 0800 4717          addq.b    #1,_OSTaskCtr.L
00001CC2  0D34      
                    4718   ; OS_EXIT_CRITICAL();
00001CC4  46DF      4719          dc.w      18143
                    4720   ; return (OS_ERR_NONE);
00001CC6  4200      4721          clr.b     D0
00001CC8  6004      4722          bra.s     OS_TCBInit_8
                    4723   OS_TCBInit_1:
                    4724   ; }
                    4725   ; OS_EXIT_CRITICAL();
00001CCA  46DF      4726          dc.w      18143
                    4727   ; return (OS_ERR_TASK_NO_MORE_TCB);
00001CCC  7042      4728          moveq     #66,D0
                    4729   OS_TCBInit_8:
00001CCE  4CDF 041C 4730          movem.l   (A7)+,D2/D3/D4/A2
00001CD2  4E5E      4731          unlk      A6
00001CD4  4E75      4732          rts
                    4733   ; /*
                    4734   ; *********************************************************************************************************
                    4735   ; *                                                uC/OS-II
                    4736   ; *                                          The Real-Time Kernel
                    4737   ; *                                         EVENT FLAG  MANAGEMENT
                    4738   ; *
                    4739   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4740   ; *                                           All Rights Reserved
                    4741   ; *
                    4742   ; * File    : OS_FLAG.C
                    4743   ; * By      : Jean J. Labrosse
                    4744   ; * Version : V2.92.07
                    4745   ; *
                    4746   ; * LICENSING TERMS:
                    4747   ; * ---------------
                    4748   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4749   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4750   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4751   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4752   ; * licensing fee.
                    4753   ; *********************************************************************************************************
                    4754   ; */
                    4755   ; #define  MICRIUM_SOURCE
                    4756   ; #ifndef  OS_MASTER_FILE
                    4757   ; #include <ucos_ii.h>
                    4758   ; #endif
                    4759   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4760   ; /*
                    4761   ; *********************************************************************************************************
                    4762   ; *                                          LOCAL PROTOTYPES
                    4763   ; *********************************************************************************************************
                    4764   ; */
                    4765   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4766   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4767   ; /*$PAGE*/
                    4768   ; /*
                    4769   ; *********************************************************************************************************
                    4770   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4771   ; *
                    4772   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4773   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4774   ; *              bits to be set/cleared.
                    4775   ; *
                    4776   ; *              This call does not block if the desired flags are not present.
                    4777   ; *
                    4778   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4779   ; *
                    4780   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4781   ; *                            The bits you want are specified by setting the corresponding bits in
                    4782   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4783   ; *                            'flags' would contain 0x03.
                    4784   ; *
                    4785   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4786   ; *                            to be set/cleared.
                    4787   ; *                            You can specify the following argument:
                    4788   ; *
                    4789   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4790   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4791   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4792   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4793   ; *
                    4794   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4795   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4796   ; *                                  the flags that are present, set 'wait_type' to:
                    4797   ; *
                    4798   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4799   ; *
                    4800   ; *              perr          is a pointer to an error code and can be:
                    4801   ; *                            OS_ERR_NONE               No error
                    4802   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4803   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4804   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4805   ; *                                                      group handle.
                    4806   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4807   ; *                                                      available.
                    4808   ; *
                    4809   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4810   ; *              occurred.
                    4811   ; *
                    4812   ; * Called from: Task or ISR
                    4813   ; *
                    4814   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4815   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4816   ; *                 event flags.
                    4817   ; *********************************************************************************************************
                    4818   ; */
                    4819   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4820   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4821   ; OS_FLAGS      flags,
                    4822   ; INT8U         wait_type,
                    4823   ; INT8U        *perr)
                    4824   ; {
                    4825   _OSFlagAccept:
00001CD6  4E56 FFFC 4826          link      A6,#-4
00001CDA  48E7 3F00 4827          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
00001CDE  262E 0008 4828          move.l    8(A6),D3
00001CE2  282E 0014 4829          move.l    20(A6),D4
00001CE6  3A2E 000E 4830          move.w    14(A6),D5
00001CEA  CABC 0000 4831          and.l     #65535,D5
00001CEE  FFFF      
00001CF0  1E2E 0013 4832          move.b    19(A6),D7
00001CF4  CEBC 0000 4833          and.l     #255,D7
00001CF8  00FF      
                    4834   ; OS_FLAGS      flags_rdy;
                    4835   ; INT8U         result;
                    4836   ; BOOLEAN       consume;
                    4837   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4838   ; OS_CPU_SR     cpu_sr = 0u;
                    4839   ; #endif
                    4840   ; #ifdef OS_SAFETY_CRITICAL
                    4841   ; if (perr == (INT8U *)0) {
                    4842   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4843   ; return ((OS_FLAGS)0);
                    4844   ; }
                    4845   ; #endif
                    4846   ; #if OS_ARG_CHK_EN > 0u
                    4847   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4848   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4849   ; return ((OS_FLAGS)0);
                    4850   ; }
                    4851   ; #endif
                    4852   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001CFA  2043      4853          move.l    D3,A0
00001CFC  1010      4854          move.b    (A0),D0
00001CFE  0C00 0005 4855          cmp.b     #5,D0
00001D02  670C      4856          beq.s     OSFlagAccept_1
                    4857   ; *perr = OS_ERR_EVENT_TYPE;
00001D04  2044      4858          move.l    D4,A0
00001D06  10BC 0001 4859          move.b    #1,(A0)
                    4860   ; return ((OS_FLAGS)0);
00001D0A  4240      4861          clr.w     D0
00001D0C  6000 0100 4862          bra       OSFlagAccept_3
                    4863   OSFlagAccept_1:
                    4864   ; }
                    4865   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001D10  1007      4866          move.b    D7,D0
00001D12  C03C 0080 4867          and.b     #128,D0
00001D16  1D40 FFFF 4868          move.b    D0,-1(A6)
                    4869   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001D1A  102E FFFF 4870          move.b    -1(A6),D0
00001D1E  6708      4871          beq.s     OSFlagAccept_4
                    4872   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
00001D20  CE3C 007F 4873          and.b     #127,D7
                    4874   ; consume    = OS_TRUE;
00001D24  7C01      4875          moveq     #1,D6
00001D26  6002      4876          bra.s     OSFlagAccept_5
                    4877   OSFlagAccept_4:
                    4878   ; } else {
                    4879   ; consume    = OS_FALSE;
00001D28  4206      4880          clr.b     D6
                    4881   OSFlagAccept_5:
                    4882   ; }
                    4883   ; /*$PAGE*/
                    4884   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
00001D2A  2044      4885          move.l    D4,A0
00001D2C  4210      4886          clr.b     (A0)
                    4887   ; OS_ENTER_CRITICAL();
00001D2E  40E7      4888          dc.w      16615
00001D30  007C      4889          dc.w      124
00001D32  0700      4890          dc.w      1792
                    4891   ; switch (wait_type) {
00001D34  CEBC 0000 4892          and.l     #255,D7
00001D38  00FF      
00001D3A  2007      4893          move.l    D7,D0
00001D3C  0C80 0000 4894          cmp.l     #4,D0
00001D40  0004      
00001D42  6400 00BE 4895          bhs       OSFlagAccept_6
00001D46  E380      4896          asl.l     #1,D0
00001D48  303B 0806 4897          move.w    OSFlagAccept_8(PC,D0.L),D0
00001D4C  4EFB 0002 4898          jmp       OSFlagAccept_8(PC,D0.W)
                    4899   OSFlagAccept_8:
00001D50  0060      4900          dc.w      OSFlagAccept_11-OSFlagAccept_8
00001D52  008A      4901          dc.w      OSFlagAccept_12-OSFlagAccept_8
00001D54  0008      4902          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001D56  0034      4903          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4904   OSFlagAccept_9:
                    4905   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4906   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001D58  2043      4907          move.l    D3,A0
00001D5A  3028 0006 4908          move.w    6(A0),D0
00001D5E  C045      4909          and.w     D5,D0
00001D60  3400      4910          move.w    D0,D2
                    4911   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001D62  B445      4912          cmp.w     D5,D2
00001D64  6612      4913          bne.s     OSFlagAccept_14
                    4914   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001D66  0C06 0001 4915          cmp.b     #1,D6
00001D6A  660A      4916          bne.s     OSFlagAccept_16
                    4917   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001D6C  2043      4918          move.l    D3,A0
00001D6E  3002      4919          move.w    D2,D0
00001D70  4640      4920          not.w     D0
00001D72  C168 0006 4921          and.w     D0,6(A0)
                    4922   OSFlagAccept_16:
00001D76  6006      4923          bra.s     OSFlagAccept_15
                    4924   OSFlagAccept_14:
                    4925   ; }
                    4926   ; } else {
                    4927   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001D78  2044      4928          move.l    D4,A0
00001D7A  10BC 0070 4929          move.b    #112,(A0)
                    4930   OSFlagAccept_15:
                    4931   ; }
                    4932   ; OS_EXIT_CRITICAL();
00001D7E  46DF      4933          dc.w      18143
                    4934   ; break;
00001D80  6000 008A 4935          bra       OSFlagAccept_7
                    4936   OSFlagAccept_10:
                    4937   ; case OS_FLAG_WAIT_SET_ANY:
                    4938   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001D84  2043      4939          move.l    D3,A0
00001D86  3028 0006 4940          move.w    6(A0),D0
00001D8A  C045      4941          and.w     D5,D0
00001D8C  3400      4942          move.w    D0,D2
                    4943   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001D8E  4A42      4944          tst.w     D2
00001D90  6712      4945          beq.s     OSFlagAccept_18
                    4946   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001D92  0C06 0001 4947          cmp.b     #1,D6
00001D96  660A      4948          bne.s     OSFlagAccept_20
                    4949   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001D98  2043      4950          move.l    D3,A0
00001D9A  3002      4951          move.w    D2,D0
00001D9C  4640      4952          not.w     D0
00001D9E  C168 0006 4953          and.w     D0,6(A0)
                    4954   OSFlagAccept_20:
00001DA2  6006      4955          bra.s     OSFlagAccept_19
                    4956   OSFlagAccept_18:
                    4957   ; }
                    4958   ; } else {
                    4959   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001DA4  2044      4960          move.l    D4,A0
00001DA6  10BC 0070 4961          move.b    #112,(A0)
                    4962   OSFlagAccept_19:
                    4963   ; }
                    4964   ; OS_EXIT_CRITICAL();
00001DAA  46DF      4965          dc.w      18143
                    4966   ; break;
00001DAC  6000 005E 4967          bra       OSFlagAccept_7
                    4968   OSFlagAccept_11:
                    4969   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4970   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4971   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001DB0  2043      4972          move.l    D3,A0
00001DB2  3028 0006 4973          move.w    6(A0),D0
00001DB6  4640      4974          not.w     D0
00001DB8  C045      4975          and.w     D5,D0
00001DBA  3400      4976          move.w    D0,D2
                    4977   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001DBC  B445      4978          cmp.w     D5,D2
00001DBE  660E      4979          bne.s     OSFlagAccept_22
                    4980   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001DC0  0C06 0001 4981          cmp.b     #1,D6
00001DC4  6606      4982          bne.s     OSFlagAccept_24
                    4983   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001DC6  2043      4984          move.l    D3,A0
00001DC8  8568 0006 4985          or.w      D2,6(A0)
                    4986   OSFlagAccept_24:
00001DCC  6006      4987          bra.s     OSFlagAccept_23
                    4988   OSFlagAccept_22:
                    4989   ; }
                    4990   ; } else {
                    4991   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001DCE  2044      4992          move.l    D4,A0
00001DD0  10BC 0070 4993          move.b    #112,(A0)
                    4994   OSFlagAccept_23:
                    4995   ; }
                    4996   ; OS_EXIT_CRITICAL();
00001DD4  46DF      4997          dc.w      18143
                    4998   ; break;
00001DD6  6000 0034 4999          bra       OSFlagAccept_7
                    5000   OSFlagAccept_12:
                    5001   ; case OS_FLAG_WAIT_CLR_ANY:
                    5002   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001DDA  2043      5003          move.l    D3,A0
00001DDC  3028 0006 5004          move.w    6(A0),D0
00001DE0  4640      5005          not.w     D0
00001DE2  C045      5006          and.w     D5,D0
00001DE4  3400      5007          move.w    D0,D2
                    5008   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001DE6  4A42      5009          tst.w     D2
00001DE8  670E      5010          beq.s     OSFlagAccept_26
                    5011   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001DEA  0C06 0001 5012          cmp.b     #1,D6
00001DEE  6606      5013          bne.s     OSFlagAccept_28
                    5014   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001DF0  2043      5015          move.l    D3,A0
00001DF2  8568 0006 5016          or.w      D2,6(A0)
                    5017   OSFlagAccept_28:
00001DF6  6006      5018          bra.s     OSFlagAccept_27
                    5019   OSFlagAccept_26:
                    5020   ; }
                    5021   ; } else {
                    5022   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001DF8  2044      5023          move.l    D4,A0
00001DFA  10BC 0070 5024          move.b    #112,(A0)
                    5025   OSFlagAccept_27:
                    5026   ; }
                    5027   ; OS_EXIT_CRITICAL();
00001DFE  46DF      5028          dc.w      18143
                    5029   ; break;
00001E00  600A      5030          bra.s     OSFlagAccept_7
                    5031   OSFlagAccept_6:
                    5032   ; #endif
                    5033   ; default:
                    5034   ; OS_EXIT_CRITICAL();
00001E02  46DF      5035          dc.w      18143
                    5036   ; flags_rdy = (OS_FLAGS)0;
00001E04  4242      5037          clr.w     D2
                    5038   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
00001E06  2044      5039          move.l    D4,A0
00001E08  10BC 006F 5040          move.b    #111,(A0)
                    5041   ; break;
                    5042   OSFlagAccept_7:
                    5043   ; }
                    5044   ; return (flags_rdy);
00001E0C  3002      5045          move.w    D2,D0
                    5046   OSFlagAccept_3:
00001E0E  4CDF 00FC 5047          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
00001E12  4E5E      5048          unlk      A6
00001E14  4E75      5049          rts
                    5050   ; }
                    5051   ; #endif
                    5052   ; /*$PAGE*/
                    5053   ; /*
                    5054   ; *********************************************************************************************************
                    5055   ; *                                        CREATE AN EVENT FLAG
                    5056   ; *
                    5057   ; * Description: This function is called to create an event flag group.
                    5058   ; *
                    5059   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    5060   ; *
                    5061   ; *              perr          is a pointer to an error code which will be returned to your application:
                    5062   ; *                               OS_ERR_NONE               if the call was successful.
                    5063   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    5064   ; *                                                         ISR.
                    5065   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    5066   ; *
                    5067   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    5068   ; *
                    5069   ; * Called from: Task ONLY
                    5070   ; *********************************************************************************************************
                    5071   ; */
                    5072   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    5073   ; INT8U    *perr)
                    5074   ; {
                    5075   _OSFlagCreate:
00001E16  4E56 0000 5076          link      A6,#0
00001E1A  48E7 3020 5077          movem.l   D2/D3/A2,-(A7)
00001E1E  45F9 0800 5078          lea       _OSFlagFreeList.L,A2
00001E22  0C10      
00001E24  262E 000C 5079          move.l    12(A6),D3
                    5080   ; OS_FLAG_GRP *pgrp;
                    5081   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    5082   ; OS_CPU_SR    cpu_sr = 0u;
                    5083   ; #endif
                    5084   ; #ifdef OS_SAFETY_CRITICAL
                    5085   ; if (perr == (INT8U *)0) {
                    5086   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5087   ; return ((OS_FLAG_GRP *)0);
                    5088   ; }
                    5089   ; #endif
                    5090   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    5091   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    5092   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5093   ; return ((OS_FLAG_GRP *)0);
                    5094   ; }
                    5095   ; #endif
                    5096   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001E28  1039 0800 5097          move.b    _OSIntNesting.L,D0
00001E2C  0D20      
00001E2E  0C00 0000 5098          cmp.b     #0,D0
00001E32  630C      5099          bls.s     OSFlagCreate_1
                    5100   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
00001E34  2043      5101          move.l    D3,A0
00001E36  10BC 0010 5102          move.b    #16,(A0)
                    5103   ; return ((OS_FLAG_GRP *)0);
00001E3A  4280      5104          clr.l     D0
00001E3C  6000 0046 5105          bra       OSFlagCreate_3
                    5106   OSFlagCreate_1:
                    5107   ; }
                    5108   ; OS_ENTER_CRITICAL();
00001E40  40E7      5109          dc.w      16615
00001E42  007C      5110          dc.w      124
00001E44  0700      5111          dc.w      1792
                    5112   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001E46  2412      5113          move.l    (A2),D2
                    5114   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001E48  4A82      5115          tst.l     D2
00001E4A  672E      5116          beq.s     OSFlagCreate_4
                    5117   ; /* Adjust free list                                */
                    5118   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001E4C  2052      5119          move.l    (A2),A0
00001E4E  24A8 0002 5120          move.l    2(A0),(A2)
                    5121   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
00001E52  2042      5122          move.l    D2,A0
00001E54  10BC 0005 5123          move.b    #5,(A0)
                    5124   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001E58  2042      5125          move.l    D2,A0
00001E5A  316E 000A 5126          move.w    10(A6),6(A0)
00001E5E  0006      
                    5127   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
00001E60  2042      5128          move.l    D2,A0
00001E62  42A8 0002 5129          clr.l     2(A0)
                    5130   ; #if OS_FLAG_NAME_EN > 0u
                    5131   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001E66  41F9 0000 5132          lea       @ucos_ii_1.L,A0
00001E6A  6F2A      
00001E6C  2242      5133          move.l    D2,A1
00001E6E  2348 0008 5134          move.l    A0,8(A1)
                    5135   ; #endif
                    5136   ; OS_EXIT_CRITICAL();
00001E72  46DF      5137          dc.w      18143
                    5138   ; *perr                = OS_ERR_NONE;
00001E74  2043      5139          move.l    D3,A0
00001E76  4210      5140          clr.b     (A0)
00001E78  6008      5141          bra.s     OSFlagCreate_5
                    5142   OSFlagCreate_4:
                    5143   ; } else {
                    5144   ; OS_EXIT_CRITICAL();
00001E7A  46DF      5145          dc.w      18143
                    5146   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001E7C  2043      5147          move.l    D3,A0
00001E7E  10BC 0072 5148          move.b    #114,(A0)
                    5149   OSFlagCreate_5:
                    5150   ; }
                    5151   ; return (pgrp);                                  /* Return pointer to event flag group              */
00001E82  2002      5152          move.l    D2,D0
                    5153   OSFlagCreate_3:
00001E84  4CDF 040C 5154          movem.l   (A7)+,D2/D3/A2
00001E88  4E5E      5155          unlk      A6
00001E8A  4E75      5156          rts
                    5157   ; }
                    5158   ; /*$PAGE*/
                    5159   ; /*
                    5160   ; *********************************************************************************************************
                    5161   ; *                                     DELETE AN EVENT FLAG GROUP
                    5162   ; *
                    5163   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    5164   ; *              group.
                    5165   ; *
                    5166   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5167   ; *
                    5168   ; *              opt           determines delete options as follows:
                    5169   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    5170   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    5171   ; *                                                    waiting.  In this case, all the tasks pending will be
                    5172   ; *                                                    readied.
                    5173   ; *
                    5174   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    5175   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    5176   ; *                                                      deleted
                    5177   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    5178   ; *                                                      an ISR
                    5179   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5180   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    5181   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    5182   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    5183   ; *                                                      group.
                    5184   ; *
                    5185   ; * Returns    : pgrp          upon error
                    5186   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    5187   ; *
                    5188   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    5189   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    5190   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    5191   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    5192   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    5193   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    5194   ; *********************************************************************************************************
                    5195   ; */
                    5196   ; #if OS_FLAG_DEL_EN > 0u
                    5197   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    5198   ; INT8U         opt,
                    5199   ; INT8U        *perr)
                    5200   ; {
                    5201   _OSFlagDel:
00001E8C  4E56 0000 5202          link      A6,#0
00001E90  48E7 3E20 5203          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
00001E94  242E 0008 5204          move.l    8(A6),D2
00001E98  262E 0010 5205          move.l    16(A6),D3
00001E9C  45F9 0800 5206          lea       _OSFlagFreeList.L,A2
00001EA0  0C10      
                    5207   ; BOOLEAN       tasks_waiting;
                    5208   ; OS_FLAG_NODE *pnode;
                    5209   ; OS_FLAG_GRP  *pgrp_return;
                    5210   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5211   ; OS_CPU_SR     cpu_sr = 0u;
                    5212   ; #endif
                    5213   ; #ifdef OS_SAFETY_CRITICAL
                    5214   ; if (perr == (INT8U *)0) {
                    5215   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5216   ; return ((OS_FLAG_GRP *)0);
                    5217   ; }
                    5218   ; #endif
                    5219   ; #if OS_ARG_CHK_EN > 0u
                    5220   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5221   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5222   ; return (pgrp);
                    5223   ; }
                    5224   ; #endif
                    5225   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001EA2  1039 0800 5226          move.b    _OSIntNesting.L,D0
00001EA6  0D20      
00001EA8  0C00 0000 5227          cmp.b     #0,D0
00001EAC  630C      5228          bls.s     OSFlagDel_1
                    5229   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001EAE  2043      5230          move.l    D3,A0
00001EB0  10BC 000F 5231          move.b    #15,(A0)
                    5232   ; return (pgrp);
00001EB4  2002      5233          move.l    D2,D0
00001EB6  6000 00EC 5234          bra       OSFlagDel_3
                    5235   OSFlagDel_1:
                    5236   ; }
                    5237   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
00001EBA  2042      5238          move.l    D2,A0
00001EBC  1010      5239          move.b    (A0),D0
00001EBE  0C00 0005 5240          cmp.b     #5,D0
00001EC2  670C      5241          beq.s     OSFlagDel_4
                    5242   ; *perr = OS_ERR_EVENT_TYPE;
00001EC4  2043      5243          move.l    D3,A0
00001EC6  10BC 0001 5244          move.b    #1,(A0)
                    5245   ; return (pgrp);
00001ECA  2002      5246          move.l    D2,D0
00001ECC  6000 00D6 5247          bra       OSFlagDel_3
                    5248   OSFlagDel_4:
                    5249   ; }
                    5250   ; OS_ENTER_CRITICAL();
00001ED0  40E7      5251          dc.w      16615
00001ED2  007C      5252          dc.w      124
00001ED4  0700      5253          dc.w      1792
                    5254   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
00001ED6  2042      5255          move.l    D2,A0
00001ED8  2028 0002 5256          move.l    2(A0),D0
00001EDC  6704      5257          beq.s     OSFlagDel_6
                    5258   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00001EDE  7C01      5259          moveq     #1,D6
00001EE0  6002      5260          bra.s     OSFlagDel_7
                    5261   OSFlagDel_6:
                    5262   ; } else {
                    5263   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00001EE2  4206      5264          clr.b     D6
                    5265   OSFlagDel_7:
                    5266   ; }
                    5267   ; switch (opt) {
00001EE4  102E 000F 5268          move.b    15(A6),D0
00001EE8  C0BC 0000 5269          and.l     #255,D0
00001EEC  00FF      
00001EEE  0C80 0000 5270          cmp.l     #1,D0
00001EF2  0001      
00001EF4  6700 0048 5271          beq       OSFlagDel_11
00001EF8  6200 009E 5272          bhi       OSFlagDel_8
00001EFC  4A80      5273          tst.l     D0
00001EFE  6704      5274          beq.s     OSFlagDel_10
00001F00  6000 0096 5275          bra       OSFlagDel_8
                    5276   OSFlagDel_10:
                    5277   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    5278   ; if (tasks_waiting == OS_FALSE) {
00001F04  4A06      5279          tst.b     D6
00001F06  6628      5280          bne.s     OSFlagDel_13
                    5281   ; #if OS_FLAG_NAME_EN > 0u
                    5282   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001F08  41F9 0000 5283          lea       @ucos_ii_1.L,A0
00001F0C  6F2A      
00001F0E  2242      5284          move.l    D2,A1
00001F10  2348 0008 5285          move.l    A0,8(A1)
                    5286   ; #endif
                    5287   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001F14  2042      5288          move.l    D2,A0
00001F16  4210      5289          clr.b     (A0)
                    5290   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
00001F18  2042      5291          move.l    D2,A0
00001F1A  2152 0002 5292          move.l    (A2),2(A0)
                    5293   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001F1E  2042      5294          move.l    D2,A0
00001F20  4268 0006 5295          clr.w     6(A0)
                    5296   ; OSFlagFreeList       = pgrp;
00001F24  2482      5297          move.l    D2,(A2)
                    5298   ; OS_EXIT_CRITICAL();
00001F26  46DF      5299          dc.w      18143
                    5300   ; *perr                = OS_ERR_NONE;
00001F28  2043      5301          move.l    D3,A0
00001F2A  4210      5302          clr.b     (A0)
                    5303   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00001F2C  4285      5304          clr.l     D5
00001F2E  600A      5305          bra.s     OSFlagDel_14
                    5306   OSFlagDel_13:
                    5307   ; } else {
                    5308   ; OS_EXIT_CRITICAL();
00001F30  46DF      5309          dc.w      18143
                    5310   ; *perr                = OS_ERR_TASK_WAITING;
00001F32  2043      5311          move.l    D3,A0
00001F34  10BC 0049 5312          move.b    #73,(A0)
                    5313   ; pgrp_return          = pgrp;
00001F38  2A02      5314          move.l    D2,D5
                    5315   OSFlagDel_14:
                    5316   ; }
                    5317   ; break;
00001F3A  6000 0066 5318          bra       OSFlagDel_9
                    5319   OSFlagDel_11:
                    5320   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    5321   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001F3E  2042      5322          move.l    D2,A0
00001F40  2828 0002 5323          move.l    2(A0),D4
                    5324   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    5325   OSFlagDel_15:
00001F44  4A84      5326          tst.l     D4
00001F46  671E      5327          beq.s     OSFlagDel_17
                    5328   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
00001F48  4878 0002 5329          pea       2
00001F4C  42A7      5330          clr.l     -(A7)
00001F4E  2F04      5331          move.l    D4,-(A7)
00001F50  4EB9 0000 5332          jsr       @ucos_ii_OS_FlagTaskRdy
00001F54  26C2      
00001F56  DEFC 000C 5333          add.w     #12,A7
00001F5A  C0BC 0000 5334          and.l     #255,D0
00001F5E  00FF      
                    5335   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00001F60  2044      5336          move.l    D4,A0
00001F62  2810      5337          move.l    (A0),D4
00001F64  60DE      5338          bra       OSFlagDel_15
                    5339   OSFlagDel_17:
                    5340   ; }
                    5341   ; #if OS_FLAG_NAME_EN > 0u
                    5342   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001F66  41F9 0000 5343          lea       @ucos_ii_1.L,A0
00001F6A  6F2A      
00001F6C  2242      5344          move.l    D2,A1
00001F6E  2348 0008 5345          move.l    A0,8(A1)
                    5346   ; #endif
                    5347   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001F72  2042      5348          move.l    D2,A0
00001F74  4210      5349          clr.b     (A0)
                    5350   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
00001F76  2042      5351          move.l    D2,A0
00001F78  2152 0002 5352          move.l    (A2),2(A0)
                    5353   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001F7C  2042      5354          move.l    D2,A0
00001F7E  4268 0006 5355          clr.w     6(A0)
                    5356   ; OSFlagFreeList       = pgrp;
00001F82  2482      5357          move.l    D2,(A2)
                    5358   ; OS_EXIT_CRITICAL();
00001F84  46DF      5359          dc.w      18143
                    5360   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00001F86  0C06 0001 5361          cmp.b     #1,D6
00001F8A  6604      5362          bne.s     OSFlagDel_18
                    5363   ; OS_Sched();                               /* Find highest priority task ready to run  */
00001F8C  4EB8 190E 5364          jsr       _OS_Sched
                    5365   OSFlagDel_18:
                    5366   ; }
                    5367   ; *perr = OS_ERR_NONE;
00001F90  2043      5368          move.l    D3,A0
00001F92  4210      5369          clr.b     (A0)
                    5370   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
00001F94  4285      5371          clr.l     D5
                    5372   ; break;
00001F96  600A      5373          bra.s     OSFlagDel_9
                    5374   OSFlagDel_8:
                    5375   ; default:
                    5376   ; OS_EXIT_CRITICAL();
00001F98  46DF      5377          dc.w      18143
                    5378   ; *perr                = OS_ERR_INVALID_OPT;
00001F9A  2043      5379          move.l    D3,A0
00001F9C  10BC 0007 5380          move.b    #7,(A0)
                    5381   ; pgrp_return          = pgrp;
00001FA0  2A02      5382          move.l    D2,D5
                    5383   ; break;
                    5384   OSFlagDel_9:
                    5385   ; }
                    5386   ; return (pgrp_return);
00001FA2  2005      5387          move.l    D5,D0
                    5388   OSFlagDel_3:
00001FA4  4CDF 047C 5389          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001FA8  4E5E      5390          unlk      A6
00001FAA  4E75      5391          rts
                    5392   ; }
                    5393   ; #endif
                    5394   ; /*$PAGE*/
                    5395   ; /*
                    5396   ; *********************************************************************************************************
                    5397   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    5398   ; *
                    5399   ; * Description: This function is used to obtain the name assigned to an event flag group
                    5400   ; *
                    5401   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5402   ; *
                    5403   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5404   ; *                        group.
                    5405   ; *
                    5406   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5407   ; *
                    5408   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5409   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5410   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5411   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5412   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5413   ; *
                    5414   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5415   ; *********************************************************************************************************
                    5416   ; */
                    5417   ; #if OS_FLAG_NAME_EN > 0u
                    5418   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5419   ; INT8U        **pname,
                    5420   ; INT8U         *perr)
                    5421   ; {
                    5422   _OSFlagNameGet:
00001FAC  4E56 FFFC 5423          link      A6,#-4
00001FB0  2F02      5424          move.l    D2,-(A7)
00001FB2  242E 0010 5425          move.l    16(A6),D2
                    5426   ; INT8U      len;
                    5427   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5428   ; OS_CPU_SR  cpu_sr = 0u;
                    5429   ; #endif
                    5430   ; #ifdef OS_SAFETY_CRITICAL
                    5431   ; if (perr == (INT8U *)0) {
                    5432   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5433   ; return (0u);
                    5434   ; }
                    5435   ; #endif
                    5436   ; #if OS_ARG_CHK_EN > 0u
                    5437   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5438   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5439   ; return (0u);
                    5440   ; }
                    5441   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5442   ; *perr = OS_ERR_PNAME_NULL;
                    5443   ; return (0u);
                    5444   ; }
                    5445   ; #endif
                    5446   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001FB6  1039 0800 5447          move.b    _OSIntNesting.L,D0
00001FBA  0D20      
00001FBC  0C00 0000 5448          cmp.b     #0,D0
00001FC0  630C      5449          bls.s     OSFlagNameGet_1
                    5450   ; *perr = OS_ERR_NAME_GET_ISR;
00001FC2  2042      5451          move.l    D2,A0
00001FC4  10BC 0011 5452          move.b    #17,(A0)
                    5453   ; return (0u);
00001FC8  4200      5454          clr.b     D0
00001FCA  6000 0046 5455          bra       OSFlagNameGet_3
                    5456   OSFlagNameGet_1:
                    5457   ; }
                    5458   ; OS_ENTER_CRITICAL();
00001FCE  40E7      5459          dc.w      16615
00001FD0  007C      5460          dc.w      124
00001FD2  0700      5461          dc.w      1792
                    5462   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001FD4  206E 0008 5463          move.l    8(A6),A0
00001FD8  1010      5464          move.b    (A0),D0
00001FDA  0C00 0005 5465          cmp.b     #5,D0
00001FDE  670C      5466          beq.s     OSFlagNameGet_4
                    5467   ; OS_EXIT_CRITICAL();
00001FE0  46DF      5468          dc.w      18143
                    5469   ; *perr = OS_ERR_EVENT_TYPE;
00001FE2  2042      5470          move.l    D2,A0
00001FE4  10BC 0001 5471          move.b    #1,(A0)
                    5472   ; return (0u);
00001FE8  4200      5473          clr.b     D0
00001FEA  6026      5474          bra.s     OSFlagNameGet_3
                    5475   OSFlagNameGet_4:
                    5476   ; }
                    5477   ; *pname = pgrp->OSFlagName;
00001FEC  206E 0008 5478          move.l    8(A6),A0
00001FF0  226E 000C 5479          move.l    12(A6),A1
00001FF4  22A8 0008 5480          move.l    8(A0),(A1)
                    5481   ; len    = OS_StrLen(*pname);
00001FF8  206E 000C 5482          move.l    12(A6),A0
00001FFC  2F10      5483          move.l    (A0),-(A7)
00001FFE  4EB8 19B8 5484          jsr       _OS_StrLen
00002002  584F      5485          addq.w    #4,A7
00002004  1D40 FFFF 5486          move.b    D0,-1(A6)
                    5487   ; OS_EXIT_CRITICAL();
00002008  46DF      5488          dc.w      18143
                    5489   ; *perr  = OS_ERR_NONE;
0000200A  2042      5490          move.l    D2,A0
0000200C  4210      5491          clr.b     (A0)
                    5492   ; return (len);
0000200E  102E FFFF 5493          move.b    -1(A6),D0
                    5494   OSFlagNameGet_3:
00002012  241F      5495          move.l    (A7)+,D2
00002014  4E5E      5496          unlk      A6
00002016  4E75      5497          rts
                    5498   ; }
                    5499   ; #endif
                    5500   ; /*$PAGE*/
                    5501   ; /*
                    5502   ; *********************************************************************************************************
                    5503   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5504   ; *
                    5505   ; * Description: This function assigns a name to an event flag group.
                    5506   ; *
                    5507   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5508   ; *
                    5509   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5510   ; *                        group.
                    5511   ; *
                    5512   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5513   ; *
                    5514   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5515   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5516   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5517   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5518   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5519   ; *
                    5520   ; * Returns    : None
                    5521   ; *********************************************************************************************************
                    5522   ; */
                    5523   ; #if OS_FLAG_NAME_EN > 0u
                    5524   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5525   ; INT8U        *pname,
                    5526   ; INT8U        *perr)
                    5527   ; {
                    5528   _OSFlagNameSet:
00002018  4E56 0000 5529          link      A6,#0
0000201C  2F02      5530          move.l    D2,-(A7)
0000201E  242E 0010 5531          move.l    16(A6),D2
                    5532   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5533   ; OS_CPU_SR  cpu_sr = 0u;
                    5534   ; #endif
                    5535   ; #ifdef OS_SAFETY_CRITICAL
                    5536   ; if (perr == (INT8U *)0) {
                    5537   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5538   ; return;
                    5539   ; }
                    5540   ; #endif
                    5541   ; #if OS_ARG_CHK_EN > 0u
                    5542   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5543   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5544   ; return;
                    5545   ; }
                    5546   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5547   ; *perr = OS_ERR_PNAME_NULL;
                    5548   ; return;
                    5549   ; }
                    5550   ; #endif
                    5551   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002022  1039 0800 5552          move.b    _OSIntNesting.L,D0
00002026  0D20      
00002028  0C00 0000 5553          cmp.b     #0,D0
0000202C  630A      5554          bls.s     OSFlagNameSet_1
                    5555   ; *perr = OS_ERR_NAME_SET_ISR;
0000202E  2042      5556          move.l    D2,A0
00002030  10BC 0012 5557          move.b    #18,(A0)
                    5558   ; return;
00002034  6000 002E 5559          bra       OSFlagNameSet_3
                    5560   OSFlagNameSet_1:
                    5561   ; }
                    5562   ; OS_ENTER_CRITICAL();
00002038  40E7      5563          dc.w      16615
0000203A  007C      5564          dc.w      124
0000203C  0700      5565          dc.w      1792
                    5566   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
0000203E  206E 0008 5567          move.l    8(A6),A0
00002042  1010      5568          move.b    (A0),D0
00002044  0C00 0005 5569          cmp.b     #5,D0
00002048  670A      5570          beq.s     OSFlagNameSet_4
                    5571   ; OS_EXIT_CRITICAL();
0000204A  46DF      5572          dc.w      18143
                    5573   ; *perr = OS_ERR_EVENT_TYPE;
0000204C  2042      5574          move.l    D2,A0
0000204E  10BC 0001 5575          move.b    #1,(A0)
                    5576   ; return;
00002052  6010      5577          bra.s     OSFlagNameSet_3
                    5578   OSFlagNameSet_4:
                    5579   ; }
                    5580   ; pgrp->OSFlagName = pname;
00002054  206E 0008 5581          move.l    8(A6),A0
00002058  216E 000C 5582          move.l    12(A6),8(A0)
0000205C  0008      
                    5583   ; OS_EXIT_CRITICAL();
0000205E  46DF      5584          dc.w      18143
                    5585   ; *perr            = OS_ERR_NONE;
00002060  2042      5586          move.l    D2,A0
00002062  4210      5587          clr.b     (A0)
                    5588   ; return;
                    5589   OSFlagNameSet_3:
00002064  241F      5590          move.l    (A7)+,D2
00002066  4E5E      5591          unlk      A6
00002068  4E75      5592          rts
                    5593   ; }
                    5594   ; #endif
                    5595   ; /*$PAGE*/
                    5596   ; /*
                    5597   ; *********************************************************************************************************
                    5598   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5599   ; *
                    5600   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5601   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5602   ; *
                    5603   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5604   ; *
                    5605   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5606   ; *                            The bits you want are specified by setting the corresponding bits in
                    5607   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5608   ; *                            'flags' would contain 0x03.
                    5609   ; *
                    5610   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5611   ; *                            You can specify the following argument:
                    5612   ; *
                    5613   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5614   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5615   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5616   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5617   ; *
                    5618   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5619   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5620   ; *                                  the flags that are present, set 'wait_type' to:
                    5621   ; *
                    5622   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5623   ; *
                    5624   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5625   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5626   ; *                            forever at the specified event flag group or, until a message arrives.
                    5627   ; *
                    5628   ; *              perr          is a pointer to an error code and can be:
                    5629   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5630   ; *                                                      'timeout'.
                    5631   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5632   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5633   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5634   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5635   ; *                                                      'timeout'.
                    5636   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5637   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5638   ; *
                    5639   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5640   ; *              occurred.
                    5641   ; *
                    5642   ; * Called from: Task ONLY
                    5643   ; *
                    5644   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5645   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5646   ; *                 event flags.
                    5647   ; *********************************************************************************************************
                    5648   ; */
                    5649   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5650   ; OS_FLAGS      flags,
                    5651   ; INT8U         wait_type,
                    5652   ; INT32U        timeout,
                    5653   ; INT8U        *perr)
                    5654   ; {
                    5655   _OSFlagPend:
0000206A  4E56 FFE8 5656          link      A6,#-24
0000206E  48E7 3F3C 5657          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002072  262E 0008 5658          move.l    8(A6),D3
00002076  282E 0018 5659          move.l    24(A6),D4
0000207A  3A2E 000E 5660          move.w    14(A6),D5
0000207E  CABC 0000 5661          and.l     #65535,D5
00002082  FFFF      
00002084  45F9 0800 5662          lea       _OSTCBCur.L,A2
00002088  0E3A      
0000208A  1C2E 0013 5663          move.b    19(A6),D6
0000208E  CCBC 0000 5664          and.l     #255,D6
00002092  00FF      
00002094  47EE FFEA 5665          lea       -22(A6),A3
00002098  286E 0014 5666          move.l    20(A6),A4
0000209C  4BF9 0000 5667          lea       @ucos_ii_OS_FlagBlock.L,A5
000020A0  2564      
                    5668   ; OS_FLAG_NODE  node;
                    5669   ; OS_FLAGS      flags_rdy;
                    5670   ; INT8U         result;
                    5671   ; INT8U         pend_stat;
                    5672   ; BOOLEAN       consume;
                    5673   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5674   ; OS_CPU_SR     cpu_sr = 0u;
                    5675   ; #endif
                    5676   ; #ifdef OS_SAFETY_CRITICAL
                    5677   ; if (perr == (INT8U *)0) {
                    5678   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5679   ; return ((OS_FLAGS)0);
                    5680   ; }
                    5681   ; #endif
                    5682   ; #if OS_ARG_CHK_EN > 0u
                    5683   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5684   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5685   ; return ((OS_FLAGS)0);
                    5686   ; }
                    5687   ; #endif
                    5688   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000020A2  1039 0800 5689          move.b    _OSIntNesting.L,D0
000020A6  0D20      
000020A8  0C00 0000 5690          cmp.b     #0,D0
000020AC  630C      5691          bls.s     OSFlagPend_1
                    5692   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000020AE  2044      5693          move.l    D4,A0
000020B0  10BC 0002 5694          move.b    #2,(A0)
                    5695   ; return ((OS_FLAGS)0);
000020B4  4240      5696          clr.w     D0
000020B6  6000 028A 5697          bra       OSFlagPend_3
                    5698   OSFlagPend_1:
                    5699   ; }
                    5700   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
000020BA  1039 0800 5701          move.b    _OSLockNesting.L,D0
000020BE  0D22      
000020C0  0C00 0000 5702          cmp.b     #0,D0
000020C4  630C      5703          bls.s     OSFlagPend_4
                    5704   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
000020C6  2044      5705          move.l    D4,A0
000020C8  10BC 000D 5706          move.b    #13,(A0)
                    5707   ; return ((OS_FLAGS)0);
000020CC  4240      5708          clr.w     D0
000020CE  6000 0272 5709          bra       OSFlagPend_3
                    5710   OSFlagPend_4:
                    5711   ; }
                    5712   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000020D2  2043      5713          move.l    D3,A0
000020D4  1010      5714          move.b    (A0),D0
000020D6  0C00 0005 5715          cmp.b     #5,D0
000020DA  670C      5716          beq.s     OSFlagPend_6
                    5717   ; *perr = OS_ERR_EVENT_TYPE;
000020DC  2044      5718          move.l    D4,A0
000020DE  10BC 0001 5719          move.b    #1,(A0)
                    5720   ; return ((OS_FLAGS)0);
000020E2  4240      5721          clr.w     D0
000020E4  6000 025C 5722          bra       OSFlagPend_3
                    5723   OSFlagPend_6:
                    5724   ; }
                    5725   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
000020E8  1006      5726          move.b    D6,D0
000020EA  C03C 0080 5727          and.b     #128,D0
000020EE  1D40 FFFE 5728          move.b    D0,-2(A6)
                    5729   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
000020F2  102E FFFE 5730          move.b    -2(A6),D0
000020F6  670C      5731          beq.s     OSFlagPend_8
                    5732   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
000020F8  103C 0080 5733          move.b    #128,D0
000020FC  4600      5734          not.b     D0
000020FE  CC00      5735          and.b     D0,D6
                    5736   ; consume    = OS_TRUE;
00002100  7E01      5737          moveq     #1,D7
00002102  6002      5738          bra.s     OSFlagPend_9
                    5739   OSFlagPend_8:
                    5740   ; } else {
                    5741   ; consume    = OS_FALSE;
00002104  7E00      5742          moveq     #0,D7
                    5743   OSFlagPend_9:
                    5744   ; }
                    5745   ; /*$PAGE*/
                    5746   ; OS_ENTER_CRITICAL();
00002106  40E7      5747          dc.w      16615
00002108  007C      5748          dc.w      124
0000210A  0700      5749          dc.w      1792
                    5750   ; switch (wait_type) {
0000210C  CCBC 0000 5751          and.l     #255,D6
00002110  00FF      
00002112  2006      5752          move.l    D6,D0
00002114  0C80 0000 5753          cmp.l     #4,D0
00002118  0004      
0000211A  6400 0156 5754          bhs       OSFlagPend_10
0000211E  E380      5755          asl.l     #1,D0
00002120  303B 0806 5756          move.w    OSFlagPend_12(PC,D0.L),D0
00002124  4EFB 0002 5757          jmp       OSFlagPend_12(PC,D0.W)
                    5758   OSFlagPend_12:
00002128  00AC      5759          dc.w      OSFlagPend_15-OSFlagPend_12
0000212A  00FC      5760          dc.w      OSFlagPend_16-OSFlagPend_12
0000212C  0008      5761          dc.w      OSFlagPend_13-OSFlagPend_12
0000212E  005A      5762          dc.w      OSFlagPend_14-OSFlagPend_12
                    5763   OSFlagPend_13:
                    5764   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5765   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00002130  2043      5766          move.l    D3,A0
00002132  3028 0006 5767          move.w    6(A0),D0
00002136  C045      5768          and.w     D5,D0
00002138  3400      5769          move.w    D0,D2
                    5770   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
0000213A  B445      5771          cmp.w     D5,D2
0000213C  6622      5772          bne.s     OSFlagPend_18
                    5773   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
0000213E  0C07 0001 5774          cmp.b     #1,D7
00002142  660A      5775          bne.s     OSFlagPend_20
                    5776   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
00002144  2043      5777          move.l    D3,A0
00002146  3002      5778          move.w    D2,D0
00002148  4640      5779          not.w     D0
0000214A  C168 0006 5780          and.w     D0,6(A0)
                    5781   OSFlagPend_20:
                    5782   ; }
                    5783   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
0000214E  2052      5784          move.l    (A2),A0
00002150  3142 002C 5785          move.w    D2,44(A0)
                    5786   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00002154  46DF      5787          dc.w      18143
                    5788   ; *perr                   = OS_ERR_NONE;
00002156  2044      5789          move.l    D4,A0
00002158  4210      5790          clr.b     (A0)
                    5791   ; return (flags_rdy);
0000215A  3002      5792          move.w    D2,D0
0000215C  6000 01E4 5793          bra       OSFlagPend_3
                    5794   OSFlagPend_18:
                    5795   ; } else {                                      /* Block task until events occur or timeout */
                    5796   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002160  2F0C      5797          move.l    A4,-(A7)
00002162  CCBC 0000 5798          and.l     #255,D6
00002166  00FF      
00002168  2F06      5799          move.l    D6,-(A7)
0000216A  CABC 0000 5800          and.l     #65535,D5
0000216E  FFFF      
00002170  2F05      5801          move.l    D5,-(A7)
00002172  2F0B      5802          move.l    A3,-(A7)
00002174  2F03      5803          move.l    D3,-(A7)
00002176  4E95      5804          jsr       (A5)
00002178  DEFC 0014 5805          add.w     #20,A7
                    5806   ; OS_EXIT_CRITICAL();
0000217C  46DF      5807          dc.w      18143
                    5808   ; }
                    5809   ; break;
0000217E  6000 0102 5810          bra       OSFlagPend_11
                    5811   OSFlagPend_14:
                    5812   ; case OS_FLAG_WAIT_SET_ANY:
                    5813   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
00002182  2043      5814          move.l    D3,A0
00002184  3028 0006 5815          move.w    6(A0),D0
00002188  C045      5816          and.w     D5,D0
0000218A  3400      5817          move.w    D0,D2
                    5818   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
0000218C  4A42      5819          tst.w     D2
0000218E  6722      5820          beq.s     OSFlagPend_22
                    5821   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002190  0C07 0001 5822          cmp.b     #1,D7
00002194  660A      5823          bne.s     OSFlagPend_24
                    5824   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
00002196  2043      5825          move.l    D3,A0
00002198  3002      5826          move.w    D2,D0
0000219A  4640      5827          not.w     D0
0000219C  C168 0006 5828          and.w     D0,6(A0)
                    5829   OSFlagPend_24:
                    5830   ; }
                    5831   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
000021A0  2052      5832          move.l    (A2),A0
000021A2  3142 002C 5833          move.w    D2,44(A0)
                    5834   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
000021A6  46DF      5835          dc.w      18143
                    5836   ; *perr                   = OS_ERR_NONE;
000021A8  2044      5837          move.l    D4,A0
000021AA  4210      5838          clr.b     (A0)
                    5839   ; return (flags_rdy);
000021AC  3002      5840          move.w    D2,D0
000021AE  6000 0192 5841          bra       OSFlagPend_3
                    5842   OSFlagPend_22:
                    5843   ; } else {                                      /* Block task until events occur or timeout */
                    5844   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
000021B2  2F0C      5845          move.l    A4,-(A7)
000021B4  CCBC 0000 5846          and.l     #255,D6
000021B8  00FF      
000021BA  2F06      5847          move.l    D6,-(A7)
000021BC  CABC 0000 5848          and.l     #65535,D5
000021C0  FFFF      
000021C2  2F05      5849          move.l    D5,-(A7)
000021C4  2F0B      5850          move.l    A3,-(A7)
000021C6  2F03      5851          move.l    D3,-(A7)
000021C8  4E95      5852          jsr       (A5)
000021CA  DEFC 0014 5853          add.w     #20,A7
                    5854   ; OS_EXIT_CRITICAL();
000021CE  46DF      5855          dc.w      18143
                    5856   ; }
                    5857   ; break;
000021D0  6000 00B0 5858          bra       OSFlagPend_11
                    5859   OSFlagPend_15:
                    5860   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5861   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5862   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
000021D4  2043      5863          move.l    D3,A0
000021D6  3028 0006 5864          move.w    6(A0),D0
000021DA  4640      5865          not.w     D0
000021DC  C045      5866          and.w     D5,D0
000021DE  3400      5867          move.w    D0,D2
                    5868   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
000021E0  B445      5869          cmp.w     D5,D2
000021E2  661E      5870          bne.s     OSFlagPend_26
                    5871   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000021E4  0C07 0001 5872          cmp.b     #1,D7
000021E8  6606      5873          bne.s     OSFlagPend_28
                    5874   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
000021EA  2043      5875          move.l    D3,A0
000021EC  8568 0006 5876          or.w      D2,6(A0)
                    5877   OSFlagPend_28:
                    5878   ; }
                    5879   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
000021F0  2052      5880          move.l    (A2),A0
000021F2  3142 002C 5881          move.w    D2,44(A0)
                    5882   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
000021F6  46DF      5883          dc.w      18143
                    5884   ; *perr                   = OS_ERR_NONE;
000021F8  2044      5885          move.l    D4,A0
000021FA  4210      5886          clr.b     (A0)
                    5887   ; return (flags_rdy);
000021FC  3002      5888          move.w    D2,D0
000021FE  6000 0142 5889          bra       OSFlagPend_3
                    5890   OSFlagPend_26:
                    5891   ; } else {                                      /* Block task until events occur or timeout */
                    5892   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002202  2F0C      5893          move.l    A4,-(A7)
00002204  CCBC 0000 5894          and.l     #255,D6
00002208  00FF      
0000220A  2F06      5895          move.l    D6,-(A7)
0000220C  CABC 0000 5896          and.l     #65535,D5
00002210  FFFF      
00002212  2F05      5897          move.l    D5,-(A7)
00002214  2F0B      5898          move.l    A3,-(A7)
00002216  2F03      5899          move.l    D3,-(A7)
00002218  4E95      5900          jsr       (A5)
0000221A  DEFC 0014 5901          add.w     #20,A7
                    5902   ; OS_EXIT_CRITICAL();
0000221E  46DF      5903          dc.w      18143
                    5904   ; }
                    5905   ; break;
00002220  6000 0060 5906          bra       OSFlagPend_11
                    5907   OSFlagPend_16:
                    5908   ; case OS_FLAG_WAIT_CLR_ANY:
                    5909   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00002224  2043      5910          move.l    D3,A0
00002226  3028 0006 5911          move.w    6(A0),D0
0000222A  4640      5912          not.w     D0
0000222C  C045      5913          and.w     D5,D0
0000222E  3400      5914          move.w    D0,D2
                    5915   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00002230  4A42      5916          tst.w     D2
00002232  671E      5917          beq.s     OSFlagPend_30
                    5918   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00002234  0C07 0001 5919          cmp.b     #1,D7
00002238  6606      5920          bne.s     OSFlagPend_32
                    5921   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
0000223A  2043      5922          move.l    D3,A0
0000223C  8568 0006 5923          or.w      D2,6(A0)
                    5924   OSFlagPend_32:
                    5925   ; }
                    5926   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00002240  2052      5927          move.l    (A2),A0
00002242  3142 002C 5928          move.w    D2,44(A0)
                    5929   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00002246  46DF      5930          dc.w      18143
                    5931   ; *perr                   = OS_ERR_NONE;
00002248  2044      5932          move.l    D4,A0
0000224A  4210      5933          clr.b     (A0)
                    5934   ; return (flags_rdy);
0000224C  3002      5935          move.w    D2,D0
0000224E  6000 00F2 5936          bra       OSFlagPend_3
                    5937   OSFlagPend_30:
                    5938   ; } else {                                      /* Block task until events occur or timeout */
                    5939   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00002252  2F0C      5940          move.l    A4,-(A7)
00002254  CCBC 0000 5941          and.l     #255,D6
00002258  00FF      
0000225A  2F06      5942          move.l    D6,-(A7)
0000225C  CABC 0000 5943          and.l     #65535,D5
00002260  FFFF      
00002262  2F05      5944          move.l    D5,-(A7)
00002264  2F0B      5945          move.l    A3,-(A7)
00002266  2F03      5946          move.l    D3,-(A7)
00002268  4E95      5947          jsr       (A5)
0000226A  DEFC 0014 5948          add.w     #20,A7
                    5949   ; OS_EXIT_CRITICAL();
0000226E  46DF      5950          dc.w      18143
                    5951   ; }
                    5952   ; break;
00002270  6010      5953          bra.s     OSFlagPend_11
                    5954   OSFlagPend_10:
                    5955   ; #endif
                    5956   ; default:
                    5957   ; OS_EXIT_CRITICAL();
00002272  46DF      5958          dc.w      18143
                    5959   ; flags_rdy = (OS_FLAGS)0;
00002274  4242      5960          clr.w     D2
                    5961   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
00002276  2044      5962          move.l    D4,A0
00002278  10BC 006F 5963          move.b    #111,(A0)
                    5964   ; return (flags_rdy);
0000227C  3002      5965          move.w    D2,D0
0000227E  6000 00C2 5966          bra       OSFlagPend_3
                    5967   OSFlagPend_11:
                    5968   ; }
                    5969   ; /*$PAGE*/
                    5970   ; OS_Sched();                                            /* Find next HPT ready to run               */
00002282  4EB8 190E 5971          jsr       _OS_Sched
                    5972   ; OS_ENTER_CRITICAL();
00002286  40E7      5973          dc.w      16615
00002288  007C      5974          dc.w      124
0000228A  0700      5975          dc.w      1792
                    5976   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
0000228C  2052      5977          move.l    (A2),A0
0000228E  1028 0033 5978          move.b    51(A0),D0
00002292  6700 0056 5979          beq       OSFlagPend_34
                    5980   ; pend_stat                = OSTCBCur->OSTCBStatPend;
00002296  2052      5981          move.l    (A2),A0
00002298  1D68 0033 5982          move.b    51(A0),-1(A6)
0000229C  FFFF      
                    5983   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0000229E  2052      5984          move.l    (A2),A0
000022A0  4228 0033 5985          clr.b     51(A0)
                    5986   ; OS_FlagUnlink(&node);
000022A4  2F0B      5987          move.l    A3,-(A7)
000022A6  4EB9 0000 5988          jsr       _OS_FlagUnlink
000022AA  273E      
000022AC  584F      5989          addq.w    #4,A7
                    5990   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
000022AE  2052      5991          move.l    (A2),A0
000022B0  4228 0032 5992          clr.b     50(A0)
                    5993   ; OS_EXIT_CRITICAL();
000022B4  46DF      5994          dc.w      18143
                    5995   ; flags_rdy                = (OS_FLAGS)0;
000022B6  4242      5996          clr.w     D2
                    5997   ; switch (pend_stat) {
000022B8  102E FFFF 5998          move.b    -1(A6),D0
000022BC  C0BC 0000 5999          and.l     #255,D0
000022C0  00FF      
000022C2  0C80 0000 6000          cmp.l     #2,D0
000022C6  0002      
000022C8  670C      6001          beq.s     OSFlagPend_38
000022CA  6212      6002          bhi.s     OSFlagPend_39
000022CC  0C80 0000 6003          cmp.l     #1,D0
000022D0  0001      
000022D2  670A      6004          beq.s     OSFlagPend_39
000022D4  6008      6005          bra.s     OSFlagPend_39
                    6006   OSFlagPend_38:
                    6007   ; case OS_STAT_PEND_ABORT:
                    6008   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
000022D6  2044      6009          move.l    D4,A0
000022D8  10BC 000E 6010          move.b    #14,(A0)
                    6011   ; break;
000022DC  6006      6012          bra.s     OSFlagPend_37
                    6013   OSFlagPend_39:
                    6014   ; case OS_STAT_PEND_TO:
                    6015   ; default:
                    6016   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
000022DE  2044      6017          move.l    D4,A0
000022E0  10BC 000A 6018          move.b    #10,(A0)
                    6019   ; break;
                    6020   OSFlagPend_37:
                    6021   ; }
                    6022   ; return (flags_rdy);
000022E4  3002      6023          move.w    D2,D0
000022E6  6000 005A 6024          bra       OSFlagPend_3
                    6025   OSFlagPend_34:
                    6026   ; }
                    6027   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
000022EA  2052      6028          move.l    (A2),A0
000022EC  3428 002C 6029          move.w    44(A0),D2
                    6030   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
000022F0  0C07 0001 6031          cmp.b     #1,D7
000022F4  6600 0044 6032          bne       OSFlagPend_44
                    6033   ; switch (wait_type) {
000022F8  CCBC 0000 6034          and.l     #255,D6
000022FC  00FF      
000022FE  2006      6035          move.l    D6,D0
00002300  0C80 0000 6036          cmp.l     #4,D0
00002304  0004      
00002306  6426      6037          bhs.s     OSFlagPend_43
00002308  E380      6038          asl.l     #1,D0
0000230A  303B 0806 6039          move.w    OSFlagPend_45(PC,D0.L),D0
0000230E  4EFB 0002 6040          jmp       OSFlagPend_45(PC,D0.W)
                    6041   OSFlagPend_45:
00002312  0014      6042          dc.w      OSFlagPend_48-OSFlagPend_45
00002314  0014      6043          dc.w      OSFlagPend_48-OSFlagPend_45
00002316  0008      6044          dc.w      OSFlagPend_46-OSFlagPend_45
00002318  0008      6045          dc.w      OSFlagPend_46-OSFlagPend_45
                    6046   OSFlagPend_46:
                    6047   ; case OS_FLAG_WAIT_SET_ALL:
                    6048   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    6049   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
0000231A  2043      6050          move.l    D3,A0
0000231C  3002      6051          move.w    D2,D0
0000231E  4640      6052          not.w     D0
00002320  C168 0006 6053          and.w     D0,6(A0)
                    6054   ; break;
00002324  6014      6055          bra.s     OSFlagPend_44
                    6056   OSFlagPend_48:
                    6057   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6058   ; case OS_FLAG_WAIT_CLR_ALL:
                    6059   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    6060   ; pgrp->OSFlagFlags |=  flags_rdy;
00002326  2043      6061          move.l    D3,A0
00002328  8568 0006 6062          or.w      D2,6(A0)
                    6063   ; break;
0000232C  600C      6064          bra.s     OSFlagPend_44
                    6065   OSFlagPend_43:
                    6066   ; #endif
                    6067   ; default:
                    6068   ; OS_EXIT_CRITICAL();
0000232E  46DF      6069          dc.w      18143
                    6070   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00002330  2044      6071          move.l    D4,A0
00002332  10BC 006F 6072          move.b    #111,(A0)
                    6073   ; return ((OS_FLAGS)0);
00002336  4240      6074          clr.w     D0
00002338  6008      6075          bra.s     OSFlagPend_3
                    6076   OSFlagPend_44:
                    6077   ; }
                    6078   ; }
                    6079   ; OS_EXIT_CRITICAL();
0000233A  46DF      6080          dc.w      18143
                    6081   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
0000233C  2044      6082          move.l    D4,A0
0000233E  4210      6083          clr.b     (A0)
                    6084   ; return (flags_rdy);
00002340  3002      6085          move.w    D2,D0
                    6086   OSFlagPend_3:
00002342  4CDF 3CFC 6087          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002346  4E5E      6088          unlk      A6
00002348  4E75      6089          rts
                    6090   ; }
                    6091   ; /*$PAGE*/
                    6092   ; /*
                    6093   ; *********************************************************************************************************
                    6094   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    6095   ; *
                    6096   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    6097   ; *              In other words, this function allows you to tell "Who done it!".
                    6098   ; *
                    6099   ; * Arguments  : None
                    6100   ; *
                    6101   ; * Returns    : The flags that caused the task to be ready.
                    6102   ; *
                    6103   ; * Called from: Task ONLY
                    6104   ; *********************************************************************************************************
                    6105   ; */
                    6106   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    6107   ; {
                    6108   _OSFlagPendGetFlagsRdy:
0000234A  4E56 FFFC 6109          link      A6,#-4
                    6110   ; OS_FLAGS      flags;
                    6111   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6112   ; OS_CPU_SR     cpu_sr = 0u;
                    6113   ; #endif
                    6114   ; OS_ENTER_CRITICAL();
0000234E  40E7      6115          dc.w      16615
00002350  007C      6116          dc.w      124
00002352  0700      6117          dc.w      1792
                    6118   ; flags = OSTCBCur->OSTCBFlagsRdy;
00002354  2079 0800 6119          move.l    _OSTCBCur.L,A0
00002358  0E3A      
0000235A  3D68 002C 6120          move.w    44(A0),-2(A6)
0000235E  FFFE      
                    6121   ; OS_EXIT_CRITICAL();
00002360  46DF      6122          dc.w      18143
                    6123   ; return (flags);
00002362  302E FFFE 6124          move.w    -2(A6),D0
00002366  4E5E      6125          unlk      A6
00002368  4E75      6126          rts
                    6127   ; }
                    6128   ; /*$PAGE*/
                    6129   ; /*
                    6130   ; *********************************************************************************************************
                    6131   ; *                                       POST EVENT FLAG BIT(S)
                    6132   ; *
                    6133   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    6134   ; *              set or clear are specified by a 'bit mask'.
                    6135   ; *
                    6136   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6137   ; *
                    6138   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    6139   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    6140   ; *                            and 5 you would set 'flags' to:
                    6141   ; *
                    6142   ; *                                0x31     (note, bit 0 is least significant bit)
                    6143   ; *
                    6144   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    6145   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    6146   ; *                            4 and 5 you would specify 'flags' as:
                    6147   ; *
                    6148   ; *                                0x31     (note, bit 0 is least significant bit)
                    6149   ; *
                    6150   ; *              opt           indicates whether the flags will be:
                    6151   ; *                                set     (OS_FLAG_SET) or
                    6152   ; *                                cleared (OS_FLAG_CLR)
                    6153   ; *
                    6154   ; *              perr          is a pointer to an error code and can be:
                    6155   ; *                            OS_ERR_NONE                The call was successfull
                    6156   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6157   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6158   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    6159   ; *
                    6160   ; * Returns    : the new value of the event flags bits that are still set.
                    6161   ; *
                    6162   ; * Called From: Task or ISR
                    6163   ; *
                    6164   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    6165   ; *                 flag group.
                    6166   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    6167   ; *                 the event flag group.
                    6168   ; *********************************************************************************************************
                    6169   ; */
                    6170   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    6171   ; OS_FLAGS      flags,
                    6172   ; INT8U         opt,
                    6173   ; INT8U        *perr)
                    6174   ; {
                    6175   _OSFlagPost:
0000236A  4E56 FFFC 6176          link      A6,#-4
0000236E  48E7 3F20 6177          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002372  282E 0008 6178          move.l    8(A6),D4
00002376  45F9 0000 6179          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
0000237A  26C2      
0000237C  2E2E 0014 6180          move.l    20(A6),D7
                    6181   ; OS_FLAG_NODE *pnode;
                    6182   ; BOOLEAN       sched;
                    6183   ; OS_FLAGS      flags_cur;
                    6184   ; OS_FLAGS      flags_rdy;
                    6185   ; BOOLEAN       rdy;
                    6186   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    6187   ; OS_CPU_SR     cpu_sr = 0u;
                    6188   ; #endif
                    6189   ; #ifdef OS_SAFETY_CRITICAL
                    6190   ; if (perr == (INT8U *)0) {
                    6191   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6192   ; return ((OS_FLAGS)0);
                    6193   ; }
                    6194   ; #endif
                    6195   ; #if OS_ARG_CHK_EN > 0u
                    6196   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    6197   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6198   ; return ((OS_FLAGS)0);
                    6199   ; }
                    6200   ; #endif
                    6201   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00002380  2044      6202          move.l    D4,A0
00002382  1010      6203          move.b    (A0),D0
00002384  0C00 0005 6204          cmp.b     #5,D0
00002388  670C      6205          beq.s     OSFlagPost_1
                    6206   ; *perr = OS_ERR_EVENT_TYPE;
0000238A  2047      6207          move.l    D7,A0
0000238C  10BC 0001 6208          move.b    #1,(A0)
                    6209   ; return ((OS_FLAGS)0);
00002390  4240      6210          clr.w     D0
00002392  6000 018C 6211          bra       OSFlagPost_3
                    6212   OSFlagPost_1:
                    6213   ; }
                    6214   ; /*$PAGE*/
                    6215   ; OS_ENTER_CRITICAL();
00002396  40E7      6216          dc.w      16615
00002398  007C      6217          dc.w      124
0000239A  0700      6218          dc.w      1792
                    6219   ; switch (opt) {
0000239C  102E 0013 6220          move.b    19(A6),D0
000023A0  C0BC 0000 6221          and.l     #255,D0
000023A4  00FF      
000023A6  0C80 0000 6222          cmp.l     #1,D0
000023AA  0001      
000023AC  6716      6223          beq.s     OSFlagPost_7
000023AE  6220      6224          bhi.s     OSFlagPost_4
000023B0  4A80      6225          tst.l     D0
000023B2  6702      6226          beq.s     OSFlagPost_6
000023B4  601A      6227          bra.s     OSFlagPost_4
                    6228   OSFlagPost_6:
                    6229   ; case OS_FLAG_CLR:
                    6230   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
000023B6  2044      6231          move.l    D4,A0
000023B8  302E 000E 6232          move.w    14(A6),D0
000023BC  4640      6233          not.w     D0
000023BE  C168 0006 6234          and.w     D0,6(A0)
                    6235   ; break;
000023C2  601A      6236          bra.s     OSFlagPost_5
                    6237   OSFlagPost_7:
                    6238   ; case OS_FLAG_SET:
                    6239   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
000023C4  2044      6240          move.l    D4,A0
000023C6  302E 000E 6241          move.w    14(A6),D0
000023CA  8168 0006 6242          or.w      D0,6(A0)
                    6243   ; break;
000023CE  600E      6244          bra.s     OSFlagPost_5
                    6245   OSFlagPost_4:
                    6246   ; default:
                    6247   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
000023D0  46DF      6248          dc.w      18143
                    6249   ; *perr = OS_ERR_FLAG_INVALID_OPT;
000023D2  2047      6250          move.l    D7,A0
000023D4  10BC 0071 6251          move.b    #113,(A0)
                    6252   ; return ((OS_FLAGS)0);
000023D8  4240      6253          clr.w     D0
000023DA  6000 0144 6254          bra       OSFlagPost_3
                    6255   OSFlagPost_5:
                    6256   ; }
                    6257   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
000023DE  4206      6258          clr.b     D6
                    6259   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000023E0  2044      6260          move.l    D4,A0
000023E2  2428 0002 6261          move.l    2(A0),D2
                    6262   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    6263   OSFlagPost_9:
000023E6  4A82      6264          tst.l     D2
000023E8  6700 0112 6265          beq       OSFlagPost_11
                    6266   ; switch (pnode->OSFlagNodeWaitType) {
000023EC  2042      6267          move.l    D2,A0
000023EE  1028 0012 6268          move.b    18(A0),D0
000023F2  C0BC 0000 6269          and.l     #255,D0
000023F6  00FF      
000023F8  0C80 0000 6270          cmp.l     #4,D0
000023FC  0004      
000023FE  6400 00E6 6271          bhs       OSFlagPost_12
00002402  E380      6272          asl.l     #1,D0
00002404  303B 0806 6273          move.w    OSFlagPost_14(PC,D0.L),D0
00002408  4EFB 0002 6274          jmp       OSFlagPost_14(PC,D0.W)
                    6275   OSFlagPost_14:
0000240C  0070      6276          dc.w      OSFlagPost_17-OSFlagPost_14
0000240E  00A8      6277          dc.w      OSFlagPost_18-OSFlagPost_14
00002410  0008      6278          dc.w      OSFlagPost_15-OSFlagPost_14
00002412  003E      6279          dc.w      OSFlagPost_16-OSFlagPost_14
                    6280   OSFlagPost_15:
                    6281   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    6282   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00002414  2044      6283          move.l    D4,A0
00002416  3028 0006 6284          move.w    6(A0),D0
0000241A  2042      6285          move.l    D2,A0
0000241C  C068 0010 6286          and.w     16(A0),D0
00002420  3600      6287          move.w    D0,D3
                    6288   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00002422  2042      6289          move.l    D2,A0
00002424  B668 0010 6290          cmp.w     16(A0),D3
00002428  661C      6291          bne.s     OSFlagPost_22
                    6292   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
0000242A  42A7      6293          clr.l     -(A7)
0000242C  C6BC 0000 6294          and.l     #65535,D3
00002430  FFFF      
00002432  2F03      6295          move.l    D3,-(A7)
00002434  2F02      6296          move.l    D2,-(A7)
00002436  4E92      6297          jsr       (A2)
00002438  DEFC 000C 6298          add.w     #12,A7
0000243C  1A00      6299          move.b    D0,D5
                    6300   ; if (rdy == OS_TRUE) {
0000243E  0C05 0001 6301          cmp.b     #1,D5
00002442  6602      6302          bne.s     OSFlagPost_22
                    6303   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002444  7C01      6304          moveq     #1,D6
                    6305   OSFlagPost_22:
                    6306   ; }
                    6307   ; }
                    6308   ; break;
00002446  6000 00AC 6309          bra       OSFlagPost_13
                    6310   OSFlagPost_16:
                    6311   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    6312   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
0000244A  2044      6313          move.l    D4,A0
0000244C  3028 0006 6314          move.w    6(A0),D0
00002450  2042      6315          move.l    D2,A0
00002452  C068 0010 6316          and.w     16(A0),D0
00002456  3600      6317          move.w    D0,D3
                    6318   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00002458  4A43      6319          tst.w     D3
0000245A  671C      6320          beq.s     OSFlagPost_26
                    6321   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
0000245C  42A7      6322          clr.l     -(A7)
0000245E  C6BC 0000 6323          and.l     #65535,D3
00002462  FFFF      
00002464  2F03      6324          move.l    D3,-(A7)
00002466  2F02      6325          move.l    D2,-(A7)
00002468  4E92      6326          jsr       (A2)
0000246A  DEFC 000C 6327          add.w     #12,A7
0000246E  1A00      6328          move.b    D0,D5
                    6329   ; if (rdy == OS_TRUE) {
00002470  0C05 0001 6330          cmp.b     #1,D5
00002474  6602      6331          bne.s     OSFlagPost_26
                    6332   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00002476  7C01      6333          moveq     #1,D6
                    6334   OSFlagPost_26:
                    6335   ; }
                    6336   ; }
                    6337   ; break;
00002478  6000 007A 6338          bra       OSFlagPost_13
                    6339   OSFlagPost_17:
                    6340   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    6341   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    6342   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
0000247C  2044      6343          move.l    D4,A0
0000247E  3028 0006 6344          move.w    6(A0),D0
00002482  4640      6345          not.w     D0
00002484  2042      6346          move.l    D2,A0
00002486  C068 0010 6347          and.w     16(A0),D0
0000248A  3600      6348          move.w    D0,D3
                    6349   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
0000248C  2042      6350          move.l    D2,A0
0000248E  B668 0010 6351          cmp.w     16(A0),D3
00002492  661C      6352          bne.s     OSFlagPost_30
                    6353   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00002494  42A7      6354          clr.l     -(A7)
00002496  C6BC 0000 6355          and.l     #65535,D3
0000249A  FFFF      
0000249C  2F03      6356          move.l    D3,-(A7)
0000249E  2F02      6357          move.l    D2,-(A7)
000024A0  4E92      6358          jsr       (A2)
000024A2  DEFC 000C 6359          add.w     #12,A7
000024A6  1A00      6360          move.b    D0,D5
                    6361   ; if (rdy == OS_TRUE) {
000024A8  0C05 0001 6362          cmp.b     #1,D5
000024AC  6602      6363          bne.s     OSFlagPost_30
                    6364   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000024AE  7C01      6365          moveq     #1,D6
                    6366   OSFlagPost_30:
                    6367   ; }
                    6368   ; }
                    6369   ; break;
000024B0  6000 0042 6370          bra       OSFlagPost_13
                    6371   OSFlagPost_18:
                    6372   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    6373   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
000024B4  2044      6374          move.l    D4,A0
000024B6  3028 0006 6375          move.w    6(A0),D0
000024BA  4640      6376          not.w     D0
000024BC  2042      6377          move.l    D2,A0
000024BE  C068 0010 6378          and.w     16(A0),D0
000024C2  3600      6379          move.w    D0,D3
                    6380   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
000024C4  4A43      6381          tst.w     D3
000024C6  671C      6382          beq.s     OSFlagPost_34
                    6383   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
000024C8  42A7      6384          clr.l     -(A7)
000024CA  C6BC 0000 6385          and.l     #65535,D3
000024CE  FFFF      
000024D0  2F03      6386          move.l    D3,-(A7)
000024D2  2F02      6387          move.l    D2,-(A7)
000024D4  4E92      6388          jsr       (A2)
000024D6  DEFC 000C 6389          add.w     #12,A7
000024DA  1A00      6390          move.b    D0,D5
                    6391   ; if (rdy == OS_TRUE) {
000024DC  0C05 0001 6392          cmp.b     #1,D5
000024E0  6602      6393          bne.s     OSFlagPost_34
                    6394   ; sched = OS_TRUE;                     /* When done we will reschedule          */
000024E2  7C01      6395          moveq     #1,D6
                    6396   OSFlagPost_34:
                    6397   ; }
                    6398   ; }
                    6399   ; break;
000024E4  600E      6400          bra.s     OSFlagPost_13
                    6401   OSFlagPost_12:
                    6402   ; #endif
                    6403   ; default:
                    6404   ; OS_EXIT_CRITICAL();
000024E6  46DF      6405          dc.w      18143
                    6406   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
000024E8  2047      6407          move.l    D7,A0
000024EA  10BC 006F 6408          move.b    #111,(A0)
                    6409   ; return ((OS_FLAGS)0);
000024EE  4240      6410          clr.w     D0
000024F0  6000 002E 6411          bra       OSFlagPost_3
                    6412   OSFlagPost_13:
                    6413   ; }
                    6414   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
000024F4  2042      6415          move.l    D2,A0
000024F6  2410      6416          move.l    (A0),D2
000024F8  6000 FEEC 6417          bra       OSFlagPost_9
                    6418   OSFlagPost_11:
                    6419   ; }
                    6420   ; OS_EXIT_CRITICAL();
000024FC  46DF      6421          dc.w      18143
                    6422   ; if (sched == OS_TRUE) {
000024FE  0C06 0001 6423          cmp.b     #1,D6
00002502  6604      6424          bne.s     OSFlagPost_36
                    6425   ; OS_Sched();
00002504  4EB8 190E 6426          jsr       _OS_Sched
                    6427   OSFlagPost_36:
                    6428   ; }
                    6429   ; OS_ENTER_CRITICAL();
00002508  40E7      6430          dc.w      16615
0000250A  007C      6431          dc.w      124
0000250C  0700      6432          dc.w      1792
                    6433   ; flags_cur = pgrp->OSFlagFlags;
0000250E  2044      6434          move.l    D4,A0
00002510  3D68 0006 6435          move.w    6(A0),-2(A6)
00002514  FFFE      
                    6436   ; OS_EXIT_CRITICAL();
00002516  46DF      6437          dc.w      18143
                    6438   ; *perr     = OS_ERR_NONE;
00002518  2047      6439          move.l    D7,A0
0000251A  4210      6440          clr.b     (A0)
                    6441   ; return (flags_cur);
0000251C  302E FFFE 6442          move.w    -2(A6),D0
                    6443   OSFlagPost_3:
00002520  4CDF 04FC 6444          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002524  4E5E      6445          unlk      A6
00002526  4E75      6446          rts
                    6447   ; }
                    6448   ; /*$PAGE*/
                    6449   ; /*
                    6450   ; *********************************************************************************************************
                    6451   ; *                                          QUERY EVENT FLAG
                    6452   ; *
                    6453   ; * Description: This function is used to check the value of the event flag group.
                    6454   ; *
                    6455   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6456   ; *
                    6457   ; *              perr          is a pointer to an error code returned to the called:
                    6458   ; *                            OS_ERR_NONE                The call was successfull
                    6459   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6460   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6461   ; *
                    6462   ; * Returns    : The current value of the event flag group.
                    6463   ; *
                    6464   ; * Called From: Task or ISR
                    6465   ; *********************************************************************************************************
                    6466   ; */
                    6467   ; #if OS_FLAG_QUERY_EN > 0u
                    6468   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6469   ; INT8U        *perr)
                    6470   ; {
                    6471   _OSFlagQuery:
00002528  4E56 FFFC 6472          link      A6,#-4
                    6473   ; OS_FLAGS   flags;
                    6474   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6475   ; OS_CPU_SR  cpu_sr = 0u;
                    6476   ; #endif
                    6477   ; #ifdef OS_SAFETY_CRITICAL
                    6478   ; if (perr == (INT8U *)0) {
                    6479   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6480   ; return ((OS_FLAGS)0);
                    6481   ; }
                    6482   ; #endif
                    6483   ; #if OS_ARG_CHK_EN > 0u
                    6484   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6485   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6486   ; return ((OS_FLAGS)0);
                    6487   ; }
                    6488   ; #endif
                    6489   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
0000252C  206E 0008 6490          move.l    8(A6),A0
00002530  1010      6491          move.b    (A0),D0
00002532  0C00 0005 6492          cmp.b     #5,D0
00002536  670C      6493          beq.s     OSFlagQuery_1
                    6494   ; *perr = OS_ERR_EVENT_TYPE;
00002538  206E 000C 6495          move.l    12(A6),A0
0000253C  10BC 0001 6496          move.b    #1,(A0)
                    6497   ; return ((OS_FLAGS)0);
00002540  4240      6498          clr.w     D0
00002542  601C      6499          bra.s     OSFlagQuery_3
                    6500   OSFlagQuery_1:
                    6501   ; }
                    6502   ; OS_ENTER_CRITICAL();
00002544  40E7      6503          dc.w      16615
00002546  007C      6504          dc.w      124
00002548  0700      6505          dc.w      1792
                    6506   ; flags = pgrp->OSFlagFlags;
0000254A  206E 0008 6507          move.l    8(A6),A0
0000254E  3D68 0006 6508          move.w    6(A0),-2(A6)
00002552  FFFE      
                    6509   ; OS_EXIT_CRITICAL();
00002554  46DF      6510          dc.w      18143
                    6511   ; *perr = OS_ERR_NONE;
00002556  206E 000C 6512          move.l    12(A6),A0
0000255A  4210      6513          clr.b     (A0)
                    6514   ; return (flags);                               /* Return the current value of the event flags       */
0000255C  302E FFFE 6515          move.w    -2(A6),D0
                    6516   OSFlagQuery_3:
00002560  4E5E      6517          unlk      A6
00002562  4E75      6518          rts
                    6519   ; }
                    6520   ; #endif
                    6521   ; /*$PAGE*/
                    6522   ; /*
                    6523   ; *********************************************************************************************************
                    6524   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6525   ; *
                    6526   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6527   ; *              event flag bit(s) are set.
                    6528   ; *
                    6529   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6530   ; *
                    6531   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6532   ; *                            event flag bit(s) to be set.
                    6533   ; *
                    6534   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6535   ; *                            The bits you want are specified by setting the corresponding bits in
                    6536   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6537   ; *                            'flags' would contain 0x03.
                    6538   ; *
                    6539   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6540   ; *                            to be set/cleared.
                    6541   ; *                            You can specify the following argument:
                    6542   ; *
                    6543   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6544   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6545   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6546   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6547   ; *
                    6548   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6549   ; *                            bit(s) to be set.
                    6550   ; *
                    6551   ; * Returns    : none
                    6552   ; *
                    6553   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6554   ; *
                    6555   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6556   ; *********************************************************************************************************
                    6557   ; */
                    6558   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6559   ; OS_FLAG_NODE *pnode,
                    6560   ; OS_FLAGS      flags,
                    6561   ; INT8U         wait_type,
                    6562   ; INT32U        timeout)
                    6563   ; {
                    6564   @ucos_ii_OS_FlagBlock:
00002564  4E56 0000 6565          link      A6,#0
00002568  48E7 3C20 6566          movem.l   D2/D3/D4/D5/A2,-(A7)
0000256C  242E 000C 6567          move.l    12(A6),D2
00002570  45F9 0800 6568          lea       _OSTCBCur.L,A2
00002574  0E3A      
00002576  262E 0008 6569          move.l    8(A6),D3
                    6570   ; OS_FLAG_NODE  *pnode_next;
                    6571   ; INT8U          y;
                    6572   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
0000257A  2052      6573          move.l    (A2),A0
0000257C  0028 0020 6574          or.b      #32,50(A0)
00002580  0032      
                    6575   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00002582  2052      6576          move.l    (A2),A0
00002584  4228 0033 6577          clr.b     51(A0)
                    6578   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002588  2052      6579          move.l    (A2),A0
0000258A  216E 0018 6580          move.l    24(A6),46(A0)
0000258E  002E      
                    6581   ; #if OS_TASK_DEL_EN > 0u
                    6582   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
00002590  2052      6583          move.l    (A2),A0
00002592  2142 0028 6584          move.l    D2,40(A0)
                    6585   ; #endif
                    6586   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
00002596  2042      6587          move.l    D2,A0
00002598  316E 0012 6588          move.w    18(A6),16(A0)
0000259C  0010      
                    6589   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
0000259E  2042      6590          move.l    D2,A0
000025A0  116E 0017 6591          move.b    23(A6),18(A0)
000025A4  0012      
                    6592   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
000025A6  2042      6593          move.l    D2,A0
000025A8  2152 0008 6594          move.l    (A2),8(A0)
                    6595   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000025AC  2043      6596          move.l    D3,A0
000025AE  2242      6597          move.l    D2,A1
000025B0  22A8 0002 6598          move.l    2(A0),(A1)
                    6599   ; pnode->OSFlagNodePrev     = (void *)0;
000025B4  2042      6600          move.l    D2,A0
000025B6  42A8 0004 6601          clr.l     4(A0)
                    6602   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000025BA  2042      6603          move.l    D2,A0
000025BC  2143 000C 6604          move.l    D3,12(A0)
                    6605   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000025C0  2043      6606          move.l    D3,A0
000025C2  2A28 0002 6607          move.l    2(A0),D5
                    6608   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000025C6  4A85      6609          tst.l     D5
000025C8  6706      6610          beq.s     @ucos_ii_OS_FlagBlock_1
                    6611   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000025CA  2045      6612          move.l    D5,A0
000025CC  2142 0004 6613          move.l    D2,4(A0)
                    6614   @ucos_ii_OS_FlagBlock_1:
                    6615   ; }
                    6616   ; pgrp->OSFlagWaitList = (void *)pnode;
000025D0  2043      6617          move.l    D3,A0
000025D2  2142 0002 6618          move.l    D2,2(A0)
                    6619   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000025D6  2052      6620          move.l    (A2),A0
000025D8  1828 0036 6621          move.b    54(A0),D4
                    6622   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000025DC  C8BC 0000 6623          and.l     #255,D4
000025E0  00FF      
000025E2  41F9 0800 6624          lea       _OSRdyTbl.L,A0
000025E6  0D2A      
000025E8  2252      6625          move.l    (A2),A1
000025EA  1029 0037 6626          move.b    55(A1),D0
000025EE  4600      6627          not.b     D0
000025F0  C130 4800 6628          and.b     D0,0(A0,D4.L)
                    6629   ; if (OSRdyTbl[y] == 0x00u) {
000025F4  C8BC 0000 6630          and.l     #255,D4
000025F8  00FF      
000025FA  41F9 0800 6631          lea       _OSRdyTbl.L,A0
000025FE  0D2A      
00002600  1030 4800 6632          move.b    0(A0,D4.L),D0
00002604  660E      6633          bne.s     @ucos_ii_OS_FlagBlock_3
                    6634   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00002606  2052      6635          move.l    (A2),A0
00002608  1028 0038 6636          move.b    56(A0),D0
0000260C  4600      6637          not.b     D0
0000260E  C139 0800 6638          and.b     D0,_OSRdyGrp.L
00002612  0D28      
                    6639   @ucos_ii_OS_FlagBlock_3:
00002614  4CDF 043C 6640          movem.l   (A7)+,D2/D3/D4/D5/A2
00002618  4E5E      6641          unlk      A6
0000261A  4E75      6642          rts
                    6643   ; }
                    6644   ; }
                    6645   ; /*$PAGE*/
                    6646   ; /*
                    6647   ; *********************************************************************************************************
                    6648   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6649   ; *
                    6650   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6651   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6652   ; *
                    6653   ; * Arguments  : none
                    6654   ; *
                    6655   ; * Returns    : none
                    6656   ; *
                    6657   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6658   ; *********************************************************************************************************
                    6659   ; */
                    6660   ; void  OS_FlagInit (void)
                    6661   ; {
                    6662   _OS_FlagInit:
0000261C  4E56 FFF8 6663          link      A6,#-8
00002620  48E7 3020 6664          movem.l   D2/D3/A2,-(A7)
00002624  45F9 0800 6665          lea       _OSFlagTbl.L,A2
00002628  0BD4      
                    6666   ; #if OS_MAX_FLAGS == 1u
                    6667   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6668   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6669   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6670   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6671   ; #if OS_FLAG_NAME_EN > 0u
                    6672   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6673   ; #endif
                    6674   ; #endif
                    6675   ; #if OS_MAX_FLAGS >= 2u
                    6676   ; INT16U        ix;
                    6677   ; INT16U        ix_next;
                    6678   ; OS_FLAG_GRP  *pgrp1;
                    6679   ; OS_FLAG_GRP  *pgrp2;
                    6680   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
0000262A  4878 003C 6681          pea       60
0000262E  2F0A      6682          move.l    A2,-(A7)
00002630  4EB8 18C2 6683          jsr       _OS_MemClr
00002634  504F      6684          addq.w    #8,A7
                    6685   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00002636  4243      6686          clr.w     D3
                    6687   OS_FlagInit_1:
00002638  0C43 0004 6688          cmp.w     #4,D3
0000263C  6400 004E 6689          bhs       OS_FlagInit_3
                    6690   ; ix_next = ix + 1u;
00002640  3003      6691          move.w    D3,D0
00002642  5240      6692          addq.w    #1,D0
00002644  3D40 FFFA 6693          move.w    D0,-6(A6)
                    6694   ; pgrp1 = &OSFlagTbl[ix];
00002648  200A      6695          move.l    A2,D0
0000264A  C6BC 0000 6696          and.l     #65535,D3
0000264E  FFFF      
00002650  2203      6697          move.l    D3,D1
00002652  C3FC 000C 6698          muls      #12,D1
00002656  D081      6699          add.l     D1,D0
00002658  2400      6700          move.l    D0,D2
                    6701   ; pgrp2 = &OSFlagTbl[ix_next];
0000265A  200A      6702          move.l    A2,D0
0000265C  322E FFFA 6703          move.w    -6(A6),D1
00002660  C2BC 0000 6704          and.l     #65535,D1
00002664  FFFF      
00002666  C3FC 000C 6705          muls      #12,D1
0000266A  D081      6706          add.l     D1,D0
0000266C  2D40 FFFC 6707          move.l    D0,-4(A6)
                    6708   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002670  2042      6709          move.l    D2,A0
00002672  4210      6710          clr.b     (A0)
                    6711   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
00002674  2042      6712          move.l    D2,A0
00002676  216E FFFC 6713          move.l    -4(A6),2(A0)
0000267A  0002      
                    6714   ; #if OS_FLAG_NAME_EN > 0u
                    6715   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
0000267C  41F9 0000 6716          lea       @ucos_ii_1.L,A0
00002680  6F2A      
00002682  2242      6717          move.l    D2,A1
00002684  2348 0008 6718          move.l    A0,8(A1)
00002688  5243      6719          addq.w    #1,D3
0000268A  60AC      6720          bra       OS_FlagInit_1
                    6721   OS_FlagInit_3:
                    6722   ; #endif
                    6723   ; }
                    6724   ; pgrp1                 = &OSFlagTbl[ix];
0000268C  200A      6725          move.l    A2,D0
0000268E  C6BC 0000 6726          and.l     #65535,D3
00002692  FFFF      
00002694  2203      6727          move.l    D3,D1
00002696  C3FC 000C 6728          muls      #12,D1
0000269A  D081      6729          add.l     D1,D0
0000269C  2400      6730          move.l    D0,D2
                    6731   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0000269E  2042      6732          move.l    D2,A0
000026A0  4210      6733          clr.b     (A0)
                    6734   ; pgrp1->OSFlagWaitList = (void *)0;
000026A2  2042      6735          move.l    D2,A0
000026A4  42A8 0002 6736          clr.l     2(A0)
                    6737   ; #if OS_FLAG_NAME_EN > 0u
                    6738   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
000026A8  41F9 0000 6739          lea       @ucos_ii_1.L,A0
000026AC  6F2A      
000026AE  2242      6740          move.l    D2,A1
000026B0  2348 0008 6741          move.l    A0,8(A1)
                    6742   ; #endif
                    6743   ; OSFlagFreeList        = &OSFlagTbl[0];
000026B4  23CA 0800 6744          move.l    A2,_OSFlagFreeList.L
000026B8  0C10      
000026BA  4CDF 040C 6745          movem.l   (A7)+,D2/D3/A2
000026BE  4E5E      6746          unlk      A6
000026C0  4E75      6747          rts
                    6748   ; #endif
                    6749   ; }
                    6750   ; /*$PAGE*/
                    6751   ; /*
                    6752   ; *********************************************************************************************************
                    6753   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6754   ; *
                    6755   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6756   ; *              desired event flag bits have been set.
                    6757   ; *
                    6758   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6759   ; *                            event flag bit(s) to be set.
                    6760   ; *
                    6761   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6762   ; *                            ready-to-run.
                    6763   ; *
                    6764   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6765   ; *
                    6766   ; *
                    6767   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6768   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6769   ; *
                    6770   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6771   ; *
                    6772   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6773   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6774   ; *********************************************************************************************************
                    6775   ; */
                    6776   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6777   ; OS_FLAGS      flags_rdy,
                    6778   ; INT8U         pend_stat)
                    6779   ; {
                    6780   @ucos_ii_OS_FlagTaskRdy:
000026C2  4E56 0000 6781          link      A6,#0
000026C6  48E7 3000 6782          movem.l   D2/D3,-(A7)
                    6783   ; OS_TCB   *ptcb;
                    6784   ; BOOLEAN   sched;
                    6785   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000026CA  206E 0008 6786          move.l    8(A6),A0
000026CE  2428 0008 6787          move.l    8(A0),D2
                    6788   ; ptcb->OSTCBDly       = 0u;
000026D2  2042      6789          move.l    D2,A0
000026D4  42A8 002E 6790          clr.l     46(A0)
                    6791   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
000026D8  2042      6792          move.l    D2,A0
000026DA  316E 000E 6793          move.w    14(A6),44(A0)
000026DE  002C      
                    6794   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000026E0  2042      6795          move.l    D2,A0
000026E2  7020      6796          moveq     #32,D0
000026E4  4600      6797          not.b     D0
000026E6  C128 0032 6798          and.b     D0,50(A0)
                    6799   ; ptcb->OSTCBStatPend  = pend_stat;
000026EA  2042      6800          move.l    D2,A0
000026EC  116E 0013 6801          move.b    19(A6),51(A0)
000026F0  0033      
                    6802   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000026F2  2042      6803          move.l    D2,A0
000026F4  1028 0032 6804          move.b    50(A0),D0
000026F8  662C      6805          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6806   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000026FA  2042      6807          move.l    D2,A0
000026FC  1028 0038 6808          move.b    56(A0),D0
00002700  8139 0800 6809          or.b      D0,_OSRdyGrp.L
00002704  0D28      
                    6810   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00002706  2042      6811          move.l    D2,A0
00002708  1028 0036 6812          move.b    54(A0),D0
0000270C  C0BC 0000 6813          and.l     #255,D0
00002710  00FF      
00002712  41F9 0800 6814          lea       _OSRdyTbl.L,A0
00002716  0D2A      
00002718  2242      6815          move.l    D2,A1
0000271A  1229 0037 6816          move.b    55(A1),D1
0000271E  8330 0800 6817          or.b      D1,0(A0,D0.L)
                    6818   ; sched                   = OS_TRUE;
00002722  7601      6819          moveq     #1,D3
00002724  6002      6820          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6821   @ucos_ii_OS_FlagTaskRdy_1:
                    6822   ; } else {
                    6823   ; sched                   = OS_FALSE;
00002726  4203      6824          clr.b     D3
                    6825   @ucos_ii_OS_FlagTaskRdy_2:
                    6826   ; }
                    6827   ; OS_FlagUnlink(pnode);
00002728  2F2E 0008 6828          move.l    8(A6),-(A7)
0000272C  4EB9 0000 6829          jsr       _OS_FlagUnlink
00002730  273E      
00002732  584F      6830          addq.w    #4,A7
                    6831   ; return (sched);
00002734  1003      6832          move.b    D3,D0
00002736  4CDF 000C 6833          movem.l   (A7)+,D2/D3
0000273A  4E5E      6834          unlk      A6
0000273C  4E75      6835          rts
                    6836   ; }
                    6837   ; /*$PAGE*/
                    6838   ; /*
                    6839   ; *********************************************************************************************************
                    6840   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6841   ; *
                    6842   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6843   ; *              list of tasks waiting for the event flag.
                    6844   ; *
                    6845   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6846   ; *                            event flag bit(s) to be set.
                    6847   ; *
                    6848   ; * Returns    : none
                    6849   ; *
                    6850   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6851   ; *              OSFlagPend()     OS_FLAG.C
                    6852   ; *              OSTaskDel()      OS_TASK.C
                    6853   ; *
                    6854   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6855   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6856   ; *********************************************************************************************************
                    6857   ; */
                    6858   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6859   ; {
                    6860   _OS_FlagUnlink:
0000273E  4E56 FFF8 6861          link      A6,#-8
00002742  48E7 3800 6862          movem.l   D2/D3/D4,-(A7)
00002746  262E 0008 6863          move.l    8(A6),D3
                    6864   ; #if OS_TASK_DEL_EN > 0u
                    6865   ; OS_TCB       *ptcb;
                    6866   ; #endif
                    6867   ; OS_FLAG_GRP  *pgrp;
                    6868   ; OS_FLAG_NODE *pnode_prev;
                    6869   ; OS_FLAG_NODE *pnode_next;
                    6870   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
0000274A  2043      6871          move.l    D3,A0
0000274C  2828 0004 6872          move.l    4(A0),D4
                    6873   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00002750  2043      6874          move.l    D3,A0
00002752  2410      6875          move.l    (A0),D2
                    6876   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
00002754  4A84      6877          tst.l     D4
00002756  661C      6878          bne.s     OS_FlagUnlink_1
                    6879   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00002758  2043      6880          move.l    D3,A0
0000275A  2D68 000C 6881          move.l    12(A0),-4(A6)
0000275E  FFFC      
                    6882   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00002760  206E FFFC 6883          move.l    -4(A6),A0
00002764  2142 0002 6884          move.l    D2,2(A0)
                    6885   ; if (pnode_next != (OS_FLAG_NODE *)0) {
00002768  4A82      6886          tst.l     D2
0000276A  6706      6887          beq.s     OS_FlagUnlink_3
                    6888   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
0000276C  2042      6889          move.l    D2,A0
0000276E  42A8 0004 6890          clr.l     4(A0)
                    6891   OS_FlagUnlink_3:
00002772  600E      6892          bra.s     OS_FlagUnlink_5
                    6893   OS_FlagUnlink_1:
                    6894   ; }
                    6895   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6896   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
00002774  2044      6897          move.l    D4,A0
00002776  2082      6898          move.l    D2,(A0)
                    6899   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
00002778  4A82      6900          tst.l     D2
0000277A  6706      6901          beq.s     OS_FlagUnlink_5
                    6902   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
0000277C  2042      6903          move.l    D2,A0
0000277E  2144 0004 6904          move.l    D4,4(A0)
                    6905   OS_FlagUnlink_5:
                    6906   ; }
                    6907   ; }
                    6908   ; #if OS_TASK_DEL_EN > 0u
                    6909   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00002782  2043      6910          move.l    D3,A0
00002784  2D68 0008 6911          move.l    8(A0),-8(A6)
00002788  FFF8      
                    6912   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
0000278A  206E FFF8 6913          move.l    -8(A6),A0
0000278E  42A8 0028 6914          clr.l     40(A0)
00002792  4CDF 001C 6915          movem.l   (A7)+,D2/D3/D4
00002796  4E5E      6916          unlk      A6
00002798  4E75      6917          rts
                    6918   ; /*
                    6919   ; *********************************************************************************************************
                    6920   ; *                                                uC/OS-II
                    6921   ; *                                          The Real-Time Kernel
                    6922   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6923   ; *
                    6924   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6925   ; *                                           All Rights Reserved
                    6926   ; *
                    6927   ; * File    : OS_MBOX.C
                    6928   ; * By      : Jean J. Labrosse
                    6929   ; * Version : V2.92.07
                    6930   ; *
                    6931   ; * LICENSING TERMS:
                    6932   ; * ---------------
                    6933   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6934   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6935   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6936   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6937   ; * licensing fee.
                    6938   ; *********************************************************************************************************
                    6939   ; */
                    6940   ; #define  MICRIUM_SOURCE
                    6941   ; #ifndef  OS_MASTER_FILE
                    6942   ; #include <ucos_ii.h>
                    6943   ; #endif
                    6944   ; #if OS_MBOX_EN > 0u
                    6945   ; /*
                    6946   ; *********************************************************************************************************
                    6947   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6948   ; *
                    6949   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6950   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6951   ; *
                    6952   ; * Arguments  : pevent        is a pointer to the event control block
                    6953   ; *
                    6954   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6955   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6956   ; *              == (void *)0  if the mailbox is empty or,
                    6957   ; *                            if 'pevent' is a NULL pointer or,
                    6958   ; *                            if you didn't pass the proper event pointer.
                    6959   ; *********************************************************************************************************
                    6960   ; */
                    6961   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6962   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6963   ; {
                    6964   _OSMboxAccept:
0000279A  4E56 FFFC 6965          link      A6,#-4
0000279E  2F02      6966          move.l    D2,-(A7)
000027A0  242E 0008 6967          move.l    8(A6),D2
                    6968   ; void      *pmsg;
                    6969   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6970   ; OS_CPU_SR  cpu_sr = 0u;
                    6971   ; #endif
                    6972   ; #if OS_ARG_CHK_EN > 0u
                    6973   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6974   ; return ((void *)0);
                    6975   ; }
                    6976   ; #endif
                    6977   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000027A4  2042      6978          move.l    D2,A0
000027A6  1010      6979          move.b    (A0),D0
000027A8  0C00 0001 6980          cmp.b     #1,D0
000027AC  6704      6981          beq.s     OSMboxAccept_1
                    6982   ; return ((void *)0);
000027AE  4280      6983          clr.l     D0
000027B0  601A      6984          bra.s     OSMboxAccept_3
                    6985   OSMboxAccept_1:
                    6986   ; }
                    6987   ; OS_ENTER_CRITICAL();
000027B2  40E7      6988          dc.w      16615
000027B4  007C      6989          dc.w      124
000027B6  0700      6990          dc.w      1792
                    6991   ; pmsg               = pevent->OSEventPtr;
000027B8  2042      6992          move.l    D2,A0
000027BA  2D68 0002 6993          move.l    2(A0),-4(A6)
000027BE  FFFC      
                    6994   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
000027C0  2042      6995          move.l    D2,A0
000027C2  42A8 0002 6996          clr.l     2(A0)
                    6997   ; OS_EXIT_CRITICAL();
000027C6  46DF      6998          dc.w      18143
                    6999   ; return (pmsg);                                        /* Return the message received (or NULL)     */
000027C8  202E FFFC 7000          move.l    -4(A6),D0
                    7001   OSMboxAccept_3:
000027CC  241F      7002          move.l    (A7)+,D2
000027CE  4E5E      7003          unlk      A6
000027D0  4E75      7004          rts
                    7005   ; }
                    7006   ; #endif
                    7007   ; /*$PAGE*/
                    7008   ; /*
                    7009   ; *********************************************************************************************************
                    7010   ; *                                          CREATE A MESSAGE MAILBOX
                    7011   ; *
                    7012   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    7013   ; *
                    7014   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    7015   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    7016   ; *                            will be considered empty.
                    7017   ; *
                    7018   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    7019   ; *                                created mailbox
                    7020   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    7021   ; *********************************************************************************************************
                    7022   ; */
                    7023   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    7024   ; {
                    7025   _OSMboxCreate:
000027D2  4E56 0000 7026          link      A6,#0
000027D6  48E7 2020 7027          movem.l   D2/A2,-(A7)
000027DA  45F9 0800 7028          lea       _OSEventFreeList.L,A2
000027DE  0AF4      
                    7029   ; OS_EVENT  *pevent;
                    7030   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    7031   ; OS_CPU_SR  cpu_sr = 0u;
                    7032   ; #endif
                    7033   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7034   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7035   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7036   ; return ((OS_EVENT *)0);
                    7037   ; }
                    7038   ; #endif
                    7039   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000027E0  1039 0800 7040          move.b    _OSIntNesting.L,D0
000027E4  0D20      
000027E6  0C00 0000 7041          cmp.b     #0,D0
000027EA  6306      7042          bls.s     OSMboxCreate_1
                    7043   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000027EC  4280      7044          clr.l     D0
000027EE  6000 0044 7045          bra       OSMboxCreate_3
                    7046   OSMboxCreate_1:
                    7047   ; }
                    7048   ; OS_ENTER_CRITICAL();
000027F2  40E7      7049          dc.w      16615
000027F4  007C      7050          dc.w      124
000027F6  0700      7051          dc.w      1792
                    7052   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000027F8  2412      7053          move.l    (A2),D2
                    7054   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000027FA  2012      7055          move.l    (A2),D0
000027FC  6706      7056          beq.s     OSMboxCreate_4
                    7057   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000027FE  2052      7058          move.l    (A2),A0
00002800  24A8 0002 7059          move.l    2(A0),(A2)
                    7060   OSMboxCreate_4:
                    7061   ; }
                    7062   ; OS_EXIT_CRITICAL();
00002804  46DF      7063          dc.w      18143
                    7064   ; if (pevent != (OS_EVENT *)0) {
00002806  4A82      7065          tst.l     D2
00002808  6728      7066          beq.s     OSMboxCreate_6
                    7067   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
0000280A  2042      7068          move.l    D2,A0
0000280C  10BC 0001 7069          move.b    #1,(A0)
                    7070   ; pevent->OSEventCnt     = 0u;
00002810  2042      7071          move.l    D2,A0
00002812  4268 0006 7072          clr.w     6(A0)
                    7073   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
00002816  2042      7074          move.l    D2,A0
00002818  216E 0008 7075          move.l    8(A6),2(A0)
0000281C  0002      
                    7076   ; #if OS_EVENT_NAME_EN > 0u
                    7077   ; pevent->OSEventName    = (INT8U *)(void *)"?";
0000281E  41F9 0000 7078          lea       @ucos_ii_1.L,A0
00002822  6F2A      
00002824  2242      7079          move.l    D2,A1
00002826  2348 0012 7080          move.l    A0,18(A1)
                    7081   ; #endif
                    7082   ; OS_EventWaitListInit(pevent);
0000282A  2F02      7083          move.l    D2,-(A7)
0000282C  4EB8 15F6 7084          jsr       _OS_EventWaitListInit
00002830  584F      7085          addq.w    #4,A7
                    7086   OSMboxCreate_6:
                    7087   ; }
                    7088   ; return (pevent);                             /* Return pointer to event control block              */
00002832  2002      7089          move.l    D2,D0
                    7090   OSMboxCreate_3:
00002834  4CDF 0404 7091          movem.l   (A7)+,D2/A2
00002838  4E5E      7092          unlk      A6
0000283A  4E75      7093          rts
                    7094   ; }
                    7095   ; /*$PAGE*/
                    7096   ; /*
                    7097   ; *********************************************************************************************************
                    7098   ; *                                           DELETE A MAIBOX
                    7099   ; *
                    7100   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    7101   ; *
                    7102   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    7103   ; *                            mailbox.
                    7104   ; *
                    7105   ; *              opt           determines delete options as follows:
                    7106   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    7107   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    7108   ; *                                                    In this case, all the tasks pending will be readied.
                    7109   ; *
                    7110   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    7111   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    7112   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    7113   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    7114   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    7115   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    7116   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    7117   ; *
                    7118   ; * Returns    : pevent        upon error
                    7119   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    7120   ; *
                    7121   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    7122   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    7123   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    7124   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    7125   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    7126   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    7127   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    7128   ; *                 will no longer be guarded by the mailbox.
                    7129   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    7130   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    7131   ; *********************************************************************************************************
                    7132   ; */
                    7133   ; #if OS_MBOX_DEL_EN > 0u
                    7134   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    7135   ; INT8U      opt,
                    7136   ; INT8U     *perr)
                    7137   ; {
                    7138   _OSMboxDel:
0000283C  4E56 0000 7139          link      A6,#0
00002840  48E7 3C20 7140          movem.l   D2/D3/D4/D5/A2,-(A7)
00002844  242E 0008 7141          move.l    8(A6),D2
00002848  262E 0010 7142          move.l    16(A6),D3
0000284C  45F9 0800 7143          lea       _OSEventFreeList.L,A2
00002850  0AF4      
                    7144   ; BOOLEAN    tasks_waiting;
                    7145   ; OS_EVENT  *pevent_return;
                    7146   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7147   ; OS_CPU_SR  cpu_sr = 0u;
                    7148   ; #endif
                    7149   ; #ifdef OS_SAFETY_CRITICAL
                    7150   ; if (perr == (INT8U *)0) {
                    7151   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7152   ; return ((OS_EVENT *)0);
                    7153   ; }
                    7154   ; #endif
                    7155   ; #if OS_ARG_CHK_EN > 0u
                    7156   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7157   ; *perr = OS_ERR_PEVENT_NULL;
                    7158   ; return (pevent);
                    7159   ; }
                    7160   ; #endif
                    7161   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002852  2042      7162          move.l    D2,A0
00002854  1010      7163          move.b    (A0),D0
00002856  0C00 0001 7164          cmp.b     #1,D0
0000285A  670C      7165          beq.s     OSMboxDel_1
                    7166   ; *perr = OS_ERR_EVENT_TYPE;
0000285C  2043      7167          move.l    D3,A0
0000285E  10BC 0001 7168          move.b    #1,(A0)
                    7169   ; return (pevent);
00002862  2002      7170          move.l    D2,D0
00002864  6000 00EA 7171          bra       OSMboxDel_3
                    7172   OSMboxDel_1:
                    7173   ; }
                    7174   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002868  1039 0800 7175          move.b    _OSIntNesting.L,D0
0000286C  0D20      
0000286E  0C00 0000 7176          cmp.b     #0,D0
00002872  630C      7177          bls.s     OSMboxDel_4
                    7178   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00002874  2043      7179          move.l    D3,A0
00002876  10BC 000F 7180          move.b    #15,(A0)
                    7181   ; return (pevent);
0000287A  2002      7182          move.l    D2,D0
0000287C  6000 00D2 7183          bra       OSMboxDel_3
                    7184   OSMboxDel_4:
                    7185   ; }
                    7186   ; OS_ENTER_CRITICAL();
00002880  40E7      7187          dc.w      16615
00002882  007C      7188          dc.w      124
00002884  0700      7189          dc.w      1792
                    7190   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
00002886  2042      7191          move.l    D2,A0
00002888  1028 0008 7192          move.b    8(A0),D0
0000288C  6704      7193          beq.s     OSMboxDel_6
                    7194   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
0000288E  7A01      7195          moveq     #1,D5
00002890  6002      7196          bra.s     OSMboxDel_7
                    7197   OSMboxDel_6:
                    7198   ; } else {
                    7199   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00002892  4205      7200          clr.b     D5
                    7201   OSMboxDel_7:
                    7202   ; }
                    7203   ; switch (opt) {
00002894  102E 000F 7204          move.b    15(A6),D0
00002898  C0BC 0000 7205          and.l     #255,D0
0000289C  00FF      
0000289E  0C80 0000 7206          cmp.l     #1,D0
000028A2  0001      
000028A4  6700 0048 7207          beq       OSMboxDel_11
000028A8  6200 009A 7208          bhi       OSMboxDel_8
000028AC  4A80      7209          tst.l     D0
000028AE  6704      7210          beq.s     OSMboxDel_10
000028B0  6000 0092 7211          bra       OSMboxDel_8
                    7212   OSMboxDel_10:
                    7213   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    7214   ; if (tasks_waiting == OS_FALSE) {
000028B4  4A05      7215          tst.b     D5
000028B6  6628      7216          bne.s     OSMboxDel_13
                    7217   ; #if OS_EVENT_NAME_EN > 0u
                    7218   ; pevent->OSEventName = (INT8U *)(void *)"?";
000028B8  41F9 0000 7219          lea       @ucos_ii_1.L,A0
000028BC  6F2A      
000028BE  2242      7220          move.l    D2,A1
000028C0  2348 0012 7221          move.l    A0,18(A1)
                    7222   ; #endif
                    7223   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
000028C4  2042      7224          move.l    D2,A0
000028C6  4210      7225          clr.b     (A0)
                    7226   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
000028C8  2042      7227          move.l    D2,A0
000028CA  2152 0002 7228          move.l    (A2),2(A0)
                    7229   ; pevent->OSEventCnt  = 0u;
000028CE  2042      7230          move.l    D2,A0
000028D0  4268 0006 7231          clr.w     6(A0)
                    7232   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
000028D4  2482      7233          move.l    D2,(A2)
                    7234   ; OS_EXIT_CRITICAL();
000028D6  46DF      7235          dc.w      18143
                    7236   ; *perr               = OS_ERR_NONE;
000028D8  2043      7237          move.l    D3,A0
000028DA  4210      7238          clr.b     (A0)
                    7239   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
000028DC  4284      7240          clr.l     D4
000028DE  600A      7241          bra.s     OSMboxDel_14
                    7242   OSMboxDel_13:
                    7243   ; } else {
                    7244   ; OS_EXIT_CRITICAL();
000028E0  46DF      7245          dc.w      18143
                    7246   ; *perr               = OS_ERR_TASK_WAITING;
000028E2  2043      7247          move.l    D3,A0
000028E4  10BC 0049 7248          move.b    #73,(A0)
                    7249   ; pevent_return       = pevent;
000028E8  2802      7250          move.l    D2,D4
                    7251   OSMboxDel_14:
                    7252   ; }
                    7253   ; break;
000028EA  6000 0062 7254          bra       OSMboxDel_9
                    7255   OSMboxDel_11:
                    7256   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    7257   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    7258   OSMboxDel_15:
000028EE  2042      7259          move.l    D2,A0
000028F0  1028 0008 7260          move.b    8(A0),D0
000028F4  671C      7261          beq.s     OSMboxDel_17
                    7262   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000028F6  4878 0002 7263          pea       2
000028FA  4878 0002 7264          pea       2
000028FE  42A7      7265          clr.l     -(A7)
00002900  2F02      7266          move.l    D2,-(A7)
00002902  4EB8 132E 7267          jsr       _OS_EventTaskRdy
00002906  DEFC 0010 7268          add.w     #16,A7
0000290A  C0BC 0000 7269          and.l     #255,D0
0000290E  00FF      
00002910  60DC      7270          bra       OSMboxDel_15
                    7271   OSMboxDel_17:
                    7272   ; }
                    7273   ; #if OS_EVENT_NAME_EN > 0u
                    7274   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00002912  41F9 0000 7275          lea       @ucos_ii_1.L,A0
00002916  6F2A      
00002918  2242      7276          move.l    D2,A1
0000291A  2348 0012 7277          move.l    A0,18(A1)
                    7278   ; #endif
                    7279   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0000291E  2042      7280          move.l    D2,A0
00002920  4210      7281          clr.b     (A0)
                    7282   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00002922  2042      7283          move.l    D2,A0
00002924  2152 0002 7284          move.l    (A2),2(A0)
                    7285   ; pevent->OSEventCnt     = 0u;
00002928  2042      7286          move.l    D2,A0
0000292A  4268 0006 7287          clr.w     6(A0)
                    7288   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
0000292E  2482      7289          move.l    D2,(A2)
                    7290   ; OS_EXIT_CRITICAL();
00002930  46DF      7291          dc.w      18143
                    7292   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00002932  0C05 0001 7293          cmp.b     #1,D5
00002936  6604      7294          bne.s     OSMboxDel_18
                    7295   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002938  4EB8 190E 7296          jsr       _OS_Sched
                    7297   OSMboxDel_18:
                    7298   ; }
                    7299   ; *perr         = OS_ERR_NONE;
0000293C  2043      7300          move.l    D3,A0
0000293E  4210      7301          clr.b     (A0)
                    7302   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
00002940  4284      7303          clr.l     D4
                    7304   ; break;
00002942  600A      7305          bra.s     OSMboxDel_9
                    7306   OSMboxDel_8:
                    7307   ; default:
                    7308   ; OS_EXIT_CRITICAL();
00002944  46DF      7309          dc.w      18143
                    7310   ; *perr         = OS_ERR_INVALID_OPT;
00002946  2043      7311          move.l    D3,A0
00002948  10BC 0007 7312          move.b    #7,(A0)
                    7313   ; pevent_return = pevent;
0000294C  2802      7314          move.l    D2,D4
                    7315   ; break;
                    7316   OSMboxDel_9:
                    7317   ; }
                    7318   ; return (pevent_return);
0000294E  2004      7319          move.l    D4,D0
                    7320   OSMboxDel_3:
00002950  4CDF 043C 7321          movem.l   (A7)+,D2/D3/D4/D5/A2
00002954  4E5E      7322          unlk      A6
00002956  4E75      7323          rts
                    7324   ; }
                    7325   ; #endif
                    7326   ; /*$PAGE*/
                    7327   ; /*
                    7328   ; *********************************************************************************************************
                    7329   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    7330   ; *
                    7331   ; * Description: This function waits for a message to be sent to a mailbox
                    7332   ; *
                    7333   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7334   ; *
                    7335   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    7336   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    7337   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    7338   ; *                            forever at the specified mailbox or, until a message arrives.
                    7339   ; *
                    7340   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7341   ; *                            messages are:
                    7342   ; *
                    7343   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    7344   ; *                                                message.
                    7345   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    7346   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    7347   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    7348   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    7349   ; *                                                would lead to a suspension.
                    7350   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    7351   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    7352   ; *
                    7353   ; * Returns    : != (void *)0  is a pointer to the message received
                    7354   ; *              == (void *)0  if no message was received or,
                    7355   ; *                            if 'pevent' is a NULL pointer or,
                    7356   ; *                            if you didn't pass the proper pointer to the event control block.
                    7357   ; *********************************************************************************************************
                    7358   ; */
                    7359   ; /*$PAGE*/
                    7360   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    7361   ; INT32U     timeout,
                    7362   ; INT8U     *perr)
                    7363   ; {
                    7364   _OSMboxPend:
00002958  4E56 0000 7365          link      A6,#0
0000295C  48E7 3820 7366          movem.l   D2/D3/D4/A2,-(A7)
00002960  45F9 0800 7367          lea       _OSTCBCur.L,A2
00002964  0E3A      
00002966  262E 0010 7368          move.l    16(A6),D3
0000296A  282E 0008 7369          move.l    8(A6),D4
                    7370   ; void      *pmsg;
                    7371   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7372   ; OS_CPU_SR  cpu_sr = 0u;
                    7373   ; #endif
                    7374   ; #ifdef OS_SAFETY_CRITICAL
                    7375   ; if (perr == (INT8U *)0) {
                    7376   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7377   ; return ((void *)0);
                    7378   ; }
                    7379   ; #endif
                    7380   ; #if OS_ARG_CHK_EN > 0u
                    7381   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7382   ; *perr = OS_ERR_PEVENT_NULL;
                    7383   ; return ((void *)0);
                    7384   ; }
                    7385   ; #endif
                    7386   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
0000296E  2044      7387          move.l    D4,A0
00002970  1010      7388          move.b    (A0),D0
00002972  0C00 0001 7389          cmp.b     #1,D0
00002976  670C      7390          beq.s     OSMboxPend_1
                    7391   ; *perr = OS_ERR_EVENT_TYPE;
00002978  2043      7392          move.l    D3,A0
0000297A  10BC 0001 7393          move.b    #1,(A0)
                    7394   ; return ((void *)0);
0000297E  4280      7395          clr.l     D0
00002980  6000 00F0 7396          bra       OSMboxPend_3
                    7397   OSMboxPend_1:
                    7398   ; }
                    7399   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00002984  1039 0800 7400          move.b    _OSIntNesting.L,D0
00002988  0D20      
0000298A  0C00 0000 7401          cmp.b     #0,D0
0000298E  630C      7402          bls.s     OSMboxPend_4
                    7403   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00002990  2043      7404          move.l    D3,A0
00002992  10BC 0002 7405          move.b    #2,(A0)
                    7406   ; return ((void *)0);
00002996  4280      7407          clr.l     D0
00002998  6000 00D8 7408          bra       OSMboxPend_3
                    7409   OSMboxPend_4:
                    7410   ; }
                    7411   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
0000299C  1039 0800 7412          move.b    _OSLockNesting.L,D0
000029A0  0D22      
000029A2  0C00 0000 7413          cmp.b     #0,D0
000029A6  630C      7414          bls.s     OSMboxPend_6
                    7415   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
000029A8  2043      7416          move.l    D3,A0
000029AA  10BC 000D 7417          move.b    #13,(A0)
                    7418   ; return ((void *)0);
000029AE  4280      7419          clr.l     D0
000029B0  6000 00C0 7420          bra       OSMboxPend_3
                    7421   OSMboxPend_6:
                    7422   ; }
                    7423   ; OS_ENTER_CRITICAL();
000029B4  40E7      7424          dc.w      16615
000029B6  007C      7425          dc.w      124
000029B8  0700      7426          dc.w      1792
                    7427   ; pmsg = pevent->OSEventPtr;
000029BA  2044      7428          move.l    D4,A0
000029BC  2428 0002 7429          move.l    2(A0),D2
                    7430   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
000029C0  4A82      7431          tst.l     D2
000029C2  6712      7432          beq.s     OSMboxPend_8
                    7433   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
000029C4  2044      7434          move.l    D4,A0
000029C6  42A8 0002 7435          clr.l     2(A0)
                    7436   ; OS_EXIT_CRITICAL();
000029CA  46DF      7437          dc.w      18143
                    7438   ; *perr = OS_ERR_NONE;
000029CC  2043      7439          move.l    D3,A0
000029CE  4210      7440          clr.b     (A0)
                    7441   ; return (pmsg);                                /* Return the message received (or NULL)         */
000029D0  2002      7442          move.l    D2,D0
000029D2  6000 009E 7443          bra       OSMboxPend_3
                    7444   OSMboxPend_8:
                    7445   ; }
                    7446   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
000029D6  2052      7447          move.l    (A2),A0
000029D8  0028 0002 7448          or.b      #2,50(A0)
000029DC  0032      
                    7449   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000029DE  2052      7450          move.l    (A2),A0
000029E0  4228 0033 7451          clr.b     51(A0)
                    7452   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
000029E4  2052      7453          move.l    (A2),A0
000029E6  216E 000C 7454          move.l    12(A6),46(A0)
000029EA  002E      
                    7455   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000029EC  2F04      7456          move.l    D4,-(A7)
000029EE  4EB8 1412 7457          jsr       _OS_EventTaskWait
000029F2  584F      7458          addq.w    #4,A7
                    7459   ; OS_EXIT_CRITICAL();
000029F4  46DF      7460          dc.w      18143
                    7461   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
000029F6  4EB8 190E 7462          jsr       _OS_Sched
                    7463   ; OS_ENTER_CRITICAL();
000029FA  40E7      7464          dc.w      16615
000029FC  007C      7465          dc.w      124
000029FE  0700      7466          dc.w      1792
                    7467   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00002A00  2052      7468          move.l    (A2),A0
00002A02  1028 0033 7469          move.b    51(A0),D0
00002A06  C0BC 0000 7470          and.l     #255,D0
00002A0A  00FF      
00002A0C  0C80 0000 7471          cmp.l     #1,D0
00002A10  0001      
00002A12  6700 002A 7472          beq       OSMboxPend_14
00002A16  6206      7473          bhi.s     OSMboxPend_16
00002A18  4A80      7474          tst.l     D0
00002A1A  670C      7475          beq.s     OSMboxPend_12
00002A1C  6020      7476          bra.s     OSMboxPend_14
                    7477   OSMboxPend_16:
00002A1E  0C80 0000 7478          cmp.l     #2,D0
00002A22  0002      
00002A24  670E      7479          beq.s     OSMboxPend_13
00002A26  6016      7480          bra.s     OSMboxPend_14
                    7481   OSMboxPend_12:
                    7482   ; case OS_STAT_PEND_OK:
                    7483   ; pmsg =  OSTCBCur->OSTCBMsg;
00002A28  2052      7484          move.l    (A2),A0
00002A2A  2428 0024 7485          move.l    36(A0),D2
                    7486   ; *perr =  OS_ERR_NONE;
00002A2E  2043      7487          move.l    D3,A0
00002A30  4210      7488          clr.b     (A0)
                    7489   ; break;
00002A32  601C      7490          bra.s     OSMboxPend_11
                    7491   OSMboxPend_13:
                    7492   ; case OS_STAT_PEND_ABORT:
                    7493   ; pmsg = (void *)0;
00002A34  4282      7494          clr.l     D2
                    7495   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00002A36  2043      7496          move.l    D3,A0
00002A38  10BC 000E 7497          move.b    #14,(A0)
                    7498   ; break;
00002A3C  6012      7499          bra.s     OSMboxPend_11
                    7500   OSMboxPend_14:
                    7501   ; case OS_STAT_PEND_TO:
                    7502   ; default:
                    7503   ; OS_EventTaskRemove(OSTCBCur, pevent);
00002A3E  2F04      7504          move.l    D4,-(A7)
00002A40  2F12      7505          move.l    (A2),-(A7)
00002A42  4EB8 1534 7506          jsr       _OS_EventTaskRemove
00002A46  504F      7507          addq.w    #8,A7
                    7508   ; pmsg = (void *)0;
00002A48  4282      7509          clr.l     D2
                    7510   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00002A4A  2043      7511          move.l    D3,A0
00002A4C  10BC 000A 7512          move.b    #10,(A0)
                    7513   ; break;
                    7514   OSMboxPend_11:
                    7515   ; }
                    7516   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00002A50  2052      7517          move.l    (A2),A0
00002A52  4228 0032 7518          clr.b     50(A0)
                    7519   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00002A56  2052      7520          move.l    (A2),A0
00002A58  4228 0033 7521          clr.b     51(A0)
                    7522   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002A5C  2052      7523          move.l    (A2),A0
00002A5E  42A8 001C 7524          clr.l     28(A0)
                    7525   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7526   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00002A62  2052      7527          move.l    (A2),A0
00002A64  42A8 0020 7528          clr.l     32(A0)
                    7529   ; #endif
                    7530   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002A68  2052      7531          move.l    (A2),A0
00002A6A  42A8 0024 7532          clr.l     36(A0)
                    7533   ; OS_EXIT_CRITICAL();
00002A6E  46DF      7534          dc.w      18143
                    7535   ; return (pmsg);                                    /* Return received message                       */
00002A70  2002      7536          move.l    D2,D0
                    7537   OSMboxPend_3:
00002A72  4CDF 041C 7538          movem.l   (A7)+,D2/D3/D4/A2
00002A76  4E5E      7539          unlk      A6
00002A78  4E75      7540          rts
                    7541   ; }
                    7542   ; /*$PAGE*/
                    7543   ; /*
                    7544   ; *********************************************************************************************************
                    7545   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7546   ; *
                    7547   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7548   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7549   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7550   ; *
                    7551   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7552   ; *
                    7553   ; *              opt           determines the type of ABORT performed:
                    7554   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7555   ; *                                                     mailbox
                    7556   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7557   ; *                                                     mailbox
                    7558   ; *
                    7559   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7560   ; *                            messages are:
                    7561   ; *
                    7562   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7563   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7564   ; *                                                and informed of the aborted wait; check return value
                    7565   ; *                                                for the number of tasks whose wait on the mailbox
                    7566   ; *                                                was aborted.
                    7567   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7568   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7569   ; *
                    7570   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7571   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7572   ; *********************************************************************************************************
                    7573   ; */
                    7574   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7575   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7576   ; INT8U      opt,
                    7577   ; INT8U     *perr)
                    7578   ; {
                    7579   _OSMboxPendAbort:
00002A7A  4E56 0000 7580          link      A6,#0
00002A7E  48E7 3800 7581          movem.l   D2/D3/D4,-(A7)
00002A82  242E 0008 7582          move.l    8(A6),D2
00002A86  282E 0010 7583          move.l    16(A6),D4
                    7584   ; INT8U      nbr_tasks;
                    7585   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7586   ; OS_CPU_SR  cpu_sr = 0u;
                    7587   ; #endif
                    7588   ; #ifdef OS_SAFETY_CRITICAL
                    7589   ; if (perr == (INT8U *)0) {
                    7590   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7591   ; return (0u);
                    7592   ; }
                    7593   ; #endif
                    7594   ; #if OS_ARG_CHK_EN > 0u
                    7595   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7596   ; *perr = OS_ERR_PEVENT_NULL;
                    7597   ; return (0u);
                    7598   ; }
                    7599   ; #endif
                    7600   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002A8A  2042      7601          move.l    D2,A0
00002A8C  1010      7602          move.b    (A0),D0
00002A8E  0C00 0001 7603          cmp.b     #1,D0
00002A92  670C      7604          beq.s     OSMboxPendAbort_1
                    7605   ; *perr = OS_ERR_EVENT_TYPE;
00002A94  2044      7606          move.l    D4,A0
00002A96  10BC 0001 7607          move.b    #1,(A0)
                    7608   ; return (0u);
00002A9A  4200      7609          clr.b     D0
00002A9C  6000 008C 7610          bra       OSMboxPendAbort_3
                    7611   OSMboxPendAbort_1:
                    7612   ; }
                    7613   ; OS_ENTER_CRITICAL();
00002AA0  40E7      7614          dc.w      16615
00002AA2  007C      7615          dc.w      124
00002AA4  0700      7616          dc.w      1792
                    7617   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
00002AA6  2042      7618          move.l    D2,A0
00002AA8  1028 0008 7619          move.b    8(A0),D0
00002AAC  6700 0074 7620          beq       OSMboxPendAbort_4
                    7621   ; nbr_tasks = 0u;
00002AB0  4203      7622          clr.b     D3
                    7623   ; switch (opt) {
00002AB2  102E 000F 7624          move.b    15(A6),D0
00002AB6  C0BC 0000 7625          and.l     #255,D0
00002ABA  00FF      
00002ABC  0C80 0000 7626          cmp.l     #1,D0
00002AC0  0001      
00002AC2  670A      7627          beq.s     OSMboxPendAbort_8
00002AC4  6200 0030 7628          bhi       OSMboxPendAbort_9
00002AC8  4A80      7629          tst.l     D0
00002ACA  672A      7630          beq.s     OSMboxPendAbort_9
00002ACC  6028      7631          bra.s     OSMboxPendAbort_9
                    7632   OSMboxPendAbort_8:
                    7633   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7634   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7635   OSMboxPendAbort_11:
00002ACE  2042      7636          move.l    D2,A0
00002AD0  1028 0008 7637          move.b    8(A0),D0
00002AD4  671E      7638          beq.s     OSMboxPendAbort_13
                    7639   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002AD6  4878 0002 7640          pea       2
00002ADA  4878 0002 7641          pea       2
00002ADE  42A7      7642          clr.l     -(A7)
00002AE0  2F02      7643          move.l    D2,-(A7)
00002AE2  4EB8 132E 7644          jsr       _OS_EventTaskRdy
00002AE6  DEFC 0010 7645          add.w     #16,A7
00002AEA  C0BC 0000 7646          and.l     #255,D0
00002AEE  00FF      
                    7647   ; nbr_tasks++;
00002AF0  5203      7648          addq.b    #1,D3
00002AF2  60DA      7649          bra       OSMboxPendAbort_11
                    7650   OSMboxPendAbort_13:
                    7651   ; }
                    7652   ; break;
00002AF4  601C      7653          bra.s     OSMboxPendAbort_7
                    7654   OSMboxPendAbort_9:
                    7655   ; case OS_PEND_OPT_NONE:
                    7656   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7657   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002AF6  4878 0002 7658          pea       2
00002AFA  4878 0002 7659          pea       2
00002AFE  42A7      7660          clr.l     -(A7)
00002B00  2F02      7661          move.l    D2,-(A7)
00002B02  4EB8 132E 7662          jsr       _OS_EventTaskRdy
00002B06  DEFC 0010 7663          add.w     #16,A7
00002B0A  C0BC 0000 7664          and.l     #255,D0
00002B0E  00FF      
                    7665   ; nbr_tasks++;
00002B10  5203      7666          addq.b    #1,D3
                    7667   ; break;
                    7668   OSMboxPendAbort_7:
                    7669   ; }
                    7670   ; OS_EXIT_CRITICAL();
00002B12  46DF      7671          dc.w      18143
                    7672   ; OS_Sched();                                        /* Find HPT ready to run                    */
00002B14  4EB8 190E 7673          jsr       _OS_Sched
                    7674   ; *perr = OS_ERR_PEND_ABORT;
00002B18  2044      7675          move.l    D4,A0
00002B1A  10BC 000E 7676          move.b    #14,(A0)
                    7677   ; return (nbr_tasks);
00002B1E  1003      7678          move.b    D3,D0
00002B20  6008      7679          bra.s     OSMboxPendAbort_3
                    7680   OSMboxPendAbort_4:
                    7681   ; }
                    7682   ; OS_EXIT_CRITICAL();
00002B22  46DF      7683          dc.w      18143
                    7684   ; *perr = OS_ERR_NONE;
00002B24  2044      7685          move.l    D4,A0
00002B26  4210      7686          clr.b     (A0)
                    7687   ; return (0u);                                           /* No tasks waiting on mailbox              */
00002B28  4200      7688          clr.b     D0
                    7689   OSMboxPendAbort_3:
00002B2A  4CDF 001C 7690          movem.l   (A7)+,D2/D3/D4
00002B2E  4E5E      7691          unlk      A6
00002B30  4E75      7692          rts
                    7693   ; }
                    7694   ; #endif
                    7695   ; /*$PAGE*/
                    7696   ; /*
                    7697   ; *********************************************************************************************************
                    7698   ; *                                      POST MESSAGE TO A MAILBOX
                    7699   ; *
                    7700   ; * Description: This function sends a message to a mailbox
                    7701   ; *
                    7702   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7703   ; *
                    7704   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7705   ; *
                    7706   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7707   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7708   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7709   ; *                                   are allowed to send another one.
                    7710   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7711   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7712   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7713   ; *
                    7714   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7715   ; *********************************************************************************************************
                    7716   ; */
                    7717   ; #if OS_MBOX_POST_EN > 0u
                    7718   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7719   ; void      *pmsg)
                    7720   ; {
                    7721   _OSMboxPost:
00002B32  4E56 0000 7722          link      A6,#0
00002B36  2F02      7723          move.l    D2,-(A7)
00002B38  242E 0008 7724          move.l    8(A6),D2
                    7725   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7726   ; OS_CPU_SR  cpu_sr = 0u;
                    7727   ; #endif
                    7728   ; #if OS_ARG_CHK_EN > 0u
                    7729   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7730   ; return (OS_ERR_PEVENT_NULL);
                    7731   ; }
                    7732   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7733   ; return (OS_ERR_POST_NULL_PTR);
                    7734   ; }
                    7735   ; #endif
                    7736   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002B3C  2042      7737          move.l    D2,A0
00002B3E  1010      7738          move.b    (A0),D0
00002B40  0C00 0001 7739          cmp.b     #1,D0
00002B44  6706      7740          beq.s     OSMboxPost_1
                    7741   ; return (OS_ERR_EVENT_TYPE);
00002B46  7001      7742          moveq     #1,D0
00002B48  6000 004E 7743          bra       OSMboxPost_3
                    7744   OSMboxPost_1:
                    7745   ; }
                    7746   ; OS_ENTER_CRITICAL();
00002B4C  40E7      7747          dc.w      16615
00002B4E  007C      7748          dc.w      124
00002B50  0700      7749          dc.w      1792
                    7750   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002B52  2042      7751          move.l    D2,A0
00002B54  1028 0008 7752          move.b    8(A0),D0
00002B58  6724      7753          beq.s     OSMboxPost_4
                    7754   ; /* Ready HPT waiting on event                    */
                    7755   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002B5A  42A7      7756          clr.l     -(A7)
00002B5C  4878 0002 7757          pea       2
00002B60  2F2E 000C 7758          move.l    12(A6),-(A7)
00002B64  2F02      7759          move.l    D2,-(A7)
00002B66  4EB8 132E 7760          jsr       _OS_EventTaskRdy
00002B6A  DEFC 0010 7761          add.w     #16,A7
00002B6E  C0BC 0000 7762          and.l     #255,D0
00002B72  00FF      
                    7763   ; OS_EXIT_CRITICAL();
00002B74  46DF      7764          dc.w      18143
                    7765   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002B76  4EB8 190E 7766          jsr       _OS_Sched
                    7767   ; return (OS_ERR_NONE);
00002B7A  4200      7768          clr.b     D0
00002B7C  601A      7769          bra.s     OSMboxPost_3
                    7770   OSMboxPost_4:
                    7771   ; }
                    7772   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002B7E  2042      7773          move.l    D2,A0
00002B80  2028 0002 7774          move.l    2(A0),D0
00002B84  6706      7775          beq.s     OSMboxPost_6
                    7776   ; OS_EXIT_CRITICAL();
00002B86  46DF      7777          dc.w      18143
                    7778   ; return (OS_ERR_MBOX_FULL);
00002B88  7014      7779          moveq     #20,D0
00002B8A  600C      7780          bra.s     OSMboxPost_3
                    7781   OSMboxPost_6:
                    7782   ; }
                    7783   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002B8C  2042      7784          move.l    D2,A0
00002B8E  216E 000C 7785          move.l    12(A6),2(A0)
00002B92  0002      
                    7786   ; OS_EXIT_CRITICAL();
00002B94  46DF      7787          dc.w      18143
                    7788   ; return (OS_ERR_NONE);
00002B96  4200      7789          clr.b     D0
                    7790   OSMboxPost_3:
00002B98  241F      7791          move.l    (A7)+,D2
00002B9A  4E5E      7792          unlk      A6
00002B9C  4E75      7793          rts
                    7794   ; }
                    7795   ; #endif
                    7796   ; /*$PAGE*/
                    7797   ; /*
                    7798   ; *********************************************************************************************************
                    7799   ; *                                      POST MESSAGE TO A MAILBOX
                    7800   ; *
                    7801   ; * Description: This function sends a message to a mailbox
                    7802   ; *
                    7803   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7804   ; *
                    7805   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7806   ; *
                    7807   ; *              opt           determines the type of POST performed:
                    7808   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7809   ; *                                                     (Identical to OSMboxPost())
                    7810   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7811   ; *
                    7812   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7813   ; *
                    7814   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7815   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7816   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7817   ; *                                   are allowed to send another one.
                    7818   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7819   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7820   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7821   ; *
                    7822   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7823   ; *
                    7824   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7825   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7826   ; *********************************************************************************************************
                    7827   ; */
                    7828   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7829   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7830   ; void      *pmsg,
                    7831   ; INT8U      opt)
                    7832   ; {
                    7833   _OSMboxPostOpt:
00002B9E  4E56 0000 7834          link      A6,#0
00002BA2  48E7 3000 7835          movem.l   D2/D3,-(A7)
00002BA6  242E 0008 7836          move.l    8(A6),D2
00002BAA  262E 000C 7837          move.l    12(A6),D3
                    7838   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7839   ; OS_CPU_SR  cpu_sr = 0u;
                    7840   ; #endif
                    7841   ; #if OS_ARG_CHK_EN > 0u
                    7842   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7843   ; return (OS_ERR_PEVENT_NULL);
                    7844   ; }
                    7845   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7846   ; return (OS_ERR_POST_NULL_PTR);
                    7847   ; }
                    7848   ; #endif
                    7849   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002BAE  2042      7850          move.l    D2,A0
00002BB0  1010      7851          move.b    (A0),D0
00002BB2  0C00 0001 7852          cmp.b     #1,D0
00002BB6  6706      7853          beq.s     OSMboxPostOpt_1
                    7854   ; return (OS_ERR_EVENT_TYPE);
00002BB8  7001      7855          moveq     #1,D0
00002BBA  6000 0084 7856          bra       OSMboxPostOpt_3
                    7857   OSMboxPostOpt_1:
                    7858   ; }
                    7859   ; OS_ENTER_CRITICAL();
00002BBE  40E7      7860          dc.w      16615
00002BC0  007C      7861          dc.w      124
00002BC2  0700      7862          dc.w      1792
                    7863   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
00002BC4  2042      7864          move.l    D2,A0
00002BC6  1028 0008 7865          move.b    8(A0),D0
00002BCA  6700 005C 7866          beq       OSMboxPostOpt_4
                    7867   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00002BCE  102E 0013 7868          move.b    19(A6),D0
00002BD2  C03C 0001 7869          and.b     #1,D0
00002BD6  6724      7870          beq.s     OSMboxPostOpt_6
                    7871   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7872   OSMboxPostOpt_8:
00002BD8  2042      7873          move.l    D2,A0
00002BDA  1028 0008 7874          move.b    8(A0),D0
00002BDE  671A      7875          beq.s     OSMboxPostOpt_10
                    7876   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002BE0  42A7      7877          clr.l     -(A7)
00002BE2  4878 0002 7878          pea       2
00002BE6  2F03      7879          move.l    D3,-(A7)
00002BE8  2F02      7880          move.l    D2,-(A7)
00002BEA  4EB8 132E 7881          jsr       _OS_EventTaskRdy
00002BEE  DEFC 0010 7882          add.w     #16,A7
00002BF2  C0BC 0000 7883          and.l     #255,D0
00002BF6  00FF      
00002BF8  60DE      7884          bra       OSMboxPostOpt_8
                    7885   OSMboxPostOpt_10:
00002BFA  6018      7886          bra.s     OSMboxPostOpt_7
                    7887   OSMboxPostOpt_6:
                    7888   ; }
                    7889   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7890   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002BFC  42A7      7891          clr.l     -(A7)
00002BFE  4878 0002 7892          pea       2
00002C02  2F03      7893          move.l    D3,-(A7)
00002C04  2F02      7894          move.l    D2,-(A7)
00002C06  4EB8 132E 7895          jsr       _OS_EventTaskRdy
00002C0A  DEFC 0010 7896          add.w     #16,A7
00002C0E  C0BC 0000 7897          and.l     #255,D0
00002C12  00FF      
                    7898   OSMboxPostOpt_7:
                    7899   ; }
                    7900   ; OS_EXIT_CRITICAL();
00002C14  46DF      7901          dc.w      18143
                    7902   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00002C16  102E 0013 7903          move.b    19(A6),D0
00002C1A  C03C 0004 7904          and.b     #4,D0
00002C1E  6604      7905          bne.s     OSMboxPostOpt_11
                    7906   ; OS_Sched();                               /* Find HPT ready to run                         */
00002C20  4EB8 190E 7907          jsr       _OS_Sched
                    7908   OSMboxPostOpt_11:
                    7909   ; }
                    7910   ; return (OS_ERR_NONE);
00002C24  4200      7911          clr.b     D0
00002C26  6018      7912          bra.s     OSMboxPostOpt_3
                    7913   OSMboxPostOpt_4:
                    7914   ; }
                    7915   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002C28  2042      7916          move.l    D2,A0
00002C2A  2028 0002 7917          move.l    2(A0),D0
00002C2E  6706      7918          beq.s     OSMboxPostOpt_13
                    7919   ; OS_EXIT_CRITICAL();
00002C30  46DF      7920          dc.w      18143
                    7921   ; return (OS_ERR_MBOX_FULL);
00002C32  7014      7922          moveq     #20,D0
00002C34  600A      7923          bra.s     OSMboxPostOpt_3
                    7924   OSMboxPostOpt_13:
                    7925   ; }
                    7926   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002C36  2042      7927          move.l    D2,A0
00002C38  2143 0002 7928          move.l    D3,2(A0)
                    7929   ; OS_EXIT_CRITICAL();
00002C3C  46DF      7930          dc.w      18143
                    7931   ; return (OS_ERR_NONE);
00002C3E  4200      7932          clr.b     D0
                    7933   OSMboxPostOpt_3:
00002C40  4CDF 000C 7934          movem.l   (A7)+,D2/D3
00002C44  4E5E      7935          unlk      A6
00002C46  4E75      7936          rts
                    7937   ; }
                    7938   ; #endif
                    7939   ; /*$PAGE*/
                    7940   ; /*
                    7941   ; *********************************************************************************************************
                    7942   ; *                                       QUERY A MESSAGE MAILBOX
                    7943   ; *
                    7944   ; * Description: This function obtains information about a message mailbox.
                    7945   ; *
                    7946   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7947   ; *
                    7948   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7949   ; *                            mailbox.
                    7950   ; *
                    7951   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7952   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7953   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7954   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7955   ; *********************************************************************************************************
                    7956   ; */
                    7957   ; #if OS_MBOX_QUERY_EN > 0u
                    7958   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7959   ; OS_MBOX_DATA  *p_mbox_data)
                    7960   ; {
                    7961   _OSMboxQuery:
00002C48  4E56 FFF8 7962          link      A6,#-8
00002C4C  48E7 3800 7963          movem.l   D2/D3/D4,-(A7)
00002C50  242E 0008 7964          move.l    8(A6),D2
00002C54  282E 000C 7965          move.l    12(A6),D4
                    7966   ; INT8U       i;
                    7967   ; OS_PRIO    *psrc;
                    7968   ; OS_PRIO    *pdest;
                    7969   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7970   ; OS_CPU_SR   cpu_sr = 0u;
                    7971   ; #endif
                    7972   ; #if OS_ARG_CHK_EN > 0u
                    7973   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7974   ; return (OS_ERR_PEVENT_NULL);
                    7975   ; }
                    7976   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7977   ; return (OS_ERR_PDATA_NULL);
                    7978   ; }
                    7979   ; #endif
                    7980   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002C58  2042      7981          move.l    D2,A0
00002C5A  1010      7982          move.b    (A0),D0
00002C5C  0C00 0001 7983          cmp.b     #1,D0
00002C60  6706      7984          beq.s     OSMboxQuery_1
                    7985   ; return (OS_ERR_EVENT_TYPE);
00002C62  7001      7986          moveq     #1,D0
00002C64  6000 004C 7987          bra       OSMboxQuery_3
                    7988   OSMboxQuery_1:
                    7989   ; }
                    7990   ; OS_ENTER_CRITICAL();
00002C68  40E7      7991          dc.w      16615
00002C6A  007C      7992          dc.w      124
00002C6C  0700      7993          dc.w      1792
                    7994   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
00002C6E  2042      7995          move.l    D2,A0
00002C70  2244      7996          move.l    D4,A1
00002C72  1368 0008 7997          move.b    8(A0),12(A1)
00002C76  000C      
                    7998   ; psrc                    = &pevent->OSEventTbl[0];
00002C78  700A      7999          moveq     #10,D0
00002C7A  D082      8000          add.l     D2,D0
00002C7C  2D40 FFF8 8001          move.l    D0,-8(A6)
                    8002   ; pdest                   = &p_mbox_data->OSEventTbl[0];
00002C80  7004      8003          moveq     #4,D0
00002C82  D084      8004          add.l     D4,D0
00002C84  2D40 FFFC 8005          move.l    D0,-4(A6)
                    8006   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002C88  4203      8007          clr.b     D3
                    8008   OSMboxQuery_4:
00002C8A  0C03 0008 8009          cmp.b     #8,D3
00002C8E  6416      8010          bhs.s     OSMboxQuery_6
                    8011   ; *pdest++ = *psrc++;
00002C90  206E FFF8 8012          move.l    -8(A6),A0
00002C94  52AE FFF8 8013          addq.l    #1,-8(A6)
00002C98  226E FFFC 8014          move.l    -4(A6),A1
00002C9C  52AE FFFC 8015          addq.l    #1,-4(A6)
00002CA0  1290      8016          move.b    (A0),(A1)
00002CA2  5203      8017          addq.b    #1,D3
00002CA4  60E4      8018          bra       OSMboxQuery_4
                    8019   OSMboxQuery_6:
                    8020   ; }
                    8021   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002CA6  2042      8022          move.l    D2,A0
00002CA8  2244      8023          move.l    D4,A1
00002CAA  22A8 0002 8024          move.l    2(A0),(A1)
                    8025   ; OS_EXIT_CRITICAL();
00002CAE  46DF      8026          dc.w      18143
                    8027   ; return (OS_ERR_NONE);
00002CB0  4200      8028          clr.b     D0
                    8029   OSMboxQuery_3:
00002CB2  4CDF 001C 8030          movem.l   (A7)+,D2/D3/D4
00002CB6  4E5E      8031          unlk      A6
00002CB8  4E75      8032          rts
                    8033   ; /*
                    8034   ; *********************************************************************************************************
                    8035   ; *                                                uC/OS-II
                    8036   ; *                                          The Real-Time Kernel
                    8037   ; *                                            MEMORY MANAGEMENT
                    8038   ; *
                    8039   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8040   ; *                                           All Rights Reserved
                    8041   ; *
                    8042   ; * File    : OS_MEM.C
                    8043   ; * By      : Jean J. Labrosse
                    8044   ; * Version : V2.92.07
                    8045   ; *
                    8046   ; * LICENSING TERMS:
                    8047   ; * ---------------
                    8048   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8049   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8050   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8051   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8052   ; * licensing fee.
                    8053   ; *********************************************************************************************************
                    8054   ; */
                    8055   ; #define  MICRIUM_SOURCE
                    8056   ; #ifndef  OS_MASTER_FILE
                    8057   ; #include <ucos_ii.h>
                    8058   ; #endif
                    8059   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    8060   ; /*
                    8061   ; *********************************************************************************************************
                    8062   ; *                                      CREATE A MEMORY PARTITION
                    8063   ; *
                    8064   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    8065   ; *
                    8066   ; * Arguments   : addr     is the starting address of the memory partition
                    8067   ; *
                    8068   ; *               nblks    is the number of memory blocks to create from the partition.
                    8069   ; *
                    8070   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    8071   ; *
                    8072   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    8073   ; *                        this function to either:
                    8074   ; *
                    8075   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    8076   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    8077   ; *                                                 storage of the partition or, the block does not align
                    8078   ; *                                                 on a pointer boundary
                    8079   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    8080   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    8081   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    8082   ; *                                                   - must be greater than the size of a pointer
                    8083   ; *                                                   - must be able to hold an integral number of pointers
                    8084   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    8085   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    8086   ; *                              free partition is available.
                    8087   ; *********************************************************************************************************
                    8088   ; */
                    8089   ; OS_MEM  *OSMemCreate (void   *addr,
                    8090   ; INT32U  nblks,
                    8091   ; INT32U  blksize,
                    8092   ; INT8U  *perr)
                    8093   ; {
                    8094   _OSMemCreate:
00002CBA  4E56 FFFC 8095          link      A6,#-4
00002CBE  48E7 3F20 8096          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002CC2  282E 0008 8097          move.l    8(A6),D4
00002CC6  45F9 0800 8098          lea       _OSMemFreeList.L,A2
00002CCA  16AE      
00002CCC  2E2E 000C 8099          move.l    12(A6),D7
                    8100   ; OS_MEM    *pmem;
                    8101   ; INT8U     *pblk;
                    8102   ; void     **plink;
                    8103   ; INT32U     loops;
                    8104   ; INT32U     i;
                    8105   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8106   ; OS_CPU_SR  cpu_sr = 0u;
                    8107   ; #endif
                    8108   ; #ifdef OS_SAFETY_CRITICAL
                    8109   ; if (perr == (INT8U *)0) {
                    8110   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8111   ; return ((OS_MEM *)0);
                    8112   ; }
                    8113   ; #endif
                    8114   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8115   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8116   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8117   ; return ((OS_MEM *)0);
                    8118   ; }
                    8119   ; #endif
                    8120   ; #if OS_ARG_CHK_EN > 0u
                    8121   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    8122   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8123   ; return ((OS_MEM *)0);
                    8124   ; }
                    8125   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    8126   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    8127   ; return ((OS_MEM *)0);
                    8128   ; }
                    8129   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    8130   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    8131   ; return ((OS_MEM *)0);
                    8132   ; }
                    8133   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    8134   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    8135   ; return ((OS_MEM *)0);
                    8136   ; }
                    8137   ; #endif
                    8138   ; OS_ENTER_CRITICAL();
00002CD0  40E7      8139          dc.w      16615
00002CD2  007C      8140          dc.w      124
00002CD4  0700      8141          dc.w      1792
                    8142   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
00002CD6  2412      8143          move.l    (A2),D2
                    8144   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
00002CD8  2012      8145          move.l    (A2),D0
00002CDA  6706      8146          beq.s     OSMemCreate_1
                    8147   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
00002CDC  2052      8148          move.l    (A2),A0
00002CDE  24A8 0004 8149          move.l    4(A0),(A2)
                    8150   OSMemCreate_1:
                    8151   ; }
                    8152   ; OS_EXIT_CRITICAL();
00002CE2  46DF      8153          dc.w      18143
                    8154   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
00002CE4  4A82      8155          tst.l     D2
00002CE6  660E      8156          bne.s     OSMemCreate_3
                    8157   ; *perr = OS_ERR_MEM_INVALID_PART;
00002CE8  206E 0014 8158          move.l    20(A6),A0
00002CEC  10BC 005A 8159          move.b    #90,(A0)
                    8160   ; return ((OS_MEM *)0);
00002CF0  4280      8161          clr.l     D0
00002CF2  6000 0050 8162          bra       OSMemCreate_5
                    8163   OSMemCreate_3:
                    8164   ; }
                    8165   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
00002CF6  2A04      8166          move.l    D4,D5
                    8167   ; pblk  = (INT8U *)addr;
00002CF8  2604      8168          move.l    D4,D3
                    8169   ; loops  = nblks - 1u;
00002CFA  2007      8170          move.l    D7,D0
00002CFC  5380      8171          subq.l    #1,D0
00002CFE  2D40 FFFC 8172          move.l    D0,-4(A6)
                    8173   ; for (i = 0u; i < loops; i++) {
00002D02  4286      8174          clr.l     D6
                    8175   OSMemCreate_6:
00002D04  BCAE FFFC 8176          cmp.l     -4(A6),D6
00002D08  6410      8177          bhs.s     OSMemCreate_8
                    8178   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
00002D0A  202E 0010 8179          move.l    16(A6),D0
00002D0E  D680      8180          add.l     D0,D3
                    8181   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
00002D10  2045      8182          move.l    D5,A0
00002D12  2083      8183          move.l    D3,(A0)
                    8184   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
00002D14  2A03      8185          move.l    D3,D5
00002D16  5286      8186          addq.l    #1,D6
00002D18  60EA      8187          bra       OSMemCreate_6
                    8188   OSMemCreate_8:
                    8189   ; }
                    8190   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
00002D1A  2045      8191          move.l    D5,A0
00002D1C  4290      8192          clr.l     (A0)
                    8193   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
00002D1E  2042      8194          move.l    D2,A0
00002D20  2084      8195          move.l    D4,(A0)
                    8196   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
00002D22  2042      8197          move.l    D2,A0
00002D24  2144 0004 8198          move.l    D4,4(A0)
                    8199   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
00002D28  2042      8200          move.l    D2,A0
00002D2A  2147 0010 8201          move.l    D7,16(A0)
                    8202   ; pmem->OSMemNBlks    = nblks;
00002D2E  2042      8203          move.l    D2,A0
00002D30  2147 000C 8204          move.l    D7,12(A0)
                    8205   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
00002D34  2042      8206          move.l    D2,A0
00002D36  216E 0010 8207          move.l    16(A6),8(A0)
00002D3A  0008      
                    8208   ; *perr               = OS_ERR_NONE;
00002D3C  206E 0014 8209          move.l    20(A6),A0
00002D40  4210      8210          clr.b     (A0)
                    8211   ; return (pmem);
00002D42  2002      8212          move.l    D2,D0
                    8213   OSMemCreate_5:
00002D44  4CDF 04FC 8214          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002D48  4E5E      8215          unlk      A6
00002D4A  4E75      8216          rts
                    8217   ; }
                    8218   ; /*$PAGE*/
                    8219   ; /*
                    8220   ; *********************************************************************************************************
                    8221   ; *                                         GET A MEMORY BLOCK
                    8222   ; *
                    8223   ; * Description : Get a memory block from a partition
                    8224   ; *
                    8225   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8226   ; *
                    8227   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    8228   ; *                       function to either:
                    8229   ; *
                    8230   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    8231   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    8232   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    8233   ; *
                    8234   ; * Returns     : A pointer to a memory block if no error is detected
                    8235   ; *               A pointer to NULL if an error is detected
                    8236   ; *********************************************************************************************************
                    8237   ; */
                    8238   ; void  *OSMemGet (OS_MEM  *pmem,
                    8239   ; INT8U   *perr)
                    8240   ; {
                    8241   _OSMemGet:
00002D4C  4E56 0000 8242          link      A6,#0
00002D50  48E7 3000 8243          movem.l   D2/D3,-(A7)
00002D54  242E 0008 8244          move.l    8(A6),D2
                    8245   ; void      *pblk;
                    8246   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    8247   ; OS_CPU_SR  cpu_sr = 0u;
                    8248   ; #endif
                    8249   ; #ifdef OS_SAFETY_CRITICAL
                    8250   ; if (perr == (INT8U *)0) {
                    8251   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8252   ; return ((void *)0);
                    8253   ; }
                    8254   ; #endif
                    8255   ; #if OS_ARG_CHK_EN > 0u
                    8256   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    8257   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8258   ; return ((void *)0);
                    8259   ; }
                    8260   ; #endif
                    8261   ; OS_ENTER_CRITICAL();
00002D58  40E7      8262          dc.w      16615
00002D5A  007C      8263          dc.w      124
00002D5C  0700      8264          dc.w      1792
                    8265   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002D5E  2042      8266          move.l    D2,A0
00002D60  2028 0010 8267          move.l    16(A0),D0
00002D64  0C80 0000 8268          cmp.l     #0,D0
00002D68  0000      
00002D6A  6326      8269          bls.s     OSMemGet_1
                    8270   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002D6C  2042      8271          move.l    D2,A0
00002D6E  2628 0004 8272          move.l    4(A0),D3
                    8273   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
00002D72  2043      8274          move.l    D3,A0
00002D74  2242      8275          move.l    D2,A1
00002D76  2350 0004 8276          move.l    (A0),4(A1)
                    8277   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002D7A  2002      8278          move.l    D2,D0
00002D7C  0680 0000 8279          add.l     #16,D0
00002D80  0010      
00002D82  2040      8280          move.l    D0,A0
00002D84  5390      8281          subq.l    #1,(A0)
                    8282   ; OS_EXIT_CRITICAL();
00002D86  46DF      8283          dc.w      18143
                    8284   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002D88  206E 000C 8285          move.l    12(A6),A0
00002D8C  4210      8286          clr.b     (A0)
                    8287   ; return (pblk);                                /*      Return memory block to caller            */
00002D8E  2003      8288          move.l    D3,D0
00002D90  600C      8289          bra.s     OSMemGet_3
                    8290   OSMemGet_1:
                    8291   ; }
                    8292   ; OS_EXIT_CRITICAL();
00002D92  46DF      8293          dc.w      18143
                    8294   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
00002D94  206E 000C 8295          move.l    12(A6),A0
00002D98  10BC 005D 8296          move.b    #93,(A0)
                    8297   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002D9C  4280      8298          clr.l     D0
                    8299   OSMemGet_3:
00002D9E  4CDF 000C 8300          movem.l   (A7)+,D2/D3
00002DA2  4E5E      8301          unlk      A6
00002DA4  4E75      8302          rts
                    8303   ; }
                    8304   ; /*$PAGE*/
                    8305   ; /*
                    8306   ; *********************************************************************************************************
                    8307   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    8308   ; *
                    8309   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    8310   ; *
                    8311   ; * Arguments  : pmem      is a pointer to the memory partition
                    8312   ; *
                    8313   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    8314   ; *
                    8315   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8316   ; *
                    8317   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8318   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8319   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8320   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    8321   ; *
                    8322   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    8323   ; *********************************************************************************************************
                    8324   ; */
                    8325   ; #if OS_MEM_NAME_EN > 0u
                    8326   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    8327   ; INT8U   **pname,
                    8328   ; INT8U    *perr)
                    8329   ; {
                    8330   _OSMemNameGet:
00002DA6  4E56 FFFC 8331          link      A6,#-4
                    8332   ; INT8U      len;
                    8333   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8334   ; OS_CPU_SR  cpu_sr = 0u;
                    8335   ; #endif
                    8336   ; #ifdef OS_SAFETY_CRITICAL
                    8337   ; if (perr == (INT8U *)0) {
                    8338   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8339   ; return (0u);
                    8340   ; }
                    8341   ; #endif
                    8342   ; #if OS_ARG_CHK_EN > 0u
                    8343   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8344   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8345   ; return (0u);
                    8346   ; }
                    8347   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    8348   ; *perr = OS_ERR_PNAME_NULL;
                    8349   ; return (0u);
                    8350   ; }
                    8351   ; #endif
                    8352   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002DAA  1039 0800 8353          move.b    _OSIntNesting.L,D0
00002DAE  0D20      
00002DB0  0C00 0000 8354          cmp.b     #0,D0
00002DB4  630C      8355          bls.s     OSMemNameGet_1
                    8356   ; *perr = OS_ERR_NAME_GET_ISR;
00002DB6  206E 0010 8357          move.l    16(A6),A0
00002DBA  10BC 0011 8358          move.b    #17,(A0)
                    8359   ; return (0u);
00002DBE  4200      8360          clr.b     D0
00002DC0  602E      8361          bra.s     OSMemNameGet_3
                    8362   OSMemNameGet_1:
                    8363   ; }
                    8364   ; OS_ENTER_CRITICAL();
00002DC2  40E7      8365          dc.w      16615
00002DC4  007C      8366          dc.w      124
00002DC6  0700      8367          dc.w      1792
                    8368   ; *pname = pmem->OSMemName;
00002DC8  206E 0008 8369          move.l    8(A6),A0
00002DCC  226E 000C 8370          move.l    12(A6),A1
00002DD0  22A8 0014 8371          move.l    20(A0),(A1)
                    8372   ; len    = OS_StrLen(*pname);
00002DD4  206E 000C 8373          move.l    12(A6),A0
00002DD8  2F10      8374          move.l    (A0),-(A7)
00002DDA  4EB8 19B8 8375          jsr       _OS_StrLen
00002DDE  584F      8376          addq.w    #4,A7
00002DE0  1D40 FFFF 8377          move.b    D0,-1(A6)
                    8378   ; OS_EXIT_CRITICAL();
00002DE4  46DF      8379          dc.w      18143
                    8380   ; *perr  = OS_ERR_NONE;
00002DE6  206E 0010 8381          move.l    16(A6),A0
00002DEA  4210      8382          clr.b     (A0)
                    8383   ; return (len);
00002DEC  102E FFFF 8384          move.b    -1(A6),D0
                    8385   OSMemNameGet_3:
00002DF0  4E5E      8386          unlk      A6
00002DF2  4E75      8387          rts
                    8388   ; }
                    8389   ; #endif
                    8390   ; /*$PAGE*/
                    8391   ; /*
                    8392   ; *********************************************************************************************************
                    8393   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    8394   ; *
                    8395   ; * Description: This function assigns a name to a memory partition.
                    8396   ; *
                    8397   ; * Arguments  : pmem      is a pointer to the memory partition
                    8398   ; *
                    8399   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    8400   ; *
                    8401   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8402   ; *
                    8403   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8404   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8405   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8406   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8407   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8408   ; *
                    8409   ; * Returns    : None
                    8410   ; *********************************************************************************************************
                    8411   ; */
                    8412   ; #if OS_MEM_NAME_EN > 0u
                    8413   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8414   ; INT8U   *pname,
                    8415   ; INT8U   *perr)
                    8416   ; {
                    8417   _OSMemNameSet:
00002DF4  4E56 0000 8418          link      A6,#0
                    8419   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8420   ; OS_CPU_SR  cpu_sr = 0u;
                    8421   ; #endif
                    8422   ; #ifdef OS_SAFETY_CRITICAL
                    8423   ; if (perr == (INT8U *)0) {
                    8424   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8425   ; return;
                    8426   ; }
                    8427   ; #endif
                    8428   ; #if OS_ARG_CHK_EN > 0u
                    8429   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8430   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8431   ; return;
                    8432   ; }
                    8433   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8434   ; *perr = OS_ERR_PNAME_NULL;
                    8435   ; return;
                    8436   ; }
                    8437   ; #endif
                    8438   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002DF8  1039 0800 8439          move.b    _OSIntNesting.L,D0
00002DFC  0D20      
00002DFE  0C00 0000 8440          cmp.b     #0,D0
00002E02  630A      8441          bls.s     OSMemNameSet_1
                    8442   ; *perr = OS_ERR_NAME_SET_ISR;
00002E04  206E 0010 8443          move.l    16(A6),A0
00002E08  10BC 0012 8444          move.b    #18,(A0)
                    8445   ; return;
00002E0C  6018      8446          bra.s     OSMemNameSet_3
                    8447   OSMemNameSet_1:
                    8448   ; }
                    8449   ; OS_ENTER_CRITICAL();
00002E0E  40E7      8450          dc.w      16615
00002E10  007C      8451          dc.w      124
00002E12  0700      8452          dc.w      1792
                    8453   ; pmem->OSMemName = pname;
00002E14  206E 0008 8454          move.l    8(A6),A0
00002E18  216E 000C 8455          move.l    12(A6),20(A0)
00002E1C  0014      
                    8456   ; OS_EXIT_CRITICAL();
00002E1E  46DF      8457          dc.w      18143
                    8458   ; *perr           = OS_ERR_NONE;
00002E20  206E 0010 8459          move.l    16(A6),A0
00002E24  4210      8460          clr.b     (A0)
                    8461   OSMemNameSet_3:
00002E26  4E5E      8462          unlk      A6
00002E28  4E75      8463          rts
                    8464   ; }
                    8465   ; #endif
                    8466   ; /*$PAGE*/
                    8467   ; /*
                    8468   ; *********************************************************************************************************
                    8469   ; *                                       RELEASE A MEMORY BLOCK
                    8470   ; *
                    8471   ; * Description : Returns a memory block to a partition
                    8472   ; *
                    8473   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8474   ; *
                    8475   ; *               pblk    is a pointer to the memory block being released.
                    8476   ; *
                    8477   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8478   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8479   ; *                                        partition (You freed more blocks than you allocated!)
                    8480   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8481   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8482   ; *********************************************************************************************************
                    8483   ; */
                    8484   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8485   ; void    *pblk)
                    8486   ; {
                    8487   _OSMemPut:
00002E2A  4E56 0000 8488          link      A6,#0
00002E2E  2F02      8489          move.l    D2,-(A7)
00002E30  242E 0008 8490          move.l    8(A6),D2
                    8491   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8492   ; OS_CPU_SR  cpu_sr = 0u;
                    8493   ; #endif
                    8494   ; #if OS_ARG_CHK_EN > 0u
                    8495   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8496   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8497   ; }
                    8498   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8499   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8500   ; }
                    8501   ; #endif
                    8502   ; OS_ENTER_CRITICAL();
00002E34  40E7      8503          dc.w      16615
00002E36  007C      8504          dc.w      124
00002E38  0700      8505          dc.w      1792
                    8506   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002E3A  2042      8507          move.l    D2,A0
00002E3C  2242      8508          move.l    D2,A1
00002E3E  2028 0010 8509          move.l    16(A0),D0
00002E42  B0A9 000C 8510          cmp.l     12(A1),D0
00002E46  6506      8511          blo.s     OSMemPut_1
                    8512   ; OS_EXIT_CRITICAL();
00002E48  46DF      8513          dc.w      18143
                    8514   ; return (OS_ERR_MEM_FULL);
00002E4A  705E      8515          moveq     #94,D0
00002E4C  6024      8516          bra.s     OSMemPut_3
                    8517   OSMemPut_1:
                    8518   ; }
                    8519   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002E4E  2042      8520          move.l    D2,A0
00002E50  202E 000C 8521          move.l    12(A6),D0
00002E54  2240      8522          move.l    D0,A1
00002E56  22A8 0004 8523          move.l    4(A0),(A1)
                    8524   ; pmem->OSMemFreeList = pblk;
00002E5A  2042      8525          move.l    D2,A0
00002E5C  216E 000C 8526          move.l    12(A6),4(A0)
00002E60  0004      
                    8527   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
00002E62  2002      8528          move.l    D2,D0
00002E64  0680 0000 8529          add.l     #16,D0
00002E68  0010      
00002E6A  2040      8530          move.l    D0,A0
00002E6C  5290      8531          addq.l    #1,(A0)
                    8532   ; OS_EXIT_CRITICAL();
00002E6E  46DF      8533          dc.w      18143
                    8534   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
00002E70  4200      8535          clr.b     D0
                    8536   OSMemPut_3:
00002E72  241F      8537          move.l    (A7)+,D2
00002E74  4E5E      8538          unlk      A6
00002E76  4E75      8539          rts
                    8540   ; }
                    8541   ; /*$PAGE*/
                    8542   ; /*
                    8543   ; *********************************************************************************************************
                    8544   ; *                                       QUERY MEMORY PARTITION
                    8545   ; *
                    8546   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8547   ; *               used memory blocks from a memory partition.
                    8548   ; *
                    8549   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8550   ; *
                    8551   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8552   ; *                           partition.
                    8553   ; *
                    8554   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8555   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8556   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8557   ; *********************************************************************************************************
                    8558   ; */
                    8559   ; #if OS_MEM_QUERY_EN > 0u
                    8560   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8561   ; OS_MEM_DATA  *p_mem_data)
                    8562   ; {
                    8563   _OSMemQuery:
00002E78  4E56 0000 8564          link      A6,#0
00002E7C  48E7 3000 8565          movem.l   D2/D3,-(A7)
00002E80  242E 000C 8566          move.l    12(A6),D2
00002E84  262E 0008 8567          move.l    8(A6),D3
                    8568   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8569   ; OS_CPU_SR  cpu_sr = 0u;
                    8570   ; #endif
                    8571   ; #if OS_ARG_CHK_EN > 0u
                    8572   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8573   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8574   ; }
                    8575   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8576   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8577   ; }
                    8578   ; #endif
                    8579   ; OS_ENTER_CRITICAL();
00002E88  40E7      8580          dc.w      16615
00002E8A  007C      8581          dc.w      124
00002E8C  0700      8582          dc.w      1792
                    8583   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002E8E  2043      8584          move.l    D3,A0
00002E90  2242      8585          move.l    D2,A1
00002E92  2290      8586          move.l    (A0),(A1)
                    8587   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
00002E94  2043      8588          move.l    D3,A0
00002E96  2242      8589          move.l    D2,A1
00002E98  2368 0004 8590          move.l    4(A0),4(A1)
00002E9C  0004      
                    8591   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002E9E  2043      8592          move.l    D3,A0
00002EA0  2242      8593          move.l    D2,A1
00002EA2  2368 0008 8594          move.l    8(A0),8(A1)
00002EA6  0008      
                    8595   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002EA8  2043      8596          move.l    D3,A0
00002EAA  2242      8597          move.l    D2,A1
00002EAC  2368 000C 8598          move.l    12(A0),12(A1)
00002EB0  000C      
                    8599   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
00002EB2  2043      8600          move.l    D3,A0
00002EB4  2242      8601          move.l    D2,A1
00002EB6  2368 0010 8602          move.l    16(A0),16(A1)
00002EBA  0010      
                    8603   ; OS_EXIT_CRITICAL();
00002EBC  46DF      8604          dc.w      18143
                    8605   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
00002EBE  2042      8606          move.l    D2,A0
00002EC0  2028 000C 8607          move.l    12(A0),D0
00002EC4  2042      8608          move.l    D2,A0
00002EC6  90A8 0010 8609          sub.l     16(A0),D0
00002ECA  2042      8610          move.l    D2,A0
00002ECC  2140 0014 8611          move.l    D0,20(A0)
                    8612   ; return (OS_ERR_NONE);
00002ED0  4200      8613          clr.b     D0
00002ED2  4CDF 000C 8614          movem.l   (A7)+,D2/D3
00002ED6  4E5E      8615          unlk      A6
00002ED8  4E75      8616          rts
                    8617   ; }
                    8618   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8619   ; /*$PAGE*/
                    8620   ; /*
                    8621   ; *********************************************************************************************************
                    8622   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8623   ; *
                    8624   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8625   ; *               application MUST NOT call this function.
                    8626   ; *
                    8627   ; * Arguments   : none
                    8628   ; *
                    8629   ; * Returns     : none
                    8630   ; *
                    8631   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8632   ; *********************************************************************************************************
                    8633   ; */
                    8634   ; void  OS_MemInit (void)
                    8635   ; {
                    8636   _OS_MemInit:
00002EDA  48E7 3020 8637          movem.l   D2/D3/A2,-(A7)
00002EDE  45F9 0800 8638          lea       _OSMemTbl.L,A2
00002EE2  16B2      
                    8639   ; #if OS_MAX_MEM_PART == 1u
                    8640   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8641   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8642   ; #if OS_MEM_NAME_EN > 0u
                    8643   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8644   ; #endif
                    8645   ; #endif
                    8646   ; #if OS_MAX_MEM_PART >= 2u
                    8647   ; OS_MEM  *pmem;
                    8648   ; INT16U   i;
                    8649   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
00002EE4  4878 0078 8650          pea       120
00002EE8  2F0A      8651          move.l    A2,-(A7)
00002EEA  4EB8 18C2 8652          jsr       _OS_MemClr
00002EEE  504F      8653          addq.w    #8,A7
                    8654   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
00002EF0  4243      8655          clr.w     D3
                    8656   OS_MemInit_1:
00002EF2  0C43 0004 8657          cmp.w     #4,D3
00002EF6  6400 003C 8658          bhs       OS_MemInit_3
                    8659   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
00002EFA  200A      8660          move.l    A2,D0
00002EFC  C6BC 0000 8661          and.l     #65535,D3
00002F00  FFFF      
00002F02  2203      8662          move.l    D3,D1
00002F04  C3FC 0018 8663          muls      #24,D1
00002F08  D081      8664          add.l     D1,D0
00002F0A  2400      8665          move.l    D0,D2
                    8666   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
00002F0C  200A      8667          move.l    A2,D0
00002F0E  C6BC 0000 8668          and.l     #65535,D3
00002F12  FFFF      
00002F14  2203      8669          move.l    D3,D1
00002F16  5281      8670          addq.l    #1,D1
00002F18  C3FC 0018 8671          muls      #24,D1
00002F1C  D081      8672          add.l     D1,D0
00002F1E  2042      8673          move.l    D2,A0
00002F20  2140 0004 8674          move.l    D0,4(A0)
                    8675   ; #if OS_MEM_NAME_EN > 0u
                    8676   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00002F24  41F9 0000 8677          lea       @ucos_ii_1.L,A0
00002F28  6F2A      
00002F2A  2242      8678          move.l    D2,A1
00002F2C  2348 0014 8679          move.l    A0,20(A1)
00002F30  5243      8680          addq.w    #1,D3
00002F32  60BE      8681          bra       OS_MemInit_1
                    8682   OS_MemInit_3:
                    8683   ; #endif
                    8684   ; }
                    8685   ; pmem                = &OSMemTbl[i];
00002F34  200A      8686          move.l    A2,D0
00002F36  C6BC 0000 8687          and.l     #65535,D3
00002F3A  FFFF      
00002F3C  2203      8688          move.l    D3,D1
00002F3E  C3FC 0018 8689          muls      #24,D1
00002F42  D081      8690          add.l     D1,D0
00002F44  2400      8691          move.l    D0,D2
                    8692   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00002F46  2042      8693          move.l    D2,A0
00002F48  42A8 0004 8694          clr.l     4(A0)
                    8695   ; #if OS_MEM_NAME_EN > 0u
                    8696   ; pmem->OSMemName = (INT8U *)(void *)"?";
00002F4C  41F9 0000 8697          lea       @ucos_ii_1.L,A0
00002F50  6F2A      
00002F52  2242      8698          move.l    D2,A1
00002F54  2348 0014 8699          move.l    A0,20(A1)
                    8700   ; #endif
                    8701   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
00002F58  23CA 0800 8702          move.l    A2,_OSMemFreeList.L
00002F5C  16AE      
00002F5E  4CDF 040C 8703          movem.l   (A7)+,D2/D3/A2
00002F62  4E75      8704          rts
                    8705   ; /*
                    8706   ; *********************************************************************************************************
                    8707   ; *                                                uC/OS-II
                    8708   ; *                                          The Real-Time Kernel
                    8709   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8710   ; *
                    8711   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8712   ; *                                           All Rights Reserved
                    8713   ; *
                    8714   ; * File    : OS_MUTEX.C
                    8715   ; * By      : Jean J. Labrosse
                    8716   ; * Version : V2.92.07
                    8717   ; *
                    8718   ; * LICENSING TERMS:
                    8719   ; * ---------------
                    8720   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8721   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8722   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8723   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8724   ; * licensing fee.
                    8725   ; *********************************************************************************************************
                    8726   ; */
                    8727   ; #define  MICRIUM_SOURCE
                    8728   ; #ifndef  OS_MASTER_FILE
                    8729   ; #include <ucos_ii.h>
                    8730   ; #endif
                    8731   ; #if OS_MUTEX_EN > 0u
                    8732   ; /*
                    8733   ; *********************************************************************************************************
                    8734   ; *                                           LOCAL CONSTANTS
                    8735   ; *********************************************************************************************************
                    8736   ; */
                    8737   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8738   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8739   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8740   ; /*
                    8741   ; *********************************************************************************************************
                    8742   ; *                                           LOCAL CONSTANTS
                    8743   ; *********************************************************************************************************
                    8744   ; */
                    8745   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8746   ; /*$PAGE*/
                    8747   ; /*
                    8748   ; *********************************************************************************************************
                    8749   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8750   ; *
                    8751   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8752   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8753   ; *              not available or the event did not occur.
                    8754   ; *
                    8755   ; * Arguments  : pevent     is a pointer to the event control block
                    8756   ; *
                    8757   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8758   ; *                            OS_ERR_NONE         if the call was successful.
                    8759   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8760   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8761   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8762   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8763   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8764   ; *                                                indicates that you did not set the PCP higher (lower
                    8765   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8766   ; *                                                Unfortunately, this is something that could not be
                    8767   ; *                                                detected when the Mutex is created because we don't know
                    8768   ; *                                                what tasks will be using the Mutex.
                    8769   ; *
                    8770   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8771   ; *              == OS_FALSE   a) if the resource is not available
                    8772   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8773   ; *                            c) you called this function from an ISR
                    8774   ; *
                    8775   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8776   ; *              intended to be used by tasks only.
                    8777   ; *********************************************************************************************************
                    8778   ; */
                    8779   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8780   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8781   ; INT8U     *perr)
                    8782   ; {
                    8783   _OSMutexAccept:
00002F64  4E56 0000 8784          link      A6,#0
00002F68  48E7 3820 8785          movem.l   D2/D3/D4/A2,-(A7)
00002F6C  242E 0008 8786          move.l    8(A6),D2
00002F70  262E 000C 8787          move.l    12(A6),D3
00002F74  45F9 0800 8788          lea       _OSTCBCur.L,A2
00002F78  0E3A      
                    8789   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8790   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8791   ; OS_CPU_SR  cpu_sr = 0u;
                    8792   ; #endif
                    8793   ; #ifdef OS_SAFETY_CRITICAL
                    8794   ; if (perr == (INT8U *)0) {
                    8795   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8796   ; return (OS_FALSE);
                    8797   ; }
                    8798   ; #endif
                    8799   ; #if OS_ARG_CHK_EN > 0u
                    8800   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8801   ; *perr = OS_ERR_PEVENT_NULL;
                    8802   ; return (OS_FALSE);
                    8803   ; }
                    8804   ; #endif
                    8805   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00002F7A  2042      8806          move.l    D2,A0
00002F7C  1010      8807          move.b    (A0),D0
00002F7E  0C00 0004 8808          cmp.b     #4,D0
00002F82  670C      8809          beq.s     OSMutexAccept_1
                    8810   ; *perr = OS_ERR_EVENT_TYPE;
00002F84  2043      8811          move.l    D3,A0
00002F86  10BC 0001 8812          move.b    #1,(A0)
                    8813   ; return (OS_FALSE);
00002F8A  4200      8814          clr.b     D0
00002F8C  6000 0084 8815          bra       OSMutexAccept_3
                    8816   OSMutexAccept_1:
                    8817   ; }
                    8818   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
00002F90  1039 0800 8819          move.b    _OSIntNesting.L,D0
00002F94  0D20      
00002F96  0C00 0000 8820          cmp.b     #0,D0
00002F9A  630C      8821          bls.s     OSMutexAccept_4
                    8822   ; *perr = OS_ERR_PEND_ISR;
00002F9C  2043      8823          move.l    D3,A0
00002F9E  10BC 0002 8824          move.b    #2,(A0)
                    8825   ; return (OS_FALSE);
00002FA2  4200      8826          clr.b     D0
00002FA4  6000 006C 8827          bra       OSMutexAccept_3
                    8828   OSMutexAccept_4:
                    8829   ; }
                    8830   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
00002FA8  40E7      8831          dc.w      16615
00002FAA  007C      8832          dc.w      124
00002FAC  0700      8833          dc.w      1792
                    8834   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00002FAE  2042      8835          move.l    D2,A0
00002FB0  3028 0006 8836          move.w    6(A0),D0
00002FB4  E048      8837          lsr.w     #8,D0
00002FB6  1800      8838          move.b    D0,D4
                    8839   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002FB8  2042      8840          move.l    D2,A0
00002FBA  3028 0006 8841          move.w    6(A0),D0
00002FBE  C07C 00FF 8842          and.w     #255,D0
00002FC2  0C40 00FF 8843          cmp.w     #255,D0
00002FC6  6600 0042 8844          bne       OSMutexAccept_6
                    8845   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
00002FCA  2042      8846          move.l    D2,A0
00002FCC  0268 FF00 8847          and.w     #65280,6(A0)
00002FD0  0006      
                    8848   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
00002FD2  2042      8849          move.l    D2,A0
00002FD4  2252      8850          move.l    (A2),A1
00002FD6  1029 0034 8851          move.b    52(A1),D0
00002FDA  C07C 00FF 8852          and.w     #255,D0
00002FDE  8168 0006 8853          or.w      D0,6(A0)
                    8854   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
00002FE2  2042      8855          move.l    D2,A0
00002FE4  2152 0002 8856          move.l    (A2),2(A0)
                    8857   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002FE8  0C04 00FF 8858          cmp.b     #255,D4
00002FEC  6712      8859          beq.s     OSMutexAccept_8
00002FEE  2052      8860          move.l    (A2),A0
00002FF0  B828 0034 8861          cmp.b     52(A0),D4
00002FF4  650A      8862          blo.s     OSMutexAccept_8
                    8863   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8864   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
00002FF6  46DF      8865          dc.w      18143
                    8866   ; *perr = OS_ERR_PCP_LOWER;
00002FF8  2043      8867          move.l    D3,A0
00002FFA  10BC 0078 8868          move.b    #120,(A0)
00002FFE  6006      8869          bra.s     OSMutexAccept_9
                    8870   OSMutexAccept_8:
                    8871   ; } else {
                    8872   ; OS_EXIT_CRITICAL();
00003000  46DF      8873          dc.w      18143
                    8874   ; *perr = OS_ERR_NONE;
00003002  2043      8875          move.l    D3,A0
00003004  4210      8876          clr.b     (A0)
                    8877   OSMutexAccept_9:
                    8878   ; }
                    8879   ; return (OS_TRUE);
00003006  7001      8880          moveq     #1,D0
00003008  6008      8881          bra.s     OSMutexAccept_3
                    8882   OSMutexAccept_6:
                    8883   ; }
                    8884   ; OS_EXIT_CRITICAL();
0000300A  46DF      8885          dc.w      18143
                    8886   ; *perr = OS_ERR_NONE;
0000300C  2043      8887          move.l    D3,A0
0000300E  4210      8888          clr.b     (A0)
                    8889   ; return (OS_FALSE);
00003010  4200      8890          clr.b     D0
                    8891   OSMutexAccept_3:
00003012  4CDF 041C 8892          movem.l   (A7)+,D2/D3/D4/A2
00003016  4E5E      8893          unlk      A6
00003018  4E75      8894          rts
                    8895   ; }
                    8896   ; #endif
                    8897   ; /*$PAGE*/
                    8898   ; /*
                    8899   ; *********************************************************************************************************
                    8900   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8901   ; *
                    8902   ; * Description: This function creates a mutual exclusion semaphore.
                    8903   ; *
                    8904   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8905   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8906   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8907   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8908   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8909   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8910   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8911   ; *                            semaphore do not have their priority promoted.
                    8912   ; *
                    8913   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8914   ; *                               OS_ERR_NONE         if the call was successful.
                    8915   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8916   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8917   ; *                                                   already exist.
                    8918   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8919   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8920   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8921   ; *
                    8922   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8923   ; *                            created mutex.
                    8924   ; *              == (void *)0  if an error is detected.
                    8925   ; *
                    8926   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8927   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8928   ; *
                    8929   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8930   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8931   ; *                 promotion is disabled.
                    8932   ; *********************************************************************************************************
                    8933   ; */
                    8934   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8935   ; INT8U  *perr)
                    8936   ; {
                    8937   _OSMutexCreate:
0000301A  4E56 0000 8938          link      A6,#0
0000301E  48E7 3830 8939          movem.l   D2/D3/D4/A2/A3,-(A7)
00003022  162E 000B 8940          move.b    11(A6),D3
00003026  C6BC 0000 8941          and.l     #255,D3
0000302A  00FF      
0000302C  282E 000C 8942          move.l    12(A6),D4
00003030  45F9 0800 8943          lea       _OSEventFreeList.L,A2
00003034  0AF4      
00003036  47F9 0800 8944          lea       _OSTCBPrioTbl.L,A3
0000303A  0E4A      
                    8945   ; OS_EVENT  *pevent;
                    8946   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8947   ; OS_CPU_SR  cpu_sr = 0u;
                    8948   ; #endif
                    8949   ; #ifdef OS_SAFETY_CRITICAL
                    8950   ; if (perr == (INT8U *)0) {
                    8951   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8952   ; return ((OS_EVENT *)0);
                    8953   ; }
                    8954   ; #endif
                    8955   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8956   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8957   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8958   ; return ((OS_EVENT *)0);
                    8959   ; }
                    8960   ; #endif
                    8961   ; #if OS_ARG_CHK_EN > 0u
                    8962   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8963   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8964   ; *perr = OS_ERR_PRIO_INVALID;
                    8965   ; return ((OS_EVENT *)0);
                    8966   ; }
                    8967   ; }
                    8968   ; #endif
                    8969   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0000303C  1039 0800 8970          move.b    _OSIntNesting.L,D0
00003040  0D20      
00003042  0C00 0000 8971          cmp.b     #0,D0
00003046  630C      8972          bls.s     OSMutexCreate_1
                    8973   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
00003048  2044      8974          move.l    D4,A0
0000304A  10BC 0010 8975          move.b    #16,(A0)
                    8976   ; return ((OS_EVENT *)0);
0000304E  4280      8977          clr.l     D0
00003050  6000 00A6 8978          bra       OSMutexCreate_3
                    8979   OSMutexCreate_1:
                    8980   ; }
                    8981   ; OS_ENTER_CRITICAL();
00003054  40E7      8982          dc.w      16615
00003056  007C      8983          dc.w      124
00003058  0700      8984          dc.w      1792
                    8985   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
0000305A  0C03 00FF 8986          cmp.b     #255,D3
0000305E  6730      8987          beq.s     OSMutexCreate_4
                    8988   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00003060  C6BC 0000 8989          and.l     #255,D3
00003064  00FF      
00003066  2003      8990          move.l    D3,D0
00003068  E588      8991          lsl.l     #2,D0
0000306A  2033 0800 8992          move.l    0(A3,D0.L),D0
0000306E  670E      8993          beq.s     OSMutexCreate_6
                    8994   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00003070  46DF      8995          dc.w      18143
                    8996   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00003072  2044      8997          move.l    D4,A0
00003074  10BC 0028 8998          move.b    #40,(A0)
                    8999   ; return ((OS_EVENT *)0);
00003078  4280      9000          clr.l     D0
0000307A  6000 007C 9001          bra       OSMutexCreate_3
                    9002   OSMutexCreate_6:
                    9003   ; }
                    9004   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
0000307E  C6BC 0000 9005          and.l     #255,D3
00003082  00FF      
00003084  2003      9006          move.l    D3,D0
00003086  E588      9007          lsl.l     #2,D0
00003088  27BC 0000 9008          move.l    #1,0(A3,D0.L)
0000308C  0001 0800 
                    9009   OSMutexCreate_4:
                    9010   ; }
                    9011   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00003090  2412      9012          move.l    (A2),D2
                    9013   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
00003092  4A82      9014          tst.l     D2
00003094  6622      9015          bne.s     OSMutexCreate_8
                    9016   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00003096  0C03 00FF 9017          cmp.b     #255,D3
0000309A  670E      9018          beq.s     OSMutexCreate_10
                    9019   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
0000309C  C6BC 0000 9020          and.l     #255,D3
000030A0  00FF      
000030A2  2003      9021          move.l    D3,D0
000030A4  E588      9022          lsl.l     #2,D0
000030A6  42B3 0800 9023          clr.l     0(A3,D0.L)
                    9024   OSMutexCreate_10:
                    9025   ; }
                    9026   ; OS_EXIT_CRITICAL();
000030AA  46DF      9027          dc.w      18143
                    9028   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
000030AC  2044      9029          move.l    D4,A0
000030AE  10BC 0004 9030          move.b    #4,(A0)
                    9031   ; return (pevent);
000030B2  2002      9032          move.l    D2,D0
000030B4  6000 0042 9033          bra       OSMutexCreate_3
                    9034   OSMutexCreate_8:
                    9035   ; }
                    9036   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
000030B8  2052      9037          move.l    (A2),A0
000030BA  24A8 0002 9038          move.l    2(A0),(A2)
                    9039   ; OS_EXIT_CRITICAL();
000030BE  46DF      9040          dc.w      18143
                    9041   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
000030C0  2042      9042          move.l    D2,A0
000030C2  10BC 0004 9043          move.b    #4,(A0)
                    9044   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
000030C6  1003      9045          move.b    D3,D0
000030C8  C07C 00FF 9046          and.w     #255,D0
000030CC  E148      9047          lsl.w     #8,D0
000030CE  807C 00FF 9048          or.w      #255,D0
000030D2  2042      9049          move.l    D2,A0
000030D4  3140 0006 9050          move.w    D0,6(A0)
                    9051   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
000030D8  2042      9052          move.l    D2,A0
000030DA  42A8 0002 9053          clr.l     2(A0)
                    9054   ; #if OS_EVENT_NAME_EN > 0u
                    9055   ; pevent->OSEventName = (INT8U *)(void *)"?";
000030DE  41F9 0000 9056          lea       @ucos_ii_1.L,A0
000030E2  6F2A      
000030E4  2242      9057          move.l    D2,A1
000030E6  2348 0012 9058          move.l    A0,18(A1)
                    9059   ; #endif
                    9060   ; OS_EventWaitListInit(pevent);
000030EA  2F02      9061          move.l    D2,-(A7)
000030EC  4EB8 15F6 9062          jsr       _OS_EventWaitListInit
000030F0  584F      9063          addq.w    #4,A7
                    9064   ; *perr = OS_ERR_NONE;
000030F2  2044      9065          move.l    D4,A0
000030F4  4210      9066          clr.b     (A0)
                    9067   ; return (pevent);
000030F6  2002      9068          move.l    D2,D0
                    9069   OSMutexCreate_3:
000030F8  4CDF 0C1C 9070          movem.l   (A7)+,D2/D3/D4/A2/A3
000030FC  4E5E      9071          unlk      A6
000030FE  4E75      9072          rts
                    9073   ; }
                    9074   ; /*$PAGE*/
                    9075   ; /*
                    9076   ; *********************************************************************************************************
                    9077   ; *                                           DELETE A MUTEX
                    9078   ; *
                    9079   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    9080   ; *
                    9081   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    9082   ; *
                    9083   ; *              opt           determines delete options as follows:
                    9084   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    9085   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    9086   ; *                                                    In this case, all the tasks pending will be readied.
                    9087   ; *
                    9088   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    9089   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    9090   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    9091   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    9092   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    9093   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9094   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    9095   ; *
                    9096   ; * Returns    : pevent        upon error
                    9097   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    9098   ; *
                    9099   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    9100   ; *                 the mutex MUST check the return code of OSMutexPend().
                    9101   ; *
                    9102   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    9103   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    9104   ; *
                    9105   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    9106   ; *                 resource(s) will no longer be guarded by the mutex.
                    9107   ; *
                    9108   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    9109   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    9110   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    9111   ; *                            that task will be made ready-to-run at its original priority.
                    9112   ; *********************************************************************************************************
                    9113   ; */
                    9114   ; #if OS_MUTEX_DEL_EN > 0u
                    9115   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    9116   ; INT8U      opt,
                    9117   ; INT8U     *perr)
                    9118   ; {
                    9119   _OSMutexDel:
00003100  4E56 FFFC 9120          link      A6,#-4
00003104  48E7 3F20 9121          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00003108  242E 0008 9122          move.l    8(A6),D2
0000310C  282E 0010 9123          move.l    16(A6),D4
00003110  45F9 0800 9124          lea       _OSEventFreeList.L,A2
00003114  0AF4      
                    9125   ; BOOLEAN    tasks_waiting;
                    9126   ; OS_EVENT  *pevent_return;
                    9127   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    9128   ; INT8U      prio;
                    9129   ; OS_TCB    *ptcb;
                    9130   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9131   ; OS_CPU_SR  cpu_sr = 0u;
                    9132   ; #endif
                    9133   ; #ifdef OS_SAFETY_CRITICAL
                    9134   ; if (perr == (INT8U *)0) {
                    9135   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9136   ; return ((OS_EVENT *)0);
                    9137   ; }
                    9138   ; #endif
                    9139   ; #if OS_ARG_CHK_EN > 0u
                    9140   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9141   ; *perr = OS_ERR_PEVENT_NULL;
                    9142   ; return (pevent);
                    9143   ; }
                    9144   ; #endif
                    9145   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00003116  2042      9146          move.l    D2,A0
00003118  1010      9147          move.b    (A0),D0
0000311A  0C00 0004 9148          cmp.b     #4,D0
0000311E  670C      9149          beq.s     OSMutexDel_1
                    9150   ; *perr = OS_ERR_EVENT_TYPE;
00003120  2044      9151          move.l    D4,A0
00003122  10BC 0001 9152          move.b    #1,(A0)
                    9153   ; return (pevent);
00003126  2002      9154          move.l    D2,D0
00003128  6000 017C 9155          bra       OSMutexDel_3
                    9156   OSMutexDel_1:
                    9157   ; }
                    9158   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0000312C  1039 0800 9159          move.b    _OSIntNesting.L,D0
00003130  0D20      
00003132  0C00 0000 9160          cmp.b     #0,D0
00003136  630C      9161          bls.s     OSMutexDel_4
                    9162   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
00003138  2044      9163          move.l    D4,A0
0000313A  10BC 000F 9164          move.b    #15,(A0)
                    9165   ; return (pevent);
0000313E  2002      9166          move.l    D2,D0
00003140  6000 0164 9167          bra       OSMutexDel_3
                    9168   OSMutexDel_4:
                    9169   ; }
                    9170   ; OS_ENTER_CRITICAL();
00003144  40E7      9171          dc.w      16615
00003146  007C      9172          dc.w      124
00003148  0700      9173          dc.w      1792
                    9174   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
0000314A  2042      9175          move.l    D2,A0
0000314C  1028 0008 9176          move.b    8(A0),D0
00003150  6704      9177          beq.s     OSMutexDel_6
                    9178   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003152  7E01      9179          moveq     #1,D7
00003154  6002      9180          bra.s     OSMutexDel_7
                    9181   OSMutexDel_6:
                    9182   ; } else {
                    9183   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00003156  7E00      9184          moveq     #0,D7
                    9185   OSMutexDel_7:
                    9186   ; }
                    9187   ; switch (opt) {
00003158  102E 000F 9188          move.b    15(A6),D0
0000315C  C0BC 0000 9189          and.l     #255,D0
00003160  00FF      
00003162  0C80 0000 9190          cmp.l     #1,D0
00003166  0001      
00003168  6700 006E 9191          beq       OSMutexDel_11
0000316C  6200 012C 9192          bhi       OSMutexDel_8
00003170  4A80      9193          tst.l     D0
00003172  6704      9194          beq.s     OSMutexDel_10
00003174  6000 0124 9195          bra       OSMutexDel_8
                    9196   OSMutexDel_10:
                    9197   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    9198   ; if (tasks_waiting == OS_FALSE) {
00003178  4A07      9199          tst.b     D7
0000317A  6600 004E 9200          bne       OSMutexDel_13
                    9201   ; #if OS_EVENT_NAME_EN > 0u
                    9202   ; pevent->OSEventName   = (INT8U *)(void *)"?";
0000317E  41F9 0000 9203          lea       @ucos_ii_1.L,A0
00003182  6F2A      
00003184  2242      9204          move.l    D2,A1
00003186  2348 0012 9205          move.l    A0,18(A1)
                    9206   ; #endif
                    9207   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
0000318A  2042      9208          move.l    D2,A0
0000318C  3028 0006 9209          move.w    6(A0),D0
00003190  E048      9210          lsr.w     #8,D0
00003192  1600      9211          move.b    D0,D3
                    9212   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003194  0C03 00FF 9213          cmp.b     #255,D3
00003198  6714      9214          beq.s     OSMutexDel_15
                    9215   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
0000319A  C6BC 0000 9216          and.l     #255,D3
0000319E  00FF      
000031A0  2003      9217          move.l    D3,D0
000031A2  E588      9218          lsl.l     #2,D0
000031A4  41F9 0800 9219          lea       _OSTCBPrioTbl.L,A0
000031A8  0E4A      
000031AA  42B0 0800 9220          clr.l     0(A0,D0.L)
                    9221   OSMutexDel_15:
                    9222   ; }
                    9223   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
000031AE  2042      9224          move.l    D2,A0
000031B0  4210      9225          clr.b     (A0)
                    9226   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
000031B2  2042      9227          move.l    D2,A0
000031B4  2152 0002 9228          move.l    (A2),2(A0)
                    9229   ; pevent->OSEventCnt    = 0u;
000031B8  2042      9230          move.l    D2,A0
000031BA  4268 0006 9231          clr.w     6(A0)
                    9232   ; OSEventFreeList       = pevent;
000031BE  2482      9233          move.l    D2,(A2)
                    9234   ; OS_EXIT_CRITICAL();
000031C0  46DF      9235          dc.w      18143
                    9236   ; *perr                 = OS_ERR_NONE;
000031C2  2044      9237          move.l    D4,A0
000031C4  4210      9238          clr.b     (A0)
                    9239   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
000031C6  4285      9240          clr.l     D5
000031C8  600A      9241          bra.s     OSMutexDel_14
                    9242   OSMutexDel_13:
                    9243   ; } else {
                    9244   ; OS_EXIT_CRITICAL();
000031CA  46DF      9245          dc.w      18143
                    9246   ; *perr                 = OS_ERR_TASK_WAITING;
000031CC  2044      9247          move.l    D4,A0
000031CE  10BC 0049 9248          move.b    #73,(A0)
                    9249   ; pevent_return         = pevent;
000031D2  2A02      9250          move.l    D2,D5
                    9251   OSMutexDel_14:
                    9252   ; }
                    9253   ; break;
000031D4  6000 00CE 9254          bra       OSMutexDel_9
                    9255   OSMutexDel_11:
                    9256   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    9257   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
000031D8  2042      9258          move.l    D2,A0
000031DA  3028 0006 9259          move.w    6(A0),D0
000031DE  E048      9260          lsr.w     #8,D0
000031E0  1600      9261          move.b    D0,D3
                    9262   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000031E2  0C03 00FF 9263          cmp.b     #255,D3
000031E6  6700 0038 9264          beq       OSMutexDel_21
                    9265   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
000031EA  2042      9266          move.l    D2,A0
000031EC  3028 0006 9267          move.w    6(A0),D0
000031F0  C07C 00FF 9268          and.w     #255,D0
000031F4  1D40 FFFF 9269          move.b    D0,-1(A6)
                    9270   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
000031F8  2042      9271          move.l    D2,A0
000031FA  2C28 0002 9272          move.l    2(A0),D6
                    9273   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
000031FE  4A86      9274          tst.l     D6
00003200  671E      9275          beq.s     OSMutexDel_21
                    9276   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00003202  2046      9277          move.l    D6,A0
00003204  B628 0034 9278          cmp.b     52(A0),D3
00003208  6616      9279          bne.s     OSMutexDel_21
                    9280   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
0000320A  122E FFFF 9281          move.b    -1(A6),D1
0000320E  C2BC 0000 9282          and.l     #255,D1
00003212  00FF      
00003214  2F01      9283          move.l    D1,-(A7)
00003216  2F06      9284          move.l    D6,-(A7)
00003218  4EB9 0000 9285          jsr       @ucos_ii_OSMutex_RdyAtPrio
0000321C  375C      
0000321E  504F      9286          addq.w    #8,A7
                    9287   OSMutexDel_21:
                    9288   ; }
                    9289   ; }
                    9290   ; }
                    9291   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    9292   OSMutexDel_23:
00003220  2042      9293          move.l    D2,A0
00003222  1028 0008 9294          move.b    8(A0),D0
00003226  671C      9295          beq.s     OSMutexDel_25
                    9296   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00003228  4878 0002 9297          pea       2
0000322C  4878 0010 9298          pea       16
00003230  42A7      9299          clr.l     -(A7)
00003232  2F02      9300          move.l    D2,-(A7)
00003234  4EB8 132E 9301          jsr       _OS_EventTaskRdy
00003238  DEFC 0010 9302          add.w     #16,A7
0000323C  C0BC 0000 9303          and.l     #255,D0
00003240  00FF      
00003242  60DC      9304          bra       OSMutexDel_23
                    9305   OSMutexDel_25:
                    9306   ; }
                    9307   ; #if OS_EVENT_NAME_EN > 0u
                    9308   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00003244  41F9 0000 9309          lea       @ucos_ii_1.L,A0
00003248  6F2A      
0000324A  2242      9310          move.l    D2,A1
0000324C  2348 0012 9311          move.l    A0,18(A1)
                    9312   ; #endif
                    9313   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00003250  2042      9314          move.l    D2,A0
00003252  3028 0006 9315          move.w    6(A0),D0
00003256  E048      9316          lsr.w     #8,D0
00003258  1600      9317          move.b    D0,D3
                    9318   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0000325A  0C03 00FF 9319          cmp.b     #255,D3
0000325E  6714      9320          beq.s     OSMutexDel_26
                    9321   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
00003260  C6BC 0000 9322          and.l     #255,D3
00003264  00FF      
00003266  2003      9323          move.l    D3,D0
00003268  E588      9324          lsl.l     #2,D0
0000326A  41F9 0800 9325          lea       _OSTCBPrioTbl.L,A0
0000326E  0E4A      
00003270  42B0 0800 9326          clr.l     0(A0,D0.L)
                    9327   OSMutexDel_26:
                    9328   ; }
                    9329   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00003274  2042      9330          move.l    D2,A0
00003276  4210      9331          clr.b     (A0)
                    9332   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
00003278  2042      9333          move.l    D2,A0
0000327A  2152 0002 9334          move.l    (A2),2(A0)
                    9335   ; pevent->OSEventCnt    = 0u;
0000327E  2042      9336          move.l    D2,A0
00003280  4268 0006 9337          clr.w     6(A0)
                    9338   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
00003284  2482      9339          move.l    D2,(A2)
                    9340   ; OS_EXIT_CRITICAL();
00003286  46DF      9341          dc.w      18143
                    9342   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003288  0C07 0001 9343          cmp.b     #1,D7
0000328C  6604      9344          bne.s     OSMutexDel_28
                    9345   ; OS_Sched();                               /* Find highest priority task ready to run  */
0000328E  4EB8 190E 9346          jsr       _OS_Sched
                    9347   OSMutexDel_28:
                    9348   ; }
                    9349   ; *perr         = OS_ERR_NONE;
00003292  2044      9350          move.l    D4,A0
00003294  4210      9351          clr.b     (A0)
                    9352   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
00003296  4285      9353          clr.l     D5
                    9354   ; break;
00003298  600A      9355          bra.s     OSMutexDel_9
                    9356   OSMutexDel_8:
                    9357   ; default:
                    9358   ; OS_EXIT_CRITICAL();
0000329A  46DF      9359          dc.w      18143
                    9360   ; *perr         = OS_ERR_INVALID_OPT;
0000329C  2044      9361          move.l    D4,A0
0000329E  10BC 0007 9362          move.b    #7,(A0)
                    9363   ; pevent_return = pevent;
000032A2  2A02      9364          move.l    D2,D5
                    9365   ; break;
                    9366   OSMutexDel_9:
                    9367   ; }
                    9368   ; return (pevent_return);
000032A4  2005      9369          move.l    D5,D0
                    9370   OSMutexDel_3:
000032A6  4CDF 04FC 9371          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000032AA  4E5E      9372          unlk      A6
000032AC  4E75      9373          rts
                    9374   ; }
                    9375   ; #endif
                    9376   ; /*$PAGE*/
                    9377   ; /*
                    9378   ; *********************************************************************************************************
                    9379   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    9380   ; *
                    9381   ; * Description: This function waits for a mutual exclusion semaphore.
                    9382   ; *
                    9383   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    9384   ; *                            mutex.
                    9385   ; *
                    9386   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    9387   ; *                            wait for the resource up to the amount of time specified by this argument.
                    9388   ; *                            If you specify 0, however, your task will wait forever at the specified
                    9389   ; *                            mutex or, until the resource becomes available.
                    9390   ; *
                    9391   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9392   ; *                            messages are:
                    9393   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    9394   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    9395   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    9396   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    9397   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    9398   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    9399   ; *                                                  would lead to a suspension.
                    9400   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9401   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9402   ; *                                                  indicates that you did not set the PCP higher (lower
                    9403   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9404   ; *                                                  Unfortunately, this is something that could not be
                    9405   ; *                                                  detected when the Mutex is created because we don't know
                    9406   ; *                                                  what tasks will be using the Mutex.
                    9407   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9408   ; *
                    9409   ; * Returns    : none
                    9410   ; *
                    9411   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9412   ; *
                    9413   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9414   ; *********************************************************************************************************
                    9415   ; */
                    9416   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9417   ; INT32U     timeout,
                    9418   ; INT8U     *perr)
                    9419   ; {
                    9420   _OSMutexPend:
000032AE  4E56 FFFC 9421          link      A6,#-4
000032B2  48E7 3F30 9422          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
000032B6  45F9 0800 9423          lea       _OSTCBCur.L,A2
000032BA  0E3A      
000032BC  262E 0008 9424          move.l    8(A6),D3
000032C0  2A2E 0010 9425          move.l    16(A6),D5
000032C4  47F9 0800 9426          lea       _OSRdyTbl.L,A3
000032C8  0D2A      
                    9427   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9428   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9429   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9430   ; OS_TCB    *ptcb;
                    9431   ; OS_EVENT  *pevent2;
                    9432   ; INT8U      y;
                    9433   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9434   ; OS_CPU_SR  cpu_sr = 0u;
                    9435   ; #endif
                    9436   ; #ifdef OS_SAFETY_CRITICAL
                    9437   ; if (perr == (INT8U *)0) {
                    9438   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9439   ; return;
                    9440   ; }
                    9441   ; #endif
                    9442   ; #if OS_ARG_CHK_EN > 0u
                    9443   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9444   ; *perr = OS_ERR_PEVENT_NULL;
                    9445   ; return;
                    9446   ; }
                    9447   ; #endif
                    9448   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000032CA  2043      9449          move.l    D3,A0
000032CC  1010      9450          move.b    (A0),D0
000032CE  0C00 0004 9451          cmp.b     #4,D0
000032D2  670A      9452          beq.s     OSMutexPend_1
                    9453   ; *perr = OS_ERR_EVENT_TYPE;
000032D4  2045      9454          move.l    D5,A0
000032D6  10BC 0001 9455          move.b    #1,(A0)
                    9456   ; return;
000032DA  6000 02AC 9457          bra       OSMutexPend_3
                    9458   OSMutexPend_1:
                    9459   ; }
                    9460   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000032DE  1039 0800 9461          move.b    _OSIntNesting.L,D0
000032E2  0D20      
000032E4  0C00 0000 9462          cmp.b     #0,D0
000032E8  630A      9463          bls.s     OSMutexPend_4
                    9464   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000032EA  2045      9465          move.l    D5,A0
000032EC  10BC 0002 9466          move.b    #2,(A0)
                    9467   ; return;
000032F0  6000 0296 9468          bra       OSMutexPend_3
                    9469   OSMutexPend_4:
                    9470   ; }
                    9471   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
000032F4  1039 0800 9472          move.b    _OSLockNesting.L,D0
000032F8  0D22      
000032FA  0C00 0000 9473          cmp.b     #0,D0
000032FE  630A      9474          bls.s     OSMutexPend_6
                    9475   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00003300  2045      9476          move.l    D5,A0
00003302  10BC 000D 9477          move.b    #13,(A0)
                    9478   ; return;
00003306  6000 0280 9479          bra       OSMutexPend_3
                    9480   OSMutexPend_6:
                    9481   ; }
                    9482   ; /*$PAGE*/
                    9483   ; OS_ENTER_CRITICAL();
0000330A  40E7      9484          dc.w      16615
0000330C  007C      9485          dc.w      124
0000330E  0700      9486          dc.w      1792
                    9487   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
00003310  2043      9488          move.l    D3,A0
00003312  3028 0006 9489          move.w    6(A0),D0
00003316  E048      9490          lsr.w     #8,D0
00003318  1E00      9491          move.b    D0,D7
                    9492   ; /* Is Mutex available?                      */
                    9493   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
0000331A  2043      9494          move.l    D3,A0
0000331C  3028 0006 9495          move.w    6(A0),D0
00003320  C07C 00FF 9496          and.w     #255,D0
00003324  C07C 00FF 9497          and.w     #255,D0
00003328  0C40 00FF 9498          cmp.w     #255,D0
0000332C  6600 0042 9499          bne       OSMutexPend_8
                    9500   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
00003330  2043      9501          move.l    D3,A0
00003332  0268 FF00 9502          and.w     #65280,6(A0)
00003336  0006      
                    9503   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
00003338  2043      9504          move.l    D3,A0
0000333A  2252      9505          move.l    (A2),A1
0000333C  1029 0034 9506          move.b    52(A1),D0
00003340  C07C 00FF 9507          and.w     #255,D0
00003344  8168 0006 9508          or.w      D0,6(A0)
                    9509   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
00003348  2043      9510          move.l    D3,A0
0000334A  2152 0002 9511          move.l    (A2),2(A0)
                    9512   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
0000334E  0C07 00FF 9513          cmp.b     #255,D7
00003352  6712      9514          beq.s     OSMutexPend_10
00003354  2052      9515          move.l    (A2),A0
00003356  BE28 0034 9516          cmp.b     52(A0),D7
0000335A  650A      9517          blo.s     OSMutexPend_10
                    9518   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9519   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
0000335C  46DF      9520          dc.w      18143
                    9521   ; *perr = OS_ERR_PCP_LOWER;
0000335E  2045      9522          move.l    D5,A0
00003360  10BC 0078 9523          move.b    #120,(A0)
00003364  6006      9524          bra.s     OSMutexPend_11
                    9525   OSMutexPend_10:
                    9526   ; } else {
                    9527   ; OS_EXIT_CRITICAL();
00003366  46DF      9528          dc.w      18143
                    9529   ; *perr = OS_ERR_NONE;
00003368  2045      9530          move.l    D5,A0
0000336A  4210      9531          clr.b     (A0)
                    9532   OSMutexPend_11:
                    9533   ; }
                    9534   ; return;
0000336C  6000 021A 9535          bra       OSMutexPend_3
                    9536   OSMutexPend_8:
                    9537   ; }
                    9538   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00003370  0C07 00FF 9539          cmp.b     #255,D7
00003374  6700 018A 9540          beq       OSMutexPend_16
                    9541   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
00003378  2043      9542          move.l    D3,A0
0000337A  3028 0006 9543          move.w    6(A0),D0
0000337E  C07C 00FF 9544          and.w     #255,D0
00003382  1D40 FFFE 9545          move.b    D0,-2(A6)
                    9546   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
00003386  2043      9547          move.l    D3,A0
00003388  2428 0002 9548          move.l    2(A0),D2
                    9549   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
0000338C  2042      9550          move.l    D2,A0
0000338E  BE28 0034 9551          cmp.b     52(A0),D7
00003392  6400 016C 9552          bhs       OSMutexPend_16
                    9553   ; if (mprio > OSTCBCur->OSTCBPrio) {
00003396  2052      9554          move.l    (A2),A0
00003398  102E FFFE 9555          move.b    -2(A6),D0
0000339C  B028 0034 9556          cmp.b     52(A0),D0
000033A0  6300 015E 9557          bls       OSMutexPend_16
                    9558   ; y = ptcb->OSTCBY;
000033A4  2042      9559          move.l    D2,A0
000033A6  1C28 0036 9560          move.b    54(A0),D6
                    9561   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
000033AA  CCBC 0000 9562          and.l     #255,D6
000033AE  00FF      
000033B0  1033 6800 9563          move.b    0(A3,D6.L),D0
000033B4  2042      9564          move.l    D2,A0
000033B6  C028 0037 9565          and.b     55(A0),D0
000033BA  6736      9566          beq.s     OSMutexPend_18
                    9567   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
000033BC  CCBC 0000 9568          and.l     #255,D6
000033C0  00FF      
000033C2  2042      9569          move.l    D2,A0
000033C4  1028 0037 9570          move.b    55(A0),D0
000033C8  4600      9571          not.b     D0
000033CA  C133 6800 9572          and.b     D0,0(A3,D6.L)
                    9573   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
000033CE  CCBC 0000 9574          and.l     #255,D6
000033D2  00FF      
000033D4  1033 6800 9575          move.b    0(A3,D6.L),D0
000033D8  660E      9576          bne.s     OSMutexPend_20
                    9577   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000033DA  2042      9578          move.l    D2,A0
000033DC  1028 0038 9579          move.b    56(A0),D0
000033E0  4600      9580          not.b     D0
000033E2  C139 0800 9581          and.b     D0,_OSRdyGrp.L
000033E6  0D28      
                    9582   OSMutexPend_20:
                    9583   ; }
                    9584   ; rdy = OS_TRUE;
000033E8  1D7C 0001 9585          move.b    #1,-1(A6)
000033EC  FFFF      
000033EE  6000 004C 9586          bra       OSMutexPend_19
                    9587   OSMutexPend_18:
                    9588   ; } else {
                    9589   ; pevent2 = ptcb->OSTCBEventPtr;
000033F2  2042      9590          move.l    D2,A0
000033F4  2828 001C 9591          move.l    28(A0),D4
                    9592   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
000033F8  4A84      9593          tst.l     D4
000033FA  6700 003C 9594          beq       OSMutexPend_24
                    9595   ; y = ptcb->OSTCBY;
000033FE  2042      9596          move.l    D2,A0
00003400  1C28 0036 9597          move.b    54(A0),D6
                    9598   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003404  2044      9599          move.l    D4,A0
00003406  CCBC 0000 9600          and.l     #255,D6
0000340A  00FF      
0000340C  D1C6      9601          add.l     D6,A0
0000340E  2242      9602          move.l    D2,A1
00003410  1029 0037 9603          move.b    55(A1),D0
00003414  4600      9604          not.b     D0
00003416  C128 000A 9605          and.b     D0,10(A0)
                    9606   ; if (pevent2->OSEventTbl[y] == 0u) {
0000341A  2044      9607          move.l    D4,A0
0000341C  CCBC 0000 9608          and.l     #255,D6
00003420  00FF      
00003422  D1C6      9609          add.l     D6,A0
00003424  1028 000A 9610          move.b    10(A0),D0
00003428  660E      9611          bne.s     OSMutexPend_24
                    9612   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000342A  2044      9613          move.l    D4,A0
0000342C  2242      9614          move.l    D2,A1
0000342E  1029 0038 9615          move.b    56(A1),D0
00003432  4600      9616          not.b     D0
00003434  C128 0008 9617          and.b     D0,8(A0)
                    9618   OSMutexPend_24:
                    9619   ; }
                    9620   ; }
                    9621   ; rdy = OS_FALSE;                        /* No                                       */
00003438  422E FFFF 9622          clr.b     -1(A6)
                    9623   OSMutexPend_19:
                    9624   ; }
                    9625   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
0000343C  2042      9626          move.l    D2,A0
0000343E  1147 0034 9627          move.b    D7,52(A0)
                    9628   ; #if OS_LOWEST_PRIO <= 63u
                    9629   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
00003442  2042      9630          move.l    D2,A0
00003444  1028 0034 9631          move.b    52(A0),D0
00003448  E608      9632          lsr.b     #3,D0
0000344A  2042      9633          move.l    D2,A0
0000344C  1140 0036 9634          move.b    D0,54(A0)
                    9635   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
00003450  2042      9636          move.l    D2,A0
00003452  1028 0034 9637          move.b    52(A0),D0
00003456  C03C 0007 9638          and.b     #7,D0
0000345A  2042      9639          move.l    D2,A0
0000345C  1140 0035 9640          move.b    D0,53(A0)
                    9641   ; #else
                    9642   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9643   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9644   ; #endif
                    9645   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
00003460  7001      9646          moveq     #1,D0
00003462  2042      9647          move.l    D2,A0
00003464  1228 0036 9648          move.b    54(A0),D1
00003468  C2BC 0000 9649          and.l     #255,D1
0000346C  00FF      
0000346E  E3A8      9650          lsl.l     D1,D0
00003470  2042      9651          move.l    D2,A0
00003472  1140 0038 9652          move.b    D0,56(A0)
                    9653   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
00003476  7001      9654          moveq     #1,D0
00003478  2042      9655          move.l    D2,A0
0000347A  1228 0035 9656          move.b    53(A0),D1
0000347E  C2BC 0000 9657          and.l     #255,D1
00003482  00FF      
00003484  E3A8      9658          lsl.l     D1,D0
00003486  2042      9659          move.l    D2,A0
00003488  1140 0037 9660          move.b    D0,55(A0)
                    9661   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
0000348C  102E FFFF 9662          move.b    -1(A6),D0
00003490  0C00 0001 9663          cmp.b     #1,D0
00003494  6626      9664          bne.s     OSMutexPend_26
                    9665   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
00003496  2042      9666          move.l    D2,A0
00003498  1028 0038 9667          move.b    56(A0),D0
0000349C  8139 0800 9668          or.b      D0,_OSRdyGrp.L
000034A0  0D28      
                    9669   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000034A2  2042      9670          move.l    D2,A0
000034A4  1028 0036 9671          move.b    54(A0),D0
000034A8  C0BC 0000 9672          and.l     #255,D0
000034AC  00FF      
000034AE  2042      9673          move.l    D2,A0
000034B0  1228 0037 9674          move.b    55(A0),D1
000034B4  8333 0800 9675          or.b      D1,0(A3,D0.L)
000034B8  6000 0032 9676          bra       OSMutexPend_28
                    9677   OSMutexPend_26:
                    9678   ; } else {
                    9679   ; pevent2 = ptcb->OSTCBEventPtr;
000034BC  2042      9680          move.l    D2,A0
000034BE  2828 001C 9681          move.l    28(A0),D4
                    9682   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
000034C2  4A84      9683          tst.l     D4
000034C4  6726      9684          beq.s     OSMutexPend_28
                    9685   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
000034C6  2044      9686          move.l    D4,A0
000034C8  2242      9687          move.l    D2,A1
000034CA  1029 0038 9688          move.b    56(A1),D0
000034CE  8128 0008 9689          or.b      D0,8(A0)
                    9690   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000034D2  2044      9691          move.l    D4,A0
000034D4  2242      9692          move.l    D2,A1
000034D6  1029 0036 9693          move.b    54(A1),D0
000034DA  C0BC 0000 9694          and.l     #255,D0
000034DE  00FF      
000034E0  D1C0      9695          add.l     D0,A0
000034E2  2242      9696          move.l    D2,A1
000034E4  1029 0037 9697          move.b    55(A1),D0
000034E8  8128 000A 9698          or.b      D0,10(A0)
                    9699   OSMutexPend_28:
                    9700   ; }
                    9701   ; }
                    9702   ; OSTCBPrioTbl[pcp] = ptcb;
000034EC  CEBC 0000 9703          and.l     #255,D7
000034F0  00FF      
000034F2  2007      9704          move.l    D7,D0
000034F4  E588      9705          lsl.l     #2,D0
000034F6  41F9 0800 9706          lea       _OSTCBPrioTbl.L,A0
000034FA  0E4A      
000034FC  2182 0800 9707          move.l    D2,0(A0,D0.L)
                    9708   OSMutexPend_16:
                    9709   ; }
                    9710   ; }
                    9711   ; }
                    9712   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
00003500  2052      9713          move.l    (A2),A0
00003502  0028 0010 9714          or.b      #16,50(A0)
00003506  0032      
                    9715   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003508  2052      9716          move.l    (A2),A0
0000350A  4228 0033 9717          clr.b     51(A0)
                    9718   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
0000350E  2052      9719          move.l    (A2),A0
00003510  216E 000C 9720          move.l    12(A6),46(A0)
00003514  002E      
                    9721   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00003516  2F03      9722          move.l    D3,-(A7)
00003518  4EB8 1412 9723          jsr       _OS_EventTaskWait
0000351C  584F      9724          addq.w    #4,A7
                    9725   ; OS_EXIT_CRITICAL();
0000351E  46DF      9726          dc.w      18143
                    9727   ; OS_Sched();                                       /* Find next highest priority task ready         */
00003520  4EB8 190E 9728          jsr       _OS_Sched
                    9729   ; OS_ENTER_CRITICAL();
00003524  40E7      9730          dc.w      16615
00003526  007C      9731          dc.w      124
00003528  0700      9732          dc.w      1792
                    9733   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
0000352A  2052      9734          move.l    (A2),A0
0000352C  1028 0033 9735          move.b    51(A0),D0
00003530  C0BC 0000 9736          and.l     #255,D0
00003534  00FF      
00003536  0C80 0000 9737          cmp.l     #1,D0
0000353A  0001      
0000353C  6720      9738          beq.s     OSMutexPend_34
0000353E  6206      9739          bhi.s     OSMutexPend_36
00003540  4A80      9740          tst.l     D0
00003542  670C      9741          beq.s     OSMutexPend_32
00003544  6018      9742          bra.s     OSMutexPend_34
                    9743   OSMutexPend_36:
00003546  0C80 0000 9744          cmp.l     #2,D0
0000354A  0002      
0000354C  6708      9745          beq.s     OSMutexPend_33
0000354E  600E      9746          bra.s     OSMutexPend_34
                    9747   OSMutexPend_32:
                    9748   ; case OS_STAT_PEND_OK:
                    9749   ; *perr = OS_ERR_NONE;
00003550  2045      9750          move.l    D5,A0
00003552  4210      9751          clr.b     (A0)
                    9752   ; break;
00003554  6018      9753          bra.s     OSMutexPend_31
                    9754   OSMutexPend_33:
                    9755   ; case OS_STAT_PEND_ABORT:
                    9756   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
00003556  2045      9757          move.l    D5,A0
00003558  10BC 000E 9758          move.b    #14,(A0)
                    9759   ; break;
0000355C  6010      9760          bra.s     OSMutexPend_31
                    9761   OSMutexPend_34:
                    9762   ; case OS_STAT_PEND_TO:
                    9763   ; default:
                    9764   ; OS_EventTaskRemove(OSTCBCur, pevent);
0000355E  2F03      9765          move.l    D3,-(A7)
00003560  2F12      9766          move.l    (A2),-(A7)
00003562  4EB8 1534 9767          jsr       _OS_EventTaskRemove
00003566  504F      9768          addq.w    #8,A7
                    9769   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
00003568  2045      9770          move.l    D5,A0
0000356A  10BC 000A 9771          move.b    #10,(A0)
                    9772   ; break;
                    9773   OSMutexPend_31:
                    9774   ; }
                    9775   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000356E  2052      9776          move.l    (A2),A0
00003570  4228 0032 9777          clr.b     50(A0)
                    9778   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003574  2052      9779          move.l    (A2),A0
00003576  4228 0033 9780          clr.b     51(A0)
                    9781   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
0000357A  2052      9782          move.l    (A2),A0
0000357C  42A8 001C 9783          clr.l     28(A0)
                    9784   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9785   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003580  2052      9786          move.l    (A2),A0
00003582  42A8 0020 9787          clr.l     32(A0)
                    9788   ; #endif
                    9789   ; OS_EXIT_CRITICAL();
00003586  46DF      9790          dc.w      18143
                    9791   OSMutexPend_3:
00003588  4CDF 0CFC 9792          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
0000358C  4E5E      9793          unlk      A6
0000358E  4E75      9794          rts
                    9795   ; }
                    9796   ; /*$PAGE*/
                    9797   ; /*
                    9798   ; *********************************************************************************************************
                    9799   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9800   ; *
                    9801   ; * Description: This function signals a mutual exclusion semaphore
                    9802   ; *
                    9803   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9804   ; *                                  mutex.
                    9805   ; *
                    9806   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9807   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9808   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9809   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9810   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9811   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9812   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9813   ; *                                      indicates that you did not set the PCP higher (lower
                    9814   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9815   ; *                                      Unfortunately, this is something that could not be
                    9816   ; *                                      detected when the Mutex is created because we don't know
                    9817   ; *                                      what tasks will be using the Mutex.
                    9818   ; *********************************************************************************************************
                    9819   ; */
                    9820   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9821   ; {
                    9822   _OSMutexPost:
00003590  4E56 0000 9823          link      A6,#0
00003594  48E7 3820 9824          movem.l   D2/D3/D4/A2,-(A7)
00003598  242E 0008 9825          move.l    8(A6),D2
0000359C  45F9 0800 9826          lea       _OSTCBCur.L,A2
000035A0  0E3A      
                    9827   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9828   ; INT8U      prio;
                    9829   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9830   ; OS_CPU_SR  cpu_sr = 0u;
                    9831   ; #endif
                    9832   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000035A2  1039 0800 9833          move.b    _OSIntNesting.L,D0
000035A6  0D20      
000035A8  0C00 0000 9834          cmp.b     #0,D0
000035AC  6306      9835          bls.s     OSMutexPost_1
                    9836   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
000035AE  7005      9837          moveq     #5,D0
000035B0  6000 00F0 9838          bra       OSMutexPost_3
                    9839   OSMutexPost_1:
                    9840   ; }
                    9841   ; #if OS_ARG_CHK_EN > 0u
                    9842   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9843   ; return (OS_ERR_PEVENT_NULL);
                    9844   ; }
                    9845   ; #endif
                    9846   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
000035B4  2042      9847          move.l    D2,A0
000035B6  1010      9848          move.b    (A0),D0
000035B8  0C00 0004 9849          cmp.b     #4,D0
000035BC  6706      9850          beq.s     OSMutexPost_4
                    9851   ; return (OS_ERR_EVENT_TYPE);
000035BE  7001      9852          moveq     #1,D0
000035C0  6000 00E0 9853          bra       OSMutexPost_3
                    9854   OSMutexPost_4:
                    9855   ; }
                    9856   ; OS_ENTER_CRITICAL();
000035C4  40E7      9857          dc.w      16615
000035C6  007C      9858          dc.w      124
000035C8  0700      9859          dc.w      1792
                    9860   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
000035CA  2042      9861          move.l    D2,A0
000035CC  3028 0006 9862          move.w    6(A0),D0
000035D0  E048      9863          lsr.w     #8,D0
000035D2  1800      9864          move.b    D0,D4
                    9865   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
000035D4  2042      9866          move.l    D2,A0
000035D6  3028 0006 9867          move.w    6(A0),D0
000035DA  C07C 00FF 9868          and.w     #255,D0
000035DE  1600      9869          move.b    D0,D3
                    9870   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
000035E0  2042      9871          move.l    D2,A0
000035E2  2012      9872          move.l    (A2),D0
000035E4  B0A8 0002 9873          cmp.l     2(A0),D0
000035E8  6708      9874          beq.s     OSMutexPost_6
                    9875   ; OS_EXIT_CRITICAL();
000035EA  46DF      9876          dc.w      18143
                    9877   ; return (OS_ERR_NOT_MUTEX_OWNER);
000035EC  7064      9878          moveq     #100,D0
000035EE  6000 00B2 9879          bra       OSMutexPost_3
                    9880   OSMutexPost_6:
                    9881   ; }
                    9882   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000035F2  0C04 00FF 9883          cmp.b     #255,D4
000035F6  6732      9884          beq.s     OSMutexPost_8
                    9885   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
000035F8  2052      9886          move.l    (A2),A0
000035FA  B828 0034 9887          cmp.b     52(A0),D4
000035FE  6612      9888          bne.s     OSMutexPost_10
                    9889   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
00003600  C6BC 0000 9890          and.l     #255,D3
00003604  00FF      
00003606  2F03      9891          move.l    D3,-(A7)
00003608  2F12      9892          move.l    (A2),-(A7)
0000360A  4EB9 0000 9893          jsr       @ucos_ii_OSMutex_RdyAtPrio
0000360E  375C      
00003610  504F      9894          addq.w    #8,A7
                    9895   OSMutexPost_10:
                    9896   ; }
                    9897   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
00003612  C8BC 0000 9898          and.l     #255,D4
00003616  00FF      
00003618  2004      9899          move.l    D4,D0
0000361A  E588      9900          lsl.l     #2,D0
0000361C  41F9 0800 9901          lea       _OSTCBPrioTbl.L,A0
00003620  0E4A      
00003622  21BC 0000 9902          move.l    #1,0(A0,D0.L)
00003626  0001 0800 
                    9903   OSMutexPost_8:
                    9904   ; }
                    9905   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
0000362A  2042      9906          move.l    D2,A0
0000362C  1028 0008 9907          move.b    8(A0),D0
00003630  6700 005E 9908          beq       OSMutexPost_12
                    9909   ; /* Yes, Make HPT waiting for mutex ready         */
                    9910   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
00003634  42A7      9911          clr.l     -(A7)
00003636  4878 0010 9912          pea       16
0000363A  42A7      9913          clr.l     -(A7)
0000363C  2F02      9914          move.l    D2,-(A7)
0000363E  4EB8 132E 9915          jsr       _OS_EventTaskRdy
00003642  DEFC 0010 9916          add.w     #16,A7
00003646  1600      9917          move.b    D0,D3
                    9918   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
00003648  2042      9919          move.l    D2,A0
0000364A  0268 FF00 9920          and.w     #65280,6(A0)
0000364E  0006      
                    9921   ; pevent->OSEventCnt |= prio;
00003650  2042      9922          move.l    D2,A0
00003652  C67C 00FF 9923          and.w     #255,D3
00003656  8768 0006 9924          or.w      D3,6(A0)
                    9925   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
0000365A  C6BC 0000 9926          and.l     #255,D3
0000365E  00FF      
00003660  2003      9927          move.l    D3,D0
00003662  E588      9928          lsl.l     #2,D0
00003664  41F9 0800 9929          lea       _OSTCBPrioTbl.L,A0
00003668  0E4A      
0000366A  2242      9930          move.l    D2,A1
0000366C  2370 0800 9931          move.l    0(A0,D0.L),2(A1)
00003670  0002      
                    9932   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
00003672  0C04 00FF 9933          cmp.b     #255,D4
00003676  670E      9934          beq.s     OSMutexPost_14
00003678  B604      9935          cmp.b     D4,D3
0000367A  620A      9936          bhi.s     OSMutexPost_14
                    9937   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9938   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
0000367C  46DF      9939          dc.w      18143
                    9940   ; OS_Sched();                               /*      Find highest priority task ready to run  */
0000367E  4EB8 190E 9941          jsr       _OS_Sched
                    9942   ; return (OS_ERR_PCP_LOWER);
00003682  7078      9943          moveq     #120,D0
00003684  601C      9944          bra.s     OSMutexPost_3
                    9945   OSMutexPost_14:
                    9946   ; } else {
                    9947   ; OS_EXIT_CRITICAL();
00003686  46DF      9948          dc.w      18143
                    9949   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003688  4EB8 190E 9950          jsr       _OS_Sched
                    9951   ; return (OS_ERR_NONE);
0000368C  4200      9952          clr.b     D0
0000368E  6012      9953          bra.s     OSMutexPost_3
                    9954   OSMutexPost_12:
                    9955   ; }
                    9956   ; }
                    9957   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
00003690  2042      9958          move.l    D2,A0
00003692  0068 00FF 9959          or.w      #255,6(A0)
00003696  0006      
                    9960   ; pevent->OSEventPtr  = (void *)0;
00003698  2042      9961          move.l    D2,A0
0000369A  42A8 0002 9962          clr.l     2(A0)
                    9963   ; OS_EXIT_CRITICAL();
0000369E  46DF      9964          dc.w      18143
                    9965   ; return (OS_ERR_NONE);
000036A0  4200      9966          clr.b     D0
                    9967   OSMutexPost_3:
000036A2  4CDF 041C 9968          movem.l   (A7)+,D2/D3/D4/A2
000036A6  4E5E      9969          unlk      A6
000036A8  4E75      9970          rts
                    9971   ; }
                    9972   ; /*$PAGE*/
                    9973   ; /*
                    9974   ; *********************************************************************************************************
                    9975   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9976   ; *
                    9977   ; * Description: This function obtains information about a mutex
                    9978   ; *
                    9979   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9980   ; *
                    9981   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9982   ; *
                    9983   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9984   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9985   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9986   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9987   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9988   ; *********************************************************************************************************
                    9989   ; */
                    9990   ; #if OS_MUTEX_QUERY_EN > 0u
                    9991   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9992   ; OS_MUTEX_DATA  *p_mutex_data)
                    9993   ; {
                    9994   _OSMutexQuery:
000036AA  4E56 FFF8 9995          link      A6,#-8
000036AE  48E7 3800 9996          movem.l   D2/D3/D4,-(A7)
000036B2  242E 000C 9997          move.l    12(A6),D2
000036B6  262E 0008 9998          move.l    8(A6),D3
                    9999   ; INT8U       i;
                    10000   ; OS_PRIO    *psrc;
                    10001   ; OS_PRIO    *pdest;
                    10002   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10003   ; OS_CPU_SR   cpu_sr = 0u;
                    10004   ; #endif
                    10005   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000036BA  1039 0800 10006          move.b    _OSIntNesting.L,D0
000036BE  0D20      
000036C0  0C00 0000 10007          cmp.b     #0,D0
000036C4  6306      10008          bls.s     OSMutexQuery_1
                    10009   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
000036C6  7006      10010          moveq     #6,D0
000036C8  6000 008A 10011          bra       OSMutexQuery_3
                    10012   OSMutexQuery_1:
                    10013   ; }
                    10014   ; #if OS_ARG_CHK_EN > 0u
                    10015   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10016   ; return (OS_ERR_PEVENT_NULL);
                    10017   ; }
                    10018   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    10019   ; return (OS_ERR_PDATA_NULL);
                    10020   ; }
                    10021   ; #endif
                    10022   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000036CC  2043      10023          move.l    D3,A0
000036CE  1010      10024          move.b    (A0),D0
000036D0  0C00 0004 10025          cmp.b     #4,D0
000036D4  6706      10026          beq.s     OSMutexQuery_4
                    10027   ; return (OS_ERR_EVENT_TYPE);
000036D6  7001      10028          moveq     #1,D0
000036D8  6000 007A 10029          bra       OSMutexQuery_3
                    10030   OSMutexQuery_4:
                    10031   ; }
                    10032   ; OS_ENTER_CRITICAL();
000036DC  40E7      10033          dc.w      16615
000036DE  007C      10034          dc.w      124
000036E0  0700      10035          dc.w      1792
                    10036   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
000036E2  2043      10037          move.l    D3,A0
000036E4  3028 0006 10038          move.w    6(A0),D0
000036E8  E048      10039          lsr.w     #8,D0
000036EA  2042      10040          move.l    D2,A0
000036EC  1140 000B 10041          move.b    D0,11(A0)
                    10042   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
000036F0  2043      10043          move.l    D3,A0
000036F2  3028 0006 10044          move.w    6(A0),D0
000036F6  C07C 00FF 10045          and.w     #255,D0
000036FA  2042      10046          move.l    D2,A0
000036FC  1140 000A 10047          move.b    D0,10(A0)
                    10048   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
00003700  2042      10049          move.l    D2,A0
00003702  1028 000A 10050          move.b    10(A0),D0
00003706  0C00 00FF 10051          cmp.b     #255,D0
0000370A  660A      10052          bne.s     OSMutexQuery_6
                    10053   ; p_mutex_data->OSValue = OS_TRUE;
0000370C  2042      10054          move.l    D2,A0
0000370E  117C 0001 10055          move.b    #1,9(A0)
00003712  0009      
00003714  6006      10056          bra.s     OSMutexQuery_7
                    10057   OSMutexQuery_6:
                    10058   ; } else {
                    10059   ; p_mutex_data->OSValue = OS_FALSE;
00003716  2042      10060          move.l    D2,A0
00003718  4228 0009 10061          clr.b     9(A0)
                    10062   OSMutexQuery_7:
                    10063   ; }
                    10064   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
0000371C  2043      10065          move.l    D3,A0
0000371E  2242      10066          move.l    D2,A1
00003720  1368 0008 10067          move.b    8(A0),8(A1)
00003724  0008      
                    10068   ; psrc                      = &pevent->OSEventTbl[0];
00003726  700A      10069          moveq     #10,D0
00003728  D083      10070          add.l     D3,D0
0000372A  2D40 FFF8 10071          move.l    D0,-8(A6)
                    10072   ; pdest                     = &p_mutex_data->OSEventTbl[0];
0000372E  2D42 FFFC 10073          move.l    D2,-4(A6)
                    10074   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003732  4204      10075          clr.b     D4
                    10076   OSMutexQuery_8:
00003734  0C04 0008 10077          cmp.b     #8,D4
00003738  6416      10078          bhs.s     OSMutexQuery_10
                    10079   ; *pdest++ = *psrc++;
0000373A  206E FFF8 10080          move.l    -8(A6),A0
0000373E  52AE FFF8 10081          addq.l    #1,-8(A6)
00003742  226E FFFC 10082          move.l    -4(A6),A1
00003746  52AE FFFC 10083          addq.l    #1,-4(A6)
0000374A  1290      10084          move.b    (A0),(A1)
0000374C  5204      10085          addq.b    #1,D4
0000374E  60E4      10086          bra       OSMutexQuery_8
                    10087   OSMutexQuery_10:
                    10088   ; }
                    10089   ; OS_EXIT_CRITICAL();
00003750  46DF      10090          dc.w      18143
                    10091   ; return (OS_ERR_NONE);
00003752  4200      10092          clr.b     D0
                    10093   OSMutexQuery_3:
00003754  4CDF 001C 10094          movem.l   (A7)+,D2/D3/D4
00003758  4E5E      10095          unlk      A6
0000375A  4E75      10096          rts
                    10097   ; }
                    10098   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    10099   ; /*$PAGE*/
                    10100   ; /*
                    10101   ; *********************************************************************************************************
                    10102   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    10103   ; *
                    10104   ; * Description: This function makes a task ready at the specified priority
                    10105   ; *
                    10106   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    10107   ; *
                    10108   ; *              prio            is the desired priority
                    10109   ; *
                    10110   ; * Returns    : none
                    10111   ; *********************************************************************************************************
                    10112   ; */
                    10113   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    10114   ; INT8U    prio)
                    10115   ; {
                    10116   @ucos_ii_OSMutex_RdyAtPrio:
0000375C  4E56 0000 10117          link      A6,#0
00003760  48E7 3820 10118          movem.l   D2/D3/D4/A2,-(A7)
00003764  242E 0008 10119          move.l    8(A6),D2
00003768  162E 000F 10120          move.b    15(A6),D3
0000376C  C6BC 0000 10121          and.l     #255,D3
00003770  00FF      
00003772  45F9 0800 10122          lea       _OSRdyTbl.L,A2
00003776  0D2A      
                    10123   ; INT8U  y;
                    10124   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
00003778  2042      10125          move.l    D2,A0
0000377A  1828 0036 10126          move.b    54(A0),D4
                    10127   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
0000377E  C8BC 0000 10128          and.l     #255,D4
00003782  00FF      
00003784  2042      10129          move.l    D2,A0
00003786  1028 0037 10130          move.b    55(A0),D0
0000378A  4600      10131          not.b     D0
0000378C  C132 4800 10132          and.b     D0,0(A2,D4.L)
                    10133   ; if (OSRdyTbl[y] == 0u) {
00003790  C8BC 0000 10134          and.l     #255,D4
00003794  00FF      
00003796  1032 4800 10135          move.b    0(A2,D4.L),D0
0000379A  660E      10136          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    10137   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000379C  2042      10138          move.l    D2,A0
0000379E  1028 0038 10139          move.b    56(A0),D0
000037A2  4600      10140          not.b     D0
000037A4  C139 0800 10141          and.b     D0,_OSRdyGrp.L
000037A8  0D28      
                    10142   @ucos_ii_OSMutex_RdyAtPrio_1:
                    10143   ; }
                    10144   ; ptcb->OSTCBPrio         = prio;
000037AA  2042      10145          move.l    D2,A0
000037AC  1143 0034 10146          move.b    D3,52(A0)
                    10147   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
000037B0  13C3 0800 10148          move.b    D3,_OSPrioCur.L
000037B4  0D24      
                    10149   ; #if OS_LOWEST_PRIO <= 63u
                    10150   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
000037B6  1003      10151          move.b    D3,D0
000037B8  E608      10152          lsr.b     #3,D0
000037BA  C03C 0007 10153          and.b     #7,D0
000037BE  2042      10154          move.l    D2,A0
000037C0  1140 0036 10155          move.b    D0,54(A0)
                    10156   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
000037C4  1003      10157          move.b    D3,D0
000037C6  C03C 0007 10158          and.b     #7,D0
000037CA  2042      10159          move.l    D2,A0
000037CC  1140 0035 10160          move.b    D0,53(A0)
                    10161   ; #else
                    10162   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    10163   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    10164   ; #endif
                    10165   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
000037D0  7001      10166          moveq     #1,D0
000037D2  2042      10167          move.l    D2,A0
000037D4  1228 0036 10168          move.b    54(A0),D1
000037D8  C2BC 0000 10169          and.l     #255,D1
000037DC  00FF      
000037DE  E3A8      10170          lsl.l     D1,D0
000037E0  2042      10171          move.l    D2,A0
000037E2  1140 0038 10172          move.b    D0,56(A0)
                    10173   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000037E6  7001      10174          moveq     #1,D0
000037E8  2042      10175          move.l    D2,A0
000037EA  1228 0035 10176          move.b    53(A0),D1
000037EE  C2BC 0000 10177          and.l     #255,D1
000037F2  00FF      
000037F4  E3A8      10178          lsl.l     D1,D0
000037F6  2042      10179          move.l    D2,A0
000037F8  1140 0037 10180          move.b    D0,55(A0)
                    10181   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
000037FC  2042      10182          move.l    D2,A0
000037FE  1028 0038 10183          move.b    56(A0),D0
00003802  8139 0800 10184          or.b      D0,_OSRdyGrp.L
00003806  0D28      
                    10185   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00003808  2042      10186          move.l    D2,A0
0000380A  1028 0036 10187          move.b    54(A0),D0
0000380E  C0BC 0000 10188          and.l     #255,D0
00003812  00FF      
00003814  2042      10189          move.l    D2,A0
00003816  1228 0037 10190          move.b    55(A0),D1
0000381A  8332 0800 10191          or.b      D1,0(A2,D0.L)
                    10192   ; OSTCBPrioTbl[prio]      = ptcb;
0000381E  C6BC 0000 10193          and.l     #255,D3
00003822  00FF      
00003824  2003      10194          move.l    D3,D0
00003826  E588      10195          lsl.l     #2,D0
00003828  41F9 0800 10196          lea       _OSTCBPrioTbl.L,A0
0000382C  0E4A      
0000382E  2182 0800 10197          move.l    D2,0(A0,D0.L)
00003832  4CDF 041C 10198          movem.l   (A7)+,D2/D3/D4/A2
00003836  4E5E      10199          unlk      A6
00003838  4E75      10200          rts
                    10201   ; /*
                    10202   ; *********************************************************************************************************
                    10203   ; *                                                uC/OS-II
                    10204   ; *                                          The Real-Time Kernel
                    10205   ; *                                        MESSAGE QUEUE MANAGEMENT
                    10206   ; *
                    10207   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    10208   ; *                                           All Rights Reserved
                    10209   ; *
                    10210   ; * File    : OS_Q.C
                    10211   ; * By      : Jean J. Labrosse
                    10212   ; * Version : V2.92.07
                    10213   ; *
                    10214   ; * LICENSING TERMS:
                    10215   ; * ---------------
                    10216   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    10217   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    10218   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    10219   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    10220   ; * licensing fee.
                    10221   ; *********************************************************************************************************
                    10222   ; */
                    10223   ; #define  MICRIUM_SOURCE
                    10224   ; #ifndef  OS_MASTER_FILE
                    10225   ; #include <ucos_ii.h>
                    10226   ; #endif
                    10227   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    10228   ; /*
                    10229   ; *********************************************************************************************************
                    10230   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    10231   ; *
                    10232   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    10233   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    10234   ; *
                    10235   ; * Arguments  : pevent        is a pointer to the event control block
                    10236   ; *
                    10237   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10238   ; *                            messages are:
                    10239   ; *
                    10240   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10241   ; *                                                message.
                    10242   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10243   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10244   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    10245   ; *
                    10246   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    10247   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    10248   ; *                            one less entry.
                    10249   ; *              == (void *)0  if you received a NULL pointer message
                    10250   ; *                            if the queue is empty or,
                    10251   ; *                            if 'pevent' is a NULL pointer or,
                    10252   ; *                            if you passed an invalid event type
                    10253   ; *
                    10254   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    10255   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    10256   ; *********************************************************************************************************
                    10257   ; */
                    10258   ; #if OS_Q_ACCEPT_EN > 0u
                    10259   ; void  *OSQAccept (OS_EVENT  *pevent,
                    10260   ; INT8U     *perr)
                    10261   ; {
                    10262   _OSQAccept:
0000383A  4E56 0000 10263          link      A6,#0
0000383E  48E7 3800 10264          movem.l   D2/D3/D4,-(A7)
00003842  282E 000C 10265          move.l    12(A6),D4
                    10266   ; void      *pmsg;
                    10267   ; OS_Q      *pq;
                    10268   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10269   ; OS_CPU_SR  cpu_sr = 0u;
                    10270   ; #endif
                    10271   ; #ifdef OS_SAFETY_CRITICAL
                    10272   ; if (perr == (INT8U *)0) {
                    10273   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10274   ; return ((void *)0);
                    10275   ; }
                    10276   ; #endif
                    10277   ; #if OS_ARG_CHK_EN > 0u
                    10278   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10279   ; *perr = OS_ERR_PEVENT_NULL;
                    10280   ; return ((void *)0);
                    10281   ; }
                    10282   ; #endif
                    10283   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003846  206E 0008 10284          move.l    8(A6),A0
0000384A  1010      10285          move.b    (A0),D0
0000384C  0C00 0002 10286          cmp.b     #2,D0
00003850  670C      10287          beq.s     OSQAccept_1
                    10288   ; *perr = OS_ERR_EVENT_TYPE;
00003852  2044      10289          move.l    D4,A0
00003854  10BC 0001 10290          move.b    #1,(A0)
                    10291   ; return ((void *)0);
00003858  4280      10292          clr.l     D0
0000385A  6000 0064 10293          bra       OSQAccept_3
                    10294   OSQAccept_1:
                    10295   ; }
                    10296   ; OS_ENTER_CRITICAL();
0000385E  40E7      10297          dc.w      16615
00003860  007C      10298          dc.w      124
00003862  0700      10299          dc.w      1792
                    10300   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003864  206E 0008 10301          move.l    8(A6),A0
00003868  2428 0002 10302          move.l    2(A0),D2
                    10303   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
0000386C  2042      10304          move.l    D2,A0
0000386E  3028 0016 10305          move.w    22(A0),D0
00003872  0C40 0000 10306          cmp.w     #0,D0
00003876  6300 003C 10307          bls       OSQAccept_4
                    10308   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
0000387A  2002      10309          move.l    D2,D0
0000387C  0680 0000 10310          add.l     #16,D0
00003880  0010      
00003882  2040      10311          move.l    D0,A0
00003884  2250      10312          move.l    (A0),A1
00003886  5890      10313          addq.l    #4,(A0)
00003888  2611      10314          move.l    (A1),D3
                    10315   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
0000388A  2002      10316          move.l    D2,D0
0000388C  0680 0000 10317          add.l     #22,D0
00003890  0016      
00003892  2040      10318          move.l    D0,A0
00003894  5350      10319          subq.w    #1,(A0)
                    10320   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003896  2042      10321          move.l    D2,A0
00003898  2242      10322          move.l    D2,A1
0000389A  2028 0010 10323          move.l    16(A0),D0
0000389E  B0A9 0008 10324          cmp.l     8(A1),D0
000038A2  660A      10325          bne.s     OSQAccept_6
                    10326   ; pq->OSQOut = pq->OSQStart;
000038A4  2042      10327          move.l    D2,A0
000038A6  2242      10328          move.l    D2,A1
000038A8  2368 0004 10329          move.l    4(A0),16(A1)
000038AC  0010      
                    10330   OSQAccept_6:
                    10331   ; }
                    10332   ; *perr = OS_ERR_NONE;
000038AE  2044      10333          move.l    D4,A0
000038B0  4210      10334          clr.b     (A0)
000038B2  6008      10335          bra.s     OSQAccept_5
                    10336   OSQAccept_4:
                    10337   ; } else {
                    10338   ; *perr = OS_ERR_Q_EMPTY;
000038B4  2044      10339          move.l    D4,A0
000038B6  10BC 001F 10340          move.b    #31,(A0)
                    10341   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
000038BA  4283      10342          clr.l     D3
                    10343   OSQAccept_5:
                    10344   ; }
                    10345   ; OS_EXIT_CRITICAL();
000038BC  46DF      10346          dc.w      18143
                    10347   ; return (pmsg);                               /* Return message received (or NULL)                  */
000038BE  2003      10348          move.l    D3,D0
                    10349   OSQAccept_3:
000038C0  4CDF 001C 10350          movem.l   (A7)+,D2/D3/D4
000038C4  4E5E      10351          unlk      A6
000038C6  4E75      10352          rts
                    10353   ; }
                    10354   ; #endif
                    10355   ; /*$PAGE*/
                    10356   ; /*
                    10357   ; *********************************************************************************************************
                    10358   ; *                                       CREATE A MESSAGE QUEUE
                    10359   ; *
                    10360   ; * Description: This function creates a message queue if free event control blocks are available.
                    10361   ; *
                    10362   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    10363   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    10364   ; *
                    10365   ; *                            void *MessageStorage[size]
                    10366   ; *
                    10367   ; *              size          is the number of elements in the storage area
                    10368   ; *
                    10369   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    10370   ; *                                created queue
                    10371   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    10372   ; *********************************************************************************************************
                    10373   ; */
                    10374   ; OS_EVENT  *OSQCreate (void    **start,
                    10375   ; INT16U    size)
                    10376   ; {
                    10377   _OSQCreate:
000038C8  4E56 0000 10378          link      A6,#0
000038CC  48E7 3830 10379          movem.l   D2/D3/D4/A2/A3,-(A7)
000038D0  45F9 0800 10380          lea       _OSEventFreeList.L,A2
000038D4  0AF4      
000038D6  282E 0008 10381          move.l    8(A6),D4
000038DA  47F9 0800 10382          lea       _OSQFreeList.L,A3
000038DE  172A      
                    10383   ; OS_EVENT  *pevent;
                    10384   ; OS_Q      *pq;
                    10385   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10386   ; OS_CPU_SR  cpu_sr = 0u;
                    10387   ; #endif
                    10388   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    10389   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    10390   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10391   ; return ((OS_EVENT *)0);
                    10392   ; }
                    10393   ; #endif
                    10394   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000038E0  1039 0800 10395          move.b    _OSIntNesting.L,D0
000038E4  0D20      
000038E6  0C00 0000 10396          cmp.b     #0,D0
000038EA  6306      10397          bls.s     OSQCreate_1
                    10398   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000038EC  4280      10399          clr.l     D0
000038EE  6000 009C 10400          bra       OSQCreate_3
                    10401   OSQCreate_1:
                    10402   ; }
                    10403   ; OS_ENTER_CRITICAL();
000038F2  40E7      10404          dc.w      16615
000038F4  007C      10405          dc.w      124
000038F6  0700      10406          dc.w      1792
                    10407   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000038F8  2412      10408          move.l    (A2),D2
                    10409   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000038FA  2012      10410          move.l    (A2),D0
000038FC  6706      10411          beq.s     OSQCreate_4
                    10412   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000038FE  2052      10413          move.l    (A2),A0
00003900  24A8 0002 10414          move.l    2(A0),(A2)
                    10415   OSQCreate_4:
                    10416   ; }
                    10417   ; OS_EXIT_CRITICAL();
00003904  46DF      10418          dc.w      18143
                    10419   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
00003906  4A82      10420          tst.l     D2
00003908  6700 0080 10421          beq       OSQCreate_9
                    10422   ; OS_ENTER_CRITICAL();
0000390C  40E7      10423          dc.w      16615
0000390E  007C      10424          dc.w      124
00003910  0700      10425          dc.w      1792
                    10426   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
00003912  2613      10427          move.l    (A3),D3
                    10428   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
00003914  4A83      10429          tst.l     D3
00003916  6700 0066 10430          beq       OSQCreate_8
                    10431   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
0000391A  2053      10432          move.l    (A3),A0
0000391C  2690      10433          move.l    (A0),(A3)
                    10434   ; OS_EXIT_CRITICAL();
0000391E  46DF      10435          dc.w      18143
                    10436   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
00003920  2043      10437          move.l    D3,A0
00003922  2144 0004 10438          move.l    D4,4(A0)
                    10439   ; pq->OSQEnd             = &start[size];
00003926  2004      10440          move.l    D4,D0
00003928  322E 000E 10441          move.w    14(A6),D1
0000392C  C2BC 0000 10442          and.l     #65535,D1
00003930  FFFF      
00003932  E589      10443          lsl.l     #2,D1
00003934  D081      10444          add.l     D1,D0
00003936  2043      10445          move.l    D3,A0
00003938  2140 0008 10446          move.l    D0,8(A0)
                    10447   ; pq->OSQIn              = start;
0000393C  2043      10448          move.l    D3,A0
0000393E  2144 000C 10449          move.l    D4,12(A0)
                    10450   ; pq->OSQOut             = start;
00003942  2043      10451          move.l    D3,A0
00003944  2144 0010 10452          move.l    D4,16(A0)
                    10453   ; pq->OSQSize            = size;
00003948  2043      10454          move.l    D3,A0
0000394A  316E 000E 10455          move.w    14(A6),20(A0)
0000394E  0014      
                    10456   ; pq->OSQEntries         = 0u;
00003950  2043      10457          move.l    D3,A0
00003952  4268 0016 10458          clr.w     22(A0)
                    10459   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
00003956  2042      10460          move.l    D2,A0
00003958  10BC 0002 10461          move.b    #2,(A0)
                    10462   ; pevent->OSEventCnt     = 0u;
0000395C  2042      10463          move.l    D2,A0
0000395E  4268 0006 10464          clr.w     6(A0)
                    10465   ; pevent->OSEventPtr     = pq;
00003962  2042      10466          move.l    D2,A0
00003964  2143 0002 10467          move.l    D3,2(A0)
                    10468   ; #if OS_EVENT_NAME_EN > 0u
                    10469   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003968  41F9 0000 10470          lea       @ucos_ii_1.L,A0
0000396C  6F2A      
0000396E  2242      10471          move.l    D2,A1
00003970  2348 0012 10472          move.l    A0,18(A1)
                    10473   ; #endif
                    10474   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
00003974  2F02      10475          move.l    D2,-(A7)
00003976  4EB8 15F6 10476          jsr       _OS_EventWaitListInit
0000397A  584F      10477          addq.w    #4,A7
0000397C  600C      10478          bra.s     OSQCreate_9
                    10479   OSQCreate_8:
                    10480   ; } else {
                    10481   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
0000397E  2042      10482          move.l    D2,A0
00003980  2152 0002 10483          move.l    (A2),2(A0)
                    10484   ; OSEventFreeList    = pevent;
00003984  2482      10485          move.l    D2,(A2)
                    10486   ; OS_EXIT_CRITICAL();
00003986  46DF      10487          dc.w      18143
                    10488   ; pevent = (OS_EVENT *)0;
00003988  4282      10489          clr.l     D2
                    10490   OSQCreate_9:
                    10491   ; }
                    10492   ; }
                    10493   ; return (pevent);
0000398A  2002      10494          move.l    D2,D0
                    10495   OSQCreate_3:
0000398C  4CDF 0C1C 10496          movem.l   (A7)+,D2/D3/D4/A2/A3
00003990  4E5E      10497          unlk      A6
00003992  4E75      10498          rts
                    10499   ; }
                    10500   ; /*$PAGE*/
                    10501   ; /*
                    10502   ; *********************************************************************************************************
                    10503   ; *                                       DELETE A MESSAGE QUEUE
                    10504   ; *
                    10505   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10506   ; *
                    10507   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10508   ; *                            queue.
                    10509   ; *
                    10510   ; *              opt           determines delete options as follows:
                    10511   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10512   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10513   ; *                                                    In this case, all the tasks pending will be readied.
                    10514   ; *
                    10515   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10516   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10517   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10518   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10519   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10520   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10521   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10522   ; *
                    10523   ; * Returns    : pevent        upon error
                    10524   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10525   ; *
                    10526   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10527   ; *                 the queue MUST check the return code of OSQPend().
                    10528   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10529   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10530   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10531   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10532   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10533   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10534   ; *                 will no longer be guarded by the queue.
                    10535   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10536   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10537   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10538   ; *                 then, the storage can be reused.
                    10539   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10540   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10541   ; *********************************************************************************************************
                    10542   ; */
                    10543   ; #if OS_Q_DEL_EN > 0u
                    10544   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10545   ; INT8U      opt,
                    10546   ; INT8U     *perr)
                    10547   ; {
                    10548   _OSQDel:
00003994  4E56 0000 10549          link      A6,#0
00003998  48E7 3E30 10550          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
0000399C  242E 0008 10551          move.l    8(A6),D2
000039A0  282E 0010 10552          move.l    16(A6),D4
000039A4  45F9 0800 10553          lea       _OSEventFreeList.L,A2
000039A8  0AF4      
000039AA  47F9 0800 10554          lea       _OSQFreeList.L,A3
000039AE  172A      
                    10555   ; BOOLEAN    tasks_waiting;
                    10556   ; OS_EVENT  *pevent_return;
                    10557   ; OS_Q      *pq;
                    10558   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10559   ; OS_CPU_SR  cpu_sr = 0u;
                    10560   ; #endif
                    10561   ; #ifdef OS_SAFETY_CRITICAL
                    10562   ; if (perr == (INT8U *)0) {
                    10563   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10564   ; return ((OS_EVENT *)0);
                    10565   ; }
                    10566   ; #endif
                    10567   ; #if OS_ARG_CHK_EN > 0u
                    10568   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10569   ; *perr = OS_ERR_PEVENT_NULL;
                    10570   ; return (pevent);
                    10571   ; }
                    10572   ; #endif
                    10573   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
000039B0  2042      10574          move.l    D2,A0
000039B2  1010      10575          move.b    (A0),D0
000039B4  0C00 0002 10576          cmp.b     #2,D0
000039B8  670C      10577          beq.s     OSQDel_1
                    10578   ; *perr = OS_ERR_EVENT_TYPE;
000039BA  2044      10579          move.l    D4,A0
000039BC  10BC 0001 10580          move.b    #1,(A0)
                    10581   ; return (pevent);
000039C0  2002      10582          move.l    D2,D0
000039C2  6000 0104 10583          bra       OSQDel_3
                    10584   OSQDel_1:
                    10585   ; }
                    10586   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000039C6  1039 0800 10587          move.b    _OSIntNesting.L,D0
000039CA  0D20      
000039CC  0C00 0000 10588          cmp.b     #0,D0
000039D0  630C      10589          bls.s     OSQDel_4
                    10590   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000039D2  2044      10591          move.l    D4,A0
000039D4  10BC 000F 10592          move.b    #15,(A0)
                    10593   ; return (pevent);
000039D8  2002      10594          move.l    D2,D0
000039DA  6000 00EC 10595          bra       OSQDel_3
                    10596   OSQDel_4:
                    10597   ; }
                    10598   ; OS_ENTER_CRITICAL();
000039DE  40E7      10599          dc.w      16615
000039E0  007C      10600          dc.w      124
000039E2  0700      10601          dc.w      1792
                    10602   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
000039E4  2042      10603          move.l    D2,A0
000039E6  1028 0008 10604          move.b    8(A0),D0
000039EA  6704      10605          beq.s     OSQDel_6
                    10606   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000039EC  7C01      10607          moveq     #1,D6
000039EE  6002      10608          bra.s     OSQDel_7
                    10609   OSQDel_6:
                    10610   ; } else {
                    10611   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000039F0  4206      10612          clr.b     D6
                    10613   OSQDel_7:
                    10614   ; }
                    10615   ; switch (opt) {
000039F2  102E 000F 10616          move.b    15(A6),D0
000039F6  C0BC 0000 10617          and.l     #255,D0
000039FA  00FF      
000039FC  0C80 0000 10618          cmp.l     #1,D0
00003A00  0001      
00003A02  6700 0056 10619          beq       OSQDel_11
00003A06  6200 00B4 10620          bhi       OSQDel_8
00003A0A  4A80      10621          tst.l     D0
00003A0C  6704      10622          beq.s     OSQDel_10
00003A0E  6000 00AC 10623          bra       OSQDel_8
                    10624   OSQDel_10:
                    10625   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10626   ; if (tasks_waiting == OS_FALSE) {
00003A12  4A06      10627          tst.b     D6
00003A14  6600 0036 10628          bne       OSQDel_13
                    10629   ; #if OS_EVENT_NAME_EN > 0u
                    10630   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003A18  41F9 0000 10631          lea       @ucos_ii_1.L,A0
00003A1C  6F2A      
00003A1E  2242      10632          move.l    D2,A1
00003A20  2348 0012 10633          move.l    A0,18(A1)
                    10634   ; #endif
                    10635   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
00003A24  2042      10636          move.l    D2,A0
00003A26  2628 0002 10637          move.l    2(A0),D3
                    10638   ; pq->OSQPtr             = OSQFreeList;
00003A2A  2043      10639          move.l    D3,A0
00003A2C  2093      10640          move.l    (A3),(A0)
                    10641   ; OSQFreeList            = pq;
00003A2E  2683      10642          move.l    D3,(A3)
                    10643   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003A30  2042      10644          move.l    D2,A0
00003A32  4210      10645          clr.b     (A0)
                    10646   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003A34  2042      10647          move.l    D2,A0
00003A36  2152 0002 10648          move.l    (A2),2(A0)
                    10649   ; pevent->OSEventCnt     = 0u;
00003A3A  2042      10650          move.l    D2,A0
00003A3C  4268 0006 10651          clr.w     6(A0)
                    10652   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003A40  2482      10653          move.l    D2,(A2)
                    10654   ; OS_EXIT_CRITICAL();
00003A42  46DF      10655          dc.w      18143
                    10656   ; *perr                  = OS_ERR_NONE;
00003A44  2044      10657          move.l    D4,A0
00003A46  4210      10658          clr.b     (A0)
                    10659   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
00003A48  4285      10660          clr.l     D5
00003A4A  600A      10661          bra.s     OSQDel_14
                    10662   OSQDel_13:
                    10663   ; } else {
                    10664   ; OS_EXIT_CRITICAL();
00003A4C  46DF      10665          dc.w      18143
                    10666   ; *perr                  = OS_ERR_TASK_WAITING;
00003A4E  2044      10667          move.l    D4,A0
00003A50  10BC 0049 10668          move.b    #73,(A0)
                    10669   ; pevent_return          = pevent;
00003A54  2A02      10670          move.l    D2,D5
                    10671   OSQDel_14:
                    10672   ; }
                    10673   ; break;
00003A56  6000 006E 10674          bra       OSQDel_9
                    10675   OSQDel_11:
                    10676   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10677   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10678   OSQDel_15:
00003A5A  2042      10679          move.l    D2,A0
00003A5C  1028 0008 10680          move.b    8(A0),D0
00003A60  671C      10681          beq.s     OSQDel_17
                    10682   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003A62  4878 0002 10683          pea       2
00003A66  4878 0004 10684          pea       4
00003A6A  42A7      10685          clr.l     -(A7)
00003A6C  2F02      10686          move.l    D2,-(A7)
00003A6E  4EB8 132E 10687          jsr       _OS_EventTaskRdy
00003A72  DEFC 0010 10688          add.w     #16,A7
00003A76  C0BC 0000 10689          and.l     #255,D0
00003A7A  00FF      
00003A7C  60DC      10690          bra       OSQDel_15
                    10691   OSQDel_17:
                    10692   ; }
                    10693   ; #if OS_EVENT_NAME_EN > 0u
                    10694   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003A7E  41F9 0000 10695          lea       @ucos_ii_1.L,A0
00003A82  6F2A      
00003A84  2242      10696          move.l    D2,A1
00003A86  2348 0012 10697          move.l    A0,18(A1)
                    10698   ; #endif
                    10699   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003A8A  2042      10700          move.l    D2,A0
00003A8C  2628 0002 10701          move.l    2(A0),D3
                    10702   ; pq->OSQPtr             = OSQFreeList;
00003A90  2043      10703          move.l    D3,A0
00003A92  2093      10704          move.l    (A3),(A0)
                    10705   ; OSQFreeList            = pq;
00003A94  2683      10706          move.l    D3,(A3)
                    10707   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003A96  2042      10708          move.l    D2,A0
00003A98  4210      10709          clr.b     (A0)
                    10710   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003A9A  2042      10711          move.l    D2,A0
00003A9C  2152 0002 10712          move.l    (A2),2(A0)
                    10713   ; pevent->OSEventCnt     = 0u;
00003AA0  2042      10714          move.l    D2,A0
00003AA2  4268 0006 10715          clr.w     6(A0)
                    10716   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003AA6  2482      10717          move.l    D2,(A2)
                    10718   ; OS_EXIT_CRITICAL();
00003AA8  46DF      10719          dc.w      18143
                    10720   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003AAA  0C06 0001 10721          cmp.b     #1,D6
00003AAE  6604      10722          bne.s     OSQDel_18
                    10723   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003AB0  4EB8 190E 10724          jsr       _OS_Sched
                    10725   OSQDel_18:
                    10726   ; }
                    10727   ; *perr                  = OS_ERR_NONE;
00003AB4  2044      10728          move.l    D4,A0
00003AB6  4210      10729          clr.b     (A0)
                    10730   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
00003AB8  4285      10731          clr.l     D5
                    10732   ; break;
00003ABA  600A      10733          bra.s     OSQDel_9
                    10734   OSQDel_8:
                    10735   ; default:
                    10736   ; OS_EXIT_CRITICAL();
00003ABC  46DF      10737          dc.w      18143
                    10738   ; *perr                  = OS_ERR_INVALID_OPT;
00003ABE  2044      10739          move.l    D4,A0
00003AC0  10BC 0007 10740          move.b    #7,(A0)
                    10741   ; pevent_return          = pevent;
00003AC4  2A02      10742          move.l    D2,D5
                    10743   ; break;
                    10744   OSQDel_9:
                    10745   ; }
                    10746   ; return (pevent_return);
00003AC6  2005      10747          move.l    D5,D0
                    10748   OSQDel_3:
00003AC8  4CDF 0C7C 10749          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
00003ACC  4E5E      10750          unlk      A6
00003ACE  4E75      10751          rts
                    10752   ; }
                    10753   ; #endif
                    10754   ; /*$PAGE*/
                    10755   ; /*
                    10756   ; *********************************************************************************************************
                    10757   ; *                                             FLUSH QUEUE
                    10758   ; *
                    10759   ; * Description : This function is used to flush the contents of the message queue.
                    10760   ; *
                    10761   ; * Arguments   : none
                    10762   ; *
                    10763   ; * Returns     : OS_ERR_NONE         upon success
                    10764   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10765   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10766   ; *
                    10767   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10768   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10769   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10770   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10771   ; *********************************************************************************************************
                    10772   ; */
                    10773   ; #if OS_Q_FLUSH_EN > 0u
                    10774   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10775   ; {
                    10776   _OSQFlush:
00003AD0  4E56 0000 10777          link      A6,#0
00003AD4  2F02      10778          move.l    D2,-(A7)
                    10779   ; OS_Q      *pq;
                    10780   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10781   ; OS_CPU_SR  cpu_sr = 0u;
                    10782   ; #endif
                    10783   ; #if OS_ARG_CHK_EN > 0u
                    10784   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10785   ; return (OS_ERR_PEVENT_NULL);
                    10786   ; }
                    10787   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10788   ; return (OS_ERR_EVENT_TYPE);
                    10789   ; }
                    10790   ; #endif
                    10791   ; OS_ENTER_CRITICAL();
00003AD6  40E7      10792          dc.w      16615
00003AD8  007C      10793          dc.w      124
00003ADA  0700      10794          dc.w      1792
                    10795   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
00003ADC  206E 0008 10796          move.l    8(A6),A0
00003AE0  2428 0002 10797          move.l    2(A0),D2
                    10798   ; pq->OSQIn      = pq->OSQStart;
00003AE4  2042      10799          move.l    D2,A0
00003AE6  2242      10800          move.l    D2,A1
00003AE8  2368 0004 10801          move.l    4(A0),12(A1)
00003AEC  000C      
                    10802   ; pq->OSQOut     = pq->OSQStart;
00003AEE  2042      10803          move.l    D2,A0
00003AF0  2242      10804          move.l    D2,A1
00003AF2  2368 0004 10805          move.l    4(A0),16(A1)
00003AF6  0010      
                    10806   ; pq->OSQEntries = 0u;
00003AF8  2042      10807          move.l    D2,A0
00003AFA  4268 0016 10808          clr.w     22(A0)
                    10809   ; OS_EXIT_CRITICAL();
00003AFE  46DF      10810          dc.w      18143
                    10811   ; return (OS_ERR_NONE);
00003B00  4200      10812          clr.b     D0
00003B02  241F      10813          move.l    (A7)+,D2
00003B04  4E5E      10814          unlk      A6
00003B06  4E75      10815          rts
                    10816   ; }
                    10817   ; #endif
                    10818   ; /*$PAGE*/
                    10819   ; /*
                    10820   ; *********************************************************************************************************
                    10821   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10822   ; *
                    10823   ; * Description: This function waits for a message to be sent to a queue
                    10824   ; *
                    10825   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10826   ; *
                    10827   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10828   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10829   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10830   ; *                            forever at the specified queue or, until a message arrives.
                    10831   ; *
                    10832   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10833   ; *                            messages are:
                    10834   ; *
                    10835   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10836   ; *                                                message.
                    10837   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10838   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10839   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10840   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10841   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10842   ; *                                                would lead to a suspension.
                    10843   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10844   ; *
                    10845   ; * Returns    : != (void *)0  is a pointer to the message received
                    10846   ; *              == (void *)0  if you received a NULL pointer message or,
                    10847   ; *                            if no message was received or,
                    10848   ; *                            if 'pevent' is a NULL pointer or,
                    10849   ; *                            if you didn't pass a pointer to a queue.
                    10850   ; *
                    10851   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10852   ; *********************************************************************************************************
                    10853   ; */
                    10854   ; void  *OSQPend (OS_EVENT  *pevent,
                    10855   ; INT32U     timeout,
                    10856   ; INT8U     *perr)
                    10857   ; {
                    10858   _OSQPend:
00003B08  4E56 0000 10859          link      A6,#0
00003B0C  48E7 3C20 10860          movem.l   D2/D3/D4/D5/A2,-(A7)
00003B10  45F9 0800 10861          lea       _OSTCBCur.L,A2
00003B14  0E3A      
00003B16  262E 0010 10862          move.l    16(A6),D3
00003B1A  2A2E 0008 10863          move.l    8(A6),D5
                    10864   ; void      *pmsg;
                    10865   ; OS_Q      *pq;
                    10866   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10867   ; OS_CPU_SR  cpu_sr = 0u;
                    10868   ; #endif
                    10869   ; #ifdef OS_SAFETY_CRITICAL
                    10870   ; if (perr == (INT8U *)0) {
                    10871   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10872   ; return ((void *)0);
                    10873   ; }
                    10874   ; #endif
                    10875   ; #if OS_ARG_CHK_EN > 0u
                    10876   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10877   ; *perr = OS_ERR_PEVENT_NULL;
                    10878   ; return ((void *)0);
                    10879   ; }
                    10880   ; #endif
                    10881   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003B1E  2045      10882          move.l    D5,A0
00003B20  1010      10883          move.b    (A0),D0
00003B22  0C00 0002 10884          cmp.b     #2,D0
00003B26  670C      10885          beq.s     OSQPend_1
                    10886   ; *perr = OS_ERR_EVENT_TYPE;
00003B28  2043      10887          move.l    D3,A0
00003B2A  10BC 0001 10888          move.b    #1,(A0)
                    10889   ; return ((void *)0);
00003B2E  4280      10890          clr.l     D0
00003B30  6000 0128 10891          bra       OSQPend_3
                    10892   OSQPend_1:
                    10893   ; }
                    10894   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00003B34  1039 0800 10895          move.b    _OSIntNesting.L,D0
00003B38  0D20      
00003B3A  0C00 0000 10896          cmp.b     #0,D0
00003B3E  630C      10897          bls.s     OSQPend_4
                    10898   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
00003B40  2043      10899          move.l    D3,A0
00003B42  10BC 0002 10900          move.b    #2,(A0)
                    10901   ; return ((void *)0);
00003B46  4280      10902          clr.l     D0
00003B48  6000 0110 10903          bra       OSQPend_3
                    10904   OSQPend_4:
                    10905   ; }
                    10906   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00003B4C  1039 0800 10907          move.b    _OSLockNesting.L,D0
00003B50  0D22      
00003B52  0C00 0000 10908          cmp.b     #0,D0
00003B56  630C      10909          bls.s     OSQPend_6
                    10910   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003B58  2043      10911          move.l    D3,A0
00003B5A  10BC 000D 10912          move.b    #13,(A0)
                    10913   ; return ((void *)0);
00003B5E  4280      10914          clr.l     D0
00003B60  6000 00F8 10915          bra       OSQPend_3
                    10916   OSQPend_6:
                    10917   ; }
                    10918   ; OS_ENTER_CRITICAL();
00003B64  40E7      10919          dc.w      16615
00003B66  007C      10920          dc.w      124
00003B68  0700      10921          dc.w      1792
                    10922   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003B6A  2045      10923          move.l    D5,A0
00003B6C  2428 0002 10924          move.l    2(A0),D2
                    10925   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003B70  2042      10926          move.l    D2,A0
00003B72  3028 0016 10927          move.w    22(A0),D0
00003B76  0C40 0000 10928          cmp.w     #0,D0
00003B7A  6300 0042 10929          bls       OSQPend_8
                    10930   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003B7E  2002      10931          move.l    D2,D0
00003B80  0680 0000 10932          add.l     #16,D0
00003B84  0010      
00003B86  2040      10933          move.l    D0,A0
00003B88  2250      10934          move.l    (A0),A1
00003B8A  5890      10935          addq.l    #4,(A0)
00003B8C  2811      10936          move.l    (A1),D4
                    10937   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003B8E  2002      10938          move.l    D2,D0
00003B90  0680 0000 10939          add.l     #22,D0
00003B94  0016      
00003B96  2040      10940          move.l    D0,A0
00003B98  5350      10941          subq.w    #1,(A0)
                    10942   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003B9A  2042      10943          move.l    D2,A0
00003B9C  2242      10944          move.l    D2,A1
00003B9E  2028 0010 10945          move.l    16(A0),D0
00003BA2  B0A9 0008 10946          cmp.l     8(A1),D0
00003BA6  660A      10947          bne.s     OSQPend_10
                    10948   ; pq->OSQOut = pq->OSQStart;
00003BA8  2042      10949          move.l    D2,A0
00003BAA  2242      10950          move.l    D2,A1
00003BAC  2368 0004 10951          move.l    4(A0),16(A1)
00003BB0  0010      
                    10952   OSQPend_10:
                    10953   ; }
                    10954   ; OS_EXIT_CRITICAL();
00003BB2  46DF      10955          dc.w      18143
                    10956   ; *perr = OS_ERR_NONE;
00003BB4  2043      10957          move.l    D3,A0
00003BB6  4210      10958          clr.b     (A0)
                    10959   ; return (pmsg);                           /* Return message received                            */
00003BB8  2004      10960          move.l    D4,D0
00003BBA  6000 009E 10961          bra       OSQPend_3
                    10962   OSQPend_8:
                    10963   ; }
                    10964   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
00003BBE  2052      10965          move.l    (A2),A0
00003BC0  0028 0004 10966          or.b      #4,50(A0)
00003BC4  0032      
                    10967   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003BC6  2052      10968          move.l    (A2),A0
00003BC8  4228 0033 10969          clr.b     51(A0)
                    10970   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00003BCC  2052      10971          move.l    (A2),A0
00003BCE  216E 000C 10972          move.l    12(A6),46(A0)
00003BD2  002E      
                    10973   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
00003BD4  2F05      10974          move.l    D5,-(A7)
00003BD6  4EB8 1412 10975          jsr       _OS_EventTaskWait
00003BDA  584F      10976          addq.w    #4,A7
                    10977   ; OS_EXIT_CRITICAL();
00003BDC  46DF      10978          dc.w      18143
                    10979   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
00003BDE  4EB8 190E 10980          jsr       _OS_Sched
                    10981   ; OS_ENTER_CRITICAL();
00003BE2  40E7      10982          dc.w      16615
00003BE4  007C      10983          dc.w      124
00003BE6  0700      10984          dc.w      1792
                    10985   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003BE8  2052      10986          move.l    (A2),A0
00003BEA  1028 0033 10987          move.b    51(A0),D0
00003BEE  C0BC 0000 10988          and.l     #255,D0
00003BF2  00FF      
00003BF4  0C80 0000 10989          cmp.l     #1,D0
00003BF8  0001      
00003BFA  6700 002A 10990          beq       OSQPend_16
00003BFE  6206      10991          bhi.s     OSQPend_18
00003C00  4A80      10992          tst.l     D0
00003C02  670C      10993          beq.s     OSQPend_14
00003C04  6020      10994          bra.s     OSQPend_16
                    10995   OSQPend_18:
00003C06  0C80 0000 10996          cmp.l     #2,D0
00003C0A  0002      
00003C0C  670E      10997          beq.s     OSQPend_15
00003C0E  6016      10998          bra.s     OSQPend_16
                    10999   OSQPend_14:
                    11000   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    11001   ; pmsg =  OSTCBCur->OSTCBMsg;
00003C10  2052      11002          move.l    (A2),A0
00003C12  2828 0024 11003          move.l    36(A0),D4
                    11004   ; *perr =  OS_ERR_NONE;
00003C16  2043      11005          move.l    D3,A0
00003C18  4210      11006          clr.b     (A0)
                    11007   ; break;
00003C1A  601C      11008          bra.s     OSQPend_13
                    11009   OSQPend_15:
                    11010   ; case OS_STAT_PEND_ABORT:
                    11011   ; pmsg = (void *)0;
00003C1C  4284      11012          clr.l     D4
                    11013   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00003C1E  2043      11014          move.l    D3,A0
00003C20  10BC 000E 11015          move.b    #14,(A0)
                    11016   ; break;
00003C24  6012      11017          bra.s     OSQPend_13
                    11018   OSQPend_16:
                    11019   ; case OS_STAT_PEND_TO:
                    11020   ; default:
                    11021   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003C26  2F05      11022          move.l    D5,-(A7)
00003C28  2F12      11023          move.l    (A2),-(A7)
00003C2A  4EB8 1534 11024          jsr       _OS_EventTaskRemove
00003C2E  504F      11025          addq.w    #8,A7
                    11026   ; pmsg = (void *)0;
00003C30  4284      11027          clr.l     D4
                    11028   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00003C32  2043      11029          move.l    D3,A0
00003C34  10BC 000A 11030          move.b    #10,(A0)
                    11031   ; break;
                    11032   OSQPend_13:
                    11033   ; }
                    11034   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003C38  2052      11035          move.l    (A2),A0
00003C3A  4228 0032 11036          clr.b     50(A0)
                    11037   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003C3E  2052      11038          move.l    (A2),A0
00003C40  4228 0033 11039          clr.b     51(A0)
                    11040   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003C44  2052      11041          move.l    (A2),A0
00003C46  42A8 001C 11042          clr.l     28(A0)
                    11043   ; #if (OS_EVENT_MULTI_EN > 0u)
                    11044   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003C4A  2052      11045          move.l    (A2),A0
00003C4C  42A8 0020 11046          clr.l     32(A0)
                    11047   ; #endif
                    11048   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00003C50  2052      11049          move.l    (A2),A0
00003C52  42A8 0024 11050          clr.l     36(A0)
                    11051   ; OS_EXIT_CRITICAL();
00003C56  46DF      11052          dc.w      18143
                    11053   ; return (pmsg);                                    /* Return received message                       */
00003C58  2004      11054          move.l    D4,D0
                    11055   OSQPend_3:
00003C5A  4CDF 043C 11056          movem.l   (A7)+,D2/D3/D4/D5/A2
00003C5E  4E5E      11057          unlk      A6
00003C60  4E75      11058          rts
                    11059   ; }
                    11060   ; /*$PAGE*/
                    11061   ; /*
                    11062   ; *********************************************************************************************************
                    11063   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    11064   ; *
                    11065   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    11066   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    11067   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    11068   ; *
                    11069   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    11070   ; *
                    11071   ; *              opt           determines the type of ABORT performed:
                    11072   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    11073   ; *                                                     queue
                    11074   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    11075   ; *                                                     queue
                    11076   ; *
                    11077   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11078   ; *                            messages are:
                    11079   ; *
                    11080   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    11081   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    11082   ; *                                                and informed of the aborted wait; check return value
                    11083   ; *                                                for the number of tasks whose wait on the queue
                    11084   ; *                                                was aborted.
                    11085   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    11086   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11087   ; *
                    11088   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    11089   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    11090   ; *********************************************************************************************************
                    11091   ; */
                    11092   ; #if OS_Q_PEND_ABORT_EN > 0u
                    11093   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    11094   ; INT8U      opt,
                    11095   ; INT8U     *perr)
                    11096   ; {
                    11097   _OSQPendAbort:
00003C62  4E56 0000 11098          link      A6,#0
00003C66  48E7 3800 11099          movem.l   D2/D3/D4,-(A7)
00003C6A  242E 0008 11100          move.l    8(A6),D2
00003C6E  282E 0010 11101          move.l    16(A6),D4
                    11102   ; INT8U      nbr_tasks;
                    11103   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11104   ; OS_CPU_SR  cpu_sr = 0u;
                    11105   ; #endif
                    11106   ; #ifdef OS_SAFETY_CRITICAL
                    11107   ; if (perr == (INT8U *)0) {
                    11108   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11109   ; return (0u);
                    11110   ; }
                    11111   ; #endif
                    11112   ; #if OS_ARG_CHK_EN > 0u
                    11113   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11114   ; *perr = OS_ERR_PEVENT_NULL;
                    11115   ; return (0u);
                    11116   ; }
                    11117   ; #endif
                    11118   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00003C72  2042      11119          move.l    D2,A0
00003C74  1010      11120          move.b    (A0),D0
00003C76  0C00 0002 11121          cmp.b     #2,D0
00003C7A  670C      11122          beq.s     OSQPendAbort_1
                    11123   ; *perr = OS_ERR_EVENT_TYPE;
00003C7C  2044      11124          move.l    D4,A0
00003C7E  10BC 0001 11125          move.b    #1,(A0)
                    11126   ; return (0u);
00003C82  4200      11127          clr.b     D0
00003C84  6000 008C 11128          bra       OSQPendAbort_3
                    11129   OSQPendAbort_1:
                    11130   ; }
                    11131   ; OS_ENTER_CRITICAL();
00003C88  40E7      11132          dc.w      16615
00003C8A  007C      11133          dc.w      124
00003C8C  0700      11134          dc.w      1792
                    11135   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00003C8E  2042      11136          move.l    D2,A0
00003C90  1028 0008 11137          move.b    8(A0),D0
00003C94  6700 0074 11138          beq       OSQPendAbort_4
                    11139   ; nbr_tasks = 0u;
00003C98  4203      11140          clr.b     D3
                    11141   ; switch (opt) {
00003C9A  102E 000F 11142          move.b    15(A6),D0
00003C9E  C0BC 0000 11143          and.l     #255,D0
00003CA2  00FF      
00003CA4  0C80 0000 11144          cmp.l     #1,D0
00003CA8  0001      
00003CAA  670A      11145          beq.s     OSQPendAbort_8
00003CAC  6200 0030 11146          bhi       OSQPendAbort_9
00003CB0  4A80      11147          tst.l     D0
00003CB2  672A      11148          beq.s     OSQPendAbort_9
00003CB4  6028      11149          bra.s     OSQPendAbort_9
                    11150   OSQPendAbort_8:
                    11151   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    11152   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    11153   OSQPendAbort_11:
00003CB6  2042      11154          move.l    D2,A0
00003CB8  1028 0008 11155          move.b    8(A0),D0
00003CBC  671E      11156          beq.s     OSQPendAbort_13
                    11157   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003CBE  4878 0002 11158          pea       2
00003CC2  4878 0004 11159          pea       4
00003CC6  42A7      11160          clr.l     -(A7)
00003CC8  2F02      11161          move.l    D2,-(A7)
00003CCA  4EB8 132E 11162          jsr       _OS_EventTaskRdy
00003CCE  DEFC 0010 11163          add.w     #16,A7
00003CD2  C0BC 0000 11164          and.l     #255,D0
00003CD6  00FF      
                    11165   ; nbr_tasks++;
00003CD8  5203      11166          addq.b    #1,D3
00003CDA  60DA      11167          bra       OSQPendAbort_11
                    11168   OSQPendAbort_13:
                    11169   ; }
                    11170   ; break;
00003CDC  601C      11171          bra.s     OSQPendAbort_7
                    11172   OSQPendAbort_9:
                    11173   ; case OS_PEND_OPT_NONE:
                    11174   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    11175   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00003CDE  4878 0002 11176          pea       2
00003CE2  4878 0004 11177          pea       4
00003CE6  42A7      11178          clr.l     -(A7)
00003CE8  2F02      11179          move.l    D2,-(A7)
00003CEA  4EB8 132E 11180          jsr       _OS_EventTaskRdy
00003CEE  DEFC 0010 11181          add.w     #16,A7
00003CF2  C0BC 0000 11182          and.l     #255,D0
00003CF6  00FF      
                    11183   ; nbr_tasks++;
00003CF8  5203      11184          addq.b    #1,D3
                    11185   ; break;
                    11186   OSQPendAbort_7:
                    11187   ; }
                    11188   ; OS_EXIT_CRITICAL();
00003CFA  46DF      11189          dc.w      18143
                    11190   ; OS_Sched();                                        /* Find HPT ready to run                    */
00003CFC  4EB8 190E 11191          jsr       _OS_Sched
                    11192   ; *perr = OS_ERR_PEND_ABORT;
00003D00  2044      11193          move.l    D4,A0
00003D02  10BC 000E 11194          move.b    #14,(A0)
                    11195   ; return (nbr_tasks);
00003D06  1003      11196          move.b    D3,D0
00003D08  6008      11197          bra.s     OSQPendAbort_3
                    11198   OSQPendAbort_4:
                    11199   ; }
                    11200   ; OS_EXIT_CRITICAL();
00003D0A  46DF      11201          dc.w      18143
                    11202   ; *perr = OS_ERR_NONE;
00003D0C  2044      11203          move.l    D4,A0
00003D0E  4210      11204          clr.b     (A0)
                    11205   ; return (0u);                                           /* No tasks waiting on queue                */
00003D10  4200      11206          clr.b     D0
                    11207   OSQPendAbort_3:
00003D12  4CDF 001C 11208          movem.l   (A7)+,D2/D3/D4
00003D16  4E5E      11209          unlk      A6
00003D18  4E75      11210          rts
                    11211   ; }
                    11212   ; #endif
                    11213   ; /*$PAGE*/
                    11214   ; /*
                    11215   ; *********************************************************************************************************
                    11216   ; *                                       POST MESSAGE TO A QUEUE
                    11217   ; *
                    11218   ; * Description: This function sends a message to a queue
                    11219   ; *
                    11220   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11221   ; *
                    11222   ; *              pmsg          is a pointer to the message to send.
                    11223   ; *
                    11224   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11225   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11226   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11227   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11228   ; *
                    11229   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11230   ; *********************************************************************************************************
                    11231   ; */
                    11232   ; #if OS_Q_POST_EN > 0u
                    11233   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    11234   ; void      *pmsg)
                    11235   ; {
                    11236   _OSQPost:
00003D1A  4E56 0000 11237          link      A6,#0
00003D1E  48E7 3000 11238          movem.l   D2/D3,-(A7)
00003D22  262E 0008 11239          move.l    8(A6),D3
                    11240   ; OS_Q      *pq;
                    11241   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11242   ; OS_CPU_SR  cpu_sr = 0u;
                    11243   ; #endif
                    11244   ; #if OS_ARG_CHK_EN > 0u
                    11245   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11246   ; return (OS_ERR_PEVENT_NULL);
                    11247   ; }
                    11248   ; #endif
                    11249   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003D26  2043      11250          move.l    D3,A0
00003D28  1010      11251          move.b    (A0),D0
00003D2A  0C00 0002 11252          cmp.b     #2,D0
00003D2E  6706      11253          beq.s     OSQPost_1
                    11254   ; return (OS_ERR_EVENT_TYPE);
00003D30  7001      11255          moveq     #1,D0
00003D32  6000 008C 11256          bra       OSQPost_3
                    11257   OSQPost_1:
                    11258   ; }
                    11259   ; OS_ENTER_CRITICAL();
00003D36  40E7      11260          dc.w      16615
00003D38  007C      11261          dc.w      124
00003D3A  0700      11262          dc.w      1792
                    11263   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003D3C  2043      11264          move.l    D3,A0
00003D3E  1028 0008 11265          move.b    8(A0),D0
00003D42  6726      11266          beq.s     OSQPost_4
                    11267   ; /* Ready highest priority task waiting on event */
                    11268   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003D44  42A7      11269          clr.l     -(A7)
00003D46  4878 0004 11270          pea       4
00003D4A  2F2E 000C 11271          move.l    12(A6),-(A7)
00003D4E  2F03      11272          move.l    D3,-(A7)
00003D50  4EB8 132E 11273          jsr       _OS_EventTaskRdy
00003D54  DEFC 0010 11274          add.w     #16,A7
00003D58  C0BC 0000 11275          and.l     #255,D0
00003D5C  00FF      
                    11276   ; OS_EXIT_CRITICAL();
00003D5E  46DF      11277          dc.w      18143
                    11278   ; OS_Sched();                                    /* Find highest priority task ready to run      */
00003D60  4EB8 190E 11279          jsr       _OS_Sched
                    11280   ; return (OS_ERR_NONE);
00003D64  4200      11281          clr.b     D0
00003D66  6000 0058 11282          bra       OSQPost_3
                    11283   OSQPost_4:
                    11284   ; }
                    11285   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003D6A  2043      11286          move.l    D3,A0
00003D6C  2428 0002 11287          move.l    2(A0),D2
                    11288   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
00003D70  2042      11289          move.l    D2,A0
00003D72  2242      11290          move.l    D2,A1
00003D74  3028 0016 11291          move.w    22(A0),D0
00003D78  B069 0014 11292          cmp.w     20(A1),D0
00003D7C  6508      11293          blo.s     OSQPost_6
                    11294   ; OS_EXIT_CRITICAL();
00003D7E  46DF      11295          dc.w      18143
                    11296   ; return (OS_ERR_Q_FULL);
00003D80  701E      11297          moveq     #30,D0
00003D82  6000 003C 11298          bra       OSQPost_3
                    11299   OSQPost_6:
                    11300   ; }
                    11301   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003D86  2002      11302          move.l    D2,D0
00003D88  0680 0000 11303          add.l     #12,D0
00003D8C  000C      
00003D8E  2040      11304          move.l    D0,A0
00003D90  2250      11305          move.l    (A0),A1
00003D92  5890      11306          addq.l    #4,(A0)
00003D94  22AE 000C 11307          move.l    12(A6),(A1)
                    11308   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003D98  2002      11309          move.l    D2,D0
00003D9A  0680 0000 11310          add.l     #22,D0
00003D9E  0016      
00003DA0  2040      11311          move.l    D0,A0
00003DA2  5250      11312          addq.w    #1,(A0)
                    11313   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
00003DA4  2042      11314          move.l    D2,A0
00003DA6  2242      11315          move.l    D2,A1
00003DA8  2028 000C 11316          move.l    12(A0),D0
00003DAC  B0A9 0008 11317          cmp.l     8(A1),D0
00003DB0  660A      11318          bne.s     OSQPost_8
                    11319   ; pq->OSQIn = pq->OSQStart;
00003DB2  2042      11320          move.l    D2,A0
00003DB4  2242      11321          move.l    D2,A1
00003DB6  2368 0004 11322          move.l    4(A0),12(A1)
00003DBA  000C      
                    11323   OSQPost_8:
                    11324   ; }
                    11325   ; OS_EXIT_CRITICAL();
00003DBC  46DF      11326          dc.w      18143
                    11327   ; return (OS_ERR_NONE);
00003DBE  4200      11328          clr.b     D0
                    11329   OSQPost_3:
00003DC0  4CDF 000C 11330          movem.l   (A7)+,D2/D3
00003DC4  4E5E      11331          unlk      A6
00003DC6  4E75      11332          rts
                    11333   ; }
                    11334   ; #endif
                    11335   ; /*$PAGE*/
                    11336   ; /*
                    11337   ; *********************************************************************************************************
                    11338   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    11339   ; *
                    11340   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    11341   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    11342   ; *              'priority' messages.
                    11343   ; *
                    11344   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11345   ; *
                    11346   ; *              pmsg          is a pointer to the message to send.
                    11347   ; *
                    11348   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11349   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11350   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11351   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11352   ; *
                    11353   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    11354   ; *********************************************************************************************************
                    11355   ; */
                    11356   ; #if OS_Q_POST_FRONT_EN > 0u
                    11357   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    11358   ; void      *pmsg)
                    11359   ; {
                    11360   _OSQPostFront:
00003DC8  4E56 0000 11361          link      A6,#0
00003DCC  48E7 3000 11362          movem.l   D2/D3,-(A7)
00003DD0  262E 0008 11363          move.l    8(A6),D3
                    11364   ; OS_Q      *pq;
                    11365   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11366   ; OS_CPU_SR  cpu_sr = 0u;
                    11367   ; #endif
                    11368   ; #if OS_ARG_CHK_EN > 0u
                    11369   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11370   ; return (OS_ERR_PEVENT_NULL);
                    11371   ; }
                    11372   ; #endif
                    11373   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003DD4  2043      11374          move.l    D3,A0
00003DD6  1010      11375          move.b    (A0),D0
00003DD8  0C00 0002 11376          cmp.b     #2,D0
00003DDC  6706      11377          beq.s     OSQPostFront_1
                    11378   ; return (OS_ERR_EVENT_TYPE);
00003DDE  7001      11379          moveq     #1,D0
00003DE0  6000 0090 11380          bra       OSQPostFront_3
                    11381   OSQPostFront_1:
                    11382   ; }
                    11383   ; OS_ENTER_CRITICAL();
00003DE4  40E7      11384          dc.w      16615
00003DE6  007C      11385          dc.w      124
00003DE8  0700      11386          dc.w      1792
                    11387   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00003DEA  2043      11388          move.l    D3,A0
00003DEC  1028 0008 11389          move.b    8(A0),D0
00003DF0  6726      11390          beq.s     OSQPostFront_4
                    11391   ; /* Ready highest priority task waiting on event  */
                    11392   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003DF2  42A7      11393          clr.l     -(A7)
00003DF4  4878 0004 11394          pea       4
00003DF8  2F2E 000C 11395          move.l    12(A6),-(A7)
00003DFC  2F03      11396          move.l    D3,-(A7)
00003DFE  4EB8 132E 11397          jsr       _OS_EventTaskRdy
00003E02  DEFC 0010 11398          add.w     #16,A7
00003E06  C0BC 0000 11399          and.l     #255,D0
00003E0A  00FF      
                    11400   ; OS_EXIT_CRITICAL();
00003E0C  46DF      11401          dc.w      18143
                    11402   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00003E0E  4EB8 190E 11403          jsr       _OS_Sched
                    11404   ; return (OS_ERR_NONE);
00003E12  4200      11405          clr.b     D0
00003E14  6000 005C 11406          bra       OSQPostFront_3
                    11407   OSQPostFront_4:
                    11408   ; }
                    11409   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003E18  2043      11410          move.l    D3,A0
00003E1A  2428 0002 11411          move.l    2(A0),D2
                    11412   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003E1E  2042      11413          move.l    D2,A0
00003E20  2242      11414          move.l    D2,A1
00003E22  3028 0016 11415          move.w    22(A0),D0
00003E26  B069 0014 11416          cmp.w     20(A1),D0
00003E2A  6508      11417          blo.s     OSQPostFront_6
                    11418   ; OS_EXIT_CRITICAL();
00003E2C  46DF      11419          dc.w      18143
                    11420   ; return (OS_ERR_Q_FULL);
00003E2E  701E      11421          moveq     #30,D0
00003E30  6000 0040 11422          bra       OSQPostFront_3
                    11423   OSQPostFront_6:
                    11424   ; }
                    11425   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
00003E34  2042      11426          move.l    D2,A0
00003E36  2242      11427          move.l    D2,A1
00003E38  2028 0010 11428          move.l    16(A0),D0
00003E3C  B0A9 0004 11429          cmp.l     4(A1),D0
00003E40  660A      11430          bne.s     OSQPostFront_8
                    11431   ; pq->OSQOut = pq->OSQEnd;
00003E42  2042      11432          move.l    D2,A0
00003E44  2242      11433          move.l    D2,A1
00003E46  2368 0008 11434          move.l    8(A0),16(A1)
00003E4A  0010      
                    11435   OSQPostFront_8:
                    11436   ; }
                    11437   ; pq->OSQOut--;
00003E4C  2002      11438          move.l    D2,D0
00003E4E  0680 0000 11439          add.l     #16,D0
00003E52  0010      
00003E54  2040      11440          move.l    D0,A0
00003E56  5990      11441          subq.l    #4,(A0)
                    11442   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003E58  2042      11443          move.l    D2,A0
00003E5A  2068 0010 11444          move.l    16(A0),A0
00003E5E  20AE 000C 11445          move.l    12(A6),(A0)
                    11446   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003E62  2002      11447          move.l    D2,D0
00003E64  0680 0000 11448          add.l     #22,D0
00003E68  0016      
00003E6A  2040      11449          move.l    D0,A0
00003E6C  5250      11450          addq.w    #1,(A0)
                    11451   ; OS_EXIT_CRITICAL();
00003E6E  46DF      11452          dc.w      18143
                    11453   ; return (OS_ERR_NONE);
00003E70  4200      11454          clr.b     D0
                    11455   OSQPostFront_3:
00003E72  4CDF 000C 11456          movem.l   (A7)+,D2/D3
00003E76  4E5E      11457          unlk      A6
00003E78  4E75      11458          rts
                    11459   ; }
                    11460   ; #endif
                    11461   ; /*$PAGE*/
                    11462   ; /*
                    11463   ; *********************************************************************************************************
                    11464   ; *                                       POST MESSAGE TO A QUEUE
                    11465   ; *
                    11466   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11467   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11468   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11469   ; *
                    11470   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11471   ; *
                    11472   ; *              pmsg          is a pointer to the message to send.
                    11473   ; *
                    11474   ; *              opt           determines the type of POST performed:
                    11475   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11476   ; *                                                     (Identical to OSQPost())
                    11477   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11478   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11479   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11480   ; *
                    11481   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11482   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11483   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11484   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11485   ; *
                    11486   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11487   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11488   ; *********************************************************************************************************
                    11489   ; */
                    11490   ; #if OS_Q_POST_OPT_EN > 0u
                    11491   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11492   ; void      *pmsg,
                    11493   ; INT8U      opt)
                    11494   ; {
                    11495   _OSQPostOpt:
00003E7A  4E56 0000 11496          link      A6,#0
00003E7E  48E7 3C00 11497          movem.l   D2/D3/D4/D5,-(A7)
00003E82  262E 0008 11498          move.l    8(A6),D3
00003E86  282E 000C 11499          move.l    12(A6),D4
00003E8A  1A2E 0013 11500          move.b    19(A6),D5
00003E8E  CABC 0000 11501          and.l     #255,D5
00003E92  00FF      
                    11502   ; OS_Q      *pq;
                    11503   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11504   ; OS_CPU_SR  cpu_sr = 0u;
                    11505   ; #endif
                    11506   ; #if OS_ARG_CHK_EN > 0u
                    11507   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11508   ; return (OS_ERR_PEVENT_NULL);
                    11509   ; }
                    11510   ; #endif
                    11511   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
00003E94  2043      11512          move.l    D3,A0
00003E96  1010      11513          move.b    (A0),D0
00003E98  0C00 0002 11514          cmp.b     #2,D0
00003E9C  6706      11515          beq.s     OSQPostOpt_1
                    11516   ; return (OS_ERR_EVENT_TYPE);
00003E9E  7001      11517          moveq     #1,D0
00003EA0  6000 00F6 11518          bra       OSQPostOpt_3
                    11519   OSQPostOpt_1:
                    11520   ; }
                    11521   ; OS_ENTER_CRITICAL();
00003EA4  40E7      11522          dc.w      16615
00003EA6  007C      11523          dc.w      124
00003EA8  0700      11524          dc.w      1792
                    11525   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003EAA  2043      11526          move.l    D3,A0
00003EAC  1028 0008 11527          move.b    8(A0),D0
00003EB0  6700 005A 11528          beq       OSQPostOpt_4
                    11529   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
00003EB4  1005      11530          move.b    D5,D0
00003EB6  C03C 0001 11531          and.b     #1,D0
00003EBA  6724      11532          beq.s     OSQPostOpt_6
                    11533   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11534   OSQPostOpt_8:
00003EBC  2043      11535          move.l    D3,A0
00003EBE  1028 0008 11536          move.b    8(A0),D0
00003EC2  671A      11537          beq.s     OSQPostOpt_10
                    11538   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003EC4  42A7      11539          clr.l     -(A7)
00003EC6  4878 0004 11540          pea       4
00003ECA  2F04      11541          move.l    D4,-(A7)
00003ECC  2F03      11542          move.l    D3,-(A7)
00003ECE  4EB8 132E 11543          jsr       _OS_EventTaskRdy
00003ED2  DEFC 0010 11544          add.w     #16,A7
00003ED6  C0BC 0000 11545          and.l     #255,D0
00003EDA  00FF      
00003EDC  60DE      11546          bra       OSQPostOpt_8
                    11547   OSQPostOpt_10:
00003EDE  6018      11548          bra.s     OSQPostOpt_7
                    11549   OSQPostOpt_6:
                    11550   ; }
                    11551   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11552   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
00003EE0  42A7      11553          clr.l     -(A7)
00003EE2  4878 0004 11554          pea       4
00003EE6  2F04      11555          move.l    D4,-(A7)
00003EE8  2F03      11556          move.l    D3,-(A7)
00003EEA  4EB8 132E 11557          jsr       _OS_EventTaskRdy
00003EEE  DEFC 0010 11558          add.w     #16,A7
00003EF2  C0BC 0000 11559          and.l     #255,D0
00003EF6  00FF      
                    11560   OSQPostOpt_7:
                    11561   ; }
                    11562   ; OS_EXIT_CRITICAL();
00003EF8  46DF      11563          dc.w      18143
                    11564   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00003EFA  1005      11565          move.b    D5,D0
00003EFC  C03C 0004 11566          and.b     #4,D0
00003F00  6604      11567          bne.s     OSQPostOpt_11
                    11568   ; OS_Sched();                               /* Find highest priority task ready to run       */
00003F02  4EB8 190E 11569          jsr       _OS_Sched
                    11570   OSQPostOpt_11:
                    11571   ; }
                    11572   ; return (OS_ERR_NONE);
00003F06  4200      11573          clr.b     D0
00003F08  6000 008E 11574          bra       OSQPostOpt_3
                    11575   OSQPostOpt_4:
                    11576   ; }
                    11577   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003F0C  2043      11578          move.l    D3,A0
00003F0E  2428 0002 11579          move.l    2(A0),D2
                    11580   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003F12  2042      11581          move.l    D2,A0
00003F14  2242      11582          move.l    D2,A1
00003F16  3028 0016 11583          move.w    22(A0),D0
00003F1A  B069 0014 11584          cmp.w     20(A1),D0
00003F1E  6508      11585          blo.s     OSQPostOpt_13
                    11586   ; OS_EXIT_CRITICAL();
00003F20  46DF      11587          dc.w      18143
                    11588   ; return (OS_ERR_Q_FULL);
00003F22  701E      11589          moveq     #30,D0
00003F24  6000 0072 11590          bra       OSQPostOpt_3
                    11591   OSQPostOpt_13:
                    11592   ; }
                    11593   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00003F28  1005      11594          move.b    D5,D0
00003F2A  C03C 0002 11595          and.b     #2,D0
00003F2E  6700 0030 11596          beq       OSQPostOpt_15
                    11597   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00003F32  2042      11598          move.l    D2,A0
00003F34  2242      11599          move.l    D2,A1
00003F36  2028 0010 11600          move.l    16(A0),D0
00003F3A  B0A9 0004 11601          cmp.l     4(A1),D0
00003F3E  660A      11602          bne.s     OSQPostOpt_17
                    11603   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00003F40  2042      11604          move.l    D2,A0
00003F42  2242      11605          move.l    D2,A1
00003F44  2368 0008 11606          move.l    8(A0),16(A1)
00003F48  0010      
                    11607   OSQPostOpt_17:
                    11608   ; }
                    11609   ; pq->OSQOut--;
00003F4A  2002      11610          move.l    D2,D0
00003F4C  0680 0000 11611          add.l     #16,D0
00003F50  0010      
00003F52  2040      11612          move.l    D0,A0
00003F54  5990      11613          subq.l    #4,(A0)
                    11614   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
00003F56  2042      11615          move.l    D2,A0
00003F58  2068 0010 11616          move.l    16(A0),A0
00003F5C  2084      11617          move.l    D4,(A0)
00003F5E  6028      11618          bra.s     OSQPostOpt_19
                    11619   OSQPostOpt_15:
                    11620   ; } else {                                          /* No,  Post as FIFO                             */
                    11621   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00003F60  2002      11622          move.l    D2,D0
00003F62  0680 0000 11623          add.l     #12,D0
00003F66  000C      
00003F68  2040      11624          move.l    D0,A0
00003F6A  2250      11625          move.l    (A0),A1
00003F6C  5890      11626          addq.l    #4,(A0)
00003F6E  2284      11627          move.l    D4,(A1)
                    11628   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00003F70  2042      11629          move.l    D2,A0
00003F72  2242      11630          move.l    D2,A1
00003F74  2028 000C 11631          move.l    12(A0),D0
00003F78  B0A9 0008 11632          cmp.l     8(A1),D0
00003F7C  660A      11633          bne.s     OSQPostOpt_19
                    11634   ; pq->OSQIn = pq->OSQStart;
00003F7E  2042      11635          move.l    D2,A0
00003F80  2242      11636          move.l    D2,A1
00003F82  2368 0004 11637          move.l    4(A0),12(A1)
00003F86  000C      
                    11638   OSQPostOpt_19:
                    11639   ; }
                    11640   ; }
                    11641   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003F88  2002      11642          move.l    D2,D0
00003F8A  0680 0000 11643          add.l     #22,D0
00003F8E  0016      
00003F90  2040      11644          move.l    D0,A0
00003F92  5250      11645          addq.w    #1,(A0)
                    11646   ; OS_EXIT_CRITICAL();
00003F94  46DF      11647          dc.w      18143
                    11648   ; return (OS_ERR_NONE);
00003F96  4200      11649          clr.b     D0
                    11650   OSQPostOpt_3:
00003F98  4CDF 003C 11651          movem.l   (A7)+,D2/D3/D4/D5
00003F9C  4E5E      11652          unlk      A6
00003F9E  4E75      11653          rts
                    11654   ; }
                    11655   ; #endif
                    11656   ; /*$PAGE*/
                    11657   ; /*
                    11658   ; *********************************************************************************************************
                    11659   ; *                                        QUERY A MESSAGE QUEUE
                    11660   ; *
                    11661   ; * Description: This function obtains information about a message queue.
                    11662   ; *
                    11663   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11664   ; *
                    11665   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11666   ; *                            queue.
                    11667   ; *
                    11668   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11669   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11670   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11671   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11672   ; *********************************************************************************************************
                    11673   ; */
                    11674   ; #if OS_Q_QUERY_EN > 0u
                    11675   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11676   ; OS_Q_DATA *p_q_data)
                    11677   ; {
                    11678   _OSQQuery:
00003FA0  4E56 FFF8 11679          link      A6,#-8
00003FA4  48E7 3C00 11680          movem.l   D2/D3/D4/D5,-(A7)
00003FA8  242E 000C 11681          move.l    12(A6),D2
00003FAC  282E 0008 11682          move.l    8(A6),D4
                    11683   ; OS_Q       *pq;
                    11684   ; INT8U       i;
                    11685   ; OS_PRIO    *psrc;
                    11686   ; OS_PRIO    *pdest;
                    11687   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11688   ; OS_CPU_SR   cpu_sr = 0u;
                    11689   ; #endif
                    11690   ; #if OS_ARG_CHK_EN > 0u
                    11691   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11692   ; return (OS_ERR_PEVENT_NULL);
                    11693   ; }
                    11694   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11695   ; return (OS_ERR_PDATA_NULL);
                    11696   ; }
                    11697   ; #endif
                    11698   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003FB0  2044      11699          move.l    D4,A0
00003FB2  1010      11700          move.b    (A0),D0
00003FB4  0C00 0002 11701          cmp.b     #2,D0
00003FB8  6706      11702          beq.s     OSQQuery_1
                    11703   ; return (OS_ERR_EVENT_TYPE);
00003FBA  7001      11704          moveq     #1,D0
00003FBC  6000 007A 11705          bra       OSQQuery_3
                    11706   OSQQuery_1:
                    11707   ; }
                    11708   ; OS_ENTER_CRITICAL();
00003FC0  40E7      11709          dc.w      16615
00003FC2  007C      11710          dc.w      124
00003FC4  0700      11711          dc.w      1792
                    11712   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00003FC6  2044      11713          move.l    D4,A0
00003FC8  2242      11714          move.l    D2,A1
00003FCA  1368 0008 11715          move.b    8(A0),16(A1)
00003FCE  0010      
                    11716   ; psrc                 = &pevent->OSEventTbl[0];
00003FD0  700A      11717          moveq     #10,D0
00003FD2  D084      11718          add.l     D4,D0
00003FD4  2D40 FFF8 11719          move.l    D0,-8(A6)
                    11720   ; pdest                = &p_q_data->OSEventTbl[0];
00003FD8  7008      11721          moveq     #8,D0
00003FDA  D082      11722          add.l     D2,D0
00003FDC  2D40 FFFC 11723          move.l    D0,-4(A6)
                    11724   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003FE0  4205      11725          clr.b     D5
                    11726   OSQQuery_4:
00003FE2  0C05 0008 11727          cmp.b     #8,D5
00003FE6  6416      11728          bhs.s     OSQQuery_6
                    11729   ; *pdest++ = *psrc++;
00003FE8  206E FFF8 11730          move.l    -8(A6),A0
00003FEC  52AE FFF8 11731          addq.l    #1,-8(A6)
00003FF0  226E FFFC 11732          move.l    -4(A6),A1
00003FF4  52AE FFFC 11733          addq.l    #1,-4(A6)
00003FF8  1290      11734          move.b    (A0),(A1)
00003FFA  5205      11735          addq.b    #1,D5
00003FFC  60E4      11736          bra       OSQQuery_4
                    11737   OSQQuery_6:
                    11738   ; }
                    11739   ; pq = (OS_Q *)pevent->OSEventPtr;
00003FFE  2044      11740          move.l    D4,A0
00004000  2628 0002 11741          move.l    2(A0),D3
                    11742   ; if (pq->OSQEntries > 0u) {
00004004  2043      11743          move.l    D3,A0
00004006  3028 0016 11744          move.w    22(A0),D0
0000400A  0C40 0000 11745          cmp.w     #0,D0
0000400E  630C      11746          bls.s     OSQQuery_7
                    11747   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00004010  2043      11748          move.l    D3,A0
00004012  2068 0010 11749          move.l    16(A0),A0
00004016  2242      11750          move.l    D2,A1
00004018  2290      11751          move.l    (A0),(A1)
0000401A  6004      11752          bra.s     OSQQuery_8
                    11753   OSQQuery_7:
                    11754   ; } else {
                    11755   ; p_q_data->OSMsg = (void *)0;
0000401C  2042      11756          move.l    D2,A0
0000401E  4290      11757          clr.l     (A0)
                    11758   OSQQuery_8:
                    11759   ; }
                    11760   ; p_q_data->OSNMsgs = pq->OSQEntries;
00004020  2043      11761          move.l    D3,A0
00004022  2242      11762          move.l    D2,A1
00004024  3368 0016 11763          move.w    22(A0),4(A1)
00004028  0004      
                    11764   ; p_q_data->OSQSize = pq->OSQSize;
0000402A  2043      11765          move.l    D3,A0
0000402C  2242      11766          move.l    D2,A1
0000402E  3368 0014 11767          move.w    20(A0),6(A1)
00004032  0006      
                    11768   ; OS_EXIT_CRITICAL();
00004034  46DF      11769          dc.w      18143
                    11770   ; return (OS_ERR_NONE);
00004036  4200      11771          clr.b     D0
                    11772   OSQQuery_3:
00004038  4CDF 003C 11773          movem.l   (A7)+,D2/D3/D4/D5
0000403C  4E5E      11774          unlk      A6
0000403E  4E75      11775          rts
                    11776   ; }
                    11777   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11778   ; /*$PAGE*/
                    11779   ; /*
                    11780   ; *********************************************************************************************************
                    11781   ; *                                     QUEUE MODULE INITIALIZATION
                    11782   ; *
                    11783   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11784   ; *               application MUST NOT call this function.
                    11785   ; *
                    11786   ; * Arguments   :  none
                    11787   ; *
                    11788   ; * Returns     : none
                    11789   ; *
                    11790   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11791   ; *********************************************************************************************************
                    11792   ; */
                    11793   ; void  OS_QInit (void)
                    11794   ; {
                    11795   _OS_QInit:
00004040  4E56 FFF8 11796          link      A6,#-8
00004044  48E7 3020 11797          movem.l   D2/D3/A2,-(A7)
00004048  45F9 0800 11798          lea       _OSQTbl.L,A2
0000404C  172E      
                    11799   ; #if OS_MAX_QS == 1u
                    11800   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11801   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11802   ; #endif
                    11803   ; #if OS_MAX_QS >= 2u
                    11804   ; INT16U   ix;
                    11805   ; INT16U   ix_next;
                    11806   ; OS_Q    *pq1;
                    11807   ; OS_Q    *pq2;
                    11808   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
0000404E  4878 0060 11809          pea       96
00004052  2F0A      11810          move.l    A2,-(A7)
00004054  4EB8 18C2 11811          jsr       _OS_MemClr
00004058  504F      11812          addq.w    #8,A7
                    11813   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
0000405A  4242      11814          clr.w     D2
                    11815   OS_QInit_1:
0000405C  0C42 0003 11816          cmp.w     #3,D2
00004060  6400 003C 11817          bhs       OS_QInit_3
                    11818   ; ix_next = ix + 1u;
00004064  3002      11819          move.w    D2,D0
00004066  5240      11820          addq.w    #1,D0
00004068  3D40 FFFA 11821          move.w    D0,-6(A6)
                    11822   ; pq1 = &OSQTbl[ix];
0000406C  200A      11823          move.l    A2,D0
0000406E  C4BC 0000 11824          and.l     #65535,D2
00004072  FFFF      
00004074  2202      11825          move.l    D2,D1
00004076  C3FC 0018 11826          muls      #24,D1
0000407A  D081      11827          add.l     D1,D0
0000407C  2600      11828          move.l    D0,D3
                    11829   ; pq2 = &OSQTbl[ix_next];
0000407E  200A      11830          move.l    A2,D0
00004080  322E FFFA 11831          move.w    -6(A6),D1
00004084  C2BC 0000 11832          and.l     #65535,D1
00004088  FFFF      
0000408A  C3FC 0018 11833          muls      #24,D1
0000408E  D081      11834          add.l     D1,D0
00004090  2D40 FFFC 11835          move.l    D0,-4(A6)
                    11836   ; pq1->OSQPtr = pq2;
00004094  2043      11837          move.l    D3,A0
00004096  20AE FFFC 11838          move.l    -4(A6),(A0)
0000409A  5242      11839          addq.w    #1,D2
0000409C  60BE      11840          bra       OS_QInit_1
                    11841   OS_QInit_3:
                    11842   ; }
                    11843   ; pq1         = &OSQTbl[ix];
0000409E  200A      11844          move.l    A2,D0
000040A0  C4BC 0000 11845          and.l     #65535,D2
000040A4  FFFF      
000040A6  2202      11846          move.l    D2,D1
000040A8  C3FC 0018 11847          muls      #24,D1
000040AC  D081      11848          add.l     D1,D0
000040AE  2600      11849          move.l    D0,D3
                    11850   ; pq1->OSQPtr = (OS_Q *)0;
000040B0  2043      11851          move.l    D3,A0
000040B2  4290      11852          clr.l     (A0)
                    11853   ; OSQFreeList = &OSQTbl[0];
000040B4  23CA 0800 11854          move.l    A2,_OSQFreeList.L
000040B8  172A      
000040BA  4CDF 040C 11855          movem.l   (A7)+,D2/D3/A2
000040BE  4E5E      11856          unlk      A6
000040C0  4E75      11857          rts
                    11858   ; /*
                    11859   ; *********************************************************************************************************
                    11860   ; *                                                uC/OS-II
                    11861   ; *                                          The Real-Time Kernel
                    11862   ; *                                          SEMAPHORE MANAGEMENT
                    11863   ; *
                    11864   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11865   ; *                                           All Rights Reserved
                    11866   ; *
                    11867   ; * File    : OS_SEM.C
                    11868   ; * By      : Jean J. Labrosse
                    11869   ; * Version : V2.92.07
                    11870   ; *
                    11871   ; * LICENSING TERMS:
                    11872   ; * ---------------
                    11873   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11874   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11875   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11876   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11877   ; * licensing fee.
                    11878   ; *********************************************************************************************************
                    11879   ; */
                    11880   ; #define  MICRIUM_SOURCE
                    11881   ; #ifndef  OS_MASTER_FILE
                    11882   ; #include <ucos_ii.h>
                    11883   ; #endif
                    11884   ; #if OS_SEM_EN > 0u
                    11885   ; /*$PAGE*/
                    11886   ; /*
                    11887   ; *********************************************************************************************************
                    11888   ; *                                          ACCEPT SEMAPHORE
                    11889   ; *
                    11890   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11891   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11892   ; *              resource is not available or the event did not occur.
                    11893   ; *
                    11894   ; * Arguments  : pevent     is a pointer to the event control block
                    11895   ; *
                    11896   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11897   ; *                         decremented to obtain the resource.
                    11898   ; *              == 0       if the resource is not available or the event did not occur or,
                    11899   ; *                         if 'pevent' is a NULL pointer or,
                    11900   ; *                         if you didn't pass a pointer to a semaphore
                    11901   ; *********************************************************************************************************
                    11902   ; */
                    11903   ; #if OS_SEM_ACCEPT_EN > 0u
                    11904   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11905   ; {
                    11906   _OSSemAccept:
000040C2  4E56 0000 11907          link      A6,#0
000040C6  48E7 3000 11908          movem.l   D2/D3,-(A7)
000040CA  262E 0008 11909          move.l    8(A6),D3
                    11910   ; INT16U     cnt;
                    11911   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11912   ; OS_CPU_SR  cpu_sr = 0u;
                    11913   ; #endif
                    11914   ; #if OS_ARG_CHK_EN > 0u
                    11915   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11916   ; return (0u);
                    11917   ; }
                    11918   ; #endif
                    11919   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000040CE  2043      11920          move.l    D3,A0
000040D0  1010      11921          move.b    (A0),D0
000040D2  0C00 0003 11922          cmp.b     #3,D0
000040D6  6704      11923          beq.s     OSSemAccept_1
                    11924   ; return (0u);
000040D8  4240      11925          clr.w     D0
000040DA  601E      11926          bra.s     OSSemAccept_3
                    11927   OSSemAccept_1:
                    11928   ; }
                    11929   ; OS_ENTER_CRITICAL();
000040DC  40E7      11930          dc.w      16615
000040DE  007C      11931          dc.w      124
000040E0  0700      11932          dc.w      1792
                    11933   ; cnt = pevent->OSEventCnt;
000040E2  2043      11934          move.l    D3,A0
000040E4  3428 0006 11935          move.w    6(A0),D2
                    11936   ; if (cnt > 0u) {                                   /* See if resource is available                  */
000040E8  0C42 0000 11937          cmp.w     #0,D2
000040EC  6308      11938          bls.s     OSSemAccept_4
                    11939   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
000040EE  2003      11940          move.l    D3,D0
000040F0  5C80      11941          addq.l    #6,D0
000040F2  2040      11942          move.l    D0,A0
000040F4  5350      11943          subq.w    #1,(A0)
                    11944   OSSemAccept_4:
                    11945   ; }
                    11946   ; OS_EXIT_CRITICAL();
000040F6  46DF      11947          dc.w      18143
                    11948   ; return (cnt);                                     /* Return semaphore count                        */
000040F8  3002      11949          move.w    D2,D0
                    11950   OSSemAccept_3:
000040FA  4CDF 000C 11951          movem.l   (A7)+,D2/D3
000040FE  4E5E      11952          unlk      A6
00004100  4E75      11953          rts
                    11954   ; }
                    11955   ; #endif
                    11956   ; /*$PAGE*/
                    11957   ; /*
                    11958   ; *********************************************************************************************************
                    11959   ; *                                         CREATE A SEMAPHORE
                    11960   ; *
                    11961   ; * Description: This function creates a semaphore.
                    11962   ; *
                    11963   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11964   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11965   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11966   ; *                            10 resources, you would initialize the semaphore to 10).
                    11967   ; *
                    11968   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11969   ; *                            created semaphore
                    11970   ; *              == (void *)0  if no event control blocks were available
                    11971   ; *********************************************************************************************************
                    11972   ; */
                    11973   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11974   ; {
                    11975   _OSSemCreate:
00004102  4E56 0000 11976          link      A6,#0
00004106  48E7 2020 11977          movem.l   D2/A2,-(A7)
0000410A  45F9 0800 11978          lea       _OSEventFreeList.L,A2
0000410E  0AF4      
                    11979   ; OS_EVENT  *pevent;
                    11980   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11981   ; OS_CPU_SR  cpu_sr = 0u;
                    11982   ; #endif
                    11983   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11984   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11985   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11986   ; return ((OS_EVENT *)0);
                    11987   ; }
                    11988   ; #endif
                    11989   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00004110  1039 0800 11990          move.b    _OSIntNesting.L,D0
00004114  0D20      
00004116  0C00 0000 11991          cmp.b     #0,D0
0000411A  6306      11992          bls.s     OSSemCreate_1
                    11993   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
0000411C  4280      11994          clr.l     D0
0000411E  6000 0044 11995          bra       OSSemCreate_3
                    11996   OSSemCreate_1:
                    11997   ; }
                    11998   ; OS_ENTER_CRITICAL();
00004122  40E7      11999          dc.w      16615
00004124  007C      12000          dc.w      124
00004126  0700      12001          dc.w      1792
                    12002   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00004128  2412      12003          move.l    (A2),D2
                    12004   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
0000412A  2012      12005          move.l    (A2),D0
0000412C  6706      12006          beq.s     OSSemCreate_4
                    12007   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
0000412E  2052      12008          move.l    (A2),A0
00004130  24A8 0002 12009          move.l    2(A0),(A2)
                    12010   OSSemCreate_4:
                    12011   ; }
                    12012   ; OS_EXIT_CRITICAL();
00004134  46DF      12013          dc.w      18143
                    12014   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
00004136  4A82      12015          tst.l     D2
00004138  6728      12016          beq.s     OSSemCreate_6
                    12017   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
0000413A  2042      12018          move.l    D2,A0
0000413C  10BC 0003 12019          move.b    #3,(A0)
                    12020   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00004140  2042      12021          move.l    D2,A0
00004142  316E 000A 12022          move.w    10(A6),6(A0)
00004146  0006      
                    12023   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
00004148  2042      12024          move.l    D2,A0
0000414A  42A8 0002 12025          clr.l     2(A0)
                    12026   ; #if OS_EVENT_NAME_EN > 0u
                    12027   ; pevent->OSEventName    = (INT8U *)(void *)"?";
0000414E  41F9 0000 12028          lea       @ucos_ii_1.L,A0
00004152  6F2A      
00004154  2242      12029          move.l    D2,A1
00004156  2348 0012 12030          move.l    A0,18(A1)
                    12031   ; #endif
                    12032   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
0000415A  2F02      12033          move.l    D2,-(A7)
0000415C  4EB8 15F6 12034          jsr       _OS_EventWaitListInit
00004160  584F      12035          addq.w    #4,A7
                    12036   OSSemCreate_6:
                    12037   ; }
                    12038   ; return (pevent);
00004162  2002      12039          move.l    D2,D0
                    12040   OSSemCreate_3:
00004164  4CDF 0404 12041          movem.l   (A7)+,D2/A2
00004168  4E5E      12042          unlk      A6
0000416A  4E75      12043          rts
                    12044   ; }
                    12045   ; /*$PAGE*/
                    12046   ; /*
                    12047   ; *********************************************************************************************************
                    12048   ; *                                         DELETE A SEMAPHORE
                    12049   ; *
                    12050   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    12051   ; *
                    12052   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12053   ; *                            semaphore.
                    12054   ; *
                    12055   ; *              opt           determines delete options as follows:
                    12056   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    12057   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    12058   ; *                                                    In this case, all the tasks pending will be readied.
                    12059   ; *
                    12060   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    12061   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    12062   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    12063   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    12064   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    12065   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    12066   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    12067   ; *
                    12068   ; * Returns    : pevent        upon error
                    12069   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    12070   ; *
                    12071   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    12072   ; *                 the semaphore MUST check the return code of OSSemPend().
                    12073   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    12074   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    12075   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    12076   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    12077   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    12078   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    12079   ; *                 will no longer be guarded by the semaphore.
                    12080   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    12081   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    12082   ; *********************************************************************************************************
                    12083   ; */
                    12084   ; #if OS_SEM_DEL_EN > 0u
                    12085   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    12086   ; INT8U      opt,
                    12087   ; INT8U     *perr)
                    12088   ; {
                    12089   _OSSemDel:
0000416C  4E56 0000 12090          link      A6,#0
00004170  48E7 3C20 12091          movem.l   D2/D3/D4/D5/A2,-(A7)
00004174  242E 0008 12092          move.l    8(A6),D2
00004178  262E 0010 12093          move.l    16(A6),D3
0000417C  45F9 0800 12094          lea       _OSEventFreeList.L,A2
00004180  0AF4      
                    12095   ; BOOLEAN    tasks_waiting;
                    12096   ; OS_EVENT  *pevent_return;
                    12097   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12098   ; OS_CPU_SR  cpu_sr = 0u;
                    12099   ; #endif
                    12100   ; #ifdef OS_SAFETY_CRITICAL
                    12101   ; if (perr == (INT8U *)0) {
                    12102   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12103   ; return ((OS_EVENT *)0);
                    12104   ; }
                    12105   ; #endif
                    12106   ; #if OS_ARG_CHK_EN > 0u
                    12107   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12108   ; *perr = OS_ERR_PEVENT_NULL;
                    12109   ; return (pevent);
                    12110   ; }
                    12111   ; #endif
                    12112   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00004182  2042      12113          move.l    D2,A0
00004184  1010      12114          move.b    (A0),D0
00004186  0C00 0003 12115          cmp.b     #3,D0
0000418A  670C      12116          beq.s     OSSemDel_1
                    12117   ; *perr = OS_ERR_EVENT_TYPE;
0000418C  2043      12118          move.l    D3,A0
0000418E  10BC 0001 12119          move.b    #1,(A0)
                    12120   ; return (pevent);
00004192  2002      12121          move.l    D2,D0
00004194  6000 00EA 12122          bra       OSSemDel_3
                    12123   OSSemDel_1:
                    12124   ; }
                    12125   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00004198  1039 0800 12126          move.b    _OSIntNesting.L,D0
0000419C  0D20      
0000419E  0C00 0000 12127          cmp.b     #0,D0
000041A2  630C      12128          bls.s     OSSemDel_4
                    12129   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000041A4  2043      12130          move.l    D3,A0
000041A6  10BC 000F 12131          move.b    #15,(A0)
                    12132   ; return (pevent);
000041AA  2002      12133          move.l    D2,D0
000041AC  6000 00D2 12134          bra       OSSemDel_3
                    12135   OSSemDel_4:
                    12136   ; }
                    12137   ; OS_ENTER_CRITICAL();
000041B0  40E7      12138          dc.w      16615
000041B2  007C      12139          dc.w      124
000041B4  0700      12140          dc.w      1792
                    12141   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
000041B6  2042      12142          move.l    D2,A0
000041B8  1028 0008 12143          move.b    8(A0),D0
000041BC  6704      12144          beq.s     OSSemDel_6
                    12145   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000041BE  7A01      12146          moveq     #1,D5
000041C0  6002      12147          bra.s     OSSemDel_7
                    12148   OSSemDel_6:
                    12149   ; } else {
                    12150   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000041C2  4205      12151          clr.b     D5
                    12152   OSSemDel_7:
                    12153   ; }
                    12154   ; switch (opt) {
000041C4  102E 000F 12155          move.b    15(A6),D0
000041C8  C0BC 0000 12156          and.l     #255,D0
000041CC  00FF      
000041CE  0C80 0000 12157          cmp.l     #1,D0
000041D2  0001      
000041D4  6700 0048 12158          beq       OSSemDel_11
000041D8  6200 009A 12159          bhi       OSSemDel_8
000041DC  4A80      12160          tst.l     D0
000041DE  6704      12161          beq.s     OSSemDel_10
000041E0  6000 0092 12162          bra       OSSemDel_8
                    12163   OSSemDel_10:
                    12164   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    12165   ; if (tasks_waiting == OS_FALSE) {
000041E4  4A05      12166          tst.b     D5
000041E6  6628      12167          bne.s     OSSemDel_13
                    12168   ; #if OS_EVENT_NAME_EN > 0u
                    12169   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000041E8  41F9 0000 12170          lea       @ucos_ii_1.L,A0
000041EC  6F2A      
000041EE  2242      12171          move.l    D2,A1
000041F0  2348 0012 12172          move.l    A0,18(A1)
                    12173   ; #endif
                    12174   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
000041F4  2042      12175          move.l    D2,A0
000041F6  4210      12176          clr.b     (A0)
                    12177   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
000041F8  2042      12178          move.l    D2,A0
000041FA  2152 0002 12179          move.l    (A2),2(A0)
                    12180   ; pevent->OSEventCnt     = 0u;
000041FE  2042      12181          move.l    D2,A0
00004200  4268 0006 12182          clr.w     6(A0)
                    12183   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00004204  2482      12184          move.l    D2,(A2)
                    12185   ; OS_EXIT_CRITICAL();
00004206  46DF      12186          dc.w      18143
                    12187   ; *perr                  = OS_ERR_NONE;
00004208  2043      12188          move.l    D3,A0
0000420A  4210      12189          clr.b     (A0)
                    12190   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
0000420C  4284      12191          clr.l     D4
0000420E  600A      12192          bra.s     OSSemDel_14
                    12193   OSSemDel_13:
                    12194   ; } else {
                    12195   ; OS_EXIT_CRITICAL();
00004210  46DF      12196          dc.w      18143
                    12197   ; *perr                  = OS_ERR_TASK_WAITING;
00004212  2043      12198          move.l    D3,A0
00004214  10BC 0049 12199          move.b    #73,(A0)
                    12200   ; pevent_return          = pevent;
00004218  2802      12201          move.l    D2,D4
                    12202   OSSemDel_14:
                    12203   ; }
                    12204   ; break;
0000421A  6000 0062 12205          bra       OSSemDel_9
                    12206   OSSemDel_11:
                    12207   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    12208   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    12209   OSSemDel_15:
0000421E  2042      12210          move.l    D2,A0
00004220  1028 0008 12211          move.b    8(A0),D0
00004224  671C      12212          beq.s     OSSemDel_17
                    12213   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00004226  4878 0002 12214          pea       2
0000422A  4878 0001 12215          pea       1
0000422E  42A7      12216          clr.l     -(A7)
00004230  2F02      12217          move.l    D2,-(A7)
00004232  4EB8 132E 12218          jsr       _OS_EventTaskRdy
00004236  DEFC 0010 12219          add.w     #16,A7
0000423A  C0BC 0000 12220          and.l     #255,D0
0000423E  00FF      
00004240  60DC      12221          bra       OSSemDel_15
                    12222   OSSemDel_17:
                    12223   ; }
                    12224   ; #if OS_EVENT_NAME_EN > 0u
                    12225   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00004242  41F9 0000 12226          lea       @ucos_ii_1.L,A0
00004246  6F2A      
00004248  2242      12227          move.l    D2,A1
0000424A  2348 0012 12228          move.l    A0,18(A1)
                    12229   ; #endif
                    12230   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0000424E  2042      12231          move.l    D2,A0
00004250  4210      12232          clr.b     (A0)
                    12233   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00004252  2042      12234          move.l    D2,A0
00004254  2152 0002 12235          move.l    (A2),2(A0)
                    12236   ; pevent->OSEventCnt     = 0u;
00004258  2042      12237          move.l    D2,A0
0000425A  4268 0006 12238          clr.w     6(A0)
                    12239   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
0000425E  2482      12240          move.l    D2,(A2)
                    12241   ; OS_EXIT_CRITICAL();
00004260  46DF      12242          dc.w      18143
                    12243   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00004262  0C05 0001 12244          cmp.b     #1,D5
00004266  6604      12245          bne.s     OSSemDel_18
                    12246   ; OS_Sched();                               /* Find highest priority task ready to run  */
00004268  4EB8 190E 12247          jsr       _OS_Sched
                    12248   OSSemDel_18:
                    12249   ; }
                    12250   ; *perr                  = OS_ERR_NONE;
0000426C  2043      12251          move.l    D3,A0
0000426E  4210      12252          clr.b     (A0)
                    12253   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00004270  4284      12254          clr.l     D4
                    12255   ; break;
00004272  600A      12256          bra.s     OSSemDel_9
                    12257   OSSemDel_8:
                    12258   ; default:
                    12259   ; OS_EXIT_CRITICAL();
00004274  46DF      12260          dc.w      18143
                    12261   ; *perr                  = OS_ERR_INVALID_OPT;
00004276  2043      12262          move.l    D3,A0
00004278  10BC 0007 12263          move.b    #7,(A0)
                    12264   ; pevent_return          = pevent;
0000427C  2802      12265          move.l    D2,D4
                    12266   ; break;
                    12267   OSSemDel_9:
                    12268   ; }
                    12269   ; return (pevent_return);
0000427E  2004      12270          move.l    D4,D0
                    12271   OSSemDel_3:
00004280  4CDF 043C 12272          movem.l   (A7)+,D2/D3/D4/D5/A2
00004284  4E5E      12273          unlk      A6
00004286  4E75      12274          rts
                    12275   ; }
                    12276   ; #endif
                    12277   ; /*$PAGE*/
                    12278   ; /*
                    12279   ; *********************************************************************************************************
                    12280   ; *                                          PEND ON SEMAPHORE
                    12281   ; *
                    12282   ; * Description: This function waits for a semaphore.
                    12283   ; *
                    12284   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12285   ; *                            semaphore.
                    12286   ; *
                    12287   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    12288   ; *                            wait for the resource up to the amount of time specified by this argument.
                    12289   ; *                            If you specify 0, however, your task will wait forever at the specified
                    12290   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    12291   ; *
                    12292   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12293   ; *                            messages are:
                    12294   ; *
                    12295   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    12296   ; *                                                or, the event you are waiting for occurred.
                    12297   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    12298   ; *                                                'timeout'.
                    12299   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    12300   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12301   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    12302   ; *                                                would lead to a suspension.
                    12303   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12304   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    12305   ; *
                    12306   ; * Returns    : none
                    12307   ; *********************************************************************************************************
                    12308   ; */
                    12309   ; /*$PAGE*/
                    12310   ; void  OSSemPend (OS_EVENT  *pevent,
                    12311   ; INT32U     timeout,
                    12312   ; INT8U     *perr)
                    12313   ; {
                    12314   _OSSemPend:
00004288  4E56 0000 12315          link      A6,#0
0000428C  48E7 3020 12316          movem.l   D2/D3/A2,-(A7)
00004290  45F9 0800 12317          lea       _OSTCBCur.L,A2
00004294  0E3A      
00004296  242E 0010 12318          move.l    16(A6),D2
0000429A  262E 0008 12319          move.l    8(A6),D3
                    12320   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12321   ; OS_CPU_SR  cpu_sr = 0u;
                    12322   ; #endif
                    12323   ; #ifdef OS_SAFETY_CRITICAL
                    12324   ; if (perr == (INT8U *)0) {
                    12325   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12326   ; return;
                    12327   ; }
                    12328   ; #endif
                    12329   ; #if OS_ARG_CHK_EN > 0u
                    12330   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12331   ; *perr = OS_ERR_PEVENT_NULL;
                    12332   ; return;
                    12333   ; }
                    12334   ; #endif
                    12335   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000429E  2043      12336          move.l    D3,A0
000042A0  1010      12337          move.b    (A0),D0
000042A2  0C00 0003 12338          cmp.b     #3,D0
000042A6  670A      12339          beq.s     OSSemPend_1
                    12340   ; *perr = OS_ERR_EVENT_TYPE;
000042A8  2042      12341          move.l    D2,A0
000042AA  10BC 0001 12342          move.b    #1,(A0)
                    12343   ; return;
000042AE  6000 00DA 12344          bra       OSSemPend_3
                    12345   OSSemPend_1:
                    12346   ; }
                    12347   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
000042B2  1039 0800 12348          move.b    _OSIntNesting.L,D0
000042B6  0D20      
000042B8  0C00 0000 12349          cmp.b     #0,D0
000042BC  630A      12350          bls.s     OSSemPend_4
                    12351   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
000042BE  2042      12352          move.l    D2,A0
000042C0  10BC 0002 12353          move.b    #2,(A0)
                    12354   ; return;
000042C4  6000 00C4 12355          bra       OSSemPend_3
                    12356   OSSemPend_4:
                    12357   ; }
                    12358   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000042C8  1039 0800 12359          move.b    _OSLockNesting.L,D0
000042CC  0D22      
000042CE  0C00 0000 12360          cmp.b     #0,D0
000042D2  630A      12361          bls.s     OSSemPend_6
                    12362   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
000042D4  2042      12363          move.l    D2,A0
000042D6  10BC 000D 12364          move.b    #13,(A0)
                    12365   ; return;
000042DA  6000 00AE 12366          bra       OSSemPend_3
                    12367   OSSemPend_6:
                    12368   ; }
                    12369   ; OS_ENTER_CRITICAL();
000042DE  40E7      12370          dc.w      16615
000042E0  007C      12371          dc.w      124
000042E2  0700      12372          dc.w      1792
                    12373   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
000042E4  2043      12374          move.l    D3,A0
000042E6  3028 0006 12375          move.w    6(A0),D0
000042EA  0C40 0000 12376          cmp.w     #0,D0
000042EE  6312      12377          bls.s     OSSemPend_8
                    12378   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
000042F0  2003      12379          move.l    D3,D0
000042F2  5C80      12380          addq.l    #6,D0
000042F4  2040      12381          move.l    D0,A0
000042F6  5350      12382          subq.w    #1,(A0)
                    12383   ; OS_EXIT_CRITICAL();
000042F8  46DF      12384          dc.w      18143
                    12385   ; *perr = OS_ERR_NONE;
000042FA  2042      12386          move.l    D2,A0
000042FC  4210      12387          clr.b     (A0)
                    12388   ; return;
000042FE  6000 008A 12389          bra       OSSemPend_3
                    12390   OSSemPend_8:
                    12391   ; }
                    12392   ; /* Otherwise, must wait until event occurs       */
                    12393   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
00004302  2052      12394          move.l    (A2),A0
00004304  0028 0001 12395          or.b      #1,50(A0)
00004308  0032      
                    12396   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0000430A  2052      12397          move.l    (A2),A0
0000430C  4228 0033 12398          clr.b     51(A0)
                    12399   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00004310  2052      12400          move.l    (A2),A0
00004312  216E 000C 12401          move.l    12(A6),46(A0)
00004316  002E      
                    12402   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00004318  2F03      12403          move.l    D3,-(A7)
0000431A  4EB8 1412 12404          jsr       _OS_EventTaskWait
0000431E  584F      12405          addq.w    #4,A7
                    12406   ; OS_EXIT_CRITICAL();
00004320  46DF      12407          dc.w      18143
                    12408   ; OS_Sched();                                       /* Find next highest priority task ready         */
00004322  4EB8 190E 12409          jsr       _OS_Sched
                    12410   ; OS_ENTER_CRITICAL();
00004326  40E7      12411          dc.w      16615
00004328  007C      12412          dc.w      124
0000432A  0700      12413          dc.w      1792
                    12414   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
0000432C  2052      12415          move.l    (A2),A0
0000432E  1028 0033 12416          move.b    51(A0),D0
00004332  C0BC 0000 12417          and.l     #255,D0
00004336  00FF      
00004338  0C80 0000 12418          cmp.l     #1,D0
0000433C  0001      
0000433E  6720      12419          beq.s     OSSemPend_14
00004340  6206      12420          bhi.s     OSSemPend_16
00004342  4A80      12421          tst.l     D0
00004344  670C      12422          beq.s     OSSemPend_12
00004346  6018      12423          bra.s     OSSemPend_14
                    12424   OSSemPend_16:
00004348  0C80 0000 12425          cmp.l     #2,D0
0000434C  0002      
0000434E  6708      12426          beq.s     OSSemPend_13
00004350  600E      12427          bra.s     OSSemPend_14
                    12428   OSSemPend_12:
                    12429   ; case OS_STAT_PEND_OK:
                    12430   ; *perr = OS_ERR_NONE;
00004352  2042      12431          move.l    D2,A0
00004354  4210      12432          clr.b     (A0)
                    12433   ; break;
00004356  6018      12434          bra.s     OSSemPend_11
                    12435   OSSemPend_13:
                    12436   ; case OS_STAT_PEND_ABORT:
                    12437   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00004358  2042      12438          move.l    D2,A0
0000435A  10BC 000E 12439          move.b    #14,(A0)
                    12440   ; break;
0000435E  6010      12441          bra.s     OSSemPend_11
                    12442   OSSemPend_14:
                    12443   ; case OS_STAT_PEND_TO:
                    12444   ; default:
                    12445   ; OS_EventTaskRemove(OSTCBCur, pevent);
00004360  2F03      12446          move.l    D3,-(A7)
00004362  2F12      12447          move.l    (A2),-(A7)
00004364  4EB8 1534 12448          jsr       _OS_EventTaskRemove
00004368  504F      12449          addq.w    #8,A7
                    12450   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
0000436A  2042      12451          move.l    D2,A0
0000436C  10BC 000A 12452          move.b    #10,(A0)
                    12453   ; break;
                    12454   OSSemPend_11:
                    12455   ; }
                    12456   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00004370  2052      12457          move.l    (A2),A0
00004372  4228 0032 12458          clr.b     50(A0)
                    12459   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00004376  2052      12460          move.l    (A2),A0
00004378  4228 0033 12461          clr.b     51(A0)
                    12462   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
0000437C  2052      12463          move.l    (A2),A0
0000437E  42A8 001C 12464          clr.l     28(A0)
                    12465   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12466   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00004382  2052      12467          move.l    (A2),A0
00004384  42A8 0020 12468          clr.l     32(A0)
                    12469   ; #endif
                    12470   ; OS_EXIT_CRITICAL();
00004388  46DF      12471          dc.w      18143
                    12472   OSSemPend_3:
0000438A  4CDF 040C 12473          movem.l   (A7)+,D2/D3/A2
0000438E  4E5E      12474          unlk      A6
00004390  4E75      12475          rts
                    12476   ; }
                    12477   ; /*$PAGE*/
                    12478   ; /*
                    12479   ; *********************************************************************************************************
                    12480   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12481   ; *
                    12482   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12483   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12484   ; *              the semaphore via OSSemPost().
                    12485   ; *
                    12486   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12487   ; *                            semaphore.
                    12488   ; *
                    12489   ; *              opt           determines the type of ABORT performed:
                    12490   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12491   ; *                                                     semaphore
                    12492   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12493   ; *                                                     semaphore
                    12494   ; *
                    12495   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12496   ; *                            messages are:
                    12497   ; *
                    12498   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12499   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12500   ; *                                                and informed of the aborted wait; check return value
                    12501   ; *                                                for the number of tasks whose wait on the semaphore
                    12502   ; *                                                was aborted.
                    12503   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12504   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12505   ; *
                    12506   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12507   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12508   ; *********************************************************************************************************
                    12509   ; */
                    12510   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12511   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12512   ; INT8U      opt,
                    12513   ; INT8U     *perr)
                    12514   ; {
                    12515   _OSSemPendAbort:
00004392  4E56 0000 12516          link      A6,#0
00004396  48E7 3800 12517          movem.l   D2/D3/D4,-(A7)
0000439A  242E 0008 12518          move.l    8(A6),D2
0000439E  282E 0010 12519          move.l    16(A6),D4
                    12520   ; INT8U      nbr_tasks;
                    12521   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12522   ; OS_CPU_SR  cpu_sr = 0u;
                    12523   ; #endif
                    12524   ; #ifdef OS_SAFETY_CRITICAL
                    12525   ; if (perr == (INT8U *)0) {
                    12526   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12527   ; return (0u);
                    12528   ; }
                    12529   ; #endif
                    12530   ; #if OS_ARG_CHK_EN > 0u
                    12531   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12532   ; *perr = OS_ERR_PEVENT_NULL;
                    12533   ; return (0u);
                    12534   ; }
                    12535   ; #endif
                    12536   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000043A2  2042      12537          move.l    D2,A0
000043A4  1010      12538          move.b    (A0),D0
000043A6  0C00 0003 12539          cmp.b     #3,D0
000043AA  670C      12540          beq.s     OSSemPendAbort_1
                    12541   ; *perr = OS_ERR_EVENT_TYPE;
000043AC  2044      12542          move.l    D4,A0
000043AE  10BC 0001 12543          move.b    #1,(A0)
                    12544   ; return (0u);
000043B2  4200      12545          clr.b     D0
000043B4  6000 008C 12546          bra       OSSemPendAbort_3
                    12547   OSSemPendAbort_1:
                    12548   ; }
                    12549   ; OS_ENTER_CRITICAL();
000043B8  40E7      12550          dc.w      16615
000043BA  007C      12551          dc.w      124
000043BC  0700      12552          dc.w      1792
                    12553   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
000043BE  2042      12554          move.l    D2,A0
000043C0  1028 0008 12555          move.b    8(A0),D0
000043C4  6700 0074 12556          beq       OSSemPendAbort_4
                    12557   ; nbr_tasks = 0u;
000043C8  4203      12558          clr.b     D3
                    12559   ; switch (opt) {
000043CA  102E 000F 12560          move.b    15(A6),D0
000043CE  C0BC 0000 12561          and.l     #255,D0
000043D2  00FF      
000043D4  0C80 0000 12562          cmp.l     #1,D0
000043D8  0001      
000043DA  670A      12563          beq.s     OSSemPendAbort_8
000043DC  6200 0030 12564          bhi       OSSemPendAbort_9
000043E0  4A80      12565          tst.l     D0
000043E2  672A      12566          beq.s     OSSemPendAbort_9
000043E4  6028      12567          bra.s     OSSemPendAbort_9
                    12568   OSSemPendAbort_8:
                    12569   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12570   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12571   OSSemPendAbort_11:
000043E6  2042      12572          move.l    D2,A0
000043E8  1028 0008 12573          move.b    8(A0),D0
000043EC  671E      12574          beq.s     OSSemPendAbort_13
                    12575   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
000043EE  4878 0002 12576          pea       2
000043F2  4878 0001 12577          pea       1
000043F6  42A7      12578          clr.l     -(A7)
000043F8  2F02      12579          move.l    D2,-(A7)
000043FA  4EB8 132E 12580          jsr       _OS_EventTaskRdy
000043FE  DEFC 0010 12581          add.w     #16,A7
00004402  C0BC 0000 12582          and.l     #255,D0
00004406  00FF      
                    12583   ; nbr_tasks++;
00004408  5203      12584          addq.b    #1,D3
0000440A  60DA      12585          bra       OSSemPendAbort_11
                    12586   OSSemPendAbort_13:
                    12587   ; }
                    12588   ; break;
0000440C  601C      12589          bra.s     OSSemPendAbort_7
                    12590   OSSemPendAbort_9:
                    12591   ; case OS_PEND_OPT_NONE:
                    12592   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12593   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0000440E  4878 0002 12594          pea       2
00004412  4878 0001 12595          pea       1
00004416  42A7      12596          clr.l     -(A7)
00004418  2F02      12597          move.l    D2,-(A7)
0000441A  4EB8 132E 12598          jsr       _OS_EventTaskRdy
0000441E  DEFC 0010 12599          add.w     #16,A7
00004422  C0BC 0000 12600          and.l     #255,D0
00004426  00FF      
                    12601   ; nbr_tasks++;
00004428  5203      12602          addq.b    #1,D3
                    12603   ; break;
                    12604   OSSemPendAbort_7:
                    12605   ; }
                    12606   ; OS_EXIT_CRITICAL();
0000442A  46DF      12607          dc.w      18143
                    12608   ; OS_Sched();                                   /* Find HPT ready to run                         */
0000442C  4EB8 190E 12609          jsr       _OS_Sched
                    12610   ; *perr = OS_ERR_PEND_ABORT;
00004430  2044      12611          move.l    D4,A0
00004432  10BC 000E 12612          move.b    #14,(A0)
                    12613   ; return (nbr_tasks);
00004436  1003      12614          move.b    D3,D0
00004438  6008      12615          bra.s     OSSemPendAbort_3
                    12616   OSSemPendAbort_4:
                    12617   ; }
                    12618   ; OS_EXIT_CRITICAL();
0000443A  46DF      12619          dc.w      18143
                    12620   ; *perr = OS_ERR_NONE;
0000443C  2044      12621          move.l    D4,A0
0000443E  4210      12622          clr.b     (A0)
                    12623   ; return (0u);                                      /* No tasks waiting on semaphore                 */
00004440  4200      12624          clr.b     D0
                    12625   OSSemPendAbort_3:
00004442  4CDF 001C 12626          movem.l   (A7)+,D2/D3/D4
00004446  4E5E      12627          unlk      A6
00004448  4E75      12628          rts
                    12629   ; }
                    12630   ; #endif
                    12631   ; /*$PAGE*/
                    12632   ; /*
                    12633   ; *********************************************************************************************************
                    12634   ; *                                         POST TO A SEMAPHORE
                    12635   ; *
                    12636   ; * Description: This function signals a semaphore
                    12637   ; *
                    12638   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12639   ; *                            semaphore.
                    12640   ; *
                    12641   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12642   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12643   ; *                                  signaled the semaphore more often than you waited on it with either
                    12644   ; *                                  OSSemAccept() or OSSemPend().
                    12645   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12646   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12647   ; *********************************************************************************************************
                    12648   ; */
                    12649   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12650   ; {
                    12651   _OSSemPost:
0000444A  4E56 0000 12652          link      A6,#0
0000444E  2F02      12653          move.l    D2,-(A7)
00004450  242E 0008 12654          move.l    8(A6),D2
                    12655   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12656   ; OS_CPU_SR  cpu_sr = 0u;
                    12657   ; #endif
                    12658   ; #if OS_ARG_CHK_EN > 0u
                    12659   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12660   ; return (OS_ERR_PEVENT_NULL);
                    12661   ; }
                    12662   ; #endif
                    12663   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004454  2042      12664          move.l    D2,A0
00004456  1010      12665          move.b    (A0),D0
00004458  0C00 0003 12666          cmp.b     #3,D0
0000445C  6706      12667          beq.s     OSSemPost_1
                    12668   ; return (OS_ERR_EVENT_TYPE);
0000445E  7001      12669          moveq     #1,D0
00004460  6000 0050 12670          bra       OSSemPost_3
                    12671   OSSemPost_1:
                    12672   ; }
                    12673   ; OS_ENTER_CRITICAL();
00004464  40E7      12674          dc.w      16615
00004466  007C      12675          dc.w      124
00004468  0700      12676          dc.w      1792
                    12677   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
0000446A  2042      12678          move.l    D2,A0
0000446C  1028 0008 12679          move.b    8(A0),D0
00004470  6722      12680          beq.s     OSSemPost_4
                    12681   ; /* Ready HPT waiting on event                    */
                    12682   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
00004472  42A7      12683          clr.l     -(A7)
00004474  4878 0001 12684          pea       1
00004478  42A7      12685          clr.l     -(A7)
0000447A  2F02      12686          move.l    D2,-(A7)
0000447C  4EB8 132E 12687          jsr       _OS_EventTaskRdy
00004480  DEFC 0010 12688          add.w     #16,A7
00004484  C0BC 0000 12689          and.l     #255,D0
00004488  00FF      
                    12690   ; OS_EXIT_CRITICAL();
0000448A  46DF      12691          dc.w      18143
                    12692   ; OS_Sched();                                   /* Find HPT ready to run                         */
0000448C  4EB8 190E 12693          jsr       _OS_Sched
                    12694   ; return (OS_ERR_NONE);
00004490  4200      12695          clr.b     D0
00004492  601E      12696          bra.s     OSSemPost_3
                    12697   OSSemPost_4:
                    12698   ; }
                    12699   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
00004494  2042      12700          move.l    D2,A0
00004496  3028 0006 12701          move.w    6(A0),D0
0000449A  0C40 FFFF 12702          cmp.w     #65535,D0
0000449E  640E      12703          bhs.s     OSSemPost_6
                    12704   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
000044A0  2002      12705          move.l    D2,D0
000044A2  5C80      12706          addq.l    #6,D0
000044A4  2040      12707          move.l    D0,A0
000044A6  5250      12708          addq.w    #1,(A0)
                    12709   ; OS_EXIT_CRITICAL();
000044A8  46DF      12710          dc.w      18143
                    12711   ; return (OS_ERR_NONE);
000044AA  4200      12712          clr.b     D0
000044AC  6004      12713          bra.s     OSSemPost_3
                    12714   OSSemPost_6:
                    12715   ; }
                    12716   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
000044AE  46DF      12717          dc.w      18143
                    12718   ; return (OS_ERR_SEM_OVF);
000044B0  7033      12719          moveq     #51,D0
                    12720   OSSemPost_3:
000044B2  241F      12721          move.l    (A7)+,D2
000044B4  4E5E      12722          unlk      A6
000044B6  4E75      12723          rts
                    12724   ; }
                    12725   ; /*$PAGE*/
                    12726   ; /*
                    12727   ; *********************************************************************************************************
                    12728   ; *                                          QUERY A SEMAPHORE
                    12729   ; *
                    12730   ; * Description: This function obtains information about a semaphore
                    12731   ; *
                    12732   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12733   ; *                            semaphore
                    12734   ; *
                    12735   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12736   ; *                            semaphore.
                    12737   ; *
                    12738   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12739   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12740   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12741   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12742   ; *********************************************************************************************************
                    12743   ; */
                    12744   ; #if OS_SEM_QUERY_EN > 0u
                    12745   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12746   ; OS_SEM_DATA  *p_sem_data)
                    12747   ; {
                    12748   _OSSemQuery:
000044B8  4E56 FFF8 12749          link      A6,#-8
000044BC  48E7 3800 12750          movem.l   D2/D3/D4,-(A7)
000044C0  242E 0008 12751          move.l    8(A6),D2
000044C4  282E 000C 12752          move.l    12(A6),D4
                    12753   ; INT8U       i;
                    12754   ; OS_PRIO    *psrc;
                    12755   ; OS_PRIO    *pdest;
                    12756   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12757   ; OS_CPU_SR   cpu_sr = 0u;
                    12758   ; #endif
                    12759   ; #if OS_ARG_CHK_EN > 0u
                    12760   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12761   ; return (OS_ERR_PEVENT_NULL);
                    12762   ; }
                    12763   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12764   ; return (OS_ERR_PDATA_NULL);
                    12765   ; }
                    12766   ; #endif
                    12767   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
000044C8  2042      12768          move.l    D2,A0
000044CA  1010      12769          move.b    (A0),D0
000044CC  0C00 0003 12770          cmp.b     #3,D0
000044D0  6706      12771          beq.s     OSSemQuery_1
                    12772   ; return (OS_ERR_EVENT_TYPE);
000044D2  7001      12773          moveq     #1,D0
000044D4  6000 004C 12774          bra       OSSemQuery_3
                    12775   OSSemQuery_1:
                    12776   ; }
                    12777   ; OS_ENTER_CRITICAL();
000044D8  40E7      12778          dc.w      16615
000044DA  007C      12779          dc.w      124
000044DC  0700      12780          dc.w      1792
                    12781   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
000044DE  2042      12782          move.l    D2,A0
000044E0  2244      12783          move.l    D4,A1
000044E2  1368 0008 12784          move.b    8(A0),10(A1)
000044E6  000A      
                    12785   ; psrc                   = &pevent->OSEventTbl[0];
000044E8  700A      12786          moveq     #10,D0
000044EA  D082      12787          add.l     D2,D0
000044EC  2D40 FFF8 12788          move.l    D0,-8(A6)
                    12789   ; pdest                  = &p_sem_data->OSEventTbl[0];
000044F0  7002      12790          moveq     #2,D0
000044F2  D084      12791          add.l     D4,D0
000044F4  2D40 FFFC 12792          move.l    D0,-4(A6)
                    12793   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000044F8  4203      12794          clr.b     D3
                    12795   OSSemQuery_4:
000044FA  0C03 0008 12796          cmp.b     #8,D3
000044FE  6416      12797          bhs.s     OSSemQuery_6
                    12798   ; *pdest++ = *psrc++;
00004500  206E FFF8 12799          move.l    -8(A6),A0
00004504  52AE FFF8 12800          addq.l    #1,-8(A6)
00004508  226E FFFC 12801          move.l    -4(A6),A1
0000450C  52AE FFFC 12802          addq.l    #1,-4(A6)
00004510  1290      12803          move.b    (A0),(A1)
00004512  5203      12804          addq.b    #1,D3
00004514  60E4      12805          bra       OSSemQuery_4
                    12806   OSSemQuery_6:
                    12807   ; }
                    12808   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
00004516  2042      12809          move.l    D2,A0
00004518  2244      12810          move.l    D4,A1
0000451A  32A8 0006 12811          move.w    6(A0),(A1)
                    12812   ; OS_EXIT_CRITICAL();
0000451E  46DF      12813          dc.w      18143
                    12814   ; return (OS_ERR_NONE);
00004520  4200      12815          clr.b     D0
                    12816   OSSemQuery_3:
00004522  4CDF 001C 12817          movem.l   (A7)+,D2/D3/D4
00004526  4E5E      12818          unlk      A6
00004528  4E75      12819          rts
                    12820   ; }
                    12821   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12822   ; /*$PAGE*/
                    12823   ; /*
                    12824   ; *********************************************************************************************************
                    12825   ; *                                            SET SEMAPHORE
                    12826   ; *
                    12827   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12828   ; *              this value would be 0.
                    12829   ; *
                    12830   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12831   ; *              and, you want to reset the count value.
                    12832   ; *
                    12833   ; * Arguments  : pevent     is a pointer to the event control block
                    12834   ; *
                    12835   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12836   ; *                         semaphore count.
                    12837   ; *
                    12838   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12839   ; *
                    12840   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12841   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12842   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12843   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12844   ; *********************************************************************************************************
                    12845   ; */
                    12846   ; #if OS_SEM_SET_EN > 0u
                    12847   ; void  OSSemSet (OS_EVENT  *pevent,
                    12848   ; INT16U     cnt,
                    12849   ; INT8U     *perr)
                    12850   ; {
                    12851   _OSSemSet:
0000452A  4E56 0000 12852          link      A6,#0
0000452E  48E7 3000 12853          movem.l   D2/D3,-(A7)
00004532  242E 0008 12854          move.l    8(A6),D2
00004536  262E 0010 12855          move.l    16(A6),D3
                    12856   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12857   ; OS_CPU_SR  cpu_sr = 0u;
                    12858   ; #endif
                    12859   ; #ifdef OS_SAFETY_CRITICAL
                    12860   ; if (perr == (INT8U *)0) {
                    12861   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12862   ; return;
                    12863   ; }
                    12864   ; #endif
                    12865   ; #if OS_ARG_CHK_EN > 0u
                    12866   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12867   ; *perr = OS_ERR_PEVENT_NULL;
                    12868   ; return;
                    12869   ; }
                    12870   ; #endif
                    12871   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0000453A  2042      12872          move.l    D2,A0
0000453C  1010      12873          move.b    (A0),D0
0000453E  0C00 0003 12874          cmp.b     #3,D0
00004542  670A      12875          beq.s     OSSemSet_1
                    12876   ; *perr = OS_ERR_EVENT_TYPE;
00004544  2043      12877          move.l    D3,A0
00004546  10BC 0001 12878          move.b    #1,(A0)
                    12879   ; return;
0000454A  6000 003C 12880          bra       OSSemSet_3
                    12881   OSSemSet_1:
                    12882   ; }
                    12883   ; OS_ENTER_CRITICAL();
0000454E  40E7      12884          dc.w      16615
00004550  007C      12885          dc.w      124
00004552  0700      12886          dc.w      1792
                    12887   ; *perr = OS_ERR_NONE;
00004554  2043      12888          move.l    D3,A0
00004556  4210      12889          clr.b     (A0)
                    12890   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
00004558  2042      12891          move.l    D2,A0
0000455A  3028 0006 12892          move.w    6(A0),D0
0000455E  0C40 0000 12893          cmp.w     #0,D0
00004562  630A      12894          bls.s     OSSemSet_4
                    12895   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
00004564  2042      12896          move.l    D2,A0
00004566  316E 000E 12897          move.w    14(A6),6(A0)
0000456A  0006      
0000456C  6018      12898          bra.s     OSSemSet_7
                    12899   OSSemSet_4:
                    12900   ; } else {                                          /* No                                            */
                    12901   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
0000456E  2042      12902          move.l    D2,A0
00004570  1028 0008 12903          move.b    8(A0),D0
00004574  660A      12904          bne.s     OSSemSet_6
                    12905   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
00004576  2042      12906          move.l    D2,A0
00004578  316E 000E 12907          move.w    14(A6),6(A0)
0000457C  0006      
0000457E  6006      12908          bra.s     OSSemSet_7
                    12909   OSSemSet_6:
                    12910   ; } else {
                    12911   ; *perr              = OS_ERR_TASK_WAITING;
00004580  2043      12912          move.l    D3,A0
00004582  10BC 0049 12913          move.b    #73,(A0)
                    12914   OSSemSet_7:
                    12915   ; }
                    12916   ; }
                    12917   ; OS_EXIT_CRITICAL();
00004586  46DF      12918          dc.w      18143
                    12919   OSSemSet_3:
00004588  4CDF 000C 12920          movem.l   (A7)+,D2/D3
0000458C  4E5E      12921          unlk      A6
0000458E  4E75      12922          rts
                    12923   ; /*
                    12924   ; *********************************************************************************************************
                    12925   ; *                                                uC/OS-II
                    12926   ; *                                          The Real-Time Kernel
                    12927   ; *                                            TASK MANAGEMENT
                    12928   ; *
                    12929   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12930   ; *                                           All Rights Reserved
                    12931   ; *
                    12932   ; * File    : OS_TASK.C
                    12933   ; * By      : Jean J. Labrosse
                    12934   ; * Version : V2.92.07
                    12935   ; *
                    12936   ; * LICENSING TERMS:
                    12937   ; * ---------------
                    12938   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12939   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12940   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12941   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12942   ; * licensing fee.
                    12943   ; *********************************************************************************************************
                    12944   ; */
                    12945   ; #define  MICRIUM_SOURCE
                    12946   ; #ifndef  OS_MASTER_FILE
                    12947   ; #include <ucos_ii.h>
                    12948   ; #endif
                    12949   ; /*$PAGE*/
                    12950   ; /*
                    12951   ; *********************************************************************************************************
                    12952   ; *                                      CHANGE PRIORITY OF A TASK
                    12953   ; *
                    12954   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12955   ; *              priority MUST be available.
                    12956   ; *
                    12957   ; * Arguments  : oldp     is the old priority
                    12958   ; *
                    12959   ; *              newp     is the new priority
                    12960   ; *
                    12961   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12962   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12963   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12964   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12965   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12966   ; *                                     not exist.
                    12967   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12968   ; *********************************************************************************************************
                    12969   ; */
                    12970   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12971   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12972   ; INT8U  newprio)
                    12973   ; {
                    12974   _OSTaskChangePrio:
00004590  4E56 FFFC 12975          link      A6,#-4
00004594  48E7 3F38 12976          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00004598  47F9 0800 12977          lea       _OSRdyTbl.L,A3
0000459C  0D2A      
0000459E  49F9 0800 12978          lea       _OSTCBPrioTbl.L,A4
000045A2  0E4A      
                    12979   ; #if (OS_EVENT_EN)
                    12980   ; OS_EVENT  *pevent;
                    12981   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12982   ; OS_EVENT **pevents;
                    12983   ; #endif
                    12984   ; #endif
                    12985   ; OS_TCB    *ptcb;
                    12986   ; INT8U      y_new;
                    12987   ; INT8U      x_new;
                    12988   ; INT8U      y_old;
                    12989   ; OS_PRIO    bity_new;
                    12990   ; OS_PRIO    bitx_new;
                    12991   ; OS_PRIO    bity_old;
                    12992   ; OS_PRIO    bitx_old;
                    12993   ; #if OS_CRITICAL_METHOD == 3u
                    12994   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12995   ; #endif
                    12996   ; /*$PAGE*/
                    12997   ; #if OS_ARG_CHK_EN > 0u
                    12998   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12999   ; if (oldprio != OS_PRIO_SELF) {
                    13000   ; return (OS_ERR_PRIO_INVALID);
                    13001   ; }
                    13002   ; }
                    13003   ; if (newprio >= OS_LOWEST_PRIO) {
                    13004   ; return (OS_ERR_PRIO_INVALID);
                    13005   ; }
                    13006   ; #endif
                    13007   ; OS_ENTER_CRITICAL();
000045A4  40E7      13008          dc.w      16615
000045A6  007C      13009          dc.w      124
000045A8  0700      13010          dc.w      1792
                    13011   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
000045AA  102E 000F 13012          move.b    15(A6),D0
000045AE  C0BC 0000 13013          and.l     #255,D0
000045B2  00FF      
000045B4  E588      13014          lsl.l     #2,D0
000045B6  2034 0800 13015          move.l    0(A4,D0.L),D0
000045BA  6708      13016          beq.s     OSTaskChangePrio_1
                    13017   ; OS_EXIT_CRITICAL();
000045BC  46DF      13018          dc.w      18143
                    13019   ; return (OS_ERR_PRIO_EXIST);
000045BE  7028      13020          moveq     #40,D0
000045C0  6000 01E0 13021          bra       OSTaskChangePrio_3
                    13022   OSTaskChangePrio_1:
                    13023   ; }
                    13024   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
000045C4  102E 000B 13025          move.b    11(A6),D0
000045C8  0C00 00FF 13026          cmp.b     #255,D0
000045CC  660C      13027          bne.s     OSTaskChangePrio_4
                    13028   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
000045CE  2079 0800 13029          move.l    _OSTCBCur.L,A0
000045D2  0E3A      
000045D4  1D68 0034 13030          move.b    52(A0),11(A6)
000045D8  000B      
                    13031   OSTaskChangePrio_4:
                    13032   ; }
                    13033   ; ptcb = OSTCBPrioTbl[oldprio];
000045DA  102E 000B 13034          move.b    11(A6),D0
000045DE  C0BC 0000 13035          and.l     #255,D0
000045E2  00FF      
000045E4  E588      13036          lsl.l     #2,D0
000045E6  2634 0800 13037          move.l    0(A4,D0.L),D3
                    13038   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
000045EA  4A83      13039          tst.l     D3
000045EC  6608      13040          bne.s     OSTaskChangePrio_6
                    13041   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000045EE  46DF      13042          dc.w      18143
                    13043   ; return (OS_ERR_PRIO);
000045F0  7029      13044          moveq     #41,D0
000045F2  6000 01AE 13045          bra       OSTaskChangePrio_3
                    13046   OSTaskChangePrio_6:
                    13047   ; }
                    13048   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
000045F6  0C83 0000 13049          cmp.l     #1,D3
000045FA  0001      
000045FC  6608      13050          bne.s     OSTaskChangePrio_8
                    13051   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000045FE  46DF      13052          dc.w      18143
                    13053   ; return (OS_ERR_TASK_NOT_EXIST);
00004600  7043      13054          moveq     #67,D0
00004602  6000 019E 13055          bra       OSTaskChangePrio_3
                    13056   OSTaskChangePrio_8:
                    13057   ; }
                    13058   ; #if OS_LOWEST_PRIO <= 63u
                    13059   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
00004606  102E 000F 13060          move.b    15(A6),D0
0000460A  E608      13061          lsr.b     #3,D0
0000460C  1A00      13062          move.b    D0,D5
                    13063   ; x_new                 = (INT8U)(newprio & 0x07u);
0000460E  102E 000F 13064          move.b    15(A6),D0
00004612  C03C 0007 13065          and.b     #7,D0
00004616  1D40 FFFD 13066          move.b    D0,-3(A6)
                    13067   ; #else
                    13068   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    13069   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    13070   ; #endif
                    13071   ; bity_new              = (OS_PRIO)(1uL << y_new);
0000461A  7001      13072          moveq     #1,D0
0000461C  CABC 0000 13073          and.l     #255,D5
00004620  00FF      
00004622  EBA8      13074          lsl.l     D5,D0
00004624  1D40 FFFE 13075          move.b    D0,-2(A6)
                    13076   ; bitx_new              = (OS_PRIO)(1uL << x_new);
00004628  7001      13077          moveq     #1,D0
0000462A  122E FFFD 13078          move.b    -3(A6),D1
0000462E  C2BC 0000 13079          and.l     #255,D1
00004632  00FF      
00004634  E3A8      13080          lsl.l     D1,D0
00004636  1E00      13081          move.b    D0,D7
                    13082   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
00004638  102E 000B 13083          move.b    11(A6),D0
0000463C  C0BC 0000 13084          and.l     #255,D0
00004640  00FF      
00004642  E588      13085          lsl.l     #2,D0
00004644  42B4 0800 13086          clr.l     0(A4,D0.L)
                    13087   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00004648  102E 000F 13088          move.b    15(A6),D0
0000464C  C0BC 0000 13089          and.l     #255,D0
00004650  00FF      
00004652  E588      13090          lsl.l     #2,D0
00004654  2983 0800 13091          move.l    D3,0(A4,D0.L)
                    13092   ; y_old                 =  ptcb->OSTCBY;
00004658  2043      13093          move.l    D3,A0
0000465A  1828 0036 13094          move.b    54(A0),D4
                    13095   ; bity_old              =  ptcb->OSTCBBitY;
0000465E  2043      13096          move.l    D3,A0
00004660  1D68 0038 13097          move.b    56(A0),-1(A6)
00004664  FFFF      
                    13098   ; bitx_old              =  ptcb->OSTCBBitX;
00004666  2043      13099          move.l    D3,A0
00004668  1C28 0037 13100          move.b    55(A0),D6
                    13101   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
0000466C  C8BC 0000 13102          and.l     #255,D4
00004670  00FF      
00004672  1033 4800 13103          move.b    0(A3,D4.L),D0
00004676  C006      13104          and.b     D6,D0
00004678  673A      13105          beq.s     OSTaskChangePrio_10
                    13106   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
0000467A  C8BC 0000 13107          and.l     #255,D4
0000467E  00FF      
00004680  1006      13108          move.b    D6,D0
00004682  4600      13109          not.b     D0
00004684  C133 4800 13110          and.b     D0,0(A3,D4.L)
                    13111   ; if (OSRdyTbl[y_old] == 0u) {
00004688  C8BC 0000 13112          and.l     #255,D4
0000468C  00FF      
0000468E  1033 4800 13113          move.b    0(A3,D4.L),D0
00004692  660C      13114          bne.s     OSTaskChangePrio_12
                    13115   ; OSRdyGrp &= (OS_PRIO)~bity_old;
00004694  102E FFFF 13116          move.b    -1(A6),D0
00004698  4600      13117          not.b     D0
0000469A  C139 0800 13118          and.b     D0,_OSRdyGrp.L
0000469E  0D28      
                    13119   OSTaskChangePrio_12:
                    13120   ; }
                    13121   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
000046A0  102E FFFE 13122          move.b    -2(A6),D0
000046A4  8139 0800 13123          or.b      D0,_OSRdyGrp.L
000046A8  0D28      
                    13124   ; OSRdyTbl[y_new] |= bitx_new;
000046AA  CABC 0000 13125          and.l     #255,D5
000046AE  00FF      
000046B0  8F33 5800 13126          or.b      D7,0(A3,D5.L)
                    13127   OSTaskChangePrio_10:
                    13128   ; }
                    13129   ; #if (OS_EVENT_EN)
                    13130   ; pevent = ptcb->OSTCBEventPtr;
000046B4  2043      13131          move.l    D3,A0
000046B6  2428 001C 13132          move.l    28(A0),D2
                    13133   ; if (pevent != (OS_EVENT *)0) {
000046BA  4A82      13134          tst.l     D2
000046BC  6700 0048 13135          beq       OSTaskChangePrio_14
                    13136   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
000046C0  2042      13137          move.l    D2,A0
000046C2  C8BC 0000 13138          and.l     #255,D4
000046C6  00FF      
000046C8  D1C4      13139          add.l     D4,A0
000046CA  1006      13140          move.b    D6,D0
000046CC  4600      13141          not.b     D0
000046CE  C128 000A 13142          and.b     D0,10(A0)
                    13143   ; if (pevent->OSEventTbl[y_old] == 0u) {
000046D2  2042      13144          move.l    D2,A0
000046D4  C8BC 0000 13145          and.l     #255,D4
000046D8  00FF      
000046DA  D1C4      13146          add.l     D4,A0
000046DC  1028 000A 13147          move.b    10(A0),D0
000046E0  660C      13148          bne.s     OSTaskChangePrio_16
                    13149   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000046E2  2042      13150          move.l    D2,A0
000046E4  102E FFFF 13151          move.b    -1(A6),D0
000046E8  4600      13152          not.b     D0
000046EA  C128 0008 13153          and.b     D0,8(A0)
                    13154   OSTaskChangePrio_16:
                    13155   ; }
                    13156   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
000046EE  2042      13157          move.l    D2,A0
000046F0  102E FFFE 13158          move.b    -2(A6),D0
000046F4  8128 0008 13159          or.b      D0,8(A0)
                    13160   ; pevent->OSEventTbl[y_new] |= bitx_new;
000046F8  2042      13161          move.l    D2,A0
000046FA  CABC 0000 13162          and.l     #255,D5
000046FE  00FF      
00004700  D1C5      13163          add.l     D5,A0
00004702  8F28 000A 13164          or.b      D7,10(A0)
                    13165   OSTaskChangePrio_14:
                    13166   ; }
                    13167   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13168   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
00004706  2043      13169          move.l    D3,A0
00004708  2028 0020 13170          move.l    32(A0),D0
0000470C  6700 005C 13171          beq       OSTaskChangePrio_22
                    13172   ; pevents =  ptcb->OSTCBEventMultiPtr;
00004710  2043      13173          move.l    D3,A0
00004712  2468 0020 13174          move.l    32(A0),A2
                    13175   ; pevent  = *pevents;
00004716  2412      13176          move.l    (A2),D2
                    13177   ; while (pevent != (OS_EVENT *)0) {
                    13178   OSTaskChangePrio_20:
00004718  4A82      13179          tst.l     D2
0000471A  6700 004E 13180          beq       OSTaskChangePrio_22
                    13181   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
0000471E  2042      13182          move.l    D2,A0
00004720  C8BC 0000 13183          and.l     #255,D4
00004724  00FF      
00004726  D1C4      13184          add.l     D4,A0
00004728  1006      13185          move.b    D6,D0
0000472A  4600      13186          not.b     D0
0000472C  C128 000A 13187          and.b     D0,10(A0)
                    13188   ; if (pevent->OSEventTbl[y_old] == 0u) {
00004730  2042      13189          move.l    D2,A0
00004732  C8BC 0000 13190          and.l     #255,D4
00004736  00FF      
00004738  D1C4      13191          add.l     D4,A0
0000473A  1028 000A 13192          move.b    10(A0),D0
0000473E  660C      13193          bne.s     OSTaskChangePrio_23
                    13194   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
00004740  2042      13195          move.l    D2,A0
00004742  102E FFFF 13196          move.b    -1(A6),D0
00004746  4600      13197          not.b     D0
00004748  C128 0008 13198          and.b     D0,8(A0)
                    13199   OSTaskChangePrio_23:
                    13200   ; }
                    13201   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
0000474C  2042      13202          move.l    D2,A0
0000474E  102E FFFE 13203          move.b    -2(A6),D0
00004752  8128 0008 13204          or.b      D0,8(A0)
                    13205   ; pevent->OSEventTbl[y_new] |= bitx_new;
00004756  2042      13206          move.l    D2,A0
00004758  CABC 0000 13207          and.l     #255,D5
0000475C  00FF      
0000475E  D1C5      13208          add.l     D5,A0
00004760  8F28 000A 13209          or.b      D7,10(A0)
                    13210   ; pevents++;
00004764  584A      13211          addq.w    #4,A2
                    13212   ; pevent                     = *pevents;
00004766  2412      13213          move.l    (A2),D2
00004768  60AE      13214          bra       OSTaskChangePrio_20
                    13215   OSTaskChangePrio_22:
                    13216   ; }
                    13217   ; }
                    13218   ; #endif
                    13219   ; #endif
                    13220   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
0000476A  2043      13221          move.l    D3,A0
0000476C  116E 000F 13222          move.b    15(A6),52(A0)
00004770  0034      
                    13223   ; ptcb->OSTCBY    = y_new;
00004772  2043      13224          move.l    D3,A0
00004774  1145 0036 13225          move.b    D5,54(A0)
                    13226   ; ptcb->OSTCBX    = x_new;
00004778  2043      13227          move.l    D3,A0
0000477A  116E FFFD 13228          move.b    -3(A6),53(A0)
0000477E  0035      
                    13229   ; ptcb->OSTCBBitY = bity_new;
00004780  2043      13230          move.l    D3,A0
00004782  116E FFFE 13231          move.b    -2(A6),56(A0)
00004786  0038      
                    13232   ; ptcb->OSTCBBitX = bitx_new;
00004788  2043      13233          move.l    D3,A0
0000478A  1147 0037 13234          move.b    D7,55(A0)
                    13235   ; OS_EXIT_CRITICAL();
0000478E  46DF      13236          dc.w      18143
                    13237   ; if (OSRunning == OS_TRUE) {
00004790  1039 0800 13238          move.b    _OSRunning.L,D0
00004794  0D32      
00004796  0C00 0001 13239          cmp.b     #1,D0
0000479A  6604      13240          bne.s     OSTaskChangePrio_25
                    13241   ; OS_Sched();                                         /* Find new highest priority task          */
0000479C  4EB8 190E 13242          jsr       _OS_Sched
                    13243   OSTaskChangePrio_25:
                    13244   ; }
                    13245   ; return (OS_ERR_NONE);
000047A0  4200      13246          clr.b     D0
                    13247   OSTaskChangePrio_3:
000047A2  4CDF 1CFC 13248          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
000047A6  4E5E      13249          unlk      A6
000047A8  4E75      13250          rts
                    13251   ; }
                    13252   ; #endif
                    13253   ; /*$PAGE*/
                    13254   ; /*
                    13255   ; *********************************************************************************************************
                    13256   ; *                                            CREATE A TASK
                    13257   ; *
                    13258   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13259   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13260   ; *              created by an ISR.
                    13261   ; *
                    13262   ; * Arguments  : task     is a pointer to the task's code
                    13263   ; *
                    13264   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    13265   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    13266   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    13267   ; *
                    13268   ; *                           void Task (void *p_arg)
                    13269   ; *                           {
                    13270   ; *                               for (;;) {
                    13271   ; *                                   Task code;
                    13272   ; *                               }
                    13273   ; *                           }
                    13274   ; *
                    13275   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    13276   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13277   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    13278   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    13279   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    13280   ; *                       memory locations.
                    13281   ; *
                    13282   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    13283   ; *                       lower the number, the higher the priority.
                    13284   ; *
                    13285   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13286   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13287   ; *                                               (each task MUST have a unique priority).
                    13288   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13289   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    13290   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13291   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13292   ; *                                               operation started.
                    13293   ; *********************************************************************************************************
                    13294   ; */
                    13295   ; #if OS_TASK_CREATE_EN > 0u
                    13296   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    13297   ; void    *p_arg,
                    13298   ; OS_STK  *ptos,
                    13299   ; INT8U    prio)
                    13300   ; {
                    13301   _OSTaskCreate:
000047AA  4E56 FFFC 13302          link      A6,#-4
000047AE  48E7 3020 13303          movem.l   D2/D3/A2,-(A7)
000047B2  142E 0017 13304          move.b    23(A6),D2
000047B6  C4BC 0000 13305          and.l     #255,D2
000047BA  00FF      
000047BC  45F9 0800 13306          lea       _OSTCBPrioTbl.L,A2
000047C0  0E4A      
                    13307   ; OS_STK     *psp;
                    13308   ; INT8U       err;
                    13309   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13310   ; OS_CPU_SR   cpu_sr = 0u;
                    13311   ; #endif
                    13312   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13313   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13314   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13315   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13316   ; }
                    13317   ; #endif
                    13318   ; #if OS_ARG_CHK_EN > 0u
                    13319   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13320   ; return (OS_ERR_PRIO_INVALID);
                    13321   ; }
                    13322   ; #endif
                    13323   ; OS_ENTER_CRITICAL();
000047C2  40E7      13324          dc.w      16615
000047C4  007C      13325          dc.w      124
000047C6  0700      13326          dc.w      1792
                    13327   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000047C8  1039 0800 13328          move.b    _OSIntNesting.L,D0
000047CC  0D20      
000047CE  0C00 0000 13329          cmp.b     #0,D0
000047D2  6308      13330          bls.s     OSTaskCreate_1
                    13331   ; OS_EXIT_CRITICAL();
000047D4  46DF      13332          dc.w      18143
                    13333   ; return (OS_ERR_TASK_CREATE_ISR);
000047D6  703C      13334          moveq     #60,D0
000047D8  6000 0096 13335          bra       OSTaskCreate_3
                    13336   OSTaskCreate_1:
                    13337   ; }
                    13338   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000047DC  C4BC 0000 13339          and.l     #255,D2
000047E0  00FF      
000047E2  2002      13340          move.l    D2,D0
000047E4  E588      13341          lsl.l     #2,D0
000047E6  2032 0800 13342          move.l    0(A2,D0.L),D0
000047EA  6600 0080 13343          bne       OSTaskCreate_4
                    13344   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000047EE  C4BC 0000 13345          and.l     #255,D2
000047F2  00FF      
000047F4  2002      13346          move.l    D2,D0
000047F6  E588      13347          lsl.l     #2,D0
000047F8  25BC 0000 13348          move.l    #1,0(A2,D0.L)
000047FC  0001 0800 
                    13349   ; /* ... the same thing until task is created.              */
                    13350   ; OS_EXIT_CRITICAL();
00004800  46DF      13351          dc.w      18143
                    13352   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
00004802  42A7      13353          clr.l     -(A7)
00004804  2F2E 0010 13354          move.l    16(A6),-(A7)
00004808  2F2E 000C 13355          move.l    12(A6),-(A7)
0000480C  2F2E 0008 13356          move.l    8(A6),-(A7)
00004810  4EB8 0B10 13357          jsr       _OSTaskStkInit
00004814  DEFC 0010 13358          add.w     #16,A7
00004818  2D40 FFFC 13359          move.l    D0,-4(A6)
                    13360   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
0000481C  42A7      13361          clr.l     -(A7)
0000481E  42A7      13362          clr.l     -(A7)
00004820  42A7      13363          clr.l     -(A7)
00004822  42A7      13364          clr.l     -(A7)
00004824  42A7      13365          clr.l     -(A7)
00004826  2F2E FFFC 13366          move.l    -4(A6),-(A7)
0000482A  C4BC 0000 13367          and.l     #255,D2
0000482E  00FF      
00004830  2F02      13368          move.l    D2,-(A7)
00004832  4EB8 1B28 13369          jsr       _OS_TCBInit
00004836  DEFC 001C 13370          add.w     #28,A7
0000483A  1600      13371          move.b    D0,D3
                    13372   ; if (err == OS_ERR_NONE) {
0000483C  4A03      13373          tst.b     D3
0000483E  6612      13374          bne.s     OSTaskCreate_6
                    13375   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
00004840  1039 0800 13376          move.b    _OSRunning.L,D0
00004844  0D32      
00004846  0C00 0001 13377          cmp.b     #1,D0
0000484A  6604      13378          bne.s     OSTaskCreate_8
                    13379   ; OS_Sched();
0000484C  4EB8 190E 13380          jsr       _OS_Sched
                    13381   OSTaskCreate_8:
00004850  6016      13382          bra.s     OSTaskCreate_7
                    13383   OSTaskCreate_6:
                    13384   ; }
                    13385   ; } else {
                    13386   ; OS_ENTER_CRITICAL();
00004852  40E7      13387          dc.w      16615
00004854  007C      13388          dc.w      124
00004856  0700      13389          dc.w      1792
                    13390   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00004858  C4BC 0000 13391          and.l     #255,D2
0000485C  00FF      
0000485E  2002      13392          move.l    D2,D0
00004860  E588      13393          lsl.l     #2,D0
00004862  42B2 0800 13394          clr.l     0(A2,D0.L)
                    13395   ; OS_EXIT_CRITICAL();
00004866  46DF      13396          dc.w      18143
                    13397   OSTaskCreate_7:
                    13398   ; }
                    13399   ; return (err);
00004868  1003      13400          move.b    D3,D0
0000486A  6004      13401          bra.s     OSTaskCreate_3
                    13402   OSTaskCreate_4:
                    13403   ; }
                    13404   ; OS_EXIT_CRITICAL();
0000486C  46DF      13405          dc.w      18143
                    13406   ; return (OS_ERR_PRIO_EXIST);
0000486E  7028      13407          moveq     #40,D0
                    13408   OSTaskCreate_3:
00004870  4CDF 040C 13409          movem.l   (A7)+,D2/D3/A2
00004874  4E5E      13410          unlk      A6
00004876  4E75      13411          rts
                    13412   ; }
                    13413   ; #endif
                    13414   ; /*$PAGE*/
                    13415   ; /*
                    13416   ; *********************************************************************************************************
                    13417   ; *                                  CREATE A TASK (Extended Version)
                    13418   ; *
                    13419   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13420   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13421   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13422   ; *              additional information about a task to be specified.
                    13423   ; *
                    13424   ; * Arguments  : task      is a pointer to the task's code
                    13425   ; *
                    13426   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13427   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13428   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13429   ; *
                    13430   ; *                            void Task (void *p_arg)
                    13431   ; *                            {
                    13432   ; *                                for (;;) {
                    13433   ; *                                    Task code;
                    13434   ; *                                }
                    13435   ; *                            }
                    13436   ; *
                    13437   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13438   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13439   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13440   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13441   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13442   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13443   ; *
                    13444   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13445   ; *                        lower the number, the higher the priority.
                    13446   ; *
                    13447   ; *              id        is the task's ID (0..65535)
                    13448   ; *
                    13449   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13450   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13451   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13452   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13453   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13454   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13455   ; *
                    13456   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13457   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13458   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13459   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13460   ; *                        available on the stack.
                    13461   ; *
                    13462   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13463   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13464   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13465   ; *                        the task has been switched-in, etc.
                    13466   ; *
                    13467   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13468   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13469   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13470   ; *
                    13471   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13472   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13473   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13474   ; *                                                 during a context switch.
                    13475   ; *
                    13476   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13477   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13478   ; *                                               (each task MUST have a unique priority).
                    13479   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13480   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13481   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13482   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13483   ; *                                               operation started.
                    13484   ; *********************************************************************************************************
                    13485   ; */
                    13486   ; /*$PAGE*/
                    13487   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13488   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13489   ; void    *p_arg,
                    13490   ; OS_STK  *ptos,
                    13491   ; INT8U    prio,
                    13492   ; INT16U   id,
                    13493   ; OS_STK  *pbos,
                    13494   ; INT32U   stk_size,
                    13495   ; void    *pext,
                    13496   ; INT16U   opt)
                    13497   ; {
                    13498   _OSTaskCreateExt:
00004878  4E56 FFFC 13499          link      A6,#-4
0000487C  48E7 3820 13500          movem.l   D2/D3/D4/A2,-(A7)
00004880  142E 0017 13501          move.b    23(A6),D2
00004884  C4BC 0000 13502          and.l     #255,D2
00004888  00FF      
0000488A  382E 002A 13503          move.w    42(A6),D4
0000488E  C8BC 0000 13504          and.l     #65535,D4
00004892  FFFF      
00004894  45F9 0800 13505          lea       _OSTCBPrioTbl.L,A2
00004898  0E4A      
                    13506   ; OS_STK     *psp;
                    13507   ; INT8U       err;
                    13508   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13509   ; OS_CPU_SR   cpu_sr = 0u;
                    13510   ; #endif
                    13511   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13512   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13513   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13514   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13515   ; }
                    13516   ; #endif
                    13517   ; #if OS_ARG_CHK_EN > 0u
                    13518   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13519   ; return (OS_ERR_PRIO_INVALID);
                    13520   ; }
                    13521   ; #endif
                    13522   ; OS_ENTER_CRITICAL();
0000489A  40E7      13523          dc.w      16615
0000489C  007C      13524          dc.w      124
0000489E  0700      13525          dc.w      1792
                    13526   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000048A0  1039 0800 13527          move.b    _OSIntNesting.L,D0
000048A4  0D20      
000048A6  0C00 0000 13528          cmp.b     #0,D0
000048AA  6308      13529          bls.s     OSTaskCreateExt_1
                    13530   ; OS_EXIT_CRITICAL();
000048AC  46DF      13531          dc.w      18143
                    13532   ; return (OS_ERR_TASK_CREATE_ISR);
000048AE  703C      13533          moveq     #60,D0
000048B0  6000 00CC 13534          bra       OSTaskCreateExt_3
                    13535   OSTaskCreateExt_1:
                    13536   ; }
                    13537   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000048B4  C4BC 0000 13538          and.l     #255,D2
000048B8  00FF      
000048BA  2002      13539          move.l    D2,D0
000048BC  E588      13540          lsl.l     #2,D0
000048BE  2032 0800 13541          move.l    0(A2,D0.L),D0
000048C2  6600 00B6 13542          bne       OSTaskCreateExt_4
                    13543   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000048C6  C4BC 0000 13544          and.l     #255,D2
000048CA  00FF      
000048CC  2002      13545          move.l    D2,D0
000048CE  E588      13546          lsl.l     #2,D0
000048D0  25BC 0000 13547          move.l    #1,0(A2,D0.L)
000048D4  0001 0800 
                    13548   ; /* ... the same thing until task is created.              */
                    13549   ; OS_EXIT_CRITICAL();
000048D8  46DF      13550          dc.w      18143
                    13551   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13552   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
000048DA  C8BC 0000 13553          and.l     #65535,D4
000048DE  FFFF      
000048E0  2F04      13554          move.l    D4,-(A7)
000048E2  2F2E 0020 13555          move.l    32(A6),-(A7)
000048E6  2F2E 001C 13556          move.l    28(A6),-(A7)
000048EA  4EB9 0000 13557          jsr       _OS_TaskStkClr
000048EE  50D2      
000048F0  DEFC 000C 13558          add.w     #12,A7
                    13559   ; #endif
                    13560   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
000048F4  C8BC 0000 13561          and.l     #65535,D4
000048F8  FFFF      
000048FA  2F04      13562          move.l    D4,-(A7)
000048FC  2F2E 0010 13563          move.l    16(A6),-(A7)
00004900  2F2E 000C 13564          move.l    12(A6),-(A7)
00004904  2F2E 0008 13565          move.l    8(A6),-(A7)
00004908  4EB8 0B10 13566          jsr       _OSTaskStkInit
0000490C  DEFC 0010 13567          add.w     #16,A7
00004910  2D40 FFFC 13568          move.l    D0,-4(A6)
                    13569   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
00004914  C8BC 0000 13570          and.l     #65535,D4
00004918  FFFF      
0000491A  2F04      13571          move.l    D4,-(A7)
0000491C  2F2E 0024 13572          move.l    36(A6),-(A7)
00004920  2F2E 0020 13573          move.l    32(A6),-(A7)
00004924  322E 001A 13574          move.w    26(A6),D1
00004928  C2BC 0000 13575          and.l     #65535,D1
0000492C  FFFF      
0000492E  2F01      13576          move.l    D1,-(A7)
00004930  2F2E 001C 13577          move.l    28(A6),-(A7)
00004934  2F2E FFFC 13578          move.l    -4(A6),-(A7)
00004938  C4BC 0000 13579          and.l     #255,D2
0000493C  00FF      
0000493E  2F02      13580          move.l    D2,-(A7)
00004940  4EB8 1B28 13581          jsr       _OS_TCBInit
00004944  DEFC 001C 13582          add.w     #28,A7
00004948  1600      13583          move.b    D0,D3
                    13584   ; if (err == OS_ERR_NONE) {
0000494A  4A03      13585          tst.b     D3
0000494C  6612      13586          bne.s     OSTaskCreateExt_6
                    13587   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
0000494E  1039 0800 13588          move.b    _OSRunning.L,D0
00004952  0D32      
00004954  0C00 0001 13589          cmp.b     #1,D0
00004958  6604      13590          bne.s     OSTaskCreateExt_8
                    13591   ; OS_Sched();
0000495A  4EB8 190E 13592          jsr       _OS_Sched
                    13593   OSTaskCreateExt_8:
0000495E  6016      13594          bra.s     OSTaskCreateExt_7
                    13595   OSTaskCreateExt_6:
                    13596   ; }
                    13597   ; } else {
                    13598   ; OS_ENTER_CRITICAL();
00004960  40E7      13599          dc.w      16615
00004962  007C      13600          dc.w      124
00004964  0700      13601          dc.w      1792
                    13602   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
00004966  C4BC 0000 13603          and.l     #255,D2
0000496A  00FF      
0000496C  2002      13604          move.l    D2,D0
0000496E  E588      13605          lsl.l     #2,D0
00004970  42B2 0800 13606          clr.l     0(A2,D0.L)
                    13607   ; OS_EXIT_CRITICAL();
00004974  46DF      13608          dc.w      18143
                    13609   OSTaskCreateExt_7:
                    13610   ; }
                    13611   ; return (err);
00004976  1003      13612          move.b    D3,D0
00004978  6004      13613          bra.s     OSTaskCreateExt_3
                    13614   OSTaskCreateExt_4:
                    13615   ; }
                    13616   ; OS_EXIT_CRITICAL();
0000497A  46DF      13617          dc.w      18143
                    13618   ; return (OS_ERR_PRIO_EXIST);
0000497C  7028      13619          moveq     #40,D0
                    13620   OSTaskCreateExt_3:
0000497E  4CDF 041C 13621          movem.l   (A7)+,D2/D3/D4/A2
00004982  4E5E      13622          unlk      A6
00004984  4E75      13623          rts
                    13624   ; }
                    13625   ; #endif
                    13626   ; /*$PAGE*/
                    13627   ; /*
                    13628   ; *********************************************************************************************************
                    13629   ; *                                            DELETE A TASK
                    13630   ; *
                    13631   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13632   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13633   ; *              re-activated by creating the deleted task again.
                    13634   ; *
                    13635   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13636   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13637   ; *                      OS_PRIO_SELF.
                    13638   ; *
                    13639   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13640   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13641   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13642   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13643   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13644   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13645   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13646   ; *
                    13647   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13648   ; *                    a) by making it not ready
                    13649   ; *                    b) by removing it from any wait lists
                    13650   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13651   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13652   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13653   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13654   ; *              3) An ISR cannot delete a task.
                    13655   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13656   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13657   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13658   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13659   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13660   ; *********************************************************************************************************
                    13661   ; */
                    13662   ; #if OS_TASK_DEL_EN > 0u
                    13663   ; INT8U  OSTaskDel (INT8U prio)
                    13664   ; {
                    13665   _OSTaskDel:
00004986  4E56 0000 13666          link      A6,#0
0000498A  48E7 3800 13667          movem.l   D2/D3/D4,-(A7)
0000498E  162E 000B 13668          move.b    11(A6),D3
00004992  C6BC 0000 13669          and.l     #255,D3
00004996  00FF      
                    13670   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13671   ; OS_FLAG_NODE *pnode;
                    13672   ; #endif
                    13673   ; OS_TCB       *ptcb;
                    13674   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13675   ; OS_CPU_SR     cpu_sr = 0u;
                    13676   ; #endif
                    13677   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
00004998  1039 0800 13678          move.b    _OSIntNesting.L,D0
0000499C  0D20      
0000499E  0C00 0000 13679          cmp.b     #0,D0
000049A2  6306      13680          bls.s     OSTaskDel_1
                    13681   ; return (OS_ERR_TASK_DEL_ISR);
000049A4  7040      13682          moveq     #64,D0
000049A6  6000 01A4 13683          bra       OSTaskDel_3
                    13684   OSTaskDel_1:
                    13685   ; }
                    13686   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
000049AA  0C03 003F 13687          cmp.b     #63,D3
000049AE  6606      13688          bne.s     OSTaskDel_4
                    13689   ; return (OS_ERR_TASK_DEL_IDLE);
000049B0  703E      13690          moveq     #62,D0
000049B2  6000 0198 13691          bra       OSTaskDel_3
                    13692   OSTaskDel_4:
                    13693   ; }
                    13694   ; #if OS_ARG_CHK_EN > 0u
                    13695   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13696   ; if (prio != OS_PRIO_SELF) {
                    13697   ; return (OS_ERR_PRIO_INVALID);
                    13698   ; }
                    13699   ; }
                    13700   ; #endif
                    13701   ; /*$PAGE*/
                    13702   ; OS_ENTER_CRITICAL();
000049B6  40E7      13703          dc.w      16615
000049B8  007C      13704          dc.w      124
000049BA  0700      13705          dc.w      1792
                    13706   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
000049BC  0C03 00FF 13707          cmp.b     #255,D3
000049C0  660A      13708          bne.s     OSTaskDel_6
                    13709   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
000049C2  2079 0800 13710          move.l    _OSTCBCur.L,A0
000049C6  0E3A      
000049C8  1628 0034 13711          move.b    52(A0),D3
                    13712   OSTaskDel_6:
                    13713   ; }
                    13714   ; ptcb = OSTCBPrioTbl[prio];
000049CC  C6BC 0000 13715          and.l     #255,D3
000049D0  00FF      
000049D2  2003      13716          move.l    D3,D0
000049D4  E588      13717          lsl.l     #2,D0
000049D6  41F9 0800 13718          lea       _OSTCBPrioTbl.L,A0
000049DA  0E4A      
000049DC  2430 0800 13719          move.l    0(A0,D0.L),D2
                    13720   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
000049E0  4A82      13721          tst.l     D2
000049E2  6608      13722          bne.s     OSTaskDel_8
                    13723   ; OS_EXIT_CRITICAL();
000049E4  46DF      13724          dc.w      18143
                    13725   ; return (OS_ERR_TASK_NOT_EXIST);
000049E6  7043      13726          moveq     #67,D0
000049E8  6000 0162 13727          bra       OSTaskDel_3
                    13728   OSTaskDel_8:
                    13729   ; }
                    13730   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
000049EC  0C82 0000 13731          cmp.l     #1,D2
000049F0  0001      
000049F2  6608      13732          bne.s     OSTaskDel_10
                    13733   ; OS_EXIT_CRITICAL();
000049F4  46DF      13734          dc.w      18143
                    13735   ; return (OS_ERR_TASK_DEL);
000049F6  703D      13736          moveq     #61,D0
000049F8  6000 0152 13737          bra       OSTaskDel_3
                    13738   OSTaskDel_10:
                    13739   ; }
                    13740   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
000049FC  2042      13741          move.l    D2,A0
000049FE  1028 0036 13742          move.b    54(A0),D0
00004A02  C0BC 0000 13743          and.l     #255,D0
00004A06  00FF      
00004A08  41F9 0800 13744          lea       _OSRdyTbl.L,A0
00004A0C  0D2A      
00004A0E  2242      13745          move.l    D2,A1
00004A10  1229 0037 13746          move.b    55(A1),D1
00004A14  4601      13747          not.b     D1
00004A16  C330 0800 13748          and.b     D1,0(A0,D0.L)
                    13749   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
00004A1A  2042      13750          move.l    D2,A0
00004A1C  1028 0036 13751          move.b    54(A0),D0
00004A20  C0BC 0000 13752          and.l     #255,D0
00004A24  00FF      
00004A26  41F9 0800 13753          lea       _OSRdyTbl.L,A0
00004A2A  0D2A      
00004A2C  1030 0800 13754          move.b    0(A0,D0.L),D0
00004A30  660E      13755          bne.s     OSTaskDel_12
                    13756   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
00004A32  2042      13757          move.l    D2,A0
00004A34  1028 0038 13758          move.b    56(A0),D0
00004A38  4600      13759          not.b     D0
00004A3A  C139 0800 13760          and.b     D0,_OSRdyGrp.L
00004A3E  0D28      
                    13761   OSTaskDel_12:
                    13762   ; }
                    13763   ; #if (OS_EVENT_EN)
                    13764   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
00004A40  2042      13765          move.l    D2,A0
00004A42  2028 001C 13766          move.l    28(A0),D0
00004A46  670E      13767          beq.s     OSTaskDel_14
                    13768   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
00004A48  2042      13769          move.l    D2,A0
00004A4A  2F28 001C 13770          move.l    28(A0),-(A7)
00004A4E  2F02      13771          move.l    D2,-(A7)
00004A50  4EB8 1534 13772          jsr       _OS_EventTaskRemove
00004A54  504F      13773          addq.w    #8,A7
                    13774   OSTaskDel_14:
                    13775   ; }
                    13776   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13777   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
00004A56  2042      13778          move.l    D2,A0
00004A58  2028 0020 13779          move.l    32(A0),D0
00004A5C  670E      13780          beq.s     OSTaskDel_16
                    13781   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00004A5E  2042      13782          move.l    D2,A0
00004A60  2F28 0020 13783          move.l    32(A0),-(A7)
00004A64  2F02      13784          move.l    D2,-(A7)
00004A66  4EB8 1586 13785          jsr       _OS_EventTaskRemoveMulti
00004A6A  504F      13786          addq.w    #8,A7
                    13787   OSTaskDel_16:
                    13788   ; }
                    13789   ; #endif
                    13790   ; #endif
                    13791   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13792   ; pnode = ptcb->OSTCBFlagNode;
00004A6C  2042      13793          move.l    D2,A0
00004A6E  2828 0028 13794          move.l    40(A0),D4
                    13795   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
00004A72  4A84      13796          tst.l     D4
00004A74  6708      13797          beq.s     OSTaskDel_18
                    13798   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00004A76  2F04      13799          move.l    D4,-(A7)
00004A78  4EB8 273E 13800          jsr       _OS_FlagUnlink
00004A7C  584F      13801          addq.w    #4,A7
                    13802   OSTaskDel_18:
                    13803   ; }
                    13804   ; #endif
                    13805   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
00004A7E  2042      13806          move.l    D2,A0
00004A80  42A8 002E 13807          clr.l     46(A0)
                    13808   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
00004A84  2042      13809          move.l    D2,A0
00004A86  4228 0032 13810          clr.b     50(A0)
                    13811   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004A8A  2042      13812          move.l    D2,A0
00004A8C  4228 0033 13813          clr.b     51(A0)
                    13814   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
00004A90  1039 0800 13815          move.b    _OSLockNesting.L,D0
00004A94  0D22      
00004A96  0C00 00FF 13816          cmp.b     #255,D0
00004A9A  6406      13817          bhs.s     OSTaskDel_20
                    13818   ; OSLockNesting++;
00004A9C  5239 0800 13819          addq.b    #1,_OSLockNesting.L
00004AA0  0D22      
                    13820   OSTaskDel_20:
                    13821   ; }
                    13822   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
00004AA2  46DF      13823          dc.w      18143
                    13824   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
00004AA4  4EB8 132C 13825          jsr       _OS_Dummy
                    13826   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00004AA8  40E7      13827          dc.w      16615
00004AAA  007C      13828          dc.w      124
00004AAC  0700      13829          dc.w      1792
                    13830   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
00004AAE  1039 0800 13831          move.b    _OSLockNesting.L,D0
00004AB2  0D22      
00004AB4  0C00 0000 13832          cmp.b     #0,D0
00004AB8  6306      13833          bls.s     OSTaskDel_22
                    13834   ; OSLockNesting--;
00004ABA  5339 0800 13835          subq.b    #1,_OSLockNesting.L
00004ABE  0D22      
                    13836   OSTaskDel_22:
                    13837   ; }
                    13838   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
00004AC0  2F02      13839          move.l    D2,-(A7)
00004AC2  4EB8 0BFA 13840          jsr       _OSTaskDelHook
00004AC6  584F      13841          addq.w    #4,A7
                    13842   ; OSTaskCtr--;                                        /* One less task being managed                 */
00004AC8  5339 0800 13843          subq.b    #1,_OSTaskCtr.L
00004ACC  0D34      
                    13844   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
00004ACE  C6BC 0000 13845          and.l     #255,D3
00004AD2  00FF      
00004AD4  2003      13846          move.l    D3,D0
00004AD6  E588      13847          lsl.l     #2,D0
00004AD8  41F9 0800 13848          lea       _OSTCBPrioTbl.L,A0
00004ADC  0E4A      
00004ADE  42B0 0800 13849          clr.l     0(A0,D0.L)
                    13850   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
00004AE2  2042      13851          move.l    D2,A0
00004AE4  2028 0018 13852          move.l    24(A0),D0
00004AE8  6616      13853          bne.s     OSTaskDel_24
                    13854   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
00004AEA  2042      13855          move.l    D2,A0
00004AEC  2068 0014 13856          move.l    20(A0),A0
00004AF0  42A8 0018 13857          clr.l     24(A0)
                    13858   ; OSTCBList                  = ptcb->OSTCBNext;
00004AF4  2042      13859          move.l    D2,A0
00004AF6  23E8 0014 13860          move.l    20(A0),_OSTCBList.L
00004AFA  0800 0E46 
00004AFE  601C      13861          bra.s     OSTaskDel_25
                    13862   OSTaskDel_24:
                    13863   ; } else {
                    13864   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
00004B00  2042      13865          move.l    D2,A0
00004B02  2242      13866          move.l    D2,A1
00004B04  2269 0018 13867          move.l    24(A1),A1
00004B08  2368 0014 13868          move.l    20(A0),20(A1)
00004B0C  0014      
                    13869   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
00004B0E  2042      13870          move.l    D2,A0
00004B10  2242      13871          move.l    D2,A1
00004B12  2269 0014 13872          move.l    20(A1),A1
00004B16  2368 0018 13873          move.l    24(A0),24(A1)
00004B1A  0018      
                    13874   OSTaskDel_25:
                    13875   ; }
                    13876   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
00004B1C  2042      13877          move.l    D2,A0
00004B1E  2179 0800 13878          move.l    _OSTCBFreeList.L,20(A0)
00004B22  0E3E 0014 
                    13879   ; OSTCBFreeList       = ptcb;
00004B26  23C2 0800 13880          move.l    D2,_OSTCBFreeList.L
00004B2A  0E3E      
                    13881   ; #if OS_TASK_NAME_EN > 0u
                    13882   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
00004B2C  41F9 0000 13883          lea       @ucos_ii_1.L,A0
00004B30  6F2A      
00004B32  2242      13884          move.l    D2,A1
00004B34  2348 004E 13885          move.l    A0,78(A1)
                    13886   ; #endif
                    13887   ; OS_EXIT_CRITICAL();
00004B38  46DF      13888          dc.w      18143
                    13889   ; if (OSRunning == OS_TRUE) {
00004B3A  1039 0800 13890          move.b    _OSRunning.L,D0
00004B3E  0D32      
00004B40  0C00 0001 13891          cmp.b     #1,D0
00004B44  6604      13892          bne.s     OSTaskDel_26
                    13893   ; OS_Sched();                                     /* Find new highest priority task              */
00004B46  4EB8 190E 13894          jsr       _OS_Sched
                    13895   OSTaskDel_26:
                    13896   ; }
                    13897   ; return (OS_ERR_NONE);
00004B4A  4200      13898          clr.b     D0
                    13899   OSTaskDel_3:
00004B4C  4CDF 001C 13900          movem.l   (A7)+,D2/D3/D4
00004B50  4E5E      13901          unlk      A6
00004B52  4E75      13902          rts
                    13903   ; }
                    13904   ; #endif
                    13905   ; /*$PAGE*/
                    13906   ; /*
                    13907   ; *********************************************************************************************************
                    13908   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13909   ; *
                    13910   ; * Description: This function is used to:
                    13911   ; *                   a) notify a task to delete itself.
                    13912   ; *                   b) to see if a task requested that the current task delete itself.
                    13913   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13914   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13915   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13916   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13917   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13918   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13919   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13920   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13921   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13922   ; *              this:
                    13923   ; *
                    13924   ; *                   void Task(void *p_arg)
                    13925   ; *                   {
                    13926   ; *                       .
                    13927   ; *                       .
                    13928   ; *                       while (1) {
                    13929   ; *                           OSTimeDly(1);
                    13930   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13931   ; *                               Release any owned resources;
                    13932   ; *                               De-allocate any dynamic memory;
                    13933   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13934   ; *                           }
                    13935   ; *                       }
                    13936   ; *                   }
                    13937   ; *
                    13938   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13939   ; *
                    13940   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13941   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13942   ; *                                     the request has been executed.
                    13943   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13944   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13945   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13946   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13947   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13948   ; *                                     deleted.
                    13949   ; *********************************************************************************************************
                    13950   ; */
                    13951   ; /*$PAGE*/
                    13952   ; #if OS_TASK_DEL_EN > 0u
                    13953   ; INT8U  OSTaskDelReq (INT8U prio)
                    13954   ; {
                    13955   _OSTaskDelReq:
00004B54  4E56 FFFC 13956          link      A6,#-4
00004B58  48E7 3000 13957          movem.l   D2/D3,-(A7)
00004B5C  162E 000B 13958          move.b    11(A6),D3
00004B60  C6BC 0000 13959          and.l     #255,D3
00004B64  00FF      
                    13960   ; INT8U      stat;
                    13961   ; OS_TCB    *ptcb;
                    13962   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13963   ; OS_CPU_SR  cpu_sr = 0u;
                    13964   ; #endif
                    13965   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004B66  0C03 003F 13966          cmp.b     #63,D3
00004B6A  6606      13967          bne.s     OSTaskDelReq_1
                    13968   ; return (OS_ERR_TASK_DEL_IDLE);
00004B6C  703E      13969          moveq     #62,D0
00004B6E  6000 0062 13970          bra       OSTaskDelReq_3
                    13971   OSTaskDelReq_1:
                    13972   ; }
                    13973   ; #if OS_ARG_CHK_EN > 0u
                    13974   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13975   ; if (prio != OS_PRIO_SELF) {
                    13976   ; return (OS_ERR_PRIO_INVALID);
                    13977   ; }
                    13978   ; }
                    13979   ; #endif
                    13980   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
00004B72  0C03 00FF 13981          cmp.b     #255,D3
00004B76  661C      13982          bne.s     OSTaskDelReq_4
                    13983   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004B78  40E7      13984          dc.w      16615
00004B7A  007C      13985          dc.w      124
00004B7C  0700      13986          dc.w      1792
                    13987   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
00004B7E  2079 0800 13988          move.l    _OSTCBCur.L,A0
00004B82  0E3A      
00004B84  1D68 0039 13989          move.b    57(A0),-1(A6)
00004B88  FFFF      
                    13990   ; OS_EXIT_CRITICAL();
00004B8A  46DF      13991          dc.w      18143
                    13992   ; return (stat);
00004B8C  102E FFFF 13993          move.b    -1(A6),D0
00004B90  6000 0040 13994          bra       OSTaskDelReq_3
                    13995   OSTaskDelReq_4:
                    13996   ; }
                    13997   ; OS_ENTER_CRITICAL();
00004B94  40E7      13998          dc.w      16615
00004B96  007C      13999          dc.w      124
00004B98  0700      14000          dc.w      1792
                    14001   ; ptcb = OSTCBPrioTbl[prio];
00004B9A  C6BC 0000 14002          and.l     #255,D3
00004B9E  00FF      
00004BA0  2003      14003          move.l    D3,D0
00004BA2  E588      14004          lsl.l     #2,D0
00004BA4  41F9 0800 14005          lea       _OSTCBPrioTbl.L,A0
00004BA8  0E4A      
00004BAA  2430 0800 14006          move.l    0(A0,D0.L),D2
                    14007   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00004BAE  4A82      14008          tst.l     D2
00004BB0  6606      14009          bne.s     OSTaskDelReq_6
                    14010   ; OS_EXIT_CRITICAL();
00004BB2  46DF      14011          dc.w      18143
                    14012   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
00004BB4  7043      14013          moveq     #67,D0
00004BB6  601A      14014          bra.s     OSTaskDelReq_3
                    14015   OSTaskDelReq_6:
                    14016   ; }
                    14017   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00004BB8  0C82 0000 14018          cmp.l     #1,D2
00004BBC  0001      
00004BBE  6606      14019          bne.s     OSTaskDelReq_8
                    14020   ; OS_EXIT_CRITICAL();
00004BC0  46DF      14021          dc.w      18143
                    14022   ; return (OS_ERR_TASK_DEL);
00004BC2  703D      14023          moveq     #61,D0
00004BC4  600C      14024          bra.s     OSTaskDelReq_3
                    14025   OSTaskDelReq_8:
                    14026   ; }
                    14027   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00004BC6  2042      14028          move.l    D2,A0
00004BC8  117C 003F 14029          move.b    #63,57(A0)
00004BCC  0039      
                    14030   ; OS_EXIT_CRITICAL();
00004BCE  46DF      14031          dc.w      18143
                    14032   ; return (OS_ERR_NONE);
00004BD0  4200      14033          clr.b     D0
                    14034   OSTaskDelReq_3:
00004BD2  4CDF 000C 14035          movem.l   (A7)+,D2/D3
00004BD6  4E5E      14036          unlk      A6
00004BD8  4E75      14037          rts
                    14038   ; }
                    14039   ; #endif
                    14040   ; /*$PAGE*/
                    14041   ; /*
                    14042   ; *********************************************************************************************************
                    14043   ; *                                       GET THE NAME OF A TASK
                    14044   ; *
                    14045   ; * Description: This function is called to obtain the name of a task.
                    14046   ; *
                    14047   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    14048   ; *
                    14049   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    14050   ; *
                    14051   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    14052   ; *
                    14053   ; *                        OS_ERR_NONE                if the requested task is resumed
                    14054   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    14055   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    14056   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    14057   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    14058   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    14059   ; *
                    14060   ; *
                    14061   ; * Returns    : The length of the string or 0 if the task does not exist.
                    14062   ; *********************************************************************************************************
                    14063   ; */
                    14064   ; #if OS_TASK_NAME_EN > 0u
                    14065   ; INT8U  OSTaskNameGet (INT8U    prio,
                    14066   ; INT8U  **pname,
                    14067   ; INT8U   *perr)
                    14068   ; {
                    14069   _OSTaskNameGet:
00004BDA  4E56 FFFC 14070          link      A6,#-4
00004BDE  48E7 3800 14071          movem.l   D2/D3/D4,-(A7)
00004BE2  262E 0010 14072          move.l    16(A6),D3
00004BE6  182E 000B 14073          move.b    11(A6),D4
00004BEA  C8BC 0000 14074          and.l     #255,D4
00004BEE  00FF      
                    14075   ; OS_TCB    *ptcb;
                    14076   ; INT8U      len;
                    14077   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    14078   ; OS_CPU_SR  cpu_sr = 0u;
                    14079   ; #endif
                    14080   ; #ifdef OS_SAFETY_CRITICAL
                    14081   ; if (perr == (INT8U *)0) {
                    14082   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14083   ; return (0u);
                    14084   ; }
                    14085   ; #endif
                    14086   ; #if OS_ARG_CHK_EN > 0u
                    14087   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    14088   ; if (prio != OS_PRIO_SELF) {
                    14089   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    14090   ; return (0u);
                    14091   ; }
                    14092   ; }
                    14093   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    14094   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    14095   ; return (0u);
                    14096   ; }
                    14097   ; #endif
                    14098   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00004BF0  1039 0800 14099          move.b    _OSIntNesting.L,D0
00004BF4  0D20      
00004BF6  0C00 0000 14100          cmp.b     #0,D0
00004BFA  630C      14101          bls.s     OSTaskNameGet_1
                    14102   ; *perr = OS_ERR_NAME_GET_ISR;
00004BFC  2043      14103          move.l    D3,A0
00004BFE  10BC 0011 14104          move.b    #17,(A0)
                    14105   ; return (0u);
00004C02  4200      14106          clr.b     D0
00004C04  6000 0076 14107          bra       OSTaskNameGet_3
                    14108   OSTaskNameGet_1:
                    14109   ; }
                    14110   ; OS_ENTER_CRITICAL();
00004C08  40E7      14111          dc.w      16615
00004C0A  007C      14112          dc.w      124
00004C0C  0700      14113          dc.w      1792
                    14114   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
00004C0E  0C04 00FF 14115          cmp.b     #255,D4
00004C12  660A      14116          bne.s     OSTaskNameGet_4
                    14117   ; prio = OSTCBCur->OSTCBPrio;
00004C14  2079 0800 14118          move.l    _OSTCBCur.L,A0
00004C18  0E3A      
00004C1A  1828 0034 14119          move.b    52(A0),D4
                    14120   OSTaskNameGet_4:
                    14121   ; }
                    14122   ; ptcb = OSTCBPrioTbl[prio];
00004C1E  C8BC 0000 14123          and.l     #255,D4
00004C22  00FF      
00004C24  2004      14124          move.l    D4,D0
00004C26  E588      14125          lsl.l     #2,D0
00004C28  41F9 0800 14126          lea       _OSTCBPrioTbl.L,A0
00004C2C  0E4A      
00004C2E  2430 0800 14127          move.l    0(A0,D0.L),D2
                    14128   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
00004C32  4A82      14129          tst.l     D2
00004C34  660E      14130          bne.s     OSTaskNameGet_6
                    14131   ; OS_EXIT_CRITICAL();                              /* No                                         */
00004C36  46DF      14132          dc.w      18143
                    14133   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004C38  2043      14134          move.l    D3,A0
00004C3A  10BC 0043 14135          move.b    #67,(A0)
                    14136   ; return (0u);
00004C3E  4200      14137          clr.b     D0
00004C40  6000 003A 14138          bra       OSTaskNameGet_3
                    14139   OSTaskNameGet_6:
                    14140   ; }
                    14141   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
00004C44  0C82 0000 14142          cmp.l     #1,D2
00004C48  0001      
00004C4A  660C      14143          bne.s     OSTaskNameGet_8
                    14144   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
00004C4C  46DF      14145          dc.w      18143
                    14146   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004C4E  2043      14147          move.l    D3,A0
00004C50  10BC 0043 14148          move.b    #67,(A0)
                    14149   ; return (0u);
00004C54  4200      14150          clr.b     D0
00004C56  6024      14151          bra.s     OSTaskNameGet_3
                    14152   OSTaskNameGet_8:
                    14153   ; }
                    14154   ; *pname = ptcb->OSTCBTaskName;
00004C58  2042      14155          move.l    D2,A0
00004C5A  226E 000C 14156          move.l    12(A6),A1
00004C5E  22A8 004E 14157          move.l    78(A0),(A1)
                    14158   ; len    = OS_StrLen(*pname);
00004C62  206E 000C 14159          move.l    12(A6),A0
00004C66  2F10      14160          move.l    (A0),-(A7)
00004C68  4EB8 19B8 14161          jsr       _OS_StrLen
00004C6C  584F      14162          addq.w    #4,A7
00004C6E  1D40 FFFF 14163          move.b    D0,-1(A6)
                    14164   ; OS_EXIT_CRITICAL();
00004C72  46DF      14165          dc.w      18143
                    14166   ; *perr  = OS_ERR_NONE;
00004C74  2043      14167          move.l    D3,A0
00004C76  4210      14168          clr.b     (A0)
                    14169   ; return (len);
00004C78  102E FFFF 14170          move.b    -1(A6),D0
                    14171   OSTaskNameGet_3:
00004C7C  4CDF 001C 14172          movem.l   (A7)+,D2/D3/D4
00004C80  4E5E      14173          unlk      A6
00004C82  4E75      14174          rts
                    14175   ; }
                    14176   ; #endif
                    14177   ; /*$PAGE*/
                    14178   ; /*
                    14179   ; *********************************************************************************************************
                    14180   ; *                                       ASSIGN A NAME TO A TASK
                    14181   ; *
                    14182   ; * Description: This function is used to set the name of a task.
                    14183   ; *
                    14184   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    14185   ; *
                    14186   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    14187   ; *
                    14188   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    14189   ; *
                    14190   ; *                        OS_ERR_NONE                if the requested task is resumed
                    14191   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    14192   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    14193   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    14194   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    14195   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    14196   ; *
                    14197   ; * Returns    : None
                    14198   ; *********************************************************************************************************
                    14199   ; */
                    14200   ; #if OS_TASK_NAME_EN > 0u
                    14201   ; void  OSTaskNameSet (INT8U   prio,
                    14202   ; INT8U  *pname,
                    14203   ; INT8U  *perr)
                    14204   ; {
                    14205   _OSTaskNameSet:
00004C84  4E56 0000 14206          link      A6,#0
00004C88  48E7 3800 14207          movem.l   D2/D3/D4,-(A7)
00004C8C  262E 0010 14208          move.l    16(A6),D3
00004C90  182E 000B 14209          move.b    11(A6),D4
00004C94  C8BC 0000 14210          and.l     #255,D4
00004C98  00FF      
                    14211   ; OS_TCB    *ptcb;
                    14212   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    14213   ; OS_CPU_SR  cpu_sr = 0u;
                    14214   ; #endif
                    14215   ; #ifdef OS_SAFETY_CRITICAL
                    14216   ; if (perr == (INT8U *)0) {
                    14217   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14218   ; return;
                    14219   ; }
                    14220   ; #endif
                    14221   ; #if OS_ARG_CHK_EN > 0u
                    14222   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    14223   ; if (prio != OS_PRIO_SELF) {
                    14224   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    14225   ; return;
                    14226   ; }
                    14227   ; }
                    14228   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    14229   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    14230   ; return;
                    14231   ; }
                    14232   ; #endif
                    14233   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004C9A  1039 0800 14234          move.b    _OSIntNesting.L,D0
00004C9E  0D20      
00004CA0  0C00 0000 14235          cmp.b     #0,D0
00004CA4  630A      14236          bls.s     OSTaskNameSet_1
                    14237   ; *perr = OS_ERR_NAME_SET_ISR;
00004CA6  2043      14238          move.l    D3,A0
00004CA8  10BC 0012 14239          move.b    #18,(A0)
                    14240   ; return;
00004CAC  6000 005A 14241          bra       OSTaskNameSet_3
                    14242   OSTaskNameSet_1:
                    14243   ; }
                    14244   ; OS_ENTER_CRITICAL();
00004CB0  40E7      14245          dc.w      16615
00004CB2  007C      14246          dc.w      124
00004CB4  0700      14247          dc.w      1792
                    14248   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
00004CB6  0C04 00FF 14249          cmp.b     #255,D4
00004CBA  660A      14250          bne.s     OSTaskNameSet_4
                    14251   ; prio = OSTCBCur->OSTCBPrio;
00004CBC  2079 0800 14252          move.l    _OSTCBCur.L,A0
00004CC0  0E3A      
00004CC2  1828 0034 14253          move.b    52(A0),D4
                    14254   OSTaskNameSet_4:
                    14255   ; }
                    14256   ; ptcb = OSTCBPrioTbl[prio];
00004CC6  C8BC 0000 14257          and.l     #255,D4
00004CCA  00FF      
00004CCC  2004      14258          move.l    D4,D0
00004CCE  E588      14259          lsl.l     #2,D0
00004CD0  41F9 0800 14260          lea       _OSTCBPrioTbl.L,A0
00004CD4  0E4A      
00004CD6  2430 0800 14261          move.l    0(A0,D0.L),D2
                    14262   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
00004CDA  4A82      14263          tst.l     D2
00004CDC  660A      14264          bne.s     OSTaskNameSet_6
                    14265   ; OS_EXIT_CRITICAL();                          /* No                                             */
00004CDE  46DF      14266          dc.w      18143
                    14267   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004CE0  2043      14268          move.l    D3,A0
00004CE2  10BC 0043 14269          move.b    #67,(A0)
                    14270   ; return;
00004CE6  6020      14271          bra.s     OSTaskNameSet_3
                    14272   OSTaskNameSet_6:
                    14273   ; }
                    14274   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
00004CE8  0C82 0000 14275          cmp.l     #1,D2
00004CEC  0001      
00004CEE  660A      14276          bne.s     OSTaskNameSet_8
                    14277   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
00004CF0  46DF      14278          dc.w      18143
                    14279   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004CF2  2043      14280          move.l    D3,A0
00004CF4  10BC 0043 14281          move.b    #67,(A0)
                    14282   ; return;
00004CF8  600E      14283          bra.s     OSTaskNameSet_3
                    14284   OSTaskNameSet_8:
                    14285   ; }
                    14286   ; ptcb->OSTCBTaskName = pname;
00004CFA  2042      14287          move.l    D2,A0
00004CFC  216E 000C 14288          move.l    12(A6),78(A0)
00004D00  004E      
                    14289   ; OS_EXIT_CRITICAL();
00004D02  46DF      14290          dc.w      18143
                    14291   ; *perr               = OS_ERR_NONE;
00004D04  2043      14292          move.l    D3,A0
00004D06  4210      14293          clr.b     (A0)
                    14294   OSTaskNameSet_3:
00004D08  4CDF 001C 14295          movem.l   (A7)+,D2/D3/D4
00004D0C  4E5E      14296          unlk      A6
00004D0E  4E75      14297          rts
                    14298   ; }
                    14299   ; #endif
                    14300   ; /*$PAGE*/
                    14301   ; /*
                    14302   ; *********************************************************************************************************
                    14303   ; *                                       RESUME A SUSPENDED TASK
                    14304   ; *
                    14305   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    14306   ; *              will remove an explicit task suspension.
                    14307   ; *
                    14308   ; * Arguments  : prio     is the priority of the task to resume.
                    14309   ; *
                    14310   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    14311   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    14312   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    14313   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    14314   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    14315   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    14316   ; *********************************************************************************************************
                    14317   ; */
                    14318   ; #if OS_TASK_SUSPEND_EN > 0u
                    14319   ; INT8U  OSTaskResume (INT8U prio)
                    14320   ; {
                    14321   _OSTaskResume:
00004D10  4E56 0000 14322          link      A6,#0
00004D14  2F02      14323          move.l    D2,-(A7)
                    14324   ; OS_TCB    *ptcb;
                    14325   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    14326   ; OS_CPU_SR  cpu_sr = 0u;
                    14327   ; #endif
                    14328   ; #if OS_ARG_CHK_EN > 0u
                    14329   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    14330   ; return (OS_ERR_PRIO_INVALID);
                    14331   ; }
                    14332   ; #endif
                    14333   ; OS_ENTER_CRITICAL();
00004D16  40E7      14334          dc.w      16615
00004D18  007C      14335          dc.w      124
00004D1A  0700      14336          dc.w      1792
                    14337   ; ptcb = OSTCBPrioTbl[prio];
00004D1C  102E 000B 14338          move.b    11(A6),D0
00004D20  C0BC 0000 14339          and.l     #255,D0
00004D24  00FF      
00004D26  E588      14340          lsl.l     #2,D0
00004D28  41F9 0800 14341          lea       _OSTCBPrioTbl.L,A0
00004D2C  0E4A      
00004D2E  2430 0800 14342          move.l    0(A0,D0.L),D2
                    14343   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
00004D32  4A82      14344          tst.l     D2
00004D34  6608      14345          bne.s     OSTaskResume_1
                    14346   ; OS_EXIT_CRITICAL();
00004D36  46DF      14347          dc.w      18143
                    14348   ; return (OS_ERR_TASK_RESUME_PRIO);
00004D38  7046      14349          moveq     #70,D0
00004D3A  6000 0088 14350          bra       OSTaskResume_3
                    14351   OSTaskResume_1:
                    14352   ; }
                    14353   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004D3E  0C82 0000 14354          cmp.l     #1,D2
00004D42  0001      
00004D44  6608      14355          bne.s     OSTaskResume_4
                    14356   ; OS_EXIT_CRITICAL();
00004D46  46DF      14357          dc.w      18143
                    14358   ; return (OS_ERR_TASK_NOT_EXIST);
00004D48  7043      14359          moveq     #67,D0
00004D4A  6000 0078 14360          bra       OSTaskResume_3
                    14361   OSTaskResume_4:
                    14362   ; }
                    14363   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004D4E  2042      14364          move.l    D2,A0
00004D50  1028 0032 14365          move.b    50(A0),D0
00004D54  C03C 0008 14366          and.b     #8,D0
00004D58  6700 0066 14367          beq       OSTaskResume_6
                    14368   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004D5C  2042      14369          move.l    D2,A0
00004D5E  7008      14370          moveq     #8,D0
00004D60  4600      14371          not.b     D0
00004D62  C128 0032 14372          and.b     D0,50(A0)
                    14373   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004D66  2042      14374          move.l    D2,A0
00004D68  1028 0032 14375          move.b    50(A0),D0
00004D6C  6600 004C 14376          bne       OSTaskResume_8
                    14377   ; if (ptcb->OSTCBDly == 0u) {
00004D70  2042      14378          move.l    D2,A0
00004D72  2028 002E 14379          move.l    46(A0),D0
00004D76  6600 003E 14380          bne       OSTaskResume_10
                    14381   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004D7A  2042      14382          move.l    D2,A0
00004D7C  1028 0038 14383          move.b    56(A0),D0
00004D80  8139 0800 14384          or.b      D0,_OSRdyGrp.L
00004D84  0D28      
                    14385   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004D86  2042      14386          move.l    D2,A0
00004D88  1028 0036 14387          move.b    54(A0),D0
00004D8C  C0BC 0000 14388          and.l     #255,D0
00004D90  00FF      
00004D92  41F9 0800 14389          lea       _OSRdyTbl.L,A0
00004D96  0D2A      
00004D98  2242      14390          move.l    D2,A1
00004D9A  1229 0037 14391          move.b    55(A1),D1
00004D9E  8330 0800 14392          or.b      D1,0(A0,D0.L)
                    14393   ; OS_EXIT_CRITICAL();
00004DA2  46DF      14394          dc.w      18143
                    14395   ; if (OSRunning == OS_TRUE) {
00004DA4  1039 0800 14396          move.b    _OSRunning.L,D0
00004DA8  0D32      
00004DAA  0C00 0001 14397          cmp.b     #1,D0
00004DAE  6604      14398          bne.s     OSTaskResume_12
                    14399   ; OS_Sched();                               /* Find new highest priority task        */
00004DB0  4EB8 190E 14400          jsr       _OS_Sched
                    14401   OSTaskResume_12:
00004DB4  6002      14402          bra.s     OSTaskResume_11
                    14403   OSTaskResume_10:
                    14404   ; }
                    14405   ; } else {
                    14406   ; OS_EXIT_CRITICAL();
00004DB6  46DF      14407          dc.w      18143
                    14408   OSTaskResume_11:
00004DB8  6002      14409          bra.s     OSTaskResume_9
                    14410   OSTaskResume_8:
                    14411   ; }
                    14412   ; } else {                                              /* Must be pending on event              */
                    14413   ; OS_EXIT_CRITICAL();
00004DBA  46DF      14414          dc.w      18143
                    14415   OSTaskResume_9:
                    14416   ; }
                    14417   ; return (OS_ERR_NONE);
00004DBC  4200      14418          clr.b     D0
00004DBE  6004      14419          bra.s     OSTaskResume_3
                    14420   OSTaskResume_6:
                    14421   ; }
                    14422   ; OS_EXIT_CRITICAL();
00004DC0  46DF      14423          dc.w      18143
                    14424   ; return (OS_ERR_TASK_NOT_SUSPENDED);
00004DC2  7044      14425          moveq     #68,D0
                    14426   OSTaskResume_3:
00004DC4  241F      14427          move.l    (A7)+,D2
00004DC6  4E5E      14428          unlk      A6
00004DC8  4E75      14429          rts
                    14430   ; }
                    14431   ; #endif
                    14432   ; /*$PAGE*/
                    14433   ; /*
                    14434   ; *********************************************************************************************************
                    14435   ; *                                           STACK CHECKING
                    14436   ; *
                    14437   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14438   ; *              stack.
                    14439   ; *
                    14440   ; * Arguments  : prio          is the task priority
                    14441   ; *
                    14442   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14443   ; *
                    14444   ; * Returns    : OS_ERR_NONE            upon success
                    14445   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14446   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14447   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14448   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14449   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14450   ; *********************************************************************************************************
                    14451   ; */
                    14452   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14453   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14454   ; OS_STK_DATA  *p_stk_data)
                    14455   ; {
                    14456   _OSTaskStkChk:
00004DCA  4E56 FFF8 14457          link      A6,#-8
00004DCE  48E7 3C00 14458          movem.l   D2/D3/D4/D5,-(A7)
00004DD2  282E 000C 14459          move.l    12(A6),D4
00004DD6  1A2E 000B 14460          move.b    11(A6),D5
00004DDA  CABC 0000 14461          and.l     #255,D5
00004DDE  00FF      
                    14462   ; OS_TCB    *ptcb;
                    14463   ; OS_STK    *pchk;
                    14464   ; INT32U     nfree;
                    14465   ; INT32U     size;
                    14466   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14467   ; OS_CPU_SR  cpu_sr = 0u;
                    14468   ; #endif
                    14469   ; #if OS_ARG_CHK_EN > 0u
                    14470   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14471   ; if (prio != OS_PRIO_SELF) {
                    14472   ; return (OS_ERR_PRIO_INVALID);
                    14473   ; }
                    14474   ; }
                    14475   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14476   ; return (OS_ERR_PDATA_NULL);
                    14477   ; }
                    14478   ; #endif
                    14479   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00004DE0  2044      14480          move.l    D4,A0
00004DE2  4290      14481          clr.l     (A0)
                    14482   ; p_stk_data->OSUsed = 0u;
00004DE4  2044      14483          move.l    D4,A0
00004DE6  42A8 0004 14484          clr.l     4(A0)
                    14485   ; OS_ENTER_CRITICAL();
00004DEA  40E7      14486          dc.w      16615
00004DEC  007C      14487          dc.w      124
00004DEE  0700      14488          dc.w      1792
                    14489   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
00004DF0  0C05 00FF 14490          cmp.b     #255,D5
00004DF4  660A      14491          bne.s     OSTaskStkChk_1
                    14492   ; prio = OSTCBCur->OSTCBPrio;
00004DF6  2079 0800 14493          move.l    _OSTCBCur.L,A0
00004DFA  0E3A      
00004DFC  1A28 0034 14494          move.b    52(A0),D5
                    14495   OSTaskStkChk_1:
                    14496   ; }
                    14497   ; ptcb = OSTCBPrioTbl[prio];
00004E00  CABC 0000 14498          and.l     #255,D5
00004E04  00FF      
00004E06  2005      14499          move.l    D5,D0
00004E08  E588      14500          lsl.l     #2,D0
00004E0A  41F9 0800 14501          lea       _OSTCBPrioTbl.L,A0
00004E0E  0E4A      
00004E10  2430 0800 14502          move.l    0(A0,D0.L),D2
                    14503   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00004E14  4A82      14504          tst.l     D2
00004E16  6608      14505          bne.s     OSTaskStkChk_3
                    14506   ; OS_EXIT_CRITICAL();
00004E18  46DF      14507          dc.w      18143
                    14508   ; return (OS_ERR_TASK_NOT_EXIST);
00004E1A  7043      14509          moveq     #67,D0
00004E1C  6000 005C 14510          bra       OSTaskStkChk_5
                    14511   OSTaskStkChk_3:
                    14512   ; }
                    14513   ; if (ptcb == OS_TCB_RESERVED) {
00004E20  0C82 0000 14514          cmp.l     #1,D2
00004E24  0001      
00004E26  6608      14515          bne.s     OSTaskStkChk_6
                    14516   ; OS_EXIT_CRITICAL();
00004E28  46DF      14517          dc.w      18143
                    14518   ; return (OS_ERR_TASK_NOT_EXIST);
00004E2A  7043      14519          moveq     #67,D0
00004E2C  6000 004C 14520          bra       OSTaskStkChk_5
                    14521   OSTaskStkChk_6:
                    14522   ; }
                    14523   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
00004E30  2042      14524          move.l    D2,A0
00004E32  3028 0010 14525          move.w    16(A0),D0
00004E36  C07C 0001 14526          and.w     #1,D0
00004E3A  6608      14527          bne.s     OSTaskStkChk_8
                    14528   ; OS_EXIT_CRITICAL();
00004E3C  46DF      14529          dc.w      18143
                    14530   ; return (OS_ERR_TASK_OPT);
00004E3E  7045      14531          moveq     #69,D0
00004E40  6000 0038 14532          bra       OSTaskStkChk_5
                    14533   OSTaskStkChk_8:
                    14534   ; }
                    14535   ; nfree = 0u;
00004E44  4283      14536          clr.l     D3
                    14537   ; size  = ptcb->OSTCBStkSize;
00004E46  2042      14538          move.l    D2,A0
00004E48  2D68 000C 14539          move.l    12(A0),-4(A6)
00004E4C  FFFC      
                    14540   ; pchk  = ptcb->OSTCBStkBottom;
00004E4E  2042      14541          move.l    D2,A0
00004E50  2D68 0008 14542          move.l    8(A0),-8(A6)
00004E54  FFF8      
                    14543   ; OS_EXIT_CRITICAL();
00004E56  46DF      14544          dc.w      18143
                    14545   ; #if OS_STK_GROWTH == 1u
                    14546   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14547   OSTaskStkChk_10:
00004E58  206E FFF8 14548          move.l    -8(A6),A0
00004E5C  54AE FFF8 14549          addq.l    #2,-8(A6)
00004E60  3010      14550          move.w    (A0),D0
00004E62  6604      14551          bne.s     OSTaskStkChk_12
                    14552   ; nfree++;
00004E64  5283      14553          addq.l    #1,D3
00004E66  60F0      14554          bra       OSTaskStkChk_10
                    14555   OSTaskStkChk_12:
                    14556   ; }
                    14557   ; #else
                    14558   ; while (*pchk-- == (OS_STK)0) {
                    14559   ; nfree++;
                    14560   ; }
                    14561   ; #endif
                    14562   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004E68  2044      14563          move.l    D4,A0
00004E6A  2083      14564          move.l    D3,(A0)
                    14565   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004E6C  202E FFFC 14566          move.l    -4(A6),D0
00004E70  9083      14567          sub.l     D3,D0
00004E72  2044      14568          move.l    D4,A0
00004E74  2140 0004 14569          move.l    D0,4(A0)
                    14570   ; return (OS_ERR_NONE);
00004E78  4200      14571          clr.b     D0
                    14572   OSTaskStkChk_5:
00004E7A  4CDF 003C 14573          movem.l   (A7)+,D2/D3/D4/D5
00004E7E  4E5E      14574          unlk      A6
00004E80  4E75      14575          rts
                    14576   ; }
                    14577   ; #endif
                    14578   ; /*$PAGE*/
                    14579   ; /*
                    14580   ; *********************************************************************************************************
                    14581   ; *                                           SUSPEND A TASK
                    14582   ; *
                    14583   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14584   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14585   ; *
                    14586   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14587   ; *                       calling task will suspend itself and rescheduling will occur.
                    14588   ; *
                    14589   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14590   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14591   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14592   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14593   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14594   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14595   ; *
                    14596   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14597   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14598   ; *              running when the event arrives.
                    14599   ; *********************************************************************************************************
                    14600   ; */
                    14601   ; #if OS_TASK_SUSPEND_EN > 0u
                    14602   ; INT8U  OSTaskSuspend (INT8U prio)
                    14603   ; {
                    14604   _OSTaskSuspend:
00004E82  4E56 0000 14605          link      A6,#0
00004E86  48E7 3C00 14606          movem.l   D2/D3/D4/D5,-(A7)
00004E8A  182E 000B 14607          move.b    11(A6),D4
00004E8E  C8BC 0000 14608          and.l     #255,D4
00004E92  00FF      
                    14609   ; BOOLEAN    self;
                    14610   ; OS_TCB    *ptcb;
                    14611   ; INT8U      y;
                    14612   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14613   ; OS_CPU_SR  cpu_sr = 0u;
                    14614   ; #endif
                    14615   ; #if OS_ARG_CHK_EN > 0u
                    14616   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14617   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14618   ; }
                    14619   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14620   ; if (prio != OS_PRIO_SELF) {
                    14621   ; return (OS_ERR_PRIO_INVALID);
                    14622   ; }
                    14623   ; }
                    14624   ; #endif
                    14625   ; OS_ENTER_CRITICAL();
00004E94  40E7      14626          dc.w      16615
00004E96  007C      14627          dc.w      124
00004E98  0700      14628          dc.w      1792
                    14629   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004E9A  0C04 00FF 14630          cmp.b     #255,D4
00004E9E  660E      14631          bne.s     OSTaskSuspend_1
                    14632   ; prio = OSTCBCur->OSTCBPrio;
00004EA0  2079 0800 14633          move.l    _OSTCBCur.L,A0
00004EA4  0E3A      
00004EA6  1828 0034 14634          move.b    52(A0),D4
                    14635   ; self = OS_TRUE;
00004EAA  7601      14636          moveq     #1,D3
00004EAC  6012      14637          bra.s     OSTaskSuspend_4
                    14638   OSTaskSuspend_1:
                    14639   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004EAE  2079 0800 14640          move.l    _OSTCBCur.L,A0
00004EB2  0E3A      
00004EB4  B828 0034 14641          cmp.b     52(A0),D4
00004EB8  6604      14642          bne.s     OSTaskSuspend_3
                    14643   ; self = OS_TRUE;
00004EBA  7601      14644          moveq     #1,D3
00004EBC  6002      14645          bra.s     OSTaskSuspend_4
                    14646   OSTaskSuspend_3:
                    14647   ; } else {
                    14648   ; self = OS_FALSE;                                        /* No suspending another task          */
00004EBE  4203      14649          clr.b     D3
                    14650   OSTaskSuspend_4:
                    14651   ; }
                    14652   ; ptcb = OSTCBPrioTbl[prio];
00004EC0  C8BC 0000 14653          and.l     #255,D4
00004EC4  00FF      
00004EC6  2004      14654          move.l    D4,D0
00004EC8  E588      14655          lsl.l     #2,D0
00004ECA  41F9 0800 14656          lea       _OSTCBPrioTbl.L,A0
00004ECE  0E4A      
00004ED0  2430 0800 14657          move.l    0(A0,D0.L),D2
                    14658   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00004ED4  4A82      14659          tst.l     D2
00004ED6  6608      14660          bne.s     OSTaskSuspend_5
                    14661   ; OS_EXIT_CRITICAL();
00004ED8  46DF      14662          dc.w      18143
                    14663   ; return (OS_ERR_TASK_SUSPEND_PRIO);
00004EDA  7048      14664          moveq     #72,D0
00004EDC  6000 0066 14665          bra       OSTaskSuspend_7
                    14666   OSTaskSuspend_5:
                    14667   ; }
                    14668   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
00004EE0  0C82 0000 14669          cmp.l     #1,D2
00004EE4  0001      
00004EE6  6608      14670          bne.s     OSTaskSuspend_8
                    14671   ; OS_EXIT_CRITICAL();
00004EE8  46DF      14672          dc.w      18143
                    14673   ; return (OS_ERR_TASK_NOT_EXIST);
00004EEA  7043      14674          moveq     #67,D0
00004EEC  6000 0056 14675          bra       OSTaskSuspend_7
                    14676   OSTaskSuspend_8:
                    14677   ; }
                    14678   ; y            = ptcb->OSTCBY;
00004EF0  2042      14679          move.l    D2,A0
00004EF2  1A28 0036 14680          move.b    54(A0),D5
                    14681   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
00004EF6  CABC 0000 14682          and.l     #255,D5
00004EFA  00FF      
00004EFC  41F9 0800 14683          lea       _OSRdyTbl.L,A0
00004F00  0D2A      
00004F02  2242      14684          move.l    D2,A1
00004F04  1029 0037 14685          move.b    55(A1),D0
00004F08  4600      14686          not.b     D0
00004F0A  C130 5800 14687          and.b     D0,0(A0,D5.L)
                    14688   ; if (OSRdyTbl[y] == 0u) {
00004F0E  CABC 0000 14689          and.l     #255,D5
00004F12  00FF      
00004F14  41F9 0800 14690          lea       _OSRdyTbl.L,A0
00004F18  0D2A      
00004F1A  1030 5800 14691          move.b    0(A0,D5.L),D0
00004F1E  660E      14692          bne.s     OSTaskSuspend_10
                    14693   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00004F20  2042      14694          move.l    D2,A0
00004F22  1028 0038 14695          move.b    56(A0),D0
00004F26  4600      14696          not.b     D0
00004F28  C139 0800 14697          and.b     D0,_OSRdyGrp.L
00004F2C  0D28      
                    14698   OSTaskSuspend_10:
                    14699   ; }
                    14700   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00004F2E  2042      14701          move.l    D2,A0
00004F30  0028 0008 14702          or.b      #8,50(A0)
00004F34  0032      
                    14703   ; OS_EXIT_CRITICAL();
00004F36  46DF      14704          dc.w      18143
                    14705   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
00004F38  0C03 0001 14706          cmp.b     #1,D3
00004F3C  6604      14707          bne.s     OSTaskSuspend_12
                    14708   ; OS_Sched();                                             /* Find new highest priority task      */
00004F3E  4EB8 190E 14709          jsr       _OS_Sched
                    14710   OSTaskSuspend_12:
                    14711   ; }
                    14712   ; return (OS_ERR_NONE);
00004F42  4200      14713          clr.b     D0
                    14714   OSTaskSuspend_7:
00004F44  4CDF 003C 14715          movem.l   (A7)+,D2/D3/D4/D5
00004F48  4E5E      14716          unlk      A6
00004F4A  4E75      14717          rts
                    14718   ; }
                    14719   ; #endif
                    14720   ; /*$PAGE*/
                    14721   ; /*
                    14722   ; *********************************************************************************************************
                    14723   ; *                                            QUERY A TASK
                    14724   ; *
                    14725   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14726   ; *
                    14727   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14728   ; *
                    14729   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14730   ; *
                    14731   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14732   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14733   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14734   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14735   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14736   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14737   ; *********************************************************************************************************
                    14738   ; */
                    14739   ; #if OS_TASK_QUERY_EN > 0u
                    14740   ; INT8U  OSTaskQuery (INT8U    prio,
                    14741   ; OS_TCB  *p_task_data)
                    14742   ; {
                    14743   _OSTaskQuery:
00004F4C  4E56 0000 14744          link      A6,#0
00004F50  48E7 3000 14745          movem.l   D2/D3,-(A7)
00004F54  162E 000B 14746          move.b    11(A6),D3
00004F58  C6BC 0000 14747          and.l     #255,D3
00004F5C  00FF      
                    14748   ; OS_TCB    *ptcb;
                    14749   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14750   ; OS_CPU_SR  cpu_sr = 0u;
                    14751   ; #endif
                    14752   ; #if OS_ARG_CHK_EN > 0u
                    14753   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14754   ; if (prio != OS_PRIO_SELF) {
                    14755   ; return (OS_ERR_PRIO_INVALID);
                    14756   ; }
                    14757   ; }
                    14758   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14759   ; return (OS_ERR_PDATA_NULL);
                    14760   ; }
                    14761   ; #endif
                    14762   ; OS_ENTER_CRITICAL();
00004F5E  40E7      14763          dc.w      16615
00004F60  007C      14764          dc.w      124
00004F62  0700      14765          dc.w      1792
                    14766   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00004F64  0C03 00FF 14767          cmp.b     #255,D3
00004F68  660A      14768          bne.s     OSTaskQuery_1
                    14769   ; prio = OSTCBCur->OSTCBPrio;
00004F6A  2079 0800 14770          move.l    _OSTCBCur.L,A0
00004F6E  0E3A      
00004F70  1628 0034 14771          move.b    52(A0),D3
                    14772   OSTaskQuery_1:
                    14773   ; }
                    14774   ; ptcb = OSTCBPrioTbl[prio];
00004F74  C6BC 0000 14775          and.l     #255,D3
00004F78  00FF      
00004F7A  2003      14776          move.l    D3,D0
00004F7C  E588      14777          lsl.l     #2,D0
00004F7E  41F9 0800 14778          lea       _OSTCBPrioTbl.L,A0
00004F82  0E4A      
00004F84  2430 0800 14779          move.l    0(A0,D0.L),D2
                    14780   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00004F88  4A82      14781          tst.l     D2
00004F8A  6606      14782          bne.s     OSTaskQuery_3
                    14783   ; OS_EXIT_CRITICAL();
00004F8C  46DF      14784          dc.w      18143
                    14785   ; return (OS_ERR_PRIO);
00004F8E  7029      14786          moveq     #41,D0
00004F90  6024      14787          bra.s     OSTaskQuery_5
                    14788   OSTaskQuery_3:
                    14789   ; }
                    14790   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
00004F92  0C82 0000 14791          cmp.l     #1,D2
00004F96  0001      
00004F98  6606      14792          bne.s     OSTaskQuery_6
                    14793   ; OS_EXIT_CRITICAL();
00004F9A  46DF      14794          dc.w      18143
                    14795   ; return (OS_ERR_TASK_NOT_EXIST);
00004F9C  7043      14796          moveq     #67,D0
00004F9E  6016      14797          bra.s     OSTaskQuery_5
                    14798   OSTaskQuery_6:
                    14799   ; }
                    14800   ; /* Copy TCB into user storage area                    */
                    14801   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
00004FA0  4878 0056 14802          pea       86
00004FA4  2F02      14803          move.l    D2,-(A7)
00004FA6  2F2E 000C 14804          move.l    12(A6),-(A7)
00004FAA  4EB8 18E4 14805          jsr       _OS_MemCopy
00004FAE  DEFC 000C 14806          add.w     #12,A7
                    14807   ; OS_EXIT_CRITICAL();
00004FB2  46DF      14808          dc.w      18143
                    14809   ; return (OS_ERR_NONE);
00004FB4  4200      14810          clr.b     D0
                    14811   OSTaskQuery_5:
00004FB6  4CDF 000C 14812          movem.l   (A7)+,D2/D3
00004FBA  4E5E      14813          unlk      A6
00004FBC  4E75      14814          rts
                    14815   ; }
                    14816   ; #endif
                    14817   ; /*$PAGE*/
                    14818   ; /*
                    14819   ; *********************************************************************************************************
                    14820   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14821   ; *
                    14822   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14823   ; *              are application specific and can be used to store task specific values such as 'error
                    14824   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14825   ; *
                    14826   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14827   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14828   ; *
                    14829   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14830   ; *                        than OS_TASK_REG_TBL_SIZE
                    14831   ; *
                    14832   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14833   ; *
                    14834   ; *                        OS_ERR_NONE            if the call was successful
                    14835   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14836   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14837   ; *
                    14838   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14839   ; *
                    14840   ; * Note(s)    : The maximum number of task variables is 254
                    14841   ; *********************************************************************************************************
                    14842   ; */
                    14843   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14844   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14845   ; INT8U   id,
                    14846   ; INT8U  *perr)
                    14847   ; {
                    14848   _OSTaskRegGet:
00004FBE  4E56 FFFC 14849          link      A6,#-4
00004FC2  2F02      14850          move.l    D2,-(A7)
                    14851   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14852   ; OS_CPU_SR  cpu_sr = 0u;
                    14853   ; #endif
                    14854   ; INT32U     value;
                    14855   ; OS_TCB    *ptcb;
                    14856   ; #ifdef OS_SAFETY_CRITICAL
                    14857   ; if (perr == (INT8U *)0) {
                    14858   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14859   ; return (0u);
                    14860   ; }
                    14861   ; #endif
                    14862   ; #if OS_ARG_CHK_EN > 0u
                    14863   ; if (prio >= OS_LOWEST_PRIO) {
                    14864   ; if (prio != OS_PRIO_SELF) {
                    14865   ; *perr = OS_ERR_PRIO_INVALID;
                    14866   ; return (0u);
                    14867   ; }
                    14868   ; }
                    14869   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14870   ; *perr = OS_ERR_ID_INVALID;
                    14871   ; return (0u);
                    14872   ; }
                    14873   ; #endif
                    14874   ; OS_ENTER_CRITICAL();
00004FC4  40E7      14875          dc.w      16615
00004FC6  007C      14876          dc.w      124
00004FC8  0700      14877          dc.w      1792
                    14878   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004FCA  102E 000B 14879          move.b    11(A6),D0
00004FCE  0C00 00FF 14880          cmp.b     #255,D0
00004FD2  6608      14881          bne.s     OSTaskRegGet_1
                    14882   ; ptcb = OSTCBCur;
00004FD4  2439 0800 14883          move.l    _OSTCBCur.L,D2
00004FD8  0E3A      
00004FDA  6016      14884          bra.s     OSTaskRegGet_2
                    14885   OSTaskRegGet_1:
                    14886   ; } else {
                    14887   ; ptcb = OSTCBPrioTbl[prio];
00004FDC  102E 000B 14888          move.b    11(A6),D0
00004FE0  C0BC 0000 14889          and.l     #255,D0
00004FE4  00FF      
00004FE6  E588      14890          lsl.l     #2,D0
00004FE8  41F9 0800 14891          lea       _OSTCBPrioTbl.L,A0
00004FEC  0E4A      
00004FEE  2430 0800 14892          move.l    0(A0,D0.L),D2
                    14893   OSTaskRegGet_2:
                    14894   ; }
                    14895   ; value = ptcb->OSTCBRegTbl[id];
00004FF2  2042      14896          move.l    D2,A0
00004FF4  102E 000F 14897          move.b    15(A6),D0
00004FF8  C0BC 0000 14898          and.l     #255,D0
00004FFC  00FF      
00004FFE  E588      14899          lsl.l     #2,D0
00005000  D1C0      14900          add.l     D0,A0
00005002  2D68 0052 14901          move.l    82(A0),-4(A6)
00005006  FFFC      
                    14902   ; OS_EXIT_CRITICAL();
00005008  46DF      14903          dc.w      18143
                    14904   ; *perr = OS_ERR_NONE;
0000500A  206E 0010 14905          move.l    16(A6),A0
0000500E  4210      14906          clr.b     (A0)
                    14907   ; return (value);
00005010  202E FFFC 14908          move.l    -4(A6),D0
00005014  241F      14909          move.l    (A7)+,D2
00005016  4E5E      14910          unlk      A6
00005018  4E75      14911          rts
                    14912   ; }
                    14913   ; #endif
                    14914   ; /*$PAGE*/
                    14915   ; /*
                    14916   ; ************************************************************************************************************************
                    14917   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14918   ; *
                    14919   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14920   ; *              allocated dynamically instead of statically.
                    14921   ; *
                    14922   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14923   ; *
                    14924   ; *                            OS_ERR_NONE               if the call was successful
                    14925   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14926   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14927   ; *
                    14928   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14929   ; ************************************************************************************************************************
                    14930   ; */
                    14931   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14932   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14933   ; {
                    14934   _OSTaskRegGetID:
0000501A  4E56 FFFC 14935          link      A6,#-4
                    14936   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14937   ; OS_CPU_SR  cpu_sr = 0u;
                    14938   ; #endif
                    14939   ; INT8U      id;
                    14940   ; #ifdef OS_SAFETY_CRITICAL
                    14941   ; if (perr == (INT8U *)0) {
                    14942   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14943   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14944   ; }
                    14945   ; #endif
                    14946   ; OS_ENTER_CRITICAL();
0000501E  40E7      14947          dc.w      16615
00005020  007C      14948          dc.w      124
00005022  0700      14949          dc.w      1792
                    14950   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00005024  1039 0800 14951          move.b    _OSTaskRegNextAvailID.L,D0
00005028  178E      
0000502A  0C00 0001 14952          cmp.b     #1,D0
0000502E  650E      14953          blo.s     OSTaskRegGetID_1
                    14954   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00005030  206E 0008 14955          move.l    8(A6),A0
00005034  10BC 0096 14956          move.b    #150,(A0)
                    14957   ; OS_EXIT_CRITICAL();
00005038  46DF      14958          dc.w      18143
                    14959   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
0000503A  7001      14960          moveq     #1,D0
0000503C  601A      14961          bra.s     OSTaskRegGetID_3
                    14962   OSTaskRegGetID_1:
                    14963   ; }
                    14964   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
0000503E  1D79 0800 14965          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00005042  178E FFFF 
                    14966   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
00005046  5239 0800 14967          addq.b    #1,_OSTaskRegNextAvailID.L
0000504A  178E      
                    14968   ; OS_EXIT_CRITICAL();
0000504C  46DF      14969          dc.w      18143
                    14970   ; *perr = OS_ERR_NONE;
0000504E  206E 0008 14971          move.l    8(A6),A0
00005052  4210      14972          clr.b     (A0)
                    14973   ; return (id);
00005054  102E FFFF 14974          move.b    -1(A6),D0
                    14975   OSTaskRegGetID_3:
00005058  4E5E      14976          unlk      A6
0000505A  4E75      14977          rts
                    14978   ; }
                    14979   ; #endif
                    14980   ; /*$PAGE*/
                    14981   ; /*
                    14982   ; *********************************************************************************************************
                    14983   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14984   ; *
                    14985   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14986   ; *              are application specific and can be used to store task specific values such as 'error
                    14987   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14988   ; *
                    14989   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14990   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14991   ; *
                    14992   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14993   ; *                        than OS_TASK_REG_TBL_SIZE
                    14994   ; *
                    14995   ; *              value     is the desired value for the task register.
                    14996   ; *
                    14997   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14998   ; *
                    14999   ; *                        OS_ERR_NONE            if the call was successful
                    15000   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    15001   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    15002   ; *
                    15003   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    15004   ; *
                    15005   ; * Note(s)    : The maximum number of task variables is 254
                    15006   ; *********************************************************************************************************
                    15007   ; */
                    15008   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    15009   ; void  OSTaskRegSet (INT8U    prio,
                    15010   ; INT8U    id,
                    15011   ; INT32U   value,
                    15012   ; INT8U   *perr)
                    15013   ; {
                    15014   _OSTaskRegSet:
0000505C  4E56 0000 15015          link      A6,#0
00005060  2F02      15016          move.l    D2,-(A7)
                    15017   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15018   ; OS_CPU_SR  cpu_sr = 0u;
                    15019   ; #endif
                    15020   ; OS_TCB    *ptcb;
                    15021   ; #ifdef OS_SAFETY_CRITICAL
                    15022   ; if (perr == (INT8U *)0) {
                    15023   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15024   ; return;
                    15025   ; }
                    15026   ; #endif
                    15027   ; #if OS_ARG_CHK_EN > 0u
                    15028   ; if (prio >= OS_LOWEST_PRIO) {
                    15029   ; if (prio != OS_PRIO_SELF) {
                    15030   ; *perr = OS_ERR_PRIO_INVALID;
                    15031   ; return;
                    15032   ; }
                    15033   ; }
                    15034   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    15035   ; *perr = OS_ERR_ID_INVALID;
                    15036   ; return;
                    15037   ; }
                    15038   ; #endif
                    15039   ; OS_ENTER_CRITICAL();
00005062  40E7      15040          dc.w      16615
00005064  007C      15041          dc.w      124
00005066  0700      15042          dc.w      1792
                    15043   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00005068  102E 000B 15044          move.b    11(A6),D0
0000506C  0C00 00FF 15045          cmp.b     #255,D0
00005070  6608      15046          bne.s     OSTaskRegSet_1
                    15047   ; ptcb = OSTCBCur;
00005072  2439 0800 15048          move.l    _OSTCBCur.L,D2
00005076  0E3A      
00005078  6016      15049          bra.s     OSTaskRegSet_2
                    15050   OSTaskRegSet_1:
                    15051   ; } else {
                    15052   ; ptcb = OSTCBPrioTbl[prio];
0000507A  102E 000B 15053          move.b    11(A6),D0
0000507E  C0BC 0000 15054          and.l     #255,D0
00005082  00FF      
00005084  E588      15055          lsl.l     #2,D0
00005086  41F9 0800 15056          lea       _OSTCBPrioTbl.L,A0
0000508A  0E4A      
0000508C  2430 0800 15057          move.l    0(A0,D0.L),D2
                    15058   OSTaskRegSet_2:
                    15059   ; }
                    15060   ; ptcb->OSTCBRegTbl[id] = value;
00005090  2042      15061          move.l    D2,A0
00005092  102E 000F 15062          move.b    15(A6),D0
00005096  C0BC 0000 15063          and.l     #255,D0
0000509A  00FF      
0000509C  E588      15064          lsl.l     #2,D0
0000509E  D1C0      15065          add.l     D0,A0
000050A0  216E 0010 15066          move.l    16(A6),82(A0)
000050A4  0052      
                    15067   ; OS_EXIT_CRITICAL();
000050A6  46DF      15068          dc.w      18143
                    15069   ; *perr                 = OS_ERR_NONE;
000050A8  206E 0014 15070          move.l    20(A6),A0
000050AC  4210      15071          clr.b     (A0)
000050AE  241F      15072          move.l    (A7)+,D2
000050B0  4E5E      15073          unlk      A6
000050B2  4E75      15074          rts
                    15075   ; }
                    15076   ; #endif
                    15077   ; /*$PAGE*/
                    15078   ; /*
                    15079   ; *********************************************************************************************************
                    15080   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    15081   ; *
                    15082   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    15083   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    15084   ; *
                    15085   ; * Arguments  : none
                    15086   ; *
                    15087   ; * Returns    : none
                    15088   ; *
                    15089   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    15090   ; *********************************************************************************************************
                    15091   ; */
                    15092   ; void  OS_TaskReturn (void)
                    15093   ; {
                    15094   _OS_TaskReturn:
                    15095   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
000050B4  2F39 0800 15096          move.l    _OSTCBCur.L,-(A7)
000050B8  0E3A      
000050BA  4EB8 0C06 15097          jsr       _OSTaskReturnHook
000050BE  584F      15098          addq.w    #4,A7
                    15099   ; #if OS_TASK_DEL_EN > 0u
                    15100   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
000050C0  4878 00FF 15101          pea       255
000050C4  4EB8 4986 15102          jsr       _OSTaskDel
000050C8  584F      15103          addq.w    #4,A7
000050CA  C0BC 0000 15104          and.l     #255,D0
000050CE  00FF      
000050D0  4E75      15105          rts
                    15106   ; #else
                    15107   ; for (;;) {
                    15108   ; OSTimeDly(OS_TICKS_PER_SEC);
                    15109   ; }
                    15110   ; #endif
                    15111   ; }
                    15112   ; /*$PAGE*/
                    15113   ; /*
                    15114   ; *********************************************************************************************************
                    15115   ; *                                          CLEAR TASK STACK
                    15116   ; *
                    15117   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    15118   ; *
                    15119   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    15120   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    15121   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    15122   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    15123   ; *                       highest memory location of the stack and the stack will grow with increasing
                    15124   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    15125   ; *
                    15126   ; *              size     is the number of 'stack elements' to clear.
                    15127   ; *
                    15128   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    15129   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    15130   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    15131   ; *
                    15132   ; * Returns    : none
                    15133   ; *********************************************************************************************************
                    15134   ; */
                    15135   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    15136   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    15137   ; INT32U   size,
                    15138   ; INT16U   opt)
                    15139   ; {
                    15140   _OS_TaskStkClr:
000050D2  4E56 0000 15141          link      A6,#0
                    15142   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
000050D6  302E 0012 15143          move.w    18(A6),D0
000050DA  C07C 0001 15144          and.w     #1,D0
000050DE  6726      15145          beq.s     OS_TaskStkClr_7
                    15146   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
000050E0  302E 0012 15147          move.w    18(A6),D0
000050E4  C07C 0002 15148          and.w     #2,D0
000050E8  671C      15149          beq.s     OS_TaskStkClr_7
                    15150   ; #if OS_STK_GROWTH == 1u
                    15151   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    15152   OS_TaskStkClr_5:
000050EA  202E 000C 15153          move.l    12(A6),D0
000050EE  0C80 0000 15154          cmp.l     #0,D0
000050F2  0000      
000050F4  6310      15155          bls.s     OS_TaskStkClr_7
                    15156   ; size--;
000050F6  53AE 000C 15157          subq.l    #1,12(A6)
                    15158   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
000050FA  206E 0008 15159          move.l    8(A6),A0
000050FE  54AE 0008 15160          addq.l    #2,8(A6)
00005102  4250      15161          clr.w     (A0)
00005104  60E4      15162          bra       OS_TaskStkClr_5
                    15163   OS_TaskStkClr_7:
00005106  4E5E      15164          unlk      A6
00005108  4E75      15165          rts
                    15166   ; /*
                    15167   ; *********************************************************************************************************
                    15168   ; *                                                uC/OS-II
                    15169   ; *                                          The Real-Time Kernel
                    15170   ; *                                             TIME MANAGEMENT
                    15171   ; *
                    15172   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15173   ; *                                           All Rights Reserved
                    15174   ; *
                    15175   ; * File    : OS_TIME.C
                    15176   ; * By      : Jean J. Labrosse
                    15177   ; * Version : V2.92.07
                    15178   ; *
                    15179   ; * LICENSING TERMS:
                    15180   ; * ---------------
                    15181   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15182   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15183   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15184   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15185   ; * licensing fee.
                    15186   ; *********************************************************************************************************
                    15187   ; */
                    15188   ; #define  MICRIUM_SOURCE
                    15189   ; #ifndef  OS_MASTER_FILE
                    15190   ; #include <ucos_ii.h>
                    15191   ; #endif
                    15192   ; /*
                    15193   ; *********************************************************************************************************
                    15194   ; *                                        DELAY TASK 'n' TICKS
                    15195   ; *
                    15196   ; * Description: This function is called to delay execution of the currently running task until the
                    15197   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    15198   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    15199   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    15200   ; *
                    15201   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    15202   ; *                        Note that by specifying 0, the task will not be delayed.
                    15203   ; *
                    15204   ; * Returns    : none
                    15205   ; *********************************************************************************************************
                    15206   ; */
                    15207   ; void  OSTimeDly (INT32U ticks)
                    15208   ; {
                    15209   _OSTimeDly:
0000510A  4E56 0000 15210          link      A6,#0
0000510E  48E7 2020 15211          movem.l   D2/A2,-(A7)
00005112  45F9 0800 15212          lea       _OSTCBCur.L,A2
00005116  0E3A      
                    15213   ; INT8U      y;
                    15214   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15215   ; OS_CPU_SR  cpu_sr = 0u;
                    15216   ; #endif
                    15217   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00005118  1039 0800 15218          move.b    _OSIntNesting.L,D0
0000511C  0D20      
0000511E  0C00 0000 15219          cmp.b     #0,D0
00005122  6304      15220          bls.s     OSTimeDly_1
                    15221   ; return;
00005124  6000 0072 15222          bra       OSTimeDly_6
                    15223   OSTimeDly_1:
                    15224   ; }
                    15225   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00005128  1039 0800 15226          move.b    _OSLockNesting.L,D0
0000512C  0D22      
0000512E  0C00 0000 15227          cmp.b     #0,D0
00005132  6304      15228          bls.s     OSTimeDly_4
                    15229   ; return;
00005134  6000 0062 15230          bra       OSTimeDly_6
                    15231   OSTimeDly_4:
                    15232   ; }
                    15233   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
00005138  202E 0008 15234          move.l    8(A6),D0
0000513C  0C80 0000 15235          cmp.l     #0,D0
00005140  0000      
00005142  6300 0054 15236          bls       OSTimeDly_6
                    15237   ; OS_ENTER_CRITICAL();
00005146  40E7      15238          dc.w      16615
00005148  007C      15239          dc.w      124
0000514A  0700      15240          dc.w      1792
                    15241   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
0000514C  2052      15242          move.l    (A2),A0
0000514E  1428 0036 15243          move.b    54(A0),D2
                    15244   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005152  C4BC 0000 15245          and.l     #255,D2
00005156  00FF      
00005158  41F9 0800 15246          lea       _OSRdyTbl.L,A0
0000515C  0D2A      
0000515E  2252      15247          move.l    (A2),A1
00005160  1029 0037 15248          move.b    55(A1),D0
00005164  4600      15249          not.b     D0
00005166  C130 2800 15250          and.b     D0,0(A0,D2.L)
                    15251   ; if (OSRdyTbl[y] == 0u) {
0000516A  C4BC 0000 15252          and.l     #255,D2
0000516E  00FF      
00005170  41F9 0800 15253          lea       _OSRdyTbl.L,A0
00005174  0D2A      
00005176  1030 2800 15254          move.b    0(A0,D2.L),D0
0000517A  660E      15255          bne.s     OSTimeDly_8
                    15256   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0000517C  2052      15257          move.l    (A2),A0
0000517E  1028 0038 15258          move.b    56(A0),D0
00005182  4600      15259          not.b     D0
00005184  C139 0800 15260          and.b     D0,_OSRdyGrp.L
00005188  0D28      
                    15261   OSTimeDly_8:
                    15262   ; }
                    15263   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
0000518A  2052      15264          move.l    (A2),A0
0000518C  216E 0008 15265          move.l    8(A6),46(A0)
00005190  002E      
                    15266   ; OS_EXIT_CRITICAL();
00005192  46DF      15267          dc.w      18143
                    15268   ; OS_Sched();                              /* Find next task to run!                             */
00005194  4EB8 190E 15269          jsr       _OS_Sched
                    15270   OSTimeDly_6:
00005198  4CDF 0404 15271          movem.l   (A7)+,D2/A2
0000519C  4E5E      15272          unlk      A6
0000519E  4E75      15273          rts
                    15274   ; }
                    15275   ; }
                    15276   ; /*$PAGE*/
                    15277   ; /*
                    15278   ; *********************************************************************************************************
                    15279   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    15280   ; *
                    15281   ; * Description: This function is called to delay execution of the currently running task until some time
                    15282   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    15283   ; *              MILLISECONDS instead of ticks.
                    15284   ; *
                    15285   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    15286   ; *              minutes   specifies the number of minutes (max. 59)
                    15287   ; *              seconds   specifies the number of seconds (max. 59)
                    15288   ; *              ms        specifies the number of milliseconds (max. 999)
                    15289   ; *
                    15290   ; * Returns    : OS_ERR_NONE
                    15291   ; *              OS_ERR_TIME_INVALID_MINUTES
                    15292   ; *              OS_ERR_TIME_INVALID_SECONDS
                    15293   ; *              OS_ERR_TIME_INVALID_MS
                    15294   ; *              OS_ERR_TIME_ZERO_DLY
                    15295   ; *              OS_ERR_TIME_DLY_ISR
                    15296   ; *
                    15297   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    15298   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    15299   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    15300   ; *********************************************************************************************************
                    15301   ; */
                    15302   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    15303   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    15304   ; INT8U   minutes,
                    15305   ; INT8U   seconds,
                    15306   ; INT16U  ms)
                    15307   ; {
                    15308   _OSTimeDlyHMSM:
000051A0  4E56 FFFC 15309          link      A6,#-4
                    15310   ; INT32U ticks;
                    15311   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000051A4  1039 0800 15312          move.b    _OSIntNesting.L,D0
000051A8  0D20      
000051AA  0C00 0000 15313          cmp.b     #0,D0
000051AE  6306      15314          bls.s     OSTimeDlyHMSM_1
                    15315   ; return (OS_ERR_TIME_DLY_ISR);
000051B0  7055      15316          moveq     #85,D0
000051B2  6000 00A4 15317          bra       OSTimeDlyHMSM_3
                    15318   OSTimeDlyHMSM_1:
                    15319   ; }
                    15320   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
000051B6  1039 0800 15321          move.b    _OSLockNesting.L,D0
000051BA  0D22      
000051BC  0C00 0000 15322          cmp.b     #0,D0
000051C0  6306      15323          bls.s     OSTimeDlyHMSM_4
                    15324   ; return (OS_ERR_SCHED_LOCKED);
000051C2  7032      15325          moveq     #50,D0
000051C4  6000 0092 15326          bra       OSTimeDlyHMSM_3
                    15327   OSTimeDlyHMSM_4:
                    15328   ; }
                    15329   ; #if OS_ARG_CHK_EN > 0u
                    15330   ; if (hours == 0u) {
                    15331   ; if (minutes == 0u) {
                    15332   ; if (seconds == 0u) {
                    15333   ; if (ms == 0u) {
                    15334   ; return (OS_ERR_TIME_ZERO_DLY);
                    15335   ; }
                    15336   ; }
                    15337   ; }
                    15338   ; }
                    15339   ; if (minutes > 59u) {
                    15340   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    15341   ; }
                    15342   ; if (seconds > 59u) {
                    15343   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    15344   ; }
                    15345   ; if (ms > 999u) {
                    15346   ; return (OS_ERR_TIME_INVALID_MS);
                    15347   ; }
                    15348   ; #endif
                    15349   ; /* Compute the total number of clock ticks required.. */
                    15350   ; /* .. (rounded to the nearest tick)                   */
                    15351   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
000051C8  102E 000B 15352          move.b    11(A6),D0
000051CC  C0BC 0000 15353          and.l     #255,D0
000051D0  00FF      
000051D2  2F00      15354          move.l    D0,-(A7)
000051D4  4878 0E10 15355          pea       3600
000051D8  4EB9 0000 15356          jsr       ULMUL
000051DC  645C      
000051DE  2017      15357          move.l    (A7),D0
000051E0  504F      15358          addq.w    #8,A7
000051E2  122E 000F 15359          move.b    15(A6),D1
000051E6  C2BC 0000 15360          and.l     #255,D1
000051EA  00FF      
000051EC  2F01      15361          move.l    D1,-(A7)
000051EE  4878 003C 15362          pea       60
000051F2  4EB9 0000 15363          jsr       ULMUL
000051F6  645C      
000051F8  2217      15364          move.l    (A7),D1
000051FA  504F      15365          addq.w    #8,A7
000051FC  D081      15366          add.l     D1,D0
000051FE  122E 0013 15367          move.b    19(A6),D1
00005202  C2BC 0000 15368          and.l     #255,D1
00005206  00FF      
00005208  D081      15369          add.l     D1,D0
0000520A  2F00      15370          move.l    D0,-(A7)
0000520C  4878 0064 15371          pea       100
00005210  4EB9 0000 15372          jsr       ULMUL
00005214  645C      
00005216  2017      15373          move.l    (A7),D0
00005218  504F      15374          addq.w    #8,A7
0000521A  322E 0016 15375          move.w    22(A6),D1
0000521E  C2BC 0000 15376          and.l     #65535,D1
00005222  FFFF      
00005224  5A81      15377          addq.l    #5,D1
00005226  2F01      15378          move.l    D1,-(A7)
00005228  4878 0064 15379          pea       100
0000522C  4EB9 0000 15380          jsr       ULMUL
00005230  645C      
00005232  2217      15381          move.l    (A7),D1
00005234  504F      15382          addq.w    #8,A7
00005236  2F01      15383          move.l    D1,-(A7)
00005238  4878 03E8 15384          pea       1000
0000523C  4EB9 0000 15385          jsr       ULDIV
00005240  64FC      
00005242  2217      15386          move.l    (A7),D1
00005244  504F      15387          addq.w    #8,A7
00005246  D081      15388          add.l     D1,D0
00005248  2D40 FFFC 15389          move.l    D0,-4(A6)
                    15390   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    15391   ; OSTimeDly(ticks);
0000524C  2F2E FFFC 15392          move.l    -4(A6),-(A7)
00005250  4EB8 510A 15393          jsr       _OSTimeDly
00005254  584F      15394          addq.w    #4,A7
                    15395   ; return (OS_ERR_NONE);
00005256  4200      15396          clr.b     D0
                    15397   OSTimeDlyHMSM_3:
00005258  4E5E      15398          unlk      A6
0000525A  4E75      15399          rts
                    15400   ; }
                    15401   ; #endif
                    15402   ; /*$PAGE*/
                    15403   ; /*
                    15404   ; *********************************************************************************************************
                    15405   ; *                                        RESUME A DELAYED TASK
                    15406   ; *
                    15407   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15408   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15409   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15410   ; *              like a timeout occurred.
                    15411   ; *
                    15412   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15413   ; *
                    15414   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15415   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15416   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15417   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15418   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15419   ; *********************************************************************************************************
                    15420   ; */
                    15421   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15422   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15423   ; {
                    15424   _OSTimeDlyResume:
0000525C  4E56 0000 15425          link      A6,#0
00005260  2F02      15426          move.l    D2,-(A7)
                    15427   ; OS_TCB    *ptcb;
                    15428   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15429   ; OS_CPU_SR  cpu_sr = 0u;
                    15430   ; #endif
                    15431   ; if (prio >= OS_LOWEST_PRIO) {
00005262  102E 000B 15432          move.b    11(A6),D0
00005266  0C00 003F 15433          cmp.b     #63,D0
0000526A  6506      15434          blo.s     OSTimeDlyResume_1
                    15435   ; return (OS_ERR_PRIO_INVALID);
0000526C  702A      15436          moveq     #42,D0
0000526E  6000 00B4 15437          bra       OSTimeDlyResume_3
                    15438   OSTimeDlyResume_1:
                    15439   ; }
                    15440   ; OS_ENTER_CRITICAL();
00005272  40E7      15441          dc.w      16615
00005274  007C      15442          dc.w      124
00005276  0700      15443          dc.w      1792
                    15444   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
00005278  102E 000B 15445          move.b    11(A6),D0
0000527C  C0BC 0000 15446          and.l     #255,D0
00005280  00FF      
00005282  E588      15447          lsl.l     #2,D0
00005284  41F9 0800 15448          lea       _OSTCBPrioTbl.L,A0
00005288  0E4A      
0000528A  2430 0800 15449          move.l    0(A0,D0.L),D2
                    15450   ; if (ptcb == (OS_TCB *)0) {
0000528E  4A82      15451          tst.l     D2
00005290  6608      15452          bne.s     OSTimeDlyResume_4
                    15453   ; OS_EXIT_CRITICAL();
00005292  46DF      15454          dc.w      18143
                    15455   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
00005294  7043      15456          moveq     #67,D0
00005296  6000 008C 15457          bra       OSTimeDlyResume_3
                    15458   OSTimeDlyResume_4:
                    15459   ; }
                    15460   ; if (ptcb == OS_TCB_RESERVED) {
0000529A  0C82 0000 15461          cmp.l     #1,D2
0000529E  0001      
000052A0  6608      15462          bne.s     OSTimeDlyResume_6
                    15463   ; OS_EXIT_CRITICAL();
000052A2  46DF      15464          dc.w      18143
                    15465   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
000052A4  7043      15466          moveq     #67,D0
000052A6  6000 007C 15467          bra       OSTimeDlyResume_3
                    15468   OSTimeDlyResume_6:
                    15469   ; }
                    15470   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
000052AA  2042      15471          move.l    D2,A0
000052AC  2028 002E 15472          move.l    46(A0),D0
000052B0  6608      15473          bne.s     OSTimeDlyResume_8
                    15474   ; OS_EXIT_CRITICAL();
000052B2  46DF      15475          dc.w      18143
                    15476   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
000052B4  7050      15477          moveq     #80,D0
000052B6  6000 006C 15478          bra       OSTimeDlyResume_3
                    15479   OSTimeDlyResume_8:
                    15480   ; }
                    15481   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
000052BA  2042      15482          move.l    D2,A0
000052BC  42A8 002E 15483          clr.l     46(A0)
                    15484   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000052C0  2042      15485          move.l    D2,A0
000052C2  1028 0032 15486          move.b    50(A0),D0
000052C6  C03C 0037 15487          and.b     #55,D0
000052CA  6712      15488          beq.s     OSTimeDlyResume_10
                    15489   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
000052CC  2042      15490          move.l    D2,A0
000052CE  0228 00C8 15491          and.b     #-56,50(A0)
000052D2  0032      
                    15492   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
000052D4  2042      15493          move.l    D2,A0
000052D6  117C 0001 15494          move.b    #1,51(A0)
000052DA  0033      
000052DC  6006      15495          bra.s     OSTimeDlyResume_11
                    15496   OSTimeDlyResume_10:
                    15497   ; } else {
                    15498   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
000052DE  2042      15499          move.l    D2,A0
000052E0  4228 0033 15500          clr.b     51(A0)
                    15501   OSTimeDlyResume_11:
                    15502   ; }
                    15503   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
000052E4  2042      15504          move.l    D2,A0
000052E6  1028 0032 15505          move.b    50(A0),D0
000052EA  C03C 0008 15506          and.b     #8,D0
000052EE  6630      15507          bne.s     OSTimeDlyResume_12
                    15508   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
000052F0  2042      15509          move.l    D2,A0
000052F2  1028 0038 15510          move.b    56(A0),D0
000052F6  8139 0800 15511          or.b      D0,_OSRdyGrp.L
000052FA  0D28      
                    15512   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000052FC  2042      15513          move.l    D2,A0
000052FE  1028 0036 15514          move.b    54(A0),D0
00005302  C0BC 0000 15515          and.l     #255,D0
00005306  00FF      
00005308  41F9 0800 15516          lea       _OSRdyTbl.L,A0
0000530C  0D2A      
0000530E  2242      15517          move.l    D2,A1
00005310  1229 0037 15518          move.b    55(A1),D1
00005314  8330 0800 15519          or.b      D1,0(A0,D0.L)
                    15520   ; OS_EXIT_CRITICAL();
00005318  46DF      15521          dc.w      18143
                    15522   ; OS_Sched();                                            /* See if this is new highest priority  */
0000531A  4EB8 190E 15523          jsr       _OS_Sched
0000531E  6002      15524          bra.s     OSTimeDlyResume_13
                    15525   OSTimeDlyResume_12:
                    15526   ; } else {
                    15527   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
00005320  46DF      15528          dc.w      18143
                    15529   OSTimeDlyResume_13:
                    15530   ; }
                    15531   ; return (OS_ERR_NONE);
00005322  4200      15532          clr.b     D0
                    15533   OSTimeDlyResume_3:
00005324  241F      15534          move.l    (A7)+,D2
00005326  4E5E      15535          unlk      A6
00005328  4E75      15536          rts
                    15537   ; }
                    15538   ; #endif
                    15539   ; /*$PAGE*/
                    15540   ; /*
                    15541   ; *********************************************************************************************************
                    15542   ; *                                       GET CURRENT SYSTEM TIME
                    15543   ; *
                    15544   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15545   ; *              counter which keeps track of the number of clock ticks.
                    15546   ; *
                    15547   ; * Arguments  : none
                    15548   ; *
                    15549   ; * Returns    : The current value of OSTime
                    15550   ; *********************************************************************************************************
                    15551   ; */
                    15552   ; #if OS_TIME_GET_SET_EN > 0u
                    15553   ; INT32U  OSTimeGet (void)
                    15554   ; {
                    15555   _OSTimeGet:
0000532A  4E56 FFFC 15556          link      A6,#-4
                    15557   ; INT32U     ticks;
                    15558   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15559   ; OS_CPU_SR  cpu_sr = 0u;
                    15560   ; #endif
                    15561   ; OS_ENTER_CRITICAL();
0000532E  40E7      15562          dc.w      16615
00005330  007C      15563          dc.w      124
00005332  0700      15564          dc.w      1792
                    15565   ; ticks = OSTime;
00005334  2D79 0800 15566          move.l    _OSTime.L,-4(A6)
00005338  1790 FFFC 
                    15567   ; OS_EXIT_CRITICAL();
0000533C  46DF      15568          dc.w      18143
                    15569   ; return (ticks);
0000533E  202E FFFC 15570          move.l    -4(A6),D0
00005342  4E5E      15571          unlk      A6
00005344  4E75      15572          rts
                    15573   ; }
                    15574   ; #endif
                    15575   ; /*
                    15576   ; *********************************************************************************************************
                    15577   ; *                                          SET SYSTEM CLOCK
                    15578   ; *
                    15579   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15580   ; *
                    15581   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15582   ; *
                    15583   ; * Returns    : none
                    15584   ; *********************************************************************************************************
                    15585   ; */
                    15586   ; #if OS_TIME_GET_SET_EN > 0u
                    15587   ; void  OSTimeSet (INT32U ticks)
                    15588   ; {
                    15589   _OSTimeSet:
00005346  4E56 0000 15590          link      A6,#0
                    15591   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15592   ; OS_CPU_SR  cpu_sr = 0u;
                    15593   ; #endif
                    15594   ; OS_ENTER_CRITICAL();
0000534A  40E7      15595          dc.w      16615
0000534C  007C      15596          dc.w      124
0000534E  0700      15597          dc.w      1792
                    15598   ; OSTime = ticks;
00005350  23EE 0008 15599          move.l    8(A6),_OSTime.L
00005354  0800 1790 
                    15600   ; OS_EXIT_CRITICAL();
00005358  46DF      15601          dc.w      18143
0000535A  4E5E      15602          unlk      A6
0000535C  4E75      15603          rts
                    15604   ; /*
                    15605   ; *********************************************************************************************************
                    15606   ; *                                                uC/OS-II
                    15607   ; *                                          The Real-Time Kernel
                    15608   ; *                                            TIMER MANAGEMENT
                    15609   ; *
                    15610   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15611   ; *                                           All Rights Reserved
                    15612   ; *
                    15613   ; *
                    15614   ; * File    : OS_TMR.C
                    15615   ; * By      : Jean J. Labrosse
                    15616   ; * Version : V2.92.07
                    15617   ; *
                    15618   ; * LICENSING TERMS:
                    15619   ; * ---------------
                    15620   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15621   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15622   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15623   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15624   ; * licensing fee.
                    15625   ; *********************************************************************************************************
                    15626   ; */
                    15627   ; #define  MICRIUM_SOURCE
                    15628   ; #ifndef  OS_MASTER_FILE
                    15629   ; #include <ucos_ii.h>
                    15630   ; #endif
                    15631   ; /*
                    15632   ; *********************************************************************************************************
                    15633   ; *                                                        NOTES
                    15634   ; *
                    15635   ; * 1) Your application MUST define the following #define constants:
                    15636   ; *
                    15637   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15638   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15639   ; *
                    15640   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15641   ; *********************************************************************************************************
                    15642   ; */
                    15643   ; /*
                    15644   ; *********************************************************************************************************
                    15645   ; *                                              CONSTANTS
                    15646   ; *********************************************************************************************************
                    15647   ; */
                    15648   ; #define  OS_TMR_LINK_DLY       0u
                    15649   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15650   ; /*
                    15651   ; *********************************************************************************************************
                    15652   ; *                                          LOCAL PROTOTYPES
                    15653   ; *********************************************************************************************************
                    15654   ; */
                    15655   ; #if OS_TMR_EN > 0u
                    15656   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15657   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15658   ; static  void     OSTmr_InitTask      (void);
                    15659   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15660   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15661   ; static  void     OSTmr_Task          (void   *p_arg);
                    15662   ; #endif
                    15663   ; /*$PAGE*/
                    15664   ; /*
                    15665   ; *********************************************************************************************************
                    15666   ; *                                           CREATE A TIMER
                    15667   ; *
                    15668   ; * Description: This function is called by your application code to create a timer.
                    15669   ; *
                    15670   ; * Arguments  : dly           Initial delay.
                    15671   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15672   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15673   ; *                               wait for before the timer starts entering periodic mode.
                    15674   ; *
                    15675   ; *              period        The 'period' being repeated for the timer.
                    15676   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15677   ; *                               expires, it will automatically restart with the same period.
                    15678   ; *
                    15679   ; *              opt           Specifies either:
                    15680   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15681   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15682   ; *
                    15683   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15684   ; *                               The callback function must be declared as follows:
                    15685   ; *
                    15686   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15687   ; *
                    15688   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15689   ; *
                    15690   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15691   ; *                               useful for debugging.
                    15692   ; *
                    15693   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15694   ; *                               OS_ERR_NONE
                    15695   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15696   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15697   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15698   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15699   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15700   ; *
                    15701   ; * Returns    : A pointer to an OS_TMR data structure.
                    15702   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15703   ; *********************************************************************************************************
                    15704   ; */
                    15705   ; #if OS_TMR_EN > 0u
                    15706   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15707   ; INT32U           period,
                    15708   ; INT8U            opt,
                    15709   ; OS_TMR_CALLBACK  callback,
                    15710   ; void            *callback_arg,
                    15711   ; INT8U           *pname,
                    15712   ; INT8U           *perr)
                    15713   ; {
                    15714   _OSTmrCreate:
0000535E  4E56 0000 15715          link      A6,#0
00005362  48E7 3000 15716          movem.l   D2/D3,-(A7)
00005366  262E 0020 15717          move.l    32(A6),D3
                    15718   ; OS_TMR   *ptmr;
                    15719   ; #ifdef OS_SAFETY_CRITICAL
                    15720   ; if (perr == (INT8U *)0) {
                    15721   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15722   ; return ((OS_TMR *)0);
                    15723   ; }
                    15724   ; #endif
                    15725   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15726   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15727   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15728   ; return ((OS_TMR *)0);
                    15729   ; }
                    15730   ; #endif
                    15731   ; #if OS_ARG_CHK_EN > 0u
                    15732   ; switch (opt) {                                          /* Validate arguments                                     */
                    15733   ; case OS_TMR_OPT_PERIODIC:
                    15734   ; if (period == 0u) {
                    15735   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15736   ; return ((OS_TMR *)0);
                    15737   ; }
                    15738   ; break;
                    15739   ; case OS_TMR_OPT_ONE_SHOT:
                    15740   ; if (dly == 0u) {
                    15741   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15742   ; return ((OS_TMR *)0);
                    15743   ; }
                    15744   ; break;
                    15745   ; default:
                    15746   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15747   ; return ((OS_TMR *)0);
                    15748   ; }
                    15749   ; #endif
                    15750   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
0000536A  1039 0800 15751          move.b    _OSIntNesting.L,D0
0000536E  0D20      
00005370  0C00 0000 15752          cmp.b     #0,D0
00005374  630C      15753          bls.s     OSTmrCreate_1
                    15754   ; *perr  = OS_ERR_TMR_ISR;
00005376  2043      15755          move.l    D3,A0
00005378  10BC 008B 15756          move.b    #139,(A0)
                    15757   ; return ((OS_TMR *)0);
0000537C  4280      15758          clr.l     D0
0000537E  6000 0078 15759          bra       OSTmrCreate_3
                    15760   OSTmrCreate_1:
                    15761   ; }
                    15762   ; OSSchedLock();
00005382  4EB8 115E 15763          jsr       _OSSchedLock
                    15764   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
00005386  4EB9 0000 15765          jsr       @ucos_ii_OSTmr_Alloc
0000538A  58F6      
0000538C  2400      15766          move.l    D0,D2
                    15767   ; if (ptmr == (OS_TMR *)0) {
0000538E  4A82      15768          tst.l     D2
00005390  6610      15769          bne.s     OSTmrCreate_4
                    15770   ; OSSchedUnlock();
00005392  4EB8 118E 15771          jsr       _OSSchedUnlock
                    15772   ; *perr = OS_ERR_TMR_NON_AVAIL;
00005396  2043      15773          move.l    D3,A0
00005398  10BC 0086 15774          move.b    #134,(A0)
                    15775   ; return ((OS_TMR *)0);
0000539C  4280      15776          clr.l     D0
0000539E  6000 0058 15777          bra       OSTmrCreate_3
                    15778   OSTmrCreate_4:
                    15779   ; }
                    15780   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
000053A2  2042      15781          move.l    D2,A0
000053A4  117C 0001 15782          move.b    #1,35(A0)
000053A8  0023      
                    15783   ; ptmr->OSTmrDly         = dly;
000053AA  2042      15784          move.l    D2,A0
000053AC  216E 0008 15785          move.l    8(A6),22(A0)
000053B0  0016      
                    15786   ; ptmr->OSTmrPeriod      = period;
000053B2  2042      15787          move.l    D2,A0
000053B4  216E 000C 15788          move.l    12(A6),26(A0)
000053B8  001A      
                    15789   ; ptmr->OSTmrOpt         = opt;
000053BA  2042      15790          move.l    D2,A0
000053BC  116E 0013 15791          move.b    19(A6),34(A0)
000053C0  0022      
                    15792   ; ptmr->OSTmrCallback    = callback;
000053C2  2042      15793          move.l    D2,A0
000053C4  216E 0014 15794          move.l    20(A6),2(A0)
000053C8  0002      
                    15795   ; ptmr->OSTmrCallbackArg = callback_arg;
000053CA  2042      15796          move.l    D2,A0
000053CC  216E 0018 15797          move.l    24(A6),6(A0)
000053D0  0006      
                    15798   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15799   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
000053D2  202E 001C 15800          move.l    28(A6),D0
000053D6  660E      15801          bne.s     OSTmrCreate_6
                    15802   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
000053D8  41F9 0000 15803          lea       @ucos_ii_1.L,A0
000053DC  6F2A      
000053DE  2242      15804          move.l    D2,A1
000053E0  2348 001E 15805          move.l    A0,30(A1)
000053E4  6008      15806          bra.s     OSTmrCreate_7
                    15807   OSTmrCreate_6:
                    15808   ; } else {
                    15809   ; ptmr->OSTmrName    = pname;
000053E6  2042      15810          move.l    D2,A0
000053E8  216E 001C 15811          move.l    28(A6),30(A0)
000053EC  001E      
                    15812   OSTmrCreate_7:
                    15813   ; }
                    15814   ; #endif
                    15815   ; OSSchedUnlock();
000053EE  4EB8 118E 15816          jsr       _OSSchedUnlock
                    15817   ; *perr = OS_ERR_NONE;
000053F2  2043      15818          move.l    D3,A0
000053F4  4210      15819          clr.b     (A0)
                    15820   ; return (ptmr);
000053F6  2002      15821          move.l    D2,D0
                    15822   OSTmrCreate_3:
000053F8  4CDF 000C 15823          movem.l   (A7)+,D2/D3
000053FC  4E5E      15824          unlk      A6
000053FE  4E75      15825          rts
                    15826   ; }
                    15827   ; #endif
                    15828   ; /*$PAGE*/
                    15829   ; /*
                    15830   ; *********************************************************************************************************
                    15831   ; *                                           DELETE A TIMER
                    15832   ; *
                    15833   ; * Description: This function is called by your application code to delete a timer.
                    15834   ; *
                    15835   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15836   ; *
                    15837   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15838   ; *                               OS_ERR_NONE
                    15839   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15840   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15841   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15842   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15843   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15844   ; *
                    15845   ; * Returns    : OS_TRUE       If the call was successful
                    15846   ; *              OS_FALSE      If not
                    15847   ; *********************************************************************************************************
                    15848   ; */
                    15849   ; #if OS_TMR_EN > 0u
                    15850   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15851   ; INT8U   *perr)
                    15852   ; {
                    15853   _OSTmrDel:
00005400  4E56 0000 15854          link      A6,#0
00005404  48E7 3020 15855          movem.l   D2/D3/A2,-(A7)
00005408  242E 000C 15856          move.l    12(A6),D2
0000540C  262E 0008 15857          move.l    8(A6),D3
00005410  45F8 118E 15858          lea       _OSSchedUnlock.L,A2
                    15859   ; #ifdef OS_SAFETY_CRITICAL
                    15860   ; if (perr == (INT8U *)0) {
                    15861   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15862   ; return (OS_FALSE);
                    15863   ; }
                    15864   ; #endif
                    15865   ; #if OS_ARG_CHK_EN > 0u
                    15866   ; if (ptmr == (OS_TMR *)0) {
                    15867   ; *perr = OS_ERR_TMR_INVALID;
                    15868   ; return (OS_FALSE);
                    15869   ; }
                    15870   ; #endif
                    15871   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00005414  2043      15872          move.l    D3,A0
00005416  1010      15873          move.b    (A0),D0
00005418  0C00 0064 15874          cmp.b     #100,D0
0000541C  670C      15875          beq.s     OSTmrDel_1
                    15876   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000541E  2042      15877          move.l    D2,A0
00005420  10BC 0089 15878          move.b    #137,(A0)
                    15879   ; return (OS_FALSE);
00005424  4200      15880          clr.b     D0
00005426  6000 0090 15881          bra       OSTmrDel_3
                    15882   OSTmrDel_1:
                    15883   ; }
                    15884   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
0000542A  1039 0800 15885          move.b    _OSIntNesting.L,D0
0000542E  0D20      
00005430  0C00 0000 15886          cmp.b     #0,D0
00005434  630C      15887          bls.s     OSTmrDel_4
                    15888   ; *perr  = OS_ERR_TMR_ISR;
00005436  2042      15889          move.l    D2,A0
00005438  10BC 008B 15890          move.b    #139,(A0)
                    15891   ; return (OS_FALSE);
0000543C  4200      15892          clr.b     D0
0000543E  6000 0078 15893          bra       OSTmrDel_3
                    15894   OSTmrDel_4:
                    15895   ; }
                    15896   ; OSSchedLock();
00005442  4EB8 115E 15897          jsr       _OSSchedLock
                    15898   ; switch (ptmr->OSTmrState) {
00005446  2043      15899          move.l    D3,A0
00005448  1028 0023 15900          move.b    35(A0),D0
0000544C  C0BC 0000 15901          and.l     #255,D0
00005450  00FF      
00005452  0C80 0000 15902          cmp.l     #4,D0
00005456  0004      
00005458  6400 0054 15903          bhs       OSTmrDel_6
0000545C  E380      15904          asl.l     #1,D0
0000545E  303B 0806 15905          move.w    OSTmrDel_8(PC,D0.L),D0
00005462  4EFB 0002 15906          jmp       OSTmrDel_8(PC,D0.W)
                    15907   OSTmrDel_8:
00005466  003C      15908          dc.w      OSTmrDel_12-OSTmrDel_8
00005468  0028      15909          dc.w      OSTmrDel_10-OSTmrDel_8
0000546A  0028      15910          dc.w      OSTmrDel_10-OSTmrDel_8
0000546C  0008      15911          dc.w      OSTmrDel_9-OSTmrDel_8
                    15912   OSTmrDel_9:
                    15913   ; case OS_TMR_STATE_RUNNING:
                    15914   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
0000546E  2F03      15915          move.l    D3,-(A7)
00005470  4EB9 0000 15916          jsr       @ucos_ii_OSTmr_Unlink
00005474  5BEC      
00005476  584F      15917          addq.w    #4,A7
                    15918   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00005478  2F03      15919          move.l    D3,-(A7)
0000547A  4EB9 0000 15920          jsr       @ucos_ii_OSTmr_Free
0000547E  5930      
00005480  584F      15921          addq.w    #4,A7
                    15922   ; OSSchedUnlock();
00005482  4E92      15923          jsr       (A2)
                    15924   ; *perr = OS_ERR_NONE;
00005484  2042      15925          move.l    D2,A0
00005486  4210      15926          clr.b     (A0)
                    15927   ; return (OS_TRUE);
00005488  7001      15928          moveq     #1,D0
0000548A  6000 002C 15929          bra       OSTmrDel_3
                    15930   OSTmrDel_10:
                    15931   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15932   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15933   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
0000548E  2F03      15934          move.l    D3,-(A7)
00005490  4EB9 0000 15935          jsr       @ucos_ii_OSTmr_Free
00005494  5930      
00005496  584F      15936          addq.w    #4,A7
                    15937   ; OSSchedUnlock();
00005498  4E92      15938          jsr       (A2)
                    15939   ; *perr = OS_ERR_NONE;
0000549A  2042      15940          move.l    D2,A0
0000549C  4210      15941          clr.b     (A0)
                    15942   ; return (OS_TRUE);
0000549E  7001      15943          moveq     #1,D0
000054A0  6016      15944          bra.s     OSTmrDel_3
                    15945   OSTmrDel_12:
                    15946   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15947   ; OSSchedUnlock();
000054A2  4E92      15948          jsr       (A2)
                    15949   ; *perr = OS_ERR_TMR_INACTIVE;
000054A4  2042      15950          move.l    D2,A0
000054A6  10BC 0087 15951          move.b    #135,(A0)
                    15952   ; return (OS_FALSE);
000054AA  4200      15953          clr.b     D0
000054AC  600A      15954          bra.s     OSTmrDel_3
                    15955   OSTmrDel_6:
                    15956   ; default:
                    15957   ; OSSchedUnlock();
000054AE  4E92      15958          jsr       (A2)
                    15959   ; *perr = OS_ERR_TMR_INVALID_STATE;
000054B0  2042      15960          move.l    D2,A0
000054B2  10BC 008D 15961          move.b    #141,(A0)
                    15962   ; return (OS_FALSE);
000054B6  4200      15963          clr.b     D0
                    15964   OSTmrDel_3:
000054B8  4CDF 040C 15965          movem.l   (A7)+,D2/D3/A2
000054BC  4E5E      15966          unlk      A6
000054BE  4E75      15967          rts
                    15968   ; }
                    15969   ; }
                    15970   ; #endif
                    15971   ; /*$PAGE*/
                    15972   ; /*
                    15973   ; *********************************************************************************************************
                    15974   ; *                                       GET THE NAME OF A TIMER
                    15975   ; *
                    15976   ; * Description: This function is called to obtain the name of a timer.
                    15977   ; *
                    15978   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15979   ; *
                    15980   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15981   ; *
                    15982   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15983   ; *                               OS_ERR_NONE               The call was successful
                    15984   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15985   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15986   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15987   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15988   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15989   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15990   ; *
                    15991   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15992   ; *********************************************************************************************************
                    15993   ; */
                    15994   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15995   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15996   ; INT8U   **pdest,
                    15997   ; INT8U    *perr)
                    15998   ; {
                    15999   _OSTmrNameGet:
000054C0  4E56 FFFC 16000          link      A6,#-4
000054C4  48E7 3020 16001          movem.l   D2/D3/A2,-(A7)
000054C8  242E 0010 16002          move.l    16(A6),D2
000054CC  45F8 118E 16003          lea       _OSSchedUnlock.L,A2
000054D0  262E 0008 16004          move.l    8(A6),D3
                    16005   ; INT8U  len;
                    16006   ; #ifdef OS_SAFETY_CRITICAL
                    16007   ; if (perr == (INT8U *)0) {
                    16008   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16009   ; return (0u);
                    16010   ; }
                    16011   ; #endif
                    16012   ; #if OS_ARG_CHK_EN > 0u
                    16013   ; if (pdest == (INT8U **)0) {
                    16014   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    16015   ; return (0u);
                    16016   ; }
                    16017   ; if (ptmr == (OS_TMR *)0) {
                    16018   ; *perr = OS_ERR_TMR_INVALID;
                    16019   ; return (0u);
                    16020   ; }
                    16021   ; #endif
                    16022   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000054D4  2043      16023          move.l    D3,A0
000054D6  1010      16024          move.b    (A0),D0
000054D8  0C00 0064 16025          cmp.b     #100,D0
000054DC  670C      16026          beq.s     OSTmrNameGet_1
                    16027   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000054DE  2042      16028          move.l    D2,A0
000054E0  10BC 0089 16029          move.b    #137,(A0)
                    16030   ; return (0u);
000054E4  4200      16031          clr.b     D0
000054E6  6000 0082 16032          bra       OSTmrNameGet_3
                    16033   OSTmrNameGet_1:
                    16034   ; }
                    16035   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
000054EA  1039 0800 16036          move.b    _OSIntNesting.L,D0
000054EE  0D20      
000054F0  0C00 0000 16037          cmp.b     #0,D0
000054F4  630C      16038          bls.s     OSTmrNameGet_4
                    16039   ; *perr = OS_ERR_NAME_GET_ISR;
000054F6  2042      16040          move.l    D2,A0
000054F8  10BC 0011 16041          move.b    #17,(A0)
                    16042   ; return (0u);
000054FC  4200      16043          clr.b     D0
000054FE  6000 006A 16044          bra       OSTmrNameGet_3
                    16045   OSTmrNameGet_4:
                    16046   ; }
                    16047   ; OSSchedLock();
00005502  4EB8 115E 16048          jsr       _OSSchedLock
                    16049   ; switch (ptmr->OSTmrState) {
00005506  2043      16050          move.l    D3,A0
00005508  1028 0023 16051          move.b    35(A0),D0
0000550C  C0BC 0000 16052          and.l     #255,D0
00005510  00FF      
00005512  0C80 0000 16053          cmp.l     #4,D0
00005516  0004      
00005518  6400 0046 16054          bhs       OSTmrNameGet_6
0000551C  E380      16055          asl.l     #1,D0
0000551E  303B 0806 16056          move.w    OSTmrNameGet_8(PC,D0.L),D0
00005522  4EFB 0002 16057          jmp       OSTmrNameGet_8(PC,D0.W)
                    16058   OSTmrNameGet_8:
00005526  002E      16059          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
00005528  0008      16060          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
0000552A  0008      16061          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
0000552C  0008      16062          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    16063   OSTmrNameGet_9:
                    16064   ; case OS_TMR_STATE_RUNNING:
                    16065   ; case OS_TMR_STATE_STOPPED:
                    16066   ; case OS_TMR_STATE_COMPLETED:
                    16067   ; *pdest = ptmr->OSTmrName;
0000552E  2043      16068          move.l    D3,A0
00005530  226E 000C 16069          move.l    12(A6),A1
00005534  22A8 001E 16070          move.l    30(A0),(A1)
                    16071   ; len    = OS_StrLen(*pdest);
00005538  206E 000C 16072          move.l    12(A6),A0
0000553C  2F10      16073          move.l    (A0),-(A7)
0000553E  4EB8 19B8 16074          jsr       _OS_StrLen
00005542  584F      16075          addq.w    #4,A7
00005544  1D40 FFFF 16076          move.b    D0,-1(A6)
                    16077   ; OSSchedUnlock();
00005548  4E92      16078          jsr       (A2)
                    16079   ; *perr = OS_ERR_NONE;
0000554A  2042      16080          move.l    D2,A0
0000554C  4210      16081          clr.b     (A0)
                    16082   ; return (len);
0000554E  102E FFFF 16083          move.b    -1(A6),D0
00005552  6016      16084          bra.s     OSTmrNameGet_3
                    16085   OSTmrNameGet_12:
                    16086   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    16087   ; OSSchedUnlock();
00005554  4E92      16088          jsr       (A2)
                    16089   ; *perr = OS_ERR_TMR_INACTIVE;
00005556  2042      16090          move.l    D2,A0
00005558  10BC 0087 16091          move.b    #135,(A0)
                    16092   ; return (0u);
0000555C  4200      16093          clr.b     D0
0000555E  600A      16094          bra.s     OSTmrNameGet_3
                    16095   OSTmrNameGet_6:
                    16096   ; default:
                    16097   ; OSSchedUnlock();
00005560  4E92      16098          jsr       (A2)
                    16099   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005562  2042      16100          move.l    D2,A0
00005564  10BC 008D 16101          move.b    #141,(A0)
                    16102   ; return (0u);
00005568  4200      16103          clr.b     D0
                    16104   OSTmrNameGet_3:
0000556A  4CDF 040C 16105          movem.l   (A7)+,D2/D3/A2
0000556E  4E5E      16106          unlk      A6
00005570  4E75      16107          rts
                    16108   ; }
                    16109   ; }
                    16110   ; #endif
                    16111   ; /*$PAGE*/
                    16112   ; /*
                    16113   ; *********************************************************************************************************
                    16114   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    16115   ; *
                    16116   ; * Description: This function is called to get the number of ticks before a timer times out.
                    16117   ; *
                    16118   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    16119   ; *
                    16120   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16121   ; *                               OS_ERR_NONE
                    16122   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16123   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16124   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16125   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16126   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    16127   ; *
                    16128   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    16129   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    16130   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    16131   ; *********************************************************************************************************
                    16132   ; */
                    16133   ; #if OS_TMR_EN > 0u
                    16134   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    16135   ; INT8U   *perr)
                    16136   ; {
                    16137   _OSTmrRemainGet:
00005572  4E56 0000 16138          link      A6,#0
00005576  48E7 3820 16139          movem.l   D2/D3/D4/A2,-(A7)
0000557A  242E 000C 16140          move.l    12(A6),D2
0000557E  262E 0008 16141          move.l    8(A6),D3
00005582  45F8 118E 16142          lea       _OSSchedUnlock.L,A2
                    16143   ; INT32U  remain;
                    16144   ; #ifdef OS_SAFETY_CRITICAL
                    16145   ; if (perr == (INT8U *)0) {
                    16146   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16147   ; return (0u);
                    16148   ; }
                    16149   ; #endif
                    16150   ; #if OS_ARG_CHK_EN > 0u
                    16151   ; if (ptmr == (OS_TMR *)0) {
                    16152   ; *perr = OS_ERR_TMR_INVALID;
                    16153   ; return (0u);
                    16154   ; }
                    16155   ; #endif
                    16156   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005586  2043      16157          move.l    D3,A0
00005588  1010      16158          move.b    (A0),D0
0000558A  0C00 0064 16159          cmp.b     #100,D0
0000558E  670C      16160          beq.s     OSTmrRemainGet_1
                    16161   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005590  2042      16162          move.l    D2,A0
00005592  10BC 0089 16163          move.b    #137,(A0)
                    16164   ; return (0u);
00005596  4280      16165          clr.l     D0
00005598  6000 00CE 16166          bra       OSTmrRemainGet_3
                    16167   OSTmrRemainGet_1:
                    16168   ; }
                    16169   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
0000559C  1039 0800 16170          move.b    _OSIntNesting.L,D0
000055A0  0D20      
000055A2  0C00 0000 16171          cmp.b     #0,D0
000055A6  630C      16172          bls.s     OSTmrRemainGet_4
                    16173   ; *perr = OS_ERR_TMR_ISR;
000055A8  2042      16174          move.l    D2,A0
000055AA  10BC 008B 16175          move.b    #139,(A0)
                    16176   ; return (0u);
000055AE  4280      16177          clr.l     D0
000055B0  6000 00B6 16178          bra       OSTmrRemainGet_3
                    16179   OSTmrRemainGet_4:
                    16180   ; }
                    16181   ; OSSchedLock();
000055B4  4EB8 115E 16182          jsr       _OSSchedLock
                    16183   ; switch (ptmr->OSTmrState) {
000055B8  2043      16184          move.l    D3,A0
000055BA  1028 0023 16185          move.b    35(A0),D0
000055BE  C0BC 0000 16186          and.l     #255,D0
000055C2  00FF      
000055C4  0C80 0000 16187          cmp.l     #4,D0
000055C8  0004      
000055CA  6400 0092 16188          bhs       OSTmrRemainGet_6
000055CE  E380      16189          asl.l     #1,D0
000055D0  303B 0806 16190          move.w    OSTmrRemainGet_8(PC,D0.L),D0
000055D4  4EFB 0002 16191          jmp       OSTmrRemainGet_8(PC,D0.W)
                    16192   OSTmrRemainGet_8:
000055D8  007A      16193          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
000055DA  0022      16194          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
000055DC  0070      16195          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
000055DE  0008      16196          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    16197   OSTmrRemainGet_9:
                    16198   ; case OS_TMR_STATE_RUNNING:
                    16199   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
000055E0  2043      16200          move.l    D3,A0
000055E2  2028 0012 16201          move.l    18(A0),D0
000055E6  90B9 0800 16202          sub.l     _OSTmrTime.L,D0
000055EA  1798      
000055EC  2800      16203          move.l    D0,D4
                    16204   ; OSSchedUnlock();
000055EE  4E92      16205          jsr       (A2)
                    16206   ; *perr  = OS_ERR_NONE;
000055F0  2042      16207          move.l    D2,A0
000055F2  4210      16208          clr.b     (A0)
                    16209   ; return (remain);
000055F4  2004      16210          move.l    D4,D0
000055F6  6000 0070 16211          bra       OSTmrRemainGet_3
                    16212   OSTmrRemainGet_10:
                    16213   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    16214   ; switch (ptmr->OSTmrOpt) {
000055FA  2043      16215          move.l    D3,A0
000055FC  1028 0022 16216          move.b    34(A0),D0
00005600  C0BC 0000 16217          and.l     #255,D0
00005604  00FF      
00005606  0C80 0000 16218          cmp.l     #2,D0
0000560A  0002      
0000560C  670C      16219          beq.s     OSTmrRemainGet_16
0000560E  6228      16220          bhi.s     OSTmrRemainGet_17
00005610  0C80 0000 16221          cmp.l     #1,D0
00005614  0001      
00005616  6720      16222          beq.s     OSTmrRemainGet_17
00005618  601E      16223          bra.s     OSTmrRemainGet_17
                    16224   OSTmrRemainGet_16:
                    16225   ; case OS_TMR_OPT_PERIODIC:
                    16226   ; if (ptmr->OSTmrDly == 0u) {
0000561A  2043      16227          move.l    D3,A0
0000561C  2028 0016 16228          move.l    22(A0),D0
00005620  6608      16229          bne.s     OSTmrRemainGet_19
                    16230   ; remain = ptmr->OSTmrPeriod;
00005622  2043      16231          move.l    D3,A0
00005624  2828 001A 16232          move.l    26(A0),D4
00005628  6006      16233          bra.s     OSTmrRemainGet_20
                    16234   OSTmrRemainGet_19:
                    16235   ; } else {
                    16236   ; remain = ptmr->OSTmrDly;
0000562A  2043      16237          move.l    D3,A0
0000562C  2828 0016 16238          move.l    22(A0),D4
                    16239   OSTmrRemainGet_20:
                    16240   ; }
                    16241   ; OSSchedUnlock();
00005630  4E92      16242          jsr       (A2)
                    16243   ; *perr  = OS_ERR_NONE;
00005632  2042      16244          move.l    D2,A0
00005634  4210      16245          clr.b     (A0)
                    16246   ; break;
00005636  600C      16247          bra.s     OSTmrRemainGet_15
                    16248   OSTmrRemainGet_17:
                    16249   ; case OS_TMR_OPT_ONE_SHOT:
                    16250   ; default:
                    16251   ; remain = ptmr->OSTmrDly;
00005638  2043      16252          move.l    D3,A0
0000563A  2828 0016 16253          move.l    22(A0),D4
                    16254   ; OSSchedUnlock();
0000563E  4E92      16255          jsr       (A2)
                    16256   ; *perr  = OS_ERR_NONE;
00005640  2042      16257          move.l    D2,A0
00005642  4210      16258          clr.b     (A0)
                    16259   ; break;
                    16260   OSTmrRemainGet_15:
                    16261   ; }
                    16262   ; return (remain);
00005644  2004      16263          move.l    D4,D0
00005646  6020      16264          bra.s     OSTmrRemainGet_3
                    16265   OSTmrRemainGet_11:
                    16266   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    16267   ; OSSchedUnlock();
00005648  4E92      16268          jsr       (A2)
                    16269   ; *perr = OS_ERR_NONE;
0000564A  2042      16270          move.l    D2,A0
0000564C  4210      16271          clr.b     (A0)
                    16272   ; return (0u);
0000564E  4280      16273          clr.l     D0
00005650  6016      16274          bra.s     OSTmrRemainGet_3
                    16275   OSTmrRemainGet_12:
                    16276   ; case OS_TMR_STATE_UNUSED:
                    16277   ; OSSchedUnlock();
00005652  4E92      16278          jsr       (A2)
                    16279   ; *perr = OS_ERR_TMR_INACTIVE;
00005654  2042      16280          move.l    D2,A0
00005656  10BC 0087 16281          move.b    #135,(A0)
                    16282   ; return (0u);
0000565A  4280      16283          clr.l     D0
0000565C  600A      16284          bra.s     OSTmrRemainGet_3
                    16285   OSTmrRemainGet_6:
                    16286   ; default:
                    16287   ; OSSchedUnlock();
0000565E  4E92      16288          jsr       (A2)
                    16289   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005660  2042      16290          move.l    D2,A0
00005662  10BC 008D 16291          move.b    #141,(A0)
                    16292   ; return (0u);
00005666  4280      16293          clr.l     D0
                    16294   OSTmrRemainGet_3:
00005668  4CDF 041C 16295          movem.l   (A7)+,D2/D3/D4/A2
0000566C  4E5E      16296          unlk      A6
0000566E  4E75      16297          rts
                    16298   ; }
                    16299   ; }
                    16300   ; #endif
                    16301   ; /*$PAGE*/
                    16302   ; /*
                    16303   ; *********************************************************************************************************
                    16304   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    16305   ; *
                    16306   ; * Description: This function is called to determine what state the timer is in:
                    16307   ; *
                    16308   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    16309   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    16310   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    16311   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    16312   ; *
                    16313   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    16314   ; *
                    16315   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16316   ; *                               OS_ERR_NONE
                    16317   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    16318   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    16319   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    16320   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    16321   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    16322   ; *
                    16323   ; * Returns    : The current state of the timer (see description).
                    16324   ; *********************************************************************************************************
                    16325   ; */
                    16326   ; #if OS_TMR_EN > 0u
                    16327   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    16328   ; INT8U   *perr)
                    16329   ; {
                    16330   _OSTmrStateGet:
00005670  4E56 0000 16331          link      A6,#0
00005674  48E7 3000 16332          movem.l   D2/D3,-(A7)
00005678  242E 000C 16333          move.l    12(A6),D2
                    16334   ; INT8U  state;
                    16335   ; #ifdef OS_SAFETY_CRITICAL
                    16336   ; if (perr == (INT8U *)0) {
                    16337   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16338   ; return (0u);
                    16339   ; }
                    16340   ; #endif
                    16341   ; #if OS_ARG_CHK_EN > 0u
                    16342   ; if (ptmr == (OS_TMR *)0) {
                    16343   ; *perr = OS_ERR_TMR_INVALID;
                    16344   ; return (0u);
                    16345   ; }
                    16346   ; #endif
                    16347   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
0000567C  206E 0008 16348          move.l    8(A6),A0
00005680  1010      16349          move.b    (A0),D0
00005682  0C00 0064 16350          cmp.b     #100,D0
00005686  670C      16351          beq.s     OSTmrStateGet_1
                    16352   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005688  2042      16353          move.l    D2,A0
0000568A  10BC 0089 16354          move.b    #137,(A0)
                    16355   ; return (0u);
0000568E  4200      16356          clr.b     D0
00005690  6000 005A 16357          bra       OSTmrStateGet_3
                    16358   OSTmrStateGet_1:
                    16359   ; }
                    16360   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005694  1039 0800 16361          move.b    _OSIntNesting.L,D0
00005698  0D20      
0000569A  0C00 0000 16362          cmp.b     #0,D0
0000569E  630C      16363          bls.s     OSTmrStateGet_4
                    16364   ; *perr = OS_ERR_TMR_ISR;
000056A0  2042      16365          move.l    D2,A0
000056A2  10BC 008B 16366          move.b    #139,(A0)
                    16367   ; return (0u);
000056A6  4200      16368          clr.b     D0
000056A8  6000 0042 16369          bra       OSTmrStateGet_3
                    16370   OSTmrStateGet_4:
                    16371   ; }
                    16372   ; OSSchedLock();
000056AC  4EB8 115E 16373          jsr       _OSSchedLock
                    16374   ; state = ptmr->OSTmrState;
000056B0  206E 0008 16375          move.l    8(A6),A0
000056B4  1628 0023 16376          move.b    35(A0),D3
                    16377   ; switch (state) {
000056B8  C6BC 0000 16378          and.l     #255,D3
000056BC  00FF      
000056BE  2003      16379          move.l    D3,D0
000056C0  0C80 0000 16380          cmp.l     #4,D0
000056C4  0004      
000056C6  6418      16381          bhs.s     OSTmrStateGet_6
000056C8  E380      16382          asl.l     #1,D0
000056CA  303B 0806 16383          move.w    OSTmrStateGet_8(PC,D0.L),D0
000056CE  4EFB 0002 16384          jmp       OSTmrStateGet_8(PC,D0.W)
                    16385   OSTmrStateGet_8:
000056D2  0008      16386          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000056D4  0008      16387          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000056D6  0008      16388          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000056D8  0008      16389          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    16390   OSTmrStateGet_9:
                    16391   ; case OS_TMR_STATE_UNUSED:
                    16392   ; case OS_TMR_STATE_STOPPED:
                    16393   ; case OS_TMR_STATE_COMPLETED:
                    16394   ; case OS_TMR_STATE_RUNNING:
                    16395   ; *perr = OS_ERR_NONE;
000056DA  2042      16396          move.l    D2,A0
000056DC  4210      16397          clr.b     (A0)
                    16398   ; break;
000056DE  6006      16399          bra.s     OSTmrStateGet_7
                    16400   OSTmrStateGet_6:
                    16401   ; default:
                    16402   ; *perr = OS_ERR_TMR_INVALID_STATE;
000056E0  2042      16403          move.l    D2,A0
000056E2  10BC 008D 16404          move.b    #141,(A0)
                    16405   ; break;
                    16406   OSTmrStateGet_7:
                    16407   ; }
                    16408   ; OSSchedUnlock();
000056E6  4EB8 118E 16409          jsr       _OSSchedUnlock
                    16410   ; return (state);
000056EA  1003      16411          move.b    D3,D0
                    16412   OSTmrStateGet_3:
000056EC  4CDF 000C 16413          movem.l   (A7)+,D2/D3
000056F0  4E5E      16414          unlk      A6
000056F2  4E75      16415          rts
                    16416   ; }
                    16417   ; #endif
                    16418   ; /*$PAGE*/
                    16419   ; /*
                    16420   ; *********************************************************************************************************
                    16421   ; *                                            START A TIMER
                    16422   ; *
                    16423   ; * Description: This function is called by your application code to start a timer.
                    16424   ; *
                    16425   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16426   ; *
                    16427   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16428   ; *                               OS_ERR_NONE
                    16429   ; *                               OS_ERR_TMR_INVALID
                    16430   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16431   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16432   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16433   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16434   ; *
                    16435   ; * Returns    : OS_TRUE    if the timer was started
                    16436   ; *              OS_FALSE   if an error was detected
                    16437   ; *********************************************************************************************************
                    16438   ; */
                    16439   ; #if OS_TMR_EN > 0u
                    16440   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16441   ; INT8U    *perr)
                    16442   ; {
                    16443   _OSTmrStart:
000056F4  4E56 0000 16444          link      A6,#0
000056F8  48E7 3020 16445          movem.l   D2/D3/A2,-(A7)
000056FC  242E 000C 16446          move.l    12(A6),D2
00005700  262E 0008 16447          move.l    8(A6),D3
00005704  45F8 118E 16448          lea       _OSSchedUnlock.L,A2
                    16449   ; #ifdef OS_SAFETY_CRITICAL
                    16450   ; if (perr == (INT8U *)0) {
                    16451   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16452   ; return (OS_FALSE);
                    16453   ; }
                    16454   ; #endif
                    16455   ; #if OS_ARG_CHK_EN > 0u
                    16456   ; if (ptmr == (OS_TMR *)0) {
                    16457   ; *perr = OS_ERR_TMR_INVALID;
                    16458   ; return (OS_FALSE);
                    16459   ; }
                    16460   ; #endif
                    16461   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00005708  2043      16462          move.l    D3,A0
0000570A  1010      16463          move.b    (A0),D0
0000570C  0C00 0064 16464          cmp.b     #100,D0
00005710  670C      16465          beq.s     OSTmrStart_1
                    16466   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005712  2042      16467          move.l    D2,A0
00005714  10BC 0089 16468          move.b    #137,(A0)
                    16469   ; return (OS_FALSE);
00005718  4200      16470          clr.b     D0
0000571A  6000 0094 16471          bra       OSTmrStart_3
                    16472   OSTmrStart_1:
                    16473   ; }
                    16474   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
0000571E  1039 0800 16475          move.b    _OSIntNesting.L,D0
00005722  0D20      
00005724  0C00 0000 16476          cmp.b     #0,D0
00005728  630C      16477          bls.s     OSTmrStart_4
                    16478   ; *perr  = OS_ERR_TMR_ISR;
0000572A  2042      16479          move.l    D2,A0
0000572C  10BC 008B 16480          move.b    #139,(A0)
                    16481   ; return (OS_FALSE);
00005730  4200      16482          clr.b     D0
00005732  6000 007C 16483          bra       OSTmrStart_3
                    16484   OSTmrStart_4:
                    16485   ; }
                    16486   ; OSSchedLock();
00005736  4EB8 115E 16487          jsr       _OSSchedLock
                    16488   ; switch (ptmr->OSTmrState) {
0000573A  2043      16489          move.l    D3,A0
0000573C  1028 0023 16490          move.b    35(A0),D0
00005740  C0BC 0000 16491          and.l     #255,D0
00005744  00FF      
00005746  0C80 0000 16492          cmp.l     #4,D0
0000574A  0004      
0000574C  6400 0058 16493          bhs       OSTmrStart_6
00005750  E380      16494          asl.l     #1,D0
00005752  303B 0806 16495          move.w    OSTmrStart_8(PC,D0.L),D0
00005756  4EFB 0002 16496          jmp       OSTmrStart_8(PC,D0.W)
                    16497   OSTmrStart_8:
0000575A  0040      16498          dc.w      OSTmrStart_12-OSTmrStart_8
0000575C  002A      16499          dc.w      OSTmrStart_10-OSTmrStart_8
0000575E  002A      16500          dc.w      OSTmrStart_10-OSTmrStart_8
00005760  0008      16501          dc.w      OSTmrStart_9-OSTmrStart_8
                    16502   OSTmrStart_9:
                    16503   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16504   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
00005762  2F03      16505          move.l    D3,-(A7)
00005764  4EB9 0000 16506          jsr       @ucos_ii_OSTmr_Unlink
00005768  5BEC      
0000576A  584F      16507          addq.w    #4,A7
                    16508   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
0000576C  42A7      16509          clr.l     -(A7)
0000576E  2F03      16510          move.l    D3,-(A7)
00005770  4EB9 0000 16511          jsr       @ucos_ii_OSTmr_Link
00005774  5B18      
00005776  504F      16512          addq.w    #8,A7
                    16513   ; OSSchedUnlock();
00005778  4E92      16514          jsr       (A2)
                    16515   ; *perr = OS_ERR_NONE;
0000577A  2042      16516          move.l    D2,A0
0000577C  4210      16517          clr.b     (A0)
                    16518   ; return (OS_TRUE);
0000577E  7001      16519          moveq     #1,D0
00005780  6000 002E 16520          bra       OSTmrStart_3
                    16521   OSTmrStart_10:
                    16522   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16523   ; case OS_TMR_STATE_COMPLETED:
                    16524   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005784  42A7      16525          clr.l     -(A7)
00005786  2F03      16526          move.l    D3,-(A7)
00005788  4EB9 0000 16527          jsr       @ucos_ii_OSTmr_Link
0000578C  5B18      
0000578E  504F      16528          addq.w    #8,A7
                    16529   ; OSSchedUnlock();
00005790  4E92      16530          jsr       (A2)
                    16531   ; *perr = OS_ERR_NONE;
00005792  2042      16532          move.l    D2,A0
00005794  4210      16533          clr.b     (A0)
                    16534   ; return (OS_TRUE);
00005796  7001      16535          moveq     #1,D0
00005798  6016      16536          bra.s     OSTmrStart_3
                    16537   OSTmrStart_12:
                    16538   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16539   ; OSSchedUnlock();
0000579A  4E92      16540          jsr       (A2)
                    16541   ; *perr = OS_ERR_TMR_INACTIVE;
0000579C  2042      16542          move.l    D2,A0
0000579E  10BC 0087 16543          move.b    #135,(A0)
                    16544   ; return (OS_FALSE);
000057A2  4200      16545          clr.b     D0
000057A4  600A      16546          bra.s     OSTmrStart_3
                    16547   OSTmrStart_6:
                    16548   ; default:
                    16549   ; OSSchedUnlock();
000057A6  4E92      16550          jsr       (A2)
                    16551   ; *perr = OS_ERR_TMR_INVALID_STATE;
000057A8  2042      16552          move.l    D2,A0
000057AA  10BC 008D 16553          move.b    #141,(A0)
                    16554   ; return (OS_FALSE);
000057AE  4200      16555          clr.b     D0
                    16556   OSTmrStart_3:
000057B0  4CDF 040C 16557          movem.l   (A7)+,D2/D3/A2
000057B4  4E5E      16558          unlk      A6
000057B6  4E75      16559          rts
                    16560   ; }
                    16561   ; }
                    16562   ; #endif
                    16563   ; /*$PAGE*/
                    16564   ; /*
                    16565   ; *********************************************************************************************************
                    16566   ; *                                            STOP A TIMER
                    16567   ; *
                    16568   ; * Description: This function is called by your application code to stop a timer.
                    16569   ; *
                    16570   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16571   ; *
                    16572   ; *              opt           Allows you to specify an option to this functions which can be:
                    16573   ; *
                    16574   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16575   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16576   ; *                                                        callback argument specified when the timer 
                    16577   ; *                                                        was created.
                    16578   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16579   ; *                                                        callback argument specified in THIS function call.
                    16580   ; *
                    16581   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16582   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16583   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16584   ; *
                    16585   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16586   ; *                               OS_ERR_NONE
                    16587   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16588   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16589   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16590   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16591   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16592   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16593   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16594   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16595   ; *
                    16596   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16597   ; *              OS_FALSE      If not
                    16598   ; *********************************************************************************************************
                    16599   ; */
                    16600   ; #if OS_TMR_EN > 0u
                    16601   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16602   ; INT8U    opt,
                    16603   ; void    *callback_arg,
                    16604   ; INT8U   *perr)
                    16605   ; {
                    16606   _OSTmrStop:
000057B8  4E56 0000 16607          link      A6,#0
000057BC  48E7 3820 16608          movem.l   D2/D3/D4/A2,-(A7)
000057C0  242E 0014 16609          move.l    20(A6),D2
000057C4  262E 0008 16610          move.l    8(A6),D3
000057C8  45F8 118E 16611          lea       _OSSchedUnlock.L,A2
                    16612   ; OS_TMR_CALLBACK  pfnct;
                    16613   ; #ifdef OS_SAFETY_CRITICAL
                    16614   ; if (perr == (INT8U *)0) {
                    16615   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16616   ; return (OS_FALSE);
                    16617   ; }
                    16618   ; #endif
                    16619   ; #if OS_ARG_CHK_EN > 0u
                    16620   ; if (ptmr == (OS_TMR *)0) {
                    16621   ; *perr = OS_ERR_TMR_INVALID;
                    16622   ; return (OS_FALSE);
                    16623   ; }
                    16624   ; #endif
                    16625   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
000057CC  2043      16626          move.l    D3,A0
000057CE  1010      16627          move.b    (A0),D0
000057D0  0C00 0064 16628          cmp.b     #100,D0
000057D4  670C      16629          beq.s     OSTmrStop_1
                    16630   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000057D6  2042      16631          move.l    D2,A0
000057D8  10BC 0089 16632          move.b    #137,(A0)
                    16633   ; return (OS_FALSE);
000057DC  4200      16634          clr.b     D0
000057DE  6000 00F2 16635          bra       OSTmrStop_3
                    16636   OSTmrStop_1:
                    16637   ; }
                    16638   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
000057E2  1039 0800 16639          move.b    _OSIntNesting.L,D0
000057E6  0D20      
000057E8  0C00 0000 16640          cmp.b     #0,D0
000057EC  630C      16641          bls.s     OSTmrStop_4
                    16642   ; *perr  = OS_ERR_TMR_ISR;
000057EE  2042      16643          move.l    D2,A0
000057F0  10BC 008B 16644          move.b    #139,(A0)
                    16645   ; return (OS_FALSE);
000057F4  4200      16646          clr.b     D0
000057F6  6000 00DA 16647          bra       OSTmrStop_3
                    16648   OSTmrStop_4:
                    16649   ; }
                    16650   ; OSSchedLock();
000057FA  4EB8 115E 16651          jsr       _OSSchedLock
                    16652   ; switch (ptmr->OSTmrState) {
000057FE  2043      16653          move.l    D3,A0
00005800  1028 0023 16654          move.b    35(A0),D0
00005804  C0BC 0000 16655          and.l     #255,D0
00005808  00FF      
0000580A  0C80 0000 16656          cmp.l     #4,D0
0000580E  0004      
00005810  6400 00B6 16657          bhs       OSTmrStop_6
00005814  E380      16658          asl.l     #1,D0
00005816  303B 0806 16659          move.w    OSTmrStop_8(PC,D0.L),D0
0000581A  4EFB 0002 16660          jmp       OSTmrStop_8(PC,D0.W)
                    16661   OSTmrStop_8:
0000581E  009E      16662          dc.w      OSTmrStop_12-OSTmrStop_8
00005820  0092      16663          dc.w      OSTmrStop_10-OSTmrStop_8
00005822  0092      16664          dc.w      OSTmrStop_10-OSTmrStop_8
00005824  0008      16665          dc.w      OSTmrStop_9-OSTmrStop_8
                    16666   OSTmrStop_9:
                    16667   ; case OS_TMR_STATE_RUNNING:
                    16668   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
00005826  2F03      16669          move.l    D3,-(A7)
00005828  4EB9 0000 16670          jsr       @ucos_ii_OSTmr_Unlink
0000582C  5BEC      
0000582E  584F      16671          addq.w    #4,A7
                    16672   ; *perr = OS_ERR_NONE;
00005830  2042      16673          move.l    D2,A0
00005832  4210      16674          clr.b     (A0)
                    16675   ; switch (opt) {
00005834  102E 000F 16676          move.b    15(A6),D0
00005838  C0BC 0000 16677          and.l     #255,D0
0000583C  00FF      
0000583E  0C80 0000 16678          cmp.l     #3,D0
00005842  0003      
00005844  6718      16679          beq.s     OSTmrStop_16
00005846  620A      16680          bhi.s     OSTmrStop_20
00005848  4A80      16681          tst.l     D0
0000584A  6700 0056 16682          beq       OSTmrStop_18
0000584E  6000 0054 16683          bra       OSTmrStop_14
                    16684   OSTmrStop_20:
00005852  0C80 0000 16685          cmp.l     #4,D0
00005856  0004      
00005858  6728      16686          beq.s     OSTmrStop_17
0000585A  6000 0048 16687          bra       OSTmrStop_14
                    16688   OSTmrStop_16:
                    16689   ; case OS_TMR_OPT_CALLBACK:
                    16690   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000585E  2043      16691          move.l    D3,A0
00005860  2828 0002 16692          move.l    2(A0),D4
                    16693   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005864  4A84      16694          tst.l     D4
00005866  6710      16695          beq.s     OSTmrStop_21
                    16696   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
00005868  2043      16697          move.l    D3,A0
0000586A  2F28 0006 16698          move.l    6(A0),-(A7)
0000586E  2F03      16699          move.l    D3,-(A7)
00005870  2044      16700          move.l    D4,A0
00005872  4E90      16701          jsr       (A0)
00005874  504F      16702          addq.w    #8,A7
00005876  6006      16703          bra.s     OSTmrStop_22
                    16704   OSTmrStop_21:
                    16705   ; } else {
                    16706   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005878  2042      16707          move.l    D2,A0
0000587A  10BC 008F 16708          move.b    #143,(A0)
                    16709   OSTmrStop_22:
                    16710   ; }
                    16711   ; break;
0000587E  6000 002A 16712          bra       OSTmrStop_15
                    16713   OSTmrStop_17:
                    16714   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16715   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005882  2043      16716          move.l    D3,A0
00005884  2828 0002 16717          move.l    2(A0),D4
                    16718   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005888  4A84      16719          tst.l     D4
0000588A  670E      16720          beq.s     OSTmrStop_23
                    16721   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
0000588C  2F2E 0010 16722          move.l    16(A6),-(A7)
00005890  2F03      16723          move.l    D3,-(A7)
00005892  2044      16724          move.l    D4,A0
00005894  4E90      16725          jsr       (A0)
00005896  504F      16726          addq.w    #8,A7
00005898  6006      16727          bra.s     OSTmrStop_24
                    16728   OSTmrStop_23:
                    16729   ; } else {
                    16730   ; *perr = OS_ERR_TMR_NO_CALLBACK;
0000589A  2042      16731          move.l    D2,A0
0000589C  10BC 008F 16732          move.b    #143,(A0)
                    16733   OSTmrStop_24:
                    16734   ; }
                    16735   ; break;
000058A0  6008      16736          bra.s     OSTmrStop_15
                    16737   OSTmrStop_18:
                    16738   ; case OS_TMR_OPT_NONE:
                    16739   ; break;
000058A2  6006      16740          bra.s     OSTmrStop_15
                    16741   OSTmrStop_14:
                    16742   ; default:
                    16743   ; *perr = OS_ERR_TMR_INVALID_OPT;
000058A4  2042      16744          move.l    D2,A0
000058A6  10BC 0084 16745          move.b    #132,(A0)
                    16746   ; break;
                    16747   OSTmrStop_15:
                    16748   ; }
                    16749   ; OSSchedUnlock();
000058AA  4E92      16750          jsr       (A2)
                    16751   ; return (OS_TRUE);
000058AC  7001      16752          moveq     #1,D0
000058AE  6022      16753          bra.s     OSTmrStop_3
                    16754   OSTmrStop_10:
                    16755   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16756   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16757   ; OSSchedUnlock();
000058B0  4E92      16758          jsr       (A2)
                    16759   ; *perr = OS_ERR_TMR_STOPPED;
000058B2  2042      16760          move.l    D2,A0
000058B4  10BC 008E 16761          move.b    #142,(A0)
                    16762   ; return (OS_TRUE);
000058B8  7001      16763          moveq     #1,D0
000058BA  6016      16764          bra.s     OSTmrStop_3
                    16765   OSTmrStop_12:
                    16766   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16767   ; OSSchedUnlock();
000058BC  4E92      16768          jsr       (A2)
                    16769   ; *perr = OS_ERR_TMR_INACTIVE;
000058BE  2042      16770          move.l    D2,A0
000058C0  10BC 0087 16771          move.b    #135,(A0)
                    16772   ; return (OS_FALSE);
000058C4  4200      16773          clr.b     D0
000058C6  600A      16774          bra.s     OSTmrStop_3
                    16775   OSTmrStop_6:
                    16776   ; default:
                    16777   ; OSSchedUnlock();
000058C8  4E92      16778          jsr       (A2)
                    16779   ; *perr = OS_ERR_TMR_INVALID_STATE;
000058CA  2042      16780          move.l    D2,A0
000058CC  10BC 008D 16781          move.b    #141,(A0)
                    16782   ; return (OS_FALSE);
000058D0  4200      16783          clr.b     D0
                    16784   OSTmrStop_3:
000058D2  4CDF 041C 16785          movem.l   (A7)+,D2/D3/D4/A2
000058D6  4E5E      16786          unlk      A6
000058D8  4E75      16787          rts
                    16788   ; }
                    16789   ; }
                    16790   ; #endif
                    16791   ; /*$PAGE*/
                    16792   ; /*
                    16793   ; *********************************************************************************************************
                    16794   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16795   ; *
                    16796   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16797   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16798   ; *
                    16799   ; * Arguments  : none
                    16800   ; *
                    16801   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16802   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16803   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16804   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16805   ; *                                  signaling is created by uC/OS-II.
                    16806   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16807   ; *                                  used for signaling is created by uC/OS-II.
                    16808   ; *********************************************************************************************************
                    16809   ; */
                    16810   ; #if OS_TMR_EN > 0u
                    16811   ; INT8U  OSTmrSignal (void)
                    16812   ; {
                    16813   _OSTmrSignal:
000058DA  4E56 FFFC 16814          link      A6,#-4
                    16815   ; INT8U  err;
                    16816   ; err = OSSemPost(OSTmrSemSignal);
000058DE  2F39 0800 16817          move.l    _OSTmrSemSignal.L,-(A7)
000058E2  17A0      
000058E4  4EB8 444A 16818          jsr       _OSSemPost
000058E8  584F      16819          addq.w    #4,A7
000058EA  1D40 FFFF 16820          move.b    D0,-1(A6)
                    16821   ; return (err);
000058EE  102E FFFF 16822          move.b    -1(A6),D0
000058F2  4E5E      16823          unlk      A6
000058F4  4E75      16824          rts
                    16825   ; }
                    16826   ; #endif
                    16827   ; /*$PAGE*/
                    16828   ; /*
                    16829   ; *********************************************************************************************************
                    16830   ; *                                      ALLOCATE AND FREE A TIMER
                    16831   ; *
                    16832   ; * Description: This function is called to allocate a timer.
                    16833   ; *
                    16834   ; * Arguments  : none
                    16835   ; *
                    16836   ; * Returns    : a pointer to a timer if one is available
                    16837   ; *********************************************************************************************************
                    16838   ; */
                    16839   ; #if OS_TMR_EN > 0u
                    16840   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16841   ; {
                    16842   @ucos_ii_OSTmr_Alloc:
000058F6  48E7 2020 16843          movem.l   D2/A2,-(A7)
000058FA  45F9 0800 16844          lea       _OSTmrFreeList.L,A2
000058FE  19E4      
                    16845   ; OS_TMR *ptmr;
                    16846   ; if (OSTmrFreeList == (OS_TMR *)0) {
00005900  2012      16847          move.l    (A2),D0
00005902  6604      16848          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16849   ; return ((OS_TMR *)0);
00005904  4280      16850          clr.l     D0
00005906  6022      16851          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16852   @ucos_ii_OSTmr_Alloc_1:
                    16853   ; }
                    16854   ; ptmr            = (OS_TMR *)OSTmrFreeList;
00005908  2412      16855          move.l    (A2),D2
                    16856   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
0000590A  2042      16857          move.l    D2,A0
0000590C  24A8 000A 16858          move.l    10(A0),(A2)
                    16859   ; ptmr->OSTmrNext = (OS_TCB *)0;
00005910  2042      16860          move.l    D2,A0
00005912  42A8 000A 16861          clr.l     10(A0)
                    16862   ; ptmr->OSTmrPrev = (OS_TCB *)0;
00005916  2042      16863          move.l    D2,A0
00005918  42A8 000E 16864          clr.l     14(A0)
                    16865   ; OSTmrUsed++;
0000591C  5279 0800 16866          addq.w    #1,_OSTmrUsed.L
00005920  1796      
                    16867   ; OSTmrFree--;
00005922  5379 0800 16868          subq.w    #1,_OSTmrFree.L
00005926  1794      
                    16869   ; return (ptmr);
00005928  2002      16870          move.l    D2,D0
                    16871   @ucos_ii_OSTmr_Alloc_3:
0000592A  4CDF 0404 16872          movem.l   (A7)+,D2/A2
0000592E  4E75      16873          rts
                    16874   ; }
                    16875   ; #endif
                    16876   ; /*
                    16877   ; *********************************************************************************************************
                    16878   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16879   ; *
                    16880   ; * Description: This function is called to return a timer object to the free list of timers.
                    16881   ; *
                    16882   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16883   ; *
                    16884   ; * Returns    : none
                    16885   ; *********************************************************************************************************
                    16886   ; */
                    16887   ; #if OS_TMR_EN > 0u
                    16888   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16889   ; {
                    16890   @ucos_ii_OSTmr_Free:
00005930  4E56 0000 16891          link      A6,#0
00005934  2F02      16892          move.l    D2,-(A7)
00005936  242E 0008 16893          move.l    8(A6),D2
                    16894   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
0000593A  2042      16895          move.l    D2,A0
0000593C  4228 0023 16896          clr.b     35(A0)
                    16897   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
00005940  2042      16898          move.l    D2,A0
00005942  4228 0022 16899          clr.b     34(A0)
                    16900   ; ptmr->OSTmrPeriod      = 0u;
00005946  2042      16901          move.l    D2,A0
00005948  42A8 001A 16902          clr.l     26(A0)
                    16903   ; ptmr->OSTmrMatch       = 0u;
0000594C  2042      16904          move.l    D2,A0
0000594E  42A8 0012 16905          clr.l     18(A0)
                    16906   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
00005952  2042      16907          move.l    D2,A0
00005954  42A8 0002 16908          clr.l     2(A0)
                    16909   ; ptmr->OSTmrCallbackArg = (void *)0;
00005958  2042      16910          move.l    D2,A0
0000595A  42A8 0006 16911          clr.l     6(A0)
                    16912   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16913   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
0000595E  41F9 0000 16914          lea       @ucos_ii_1.L,A0
00005962  6F2A      
00005964  2242      16915          move.l    D2,A1
00005966  2348 001E 16916          move.l    A0,30(A1)
                    16917   ; #endif
                    16918   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
0000596A  2042      16919          move.l    D2,A0
0000596C  42A8 000E 16920          clr.l     14(A0)
                    16921   ; ptmr->OSTmrNext        = OSTmrFreeList;
00005970  2042      16922          move.l    D2,A0
00005972  2179 0800 16923          move.l    _OSTmrFreeList.L,10(A0)
00005976  19E4 000A 
                    16924   ; OSTmrFreeList          = ptmr;
0000597A  23C2 0800 16925          move.l    D2,_OSTmrFreeList.L
0000597E  19E4      
                    16926   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
00005980  5379 0800 16927          subq.w    #1,_OSTmrUsed.L
00005984  1796      
                    16928   ; OSTmrFree++;
00005986  5279 0800 16929          addq.w    #1,_OSTmrFree.L
0000598A  1794      
0000598C  241F      16930          move.l    (A7)+,D2
0000598E  4E5E      16931          unlk      A6
00005990  4E75      16932          rts
                    16933   ; }
                    16934   ; #endif
                    16935   ; /*$PAGE*/
                    16936   ; /*
                    16937   ; *********************************************************************************************************
                    16938   ; *                                                    INITIALIZATION
                    16939   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16940   ; *
                    16941   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16942   ; *
                    16943   ; * Arguments  : none
                    16944   ; *
                    16945   ; * Returns    : none
                    16946   ; *********************************************************************************************************
                    16947   ; */
                    16948   ; #if OS_TMR_EN > 0u
                    16949   ; void  OSTmr_Init (void)
                    16950   ; {
                    16951   _OSTmr_Init:
00005992  4E56 FFF8 16952          link      A6,#-8
00005996  48E7 3020 16953          movem.l   D2/D3/A2,-(A7)
0000599A  45F9 0800 16954          lea       _OSTmrTbl.L,A2
0000599E  17A4      
                    16955   ; #if OS_EVENT_NAME_EN > 0u
                    16956   ; INT8U    err;
                    16957   ; #endif
                    16958   ; INT16U   ix;
                    16959   ; INT16U   ix_next;
                    16960   ; OS_TMR  *ptmr1;
                    16961   ; OS_TMR  *ptmr2;
                    16962   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
000059A0  4878 0240 16963          pea       576
000059A4  2F0A      16964          move.l    A2,-(A7)
000059A6  4EB8 18C2 16965          jsr       _OS_MemClr
000059AA  504F      16966          addq.w    #8,A7
                    16967   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
000059AC  4878 0020 16968          pea       32
000059B0  4879 0800 16969          pea       _OSTmrWheelTbl.L
000059B4  1AE8      
000059B6  4EB8 18C2 16970          jsr       _OS_MemClr
000059BA  504F      16971          addq.w    #8,A7
                    16972   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
000059BC  4243      16973          clr.w     D3
                    16974   OSTmr_Init_1:
000059BE  0C43 000F 16975          cmp.w     #15,D3
000059C2  6400 0056 16976          bhs       OSTmr_Init_3
                    16977   ; ix_next = ix + 1u;
000059C6  3003      16978          move.w    D3,D0
000059C8  5240      16979          addq.w    #1,D0
000059CA  3D40 FFFA 16980          move.w    D0,-6(A6)
                    16981   ; ptmr1 = &OSTmrTbl[ix];
000059CE  200A      16982          move.l    A2,D0
000059D0  C6BC 0000 16983          and.l     #65535,D3
000059D4  FFFF      
000059D6  2203      16984          move.l    D3,D1
000059D8  C3FC 0024 16985          muls      #36,D1
000059DC  D081      16986          add.l     D1,D0
000059DE  2400      16987          move.l    D0,D2
                    16988   ; ptmr2 = &OSTmrTbl[ix_next];
000059E0  200A      16989          move.l    A2,D0
000059E2  322E FFFA 16990          move.w    -6(A6),D1
000059E6  C2BC 0000 16991          and.l     #65535,D1
000059EA  FFFF      
000059EC  C3FC 0024 16992          muls      #36,D1
000059F0  D081      16993          add.l     D1,D0
000059F2  2D40 FFFC 16994          move.l    D0,-4(A6)
                    16995   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000059F6  2042      16996          move.l    D2,A0
000059F8  10BC 0064 16997          move.b    #100,(A0)
                    16998   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000059FC  2042      16999          move.l    D2,A0
000059FE  4228 0023 17000          clr.b     35(A0)
                    17001   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
00005A02  2042      17002          move.l    D2,A0
00005A04  216E FFFC 17003          move.l    -4(A6),10(A0)
00005A08  000A      
                    17004   ; #if OS_TMR_CFG_NAME_EN > 0u
                    17005   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005A0A  41F9 0000 17006          lea       @ucos_ii_1.L,A0
00005A0E  6F2A      
00005A10  2242      17007          move.l    D2,A1
00005A12  2348 001E 17008          move.l    A0,30(A1)
00005A16  5243      17009          addq.w    #1,D3
00005A18  60A4      17010          bra       OSTmr_Init_1
                    17011   OSTmr_Init_3:
                    17012   ; #endif
                    17013   ; }
                    17014   ; ptmr1               = &OSTmrTbl[ix];
00005A1A  200A      17015          move.l    A2,D0
00005A1C  C6BC 0000 17016          and.l     #65535,D3
00005A20  FFFF      
00005A22  2203      17017          move.l    D3,D1
00005A24  C3FC 0024 17018          muls      #36,D1
00005A28  D081      17019          add.l     D1,D0
00005A2A  2400      17020          move.l    D0,D2
                    17021   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
00005A2C  2042      17022          move.l    D2,A0
00005A2E  10BC 0064 17023          move.b    #100,(A0)
                    17024   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
00005A32  2042      17025          move.l    D2,A0
00005A34  4228 0023 17026          clr.b     35(A0)
                    17027   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005A38  2042      17028          move.l    D2,A0
00005A3A  42A8 000A 17029          clr.l     10(A0)
                    17030   ; #if OS_TMR_CFG_NAME_EN > 0u
                    17031   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005A3E  41F9 0000 17032          lea       @ucos_ii_1.L,A0
00005A42  6F2A      
00005A44  2242      17033          move.l    D2,A1
00005A46  2348 001E 17034          move.l    A0,30(A1)
                    17035   ; #endif
                    17036   ; OSTmrTime           = 0u;
00005A4A  42B9 0800 17037          clr.l     _OSTmrTime.L
00005A4E  1798      
                    17038   ; OSTmrUsed           = 0u;
00005A50  4279 0800 17039          clr.w     _OSTmrUsed.L
00005A54  1796      
                    17040   ; OSTmrFree           = OS_TMR_CFG_MAX;
00005A56  33FC 0010 17041          move.w    #16,_OSTmrFree.L
00005A5A  0800 1794 
                    17042   ; OSTmrFreeList       = &OSTmrTbl[0];
00005A5E  23CA 0800 17043          move.l    A2,_OSTmrFreeList.L
00005A62  19E4      
                    17044   ; OSTmrSem            = OSSemCreate(1u);
00005A64  4878 0001 17045          pea       1
00005A68  4EB8 4102 17046          jsr       _OSSemCreate
00005A6C  584F      17047          addq.w    #4,A7
00005A6E  23C0 0800 17048          move.l    D0,_OSTmrSem.L
00005A72  179C      
                    17049   ; OSTmrSemSignal      = OSSemCreate(0u);
00005A74  42A7      17050          clr.l     -(A7)
00005A76  4EB8 4102 17051          jsr       _OSSemCreate
00005A7A  584F      17052          addq.w    #4,A7
00005A7C  23C0 0800 17053          move.l    D0,_OSTmrSemSignal.L
00005A80  17A0      
                    17054   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    17055   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
00005A82  486E FFF9 17056          pea       -7(A6)
00005A86  4879 0000 17057          pea       @ucos_ii_4.L
00005A8A  6F48      
00005A8C  2F39 0800 17058          move.l    _OSTmrSem.L,-(A7)
00005A90  179C      
00005A92  4EB8 0CD0 17059          jsr       _OSEventNameSet
00005A96  DEFC 000C 17060          add.w     #12,A7
                    17061   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
00005A9A  486E FFF9 17062          pea       -7(A6)
00005A9E  4879 0000 17063          pea       @ucos_ii_5.L
00005AA2  6F5A      
00005AA4  2F39 0800 17064          move.l    _OSTmrSemSignal.L,-(A7)
00005AA8  17A0      
00005AAA  4EB8 0CD0 17065          jsr       _OSEventNameSet
00005AAE  DEFC 000C 17066          add.w     #12,A7
                    17067   ; #endif
                    17068   ; OSTmr_InitTask();
00005AB2  4EB9 0000 17069          jsr       @ucos_ii_OSTmr_InitTask
00005AB6  5AC0      
00005AB8  4CDF 040C 17070          movem.l   (A7)+,D2/D3/A2
00005ABC  4E5E      17071          unlk      A6
00005ABE  4E75      17072          rts
                    17073   ; }
                    17074   ; #endif
                    17075   ; /*$PAGE*/
                    17076   ; /*
                    17077   ; *********************************************************************************************************
                    17078   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    17079   ; *
                    17080   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    17081   ; *                               * Arguments  : none
                    17082   ; *
                    17083   ; * Returns    : none
                    17084   ; *********************************************************************************************************
                    17085   ; */
                    17086   ; #if OS_TMR_EN > 0u
                    17087   ; static  void  OSTmr_InitTask (void)
                    17088   ; {
                    17089   @ucos_ii_OSTmr_InitTask:
00005AC0  4E56 FFFC 17090          link      A6,#-4
                    17091   ; #if OS_TASK_NAME_EN > 0u
                    17092   ; INT8U  err;
                    17093   ; #endif
                    17094   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    17095   ; #if OS_STK_GROWTH == 1u
                    17096   ; (void)OSTaskCreateExt(OSTmr_Task,
00005AC4  4878 0003 17097          pea       3
00005AC8  42A7      17098          clr.l     -(A7)
00005ACA  4878 0080 17099          pea       128
00005ACE  4879 0800 17100          pea       _OSTmrTaskStk.L
00005AD2  19E8      
00005AD4  4878 FFFD 17101          pea       65533
00005AD8  4878 0005 17102          pea       5
00005ADC  41F9 0800 17103          lea       _OSTmrTaskStk.L,A0
00005AE0  19E8      
00005AE2  D0FC 00FE 17104          add.w     #254,A0
00005AE6  2F08      17105          move.l    A0,-(A7)
00005AE8  42A7      17106          clr.l     -(A7)
00005AEA  4879 0000 17107          pea       @ucos_ii_OSTmr_Task.L
00005AEE  5C8A      
00005AF0  4EB8 4878 17108          jsr       _OSTaskCreateExt
00005AF4  DEFC 0024 17109          add.w     #36,A7
00005AF8  C0BC 0000 17110          and.l     #255,D0
00005AFC  00FF      
                    17111   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17112   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    17113   ; OS_TASK_TMR_PRIO,
                    17114   ; OS_TASK_TMR_ID,
                    17115   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    17116   ; OS_TASK_TMR_STK_SIZE,
                    17117   ; (void *)0,                                       /* No TCB extension                        */
                    17118   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17119   ; #else
                    17120   ; (void)OSTaskCreateExt(OSTmr_Task,
                    17121   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    17122   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    17123   ; OS_TASK_TMR_PRIO,
                    17124   ; OS_TASK_TMR_ID,
                    17125   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    17126   ; OS_TASK_TMR_STK_SIZE,
                    17127   ; (void *)0,                                       /* No TCB extension                        */
                    17128   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    17129   ; #endif
                    17130   ; #else
                    17131   ; #if OS_STK_GROWTH == 1u
                    17132   ; (void)OSTaskCreate(OSTmr_Task,
                    17133   ; (void *)0,
                    17134   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    17135   ; OS_TASK_TMR_PRIO);
                    17136   ; #else
                    17137   ; (void)OSTaskCreate(OSTmr_Task,
                    17138   ; (void *)0,
                    17139   ; &OSTmrTaskStk[0],
                    17140   ; OS_TASK_TMR_PRIO);
                    17141   ; #endif
                    17142   ; #endif
                    17143   ; #if OS_TASK_NAME_EN > 0u
                    17144   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
00005AFE  486E FFFF 17145          pea       -1(A6)
00005B02  4879 0000 17146          pea       @ucos_ii_6.L
00005B06  6F6E      
00005B08  4878 0005 17147          pea       5
00005B0C  4EB8 4C84 17148          jsr       _OSTaskNameSet
00005B10  DEFC 000C 17149          add.w     #12,A7
00005B14  4E5E      17150          unlk      A6
00005B16  4E75      17151          rts
                    17152   ; #endif
                    17153   ; }
                    17154   ; #endif
                    17155   ; /*$PAGE*/
                    17156   ; /*
                    17157   ; *********************************************************************************************************
                    17158   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    17159   ; *
                    17160   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    17161   ; *              inserted at the beginning of the list.
                    17162   ; *
                    17163   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    17164   ; *
                    17165   ; *              type          Is either:
                    17166   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    17167   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    17168   ; *
                    17169   ; * Returns    : none
                    17170   ; *********************************************************************************************************
                    17171   ; */
                    17172   ; #if OS_TMR_EN > 0u
                    17173   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    17174   ; INT8U    type)
                    17175   ; {
                    17176   @ucos_ii_OSTmr_Link:
00005B18  4E56 FFFC 17177          link      A6,#-4
00005B1C  48E7 3820 17178          movem.l   D2/D3/D4/A2,-(A7)
00005B20  242E 0008 17179          move.l    8(A6),D2
00005B24  45F9 0800 17180          lea       _OSTmrTime.L,A2
00005B28  1798      
                    17181   ; OS_TMR       *ptmr1;
                    17182   ; OS_TMR_WHEEL *pspoke;
                    17183   ; INT16U        spoke;
                    17184   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
00005B2A  2042      17185          move.l    D2,A0
00005B2C  117C 0003 17186          move.b    #3,35(A0)
00005B30  0023      
                    17187   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00005B32  102E 000F 17188          move.b    15(A6),D0
00005B36  0C00 0001 17189          cmp.b     #1,D0
00005B3A  6610      17190          bne.s     @ucos_ii_OSTmr_Link_1
                    17191   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005B3C  2042      17192          move.l    D2,A0
00005B3E  2028 001A 17193          move.l    26(A0),D0
00005B42  D092      17194          add.l     (A2),D0
00005B44  2042      17195          move.l    D2,A0
00005B46  2140 0012 17196          move.l    D0,18(A0)
00005B4A  6026      17197          bra.s     @ucos_ii_OSTmr_Link_4
                    17198   @ucos_ii_OSTmr_Link_1:
                    17199   ; } else {
                    17200   ; if (ptmr->OSTmrDly == 0u) {
00005B4C  2042      17201          move.l    D2,A0
00005B4E  2028 0016 17202          move.l    22(A0),D0
00005B52  6610      17203          bne.s     @ucos_ii_OSTmr_Link_3
                    17204   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005B54  2042      17205          move.l    D2,A0
00005B56  2028 001A 17206          move.l    26(A0),D0
00005B5A  D092      17207          add.l     (A2),D0
00005B5C  2042      17208          move.l    D2,A0
00005B5E  2140 0012 17209          move.l    D0,18(A0)
00005B62  600E      17210          bra.s     @ucos_ii_OSTmr_Link_4
                    17211   @ucos_ii_OSTmr_Link_3:
                    17212   ; } else {
                    17213   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00005B64  2042      17214          move.l    D2,A0
00005B66  2028 0016 17215          move.l    22(A0),D0
00005B6A  D092      17216          add.l     (A2),D0
00005B6C  2042      17217          move.l    D2,A0
00005B6E  2140 0012 17218          move.l    D0,18(A0)
                    17219   @ucos_ii_OSTmr_Link_4:
                    17220   ; }
                    17221   ; }
                    17222   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005B72  2002      17223          move.l    D2,D0
00005B74  0680 0000 17224          add.l     #18,D0
00005B78  0012      
00005B7A  2040      17225          move.l    D0,A0
00005B7C  2F10      17226          move.l    (A0),-(A7)
00005B7E  4878 0008 17227          pea       8
00005B82  4EB9 0000 17228          jsr       ULDIV
00005B86  64FC      
00005B88  202F 0004 17229          move.l    4(A7),D0
00005B8C  504F      17230          addq.w    #8,A7
00005B8E  3D40 FFFE 17231          move.w    D0,-2(A6)
                    17232   ; pspoke = &OSTmrWheelTbl[spoke];
00005B92  41F9 0800 17233          lea       _OSTmrWheelTbl.L,A0
00005B96  1AE8      
00005B98  302E FFFE 17234          move.w    -2(A6),D0
00005B9C  C0BC 0000 17235          and.l     #65535,D0
00005BA0  FFFF      
00005BA2  E588      17236          lsl.l     #2,D0
00005BA4  D1C0      17237          add.l     D0,A0
00005BA6  2608      17238          move.l    A0,D3
                    17239   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005BA8  2043      17240          move.l    D3,A0
00005BAA  2010      17241          move.l    (A0),D0
00005BAC  6614      17242          bne.s     @ucos_ii_OSTmr_Link_5
                    17243   ; pspoke->OSTmrFirst   = ptmr;
00005BAE  2043      17244          move.l    D3,A0
00005BB0  2082      17245          move.l    D2,(A0)
                    17246   ; ptmr->OSTmrNext      = (OS_TMR *)0;
00005BB2  2042      17247          move.l    D2,A0
00005BB4  42A8 000A 17248          clr.l     10(A0)
                    17249   ; pspoke->OSTmrEntries = 1u;
00005BB8  2043      17250          move.l    D3,A0
00005BBA  317C 0001 17251          move.w    #1,4(A0)
00005BBE  0004      
00005BC0  601C      17252          bra.s     @ucos_ii_OSTmr_Link_6
                    17253   @ucos_ii_OSTmr_Link_5:
                    17254   ; } else {
                    17255   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
00005BC2  2043      17256          move.l    D3,A0
00005BC4  2810      17257          move.l    (A0),D4
                    17258   ; pspoke->OSTmrFirst   = ptmr;
00005BC6  2043      17259          move.l    D3,A0
00005BC8  2082      17260          move.l    D2,(A0)
                    17261   ; ptmr->OSTmrNext      = (void *)ptmr1;
00005BCA  2042      17262          move.l    D2,A0
00005BCC  2144 000A 17263          move.l    D4,10(A0)
                    17264   ; ptmr1->OSTmrPrev     = (void *)ptmr;
00005BD0  2044      17265          move.l    D4,A0
00005BD2  2142 000E 17266          move.l    D2,14(A0)
                    17267   ; pspoke->OSTmrEntries++;
00005BD6  2003      17268          move.l    D3,D0
00005BD8  5880      17269          addq.l    #4,D0
00005BDA  2040      17270          move.l    D0,A0
00005BDC  5250      17271          addq.w    #1,(A0)
                    17272   @ucos_ii_OSTmr_Link_6:
                    17273   ; }
                    17274   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005BDE  2042      17275          move.l    D2,A0
00005BE0  42A8 000E 17276          clr.l     14(A0)
00005BE4  4CDF 041C 17277          movem.l   (A7)+,D2/D3/D4/A2
00005BE8  4E5E      17278          unlk      A6
00005BEA  4E75      17279          rts
                    17280   ; }
                    17281   ; #endif
                    17282   ; /*$PAGE*/
                    17283   ; /*
                    17284   ; *********************************************************************************************************
                    17285   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    17286   ; *
                    17287   ; * Description: This function is called to remove the timer from the timer wheel.
                    17288   ; *
                    17289   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    17290   ; *
                    17291   ; * Returns    : none
                    17292   ; *********************************************************************************************************
                    17293   ; */
                    17294   ; #if OS_TMR_EN > 0u
                    17295   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    17296   ; {
                    17297   @ucos_ii_OSTmr_Unlink:
00005BEC  4E56 FFFC 17298          link      A6,#-4
00005BF0  48E7 3C00 17299          movem.l   D2/D3/D4/D5,-(A7)
00005BF4  242E 0008 17300          move.l    8(A6),D2
                    17301   ; OS_TMR        *ptmr1;
                    17302   ; OS_TMR        *ptmr2;
                    17303   ; OS_TMR_WHEEL  *pspoke;
                    17304   ; INT16U         spoke;
                    17305   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
00005BF8  2002      17306          move.l    D2,D0
00005BFA  0680 0000 17307          add.l     #18,D0
00005BFE  0012      
00005C00  2040      17308          move.l    D0,A0
00005C02  2F10      17309          move.l    (A0),-(A7)
00005C04  4878 0008 17310          pea       8
00005C08  4EB9 0000 17311          jsr       ULDIV
00005C0C  64FC      
00005C0E  202F 0004 17312          move.l    4(A7),D0
00005C12  504F      17313          addq.w    #8,A7
00005C14  3D40 FFFE 17314          move.w    D0,-2(A6)
                    17315   ; pspoke = &OSTmrWheelTbl[spoke];
00005C18  41F9 0800 17316          lea       _OSTmrWheelTbl.L,A0
00005C1C  1AE8      
00005C1E  302E FFFE 17317          move.w    -2(A6),D0
00005C22  C0BC 0000 17318          and.l     #65535,D0
00005C26  FFFF      
00005C28  E588      17319          lsl.l     #2,D0
00005C2A  D1C0      17320          add.l     D0,A0
00005C2C  2A08      17321          move.l    A0,D5
                    17322   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00005C2E  2045      17323          move.l    D5,A0
00005C30  B490      17324          cmp.l     (A0),D2
00005C32  6616      17325          bne.s     @ucos_ii_OSTmr_Unlink_1
                    17326   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
00005C34  2042      17327          move.l    D2,A0
00005C36  2628 000A 17328          move.l    10(A0),D3
                    17329   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
00005C3A  2045      17330          move.l    D5,A0
00005C3C  2083      17331          move.l    D3,(A0)
                    17332   ; if (ptmr1 != (OS_TMR *)0) {
00005C3E  4A83      17333          tst.l     D3
00005C40  6706      17334          beq.s     @ucos_ii_OSTmr_Unlink_3
                    17335   ; ptmr1->OSTmrPrev = (void *)0;
00005C42  2043      17336          move.l    D3,A0
00005C44  42A8 000E 17337          clr.l     14(A0)
                    17338   @ucos_ii_OSTmr_Unlink_3:
00005C48  601C      17339          bra.s     @ucos_ii_OSTmr_Unlink_5
                    17340   @ucos_ii_OSTmr_Unlink_1:
                    17341   ; }
                    17342   ; } else {
                    17343   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00005C4A  2042      17344          move.l    D2,A0
00005C4C  2628 000E 17345          move.l    14(A0),D3
                    17346   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
00005C50  2042      17347          move.l    D2,A0
00005C52  2828 000A 17348          move.l    10(A0),D4
                    17349   ; ptmr1->OSTmrNext = ptmr2;
00005C56  2043      17350          move.l    D3,A0
00005C58  2144 000A 17351          move.l    D4,10(A0)
                    17352   ; if (ptmr2 != (OS_TMR *)0) {
00005C5C  4A84      17353          tst.l     D4
00005C5E  6706      17354          beq.s     @ucos_ii_OSTmr_Unlink_5
                    17355   ; ptmr2->OSTmrPrev = (void *)ptmr1;
00005C60  2044      17356          move.l    D4,A0
00005C62  2143 000E 17357          move.l    D3,14(A0)
                    17358   @ucos_ii_OSTmr_Unlink_5:
                    17359   ; }
                    17360   ; }
                    17361   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005C66  2042      17362          move.l    D2,A0
00005C68  117C 0001 17363          move.b    #1,35(A0)
00005C6C  0023      
                    17364   ; ptmr->OSTmrNext  = (void *)0;
00005C6E  2042      17365          move.l    D2,A0
00005C70  42A8 000A 17366          clr.l     10(A0)
                    17367   ; ptmr->OSTmrPrev  = (void *)0;
00005C74  2042      17368          move.l    D2,A0
00005C76  42A8 000E 17369          clr.l     14(A0)
                    17370   ; pspoke->OSTmrEntries--;
00005C7A  2005      17371          move.l    D5,D0
00005C7C  5880      17372          addq.l    #4,D0
00005C7E  2040      17373          move.l    D0,A0
00005C80  5350      17374          subq.w    #1,(A0)
00005C82  4CDF 003C 17375          movem.l   (A7)+,D2/D3/D4/D5
00005C86  4E5E      17376          unlk      A6
00005C88  4E75      17377          rts
                    17378   ; }
                    17379   ; #endif
                    17380   ; /*$PAGE*/
                    17381   ; /*
                    17382   ; *********************************************************************************************************
                    17383   ; *                                        TIMER MANAGEMENT TASK
                    17384   ; *
                    17385   ; * Description: This task is created by OSTmrInit().
                    17386   ; *
                    17387   ; * Arguments  : none
                    17388   ; *
                    17389   ; * Returns    : none
                    17390   ; *********************************************************************************************************
                    17391   ; */
                    17392   ; #if OS_TMR_EN > 0u
                    17393   ; static  void  OSTmr_Task (void *p_arg)
                    17394   ; {
                    17395   @ucos_ii_OSTmr_Task:
00005C8A  4E56 FFF4 17396          link      A6,#-12
00005C8E  48E7 3020 17397          movem.l   D2/D3/A2,-(A7)
00005C92  45F9 0800 17398          lea       _OSTmrTime.L,A2
00005C96  1798      
                    17399   ; INT8U            err;
                    17400   ; OS_TMR          *ptmr;
                    17401   ; OS_TMR          *ptmr_next;
                    17402   ; OS_TMR_CALLBACK  pfnct;
                    17403   ; OS_TMR_WHEEL    *pspoke;
                    17404   ; INT16U           spoke;
                    17405   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17406   ; for (;;) {
                    17407   @ucos_ii_OSTmr_Task_1:
                    17408   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005C98  486E FFF5 17409          pea       -11(A6)
00005C9C  42A7      17410          clr.l     -(A7)
00005C9E  2F39 0800 17411          move.l    _OSTmrSemSignal.L,-(A7)
00005CA2  17A0      
00005CA4  4EB8 4288 17412          jsr       _OSSemPend
00005CA8  DEFC 000C 17413          add.w     #12,A7
                    17414   ; OSSchedLock();
00005CAC  4EB8 115E 17415          jsr       _OSSchedLock
                    17416   ; OSTmrTime++;                                             /* Increment the current time                        */
00005CB0  5292      17417          addq.l    #1,(A2)
                    17418   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
00005CB2  2F12      17419          move.l    (A2),-(A7)
00005CB4  4878 0008 17420          pea       8
00005CB8  4EB9 0000 17421          jsr       ULDIV
00005CBC  64FC      
00005CBE  202F 0004 17422          move.l    4(A7),D0
00005CC2  504F      17423          addq.w    #8,A7
00005CC4  3D40 FFFE 17424          move.w    D0,-2(A6)
                    17425   ; pspoke = &OSTmrWheelTbl[spoke];
00005CC8  41F9 0800 17426          lea       _OSTmrWheelTbl.L,A0
00005CCC  1AE8      
00005CCE  302E FFFE 17427          move.w    -2(A6),D0
00005CD2  C0BC 0000 17428          and.l     #65535,D0
00005CD6  FFFF      
00005CD8  E588      17429          lsl.l     #2,D0
00005CDA  D1C0      17430          add.l     D0,A0
00005CDC  2D48 FFFA 17431          move.l    A0,-6(A6)
                    17432   ; ptmr   = pspoke->OSTmrFirst;
00005CE0  206E FFFA 17433          move.l    -6(A6),A0
00005CE4  2410      17434          move.l    (A0),D2
                    17435   ; while (ptmr != (OS_TMR *)0) {
                    17436   @ucos_ii_OSTmr_Task_4:
00005CE6  4A82      17437          tst.l     D2
00005CE8  6700 005E 17438          beq       @ucos_ii_OSTmr_Task_6
                    17439   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
00005CEC  2042      17440          move.l    D2,A0
00005CEE  2D68 000A 17441          move.l    10(A0),-10(A6)
00005CF2  FFF6      
                    17442   ; /* ... timer could get unlinked from the wheel.      */
                    17443   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
00005CF4  2042      17444          move.l    D2,A0
00005CF6  2012      17445          move.l    (A2),D0
00005CF8  B0A8 0012 17446          cmp.l     18(A0),D0
00005CFC  6600 0044 17447          bne       @ucos_ii_OSTmr_Task_11
                    17448   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
00005D00  2F02      17449          move.l    D2,-(A7)
00005D02  4EB8 5BEC 17450          jsr       @ucos_ii_OSTmr_Unlink
00005D06  584F      17451          addq.w    #4,A7
                    17452   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
00005D08  2042      17453          move.l    D2,A0
00005D0A  1028 0022 17454          move.b    34(A0),D0
00005D0E  0C00 0002 17455          cmp.b     #2,D0
00005D12  660E      17456          bne.s     @ucos_ii_OSTmr_Task_9
                    17457   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
00005D14  4878 0001 17458          pea       1
00005D18  2F02      17459          move.l    D2,-(A7)
00005D1A  4EB8 5B18 17460          jsr       @ucos_ii_OSTmr_Link
00005D1E  504F      17461          addq.w    #8,A7
00005D20  6008      17462          bra.s     @ucos_ii_OSTmr_Task_10
                    17463   @ucos_ii_OSTmr_Task_9:
                    17464   ; } else {
                    17465   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00005D22  2042      17466          move.l    D2,A0
00005D24  117C 0002 17467          move.b    #2,35(A0)
00005D28  0023      
                    17468   @ucos_ii_OSTmr_Task_10:
                    17469   ; }
                    17470   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005D2A  2042      17471          move.l    D2,A0
00005D2C  2628 0002 17472          move.l    2(A0),D3
                    17473   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005D30  4A83      17474          tst.l     D3
00005D32  670E      17475          beq.s     @ucos_ii_OSTmr_Task_11
                    17476   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
00005D34  2042      17477          move.l    D2,A0
00005D36  2F28 0006 17478          move.l    6(A0),-(A7)
00005D3A  2F02      17479          move.l    D2,-(A7)
00005D3C  2043      17480          move.l    D3,A0
00005D3E  4E90      17481          jsr       (A0)
00005D40  504F      17482          addq.w    #8,A7
                    17483   @ucos_ii_OSTmr_Task_11:
                    17484   ; }
                    17485   ; }
                    17486   ; ptmr = ptmr_next;
00005D42  242E FFF6 17487          move.l    -10(A6),D2
00005D46  609E      17488          bra       @ucos_ii_OSTmr_Task_4
                    17489   @ucos_ii_OSTmr_Task_6:
                    17490   ; }
                    17491   ; OSSchedUnlock();
00005D48  4EB8 118E 17492          jsr       _OSSchedUnlock
00005D4C  6000 FF4A 17493          bra       @ucos_ii_OSTmr_Task_1
                    17494   ; /*
                    17495   ; *********************************************************************************************************
                    17496   ; *                                                uC/OS-II
                    17497   ; *                                          The Real-Time Kernel
                    17498   ; *
                    17499   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17500   ; *                                           All Rights Reserved
                    17501   ; *
                    17502   ; * File    : uCOS_II.C
                    17503   ; * By      : Jean J. Labrosse
                    17504   ; * Version : V2.91
                    17505   ; *
                    17506   ; * LICENSING TERMS:
                    17507   ; * ---------------
                    17508   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17509   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriï¿½m to properly license 
                    17510   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17511   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17512   ; * licensing fee.
                    17513   ; *********************************************************************************************************
                    17514   ; */
                    17515   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17516   ; #include "ucos_ii.h"
                    17517   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17518   ; #include "os_core.c"
                    17519   ; #include "os_flag.c"
                    17520   ; #include "os_mbox.c"
                    17521   ; #include "os_mem.c"
                    17522   ; #include "os_mutex.c"
                    17523   ; #include "os_q.c"
                    17524   ; #include "os_sem.c"
                    17525   ; #include "os_task.c"
                    17526   ; #include "os_time.c"
                    17527   ; #include "os_tmr.c"
                    17528   ; C:\CPEN412\ASN6\ASN6B_THREADS\BIOS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17529   ; #include "Bios.h"
                    17530   ; /*
                    17531   ; **  These basic IO routines are designed to handle input and output of characters
                    17532   ; **  via the serial port to the console of hyperternal
                    17533   ; **
                    17534   ; **  You need to include this code into your projects, either as a source file, or copy into your code
                    17535   ; */
                    17536   ; // things that need to be done at initialisation/boot include
                    17537   ; // 1) initialise serial port and LCD display
                    17538   ; // 2) initialise the LCD display
                    17539   ; // 3) install the trap handler for a context switch (trap0)
                    17540   ; // 4) install the TickISR for level 3 IRQ
                    17541   ; // these actions can be performed in OSInitHookBegin() in file OS_CPU_C.c (one the Port files)
                    17542   ; /*********************************************************************************************
                    17543   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    17544   ; *********************************************************************************************/
                    17545   ; void Init_RS232(void)
                    17546   ; {
                    17547   _Init_RS232:
                    17548   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00005D50  13FC 0015 17549          move.b    #21,4194368
00005D54  0040 0040 
                    17550   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00005D58  13FC 0001 17551          move.b    #1,4194372
00005D5C  0040 0044 
00005D60  4E75      17552          rts
                    17553   ; }
                    17554   ; int kbhit(void)
                    17555   ; {
                    17556   _kbhit:
                    17557   ; if(((char)(RS232_Status) & (char)(0x02)) == (char)(0x02))    // wait for Tx bit in status register to be '1'
00005D62  1039 0040 17558          move.b    4194368,D0
00005D66  0040      
00005D68  C03C 0002 17559          and.b     #2,D0
00005D6C  0C00 0002 17560          cmp.b     #2,D0
00005D70  6604      17561          bne.s     kbhit_1
                    17562   ; return 1 ;
00005D72  7001      17563          moveq     #1,D0
00005D74  6002      17564          bra.s     kbhit_3
                    17565   kbhit_1:
                    17566   ; else
                    17567   ; return 0 ;
00005D76  4280      17568          clr.l     D0
                    17569   kbhit_3:
00005D78  4E75      17570          rts
                    17571   ; }
                    17572   ; /*********************************************************************************************************
                    17573   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    17574   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    17575   ; **  to allow the board to communicate with HyperTerminal Program
                    17576   ; **
                    17577   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    17578   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    17579   ; **  call _putch() also
                    17580   ; *********************************************************************************************************/
                    17581   ; int _putch( int c)
                    17582   ; {
                    17583   __putch:
00005D7A  4E56 0000 17584          link      A6,#0
                    17585   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    17586   _putch_1:
00005D7E  1039 0040 17587          move.b    4194368,D0
00005D82  0040      
00005D84  C03C 0002 17588          and.b     #2,D0
00005D88  0C00 0002 17589          cmp.b     #2,D0
00005D8C  6702      17590          beq.s     _putch_3
00005D8E  60EE      17591          bra       _putch_1
                    17592   _putch_3:
                    17593   ; ;
                    17594   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00005D90  202E 0008 17595          move.l    8(A6),D0
00005D94  C03C 007F 17596          and.b     #127,D0
00005D98  13C0 0040 17597          move.b    D0,4194370
00005D9C  0042      
                    17598   ; return c ;                                              // putchar() expects the character to be returned
00005D9E  202E 0008 17599          move.l    8(A6),D0
00005DA2  4E5E      17600          unlk      A6
00005DA4  4E75      17601          rts
                    17602   ; }
                    17603   ; /*********************************************************************************************************
                    17604   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    17605   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    17606   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    17607   ; **
                    17608   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    17609   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    17610   ; **  call _getch() also
                    17611   ; *********************************************************************************************************/
                    17612   ; int _getch( void )
                    17613   ; {
                    17614   __getch:
00005DA6  2F02      17615          move.l    D2,-(A7)
                    17616   ; int c ;
                    17617   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    17618   _getch_1:
00005DA8  1039 0040 17619          move.b    4194368,D0
00005DAC  0040      
00005DAE  C03C 0001 17620          and.b     #1,D0
00005DB2  0C00 0001 17621          cmp.b     #1,D0
00005DB6  6702      17622          beq.s     _getch_3
00005DB8  60EE      17623          bra       _getch_1
                    17624   _getch_3:
                    17625   ; ;
                    17626   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00005DBA  1039 0040 17627          move.b    4194370,D0
00005DBE  0042      
00005DC0  C0BC 0000 17628          and.l     #255,D0
00005DC4  00FF      
00005DC6  C0BC 0000 17629          and.l     #127,D0
00005DCA  007F      
00005DCC  2400      17630          move.l    D0,D2
                    17631   ; _putch(c);
00005DCE  2F02      17632          move.l    D2,-(A7)
00005DD0  4EB8 5D7A 17633          jsr       __putch
00005DD4  584F      17634          addq.w    #4,A7
                    17635   ; return c ;
00005DD6  2002      17636          move.l    D2,D0
00005DD8  241F      17637          move.l    (A7)+,D2
00005DDA  4E75      17638          rts
                    17639   ; }
                    17640   ; /************************************************************************************
                    17641   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    17642   ; ************************************************************************************/
                    17643   ; void Wait1ms(void)
                    17644   ; {
                    17645   _Wait1ms:
00005DDC  2F02      17646          move.l    D2,-(A7)
                    17647   ; long int  i ;
                    17648   ; for(i = 0; i < 1000; i ++)
00005DDE  4282      17649          clr.l     D2
                    17650   Wait1ms_1:
00005DE0  0C82 0000 17651          cmp.l     #1000,D2
00005DE4  03E8      
00005DE6  6C04      17652          bge.s     Wait1ms_3
00005DE8  5282      17653          addq.l    #1,D2
00005DEA  60F4      17654          bra       Wait1ms_1
                    17655   Wait1ms_3:
00005DEC  241F      17656          move.l    (A7)+,D2
00005DEE  4E75      17657          rts
                    17658   ; ;
                    17659   ; }
                    17660   ; /************************************************************************************
                    17661   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    17662   ; **************************************************************************************/
                    17663   ; void Wait3ms(void)
                    17664   ; {
                    17665   _Wait3ms:
00005DF0  2F02      17666          move.l    D2,-(A7)
                    17667   ; int i ;
                    17668   ; for(i = 0; i < 3; i++)
00005DF2  4282      17669          clr.l     D2
                    17670   Wait3ms_1:
00005DF4  0C82 0000 17671          cmp.l     #3,D2
00005DF8  0003      
00005DFA  6C08      17672          bge.s     Wait3ms_3
                    17673   ; Wait1ms() ;
00005DFC  4EB8 5DDC 17674          jsr       _Wait1ms
00005E00  5282      17675          addq.l    #1,D2
00005E02  60F0      17676          bra       Wait3ms_1
                    17677   Wait3ms_3:
00005E04  241F      17678          move.l    (A7)+,D2
00005E06  4E75      17679          rts
                    17680   ; }
                    17681   ; /*********************************************************************************************
                    17682   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    17683   ; *********************************************************************************************/
                    17684   ; void Init_LCD(void)
                    17685   ; {
                    17686   _Init_LCD:
                    17687   ; LCDcommand = (char)(0x0c) ;
00005E08  13FC 000C 17688          move.b    #12,4194336
00005E0C  0040 0020 
                    17689   ; Wait3ms() ;
00005E10  4EB8 5DF0 17690          jsr       _Wait3ms
                    17691   ; LCDcommand = (char)(0x38) ;
00005E14  13FC 0038 17692          move.b    #56,4194336
00005E18  0040 0020 
                    17693   ; Wait3ms() ;
00005E1C  4EB8 5DF0 17694          jsr       _Wait3ms
00005E20  4E75      17695          rts
                    17696   ; }
                    17697   ; /******************************************************************************
                    17698   ; *subroutine to output a single character held in d1 to the LCD display
                    17699   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    17700   ; *current cursor position
                    17701   ; *******************************************************************************/
                    17702   ; void Outchar(int c)
                    17703   ; {
                    17704   _Outchar:
00005E22  4E56 0000 17705          link      A6,#0
                    17706   ; LCDdata = (char)(c);
00005E26  202E 0008 17707          move.l    8(A6),D0
00005E2A  13C0 0040 17708          move.b    D0,4194338
00005E2E  0022      
                    17709   ; Wait1ms() ;
00005E30  4EB8 5DDC 17710          jsr       _Wait1ms
00005E34  4E5E      17711          unlk      A6
00005E36  4E75      17712          rts
                    17713   ; }
                    17714   ; /**********************************************************************************
                    17715   ; *subroutine to output a message at the current cursor position of the LCD display
                    17716   ; ************************************************************************************/
                    17717   ; void OutMess(char *theMessage)
                    17718   ; {
                    17719   _OutMess:
00005E38  4E56 FFFC 17720          link      A6,#-4
                    17721   ; char c ;
                    17722   ; while((c = *theMessage++) != (char)(0))
                    17723   OutMess_1:
00005E3C  206E 0008 17724          move.l    8(A6),A0
00005E40  52AE 0008 17725          addq.l    #1,8(A6)
00005E44  1D50 FFFF 17726          move.b    (A0),-1(A6)
00005E48  1010      17727          move.b    (A0),D0
00005E4A  6712      17728          beq.s     OutMess_3
                    17729   ; Outchar(c) ;
00005E4C  122E FFFF 17730          move.b    -1(A6),D1
00005E50  4881      17731          ext.w     D1
00005E52  48C1      17732          ext.l     D1
00005E54  2F01      17733          move.l    D1,-(A7)
00005E56  4EB8 5E22 17734          jsr       _Outchar
00005E5A  584F      17735          addq.w    #4,A7
00005E5C  60DE      17736          bra       OutMess_1
                    17737   OutMess_3:
00005E5E  4E5E      17738          unlk      A6
00005E60  4E75      17739          rts
                    17740   ; }
                    17741   ; /******************************************************************************
                    17742   ; *subroutine to clear the line by issuing 24 space characters
                    17743   ; *******************************************************************************/
                    17744   ; void Clearln(void)
                    17745   ; {
                    17746   _Clearln:
00005E62  2F02      17747          move.l    D2,-(A7)
                    17748   ; unsigned char i ;
                    17749   ; for(i = 0; i < 24; i ++)
00005E64  4202      17750          clr.b     D2
                    17751   Clearln_1:
00005E66  0C02 0018 17752          cmp.b     #24,D2
00005E6A  640E      17753          bhs.s     Clearln_3
                    17754   ; Outchar(' ') ;  /* write a space char to the LCD display */
00005E6C  4878 0020 17755          pea       32
00005E70  4EB8 5E22 17756          jsr       _Outchar
00005E74  584F      17757          addq.w    #4,A7
00005E76  5202      17758          addq.b    #1,D2
00005E78  60EC      17759          bra       Clearln_1
                    17760   Clearln_3:
00005E7A  241F      17761          move.l    (A7)+,D2
00005E7C  4E75      17762          rts
                    17763   ; }
                    17764   ; /******************************************************************************
                    17765   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    17766   ; *******************************************************************************/
                    17767   ; void Oline0(char *theMessage)
                    17768   ; {
                    17769   _Oline0:
00005E7E  4E56 0000 17770          link      A6,#0
                    17771   ; LCDcommand = (char)(0x80) ;
00005E82  13FC 0080 17772          move.b    #128,4194336
00005E86  0040 0020 
                    17773   ; Wait3ms();
00005E8A  4EB8 5DF0 17774          jsr       _Wait3ms
                    17775   ; Clearln() ;
00005E8E  4EB8 5E62 17776          jsr       _Clearln
                    17777   ; LCDcommand = (char)(0x80) ;
00005E92  13FC 0080 17778          move.b    #128,4194336
00005E96  0040 0020 
                    17779   ; Wait3ms() ;
00005E9A  4EB8 5DF0 17780          jsr       _Wait3ms
                    17781   ; OutMess(theMessage) ;
00005E9E  2F2E 0008 17782          move.l    8(A6),-(A7)
00005EA2  4EB8 5E38 17783          jsr       _OutMess
00005EA6  584F      17784          addq.w    #4,A7
00005EA8  4E5E      17785          unlk      A6
00005EAA  4E75      17786          rts
                    17787   ; }
                    17788   ; /******************************************************************************
                    17789   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    17790   ; *******************************************************************************/
                    17791   ; void Oline1(char *theMessage)
                    17792   ; {
                    17793   _Oline1:
00005EAC  4E56 0000 17794          link      A6,#0
                    17795   ; LCDcommand = (char)(0xC0) ;
00005EB0  13FC 00C0 17796          move.b    #192,4194336
00005EB4  0040 0020 
                    17797   ; Wait3ms();
00005EB8  4EB8 5DF0 17798          jsr       _Wait3ms
                    17799   ; Clearln() ;
00005EBC  4EB8 5E62 17800          jsr       _Clearln
                    17801   ; LCDcommand = (char)(0xC0) ;
00005EC0  13FC 00C0 17802          move.b    #192,4194336
00005EC4  0040 0020 
                    17803   ; Wait3ms() ;
00005EC8  4EB8 5DF0 17804          jsr       _Wait3ms
                    17805   ; OutMess(theMessage) ;
00005ECC  2F2E 0008 17806          move.l    8(A6),-(A7)
00005ED0  4EB8 5E38 17807          jsr       _OutMess
00005ED4  584F      17808          addq.w    #4,A7
00005ED6  4E5E      17809          unlk      A6
00005ED8  4E75      17810          rts
                    17811   ; }
                    17812   ; /*********************************************************************************
                    17813   ; ** Timer ISR
                    17814   ; **********************************************************************************/
                    17815   ; void Timer_ISR(void)
                    17816   ; {
                    17817   _Timer_ISR:
                    17818   ; if(Timer1Status == 1) {       // Did Timer 1 produce the Interrupt?
00005EDA  1039 0040 17819          move.b    4194354,D0
00005EDE  0032      
00005EE0  0C00 0001 17820          cmp.b     #1,D0
00005EE4  6608      17821          bne.s     Timer_ISR_1
                    17822   ; Timer1Control = 3;      	// if so clear interrupt and restart timer
00005EE6  13FC 0003 17823          move.b    #3,4194354
00005EEA  0040 0032 
                    17824   Timer_ISR_1:
00005EEE  4E75      17825          rts
                    17826   ; }
                    17827   ; }
                    17828   ; /**********************************************************************************
                    17829   ; ** Timer Initialisation Routine
                    17830   ; **********************************************************************************/
                    17831   ; void Timer1_Init(void)
                    17832   ; {
                    17833   _Timer1_Init:
                    17834   ; Timer1Data = 0x03;		// program 100 hz time delay into timer 1.
00005EF0  13FC 0003 17835          move.b    #3,4194352
00005EF4  0040 0030 
                    17836   ; /*
                    17837   ; ** timer driven off 25Mhz clock so program value so that it counts down in 0.01 secs
                    17838   ; ** the example 0x03 above is loaded into top 8 bits of a 24 bit timer so reads as
                    17839   ; ** 0x03FFFF a value of 0x03 would be 262,143/25,000,000, so is close to 1/100th sec
                    17840   ; **
                    17841   ; **
                    17842   ; ** Now write binary 00000011 to timer control register:
                    17843   ; **	Bit0 = 1 (enable interrupt from that timer)
                    17844   ; **	Bit 1 = 1 enable counting
                    17845   ; */
                    17846   ; Timer1Control = 3;
00005EF8  13FC 0003 17847          move.b    #3,4194354
00005EFC  0040 0032 
00005F00  4E75      17848          rts
                    17849   ; }
                    17850   ; /*********************************************************************************************************************************
                    17851   ; **  IMPORTANT FUNCTION
                    17852   ; **  This function installs an exception (interrupt) handler so you can capture and deal with any 68000 exception in your program
                    17853   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                    17854   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                    17855   ; **  Calling this function allows you to deal with Interrupts for example
                    17856   ; **
                    17857   ; **	e.g. to install the function 'void Timer_ISR()' (see above in this program) to deal with interrupts from the timer do this
                    17858   ; **
                    17859   ; **	InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-8 on level 3 IRQ (exception number 27 on 68k)
                    17860   ; **
                    17861   ; **	see main below for other examples
                    17862   ; ***********************************************************************************************************************************/
                    17863   ; /*
                    17864   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    17865   ; {
                    17866   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
                    17867   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
                    17868   ; }
                    17869   ; */
                    17870   ; C:\CPEN412\ASN6\ASN6B_THREADS\CANBUS-CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17871   ; #include <stdio.h>
                    17872   ; #include "Canbus-Controller.h"
                    17873   ; #include "DebugMonitor.h"
                    17874   ; #define TEMP 0
                    17875   ; #define POTENTIAL 1
                    17876   ; #define LIGHT 2
                    17877   ; #define SWITCHES 3
                    17878   ; /*********************************************************************************************
                    17879   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                    17880   ; ** application note and adapted for the 68k assignment
                    17881   ; *********************************************************************************************/
                    17882   ; /*
                    17883   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                    17884   ; ** assume the addresses for the 2 can controllers given in the assignment
                    17885   ; **
                    17886   ; ** Registers are defined in terms of the following Macro for each Can controller,
                    17887   ; ** where (i) represents an registers number
                    17888   ; */
                    17889   ; /*  bus timing values for
                    17890   ; **  bit-rate : 100 kBit/s
                    17891   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                    17892   ; **  maximum tolerated propagation delay : 4450 ns
                    17893   ; **  minimum requested propagation delay : 500 ns
                    17894   ; **
                    17895   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                    17896   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                    17897   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                    17898   ; */
                    17899   ; // initialisation for Can controller 0
                    17900   ; void Init_CanBus_Controller0(void)
                    17901   ; {
                    17902   _Init_CanBus_Controller0:
                    17903   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    17904   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    17905   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    17906   ; leave loop after a time out and signal an error */
                    17907   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    17908   Init_CanBus_Controller0_1:
00005F02  1039 0050 17909          move.b    5242880,D0
00005F06  0000      
00005F08  C03C 0001 17910          and.b     #1,D0
00005F0C  6612      17911          bne.s     Init_CanBus_Controller0_3
                    17912   ; {
                    17913   ; /* other bits than the reset mode/request bit are unchanged */
                    17914   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit ;
00005F0E  1039 0050 17915          move.b    5242880,D0
00005F12  0000      
00005F14  803C 0001 17916          or.b      #1,D0
00005F18  13C0 0050 17917          move.b    D0,5242880
00005F1C  0000      
00005F1E  60E2      17918          bra       Init_CanBus_Controller0_1
                    17919   Init_CanBus_Controller0_3:
                    17920   ; }
                    17921   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    17922   ; select PeliCAN mode
                    17923   ; bypass CAN input comparator as external transceiver is used
                    17924   ; select the clock for the controller S87C654 */
                    17925   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00005F20  13FC 00C0 17926          move.b    #192,5242942
00005F24  0050 003E 
                    17927   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    17928   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    17929   ; Can0_InterruptEnReg = ClrIntEnSJA;
00005F28  4239 0050 17930          clr.b     5242888
00005F2C  0008      
                    17931   ; /* define acceptance code and mask */
                    17932   ; Can0_AcceptCode0Reg = ClrByte;
00005F2E  4239 0050 17933          clr.b     5242912
00005F32  0020      
                    17934   ; Can0_AcceptCode1Reg = ClrByte;
00005F34  4239 0050 17935          clr.b     5242914
00005F38  0022      
                    17936   ; Can0_AcceptCode2Reg = ClrByte;
00005F3A  4239 0050 17937          clr.b     5242916
00005F3E  0024      
                    17938   ; Can0_AcceptCode3Reg = ClrByte;
00005F40  4239 0050 17939          clr.b     5242918
00005F44  0026      
                    17940   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00005F46  13FC 00FF 17941          move.b    #255,5242920
00005F4A  0050 0028 
                    17942   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00005F4E  13FC 00FF 17943          move.b    #255,5242922
00005F52  0050 002A 
                    17944   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00005F56  13FC 00FF 17945          move.b    #255,5242924
00005F5A  0050 002C 
                    17946   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00005F5E  13FC 00FF 17947          move.b    #255,5242926
00005F62  0050 002E 
                    17948   ; /* configure bus timing */
                    17949   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    17950   ; Can0_BusTiming0Reg = 0x04;
00005F66  13FC 0004 17951          move.b    #4,5242892
00005F6A  0050 000C 
                    17952   ; Can0_BusTiming1Reg = 0x7F;
00005F6E  13FC 007F 17953          move.b    #127,5242894
00005F72  0050 000E 
                    17954   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    17955   ; normal output mode */
                    17956   ; Can0_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00005F76  13FC 001A 17957          move.b    #26,5242896
00005F7A  0050 0010 
                    17958   ; /* leave the reset mode/request i.e. switch to operating mode,
                    17959   ; the interrupts of the S87C654 are enabled
                    17960   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    17961   ; for the different tasks in a system */
                    17962   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    17963   ; switch off Self Test Mode and Listen Only Mode,
                    17964   ; clear Sleep Mode (wake up) */
                    17965   ; /* wait until RM_RR_Bit is cleared */
                    17966   ; /* break loop after a time out and signal an error */
                    17967   ; do{
                    17968   Init_CanBus_Controller0_4:
                    17969   ; Can0_ModeControlReg = ClrByte;
00005F7E  4239 0050 17970          clr.b     5242880
00005F82  0000      
00005F84  1039 0050 17971          move.b    5242880,D0
00005F88  0000      
00005F8A  C03C 0001 17972          and.b     #1,D0
00005F8E  66EE      17973          bne       Init_CanBus_Controller0_4
00005F90  4E75      17974          rts
                    17975   ; } while((Can0_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    17976   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    17977   ; }
                    17978   ; // initialisation for Can controller 1
                    17979   ; void Init_CanBus_Controller1(void)
                    17980   ; {
                    17981   _Init_CanBus_Controller1:
                    17982   ; // TODO - put your Canbus initialisation code for CanController 1 here
                    17983   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    17984   ; /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    17985   ; leave loop after a time out and signal an error */
                    17986   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                    17987   Init_CanBus_Controller1_1:
00005F92  1039 0050 17988          move.b    5243392,D0
00005F96  0200      
00005F98  C03C 0001 17989          and.b     #1,D0
00005F9C  6612      17990          bne.s     Init_CanBus_Controller1_3
                    17991   ; {
                    17992   ; /* other bits than the reset mode/request bit are unchanged */
                    17993   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit ;
00005F9E  1039 0050 17994          move.b    5243392,D0
00005FA2  0200      
00005FA4  803C 0001 17995          or.b      #1,D0
00005FA8  13C0 0050 17996          move.b    D0,5243392
00005FAC  0200      
00005FAE  60E2      17997          bra       Init_CanBus_Controller1_1
                    17998   Init_CanBus_Controller1_3:
                    17999   ; }
                    18000   ; /* set the Clock Divider Register according to the given hardware of Figure 3
                    18001   ; select PeliCAN mode
                    18002   ; bypass CAN input comparator as external transceiver is used
                    18003   ; select the clock for the controller S87C654 */
                    18004   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00005FB0  13FC 00C0 18005          move.b    #192,5243454
00005FB4  0050 023E 
                    18006   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    18007   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    18008   ; Can1_InterruptEnReg = ClrIntEnSJA;
00005FB8  4239 0050 18009          clr.b     5243400
00005FBC  0208      
                    18010   ; /* define acceptance code and mask */
                    18011   ; Can1_AcceptCode0Reg = ClrByte;
00005FBE  4239 0050 18012          clr.b     5243424
00005FC2  0220      
                    18013   ; Can1_AcceptCode1Reg = ClrByte;
00005FC4  4239 0050 18014          clr.b     5243426
00005FC8  0222      
                    18015   ; Can1_AcceptCode2Reg = ClrByte;
00005FCA  4239 0050 18016          clr.b     5243428
00005FCE  0224      
                    18017   ; Can1_AcceptCode3Reg = ClrByte;
00005FD0  4239 0050 18018          clr.b     5243430
00005FD4  0226      
                    18019   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00005FD6  13FC 00FF 18020          move.b    #255,5243432
00005FDA  0050 0228 
                    18021   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00005FDE  13FC 00FF 18022          move.b    #255,5243434
00005FE2  0050 022A 
                    18023   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00005FE6  13FC 00FF 18024          move.b    #255,5243436
00005FEA  0050 022C 
                    18025   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00005FEE  13FC 00FF 18026          move.b    #255,5243438
00005FF2  0050 022E 
                    18027   ; /* configure bus timing */
                    18028   ; /* bit-rate = 1 Mbit/s @ 24 MHz, the bus is sampled once */
                    18029   ; Can1_BusTiming0Reg = 0x04;
00005FF6  13FC 0004 18030          move.b    #4,5243404
00005FFA  0050 020C 
                    18031   ; Can1_BusTiming1Reg = 0x7F;
00005FFE  13FC 007F 18032          move.b    #127,5243406
00006002  0050 020E 
                    18033   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0,
                    18034   ; normal output mode */
                    18035   ; Can1_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00006006  13FC 001A 18036          move.b    #26,5243408
0000600A  0050 0210 
                    18037   ; /* leave the reset mode/request i.e. switch to operating mode,
                    18038   ; the interrupts of the S87C654 are enabled
                    18039   ; but not the CAN interrupts of the SJA1000, which can be done separately
                    18040   ; for the different tasks in a system */
                    18041   ; /* clear Reset Mode bit, select dual Acceptance Filter Mode,
                    18042   ; switch off Self Test Mode and Listen Only Mode,
                    18043   ; clear Sleep Mode (wake up) */
                    18044   ; /* wait until RM_RR_Bit is cleared */
                    18045   ; /* break loop after a time out and signal an error */
                    18046   ; do{
                    18047   Init_CanBus_Controller1_4:
                    18048   ; Can1_ModeControlReg = ClrByte;
0000600E  4239 0050 18049          clr.b     5243392
00006012  0200      
00006014  1039 0050 18050          move.b    5243392,D0
00006018  0200      
0000601A  C03C 0001 18051          and.b     #1,D0
0000601E  66EE      18052          bne       Init_CanBus_Controller1_4
00006020  4E75      18053          rts
                    18054   ; } while((Can1_ModeControlReg & RM_RR_Bit ) != ClrByte);
                    18055   ; /*----- end of Initialization Example of the SJA1000 ------------------------*/
                    18056   ; }
                    18057   ; // Transmit for sending a message via Can controller 0
                    18058   ; void CanBus0_Transmit(unsigned char data)
                    18059   ; {
                    18060   _CanBus0_Transmit:
00006022  4E56 0000 18061          link      A6,#0
                    18062   ; // TODO - put your Canbus transmit code for CanController 0 here
                    18063   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    18064   ; /* wait until the Transmit Buffer is released */
                    18065   ; do{
                    18066   CanBus0_Transmit_1:
                    18067   ; /* start a polling timer and run some tasks while waiting
                    18068   ; break the loop and signal an error if time too long */
                    18069   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
00006026  1039 0050 18070          move.b    5242884,D0
0000602A  0004      
0000602C  C03C 0004 18071          and.b     #4,D0
00006030  0C00 0004 18072          cmp.b     #4,D0
00006034  66F0      18073          bne       CanBus0_Transmit_1
                    18074   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    18075   ; /* in this example a Standard Frame message shall be transmitted */
                    18076   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00006036  13FC 0008 18077          move.b    #8,5242912
0000603A  0050 0020 
                    18078   ; Can0_TxBuffer1 = data; /*Data that will be sent*/
0000603E  13EE 000B 18079          move.b    11(A6),5242914
00006042  0050 0022 
                    18080   ; /* Start the transmission */
                    18081   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00006046  13FC 0001 18082          move.b    #1,5242882
0000604A  0050 0002 
0000604E  4E5E      18083          unlk      A6
00006050  4E75      18084          rts
                    18085   ; }
                    18086   ; // Transmit for sending a message via Can controller 1
                    18087   ; void CanBus1_Transmit(unsigned char data)
                    18088   ; {
                    18089   _CanBus1_Transmit:
00006052  4E56 0000 18090          link      A6,#0
                    18091   ; // TODO - put your Canbus transmit code for CanController 1 here
                    18092   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    18093   ; /* wait until the Transmit Buffer is released */
                    18094   ; do{
                    18095   CanBus1_Transmit_1:
                    18096   ; /* start a polling timer and run some tasks while waiting
                    18097   ; break the loop and signal an error if time too long */
                    18098   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
00006056  1039 0050 18099          move.b    5243396,D0
0000605A  0204      
0000605C  C03C 0004 18100          and.b     #4,D0
00006060  0C00 0004 18101          cmp.b     #4,D0
00006064  66F0      18102          bne       CanBus1_Transmit_1
                    18103   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    18104   ; /* in this example a Standard Frame message shall be transmitted */
                    18105   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00006066  13FC 0008 18106          move.b    #8,5243424
0000606A  0050 0220 
                    18107   ; Can1_TxBuffer1 = data; /*Data that will be sent*/
0000606E  13EE 000B 18108          move.b    11(A6),5243426
00006072  0050 0222 
                    18109   ; /* Start the transmission */
                    18110   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00006076  13FC 0001 18111          move.b    #1,5243394
0000607A  0050 0202 
0000607E  4E5E      18112          unlk      A6
00006080  4E75      18113          rts
                    18114   ; }
                    18115   ; // Receive for reading a received message via Can controller 0
                    18116   ; void CanBus0_Receive(int type)
                    18117   ; {
                    18118   _CanBus0_Receive:
00006082  4E56 FFFC 18119          link      A6,#-4
00006086  48E7 3820 18120          movem.l   D2/D3/D4/A2,-(A7)
0000608A  45F9 0000 18121          lea       _printf.L,A2
0000608E  642A      
00006090  282E 0008 18122          move.l    8(A6),D4
                    18123   ; unsigned char data;
                    18124   ; unsigned char c = 0xFF;
00006094  1D7C 00FF 18125          move.b    #255,-1(A6)
00006098  FFFF      
                    18126   ; unsigned int i = 0;
0000609A  4283      18127          clr.l     D3
                    18128   ; // TODO - put your Canbus receive code for CanController 0 here
                    18129   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18130   ; //Bottom of page 35
                    18131   ; /* enable the receive interrupt */
                    18132   ; //Can0_InterruptEnReg = RIE_Bit; ////
                    18133   ; /* wait until the Receiver Buffer is released */
                    18134   ; do{
                    18135   CanBus0_Receive_1:
                    18136   ; /* start a polling timer and run some tasks while waiting
                    18137   ; break the loop and signal an error if time too long */
                    18138   ; } while((Can0_StatusReg & RBS_Bit) != RBS_Bit );
0000609C  1039 0050 18139          move.b    5242884,D0
000060A0  0004      
000060A2  C03C 0001 18140          and.b     #1,D0
000060A6  0C00 0001 18141          cmp.b     #1,D0
000060AA  66F0      18142          bne       CanBus0_Receive_1
                    18143   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                    18144   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                    18145   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                    18146   ; */
                    18147   ; /* get the content of the Receive Buffer from SJA1000 and store the
                    18148   ; message into internal memory of the controller,
                    18149   ; it is possible at once to decode the FrameInfo and Data Length Code
                    18150   ; and adapt the fetch appropriately */
                    18151   ; data = Can0_RxBuffer1;
000060AC  1439 0050 18152          move.b    5242914,D2
000060B0  0022      
                    18153   ; if(type == TEMP){
000060B2  4A84      18154          tst.l     D4
000060B4  6616      18155          bne.s     CanBus0_Receive_3
                    18156   ; printf("Value of Thermistor (CAN0): %d\n", data);
000060B6  C4BC 0000 18157          and.l     #255,D2
000060BA  00FF      
000060BC  2F02      18158          move.l    D2,-(A7)
000060BE  4879 0000 18159          pea       @canbus~1_1.L
000060C2  707C      
000060C4  4E92      18160          jsr       (A2)
000060C6  504F      18161          addq.w    #8,A7
000060C8  6000 009C 18162          bra       CanBus0_Receive_10
                    18163   CanBus0_Receive_3:
                    18164   ; }else if(type == POTENTIAL){
000060CC  0C84 0000 18165          cmp.l     #1,D4
000060D0  0001      
000060D2  6616      18166          bne.s     CanBus0_Receive_5
                    18167   ; printf("Value of Potentiometer (CAN0): %d\n", data);
000060D4  C4BC 0000 18168          and.l     #255,D2
000060D8  00FF      
000060DA  2F02      18169          move.l    D2,-(A7)
000060DC  4879 0000 18170          pea       @canbus~1_2.L
000060E0  709C      
000060E2  4E92      18171          jsr       (A2)
000060E4  504F      18172          addq.w    #8,A7
000060E6  6000 007E 18173          bra       CanBus0_Receive_10
                    18174   CanBus0_Receive_5:
                    18175   ; }else if(type == LIGHT){
000060EA  0C84 0000 18176          cmp.l     #2,D4
000060EE  0002      
000060F0  6616      18177          bne.s     CanBus0_Receive_7
                    18178   ; printf("Value of Photo-resister (CAN0): %d\n", data);
000060F2  C4BC 0000 18179          and.l     #255,D2
000060F6  00FF      
000060F8  2F02      18180          move.l    D2,-(A7)
000060FA  4879 0000 18181          pea       @canbus~1_3.L
000060FE  70C0      
00006100  4E92      18182          jsr       (A2)
00006102  504F      18183          addq.w    #8,A7
00006104  6000 0060 18184          bra       CanBus0_Receive_10
                    18185   CanBus0_Receive_7:
                    18186   ; }else if(type == SWITCHES){
00006108  0C84 0000 18187          cmp.l     #3,D4
0000610C  0003      
0000610E  6600 004C 18188          bne       CanBus0_Receive_9
                    18189   ; printf("Value of SW[7-0] (CAN0): ");
00006112  4879 0000 18190          pea       @canbus~1_4.L
00006116  70E4      
00006118  4E92      18191          jsr       (A2)
0000611A  584F      18192          addq.w    #4,A7
                    18193   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
0000611C  263C 0000 18194          move.l    #128,D3
00006120  0080      
                    18195   CanBus0_Receive_11:
00006122  0C83 0000 18196          cmp.l     #0,D3
00006126  0000      
00006128  6326      18197          bls.s     CanBus0_Receive_13
                    18198   ; if ((data & i) == 0)
0000612A  1002      18199          move.b    D2,D0
0000612C  C0BC 0000 18200          and.l     #255,D0
00006130  00FF      
00006132  C083      18201          and.l     D3,D0
00006134  660C      18202          bne.s     CanBus0_Receive_14
                    18203   ; printf("0");
00006136  4879 0000 18204          pea       @canbus~1_5.L
0000613A  70FE      
0000613C  4E92      18205          jsr       (A2)
0000613E  584F      18206          addq.w    #4,A7
00006140  600A      18207          bra.s     CanBus0_Receive_15
                    18208   CanBus0_Receive_14:
                    18209   ; else
                    18210   ; printf("1");
00006142  4879 0000 18211          pea       @canbus~1_6.L
00006146  7100      
00006148  4E92      18212          jsr       (A2)
0000614A  584F      18213          addq.w    #4,A7
                    18214   CanBus0_Receive_15:
0000614C  E28B      18215          lsr.l     #1,D3
0000614E  60D2      18216          bra       CanBus0_Receive_11
                    18217   CanBus0_Receive_13:
                    18218   ; }
                    18219   ; printf("\n");
00006150  4879 0000 18220          pea       @canbus~1_7.L
00006154  7102      
00006156  4E92      18221          jsr       (A2)
00006158  584F      18222          addq.w    #4,A7
0000615A  600A      18223          bra.s     CanBus0_Receive_10
                    18224   CanBus0_Receive_9:
                    18225   ; }else{
                    18226   ; printf("ERROR");
0000615C  4879 0000 18227          pea       @canbus~1_8.L
00006160  7104      
00006162  4E92      18228          jsr       (A2)
00006164  584F      18229          addq.w    #4,A7
                    18230   CanBus0_Receive_10:
                    18231   ; }
                    18232   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                    18233   ; further messages will generate a new interrupt */
                    18234   ; Can0_CommandReg = RRB_Bit; /* Release Receive Buffer */
00006166  13FC 0004 18235          move.b    #4,5242882
0000616A  0050 0002 
0000616E  4CDF 041C 18236          movem.l   (A7)+,D2/D3/D4/A2
00006172  4E5E      18237          unlk      A6
00006174  4E75      18238          rts
                    18239   ; }
                    18240   ; // Receive for reading a received message via Can controller 1
                    18241   ; void CanBus1_Receive(int type)
                    18242   ; {
                    18243   _CanBus1_Receive:
00006176  4E56 FFFC 18244          link      A6,#-4
0000617A  48E7 3820 18245          movem.l   D2/D3/D4/A2,-(A7)
0000617E  45F9 0000 18246          lea       _printf.L,A2
00006182  642A      
00006184  282E 0008 18247          move.l    8(A6),D4
                    18248   ; unsigned char data;
                    18249   ; unsigned char c = 0xFF;
00006188  1D7C 00FF 18250          move.b    #255,-1(A6)
0000618C  FFFF      
                    18251   ; unsigned int i = 0;        
0000618E  4283      18252          clr.l     D3
                    18253   ; // TODO - put your Canbus receive code for CanController 1 here
                    18254   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18255   ; //Bottom of page 35
                    18256   ; // TODO - put your Canbus receive code for CanController 0 here
                    18257   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    18258   ; /* enable the receive interrupt */
                    18259   ; //Can1_InterruptEnReg = RIE_Bit;
                    18260   ; /* wait until the Receiver Buffer is released */
                    18261   ; do{
                    18262   CanBus1_Receive_1:
                    18263   ; /* start a polling timer and run some tasks while waiting
                    18264   ; break the loop and signal an error if time too long */
                    18265   ; } while((Can1_StatusReg & RBS_Bit) != RBS_Bit );
00006190  1039 0050 18266          move.b    5243396,D0
00006194  0204      
00006196  C03C 0001 18267          and.b     #1,D0
0000619A  0C00 0001 18268          cmp.b     #1,D0
0000619E  66F0      18269          bne       CanBus1_Receive_1
                    18270   ; /* read the Interrupt Register content from SJA1000 and save temporarily
                    18271   ; all interrupt flags are cleared (in PeliCAN mode the Receive
                    18272   ; Interrupt (RI) is cleared first, when giving the Release Buffer command)
                    18273   ; */
                    18274   ; /* get the content of the Receive Buffer from SJA1000 and store the
                    18275   ; message into internal memory of the controller,
                    18276   ; it is possible at once to decode the FrameInfo and Data Length Code
                    18277   ; and adapt the fetch appropriately */
                    18278   ; data = Can1_RxBuffer1;
000061A0  1439 0050 18279          move.b    5243426,D2
000061A4  0222      
                    18280   ; if(type == TEMP){
000061A6  4A84      18281          tst.l     D4
000061A8  6616      18282          bne.s     CanBus1_Receive_3
                    18283   ; printf("Value of Thermistor (CAN1): %d\n", data);
000061AA  C4BC 0000 18284          and.l     #255,D2
000061AE  00FF      
000061B0  2F02      18285          move.l    D2,-(A7)
000061B2  4879 0000 18286          pea       @canbus~1_9.L
000061B6  710A      
000061B8  4E92      18287          jsr       (A2)
000061BA  504F      18288          addq.w    #8,A7
000061BC  6000 009C 18289          bra       CanBus1_Receive_10
                    18290   CanBus1_Receive_3:
                    18291   ; }else if(type == POTENTIAL){
000061C0  0C84 0000 18292          cmp.l     #1,D4
000061C4  0001      
000061C6  6616      18293          bne.s     CanBus1_Receive_5
                    18294   ; printf("Value of Potentiometer (CAN1): %d\n", data);
000061C8  C4BC 0000 18295          and.l     #255,D2
000061CC  00FF      
000061CE  2F02      18296          move.l    D2,-(A7)
000061D0  4879 0000 18297          pea       @canbus~1_10.L
000061D4  712A      
000061D6  4E92      18298          jsr       (A2)
000061D8  504F      18299          addq.w    #8,A7
000061DA  6000 007E 18300          bra       CanBus1_Receive_10
                    18301   CanBus1_Receive_5:
                    18302   ; }else if(type == LIGHT){
000061DE  0C84 0000 18303          cmp.l     #2,D4
000061E2  0002      
000061E4  6616      18304          bne.s     CanBus1_Receive_7
                    18305   ; printf("Value of Photo-resister (CAN1): %d\n", data);
000061E6  C4BC 0000 18306          and.l     #255,D2
000061EA  00FF      
000061EC  2F02      18307          move.l    D2,-(A7)
000061EE  4879 0000 18308          pea       @canbus~1_11.L
000061F2  714E      
000061F4  4E92      18309          jsr       (A2)
000061F6  504F      18310          addq.w    #8,A7
000061F8  6000 0060 18311          bra       CanBus1_Receive_10
                    18312   CanBus1_Receive_7:
                    18313   ; }else if(type == SWITCHES){
000061FC  0C84 0000 18314          cmp.l     #3,D4
00006200  0003      
00006202  6600 004C 18315          bne       CanBus1_Receive_9
                    18316   ; printf("Value of SW[7-0] (CAN1): ");
00006206  4879 0000 18317          pea       @canbus~1_12.L
0000620A  7172      
0000620C  4E92      18318          jsr       (A2)
0000620E  584F      18319          addq.w    #4,A7
                    18320   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00006210  263C 0000 18321          move.l    #128,D3
00006214  0080      
                    18322   CanBus1_Receive_11:
00006216  0C83 0000 18323          cmp.l     #0,D3
0000621A  0000      
0000621C  6326      18324          bls.s     CanBus1_Receive_13
                    18325   ; if ((data & i) == 0)
0000621E  1002      18326          move.b    D2,D0
00006220  C0BC 0000 18327          and.l     #255,D0
00006224  00FF      
00006226  C083      18328          and.l     D3,D0
00006228  660C      18329          bne.s     CanBus1_Receive_14
                    18330   ; printf("0");
0000622A  4879 0000 18331          pea       @canbus~1_5.L
0000622E  70FE      
00006230  4E92      18332          jsr       (A2)
00006232  584F      18333          addq.w    #4,A7
00006234  600A      18334          bra.s     CanBus1_Receive_15
                    18335   CanBus1_Receive_14:
                    18336   ; else
                    18337   ; printf("1");
00006236  4879 0000 18338          pea       @canbus~1_6.L
0000623A  7100      
0000623C  4E92      18339          jsr       (A2)
0000623E  584F      18340          addq.w    #4,A7
                    18341   CanBus1_Receive_15:
00006240  E28B      18342          lsr.l     #1,D3
00006242  60D2      18343          bra       CanBus1_Receive_11
                    18344   CanBus1_Receive_13:
                    18345   ; }
                    18346   ; printf("\n");
00006244  4879 0000 18347          pea       @canbus~1_7.L
00006248  7102      
0000624A  4E92      18348          jsr       (A2)
0000624C  584F      18349          addq.w    #4,A7
0000624E  600A      18350          bra.s     CanBus1_Receive_10
                    18351   CanBus1_Receive_9:
                    18352   ; }else{
                    18353   ; printf("ERROR");
00006250  4879 0000 18354          pea       @canbus~1_8.L
00006254  7104      
00006256  4E92      18355          jsr       (A2)
00006258  584F      18356          addq.w    #4,A7
                    18357   CanBus1_Receive_10:
                    18358   ; }
                    18359   ; /* release the Receive Buffer, now the Receive Interrupt flag is cleared,
                    18360   ; further messages will generate a new interrupt */
                    18361   ; Can1_CommandReg = RRB_Bit; /* Release Receive Buffer */
0000625A  13FC 0004 18362          move.b    #4,5243394
0000625E  0050 0202 
00006262  4CDF 041C 18363          movem.l   (A7)+,D2/D3/D4/A2
00006266  4E5E      18364          unlk      A6
00006268  4E75      18365          rts
                    18366   ; }
                    18367   ; void CanBusTest(void)
                    18368   ; {
                    18369   _CanBusTest:
0000626A  48E7 2020 18370          movem.l   D2/A2,-(A7)
0000626E  45F9 0000 18371          lea       _printf.L,A2
00006272  642A      
                    18372   ; unsigned char data = 0xFF;
00006274  143C 00FF 18373          move.b    #255,D2
                    18374   ; // initialise the two Can controllers
                    18375   ; Init_CanBus_Controller0();
00006278  4EB8 5F02 18376          jsr       _Init_CanBus_Controller0
                    18377   ; Init_CanBus_Controller1();
0000627C  4EB8 5F92 18378          jsr       _Init_CanBus_Controller1
                    18379   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00006280  4879 0000 18380          pea       @canbus~1_13.L
00006284  718C      
00006286  4E92      18381          jsr       (A2)
00006288  584F      18382          addq.w    #4,A7
                    18383   ; // simple application to alternately transmit and receive messages from each of two nodes
                    18384   ; while(1)    {
                    18385   CanBusTest_1:
                    18386   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
0000628A  4EB9 0000 18387          jsr       _WaitHalfSecond
0000628E  62D8      
                    18388   ; CanBus0_Transmit(data) ;       // transmit a message via Controller 0
00006290  C4BC 0000 18389          and.l     #255,D2
00006294  00FF      
00006296  2F02      18390          move.l    D2,-(A7)
00006298  4EB8 6022 18391          jsr       _CanBus0_Transmit
0000629C  584F      18392          addq.w    #4,A7
                    18393   ; CanBus1_Receive(TEMP) ;        // receive a message via Controller 1 (and display it)
0000629E  42A7      18394          clr.l     -(A7)
000062A0  4EB8 6176 18395          jsr       _CanBus1_Receive
000062A4  584F      18396          addq.w    #4,A7
                    18397   ; printf("\r\n") ;
000062A6  4879 0000 18398          pea       @canbus~1_14.L
000062AA  71A8      
000062AC  4E92      18399          jsr       (A2)
000062AE  584F      18400          addq.w    #4,A7
                    18401   ; WaitHalfSecond();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
000062B0  4EB9 0000 18402          jsr       _WaitHalfSecond
000062B4  62D8      
                    18403   ; CanBus1_Transmit(data) ;        // transmit a message via Controller 1
000062B6  C4BC 0000 18404          and.l     #255,D2
000062BA  00FF      
000062BC  2F02      18405          move.l    D2,-(A7)
000062BE  4EB8 6052 18406          jsr       _CanBus1_Transmit
000062C2  584F      18407          addq.w    #4,A7
                    18408   ; CanBus0_Receive(TEMP) ;         // receive a message via Controller 0 (and display it)
000062C4  42A7      18409          clr.l     -(A7)
000062C6  4EB8 6082 18410          jsr       _CanBus0_Receive
000062CA  584F      18411          addq.w    #4,A7
                    18412   ; printf("\r\n") ;
000062CC  4879 0000 18413          pea       @canbus~1_14.L
000062D0  71A8      
000062D2  4E92      18414          jsr       (A2)
000062D4  584F      18415          addq.w    #4,A7
000062D6  60B2      18416          bra       CanBusTest_1
                    18417   ; }
                    18418   ; }
                    18419   ; /************************************************************************************
                    18420   ; *Subroutine to give the 68000 something useless to do to waste 1 x 500 mSec = 500mSec = 0.5sec therefore 500000
                    18421   ; ************************************************************************************/
                    18422   ; void WaitHalfSecond(void)
                    18423   ; {
                    18424   _WaitHalfSecond:
000062D8  2F02      18425          move.l    D2,-(A7)
                    18426   ; long int  i;
                    18427   ; for (i = 0; i < 500000; i++)
000062DA  4282      18428          clr.l     D2
                    18429   WaitHalfSecond_1:
000062DC  0C82 0007 18430          cmp.l     #500000,D2
000062E0  A120      
000062E2  6C04      18431          bge.s     WaitHalfSecond_3
000062E4  5282      18432          addq.l    #1,D2
000062E6  60F4      18433          bra       WaitHalfSecond_1
                    18434   WaitHalfSecond_3:
000062E8  241F      18435          move.l    (A7)+,D2
000062EA  4E75      18436          rts
                    18437   ; ;
                    18438   ; }
                    18439   ; /************************************************************************************
                    18440   ; ** Subfunctions for I2C
                    18441   ; ************************************************************************************/
                    18442   ; void Enable_SCL_Clock(void){
                    18443   _Enable_SCL_Clock:
                    18444   ; I2C_Clock_PrerLo = 0x31;
000062EC  13FC 0031 18445          move.b    #49,4227072
000062F0  0040 8000 
                    18446   ; I2C_Clock_PrerHi = 0x00;
000062F4  4239 0040 18447          clr.b     4227074
000062F8  8002      
                    18448   ; return;
000062FA  4E75      18449          rts
                    18450   ; }
                    18451   ; void WaitForI2C_TIP(void){
                    18452   _WaitForI2C_TIP:
000062FC  4E56 FFFC 18453          link      A6,#-4
                    18454   ; int TIP_bit;
                    18455   ; do{
                    18456   WaitForI2C_TIP_1:
                    18457   ; TIP_bit = (I2C_Status >> 1) & 0x01; 
00006300  1039 0040 18458          move.b    4227080,D0
00006304  8008      
00006306  C0BC 0000 18459          and.l     #255,D0
0000630A  00FF      
0000630C  E288      18460          lsr.l     #1,D0
0000630E  C0BC 0000 18461          and.l     #1,D0
00006312  0001      
00006314  2D40 FFFC 18462          move.l    D0,-4(A6)
00006318  202E FFFC 18463          move.l    -4(A6),D0
0000631C  66E2      18464          bne       WaitForI2C_TIP_1
                    18465   ; }while(TIP_bit != 0);
                    18466   ; return;
0000631E  4E5E      18467          unlk      A6
00006320  4E75      18468          rts
                    18469   ; }
                    18470   ; void WaitForI2C_RxACK(void){
                    18471   _WaitForI2C_RxACK:
00006322  4E56 FFFC 18472          link      A6,#-4
                    18473   ; int RxACK_bit;
                    18474   ; do{
                    18475   WaitForI2C_RxACK_1:
                    18476   ; RxACK_bit = (I2C_Status >> 7) & 0x01;
00006326  1039 0040 18477          move.b    4227080,D0
0000632A  8008      
0000632C  C0BC 0000 18478          and.l     #255,D0
00006330  00FF      
00006332  EE88      18479          lsr.l     #7,D0
00006334  C0BC 0000 18480          and.l     #1,D0
00006338  0001      
0000633A  2D40 FFFC 18481          move.l    D0,-4(A6)
0000633E  202E FFFC 18482          move.l    -4(A6),D0
00006342  66E2      18483          bne       WaitForI2C_RxACK_1
                    18484   ; }while(RxACK_bit != 0);
                    18485   ; return;
00006344  4E5E      18486          unlk      A6
00006346  4E75      18487          rts
                    18488   ; }
                    18489   ; /************************************************************************************
                    18490   ; ** initialises the I2C controller 
                    18491   ; ************************************************************************************/
                    18492   ; void I2C_Init(void){
                    18493   _I2C_Init:
                    18494   ; //Enabling 100Khz SCL Clock Line
                    18495   ; Enable_SCL_Clock();
00006348  4EB8 62EC 18496          jsr       _Enable_SCL_Clock
                    18497   ; //Enabling I2C for no interupts and enabling core
                    18498   ; Enable_I2C_CS();
0000634C  13FC 0080 18499          move.b    #128,4227076
00006350  0040 8004 
                    18500   ; return;
00006354  4E75      18501          rts
                    18502   ; }
                    18503   ; /************************************************************************************
                    18504   ; ** ADC Write Function to measure Thermistor, Potentimeter, Photo-resistor
                    18505   ; ************************************************************************************/
                    18506   ; unsigned char ADCWrite(int type){
                    18507   _ADCWrite:
00006356  4E56 FFE8 18508          link      A6,#-24
0000635A  48E7 3030 18509          movem.l   D2/D3/A2/A3,-(A7)
0000635E  45F8 62FC 18510          lea       _WaitForI2C_TIP.L,A2
00006362  262E 0008 18511          move.l    8(A6),D3
00006366  47F8 6322 18512          lea       _WaitForI2C_RxACK.L,A3
                    18513   ; int i;
                    18514   ; unsigned char c;
                    18515   ; unsigned char* data[3];
                    18516   ; unsigned char temp, light, potential;
                    18517   ; unsigned int delay = 0xFFFFF;
0000636A  2D7C 000F 18518          move.l    #1048575,-4(A6)
0000636E  FFFF FFFC 
                    18519   ; //Wait for TIP bit in Status Register 
                    18520   ; WaitForI2C_TIP();
00006372  4E92      18521          jsr       (A2)
                    18522   ; //Send data to Transmit register
                    18523   ; I2C_Transmit = ADC_DAC_WRITE_ADDRESS;
00006374  13FC 0092 18524          move.b    #146,4227078
00006378  0040 8006 
                    18525   ; //Set Command register
                    18526   ; I2C_Command = I2C_Slave_Write_Start_Command;
0000637C  13FC 0091 18527          move.b    #145,4227080
00006380  0040 8008 
                    18528   ; //Wait for TIP bit in Status Register 
                    18529   ; WaitForI2C_TIP();
00006384  4E92      18530          jsr       (A2)
                    18531   ; //Wait RxACK bit in Status Register 
                    18532   ; WaitForI2C_RxACK();
00006386  4E93      18533          jsr       (A3)
                    18534   ; //Send data to Transmit register
                    18535   ; I2C_Transmit = ADC_ENABLE_COMMAND;
00006388  13FC 0044 18536          move.b    #68,4227078
0000638C  0040 8006 
                    18537   ; //Set Command register
                    18538   ; I2C_Command = I2C_Slave_Write_Command;
00006390  13FC 0011 18539          move.b    #17,4227080
00006394  0040 8008 
                    18540   ; //Wait for TIP bit in Status Register 
                    18541   ; WaitForI2C_TIP();
00006398  4E92      18542          jsr       (A2)
                    18543   ; //Wait RxACK bit in Status Register 
                    18544   ; WaitForI2C_RxACK();
0000639A  4E93      18545          jsr       (A3)
                    18546   ; //Send data to Transmit register
                    18547   ; I2C_Transmit = ADC_READ_ADDRESS;
0000639C  13FC 0093 18548          move.b    #147,4227078
000063A0  0040 8006 
                    18549   ; //Set Command register
                    18550   ; I2C_Command = I2C_Slave_Write_Start_Command;
000063A4  13FC 0091 18551          move.b    #145,4227080
000063A8  0040 8008 
                    18552   ; //Wait for TIP bit in Status Register 
                    18553   ; WaitForI2C_TIP();
000063AC  4E92      18554          jsr       (A2)
                    18555   ; //Wait RxACK bit in Status Register 
                    18556   ; WaitForI2C_RxACK();
000063AE  4E93      18557          jsr       (A3)
                    18558   ; //Set Command register to skip
                    18559   ; I2C_Command = I2C_Slave_Read_Command;
000063B0  13FC 0021 18560          move.b    #33,4227080
000063B4  0040 8008 
                    18561   ; //Wait for TIP bit in Status Register 
                    18562   ; WaitForI2C_TIP();
000063B8  4E92      18563          jsr       (A2)
                    18564   ; //Set Command register to skip
                    18565   ; I2C_Command = I2C_Slave_Read_Command;
000063BA  13FC 0021 18566          move.b    #33,4227080
000063BE  0040 8008 
                    18567   ; //Wait for TIP bit in Status Register 
                    18568   ; WaitForI2C_TIP();
000063C2  4E92      18569          jsr       (A2)
                    18570   ; //Grabbing read data from Receive Register for Thermistor
                    18571   ; c = I2C_Receive;
000063C4  1439 0040 18572          move.b    4227078,D2
000063C8  8006      
                    18573   ; temp = c;
000063CA  1D42 FFF9 18574          move.b    D2,-7(A6)
                    18575   ; //Set Command register to skip
                    18576   ; I2C_Command = I2C_Slave_Read_Command;
000063CE  13FC 0021 18577          move.b    #33,4227080
000063D2  0040 8008 
                    18578   ; //Wait for TIP bit in Status Register 
                    18579   ; WaitForI2C_TIP();
000063D6  4E92      18580          jsr       (A2)
                    18581   ; //Grabbing read data from Receive Register for Potentiometer
                    18582   ; c = I2C_Receive;
000063D8  1439 0040 18583          move.b    4227078,D2
000063DC  8006      
                    18584   ; potential = c;
000063DE  1D42 FFFB 18585          move.b    D2,-5(A6)
                    18586   ; //Set Command register to skip
                    18587   ; I2C_Command = I2C_Slave_Read_Command;
000063E2  13FC 0021 18588          move.b    #33,4227080
000063E6  0040 8008 
                    18589   ; //Wait for TIP bit in Status Register 
                    18590   ; WaitForI2C_TIP();
000063EA  4E92      18591          jsr       (A2)
                    18592   ; //Grabbing read data from Receive Register for Photo-resister
                    18593   ; c = I2C_Receive;
000063EC  1439 0040 18594          move.b    4227078,D2
000063F0  8006      
                    18595   ; light = c;
000063F2  1D42 FFFA 18596          move.b    D2,-6(A6)
                    18597   ; c = 0xFF; //Give garabage value after in case
000063F6  143C 00FF 18598          move.b    #255,D2
                    18599   ; if(type == TEMP){
000063FA  4A83      18600          tst.l     D3
000063FC  6606      18601          bne.s     ADCWrite_1
                    18602   ; return temp;
000063FE  102E FFF9 18603          move.b    -7(A6),D0
00006402  601E      18604          bra.s     ADCWrite_3
                    18605   ADCWrite_1:
                    18606   ; }else if(type == POTENTIAL){
00006404  0C83 0000 18607          cmp.l     #1,D3
00006408  0001      
0000640A  6606      18608          bne.s     ADCWrite_4
                    18609   ; return potential;
0000640C  102E FFFB 18610          move.b    -5(A6),D0
00006410  6010      18611          bra.s     ADCWrite_3
                    18612   ADCWrite_4:
                    18613   ; }else if(type == LIGHT){
00006412  0C83 0000 18614          cmp.l     #2,D3
00006416  0002      
00006418  6606      18615          bne.s     ADCWrite_6
                    18616   ; return light;
0000641A  102E FFFA 18617          move.b    -6(A6),D0
0000641E  6002      18618          bra.s     ADCWrite_3
                    18619   ADCWrite_6:
                    18620   ; }else{
                    18621   ; return c;
00006420  1002      18622          move.b    D2,D0
                    18623   ADCWrite_3:
00006422  4CDF 0C0C 18624          movem.l   (A7)+,D2/D3/A2/A3
00006426  4E5E      18625          unlk      A6
00006428  4E75      18626          rts
                    18627   ; }
                    18628   ; }
                    18629   _printf:
0000642A  4E56 FFFC 18630          link      A6,#-4
0000642E  48E7 2000 18631          movem.l   D2,-(A7)
00006432  41EE 0008 18632          lea       8(A6),A0
00006436  5848      18633          addq.w    #4,A0
00006438  2408      18634          move.l    A0,D2
0000643A  2F02      18635          move.l    D2,-(A7)
0000643C  2F2E 0008 18636          move.l    8(A6),-(A7)
00006440  42A7      18637          clr.l     -(A7)
00006442  6100 0248 18638          bsr       _vsprintf
00006446  DEFC 000C 18639          add.w     #12,A7
0000644A  2D40 FFFC 18640          move.l    D0,-4(A6)
0000644E  4282      18641          clr.l     D2
00006450  202E FFFC 18642          move.l    -4(A6),D0
00006454  4CDF 0004 18643          movem.l   (A7)+,D2
00006458  4E5E      18644          unlk      A6
0000645A  4E75      18645          rts
                    18646   ULMUL:
0000645C  4E56 0000 18647          link    A6,#0
00006460  48E7 C000 18648          movem.l D0/D1,-(A7)
00006464  222E 0008 18649          move.l  8(A6),D1
00006468  202E 000C 18650          move.l  12(A6),D0
0000646C  602C      18651          bra.s   lmul_3
                    18652   LMUL:
0000646E  4E56 0000 18653          link    A6,#0
00006472  48E7 C000 18654          movem.l D0/D1,-(A7)
00006476  222E 0008 18655          move.l  8(A6),D1
0000647A  202E 000C 18656          move.l  12(A6),D0
0000647E  4A80      18657          tst.l   D0
00006480  6A0A      18658          bpl.s   lmul_1
00006482  4480      18659          neg.l   D0
00006484  4A81      18660          tst.l   D1
00006486  6A0A      18661          bpl.s   lmul_2
00006488  4481      18662          neg.l   D1
0000648A  600E      18663          bra.s   lmul_3
                    18664   lmul_1:
0000648C  4A81      18665          tst.l   D1
0000648E  6A0A      18666          bpl.s   lmul_3
00006490  4481      18667          neg.l   D1
                    18668   lmul_2:
00006492  6114      18669          bsr.s   domul
00006494  4481      18670          neg.l   D1
00006496  4080      18671          negx.l  D0
00006498  6002      18672          bra.s   lmul_4
                    18673   lmul_3:
0000649A  610C      18674          bsr.s   domul
                    18675   lmul_4:
0000649C  2D41 0008 18676          move.l  D1,8(A6)
000064A0  4CDF 0003 18677          movem.l (A7)+,D0/D1
000064A4  4E5E      18678          unlk    A6
000064A6  4E75      18679          rts
                    18680   domul:
000064A8  0C81 0000 18681          cmpi.l  #$FFFF,D1
000064AC  FFFF      
000064AE  620C      18682          bhi.s   domul_1
000064B0  0C80 0000 18683          cmpi.l  #$FFFF,D0
000064B4  FFFF      
000064B6  620E      18684          bhi.s   domul_2
000064B8  C2C0      18685          mulu    D0,D1
000064BA  4E75      18686          rts
                    18687   domul_1:
000064BC  0C80 0000 18688          cmpi.l  #$FFFF,D0
000064C0  FFFF      
000064C2  6218      18689          bhi.s   domul_4
000064C4  6002      18690          bra.s   domul_3
                    18691   domul_2
000064C6  C141      18692          exg     D0,D1
                    18693   domul_3:
000064C8  2F02      18694          move.l  D2,-(A7)
000064CA  2401      18695          move.l  D1,D2
000064CC  4842      18696          swap    D2
000064CE  C2C0      18697          mulu    D0,D1
000064D0  C4C0      18698          mulu    D0,D2
000064D2  4842      18699          swap    D2
000064D4  4242      18700          clr.w   D2
000064D6  D282      18701          add.l   D2,D1
000064D8  241F      18702          move.l  (A7)+,D2
000064DA  4E75      18703          rts
                    18704   domul_4:
000064DC  48E7 3000 18705          movem.l D2/D3,-(A7)
000064E0  2401      18706          move.l  D1,D2
000064E2  2601      18707          move.l  D1,D3
000064E4  C2C0      18708          mulu    D0,D1
000064E6  4842      18709          swap    D2
000064E8  C4C0      18710          mulu    D0,D2
000064EA  4840      18711          swap    D0
000064EC  C6C0      18712          mulu    D0,D3
000064EE  D483      18713          add.l   D3,D2
000064F0  4842      18714          swap    D2
000064F2  4242      18715          clr.w   D2
000064F4  D282      18716          add.l   D2,D1
000064F6  4CDF 000C 18717          movem.l (A7)+,D2/D3
000064FA  4E75      18718          rts
                    18719   ULDIV:
000064FC  4E56 0000 18720          link    A6,#0
00006500  48E7 C000 18721          movem.l D0/D1,-(A7)
00006504  222E 0008 18722          move.l  8(A6),D1
00006508  202E 000C 18723          move.l  12(A6),D0
0000650C  6036      18724          bra.s   ldiv_3
                    18725   LDIV:
0000650E  4E56 0000 18726          link    A6,#0
00006512  48E7 C000 18727          movem.l D0/D1,-(A7)
00006516  222E 0008 18728          move.l  8(A6),D1
0000651A  202E 000C 18729          move.l  12(A6),D0
0000651E  4A80      18730          tst.l   D0
00006520  6A0E      18731          bpl.s   ldiv_1
00006522  4480      18732          neg.l   D0
00006524  4A81      18733          tst.l   D1
00006526  6A14      18734          bpl.s   ldiv_2
00006528  4481      18735          neg.l   D1
0000652A  612A      18736          bsr.s   dodiv
0000652C  4481      18737          neg.l   D1
0000652E  6016      18738          bra.s   ldiv_4
                    18739   ldiv_1:
00006530  4A81      18740          tst.l   D1
00006532  6A10      18741          bpl.s   ldiv_3
00006534  4481      18742          neg.l   D1
00006536  611E      18743          bsr.s   dodiv
00006538  4480      18744          neg.l   D0
0000653A  600A      18745          bra.s   ldiv_4
                    18746   ldiv_2:
0000653C  6118      18747          bsr.s   dodiv
0000653E  4480      18748          neg.l   D0
00006540  4481      18749          neg.l   D1
00006542  6002      18750          bra.s   ldiv_4
                    18751   ldiv_3:
00006544  6110      18752          bsr.s   dodiv
                    18753   ldiv_4:
00006546  2D40 0008 18754          move.l  D0,8(A6)
0000654A  2D41 000C 18755          move.l  D1,12(A6)
0000654E  4CDF 0003 18756          movem.l (A7)+,D0/D1
00006552  4E5E      18757          unlk    A6
00006554  4E75      18758          rts
                    18759   dodiv:
00006556  0C81 0000 18760          cmpi.l  #$FFFF,D1
0000655A  FFFF      
0000655C  6236      18761          bhi.s   dodiv_2
0000655E  0C80 0000 18762          cmpi.l  #$FFFF,D0
00006562  FFFF      
00006564  6210      18763          bhi.s   dodiv_1
00006566  80C1      18764          divu    D1,D0
00006568  2200      18765          move.l  D0,D1
0000656A  4241      18766          clr.w   D1
0000656C  4841      18767          swap    D1
0000656E  0280 0000 18768          andi.l  #$FFFF,D0
00006572  FFFF      
00006574  4E75      18769          rts
                    18770   dodiv_1:
00006576  48A7 A000 18771          movem.w D0/D2,-(A7)
0000657A  4240      18772          clr.w   D0
0000657C  4840      18773          swap    D0
0000657E  80C1      18774          divu    D1,D0
00006580  3400      18775          move.w  D0,D2
00006582  301F      18776          move.w  (A7)+,D0
00006584  80C1      18777          divu    D1,D0
00006586  4840      18778          swap    D0
00006588  4281      18779          clr.l   D1
0000658A  3200      18780          move.w  D0,D1
0000658C  3002      18781          move.w  D2,D0
0000658E  4840      18782          swap    D0
00006590  341F      18783          move.w  (A7)+,D2
00006592  4E75      18784          rts
                    18785   dodiv_2:
00006594  48E7 3800 18786          movem.l D2/D3/D4,-(A7)
00006598  2401      18787          move.l  D1,D2
0000659A  4242      18788          clr.w   D2
0000659C  4842      18789          swap    D2
0000659E  5282      18790          addq.l  #1,D2
000065A0  2600      18791          move.l  D0,D3
000065A2  2801      18792          move.l  D1,D4
000065A4  2202      18793          move.l  D2,D1
000065A6  61CE      18794          bsr.s   dodiv_1
000065A8  2204      18795          move.l  D4,D1
000065AA  82C2      18796          divu    D2,D1
000065AC  80C1      18797          divu    D1,D0
000065AE  0280 0000 18798          andi.l  #$FFFF,D0
000065B2  FFFF      
                    18799   dodiv_3:
000065B4  2204      18800          move.l  D4,D1
000065B6  2404      18801          move.l  D4,D2
000065B8  4842      18802          swap    D2
000065BA  C2C0      18803          mulu    D0,D1
000065BC  C4C0      18804          mulu    D0,D2
000065BE  4842      18805          swap    D2
000065C0  D282      18806          add.l   D2,D1
000065C2  9283      18807          sub.l   D3,D1
000065C4  620A      18808          bhi.s   dodiv_4
000065C6  4481      18809          neg.l   D1
000065C8  B881      18810          cmp.l   D1,D4
000065CA  6208      18811          bhi.s   dodiv_5
000065CC  5280      18812          addq.l  #1,D0
000065CE  60E4      18813          bra.s   dodiv_3
                    18814   dodiv_4:
000065D0  5380      18815          subq.l  #1,D0
000065D2  60E0      18816          bra.s   dodiv_3
                    18817   dodiv_5:
000065D4  4CDF 001C 18818          movem.l (A7)+,D2/D3/D4
000065D8  4E75      18819          rts
                    18820   @vsprintf_copy:
000065DA  4E56 0000 18821          link      A6,#0
000065DE  206E 0008 18822          move.l    8(A6),A0
000065E2  4A90      18823          tst.l     (A0)
000065E4  6710      18824          beq.s     @vsprintf_copy_1
000065E6  202E 000C 18825          move.l    12(A6),D0
000065EA  206E 0008 18826          move.l    8(A6),A0
000065EE  2250      18827          move.l    (A0),A1
000065F0  5290      18828          addq.l    #1,(A0)
000065F2  1280      18829          move.b    D0,(A1)
000065F4  600A      18830          bra.s     @vsprintf_copy_2
                    18831   @vsprintf_copy_1:
000065F6  2F2E 000C 18832          move.l    12(A6),-(A7)
000065FA  6100 085C 18833          bsr       _putch
000065FE  584F      18834          addq.w    #4,A7
                    18835   @vsprintf_copy_2:
00006600  4E5E      18836          unlk      A6
00006602  4E75      18837          rts
                    18838   @vsprintf_getval:
00006604  4E56 0000 18839          link      A6,#0
00006608  48E7 3000 18840          movem.l   D2/D3,-(A7)
0000660C  242E 0008 18841          move.l    8(A6),D2
00006610  4283      18842          clr.l     D3
00006612  2042      18843          move.l    D2,A0
00006614  2050      18844          move.l    (A0),A0
00006616  1010      18845          move.b    (A0),D0
00006618  4880      18846          ext.w     D0
0000661A  48C0      18847          ext.l     D0
0000661C  0C80 0000 18848          cmp.l     #42,D0
00006620  002A      
00006622  6612      18849          bne.s     @vsprintf_getval_1
00006624  206E 000C 18850          move.l    12(A6),A0
00006628  2250      18851          move.l    (A0),A1
0000662A  5890      18852          addq.l    #4,(A0)
0000662C  2611      18853          move.l    (A1),D3
0000662E  2042      18854          move.l    D2,A0
00006630  5290      18855          addq.l    #1,(A0)
00006632  6000 004E 18856          bra       @vsprintf_getval_5
                    18857   @vsprintf_getval_1:
00006636  2042      18858          move.l    D2,A0
00006638  2050      18859          move.l    (A0),A0
0000663A  1010      18860          move.b    (A0),D0
0000663C  4880      18861          ext.w     D0
0000663E  48C0      18862          ext.l     D0
00006640  0C80 0000 18863          cmp.l     #48,D0
00006644  0030      
00006646  6D00 003A 18864          blt       @vsprintf_getval_5
0000664A  2042      18865          move.l    D2,A0
0000664C  2050      18866          move.l    (A0),A0
0000664E  1010      18867          move.b    (A0),D0
00006650  4880      18868          ext.w     D0
00006652  48C0      18869          ext.l     D0
00006654  0C80 0000 18870          cmp.l     #57,D0
00006658  0039      
0000665A  6E26      18871          bgt.s     @vsprintf_getval_5
0000665C  2F03      18872          move.l    D3,-(A7)
0000665E  4878 000A 18873          pea       10
00006662  6100 FE0A 18874          bsr       LMUL
00006666  2017      18875          move.l    (A7),D0
00006668  504F      18876          addq.w    #8,A7
0000666A  2042      18877          move.l    D2,A0
0000666C  2250      18878          move.l    (A0),A1
0000666E  5290      18879          addq.l    #1,(A0)
00006670  1211      18880          move.b    (A1),D1
00006672  4881      18881          ext.w     D1
00006674  48C1      18882          ext.l     D1
00006676  D081      18883          add.l     D1,D0
00006678  0480 0000 18884          sub.l     #48,D0
0000667C  0030      
0000667E  2600      18885          move.l    D0,D3
00006680  60B4      18886          bra       @vsprintf_getval_1
                    18887   @vsprintf_getval_5:
00006682  2003      18888          move.l    D3,D0
00006684  4CDF 000C 18889          movem.l   (A7)+,D2/D3
00006688  4E5E      18890          unlk      A6
0000668A  4E75      18891          rts
                    18892   _vsprintf:
0000668C  4E56 FFCC 18893          link      A6,#-52
00006690  48E7 3F3C 18894          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00006694  45EE 0008 18895          lea       8(A6),A2
00006698  47F8 65DA 18896          lea       @vsprintf_copy,A3
0000669C  49F9 0000 18897          lea       _ultoa,A4
000066A0  6DE4      
000066A2  4286      18898          clr.l     D6
                    18899   vsprintf_1:
000066A4  206E 000C 18900          move.l    12(A6),A0
000066A8  4A10      18901          tst.b     (A0)
000066AA  6700 0624 18902          beq       vsprintf_3
000066AE  206E 000C 18903          move.l    12(A6),A0
000066B2  1010      18904          move.b    (A0),D0
000066B4  4880      18905          ext.w     D0
000066B6  48C0      18906          ext.l     D0
000066B8  0C80 0000 18907          cmp.l     #37,D0
000066BC  0025      
000066BE  671C      18908          beq.s     vsprintf_4
000066C0  206E 000C 18909          move.l    12(A6),A0
000066C4  52AE 000C 18910          addq.l    #1,12(A6)
000066C8  1210      18911          move.b    (A0),D1
000066CA  4881      18912          ext.w     D1
000066CC  48C1      18913          ext.l     D1
000066CE  2F01      18914          move.l    D1,-(A7)
000066D0  2F0A      18915          move.l    A2,-(A7)
000066D2  4E93      18916          jsr       (A3)
000066D4  504F      18917          addq.w    #8,A7
000066D6  5286      18918          addq.l    #1,D6
000066D8  6000 05F2 18919          bra       vsprintf_2
                    18920   vsprintf_4:
000066DC  52AE 000C 18921          addq.l    #1,12(A6)
000066E0  422E FFD3 18922          clr.b     -45(A6)
000066E4  422E FFD2 18923          clr.b     -46(A6)
000066E8  422E FFD0 18924          clr.b     -48(A6)
000066EC  422E FFCF 18925          clr.b     -49(A6)
000066F0  422E FFCE 18926          clr.b     -50(A6)
000066F4  422E FFCD 18927          clr.b     -51(A6)
000066F8  42AE FFFC 18928          clr.l     -4(A6)
000066FC  7AFF      18929          moveq     #-1,D5
000066FE  41EE FFDC 18930          lea       -36(A6),A0
00006702  2608      18931          move.l    A0,D3
00006704  2408      18932          move.l    A0,D2
                    18933   vsprintf_6:
00006706  206E 000C 18934          move.l    12(A6),A0
0000670A  1010      18935          move.b    (A0),D0
0000670C  4880      18936          ext.w     D0
0000670E  48C0      18937          ext.l     D0
00006710  0C80 0000 18938          cmp.l     #43,D0
00006714  002B      
00006716  6730      18939          beq.s     vsprintf_12
00006718  6E18      18940          bgt.s     vsprintf_15
0000671A  0C80 0000 18941          cmp.l     #35,D0
0000671E  0023      
00006720  6700 003E 18942          beq       vsprintf_14
00006724  6E00 0046 18943          bgt       vsprintf_9
00006728  0C80 0000 18944          cmp.l     #32,D0
0000672C  0020      
0000672E  6724      18945          beq.s     vsprintf_13
00006730  603A      18946          bra.s     vsprintf_9
                    18947   vsprintf_15:
00006732  0C80 0000 18948          cmp.l     #45,D0
00006736  002D      
00006738  6702      18949          beq.s     vsprintf_11
0000673A  6030      18950          bra.s     vsprintf_9
                    18951   vsprintf_11:
0000673C  1D7C 0001 18952          move.b    #1,-51(A6)
00006740  FFCD      
00006742  52AE 000C 18953          addq.l    #1,12(A6)
00006746  6026      18954          bra.s     vsprintf_7
                    18955   vsprintf_12:
00006748  1D7C 0001 18956          move.b    #1,-50(A6)
0000674C  FFCE      
0000674E  52AE 000C 18957          addq.l    #1,12(A6)
00006752  601A      18958          bra.s     vsprintf_7
                    18959   vsprintf_13:
00006754  1D7C 0001 18960          move.b    #1,-49(A6)
00006758  FFCF      
0000675A  52AE 000C 18961          addq.l    #1,12(A6)
0000675E  600E      18962          bra.s     vsprintf_7
                    18963   vsprintf_14:
00006760  1D7C 0001 18964          move.b    #1,-48(A6)
00006764  FFD0      
00006766  52AE 000C 18965          addq.l    #1,12(A6)
0000676A  6002      18966          bra.s     vsprintf_7
                    18967   vsprintf_9:
0000676C  6002      18968          bra.s     vsprintf_8
                    18969   vsprintf_7:
0000676E  6096      18970          bra       vsprintf_6
                    18971   vsprintf_8:
00006770  206E 000C 18972          move.l    12(A6),A0
00006774  1010      18973          move.b    (A0),D0
00006776  4880      18974          ext.w     D0
00006778  48C0      18975          ext.l     D0
0000677A  0C80 0000 18976          cmp.l     #48,D0
0000677E  0030      
00006780  660A      18977          bne.s     vsprintf_16
00006782  52AE 000C 18978          addq.l    #1,12(A6)
00006786  1D7C 0001 18979          move.b    #1,-46(A6)
0000678A  FFD2      
                    18980   vsprintf_16:
0000678C  486E 0010 18981          pea       16(A6)
00006790  486E 000C 18982          pea       12(A6)
00006794  6100 FE6E 18983          bsr       @vsprintf_getval
00006798  504F      18984          addq.w    #8,A7
0000679A  2A40      18985          move.l    D0,A5
0000679C  206E 000C 18986          move.l    12(A6),A0
000067A0  1010      18987          move.b    (A0),D0
000067A2  4880      18988          ext.w     D0
000067A4  48C0      18989          ext.l     D0
000067A6  0C80 0000 18990          cmp.l     #46,D0
000067AA  002E      
000067AC  6614      18991          bne.s     vsprintf_18
000067AE  52AE 000C 18992          addq.l    #1,12(A6)
000067B2  486E 0010 18993          pea       16(A6)
000067B6  486E 000C 18994          pea       12(A6)
000067BA  6100 FE48 18995          bsr       @vsprintf_getval
000067BE  504F      18996          addq.w    #8,A7
000067C0  2A00      18997          move.l    D0,D5
                    18998   vsprintf_18:
000067C2  206E 000C 18999          move.l    12(A6),A0
000067C6  1010      19000          move.b    (A0),D0
000067C8  4880      19001          ext.w     D0
000067CA  48C0      19002          ext.l     D0
000067CC  0C80 0000 19003          cmp.l     #108,D0
000067D0  006C      
000067D2  660A      19004          bne.s     vsprintf_20
000067D4  52AE 000C 19005          addq.l    #1,12(A6)
000067D8  1D7C 0001 19006          move.b    #1,-45(A6)
000067DC  FFD3      
                    19007   vsprintf_20:
000067DE  206E 000C 19008          move.l    12(A6),A0
000067E2  1010      19009          move.b    (A0),D0
000067E4  4880      19010          ext.w     D0
000067E6  48C0      19011          ext.l     D0
000067E8  0C80 0000 19012          cmp.l     #111,D0
000067EC  006F      
000067EE  6700 00D4 19013          beq       vsprintf_27
000067F2  6E34      19014          bgt.s     vsprintf_33
000067F4  0C80 0000 19015          cmp.l     #100,D0
000067F8  0064      
000067FA  6700 0054 19016          beq       vsprintf_24
000067FE  6E1C      19017          bgt.s     vsprintf_34
00006800  0C80 0000 19018          cmp.l     #99,D0
00006804  0063      
00006806  6700 012C 19019          beq       vsprintf_30
0000680A  6E00 016A 19020          bgt       vsprintf_22
0000680E  0C80 0000 19021          cmp.l     #88,D0
00006812  0058      
00006814  6700 00E6 19022          beq       vsprintf_28
00006818  6000 015C 19023          bra       vsprintf_22
                    19024   vsprintf_34:
0000681C  0C80 0000 19025          cmp.l     #105,D0
00006820  0069      
00006822  672C      19026          beq.s     vsprintf_24
00006824  6000 0150 19027          bra       vsprintf_22
                    19028   vsprintf_33:
00006828  0C80 0000 19029          cmp.l     #117,D0
0000682C  0075      
0000682E  6700 005C 19030          beq       vsprintf_26
00006832  6E0E      19031          bgt.s     vsprintf_35
00006834  0C80 0000 19032          cmp.l     #115,D0
00006838  0073      
0000683A  6700 011C 19033          beq       vsprintf_31
0000683E  6000 0136 19034          bra       vsprintf_22
                    19035   vsprintf_35:
00006842  0C80 0000 19036          cmp.l     #120,D0
00006846  0078      
00006848  6700 00B2 19037          beq       vsprintf_28
0000684C  6000 0128 19038          bra       vsprintf_22
                    19039   vsprintf_24:
00006850  4A2E FFD3 19040          tst.b     -45(A6)
00006854  671A      19041          beq.s     vsprintf_36
00006856  4878 000A 19042          pea       10
0000685A  2F03      19043          move.l    D3,-(A7)
0000685C  206E 0010 19044          move.l    16(A6),A0
00006860  58AE 0010 19045          addq.l    #4,16(A6)
00006864  2F10      19046          move.l    (A0),-(A7)
00006866  6100 04F8 19047          bsr       _ltoa
0000686A  DEFC 000C 19048          add.w     #12,A7
0000686E  6018      19049          bra.s     vsprintf_37
                    19050   vsprintf_36:
00006870  4878 000A 19051          pea       10
00006874  2F03      19052          move.l    D3,-(A7)
00006876  206E 0010 19053          move.l    16(A6),A0
0000687A  58AE 0010 19054          addq.l    #4,16(A6)
0000687E  2F10      19055          move.l    (A0),-(A7)
00006880  6100 04DE 19056          bsr       _ltoa
00006884  DEFC 000C 19057          add.w     #12,A7
                    19058   vsprintf_37:
00006888  6000 00FA 19059          bra       vsprintf_23
                    19060   vsprintf_26:
0000688C  4A2E FFD3 19061          tst.b     -45(A6)
00006890  6718      19062          beq.s     vsprintf_38
00006892  4878 000A 19063          pea       10
00006896  2F03      19064          move.l    D3,-(A7)
00006898  206E 0010 19065          move.l    16(A6),A0
0000689C  58AE 0010 19066          addq.l    #4,16(A6)
000068A0  2F10      19067          move.l    (A0),-(A7)
000068A2  4E94      19068          jsr       (A4)
000068A4  DEFC 000C 19069          add.w     #12,A7
000068A8  6016      19070          bra.s     vsprintf_39
                    19071   vsprintf_38:
000068AA  4878 000A 19072          pea       10
000068AE  2F03      19073          move.l    D3,-(A7)
000068B0  206E 0010 19074          move.l    16(A6),A0
000068B4  58AE 0010 19075          addq.l    #4,16(A6)
000068B8  2F10      19076          move.l    (A0),-(A7)
000068BA  4E94      19077          jsr       (A4)
000068BC  DEFC 000C 19078          add.w     #12,A7
                    19079   vsprintf_39:
000068C0  6000 00C2 19080          bra       vsprintf_23
                    19081   vsprintf_27:
000068C4  4A2E FFD3 19082          tst.b     -45(A6)
000068C8  6718      19083          beq.s     vsprintf_40
000068CA  4878 0008 19084          pea       8
000068CE  2F03      19085          move.l    D3,-(A7)
000068D0  206E 0010 19086          move.l    16(A6),A0
000068D4  58AE 0010 19087          addq.l    #4,16(A6)
000068D8  2F10      19088          move.l    (A0),-(A7)
000068DA  4E94      19089          jsr       (A4)
000068DC  DEFC 000C 19090          add.w     #12,A7
000068E0  6016      19091          bra.s     vsprintf_41
                    19092   vsprintf_40:
000068E2  4878 0008 19093          pea       8
000068E6  2F03      19094          move.l    D3,-(A7)
000068E8  206E 0010 19095          move.l    16(A6),A0
000068EC  58AE 0010 19096          addq.l    #4,16(A6)
000068F0  2F10      19097          move.l    (A0),-(A7)
000068F2  4E94      19098          jsr       (A4)
000068F4  DEFC 000C 19099          add.w     #12,A7
                    19100   vsprintf_41:
000068F8  6000 008A 19101          bra       vsprintf_23
                    19102   vsprintf_28:
000068FC  4A2E FFD3 19103          tst.b     -45(A6)
00006900  6718      19104          beq.s     vsprintf_42
00006902  4878 0010 19105          pea       16
00006906  2F03      19106          move.l    D3,-(A7)
00006908  206E 0010 19107          move.l    16(A6),A0
0000690C  58AE 0010 19108          addq.l    #4,16(A6)
00006910  2F10      19109          move.l    (A0),-(A7)
00006912  4E94      19110          jsr       (A4)
00006914  DEFC 000C 19111          add.w     #12,A7
00006918  6016      19112          bra.s     vsprintf_43
                    19113   vsprintf_42:
0000691A  4878 0010 19114          pea       16
0000691E  2F03      19115          move.l    D3,-(A7)
00006920  206E 0010 19116          move.l    16(A6),A0
00006924  58AE 0010 19117          addq.l    #4,16(A6)
00006928  2F10      19118          move.l    (A0),-(A7)
0000692A  4E94      19119          jsr       (A4)
0000692C  DEFC 000C 19120          add.w     #12,A7
                    19121   vsprintf_43:
00006930  6000 0052 19122          bra       vsprintf_23
                    19123   vsprintf_30:
00006934  206E 0010 19124          move.l    16(A6),A0
00006938  58AE 0010 19125          addq.l    #4,16(A6)
0000693C  2010      19126          move.l    (A0),D0
0000693E  2042      19127          move.l    D2,A0
00006940  5282      19128          addq.l    #1,D2
00006942  1080      19129          move.b    D0,(A0)
00006944  2042      19130          move.l    D2,A0
00006946  4210      19131          clr.b     (A0)
00006948  200D      19132          move.l    A5,D0
0000694A  6704      19133          beq.s     vsprintf_44
0000694C  200D      19134          move.l    A5,D0
0000694E  6002      19135          bra.s     vsprintf_45
                    19136   vsprintf_44:
00006950  7001      19137          moveq     #1,D0
                    19138   vsprintf_45:
00006952  2A00      19139          move.l    D0,D5
00006954  6000 002E 19140          bra       vsprintf_23
                    19141   vsprintf_31:
00006958  206E 0010 19142          move.l    16(A6),A0
0000695C  58AE 0010 19143          addq.l    #4,16(A6)
00006960  2610      19144          move.l    (A0),D3
00006962  0C85 FFFF 19145          cmp.l     #-1,D5
00006966  FFFF      
00006968  660A      19146          bne.s     vsprintf_46
0000696A  2F03      19147          move.l    D3,-(A7)
0000696C  6100 04D8 19148          bsr       _strlen
00006970  584F      19149          addq.w    #4,A7
00006972  2A00      19150          move.l    D0,D5
                    19151   vsprintf_46:
00006974  600E      19152          bra.s     vsprintf_23
                    19153   vsprintf_22:
00006976  206E 000C 19154          move.l    12(A6),A0
0000697A  2242      19155          move.l    D2,A1
0000697C  5282      19156          addq.l    #1,D2
0000697E  1290      19157          move.b    (A0),(A1)
00006980  2042      19158          move.l    D2,A0
00006982  4210      19159          clr.b     (A0)
                    19160   vsprintf_23:
00006984  2F03      19161          move.l    D3,-(A7)
00006986  6100 04BE 19162          bsr       _strlen
0000698A  584F      19163          addq.w    #4,A7
0000698C  1800      19164          move.b    D0,D4
0000698E  206E 000C 19165          move.l    12(A6),A0
00006992  1010      19166          move.b    (A0),D0
00006994  4880      19167          ext.w     D0
00006996  48C0      19168          ext.l     D0
00006998  0C80 0000 19169          cmp.l     #115,D0
0000699C  0073      
0000699E  6618      19170          bne.s     vsprintf_48
000069A0  0C85 0000 19171          cmp.l     #0,D5
000069A4  0000      
000069A6  6D10      19172          blt.s     vsprintf_48
000069A8  4884      19173          ext.w     D4
000069AA  48C4      19174          ext.l     D4
000069AC  B885      19175          cmp.l     D5,D4
000069AE  6F04      19176          ble.s     vsprintf_50
000069B0  1005      19177          move.b    D5,D0
000069B2  6002      19178          bra.s     vsprintf_51
                    19179   vsprintf_50:
000069B4  1004      19180          move.b    D4,D0
                    19181   vsprintf_51:
000069B6  1800      19182          move.b    D0,D4
                    19183   vsprintf_48:
000069B8  206E 000C 19184          move.l    12(A6),A0
000069BC  1010      19185          move.b    (A0),D0
000069BE  4880      19186          ext.w     D0
000069C0  48C0      19187          ext.l     D0
000069C2  0C80 0000 19188          cmp.l     #88,D0
000069C6  0058      
000069C8  6600 0026 19189          bne       vsprintf_56
000069CC  41EE FFDC 19190          lea       -36(A6),A0
000069D0  2408      19191          move.l    A0,D2
                    19192   vsprintf_54:
000069D2  2042      19193          move.l    D2,A0
000069D4  4A10      19194          tst.b     (A0)
000069D6  6718      19195          beq.s     vsprintf_56
000069D8  2042      19196          move.l    D2,A0
000069DA  1210      19197          move.b    (A0),D1
000069DC  4881      19198          ext.w     D1
000069DE  48C1      19199          ext.l     D1
000069E0  2F01      19200          move.l    D1,-(A7)
000069E2  6100 04A4 19201          bsr       _toupper
000069E6  584F      19202          addq.w    #4,A7
000069E8  2042      19203          move.l    D2,A0
000069EA  1080      19204          move.b    D0,(A0)
000069EC  5282      19205          addq.l    #1,D2
000069EE  60E2      19206          bra       vsprintf_54
                    19207   vsprintf_56:
000069F0  7E00      19208          moveq     #0,D7
000069F2  41EE FFD4 19209          lea       -44(A6),A0
000069F6  2408      19210          move.l    A0,D2
000069F8  206E 000C 19211          move.l    12(A6),A0
000069FC  1010      19212          move.b    (A0),D0
000069FE  4880      19213          ext.w     D0
00006A00  48C0      19214          ext.l     D0
00006A02  0C80 0000 19215          cmp.l     #100,D0
00006A06  0064      
00006A08  6714      19216          beq.s     vsprintf_59
00006A0A  206E 000C 19217          move.l    12(A6),A0
00006A0E  1010      19218          move.b    (A0),D0
00006A10  4880      19219          ext.w     D0
00006A12  48C0      19220          ext.l     D0
00006A14  0C80 0000 19221          cmp.l     #105,D0
00006A18  0069      
00006A1A  6600 0076 19222          bne       vsprintf_65
                    19223   vsprintf_59:
00006A1E  4A2E FFCE 19224          tst.b     -50(A6)
00006A22  6612      19225          bne.s     vsprintf_62
00006A24  2043      19226          move.l    D3,A0
00006A26  1010      19227          move.b    (A0),D0
00006A28  4880      19228          ext.w     D0
00006A2A  48C0      19229          ext.l     D0
00006A2C  0C80 0000 19230          cmp.l     #45,D0
00006A30  002D      
00006A32  6600 002E 19231          bne       vsprintf_60
                    19232   vsprintf_62:
00006A36  2043      19233          move.l    D3,A0
00006A38  1010      19234          move.b    (A0),D0
00006A3A  4880      19235          ext.w     D0
00006A3C  48C0      19236          ext.l     D0
00006A3E  0C80 0000 19237          cmp.l     #45,D0
00006A42  002D      
00006A44  660E      19238          bne.s     vsprintf_63
00006A46  2043      19239          move.l    D3,A0
00006A48  5283      19240          addq.l    #1,D3
00006A4A  2242      19241          move.l    D2,A1
00006A4C  5282      19242          addq.l    #1,D2
00006A4E  1290      19243          move.b    (A0),(A1)
00006A50  5304      19244          subq.b    #1,D4
00006A52  6008      19245          bra.s     vsprintf_64
                    19246   vsprintf_63:
00006A54  2042      19247          move.l    D2,A0
00006A56  5282      19248          addq.l    #1,D2
00006A58  10BC 002B 19249          move.b    #43,(A0)
                    19250   vsprintf_64:
00006A5C  5287      19251          addq.l    #1,D7
00006A5E  6000 0032 19252          bra       vsprintf_65
                    19253   vsprintf_60:
00006A62  4A2E FFCF 19254          tst.b     -49(A6)
00006A66  6700 002A 19255          beq       vsprintf_65
00006A6A  2043      19256          move.l    D3,A0
00006A6C  1010      19257          move.b    (A0),D0
00006A6E  4880      19258          ext.w     D0
00006A70  48C0      19259          ext.l     D0
00006A72  0C80 0000 19260          cmp.l     #45,D0
00006A76  002D      
00006A78  660E      19261          bne.s     vsprintf_67
00006A7A  2043      19262          move.l    D3,A0
00006A7C  5283      19263          addq.l    #1,D3
00006A7E  2242      19264          move.l    D2,A1
00006A80  5282      19265          addq.l    #1,D2
00006A82  1290      19266          move.b    (A0),(A1)
00006A84  5304      19267          subq.b    #1,D4
00006A86  6008      19268          bra.s     vsprintf_68
                    19269   vsprintf_67:
00006A88  2042      19270          move.l    D2,A0
00006A8A  5282      19271          addq.l    #1,D2
00006A8C  10BC 0020 19272          move.b    #32,(A0)
                    19273   vsprintf_68:
00006A90  5287      19274          addq.l    #1,D7
                    19275   vsprintf_65:
00006A92  4A2E FFD0 19276          tst.b     -48(A6)
00006A96  6700 0066 19277          beq       vsprintf_77
00006A9A  206E 000C 19278          move.l    12(A6),A0
00006A9E  1010      19279          move.b    (A0),D0
00006AA0  4880      19280          ext.w     D0
00006AA2  48C0      19281          ext.l     D0
00006AA4  0C80 0000 19282          cmp.l     #111,D0
00006AA8  006F      
00006AAA  671A      19283          beq.s     vsprintf_73
00006AAC  6E0C      19284          bgt.s     vsprintf_76
00006AAE  0C80 0000 19285          cmp.l     #88,D0
00006AB2  0058      
00006AB4  6710      19286          beq.s     vsprintf_73
00006AB6  6000 0046 19287          bra       vsprintf_77
                    19288   vsprintf_76:
00006ABA  0C80 0000 19289          cmp.l     #120,D0
00006ABE  0078      
00006AC0  6704      19290          beq.s     vsprintf_73
00006AC2  6000 003A 19291          bra       vsprintf_77
                    19292   vsprintf_73:
00006AC6  2042      19293          move.l    D2,A0
00006AC8  5282      19294          addq.l    #1,D2
00006ACA  10BC 0030 19295          move.b    #48,(A0)
00006ACE  5287      19296          addq.l    #1,D7
00006AD0  206E 000C 19297          move.l    12(A6),A0
00006AD4  1010      19298          move.b    (A0),D0
00006AD6  4880      19299          ext.w     D0
00006AD8  48C0      19300          ext.l     D0
00006ADA  0C80 0000 19301          cmp.l     #120,D0
00006ADE  0078      
00006AE0  6712      19302          beq.s     vsprintf_79
00006AE2  206E 000C 19303          move.l    12(A6),A0
00006AE6  1010      19304          move.b    (A0),D0
00006AE8  4880      19305          ext.w     D0
00006AEA  48C0      19306          ext.l     D0
00006AEC  0C80 0000 19307          cmp.l     #88,D0
00006AF0  0058      
00006AF2  660A      19308          bne.s     vsprintf_77
                    19309   vsprintf_79:
00006AF4  2042      19310          move.l    D2,A0
00006AF6  5282      19311          addq.l    #1,D2
00006AF8  10BC 0078 19312          move.b    #120,(A0)
00006AFC  5287      19313          addq.l    #1,D7
                    19314   vsprintf_77:
00006AFE  2042      19315          move.l    D2,A0
00006B00  4210      19316          clr.b     (A0)
00006B02  206E 000C 19317          move.l    12(A6),A0
00006B06  1010      19318          move.b    (A0),D0
00006B08  4880      19319          ext.w     D0
00006B0A  48C0      19320          ext.l     D0
00006B0C  0C80 0000 19321          cmp.l     #105,D0
00006B10  0069      
00006B12  6700 0076 19322          beq       vsprintf_82
00006B16  6E42      19323          bgt.s     vsprintf_93
00006B18  0C80 0000 19324          cmp.l     #99,D0
00006B1C  0063      
00006B1E  6700 0084 19325          beq       vsprintf_96
00006B22  6E1C      19326          bgt.s     vsprintf_94
00006B24  0C80 0000 19327          cmp.l     #88,D0
00006B28  0058      
00006B2A  6700 005E 19328          beq       vsprintf_82
00006B2E  6E00 0184 19329          bgt       vsprintf_80
00006B32  0C80 0000 19330          cmp.l     #69,D0
00006B36  0045      
00006B38  6700 0050 19331          beq       vsprintf_82
00006B3C  6000 0176 19332          bra       vsprintf_80
                    19333   vsprintf_94:
00006B40  0C80 0000 19334          cmp.l     #101,D0
00006B44  0065      
00006B46  6700 0042 19335          beq       vsprintf_82
00006B4A  6E00 0168 19336          bgt       vsprintf_80
00006B4E  0C80 0000 19337          cmp.l     #100,D0
00006B52  0064      
00006B54  6734      19338          beq.s     vsprintf_82
00006B56  6000 015C 19339          bra       vsprintf_80
                    19340   vsprintf_93:
00006B5A  0C80 0000 19341          cmp.l     #117,D0
00006B5E  0075      
00006B60  6728      19342          beq.s     vsprintf_82
00006B62  6E1A      19343          bgt.s     vsprintf_95
00006B64  0C80 0000 19344          cmp.l     #115,D0
00006B68  0073      
00006B6A  6700 0038 19345          beq       vsprintf_96
00006B6E  6E00 0144 19346          bgt       vsprintf_80
00006B72  0C80 0000 19347          cmp.l     #111,D0
00006B76  006F      
00006B78  6710      19348          beq.s     vsprintf_82
00006B7A  6000 0138 19349          bra       vsprintf_80
                    19350   vsprintf_95:
00006B7E  0C80 0000 19351          cmp.l     #120,D0
00006B82  0078      
00006B84  6704      19352          beq.s     vsprintf_82
00006B86  6000 012C 19353          bra       vsprintf_80
                    19354   vsprintf_82:
00006B8A  4A2E FFD2 19355          tst.b     -46(A6)
00006B8E  6714      19356          beq.s     vsprintf_96
00006B90  4A2E FFCD 19357          tst.b     -51(A6)
00006B94  660E      19358          bne.s     vsprintf_96
00006B96  200D      19359          move.l    A5,D0
00006B98  9087      19360          sub.l     D7,D0
00006B9A  4884      19361          ext.w     D4
00006B9C  48C4      19362          ext.l     D4
00006B9E  9084      19363          sub.l     D4,D0
00006BA0  2D40 FFFC 19364          move.l    D0,-4(A6)
                    19365   vsprintf_96:
00006BA4  202E FFFC 19366          move.l    -4(A6),D0
00006BA8  0C80 0000 19367          cmp.l     #0,D0
00006BAC  0000      
00006BAE  6C04      19368          bge.s     vsprintf_98
00006BB0  42AE FFFC 19369          clr.l     -4(A6)
                    19370   vsprintf_98:
00006BB4  4A2E FFCD 19371          tst.b     -51(A6)
00006BB8  6600 0030 19372          bne       vsprintf_104
00006BBC  4884      19373          ext.w     D4
00006BBE  48C4      19374          ext.l     D4
00006BC0  2004      19375          move.l    D4,D0
00006BC2  D0AE FFFC 19376          add.l     -4(A6),D0
00006BC6  D087      19377          add.l     D7,D0
00006BC8  1D40 FFD1 19378          move.b    D0,-47(A6)
                    19379   vsprintf_102:
00006BCC  102E FFD1 19380          move.b    -47(A6),D0
00006BD0  4880      19381          ext.w     D0
00006BD2  48C0      19382          ext.l     D0
00006BD4  220D      19383          move.l    A5,D1
00006BD6  534D      19384          subq.w    #1,A5
00006BD8  B081      19385          cmp.l     D1,D0
00006BDA  6C0E      19386          bge.s     vsprintf_104
00006BDC  4878 0020 19387          pea       32
00006BE0  2F0A      19388          move.l    A2,-(A7)
00006BE2  4E93      19389          jsr       (A3)
00006BE4  504F      19390          addq.w    #8,A7
00006BE6  5286      19391          addq.l    #1,D6
00006BE8  60E2      19392          bra       vsprintf_102
                    19393   vsprintf_104:
00006BEA  41EE FFD4 19394          lea       -44(A6),A0
00006BEE  2408      19395          move.l    A0,D2
                    19396   vsprintf_105:
00006BF0  2042      19397          move.l    D2,A0
00006BF2  4A10      19398          tst.b     (A0)
00006BF4  6716      19399          beq.s     vsprintf_107
00006BF6  2042      19400          move.l    D2,A0
00006BF8  5282      19401          addq.l    #1,D2
00006BFA  1210      19402          move.b    (A0),D1
00006BFC  4881      19403          ext.w     D1
00006BFE  48C1      19404          ext.l     D1
00006C00  2F01      19405          move.l    D1,-(A7)
00006C02  2F0A      19406          move.l    A2,-(A7)
00006C04  4E93      19407          jsr       (A3)
00006C06  504F      19408          addq.w    #8,A7
00006C08  5286      19409          addq.l    #1,D6
00006C0A  60E4      19410          bra       vsprintf_105
                    19411   vsprintf_107:
00006C0C  202E FFFC 19412          move.l    -4(A6),D0
00006C10  1D40 FFD1 19413          move.b    D0,-47(A6)
                    19414   vsprintf_108:
00006C14  102E FFD1 19415          move.b    -47(A6),D0
00006C18  532E FFD1 19416          subq.b    #1,-47(A6)
00006C1C  4A00      19417          tst.b     D0
00006C1E  670E      19418          beq.s     vsprintf_110
00006C20  4878 0030 19419          pea       48
00006C24  2F0A      19420          move.l    A2,-(A7)
00006C26  4E93      19421          jsr       (A3)
00006C28  504F      19422          addq.w    #8,A7
00006C2A  5286      19423          addq.l    #1,D6
00006C2C  60E6      19424          bra       vsprintf_108
                    19425   vsprintf_110:
00006C2E  2043      19426          move.l    D3,A0
00006C30  4A10      19427          tst.b     (A0)
00006C32  6700 0048 19428          beq       vsprintf_113
00006C36  206E 000C 19429          move.l    12(A6),A0
00006C3A  1010      19430          move.b    (A0),D0
00006C3C  4880      19431          ext.w     D0
00006C3E  48C0      19432          ext.l     D0
00006C40  0C80 0000 19433          cmp.l     #115,D0
00006C44  0073      
00006C46  670C      19434          beq.s     vsprintf_116
00006C48  6E18      19435          bgt.s     vsprintf_119
00006C4A  0C80 0000 19436          cmp.l     #99,D0
00006C4E  0063      
00006C50  6702      19437          beq.s     vsprintf_116
00006C52  600E      19438          bra.s     vsprintf_119
                    19439   vsprintf_116:
00006C54  2005      19440          move.l    D5,D0
00006C56  5385      19441          subq.l    #1,D5
00006C58  0C80 0000 19442          cmp.l     #0,D0
00006C5C  0000      
00006C5E  6E02      19443          bgt.s     vsprintf_119
00006C60  6016      19444          bra.s     vsprintf_115
                    19445   vsprintf_119:
00006C62  2043      19446          move.l    D3,A0
00006C64  5283      19447          addq.l    #1,D3
00006C66  1210      19448          move.b    (A0),D1
00006C68  4881      19449          ext.w     D1
00006C6A  48C1      19450          ext.l     D1
00006C6C  2F01      19451          move.l    D1,-(A7)
00006C6E  2F0A      19452          move.l    A2,-(A7)
00006C70  4E93      19453          jsr       (A3)
00006C72  504F      19454          addq.w    #8,A7
00006C74  5286      19455          addq.l    #1,D6
00006C76  6002      19456          bra.s     vsprintf_112
                    19457   vsprintf_115:
00006C78  6002      19458          bra.s     vsprintf_113
                    19459   vsprintf_112:
00006C7A  60B2      19460          bra       vsprintf_110
                    19461   vsprintf_113:
00006C7C  4A2E FFCD 19462          tst.b     -51(A6)
00006C80  6700 0030 19463          beq       vsprintf_125
00006C84  4884      19464          ext.w     D4
00006C86  48C4      19465          ext.l     D4
00006C88  2004      19466          move.l    D4,D0
00006C8A  D0AE FFFC 19467          add.l     -4(A6),D0
00006C8E  D087      19468          add.l     D7,D0
00006C90  1D40 FFD1 19469          move.b    D0,-47(A6)
                    19470   vsprintf_123:
00006C94  102E FFD1 19471          move.b    -47(A6),D0
00006C98  4880      19472          ext.w     D0
00006C9A  48C0      19473          ext.l     D0
00006C9C  220D      19474          move.l    A5,D1
00006C9E  534D      19475          subq.w    #1,A5
00006CA0  B081      19476          cmp.l     D1,D0
00006CA2  6C0E      19477          bge.s     vsprintf_125
00006CA4  4878 0020 19478          pea       32
00006CA8  2F0A      19479          move.l    A2,-(A7)
00006CAA  4E93      19480          jsr       (A3)
00006CAC  504F      19481          addq.w    #8,A7
00006CAE  5386      19482          subq.l    #1,D6
00006CB0  60E2      19483          bra       vsprintf_123
                    19484   vsprintf_125:
00006CB2  6014      19485          bra.s     vsprintf_81
                    19486   vsprintf_80:
00006CB4  206E 000C 19487          move.l    12(A6),A0
00006CB8  1210      19488          move.b    (A0),D1
00006CBA  4881      19489          ext.w     D1
00006CBC  48C1      19490          ext.l     D1
00006CBE  2F01      19491          move.l    D1,-(A7)
00006CC0  2F0A      19492          move.l    A2,-(A7)
00006CC2  4E93      19493          jsr       (A3)
00006CC4  504F      19494          addq.w    #8,A7
00006CC6  5286      19495          addq.l    #1,D6
                    19496   vsprintf_81:
00006CC8  52AE 000C 19497          addq.l    #1,12(A6)
                    19498   vsprintf_2:
00006CCC  6000 F9D6 19499          bra       vsprintf_1
                    19500   vsprintf_3:
00006CD0  4A92      19501          tst.l     (A2)
00006CD2  6710      19502          beq.s     vsprintf_126
00006CD4  4201      19503          clr.b     D1
00006CD6  C2BC 0000 19504          and.l     #255,D1
00006CDA  00FF      
00006CDC  2F01      19505          move.l    D1,-(A7)
00006CDE  2F0A      19506          move.l    A2,-(A7)
00006CE0  4E93      19507          jsr       (A3)
00006CE2  504F      19508          addq.w    #8,A7
                    19509   vsprintf_126:
00006CE4  2006      19510          move.l    D6,D0
00006CE6  4CDF 3CFC 19511          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00006CEA  4E5E      19512          unlk      A6
00006CEC  4E75      19513          rts
                    19514   @itoa_convert:
00006CEE  4E56 0000 19515          link      A6,#0
00006CF2  48E7 3C00 19516          movem.l   D2/D3/D4/D5,-(A7)
00006CF6  242E 0008 19517          move.l    8(A6),D2
00006CFA  262E 0010 19518          move.l    16(A6),D3
00006CFE  2A2E 000C 19519          move.l    12(A6),D5
00006D02  2F05      19520          move.l    D5,-(A7)
00006D04  2F03      19521          move.l    D3,-(A7)
00006D06  6100 F7F4 19522          bsr       ULDIV
00006D0A  202F 0004 19523          move.l    4(A7),D0
00006D0E  504F      19524          addq.w    #8,A7
00006D10  2800      19525          move.l    D0,D4
00006D12  BA83      19526          cmp.l     D3,D5
00006D14  651A      19527          blo.s     @itoa_convert_1
00006D16  2F03      19528          move.l    D3,-(A7)
00006D18  2F05      19529          move.l    D5,-(A7)
00006D1A  2F03      19530          move.l    D3,-(A7)
00006D1C  6100 F7DE 19531          bsr       ULDIV
00006D20  2217      19532          move.l    (A7),D1
00006D22  504F      19533          addq.w    #8,A7
00006D24  2F01      19534          move.l    D1,-(A7)
00006D26  2F02      19535          move.l    D2,-(A7)
00006D28  61C4      19536          bsr       @itoa_convert
00006D2A  DEFC 000C 19537          add.w     #12,A7
00006D2E  2400      19538          move.l    D0,D2
                    19539   @itoa_convert_1:
00006D30  0C84 0000 19540          cmp.l     #9,D4
00006D34  0009      
00006D36  6E0A      19541          bgt.s     @itoa_convert_3
00006D38  2004      19542          move.l    D4,D0
00006D3A  0680 0000 19543          add.l     #48,D0
00006D3E  0030      
00006D40  600E      19544          bra.s     @itoa_convert_4
                    19545   @itoa_convert_3:
00006D42  2004      19546          move.l    D4,D0
00006D44  0680 0000 19547          add.l     #97,D0
00006D48  0061      
00006D4A  0480 0000 19548          sub.l     #10,D0
00006D4E  000A      
                    19549   @itoa_convert_4:
00006D50  2042      19550          move.l    D2,A0
00006D52  1080      19551          move.b    D0,(A0)
00006D54  2002      19552          move.l    D2,D0
00006D56  5280      19553          addq.l    #1,D0
00006D58  4CDF 003C 19554          movem.l   (A7)+,D2/D3/D4/D5
00006D5C  4E5E      19555          unlk      A6
00006D5E  4E75      19556          rts
                    19557   _ltoa:
00006D60  4E56 0000 19558          link      A6,#0
00006D64  48E7 3C00 19559          movem.l   D2/D3/D4/D5,-(A7)
00006D68  242E 0008 19560          move.l    8(A6),D2
00006D6C  262E 000C 19561          move.l    12(A6),D3
00006D70  2A2E 0010 19562          move.l    16(A6),D5
00006D74  2803      19563          move.l    D3,D4
00006D76  0C85 0000 19564          cmp.l     #2,D5
00006D7A  0002      
00006D7C  6D08      19565          blt.s     ltoa_3
00006D7E  0C85 0000 19566          cmp.l     #36,D5
00006D82  0024      
00006D84  6F06      19567          ble.s     ltoa_1
                    19568   ltoa_3:
00006D86  2003      19569          move.l    D3,D0
00006D88  6000 0052 19570          bra       ltoa_4
                    19571   ltoa_1:
00006D8C  0C85 0000 19572          cmp.l     #10,D5
00006D90  000A      
00006D92  6600 0032 19573          bne       ltoa_5
00006D96  0C82 0000 19574          cmp.l     #0,D2
00006D9A  0000      
00006D9C  6C28      19575          bge.s     ltoa_5
00006D9E  2002      19576          move.l    D2,D0
00006DA0  4480      19577          neg.l     D0
00006DA2  2400      19578          move.l    D0,D2
00006DA4  0C82 0000 19579          cmp.l     #0,D2
00006DA8  0000      
00006DAA  6C12      19580          bge.s     ltoa_7
00006DAC  4879 0800 19581          pea       @itoa_1
00006DB0  0000      
00006DB2  2F03      19582          move.l    D3,-(A7)
00006DB4  6100 00FE 19583          bsr       _strcpy
00006DB8  504F      19584          addq.w    #8,A7
00006DBA  2003      19585          move.l    D3,D0
00006DBC  601E      19586          bra.s     ltoa_4
                    19587   ltoa_7:
00006DBE  2044      19588          move.l    D4,A0
00006DC0  5284      19589          addq.l    #1,D4
00006DC2  10BC 002D 19590          move.b    #45,(A0)
                    19591   ltoa_5:
00006DC6  2F05      19592          move.l    D5,-(A7)
00006DC8  2F02      19593          move.l    D2,-(A7)
00006DCA  2F04      19594          move.l    D4,-(A7)
00006DCC  6100 FF20 19595          bsr       @itoa_convert
00006DD0  DEFC 000C 19596          add.w     #12,A7
00006DD4  2800      19597          move.l    D0,D4
00006DD6  2044      19598          move.l    D4,A0
00006DD8  4210      19599          clr.b     (A0)
00006DDA  2003      19600          move.l    D3,D0
                    19601   ltoa_4:
00006DDC  4CDF 003C 19602          movem.l   (A7)+,D2/D3/D4/D5
00006DE0  4E5E      19603          unlk      A6
00006DE2  4E75      19604          rts
                    19605   _ultoa:
00006DE4  4E56 0000 19606          link      A6,#0
00006DE8  48E7 3800 19607          movem.l   D2/D3/D4,-(A7)
00006DEC  262E 0010 19608          move.l    16(A6),D3
00006DF0  282E 000C 19609          move.l    12(A6),D4
00006DF4  2404      19610          move.l    D4,D2
00006DF6  0C83 0000 19611          cmp.l     #2,D3
00006DFA  0002      
00006DFC  6D08      19612          blt.s     ultoa_3
00006DFE  0C83 0000 19613          cmp.l     #36,D3
00006E02  0024      
00006E04  6F04      19614          ble.s     ultoa_1
                    19615   ultoa_3:
00006E06  2004      19616          move.l    D4,D0
00006E08  6018      19617          bra.s     ultoa_4
                    19618   ultoa_1:
00006E0A  2F03      19619          move.l    D3,-(A7)
00006E0C  2F2E 0008 19620          move.l    8(A6),-(A7)
00006E10  2F02      19621          move.l    D2,-(A7)
00006E12  6100 FEDA 19622          bsr       @itoa_convert
00006E16  DEFC 000C 19623          add.w     #12,A7
00006E1A  2400      19624          move.l    D0,D2
00006E1C  2042      19625          move.l    D2,A0
00006E1E  4210      19626          clr.b     (A0)
00006E20  2004      19627          move.l    D4,D0
                    19628   ultoa_4:
00006E22  4CDF 001C 19629          movem.l   (A7)+,D2/D3/D4
00006E26  4E5E      19630          unlk      A6
00006E28  4E75      19631          rts
                    19632   _itoa:
00006E2A  4E56 0000 19633          link      A6,#0
00006E2E  2F2E 0010 19634          move.l    16(A6),-(A7)
00006E32  2F2E 000C 19635          move.l    12(A6),-(A7)
00006E36  2F2E 0008 19636          move.l    8(A6),-(A7)
00006E3A  6100 FF24 19637          bsr       _ltoa
00006E3E  DEFC 000C 19638          add.w     #12,A7
00006E42  4E5E      19639          unlk      A6
00006E44  4E75      19640          rts
                    19641   _strlen:
00006E46  206F 0004 19642          move.l    (4,A7),A0
00006E4A  2248      19643          move.l    A0,A1
                    19644   strlen_1:
00006E4C  4A19      19645          tst.b     (A1)+
00006E4E  66FC      19646          bne       strlen_1
00006E50  2009      19647          move.l    A1,D0
00006E52  9088      19648          sub.l     A0,D0
00006E54  5380      19649          subq.l    #1,D0
00006E56  4E75      19650          rts
                    19651   _putch:
00006E58  4E56 0000 19652          link      A6,#0
00006E5C  48E7 2000 19653          movem.l   D2,-(A7)
00006E60  242E 0008 19654          move.l    8(A6),D2
00006E64  0C82 0000 19655          cmp.l     #10,D2
00006E68  000A      
00006E6A  660A      19656          bne.s     putch_1
00006E6C  4878 000D 19657          pea       13
00006E70  6100 EF08 19658          bsr       __putch
00006E74  584F      19659          addq.w    #4,A7
                    19660   putch_1:
00006E76  2F02      19661          move.l    D2,-(A7)
00006E78  6100 EF00 19662          bsr       __putch
00006E7C  584F      19663          addq.w    #4,A7
00006E7E  2002      19664          move.l    D2,D0
00006E80  4CDF 0004 19665          movem.l   (A7)+,D2
00006E84  4E5E      19666          unlk      A6
00006E86  4E75      19667          rts
                    19668   _toupper:
00006E88  4E56 0000 19669          link      A6,#0
00006E8C  48E7 2000 19670          movem.l   D2,-(A7)
00006E90  242E 0008 19671          move.l    8(A6),D2
00006E94  0C82 0000 19672          cmp.l     #97,D2
00006E98  0061      
00006E9A  6D0E      19673          blt.s     toupper_1
00006E9C  0C82 0000 19674          cmp.l     #122,D2
00006EA0  007A      
00006EA2  6E06      19675          bgt.s     toupper_1
00006EA4  C4BC 0000 19676          and.l     #95,D2
00006EA8  005F      
                    19677   toupper_1:
00006EAA  2002      19678          move.l    D2,D0
00006EAC  4CDF 0004 19679          movem.l   (A7)+,D2
00006EB0  4E5E      19680          unlk      A6
00006EB2  4E75      19681          rts
                    19682   _strcpy:
00006EB4  206F 0004 19683          move.l    (4,A7),A0
00006EB8  226F 0008 19684          move.l    (8,A7),A1
00006EBC  2008      19685          move.l    A0,D0
                    19686   strcpy_1:
00006EBE  10D9      19687          move.b    (A1)+,(A0)+
00006EC0  66FC      19688          bne       strcpy_1
00006EC2  4E75      19689          rts
                    19690          section   const
          0000 6EC4 19691   const      equ         *				; consts start whever the linker groups them, after the code section (but still in rom)
                    19692   
                    19693   @asn6b_~1_1:
00006EC4  416C 7465 19694          dc.b      65,108,116,101,114,97,32,68,69,49,47,54,56,75
00006EC8  7261 2044 
00006ECC  4531 2F36 
00006ED0  384B      
00006ED2  00        19695          dc.b      0
                    19696   @asn6b_~1_2:
00006ED4  4D69 6372 19697          dc.b      77,105,99,114,105,117,109,32,117,67,47,79,83
00006ED8  6975 6D20 
00006EDC  7543 2F4F 
00006EE0  53        
00006EE1  2D49 4920 19698          dc.b      45,73,73,32,82,84,79,83,0
00006EE5  5254 4F53 
00006EE9  00        
                    19699   @asn6b_~1_3:
00006EEA  7C3D 3D3D 19700          dc.b      124,61,61,61,61,61,61,61,61,61,77,69,65,83,85
00006EEE  3D3D 3D3D 
00006EF2  3D3D 4D45 
00006EF6  4153 55   
00006EF9  5249 4E47 19701          dc.b      82,73,78,71,61,61,61,61,61,61,61,61,61,61,124
00006EFD  3D3D 3D3D 
00006F01  3D3D 3D3D 
00006F05  3D3D 7C   
00006F08  0A00      19702          dc.b      10,0
                    19703   @asn6b_~1_4:
00006F0A  7C3D 3D3D 19704          dc.b      124,61,61,61,61,61,61,61,61,61,61,61,61,61,61
00006F0E  3D3D 3D3D 
00006F12  3D3D 3D3D 
00006F16  3D3D 3D   
00006F19  3D3D 3D3D 19705          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,61,124,10
00006F1D  3D3D 3D3D 
00006F21  3D3D 3D3D 
00006F25  3D7C 0A   
00006F28  00        19706          dc.b      0
                    19707   @ucos_ii_1:
00006F2A  3F00      19708          dc.b      63,0
                    19709   @ucos_ii_2:
00006F2C  7543 2F4F 19710          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
00006F30  532D 4949 
00006F34  2049 646C 
00006F38  6500      
                    19711   @ucos_ii_3:
00006F3A  7543 2F4F 19712          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
00006F3E  532D 4949 
00006F42  2053 7461 
00006F46  7400      
                    19713   @ucos_ii_4:
00006F48  7543 2F4F 19714          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
00006F4C  532D 4949 
00006F50  2054 6D72 
00006F54  4C6F      
00006F56  636B 00   19715          dc.b      99,107,0
                    19716   @ucos_ii_5:
00006F5A  7543 2F4F 19717          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
00006F5E  532D 4949 
00006F62  2054 6D72 
00006F66  5369      
00006F68  676E 616C 19718          dc.b      103,110,97,108,0
00006F6C  00        
                    19719   @ucos_ii_6:
00006F6E  7543 2F4F 19720          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
00006F72  532D 4949 
00006F76  2054 6D72 
00006F7A  00        
                    19721   _OSUnMapTbl:
00006F7C  0000 0100 19722          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
00006F80  0200 0100 
00006F84  0300 0100 
00006F88  0200 0100 
00006F8C  0400 0100 
00006F90  0200      
00006F92  0100 0300 19723          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
00006F96  0100 0200 
00006F9A  0100 0500 
00006F9E  0100 0200 
00006FA2  0100 0300 
00006FA6  0100      
00006FA8  0200 0100 19724          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
00006FAC  0400 0100 
00006FB0  0200 0100 
00006FB4  0300 0100 
00006FB8  0200 0100 
00006FBC  0600      
00006FBE  0100 0200 19725          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
00006FC2  0100 0300 
00006FC6  0100 0200 
00006FCA  0100 0400 
00006FCE  0100 0200 
00006FD2  0100      
00006FD4  0300 0100 19726          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
00006FD8  0200 0100 
00006FDC  0500 0100 
00006FE0  0200 0100 
00006FE4  0300 0100 
00006FE8  0200      
00006FEA  0100 0400 19727          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
00006FEE  0100 0200 
00006FF2  0100 0300 
00006FF6  0100 0200 
00006FFA  0100 0700 
00006FFE  0100      
00007000  0200 0100 19728          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
00007004  0300 0100 
00007008  0200 0100 
0000700C  0400 0100 
00007010  0200 0100 
00007014  0300      
00007016  0100 0200 19729          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
0000701A  0100 0500 
0000701E  0100 0200 
00007022  0100 0300 
00007026  0100 0200 
0000702A  0100      
0000702C  0400 0100 19730          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
00007030  0200 0100 
00007034  0300 0100 
00007038  0200 0100 
0000703C  0600 0100 
00007040  0200      
00007042  0100 0300 19731          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
00007046  0100 0200 
0000704A  0100 0400 
0000704E  0100 0200 
00007052  0100 0300 
00007056  0100      
00007058  0200 0100 19732          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
0000705C  0500 0100 
00007060  0200 0100 
00007064  0300 0100 
00007068  0200 0100 
0000706C  0400      
0000706E  0100 0200 19733          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
00007072  0100 0300 
00007076  0100 0200 
0000707A  0100      
                    19734   @canbus~1_1:
0000707C  5661 6C75 19735          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
00007080  6520 6F66 
00007084  2054 6865 
00007088  72        
00007089  6D69 7374 19736          dc.b      109,105,115,116,111,114,32,40,67,65,78,48,41
0000708D  6F72 2028 
00007091  4341 4E30 
00007095  29        
00007096  3A20 2564 19737          dc.b      58,32,37,100,10,0
0000709A  0A00      
                    19738   @canbus~1_2:
0000709C  5661 6C75 19739          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
000070A0  6520 6F66 
000070A4  2050 6F74 
000070A8  65        
000070A9  6E74 696F 19740          dc.b      110,116,105,111,109,101,116,101,114,32,40,67
000070AD  6D65 7465 
000070B1  7220 2843 
000070B5  414E 3029 19741          dc.b      65,78,48,41,58,32,37,100,10,0
000070B9  3A20 2564 
000070BD  0A00      
                    19742   @canbus~1_3:
000070C0  5661 6C75 19743          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
000070C4  6520 6F66 
000070C8  2050 686F 
000070CC  74        
000070CD  6F2D 7265 19744          dc.b      111,45,114,101,115,105,115,116,101,114,32,40
000070D1  7369 7374 
000070D5  6572 2028 
000070D9  4341 4E30 19745          dc.b      67,65,78,48,41,58,32,37,100,10,0
000070DD  293A 2025 
000070E1  640A 00   
                    19746   @canbus~1_4:
000070E4  5661 6C75 19747          dc.b      86,97,108,117,101,32,111,102,32,83,87,91,55
000070E8  6520 6F66 
000070EC  2053 575B 
000070F0  37        
000070F1  2D30 5D20 19748          dc.b      45,48,93,32,40,67,65,78,48,41,58,32,0
000070F5  2843 414E 
000070F9  3029 3A20 
000070FD  00        
                    19749   @canbus~1_5:
000070FE  3000      19750          dc.b      48,0
                    19751   @canbus~1_6:
00007100  3100      19752          dc.b      49,0
                    19753   @canbus~1_7:
00007102  0A00      19754          dc.b      10,0
                    19755   @canbus~1_8:
00007104  4552 524F 19756          dc.b      69,82,82,79,82,0
00007108  5200      
                    19757   @canbus~1_9:
0000710A  5661 6C75 19758          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
0000710E  6520 6F66 
00007112  2054 6865 
00007116  72        
00007117  6D69 7374 19759          dc.b      109,105,115,116,111,114,32,40,67,65,78,49,41
0000711B  6F72 2028 
0000711F  4341 4E31 
00007123  29        
00007124  3A20 2564 19760          dc.b      58,32,37,100,10,0
00007128  0A00      
                    19761   @canbus~1_10:
0000712A  5661 6C75 19762          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
0000712E  6520 6F66 
00007132  2050 6F74 
00007136  65        
00007137  6E74 696F 19763          dc.b      110,116,105,111,109,101,116,101,114,32,40,67
0000713B  6D65 7465 
0000713F  7220 2843 
00007143  414E 3129 19764          dc.b      65,78,49,41,58,32,37,100,10,0
00007147  3A20 2564 
0000714B  0A00      
                    19765   @canbus~1_11:
0000714E  5661 6C75 19766          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
00007152  6520 6F66 
00007156  2050 686F 
0000715A  74        
0000715B  6F2D 7265 19767          dc.b      111,45,114,101,115,105,115,116,101,114,32,40
0000715F  7369 7374 
00007163  6572 2028 
00007167  4341 4E31 19768          dc.b      67,65,78,49,41,58,32,37,100,10,0
0000716B  293A 2025 
0000716F  640A 00   
                    19769   @canbus~1_12:
00007172  5661 6C75 19770          dc.b      86,97,108,117,101,32,111,102,32,83,87,91,55
00007176  6520 6F66 
0000717A  2053 575B 
0000717E  37        
0000717F  2D30 5D20 19771          dc.b      45,48,93,32,40,67,65,78,49,41,58,32,0
00007183  2843 414E 
00007187  3129 3A20 
0000718B  00        
                    19772   @canbus~1_13:
0000718C  0D0A 0D0A 19773          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
00007190  2D2D 2D2D 
00007194  2043 414E 
00007198  4255 53   
0000719B  2054 6573 19774          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
0000719F  7420 2D2D 
000071A3  2D2D 0D0A 
000071A7  00        
                    19775   @canbus~1_14:
000071A8  0D0A 00   19776          dc.b      13,10,0
                    19777          section   data
          0000 71AC 19778   end_ROM    equ         *				; end of rom is wherever the last code/constant appears (* means here)
                    19779   
08000000            19780              org         RAM				; starting at address $08000000
          0800 0000 19781   begin_RAM  equ         *				; begin ram starts here
          0800 0000 19782   data       equ         *				; data starts here also
                    19783   
                    19784   @itoa_1:
08000000  2D32 3134 19785          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
08000004  3734 3833 
08000008  3634 3800 
                    19786          section   bss
          0800 000C 19787   bss        equ         *
                    19788   
                    19789   ;           org         $0B000000               Ram based vector table must be stored here otherwise InstallException Handler will not work
                    19790   
                    19791   *********************************************************************************************************
                    19792   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    19793   * install the exception handler using the C function InstallExceptionHandler()
                    19794   *********************************************************************************************************
                    19795   
0800000C            19796   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08000010            19797   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08000014            19798   VBusError        ds.l    1      storage for address of Bus Error Handler
08000018            19799   VAddressError    ds.l    1      storage for address of Address Error Handler
0800001C            19800   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08000020            19801   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08000024            19802   VCheck           ds.l    1      ditto
08000028            19803   VTrapV           ds.l    1      ditto
0800002C            19804   VPrivilege       ds.l    1      ditto
08000030            19805   VTrace           ds.l    1
08000034            19806   VLine1010emul    ds.l    1
08000038            19807   VLine1111emul    ds.l    1
0800003C            19808   VUnassigned1     ds.l    1
08000040            19809   VUnassigned2     ds.l    1
08000044            19810   VUnassigned3     ds.l    1
08000048            19811   VUninit_IRQ      ds.l    1
0800004C            19812   VUnassigned4     ds.l    1
08000050            19813   VUnassigned5     ds.l    1
08000054            19814   VUnassigned6     ds.l    1
08000058            19815   VUnassigned7     ds.l    1
0800005C            19816   VUnassigned8     ds.l    1
08000060            19817   VUnassigned9     ds.l    1
08000064            19818   VUnassigned10    ds.l    1
08000068            19819   VUnassigned11    ds.l    1
0800006C            19820   VSpuriousIRQ     ds.l    1
                    19821   
                    19822   * Interrupt handlers Vector 25-31
08000070            19823   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000074            19824   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000078            19825   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0800007C            19826   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000080            19827   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000084            19828   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08000088            19829   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    19830   
                    19831   * Trap Handler vectors 32-47
0800008C            19832   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000090            19833   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000094            19834   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08000098            19835   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0800009C            19836   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A0            19837   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A4            19838   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000A8            19839   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000AC            19840   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B0            19841   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B4            19842   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000B8            19843   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000BC            19844   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C0            19845   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C4            19846   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080000C8            19847   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    19848   
                    19849   __ungetbuf:                            ; ungetbuffer for stdio functions
080000CC            19850              ds.l        1
                    19851   __timezone:                            ; difference, in seconds, between local time and UTC
080000D0            19852              ds.l        1
                    19853   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
080000D4            19854              ds.l        1
                    19855   __romsize:                             ; size of ROM used by program
080000D8            19856              ds.l        1
                    19857   __ramsize:                             ; size of RAM used by program
080000DC            19858              ds.l        1
                    19859   
                    19860   _Task1Stk:
080000E0            19861          ds.b      512
                    19862   _Task2Stk:
080002E0            19863          ds.b      512
                    19864   _Task3Stk:
080004E0            19865          ds.b      512
                    19866   _Task4Stk:
080006E0            19867          ds.b      512
                    19868   _Task5Stk:
080008E0            19869          ds.b      512
                    19870   _mutex:
08000AE0            19871          ds.b      4
                    19872   _temp:
08000AE4            19873          ds.b      1
                    19874   _potential:
08000AE6            19875          ds.b      1
                    19876   _light:
08000AE8            19877          ds.b      1
                    19878   _switches:
08000AEA            19879          ds.b      4
                    19880   _OSTmrTickCtr:
08000AEE            19881          ds.b      1
                    19882   _OSCtxSwCtr:
08000AF0            19883          ds.b      4
                    19884   _OSEventFreeList:
08000AF4            19885          ds.b      4
                    19886   _OSEventTbl:
08000AF8            19887          ds.b      220
                    19888   _OSFlagTbl:
08000BD4            19889          ds.b      60
                    19890   _OSFlagFreeList:
08000C10            19891          ds.b      4
                    19892   _OSCPUUsage:
08000C14            19893          ds.b      1
                    19894   _OSIdleCtrMax:
08000C16            19895          ds.b      4
                    19896   _OSIdleCtrRun:
08000C1A            19897          ds.b      4
                    19898   _OSStatRdy:
08000C1E            19899          ds.b      1
                    19900   _OSTaskStatStk:
08000C20            19901          ds.b      256
                    19902   _OSIntNesting:
08000D20            19903          ds.b      1
                    19904   _OSLockNesting:
08000D22            19905          ds.b      1
                    19906   _OSPrioCur:
08000D24            19907          ds.b      1
                    19908   _OSPrioHighRdy:
08000D26            19909          ds.b      1
                    19910   _OSRdyGrp:
08000D28            19911          ds.b      1
                    19912   _OSRdyTbl:
08000D2A            19913          ds.b      8
                    19914   _OSRunning:
08000D32            19915          ds.b      1
                    19916   _OSTaskCtr:
08000D34            19917          ds.b      1
                    19918   _OSIdleCtr:
08000D36            19919          ds.b      4
                    19920   _OSTaskIdleStk:
08000D3A            19921          ds.b      256
                    19922   _OSTCBCur:
08000E3A            19923          ds.b      4
                    19924   _OSTCBFreeList:
08000E3E            19925          ds.b      4
                    19926   _OSTCBHighRdy:
08000E42            19927          ds.b      4
                    19928   _OSTCBList:
08000E46            19929          ds.b      4
                    19930   _OSTCBPrioTbl:
08000E4A            19931          ds.b      256
                    19932   _OSTCBTbl:
08000F4A            19933          ds.b      1892
                    19934   _OSMemFreeList:
080016AE            19935          ds.b      4
                    19936   _OSMemTbl:
080016B2            19937          ds.b      120
                    19938   _OSQFreeList:
0800172A            19939          ds.b      4
                    19940   _OSQTbl:
0800172E            19941          ds.b      96
                    19942   _OSTaskRegNextAvailID:
0800178E            19943          ds.b      1
                    19944   _OSTime:
08001790            19945          ds.b      4
                    19946   _OSTmrFree:
08001794            19947          ds.b      2
                    19948   _OSTmrUsed:
08001796            19949          ds.b      2
                    19950   _OSTmrTime:
08001798            19951          ds.b      4
                    19952   _OSTmrSem:
0800179C            19953          ds.b      4
                    19954   _OSTmrSemSignal:
080017A0            19955          ds.b      4
                    19956   _OSTmrTbl:
080017A4            19957          ds.b      576
                    19958   _OSTmrFreeList:
080019E4            19959          ds.b      4
                    19960   _OSTmrTaskStk:
080019E8            19961          ds.b      256
                    19962   _OSTmrWheelTbl:
08001AE8            19963          ds.b      32
                    19964          section   heap
          0800 1B08 19965   end_RAM    equ         *				; wherever the program variables end, is the start of the heap
          0800 1B08 19966   heap       equ         *
                    19967   
          0801 0000 19968   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
