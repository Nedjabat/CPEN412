680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 25 Jan 2024      Time: 00:36:07          Source: C:\M68K\PROGRAMS\MEMORYTEST.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
          0804 0000    5   StackPointerVal     equ $08040000      when using sram
                       6   ;StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
          0803 0000   11   RamVectorTable      equ $08030000      when using sram
                      12   ;RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0804 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0803 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0803 
00000486  00C4      
00000488  23FC 0803  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  00C4 0803 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  0932      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0803  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0803  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0803  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0803  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
                     145                   move.l    #1,_Trace              switch on Trace Mode
********  **** ****  Error: Undefined or illegal symbol
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
                     147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
********  **** ****  Error: Undefined or illegal symbol
                     148                   move.l    (sp)+,_PC              get at the users program counter and copy
********  **** ****  Error: Undefined or illegal symbol
                     149   *
                     150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
********  **** ****  Error: Undefined or illegal symbol
                     151                   move.l    d0,_d0
********  **** ****  Error: Undefined or illegal symbol
                     152                   move.l    d1,_d1
********  **** ****  Error: Undefined or illegal symbol
                     153                   move.l    d2,_d2
********  **** ****  Error: Undefined or illegal symbol
                     154                   move.l    d3,_d3
********  **** ****  Error: Undefined or illegal symbol
                     155                   move.l    d4,_d4
********  **** ****  Error: Undefined or illegal symbol
                     156                   move.l    d5,_d5
********  **** ****  Error: Undefined or illegal symbol
                     157                   move.l    d6,_d6
********  **** ****  Error: Undefined or illegal symbol
                     158                   move.l    d7,_d7
********  **** ****  Error: Undefined or illegal symbol
                     159   *
                     160                   move.l    a0,_a0
********  **** ****  Error: Undefined or illegal symbol
                     161                   move.l    a1,_a1
********  **** ****  Error: Undefined or illegal symbol
                     162                   move.l    a2,_a2
********  **** ****  Error: Undefined or illegal symbol
                     163                   move.l    a3,_a3
********  **** ****  Error: Undefined or illegal symbol
                     164                   move.l    a4,_a4
********  **** ****  Error: Undefined or illegal symbol
                     165                   move.l    a5,_a5
********  **** ****  Error: Undefined or illegal symbol
                     166                   move.l    a6,_a6
********  **** ****  Error: Undefined or illegal symbol
00000560  4E68       167                   move.l    usp,a0
                     168                   move.l    a0,_USP
********  **** ****  Error: Undefined or illegal symbol
                     169   *
00000568  2079 0803  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
                     175                   move.l   _d0,d0
********  **** ****  Error: Undefined or illegal symbol
                     176                   move.l   _d1,d1
********  **** ****  Error: Undefined or illegal symbol
                     177                   move.l   _d2,d2
********  **** ****  Error: Undefined or illegal symbol
                     178                   move.l   _d3,d3
********  **** ****  Error: Undefined or illegal symbol
                     179                   move.l   _d4,d4
********  **** ****  Error: Undefined or illegal symbol
                     180                   move.l   _d5,d5
********  **** ****  Error: Undefined or illegal symbol
                     181                   move.l   _d6,d6
********  **** ****  Error: Undefined or illegal symbol
                     182                   move.l   _d7,d7
********  **** ****  Error: Undefined or illegal symbol
                     183   
                     184                   move.l   _USP,a0
********  **** ****  Error: Undefined or illegal symbol
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
                     186                   move.l   _a0,a0
********  **** ****  Error: Undefined or illegal symbol
                     187                   move.l   _a1,a1
********  **** ****  Error: Undefined or illegal symbol
                     188                   move.l   _a2,a2
********  **** ****  Error: Undefined or illegal symbol
                     189                   move.l   _a3,a3
********  **** ****  Error: Undefined or illegal symbol
                     190                   move.l   _a4,a4
********  **** ****  Error: Undefined or illegal symbol
                     191                   move.l   _a5,a5
********  **** ****  Error: Undefined or illegal symbol
                     192                   move.l   _a6,a6
********  **** ****  Error: Undefined or illegal symbol
                     193   
                     194                   move.l   _SSP,sp
********  **** ****  Error: Undefined or illegal symbol
                     195                   move.l   _PC,-(sp)
********  **** ****  Error: Undefined or illegal symbol
                     196                   move.w   _SR,-(sp)
********  **** ****  Error: Undefined or illegal symbol
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0803  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0803  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0803  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0803  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0803  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0803  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0803  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0803  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0803  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0803  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0803  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0803  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0803  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0803  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0803  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0803  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
                     307                   move.l    #1,_Trace      switch on Trace Mode
********  **** ****  Error: Undefined or illegal symbol
                     308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
********  **** ****  Error: Undefined or illegal symbol
                     309                   move.l    (sp)+,_PC      get at the users program counter and copy
********  **** ****  Error: Undefined or illegal symbol
                     310   *
                     311                   move.l    d0,_d0
********  **** ****  Error: Undefined or illegal symbol
                     312                   move.l    d1,_d1
********  **** ****  Error: Undefined or illegal symbol
                     313                   move.l    d2,_d2
********  **** ****  Error: Undefined or illegal symbol
                     314                   move.l    d3,_d3
********  **** ****  Error: Undefined or illegal symbol
                     315                   move.l    d4,_d4
********  **** ****  Error: Undefined or illegal symbol
                     316                   move.l    d5,_d5
********  **** ****  Error: Undefined or illegal symbol
                     317                   move.l    d6,_d6
********  **** ****  Error: Undefined or illegal symbol
                     318                   move.l    d7,_d7
********  **** ****  Error: Undefined or illegal symbol
                     319   *
                     320                   move.l    a0,_a0
********  **** ****  Error: Undefined or illegal symbol
                     321                   move.l    a1,_a1
********  **** ****  Error: Undefined or illegal symbol
                     322                   move.l    a2,_a2
********  **** ****  Error: Undefined or illegal symbol
                     323                   move.l    a3,_a3
********  **** ****  Error: Undefined or illegal symbol
                     324                   move.l    a4,_a4
********  **** ****  Error: Undefined or illegal symbol
                     325                   move.l    a5,_a5
********  **** ****  Error: Undefined or illegal symbol
                     326                   move.l    a6,_a6
********  **** ****  Error: Undefined or illegal symbol
0000077C  4E68       327                   move.l    USP,a0
                     328                   move.l    a0,_USP
********  **** ****  Error: Undefined or illegal symbol
                     329   *
00000784  2079 0803  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
                     336                   move.l   _d0,d0
********  **** ****  Error: Undefined or illegal symbol
                     337                   move.l   _d1,d1
********  **** ****  Error: Undefined or illegal symbol
                     338                   move.l   _d2,d2
********  **** ****  Error: Undefined or illegal symbol
                     339                   move.l   _d3,d3
********  **** ****  Error: Undefined or illegal symbol
                     340                   move.l   _d4,d4
********  **** ****  Error: Undefined or illegal symbol
                     341                   move.l   _d5,d5
********  **** ****  Error: Undefined or illegal symbol
                     342                   move.l   _d6,d6
********  **** ****  Error: Undefined or illegal symbol
                     343                   move.l   _d7,d7
********  **** ****  Error: Undefined or illegal symbol
                     344   
                     345                   move.l   _USP,a0
********  **** ****  Error: Undefined or illegal symbol
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
                     347                   move.l   _a0,a0
********  **** ****  Error: Undefined or illegal symbol
                     348                   move.l   _a1,a1
********  **** ****  Error: Undefined or illegal symbol
                     349                   move.l   _a2,a2
********  **** ****  Error: Undefined or illegal symbol
                     350                   move.l   _a3,a3
********  **** ****  Error: Undefined or illegal symbol
                     351                   move.l   _a4,a4
********  **** ****  Error: Undefined or illegal symbol
                     352                   move.l   _a5,a5
********  **** ****  Error: Undefined or illegal symbol
                     353                   move.l   _a6,a6
********  **** ****  Error: Undefined or illegal symbol
                     354   
                     355                   move.l   _PC,-(sp)
********  **** ****  Error: Undefined or illegal symbol
                     356                   move.w   _SR,-(sp)
********  **** ****  Error: Undefined or illegal symbol
000007FA  4E73       357                   rte
                     358   
                     359   Trap15RamISR    jmp     _CallDebugMonitor
********  **** ****  Error: Undefined or illegal symbol
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0803  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0803  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0803  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0803  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0803  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0803  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0803  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0803  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0803  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0803  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
                     443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
********  **** ****  Error: Undefined or illegal symbol
                     444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
********  **** ****  Error: Undefined or illegal symbol
                     445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
********  **** ****  Error: Undefined or illegal symbol
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
                     448                   move.l   _d0,d0
********  **** ****  Error: Undefined or illegal symbol
                     449                   move.l   _d1,d1
********  **** ****  Error: Undefined or illegal symbol
                     450                   move.l   _d2,d2
********  **** ****  Error: Undefined or illegal symbol
                     451                   move.l   _d3,d3
********  **** ****  Error: Undefined or illegal symbol
                     452                   move.l   _d4,d4
********  **** ****  Error: Undefined or illegal symbol
                     453                   move.l   _d5,d5
********  **** ****  Error: Undefined or illegal symbol
                     454                   move.l   _d6,d6
********  **** ****  Error: Undefined or illegal symbol
                     455                   move.l   _d7,d7
********  **** ****  Error: Undefined or illegal symbol
                     456   
                     457                   move.l   _USP,a0
********  **** ****  Error: Undefined or illegal symbol
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
                     459                   move.l   _a0,a0
********  **** ****  Error: Undefined or illegal symbol
                     460                   move.l   _a1,a1
********  **** ****  Error: Undefined or illegal symbol
                     461                   move.l   _a2,a2
********  **** ****  Error: Undefined or illegal symbol
                     462                   move.l   _a3,a3
********  **** ****  Error: Undefined or illegal symbol
                     463                   move.l   _a4,a4
********  **** ****  Error: Undefined or illegal symbol
                     464                   move.l   _a5,a5
********  **** ****  Error: Undefined or illegal symbol
                     465                   move.l   _a6,a6
********  **** ****  Error: Undefined or illegal symbol
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68K\PARTB-MYPROGRAM\MEMTEST.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include <stdio.h>
                     471   ; void main(void)
                     472   ; {
                     473   _main:
00000932  4E56 FFDC  474          link      A6,#-36
                     475   ; unsigned int test_option = 0;
00000936  42AE FFDC  476          clr.l     -36(A6)
                     477   ; unsigned int bit_num = 0;
0000093A  42AE FFE0  478          clr.l     -32(A6)
                     479   ; unsigned int test_pattern = 0;
0000093E  42AE FFE4  480          clr.l     -28(A6)
                     481   ; unsigned int select_pattern = 0;
00000942  42AE FFE8  482          clr.l     -24(A6)
                     483   ; unsigned int write_data = 0;
00000946  42AE FFEC  484          clr.l     -20(A6)
                     485   ; unsigned int start_addr = 0;
0000094A  42AE FFF0  486          clr.l     -16(A6)
                     487   ; unsigned int end_addr = 0;
0000094E  42AE FFF4  488          clr.l     -12(A6)
                     489   ; unsigned int *addr_point = NULL;
00000952  42AE FFF8  490          clr.l     -8(A6)
                     491   ; unsigned int counter = 10000;
00000956  2D7C 0000  492          move.l    #10000,-4(A6)
0000095A  2710 FFFC 
0000095E  4E5E       493          unlk      A6
00000960  4E75       494          rts
                     495   ; /*
                     496   ; //prompting user for test option BYTES, WORDS, or LONG WORDS
                     497   ; while(!test_option){
                     498   ; printf("\r\nPlease enter a number to choose one of the following test options:"
                     499   ; "\r\n1 - Bytes"
                     500   ; "\r\n2 - Words"
                     501   ; "\r\n3 - Long Words\r\n");
                     502   ; scanf("%d", &test_option);
                     503   ; if((test_option != 1 && test_option != 2 && test_option != 3) || test_option == 0){
                     504   ; printf("\r\nInvalid Selection\r\n");
                     505   ; test_option = 0;
                     506   ; }
                     507   ; }
                     508   ; //assigning bit_num based on test_option
                     509   ; switch(test_option){
                     510   ; case 1:
                     511   ; printf("\r\nYou have selected test option BYTES\r\n");
                     512   ; bit_num = 8;
                     513   ; break;
                     514   ; case 2:
                     515   ; printf("\r\nYou have selected test option WORDS\r\n");
                     516   ; bit_num = 16;
                     517   ; break;
                     518   ; case 3:
                     519   ; printf("\r\nYou have selected test option LONG WORDS\r\n");
                     520   ; bit_num = 32;
                     521   ; break;
                     522   ; default:
                     523   ; printf("\r\nException - invalid test option\r\n");
                     524   ; break;
                     525   ; }
                     526   ; //prompting user to enter test pattern
                     527   ; while(!select_pattern){
                     528   ; printf("\r\nPlease enter a number to choose one of the following test patterns:"
                     529   ; "\r\n1 - 55"
                     530   ; "\r\n2 - AA"
                     531   ; "\r\n3 - FF"
                     532   ; "\r\n4 - 00\r\n");
                     533   ; scanf("%d", &select_pattern);
                     534   ; if((select_pattern != 1 && select_pattern != 2 && select_pattern != 3 && select_pattern != 4) || select_pattern == 0){
                     535   ; printf("\r\nInvalid Selection\r\n");
                     536   ; select_pattern = 0;
                     537   ; }
                     538   ; }
                     539   ; //assigning write_data based on test_pattern
                     540   ; switch(select_pattern){
                     541   ; case 1:
                     542   ; printf("\r\nYou have selected test pattern 55\r\n");
                     543   ; test_pattern = 0x55;
                     544   ; break;
                     545   ; case 2:
                     546   ; printf("\r\nYou have selected test pattern AA\r\n");
                     547   ; test_pattern = 0xAA;
                     548   ; break;
                     549   ; case 3:
                     550   ; printf("\r\nYou have selected test pattern FF\r\n");
                     551   ; test_pattern = 0xFF;
                     552   ; break;
                     553   ; case 4:
                     554   ; printf("\r\nYou have selected test pattern 00\r\n");
                     555   ; test_pattern = 0x00;
                     556   ; default:
                     557   ; printf("\r\nException - invalid test pattern\r\n");
                     558   ; break;
                     559   ; }
                     560   ; //create appropriate data set based on select_pattern and test_option
                     561   ; // ie, if select_pattern is AA and test_option is BYTES, write_data must be AAAA
                     562   ; switch(test_option){
                     563   ; case 1:
                     564   ; write_data = test_pattern;
                     565   ; break;
                     566   ; case 2:
                     567   ; write_data = test_pattern | test_pattern << 8;
                     568   ; break;
                     569   ; case 3:
                     570   ; write_data = test_pattern | test_pattern << 8 | test_pattern << 16 | test_pattern << 24;
                     571   ; break;
                     572   ; default:
                     573   ; printf("\r\nException - could not generate write_data\r\n");
                     574   ; break;
                     575   ; }
                     576   ; //prompting user to enter start address
                     577   ; while(!start_addr){
                     578   ; printf("\r\nPlease enter a starting address from 08020000 to 08030000\r\n");
                     579   ; scanf("%d", &start_addr);
                     580   ; if(start_addr<0x08020000 || start_addr>0x08030000){
                     581   ; printf("\r\nStart address is invalid\r\n");
                     582   ; start_addr = 0;
                     583   ; } else if(bit_num>8 && start_addr % 2 != 0){
                     584   ; printf("\r\nFor words or long words, please enter an even numbered address\r\n");
                     585   ; end_addr = 0;
                     586   ; } else{
                     587   ; printf("\r\nThe chosen starting address is: %x", start_addr);
                     588   ; }
                     589   ; }
                     590   ; //prompting user to enter end address
                     591   ; while(!end_addr){
                     592   ; printf("\r\nPlease enter an end address from %x to 08030000\r\n", start_addr);
                     593   ; scanf("%d", &end_addr);
                     594   ; if(end_addr<start_addr || end_addr>0x08030000){
                     595   ; printf("\r\nEnd address is invalid\r\n");
                     596   ; end_addr = 0;
                     597   ; } else if(bit_num>8 && end_addr % 2 != 0){
                     598   ; printf("\r\nFor words or long words, please enter an even numbered address\r\n");
                     599   ; end_addr = 0;
                     600   ; } else{
                     601   ; printf("\r\nThe chosen ending address is: %x", end_addr);
                     602   ; }
                     603   ; }
                     604   ; //set address pointer to start pointer
                     605   ; addr_point = start_addr;
                     606   ; //writing data
                     607   ; while(addr_point<end_addr){
                     608   ; *addr_point = write_data;
                     609   ; counter++;
                     610   ; if(counter >= 10000){
                     611   ; printf("\r\nWriting %x into address %x\r\n", *addr_point, addr_point);
                     612   ; counter = 1;
                     613   ; }
                     614   ; //need to increment address pointer according to test option chosen (bytes, words, long words)
                     615   ; if(test_option == 1){
                     616   ; addr_point = addr_point+1;
                     617   ; } else if(test_option == 2){
                     618   ; addr_point = addr_point+2;
                     619   ; }else if(test_option == 3){
                     620   ; addr_point = addr_point+4;
                     621   ; }
                     622   ; }
                     623   ; printf("\r\nWriting completed. Will now start reading.\r\n");
                     624   ; addr_point = start_addr;
                     625   ; counter = 10000;
                     626   ; //reading data
                     627   ; while(addr_point<end_addr){
                     628   ; if(*addr_point != write_data){
                     629   ; printf("\r\nAn Error has occurred: data at address %x expected to be %x, instead is reading %x", addr_point, write_data, *addr_point);
                     630   ; printf("\r\nMemory test failed.\r\n");
                     631   ; break;
                     632   ; }
                     633   ; counter++;
                     634   ; if(counter >= 10000){
                     635   ; printf("\r\nReading data value %x from address %x\r\n", *addr_point, addr_point);
                     636   ; counter = 1;
                     637   ; }
                     638   ; //need to increment address pointer according to test option chosen (bytes, words, long words)
                     639   ; if(test_option == 1){
                     640   ; addr_point = addr_point+1;
                     641   ; } else if(test_option == 2){
                     642   ; addr_point = addr_point+2;
                     643   ; }else if(test_option == 3){
                     644   ; addr_point = addr_point+4;
                     645   ; }
                     646   ; }
                     647   ; */
                     648   ; }
                     649          section   const
                     650   
                     651          section   data
00000962             652                   align
          0000 0962  653   DataStart       equ       *
                     654   
                     655   *********************************************************************************************************
                     656   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                     657   * to ram as part of the CStart routine in this file
                     658   *********************************************************************************************************
                     659   
                     660          section   bss
00000962             661                   align
          0000 0962  662   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                     663   
                     664   *********************************************************************************************************
                     665   * Section for Uninitialised Data held in ROM as constants
                     666   *********************************************************************************************************
                     667   
08030000             668                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0000  669   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                     670   
                     671   
08030000             672   bss             org       bss
                     673   
                     674   *********************************************************************************************************
                     675   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                     676   * install the exception handler using the C function InstallExceptionHandler()
                     677   *********************************************************************************************************
                     678   
                     679   
                     680   
08030000             681   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08030004             682   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08030008             683   VBusError        ds.l    1      storage for address of Bus Error Handler
0803000C             684   VAddressError    ds.l    1      storage for address of Address Error Handler
08030010             685   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08030014             686   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08030018             687   VCheck           ds.l    1      ditto
0803001C             688   VTrapV           ds.l    1      ditto
08030020             689   VPrivilege       ds.l    1      ditto
08030024             690   VTrace           ds.l    1
08030028             691   VLine1010emul    ds.l    1
0803002C             692   VLine1111emul    ds.l    1
08030030             693   VUnassigned1     ds.l    1
08030034             694   VUnassigned2     ds.l    1
08030038             695   VUnassigned3     ds.l    1
0803003C             696   VUninit_IRQ      ds.l    1
08030040             697   VUnassigned4     ds.l    1
08030044             698   VUnassigned5     ds.l    1
08030048             699   VUnassigned6     ds.l    1
0803004C             700   VUnassigned7     ds.l    1
08030050             701   VUnassigned8     ds.l    1
08030054             702   VUnassigned9     ds.l    1
08030058             703   VUnassigned10    ds.l    1
0803005C             704   VUnassigned11    ds.l    1
08030060             705   VSpuriousIRQ     ds.l    1
                     706   
                     707   * Interrupt handlers Vector 25-31
08030064             708   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030068             709   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0803006C             710   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030070             711   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030074             712   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030078             713   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0803007C             714   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                     715   
                     716   * Trap Handler vectors 32-47
08030080             717   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030084             718   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030088             719   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0803008C             720   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030090             721   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030094             722   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030098             723   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0803009C             724   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A0             725   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A4             726   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A8             727   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300AC             728   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B0             729   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B4             730   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B8             731   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300BC             732   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                     733   
                     734   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                     735   
                     736   ***********************************************************************************************************
                     737   * Other Variables
                     738   ***********************************************************************************************************
                     739   *__DebugA5       ds.l    1
                     740   *__UserA5        ds.l    1
                     741   
                     742   ***********************************************************************************************************
080300C0             743   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
080300C4             744   __allocp:       ds.l    0       ; start of allocation units
080300C4             745   __heap:         ds.l    0       ; pointers for malloc functions
                     746   
                     747   *__himem:       ds.l    himem            ; highest memory location + 1
                     748   *__stklen:      ds.l    stklen           ; default stack size
                     749   
                     750   *********************************************************************************************************
                     751   * Section for Heap
                     752   *********************************************************************************************************
                     753   
                     754          section   heap
080300C4             755                   align
          0803 00C4  756   bssEnd          equ *                   end of storage space for unitialised variables
                     757   *                                       we have to copy all initialised variable from rom to here at startup
          0803 00C4  758   heap   equ       *
080300C4             759                    align
          0000 0000

Assembly errors: 96
